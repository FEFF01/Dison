(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[50],{

/***/ "../../js/character.ts":
/*!********************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/character.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//import { Token } from './interfaces'\nvar IdentifierStart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a]|[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\nvar IdentifierPart = /[\\x24\\x5f\\x41-\\x5a\\x61-\\x7a\\x30-\\x39]|[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n    }\n    default_1.prototype.testCodePoint = function (regexp) {\n        if ((this.input.charCodeAt(this.index) & 0xfc00) === 0xd800\n            && (this.input.charCodeAt(this.index + 1) & 0xfc00) === 0xdc00) {\n            this._volatility = this.input[this.index] + this.input[this.index + 1];\n            return regexp.test(this._volatility) ? 2 : 0;\n        }\n        else {\n            return regexp.test(this.input[this.index]) ? 1 : 0;\n        }\n    };\n    default_1.prototype.testUnicodeEscape = function (regexp) {\n        var index = this.index + 1, code = 0;\n        if (this.input[index++] === \"u\") {\n            var cp = 0;\n            if (this.input[index] === \"{\") {\n                while ((code = this.hexValue(this.input.charCodeAt(++index))) >= 0) {\n                    cp = cp * 16 + code;\n                }\n                if (this.input[index++] !== \"}\") { /* || index < this.index + 5*/\n                    return 0;\n                }\n            }\n            else {\n                var len = 4;\n                while (len--) {\n                    code = this.hexValue(this.input.charCodeAt(index++));\n                    if (code >= 0) {\n                        cp = cp * 16 + code;\n                    }\n                    else {\n                        return 0;\n                    }\n                }\n            }\n            return regexp.test(this.fromCodePoint(cp))\n                ? index - this.index\n                : -(index - this.index);\n        }\n        return 0;\n    };\n    default_1.prototype.scanHex = function (length) {\n        if (length === void 0) { length = this.end; }\n        var value = 0, code = 0, len = length;\n        while (len) {\n            code = this.hexValue(this.input.charCodeAt(this.index));\n            if (code >= 0) {\n                len--;\n                value = value * 16 + code;\n            }\n            else {\n                break;\n            }\n            this.index++;\n        }\n        return [value, length - len];\n    };\n    default_1.prototype.hexValue = function (ch) {\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 :\n            ch >= 0x41 && ch <= 0x46 ? ch - 0x41 + 10 :\n                ch >= 0x61 && ch <= 0x66 ? ch - 0x61 + 10 : -1;\n    };\n    default_1.prototype.decimalValue = function (ch) {\n        return ch >= 0x30 && ch <= 0x39 ? ch - 0x30 : -1;\n    };\n    default_1.prototype.octalValue = function (ch) {\n        return ch >= 0x30 && ch <= 0x37 ? ch - 0x30 : -1;\n    };\n    default_1.prototype.binaryValue = function (ch) {\n        return ch === 0x30 || ch == 0x31 ? ch - 0x30 : -1;\n    };\n    //https://github.com/jquery/esprima/blob/master/src/character.ts\n    default_1.prototype.isWhiteSpace = function (ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n        /*return /^\\x20|\\x09|\\x0B|\\x0C|\\xA0|\\xfeff$/.test(char);*/\n    };\n    default_1.prototype.isLineTerminator = function (ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n        /*return /^\\x0A|\\x0D|\\x2028|\\x2029$/.test(char);*/\n    };\n    default_1.prototype.fromCodePoint = function (cp) {\n        return this._volatility = cp < 0x10000\n            ? String.fromCharCode(cp)\n            : String.fromCharCode(0xd800 + (cp - 0x10000) >> 10)\n                + String.fromCharCode(0xdc00 + (cp - 0x10000) & 1023);\n    };\n    default_1.prototype.inIdentifierStart = function () {\n        var ch = this.input.charCodeAt(this.index);\n        return (ch === 0x24) || (ch === 0x5F) ||\n            (ch >= 0x41 && ch <= 0x5A) ||\n            (ch >= 0x61 && ch <= 0x7A) ? 1 : (ch >= 0x80\n            ? this.testCodePoint(IdentifierStart)\n            : (ch === 0x5c ? this.testUnicodeEscape(IdentifierStart) : 0));\n        /*return /^[_$a-zA-Z\\u0080-\\uffffff]$/.test(char);*/\n    };\n    default_1.prototype.inIdentifierPart = function () {\n        var ch = this.input.charCodeAt(this.index);\n        return (ch === 0x24) || (ch === 0x5F) ||\n            (ch >= 0x41 && ch <= 0x5A) ||\n            (ch >= 0x61 && ch <= 0x7A) ||\n            (ch >= 0x30 && ch <= 0x39) ? 1 : (ch >= 0x80\n            ? this.testCodePoint(IdentifierPart)\n            : (ch === 0x5c ? this.testUnicodeEscape(IdentifierPart) : 0));\n        /*return /^[\\w$\\u0080-\\uffffff]$/.test(char);*/\n    };\n    return default_1;\n}());\nexports.default = default_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvY2hhcmFjdGVyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9tbnQvZC9Qcm9ncmFtRmlsZXMvR2l0SHViL0Rpc29uL2pzL2NoYXJhY3Rlci50cz9lYmFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0IHsgVG9rZW4gfSBmcm9tICcuL2ludGVyZmFjZXMnXHJcbmNvbnN0IElkZW50aWZpZXJTdGFydCA9IC9bXFx4MjRcXHg1ZlxceDQxLVxceDVhXFx4NjEtXFx4N2FdfFtcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVEMC1cXHUwNUVBXFx1MDVFRi1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MDlGQ1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRlxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFRlxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0M2XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2N1xcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMkQtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdUREMDAtXFx1REQyM1xcdURGMDAtXFx1REYxQ1xcdURGMjdcXHVERjMwLVxcdURGNDVcXHVERkUwLVxcdURGRjZdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ0NFxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1RlxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERUI4XFx1REYwMC1cXHVERjFBXXxcXHVEODA2W1xcdURDMDAtXFx1REMyQlxcdURDQTAtXFx1RENERlxcdURDRkZcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdURFRTAtXFx1REVGMl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OV1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU3RlxcdURGMDAtXFx1REY0QVxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMVxcdURGRTNdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkY3XXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDUwLVxcdURENTJcXHVERDY0LVxcdURENjdcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4MzhbXFx1REQwMC1cXHVERDJDXFx1REQzNy1cXHVERDNEXFx1REQ0RVxcdURFQzAtXFx1REVFQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNcXHVERDRCXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLztcclxuY29uc3QgSWRlbnRpZmllclBhcnQgPSAvW1xceDI0XFx4NWZcXHg0MS1cXHg1YVxceDYxLVxceDdhXFx4MzAtXFx4MzldfFtcXHhBQVxceEI1XFx4QjdcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RUYtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDdGRFxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MDlGQ1xcdTA5RkVcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOS1cXHUwQUZGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAwLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4Ni1cXHUwRThBXFx1MEU4Qy1cXHUwRUEzXFx1MEVBNVxcdTBFQTctXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGQVxcdTFEMDAtXFx1MURGOVxcdTFERkItXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkZcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRUZcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QkZcXHVBN0MyLVxcdUE3QzZcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY3XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdUREMzlcXHVERjAwLVxcdURGMUNcXHVERjI3XFx1REYzMC1cXHVERjUwXFx1REZFMC1cXHVERkY2XXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENDQtXFx1REQ0NlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVEREM5LVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REUzRVxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQi1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzAwLVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzVFXFx1REM1RlxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI4XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjFBXFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDMDAtXFx1REMzQVxcdURDQTAtXFx1RENFOVxcdURDRkZcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDdcXHVERERBLVxcdURERTFcXHVEREUzXFx1RERFNFxcdURFMDAtXFx1REUzRVxcdURFNDdcXHVERTUwLVxcdURFOTlcXHVERTlEXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ3XFx1REQ1MC1cXHVERDU5XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREOEVcXHVERDkwXFx1REQ5MVxcdUREOTMtXFx1REQ5OFxcdUREQTAtXFx1RERBOVxcdURFRTAtXFx1REVGNl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OV1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU3RlxcdURGMDAtXFx1REY0QVxcdURGNEYtXFx1REY4N1xcdURGOEYtXFx1REY5RlxcdURGRTBcXHVERkUxXFx1REZFM118XFx1RDgyMVtcXHVEQzAwLVxcdURGRjddfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENTAtXFx1REQ1MlxcdURENjQtXFx1REQ2N1xcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMDAtXFx1REQyQ1xcdUREMzAtXFx1REQzRFxcdURENDAtXFx1REQ0OVxcdURENEVcXHVERUMwLVxcdURFRjldfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XFx1REQwMC1cXHVERDRCXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS87XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyB7XHJcbiAgICBwdWJsaWMgaW5wdXQ6IHN0cmluZztcclxuICAgIHB1YmxpYyBpbmRleDogbnVtYmVyO1xyXG4gICAgcHVibGljIGVuZDogbnVtYmVyO1xyXG4gICAgcHVibGljIF92b2xhdGlsaXR5OiBhbnk7XHJcbiAgICBwdWJsaWMgX3Njb3BlczogYW55O1xyXG4gICAgcHJpdmF0ZSB0ZXN0Q29kZVBvaW50KHJlZ2V4cDogUmVnRXhwKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICYgMHhmYzAwKSA9PT0gMHhkODAwXHJcbiAgICAgICAgICAgICYmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZvbGF0aWxpdHkgPSB0aGlzLmlucHV0W3RoaXMuaW5kZXhdICsgdGhpcy5pbnB1dFt0aGlzLmluZGV4ICsgMV07XHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHAudGVzdCh0aGlzLl92b2xhdGlsaXR5KSA/IDIgOiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHAudGVzdCh0aGlzLmlucHV0W3RoaXMuaW5kZXhdKSA/IDEgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRlc3RVbmljb2RlRXNjYXBlKHJlZ2V4cDogUmVnRXhwKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCArIDEsIGNvZGUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0W2luZGV4KytdID09PSBcInVcIikge1xyXG4gICAgICAgICAgICBsZXQgY3AgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dFtpbmRleF0gPT09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPSB0aGlzLmhleFZhbHVlKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK2luZGV4KSkpID49IDBcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNwID0gY3AgKiAxNiArIGNvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dFtpbmRleCsrXSAhPT0gXCJ9XCIpIHsvKiB8fCBpbmRleCA8IHRoaXMuaW5kZXggKyA1Ki9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZW4gPSA0O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxlbi0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IHRoaXMuaGV4VmFsdWUodGhpcy5pbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwID0gY3AgKiAxNiArIGNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWdleHAudGVzdCh0aGlzLmZyb21Db2RlUG9pbnQoY3ApKVxyXG4gICAgICAgICAgICAgICAgPyBpbmRleCAtIHRoaXMuaW5kZXhcclxuICAgICAgICAgICAgICAgIDogLShpbmRleCAtIHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHNjYW5IZXgobGVuZ3RoOiBudW1iZXIgPSB0aGlzLmVuZCk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IDAsIGNvZGUgPSAwLCBsZW4gPSBsZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGxlbikge1xyXG4gICAgICAgICAgICBjb2RlID0gdGhpcy5oZXhWYWx1ZSh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCkpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZW4tLTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNvZGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbdmFsdWUsIGxlbmd0aCAtIGxlbl07XHJcbiAgICB9XHJcbiAgICBoZXhWYWx1ZShjaDogbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSA/IGNoIC0gMHgzMCA6XHJcbiAgICAgICAgICAgIGNoID49IDB4NDEgJiYgY2ggPD0gMHg0NiA/IGNoIC0gMHg0MSArIDEwIDpcclxuICAgICAgICAgICAgICAgIGNoID49IDB4NjEgJiYgY2ggPD0gMHg2NiA/IGNoIC0gMHg2MSArIDEwIDogLTE7XHJcbiAgICB9XHJcbiAgICBkZWNpbWFsVmFsdWUoY2g6IG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgPyBjaCAtIDB4MzAgOiAtMTtcclxuICAgIH1cclxuICAgIG9jdGFsVmFsdWUoY2g6IG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzcgPyBjaCAtIDB4MzAgOiAtMTtcclxuICAgIH1cclxuICAgIGJpbmFyeVZhbHVlKGNoOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gY2ggPT09IDB4MzAgfHwgY2ggPT0gMHgzMSA/IGNoIC0gMHgzMCA6IC0xO1xyXG4gICAgfVxyXG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2VzcHJpbWEvYmxvYi9tYXN0ZXIvc3JjL2NoYXJhY3Rlci50c1xyXG4gICAgaXNXaGl0ZVNwYWNlKGNoOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XHJcbiAgICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XHJcbiAgICAgICAgLypyZXR1cm4gL15cXHgyMHxcXHgwOXxcXHgwQnxcXHgwQ3xcXHhBMHxcXHhmZWZmJC8udGVzdChjaGFyKTsqL1xyXG4gICAgfVxyXG4gICAgaXNMaW5lVGVybWluYXRvcihjaDogbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xyXG4gICAgICAgIC8qcmV0dXJuIC9eXFx4MEF8XFx4MER8XFx4MjAyOHxcXHgyMDI5JC8udGVzdChjaGFyKTsqL1xyXG4gICAgfVxyXG4gICAgZnJvbUNvZGVQb2ludChjcDogbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbGF0aWxpdHkgPSBjcCA8IDB4MTAwMDBcclxuICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNwKVxyXG4gICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKGNwIC0gMHgxMDAwMCkgPj4gMTApXHJcbiAgICAgICAgICAgICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAoY3AgLSAweDEwMDAwKSAmIDEwMjMpO1xyXG4gICAgfVxyXG4gICAgaW5JZGVudGlmaWVyU3RhcnQoKSB7XHJcbiAgICAgICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHxcclxuICAgICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHxcclxuICAgICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgPyAxIDogKFxyXG4gICAgICAgICAgICAgICAgY2ggPj0gMHg4MFxyXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy50ZXN0Q29kZVBvaW50KElkZW50aWZpZXJTdGFydClcclxuICAgICAgICAgICAgICAgICAgICA6IChjaCA9PT0gMHg1YyA/IHRoaXMudGVzdFVuaWNvZGVFc2NhcGUoSWRlbnRpZmllclN0YXJ0KSA6IDApXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgLypyZXR1cm4gL15bXyRhLXpBLVpcXHUwMDgwLVxcdWZmZmZmZl0kLy50ZXN0KGNoYXIpOyovXHJcbiAgICB9XHJcbiAgICBpbklkZW50aWZpZXJQYXJ0KCkge1xyXG4gICAgICAgIGxldCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcclxuICAgICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8XHJcbiAgICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8XHJcbiAgICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8XHJcbiAgICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpID8gMSA6IChcclxuICAgICAgICAgICAgICAgIGNoID49IDB4ODBcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMudGVzdENvZGVQb2ludChJZGVudGlmaWVyUGFydClcclxuICAgICAgICAgICAgICAgICAgICA6IChjaCA9PT0gMHg1YyA/IHRoaXMudGVzdFVuaWNvZGVFc2NhcGUoSWRlbnRpZmllclBhcnQpIDogMClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAvKnJldHVybiAvXltcXHckXFx1MDA4MC1cXHVmZmZmZmZdJC8udGVzdChjaGFyKTsqL1xyXG4gICAgfVxyXG4gICAgLyppc0ZvbGxvd2luZ0FuRXhwcmVzc2lvbih0b2tlbj86IFRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuID8gW1xyXG4gICAgICAgICAgICAnaW4nLCAndHlwZW9mJywgJ2luc3RhbmNlb2YnLCAnbmV3JyxcclxuICAgICAgICAgICAgJ3JldHVybicsICdjYXNlJywgJ2RlbGV0ZScsICd0aHJvdycsICd2b2lkJyxcclxuICAgICAgICAgICAgLy8gYXNzaWdubWVudCBvcGVyYXRvcnNcclxuICAgICAgICAgICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnKio9JywgJy89JywgJyU9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsXHJcbiAgICAgICAgICAgICcmPScsICd8PScsICdePScsICcsJyxcclxuICAgICAgICAgICAgLy8gYmluYXJ5L3VuYXJ5IG9wZXJhdG9yc1xyXG4gICAgICAgICAgICAnKycsICctJywgJyonLCAnKionLCAnLycsICclJywgJysrJywgJy0tJywgJzw8JywgJz4+JywgJz4+PicsICcmJyxcclxuICAgICAgICAgICAgJ3wnLCAnXicsICchJywgJ34nLCAnJiYnLCAnfHwnLCAnPycsICc6JywgJz09PScsICc9PScsICc+PScsXHJcbiAgICAgICAgICAgICc8PScsICc8JywgJz4nLCAnIT0nLCAnIT09J1xyXG4gICAgICAgIF0uaW5kZXhPZih0b2tlbi52YWx1ZSkgPj0gMCA6IGZhbHNlO1xyXG4gICAgfSovXHJcbn0iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQStIQTtBQXpIQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFjQTtBQUFBOzsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../js/character.ts\n");

/***/ }),

/***/ "../../js/index.ts":
/*!****************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/index.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = exports.Tokenizer = void 0;\nvar head_1 = __webpack_require__(/*! ./lexical/head */ \"../../js/lexical/head.ts\");\nvar index_1 = __webpack_require__(/*! ./lexical/index */ \"../../js/lexical/index.ts\");\nvar parser_1 = __webpack_require__(/*! ./parser */ \"../../js/parser.ts\");\nvar tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"../../js/tokenizer.ts\");\nvar head_2 = __webpack_require__(/*! ./syntax/head */ \"../../js/syntax/head.ts\");\nvar expression_1 = __webpack_require__(/*! ./syntax/expression */ \"../../js/syntax/expression.ts\");\nvar declaration_1 = __webpack_require__(/*! ./syntax/declaration */ \"../../js/syntax/declaration.ts\");\nvar statement_1 = __webpack_require__(/*! ./syntax/statement */ \"../../js/syntax/statement.ts\");\nvar module_declaration_1 = __webpack_require__(/*! ./syntax/module_declaration */ \"../../js/syntax/module_declaration.ts\");\nhead_2.async_getter.open();\nvar EXPRESSION_TREE = head_2.async_getter.EXPRESSION_TREE;\nvar SYNTAX_TREE = head_2.createMatchTree([\n    declaration_1.default,\n    module_declaration_1.default,\n    statement_1.default\n], EXPRESSION_TREE);\nvar EXPRESSION_ITEM_PATTERN = {};\nvar DECLARATION_ITEM_PATTERN = {};\nvar STATEMENT_ITEM_PATTERN = {};\nvar STATEMENT_LIST_ITEM_PATTERN = {};\nvar MODULE_ITEM_PATTERN = {};\nfor (var _i = 0, _a = [\n    [\n        expression_1.default,\n        [EXPRESSION_ITEM_PATTERN]\n    ],\n    [\n        declaration_1.default,\n        [DECLARATION_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\n    ],\n    [\n        statement_1.default,\n        [STATEMENT_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\n    ],\n    [\n        module_declaration_1.default,\n        [MODULE_ITEM_PATTERN, STATEMENT_LIST_ITEM_PATTERN]\n    ],\n]; _i < _a.length; _i++) {\n    var _b = _a[_i], descriptor = _b[0], patterns = _b[1];\n    for (var key in descriptor) {\n        if (key) {\n            for (var _c = 0, patterns_1 = patterns; _c < patterns_1.length; _c++) {\n                var pattern = patterns_1[_c];\n                pattern[key] = true;\n            }\n        }\n    }\n}\nfunction isExpression(node) {\n    return EXPRESSION_ITEM_PATTERN[node.type];\n}\nfunction isDeclaration(node) {\n    return DECLARATION_ITEM_PATTERN[node.type];\n}\nfunction isStatement(node) {\n    return STATEMENT_ITEM_PATTERN[node.type];\n}\nfunction isStatementListItem(node) {\n    return STATEMENT_LIST_ITEM_PATTERN[node.type];\n}\nfunction isModuleItem(node) {\n    return MODULE_ITEM_PATTERN[node.type];\n}\nvar TOKEN_TYPE_MAPPERS = index_1.TOKEN_TYPE_SET.reduce(function (map, _a) {\n    var type = _a[0], id_set = _a[1];\n    for (var _i = 0, id_set_1 = id_set; _i < id_set_1.length; _i++) {\n        var id = id_set_1[_i];\n        map[\" \" + id] = type;\n    }\n    return map;\n}, {});\nvar PUNCTUATORS_TREE = head_1.createSearchTree(index_1.PUNCTUATORS);\nvar PRIMARY_EXPR_START_PUNCTUATORS_TREE = head_1.createSearchTree([index_1.REGEXP_DESCRIPTOR], head_1.createSearchTree(index_1.PUNCTUATORS, undefined, [\"/=\"]));\nvar Tokenizer = /** @class */ (function (_super) {\n    __extends(Tokenizer, _super);\n    function Tokenizer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.TYPE_ENUMS = index_1.TYPE_ENUMS;\n        _this.PRIMARY_EXPR_START_PUNCTUATORS_TREE = PRIMARY_EXPR_START_PUNCTUATORS_TREE;\n        _this.PUNCTUATORS_TREE = PUNCTUATORS_TREE;\n        return _this;\n    }\n    return Tokenizer;\n}(tokenizer_1.default));\nexports.Tokenizer = Tokenizer;\nvar Dison = /** @class */ (function (_super) {\n    __extends(Dison, _super);\n    function Dison() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.token_hooks = head_2.token_hooks;\n        _this.TYPE_ENUMS = index_1.TYPE_ENUMS;\n        _this.PRIMARY_EXPR_START_PUNCTUATORS_TREE = PRIMARY_EXPR_START_PUNCTUATORS_TREE;\n        _this.PUNCTUATORS_TREE = PUNCTUATORS_TREE;\n        _this.TOKEN_TYPE_MAPPERS = TOKEN_TYPE_MAPPERS;\n        _this.SYNTAX_TREE = SYNTAX_TREE;\n        _this.EXPRESSION_TREE = EXPRESSION_TREE;\n        _this.isExpression = isExpression;\n        _this.isStatement = isStatement;\n        _this.isStatementListItem = isStatementListItem;\n        _this.isDeclaration = isDeclaration;\n        _this.isModuleItem = isModuleItem;\n        return _this;\n    }\n    return Dison;\n}(parser_1.default));\nexports.Parser = Dison;\nexports.default = Dison;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvaW5kZXgudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL21udC9kL1Byb2dyYW1GaWxlcy9HaXRIdWIvRGlzb24vanMvaW5kZXgudHM/MDI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmltcG9ydCB7XHJcbiAgICBUb2tlbiwgTm9kZSwgQ29udGV4dCwgQ09OVEVYVCwgTWF0Y2hUcmVlXHJcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcclxuXHJcbmltcG9ydCB7IGNyZWF0ZVNlYXJjaFRyZWUgfSBmcm9tICcuL2xleGljYWwvaGVhZCdcclxuXHJcbmltcG9ydCB7XHJcbiAgICBUWVBFX0VOVU1TLFxyXG4gICAgUFVOQ1RVQVRPUlMsXHJcbiAgICBUT0tFTl9UWVBFX1NFVCxcclxuICAgIFJFR0VYUF9ERVNDUklQVE9SXHJcbn0gZnJvbSBcIi4vbGV4aWNhbC9pbmRleFwiO1xyXG5cclxuaW1wb3J0IFBhcnNlciBmcm9tICcuL3BhcnNlcic7XHJcbmltcG9ydCBUb2tlbml6ZXJPcmlnaW4gZnJvbSAnLi90b2tlbml6ZXInO1xyXG5cclxuaW1wb3J0IHsgYXN5bmNfZ2V0dGVyLCB0b2tlbl9ob29rcywgY3JlYXRlTWF0Y2hUcmVlIH0gZnJvbSAnLi9zeW50YXgvaGVhZCdcclxuXHJcbmltcG9ydCBFeHByZXNzaW9ucyBmcm9tICcuL3N5bnRheC9leHByZXNzaW9uJ1xyXG5pbXBvcnQgRGVjbGFyYXRpb25zIGZyb20gJy4vc3ludGF4L2RlY2xhcmF0aW9uJ1xyXG5pbXBvcnQgU3RhdGVtZW50cyBmcm9tICcuL3N5bnRheC9zdGF0ZW1lbnQnXHJcbmltcG9ydCBNb2R1bGVEZWNsYXJhdGlvbnMgZnJvbSAnLi9zeW50YXgvbW9kdWxlX2RlY2xhcmF0aW9uJ1xyXG5cclxuXHJcbmFzeW5jX2dldHRlci5vcGVuKCk7XHJcbmxldCBFWFBSRVNTSU9OX1RSRUU6IE1hdGNoVHJlZSA9IGFzeW5jX2dldHRlci5FWFBSRVNTSU9OX1RSRUU7XHJcblxyXG5jb25zdCBTWU5UQVhfVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShbXHJcbiAgICBEZWNsYXJhdGlvbnMsXHJcbiAgICBNb2R1bGVEZWNsYXJhdGlvbnMsXHJcbiAgICBTdGF0ZW1lbnRzXHJcbl0sIEVYUFJFU1NJT05fVFJFRSk7XHJcblxyXG5cclxubGV0IEVYUFJFU1NJT05fSVRFTV9QQVRURVJOID0ge307XHJcbmxldCBERUNMQVJBVElPTl9JVEVNX1BBVFRFUk4gPSB7fTtcclxubGV0IFNUQVRFTUVOVF9JVEVNX1BBVFRFUk4gPSB7fTtcclxubGV0IFNUQVRFTUVOVF9MSVNUX0lURU1fUEFUVEVSTiA9IHt9O1xyXG5sZXQgTU9EVUxFX0lURU1fUEFUVEVSTiA9IHt9O1xyXG5mb3IgKFxyXG4gICAgY29uc3QgW2Rlc2NyaXB0b3IsIHBhdHRlcm5zXVxyXG4gICAgb2ZcclxuICAgIFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIEV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICBbRVhQUkVTU0lPTl9JVEVNX1BBVFRFUk5dXHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIERlY2xhcmF0aW9ucyxcclxuICAgICAgICAgICAgW0RFQ0xBUkFUSU9OX0lURU1fUEFUVEVSTiwgU1RBVEVNRU5UX0xJU1RfSVRFTV9QQVRURVJOXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBTdGF0ZW1lbnRzLFxyXG4gICAgICAgICAgICBbU1RBVEVNRU5UX0lURU1fUEFUVEVSTiwgU1RBVEVNRU5UX0xJU1RfSVRFTV9QQVRURVJOXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICBNb2R1bGVEZWNsYXJhdGlvbnMsXHJcbiAgICAgICAgICAgIFtNT0RVTEVfSVRFTV9QQVRURVJOLCBTVEFURU1FTlRfTElTVF9JVEVNX1BBVFRFUk5dXHJcbiAgICAgICAgXSxcclxuICAgIF0gYXMgQXJyYXk8W1JlY29yZDxzdHJpbmcsIGFueT4sIEFycmF5PFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+Pl0+XHJcbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0V4cHJlc3Npb24obm9kZTogTm9kZSkge1xyXG4gICAgcmV0dXJuIEVYUFJFU1NJT05fSVRFTV9QQVRURVJOW25vZGUudHlwZV07XHJcbn1cclxuZnVuY3Rpb24gaXNEZWNsYXJhdGlvbihub2RlOiBOb2RlKSB7XHJcbiAgICByZXR1cm4gREVDTEFSQVRJT05fSVRFTV9QQVRURVJOW25vZGUudHlwZV07XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZTogTm9kZSkge1xyXG4gICAgcmV0dXJuIFNUQVRFTUVOVF9JVEVNX1BBVFRFUk5bbm9kZS50eXBlXTtcclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlbWVudExpc3RJdGVtKG5vZGU6IE5vZGUpIHtcclxuICAgIHJldHVybiBTVEFURU1FTlRfTElTVF9JVEVNX1BBVFRFUk5bbm9kZS50eXBlXTtcclxufVxyXG5mdW5jdGlvbiBpc01vZHVsZUl0ZW0obm9kZTogTm9kZSkge1xyXG4gICAgcmV0dXJuIE1PRFVMRV9JVEVNX1BBVFRFUk5bbm9kZS50eXBlXTtcclxufVxyXG5cclxuXHJcbmNvbnN0IFRPS0VOX1RZUEVfTUFQUEVSUzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPiA9IFRPS0VOX1RZUEVfU0VULnJlZHVjZShcclxuICAgIChtYXAsIFt0eXBlLCBpZF9zZXRdKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaWQgb2YgaWRfc2V0KSB7XHJcbiAgICAgICAgICAgIG1hcFtcIiBcIiArIGlkXSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9LCB7fVxyXG4pO1xyXG5jb25zdCBQVU5DVFVBVE9SU19UUkVFID0gY3JlYXRlU2VhcmNoVHJlZShQVU5DVFVBVE9SUyk7XHJcbmNvbnN0IFBSSU1BUllfRVhQUl9TVEFSVF9QVU5DVFVBVE9SU19UUkVFID0gY3JlYXRlU2VhcmNoVHJlZShcclxuICAgIFtSRUdFWFBfREVTQ1JJUFRPUl0sXHJcbiAgICBjcmVhdGVTZWFyY2hUcmVlKFBVTkNUVUFUT1JTLCB1bmRlZmluZWQsIFtcIi89XCJdKSxcclxuKTtcclxuXHJcblxyXG5cclxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgVG9rZW5pemVyT3JpZ2luIHtcclxuICAgIFRZUEVfRU5VTVMgPSBUWVBFX0VOVU1TO1xyXG4gICAgUFJJTUFSWV9FWFBSX1NUQVJUX1BVTkNUVUFUT1JTX1RSRUUgPSBQUklNQVJZX0VYUFJfU1RBUlRfUFVOQ1RVQVRPUlNfVFJFRTtcclxuICAgIFBVTkNUVUFUT1JTX1RSRUUgPSBQVU5DVFVBVE9SU19UUkVFO1xyXG59XHJcbmNsYXNzIERpc29uIGV4dGVuZHMgUGFyc2VyIHtcclxuICAgIHRva2VuX2hvb2tzID0gdG9rZW5faG9va3M7XHJcbiAgICBUWVBFX0VOVU1TID0gVFlQRV9FTlVNUztcclxuICAgIFBSSU1BUllfRVhQUl9TVEFSVF9QVU5DVFVBVE9SU19UUkVFID0gUFJJTUFSWV9FWFBSX1NUQVJUX1BVTkNUVUFUT1JTX1RSRUU7XHJcbiAgICBQVU5DVFVBVE9SU19UUkVFID0gUFVOQ1RVQVRPUlNfVFJFRTtcclxuICAgIFRPS0VOX1RZUEVfTUFQUEVSUyA9IFRPS0VOX1RZUEVfTUFQUEVSUztcclxuICAgIFNZTlRBWF9UUkVFID0gU1lOVEFYX1RSRUU7XHJcbiAgICBFWFBSRVNTSU9OX1RSRUUgPSBFWFBSRVNTSU9OX1RSRUU7XHJcblxyXG4gICAgaXNFeHByZXNzaW9uID0gaXNFeHByZXNzaW9uO1xyXG4gICAgaXNTdGF0ZW1lbnQgPSBpc1N0YXRlbWVudDtcclxuICAgIGlzU3RhdGVtZW50TGlzdEl0ZW0gPSBpc1N0YXRlbWVudExpc3RJdGVtO1xyXG4gICAgaXNEZWNsYXJhdGlvbiA9IGlzRGVjbGFyYXRpb247XHJcbiAgICBpc01vZHVsZUl0ZW0gPSBpc01vZHVsZUl0ZW07XHJcbn1cclxuZXhwb3J0IHtcclxuICAgIFRva2VuaXplcixcclxuICAgIERpc29uIGFzIFBhcnNlclxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBEaXNvbjtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7QUFFQTtBQU9BO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBaUJBO0FBaEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUdBO0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../js/index.ts\n");

/***/ }),

/***/ "../../js/interfaces.ts":
/*!*********************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/interfaces.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NUMERIC_KEYWORD_MAPPINGS = void 0;\nvar NUMERIC_KEYWORD_MAPPINGS;\n(function (NUMERIC_KEYWORD_MAPPINGS) {\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\".\"] = 36] = \".\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"x\"] = 8] = \"x\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"b\"] = 1] = \"b\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"o\"] = 2] = \"o\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"X\"] = 8] = \"X\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"B\"] = 1] = \"B\";\n    NUMERIC_KEYWORD_MAPPINGS[NUMERIC_KEYWORD_MAPPINGS[\"O\"] = 2] = \"O\";\n})(NUMERIC_KEYWORD_MAPPINGS || (NUMERIC_KEYWORD_MAPPINGS = {}));\nexports.NUMERIC_KEYWORD_MAPPINGS = NUMERIC_KEYWORD_MAPPINGS;\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvaW50ZXJmYWNlcy50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vbW50L2QvUHJvZ3JhbUZpbGVzL0dpdEh1Yi9EaXNvbi9qcy9pbnRlcmZhY2VzLnRzPzUxYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhcnNlciBmcm9tICcuL3BhcnNlcidcclxuXHJcbmludGVyZmFjZSBQb3NpdGlvbiB7XHJcbiAgICBsaW5lOiBudW1iZXIsLy8gPj0wXHJcbiAgICBjb2x1bW46IG51bWJlci8vID49MFxyXG59XHJcbmludGVyZmFjZSBTb3VyY2VMb2NhdGlvbiB7XHJcbiAgICBzdGFydDogUG9zaXRpb24sXHJcbiAgICBlbmQ6IFBvc2l0aW9uXHJcbn1cclxuXHJcbmludGVyZmFjZSBOb2RlIHtcclxuICAgIHR5cGU/OiBzdHJpbmcgfCBudW1iZXIsXHJcbiAgICByYW5nZT86IFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICBsb2M/OiBTb3VyY2VMb2NhdGlvbixcclxuICAgIFtwcm9wTmFtZTogc3RyaW5nXTogYW55XHJcbn1cclxuXHJcbmludGVyZmFjZSBUb2tlbiBleHRlbmRzIE5vZGUge1xyXG4gICAgdmFsdWU/OiBhbnksXHJcbiAgICBjb250ZW50PzogYW55LFxyXG4gICAgcmVnZXg/OiB7IHBhdHRlcm46IHN0cmluZywgZmxhZ3M6IHN0cmluZyB9LFxyXG4gICAgW3Byb3BOYW1lOiBzdHJpbmddOiBhbnlcclxufVxyXG5pbnRlcmZhY2UgRXhwcmVzc2lvbiBleHRlbmRzIE5vZGUge1xyXG4gICAgZWxlbWVudHM/OiBBcnJheTxFeHByZXNzaW9uPixcclxuICAgIGV4cHJlc3Npb25zPzogQXJyYXk8RXhwcmVzc2lvbj5cclxufVxyXG5cclxudHlwZSBQcm9ncmFtID0gRXhwcmVzc2lvbjtcclxudHlwZSBNYXRjaFRyZWUgPSBSZWNvcmQ8XHJcbiAgICBzdHJpbmcsXHJcbiAgICBhbnlcclxuLy8oLi4uYXJnczogYW55KSA9PiBhbnkgfCB7IFtwcm9wTmFtZTogc3RyaW5nXTogTWF0Y2hUcmVlIH1cclxuPjtcclxudHlwZSBTZWFyY2hUcmVlID0gTWF0Y2hUcmVlIHwgUmVjb3JkPFxyXG4gICAgc3RyaW5nLFxyXG4gICAgbnVtYmVyIHwgc3RyaW5nIHwgQXJyYXk8c3RyaW5nPlxyXG4+O1xyXG5cclxuY29uc3QgZW51bSBOVU1FUklDX1RZUEUge1xyXG4gICAgQklOQVJZID0gMGIxIDw8IDAsXHJcbiAgICBPQ1RBTCA9IDBiMSA8PCAxLFxyXG4gICAgREVDSU1BTCA9IDBiMSA8PCAyLFxyXG4gICAgSEVYID0gMGIxIDw8IDMsXHJcbiAgICAvL0lOVEVHRVIgPSAwYjEgPDwgNCxcclxuICAgIEZMT0FUID0gMGIxIDw8IDUsXHJcbiAgICBFID0gMGIxIDw8IDYsXHJcbiAgICBOQU4gPSAwYjEgPDwgNyxcclxufVxyXG5cclxuY29uc3QgZW51bSBDT05URVhUIHtcclxuICAgIGNvbGxlY3RlZCxcclxuICAgIHBhcnNlcixcclxuICAgIGxlZnQsXHJcbiAgICByaWdodCxcclxuICAgIHN0YXJ0LFxyXG4gICAgZW5kLFxyXG4gICAgYmVnaW4sXHJcbiAgICB0b2tlbnMsXHJcbiAgICByaWdodEFzc29jaWF0aXZlTm9kZSxcclxuICAgIG1hdGNoZWQsXHJcbiAgICBiaW5kaW5nU2V0LFxyXG4gICAgbGFiZWxTZXQsXHJcbiAgICBzdHJpY3QsXHJcbiAgICBpc01vZHVsZSxcclxuICAgIGlzRXhwcmVzc2lvbixcclxuICAgIGluRnVuY3Rpb25Cb2R5LFxyXG4gICAgaW5JdGVyYXRpb24sXHJcbiAgICBpblN3aXRjaCxcclxuICAgIGJpbmRpbmdFbGVtZW50LFxyXG4gICAgc3ByZWFkRWxlbWVudCxcclxuICAgIGFsbG93QXdhaXQsXHJcbiAgICBhbGxvd1lpZWxkLFxyXG4gICAgbGVuZ3RoXHJcbn1cclxuaW50ZXJmYWNlIENvbnRleHQgZXh0ZW5kcyBBcnJheTxhbnk+IHtcclxuICAgIFtDT05URVhULmNvbGxlY3RlZF0/OiBSZWNvcmQ8c3RyaW5nLCBOb2RlIHwgc3RyaW5nIHwgYW55IHwgQXJyYXk8Tm9kZSB8IHN0cmluZyB8IGFueT4+LFxyXG4gICAgW0NPTlRFWFQucGFyc2VyXTogUGFyc2VyLFxyXG4gICAgW0NPTlRFWFQubGVmdF0/OiBudW1iZXIsXHJcbiAgICBbQ09OVEVYVC5yaWdodF0/OiBudW1iZXIsXHJcbiAgICBbQ09OVEVYVC5zdGFydF0/OiBudW1iZXIsXHJcbiAgICBbQ09OVEVYVC5lbmRdPzogbnVtYmVyLFxyXG4gICAgW0NPTlRFWFQuYmVnaW5dPzogbnVtYmVyLFxyXG4gICAgW0NPTlRFWFQudG9rZW5zXT86IEFycmF5PE5vZGU+LFxyXG4gICAgW0NPTlRFWFQucmlnaHRBc3NvY2lhdGl2ZU5vZGVdPzogTm9kZSxcclxuICAgIFtDT05URVhULm1hdGNoZWRdPzogTWF0Y2hlZCxcclxuICAgIFtDT05URVhULmJpbmRpbmdTZXRdPzogQXJyYXk8c3RyaW5nPixcclxuICAgIFtDT05URVhULmxhYmVsU2V0XT86IEFycmF5PHN0cmluZz4sXHJcbiAgICBbQ09OVEVYVC5zdHJpY3RdPzogYm9vbGVhbixcclxuICAgIFtDT05URVhULmlzTW9kdWxlXT86IGJvb2xlYW4sXHJcbiAgICBbQ09OVEVYVC5pc0V4cHJlc3Npb25dPzogYm9vbGVhbixcclxuICAgIFtDT05URVhULmluSXRlcmF0aW9uXT86IGJvb2xlYW4sXHJcbiAgICBbQ09OVEVYVC5pbkZ1bmN0aW9uQm9keV0/OiBudW1iZXIsXHJcbiAgICBbQ09OVEVYVC5pblN3aXRjaF0/OiBib29sZWFuLFxyXG4gICAgW0NPTlRFWFQuYmluZGluZ0VsZW1lbnRdPzogYm9vbGVhbixcclxuICAgIFtDT05URVhULnNwcmVhZEVsZW1lbnRdPzogYm9vbGVhbixcclxuXHJcbiAgICBbQ09OVEVYVC5hbGxvd0F3YWl0XT86IGJvb2xlYW4sXHJcbiAgICBbQ09OVEVYVC5hbGxvd1lpZWxkXT86IGJvb2xlYW4sXHJcblxyXG4gICAgdG9rZW5zOiBBcnJheTxUb2tlbj4sXHJcbiAgICBnZXRUb2tlbihpbmRleDogbnVtYmVyKTogVG9rZW4sXHJcbiAgICB3cmFwKGtleTogbnVtYmVyLCB2YWx1ZTogYW55KTogQ29udGV4dCxcclxuICAgIHVud3JhcCgpOiBDb250ZXh0LFxyXG4gICAgc3RvcmUoLi4uYXJnczogQXJyYXk8Q09OVEVYVCB8IGFueT4pOiBudW1iZXIsXHJcbiAgICByZXN0b3JlKHBvaW50OiBudW1iZXIpOiBudW1iZXIsXHJcbn1cclxuLypcclxuY29uc3QgZW51bSBNQVRDSF9TVEFUVVMge1xyXG4gICAgRU5EID0gMSxcclxuICAgIEVSUk9SID0gLTEsXHJcbiAgICBORVhUID0gMixcclxuICAgIEFUVEFDSCA9IDNcclxufSovXHJcblxyXG5pbnRlcmZhY2UgV3JhcHBlciB7XHJcbiAgICAoKTogdm9pZCxcclxuICAgIFtwcm9wTmFtZTogc3RyaW5nXTogYW55XHJcbn1cclxuY29uc3QgZW51bSBNQVRDSEVEIHtcclxuICAgIHByZWNlZGVuY2UsXHJcbiAgICBwcm9wcyxcclxuICAgIHdyYXBwZXIsXHJcbiAgICBoYW5kbGVyLFxyXG4gICAgdmFsaWRhdG9yLFxyXG4gICAgZmlsdGVyLFxyXG59XHJcbmludGVyZmFjZSBNYXJrIHtcclxuICAgIGtleTogc3RyaW5nLFxyXG4gICAgdmFsdWU6IHN0cmluZyxcclxuICAgIGRhdGE6IChjb250ZXh0OiBDb250ZXh0LCBpbmRleDogbnVtYmVyKSA9PiBhbnlcclxufVxyXG5pbnRlcmZhY2UgQ292ZXIge1xyXG4gICAgb3JpZ2luOiBhbnksXHJcbiAgICB2YWx1ZTogYW55XHJcbn1cclxudHlwZSBPcGVyYXRpb24gPSBudWxsIHwgMCB8IHVuZGVmaW5lZCB8IGZhbHNlO1xyXG50eXBlIE5vZGVQcm9wID0gW3N0cmluZyB8IENvdmVyIHwgTWFyaywgbnVtYmVyLCBBcnJheTxQaXBlPiB8IHVuZGVmaW5lZF0gLyp8IE1hcmsqLztcclxudHlwZSBQaXBlID0gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiB8IG51bGwsIGluZGV4OiBudW1iZXIpID0+IGFueSB8IHVuZGVmaW5lZDtcclxudHlwZSBDb25uZWN0b3IgPSAoY29udGV4dDogQ29udGV4dCwgaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcclxuaW50ZXJmYWNlIE1hdGNoZWQgZXh0ZW5kcyBBcnJheTxhbnk+IHtcclxuICAgIFtNQVRDSEVELnByZWNlZGVuY2VdOiBQcmVjZWRlbmNlLFxyXG4gICAgW01BVENIRUQucHJvcHNdOiBBcnJheTxOb2RlUHJvcD4sXHJcbiAgICBbTUFUQ0hFRC53cmFwcGVyXTogV3JhcHBlcixcclxuICAgIFtNQVRDSEVELmhhbmRsZXJdPzogKGNvbnRleHQ6IENvbnRleHQpID0+IE9wZXJhdGlvbiB8IE5vZGUgfCBBcnJheTxOb2RlPixcclxuICAgIFtNQVRDSEVELnZhbGlkYXRvcl0/OiAoY29udGV4dDogQ29udGV4dCkgPT4gT3BlcmF0aW9uIHwgdHJ1ZSB8IE5vZGUgfCBBcnJheTxOb2RlPixcclxuICAgIFtNQVRDSEVELmZpbHRlcl0/OiAoY29udGV4dDogQ29udGV4dCwgbGVmdD86IG51bWJlciwgcmlnaHQ/OiBudW1iZXIpID0+IGJvb2xlYW4sXHJcbn1cclxuXHJcbmNvbnN0IGVudW0gTUFUQ0hFRF9SRUNPUkRTIHtcclxuICAgIHByZWNlZGVuY2UsXHJcbiAgICBsZWZ0LFxyXG4gICAgcmlnaHQsXHJcbiAgICBtYXRjaGVkXHJcbn1cclxuaW50ZXJmYWNlIE1hdGNoZWRSZWNvcmRzIGV4dGVuZHMgQXJyYXk8YW55PiB7XHJcbiAgICBbTUFUQ0hFRF9SRUNPUkRTLnByZWNlZGVuY2VdOiBQcmVjZWRlbmNlLFxyXG4gICAgW01BVENIRURfUkVDT1JEUy5sZWZ0XTogbnVtYmVyLFxyXG4gICAgW01BVENIRURfUkVDT1JEUy5yaWdodF06IG51bWJlcixcclxuICAgIFtNQVRDSEVEX1JFQ09SRFMubWF0Y2hlZF06IE1hdGNoZWRcclxufVxyXG5cclxuXHJcbmNvbnN0IGVudW0gUFJFQ0VERU5DRSB7XHJcbiAgICBWQUxVRSxcclxuICAgIFJJR0hUX0FTU09DSUFUSVZFXHJcbn1cclxuaW50ZXJmYWNlIFByZWNlZGVuY2UgZXh0ZW5kcyBBcnJheTxhbnk+IHtcclxuICAgIFtQUkVDRURFTkNFLlZBTFVFXTogbnVtYmVyIHwgdHJ1ZSxcclxuICAgIFtQUkVDRURFTkNFLlJJR0hUX0FTU09DSUFUSVZFXTogbnVtYmVyIHwgTnVtYmVyXHJcbn1cclxudHlwZSBWYWxpZGF0ZSA9ICh0b2tlbjogVG9rZW4pID0+IGJvb2xlYW47XHJcblxyXG5cclxuY29uc3QgZW51bSBNQVJLUyB7XHJcbiAgICBCT1VOREFSWSA9IFwiXCIsXHJcbiAgICBERUVQVEggPSBcIiBERUVQXCIsXHJcbiAgICBJREVOVElGSUVSID0gXCIgSURcIixcclxuICAgIEVORCA9IFwiIEVORFwiLFxyXG4gICAgVFlQRV9PTkxZID0gXCIgVFlQRVwiLFxyXG4gICAgV0FMS0VSID0gXCIgV0FMXCIsXHJcbiAgICBURVJNSU5BTCA9IFwiIFRFUlwiLFxyXG5cclxuICAgIEVPRiA9IFwiXCIsXHJcbiAgICBFU0NBUEUgPSBcIlxcXFxcIixcclxuXHJcbiAgICBFUlJPUiA9IFwiIEVSUlwiLFxyXG4gICAgTkVYVCA9IFwiIE5FWFRcIixcclxuICAgIEFUVEFDSCA9IFwiIEFUVFwiLFxyXG4gICAgU1RSSU5HID0gXCIgU1RSXCJcclxuXHJcbiAgICAvKlxyXG4gICAgRk9MTE9XID0gXCIgRk9MTE9XXCIsXHJcbiAgICBOT1QgPSBcIiBOT1RcIixcclxuICAgIE9SID0gXCIgT1JcIixcclxuICAgIEFORCA9IFwiIEFORFwiLCovXHJcbn1cclxuXHJcblxyXG5lbnVtIE5VTUVSSUNfS0VZV09SRF9NQVBQSU5HUyB7XHJcbiAgICBcIi5cIiA9IE5VTUVSSUNfVFlQRS5GTE9BVCB8IE5VTUVSSUNfVFlQRS5ERUNJTUFMLFxyXG4gICAgXCJ4XCIgPSBOVU1FUklDX1RZUEUuSEVYLFxyXG4gICAgXCJiXCIgPSBOVU1FUklDX1RZUEUuQklOQVJZLFxyXG4gICAgXCJvXCIgPSBOVU1FUklDX1RZUEUuT0NUQUwsXHJcblxyXG4gICAgXCJYXCIgPSBOVU1FUklDX1RZUEUuSEVYLFxyXG4gICAgXCJCXCIgPSBOVU1FUklDX1RZUEUuQklOQVJZLFxyXG4gICAgXCJPXCIgPSBOVU1FUklDX1RZUEUuT0NUQUwsXHJcbn07XHJcbmV4cG9ydCB7XHJcbiAgICBOVU1FUklDX0tFWVdPUkRfTUFQUElOR1MsXHJcbiAgICBNQVJLUyxcclxuICAgIFZhbGlkYXRlLFxyXG4gICAgUFJFQ0VERU5DRSwgUHJlY2VkZW5jZSxcclxuICAgIE5vZGVQcm9wLFxyXG4gICAgTWFyaywgQ292ZXIsXHJcbiAgICBQaXBlLFxyXG4gICAgQ29ubmVjdG9yLFxyXG4gICAgUG9zaXRpb24sXHJcbiAgICBTb3VyY2VMb2NhdGlvbixcclxuICAgIE1BVENIRURfUkVDT1JEUyxcclxuICAgIE1hdGNoZWRSZWNvcmRzLFxyXG4gICAgTWF0Y2hlZCxcclxuICAgIE1BVENIRUQsXHJcbiAgICBUb2tlbiwgQ29udGV4dCxcclxuICAgIENPTlRFWFQsIEV4cHJlc3Npb24sXHJcbiAgICBQcm9ncmFtLCBOVU1FUklDX1RZUEUsIE1hdGNoVHJlZSwgU2VhcmNoVHJlZSwvKiBUb2tlbml6ZXIsIFBhcnNlciwqLyBOb2RlXHJcbn0iXSwibWFwcGluZ3MiOiI7OztBQXdNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../js/interfaces.ts\n");

/***/ }),

/***/ "../../js/lexical/head.ts":
/*!***********************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/lexical/head.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._Scanner = exports.createSearchTree = void 0;\nfunction createSearchTree(data, root, block_list) {\n    if (root === void 0) { root = {}; }\n    if (block_list === void 0) { block_list = []; }\n    var _loop_1 = function (item) {\n        var node = root;\n        switch (true) {\n            case typeof item === \"string\":\n                item = {\n                    type: \"Punctuator\",\n                    key: item,\n                };\n                break;\n            default:\n                item.type === undefined && (item.type = \"Punctuator\");\n                break;\n        }\n        if (~block_list.indexOf(item.key)) {\n            return \"continue\";\n        }\n        for (var _i = 0, _a = item.key; _i < _a.length; _i++) {\n            var part = _a[_i];\n            node = node[part] || (node[part] = {});\n        }\n        if (node[\" END\" /* END */] && !item.overload) {\n            var next_item_1 = node[\" END\" /* END */];\n            var curr_item_1 = item;\n            if (typeof next_item_1 === \"function\") {\n                if (curr_item_1.filter) {\n                    node[\" END\" /* END */] = function (tokenizer) {\n                        return curr_item_1.filter(tokenizer) ? curr_item_1 : next_item_1(tokenizer);\n                    };\n                }\n                else {\n                    node[\" END\" /* END */] = function (tokenizer) {\n                        return next_item_1(tokenizer) || curr_item_1;\n                    };\n                }\n                return \"continue\";\n            }\n            else if (curr_item_1.filter) {\n                node[\" END\" /* END */] = function (tokenizer) {\n                    return curr_item_1.filter(tokenizer) ? curr_item_1 : next_item_1;\n                };\n                return \"continue\";\n            }\n            else {\n                console.warn(\"conflict:\", node, node[\" END\" /* END */], item);\n            }\n        }\n        node[\" END\" /* END */] = item.filter ?\n            function (tokenizer) { return item.filter(tokenizer) && item; } :\n            item;\n    };\n    for (var _i = 0, _a = data; _i < _a.length; _i++) {\n        var item = _a[_i];\n        _loop_1(item);\n    }\n    return root;\n}\nexports.createSearchTree = createSearchTree;\nfunction _Scanner(use_escape_mode) {\n    if (use_escape_mode === void 0) { use_escape_mode = false; }\n    return function (tokenizer, start) {\n        if (start === void 0) { start = tokenizer.index; }\n        var error;\n        var line_number = tokenizer.line_number;\n        var line_start = tokenizer.line_start;\n        var root = this.scan_tree;\n        var nodes = [];\n        var str = \"\";\n        var char;\n        var backslash_count = 0;\n        var token;\n        var self = this;\n        if (use_escape_mode) {\n            var has_escape = void 0;\n            while (char = tokenizer.input[tokenizer.index++]) {\n                has_escape = backslash_count % 2;\n                if (char === \"\\\\\" /* ESCAPE */) {\n                    backslash_count += 1;\n                    if (has_escape) {\n                        str += char;\n                        token = _next(\"\\\\\" /* ESCAPE */);\n                        if (token) {\n                            return token;\n                        }\n                    }\n                }\n                else {\n                    str += char;\n                    backslash_count = 0;\n                    if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\n                        tokenizer.index -= 1;\n                        token = _next(has_escape ? \"\\\\\" /* ESCAPE */ + \"\\n\" : \"\\n\");\n                        if (token) {\n                            return token;\n                        }\n                        tokenizer.index += 1;\n                        tokenizer.line_number += 1;\n                        tokenizer.line_start = tokenizer.index;\n                    }\n                    else {\n                        token = _next(!has_escape ? char : \"\\\\\" /* ESCAPE */ + char);\n                        if (token) {\n                            return token;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (char = tokenizer.input[tokenizer.index]) {\n                str += char;\n                backslash_count = 0;\n                if (tokenizer.isLineTerminator(char.charCodeAt(0))) {\n                    token = _next(\"\\n\");\n                    if (token) {\n                        return token;\n                    }\n                    tokenizer.index += 1;\n                    tokenizer.line_number += 1;\n                    tokenizer.line_start = tokenizer.index;\n                }\n                else {\n                    tokenizer.index += 1;\n                    token = _next(char);\n                    if (token) {\n                        return token;\n                    }\n                }\n            }\n        }\n        if ((token = _next(\"\" /* EOF */))) {\n            return token;\n        }\n        else {\n            var token_1 = _get_token(tokenizer.index);\n            tokenizer.err(token_1);\n            return token_1;\n        }\n        function _next(key) {\n            var index = 0, node, res;\n            for (; index < nodes.length; index += 2) {\n                node = nodes[index][key];\n                if (node) {\n                    if (res = _finally(node, nodes[index + 1])) {\n                        return res;\n                    }\n                    nodes[index] = node;\n                }\n                else {\n                    nodes.splice(index, 2);\n                    index -= 2;\n                }\n            }\n            if (node = root[key]) {\n                if (res = _finally(node, str.length - 1)) {\n                    return res;\n                }\n                nodes.push(node, str.length - 1);\n            }\n        }\n        function _get_token(end_index) {\n            tokenizer._scopes = self;\n            tokenizer._volatility = str.slice(0, end_index);\n            return tokenizer.createToken(self.type, [start, tokenizer.index], undefined, { line: line_number, column: start - line_start });\n        }\n        function _finally(node, end_index) {\n            node[\" ERR\" /* ERROR */] && (error = node[\" ERR\" /* ERROR */]);\n            var part = node[\" ATT\" /* ATTACH */] ? node[\" ATT\" /* ATTACH */](tokenizer, self) : node[\" STR\" /* STRING */];\n            if (part !== undefined) {\n                str = str.slice(0, end_index) + part;\n            }\n            switch (true) {\n                case node[\" END\" /* END */] && true:\n                    if (node[\" END\" /* END */] === true || node[\" END\" /* END */](tokenizer, self)) {\n                        var token_2 = _get_token(end_index);\n                        if (error) {\n                            token_2.error = error;\n                            tokenizer.err(token_2);\n                        }\n                        return token_2;\n                    }\n                    break;\n                case node[\" NEXT\" /* NEXT */] && true:\n                    tokenizer._scopes = self;\n                    tokenizer._volatility = str.slice(0, end_index);\n                    return node[\" NEXT\" /* NEXT */](tokenizer, self);\n            }\n        }\n    };\n}\nexports._Scanner = _Scanner;\n/**\nfunction createScanTree(data: Array<any>[]) {\n    let root: Record<string, any> = {};\n    for (let branch of data) {\n        let node = root;\n        for (let i = 0, limit = branch.length - 1, part: string; i < limit; i++) {\n            part = branch[i];\n            node = node[part] || (node[part] = {});\n        }\n        let actions = branch[branch.length - 1];\n        for (let i = 0; i < actions.length; i += 2) {\n            node[actions[i]] = actions[i + 1];\n        }\n    }\n    return root;\n}\n\n\n\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvbGV4aWNhbC9oZWFkLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9tbnQvZC9Qcm9ncmFtRmlsZXMvR2l0SHViL0Rpc29uL2pzL2xleGljYWwvaGVhZC50cz9hN2M4Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQge1xyXG4gICAgVG9rZW4sIFNlYXJjaFRyZWUsIE1BUktTXHJcbn0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcblxyXG5pbXBvcnQgVG9rZW5pemVyIGZyb20gJy4uL3Rva2VuaXplcidcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFRyZWUoXHJcbiAgICBkYXRhOiBBcnJheTxzdHJpbmcgfCBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIGFueT4+LFxyXG4gICAgcm9vdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxyXG4gICAgYmxvY2tfbGlzdDogQXJyYXk8c3RyaW5nPiA9IFtdXHJcbik6IFNlYXJjaFRyZWUge1xyXG4gICAgZm9yIChsZXQgaXRlbSBvZiBkYXRhIGFzIGFueSkge1xyXG4gICAgICAgIGxldCBub2RlID0gcm9vdDtcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQdW5jdHVhdG9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpdGVtLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09IHVuZGVmaW5lZCAmJiAoaXRlbS50eXBlID0gXCJQdW5jdHVhdG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh+YmxvY2tfbGlzdC5pbmRleE9mKGl0ZW0ua2V5KSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGl0ZW0ua2V5KSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlW3BhcnRdIHx8IChub2RlW3BhcnRdID0ge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZVtNQVJLUy5FTkRdICYmICFpdGVtLm92ZXJsb2FkKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0X2l0ZW0gPSBub2RlW01BUktTLkVORF07XHJcbiAgICAgICAgICAgIGxldCBjdXJyX2l0ZW0gPSBpdGVtO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5leHRfaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3Vycl9pdGVtLmZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVbTUFSS1MuRU5EXSA9IGZ1bmN0aW9uICh0b2tlbml6ZXI6IFRva2VuaXplcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vycl9pdGVtLmZpbHRlcih0b2tlbml6ZXIpID8gY3Vycl9pdGVtIDogbmV4dF9pdGVtKHRva2VuaXplcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlW01BUktTLkVORF0gPSBmdW5jdGlvbiAodG9rZW5pemVyOiBUb2tlbml6ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRfaXRlbSh0b2tlbml6ZXIpIHx8IGN1cnJfaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyX2l0ZW0uZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlW01BUktTLkVORF0gPSBmdW5jdGlvbiAodG9rZW5pemVyOiBUb2tlbml6ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Vycl9pdGVtLmZpbHRlcih0b2tlbml6ZXIpID8gY3Vycl9pdGVtIDogbmV4dF9pdGVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJjb25mbGljdDpcIiwgbm9kZSwgbm9kZVtNQVJLUy5FTkRdLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlW01BUktTLkVORF0gPSBpdGVtLmZpbHRlciA/XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICh0b2tlbml6ZXI6IFRva2VuaXplcikgeyByZXR1cm4gaXRlbS5maWx0ZXIodG9rZW5pemVyKSAmJiBpdGVtOyB9IDpcclxuICAgICAgICAgICAgaXRlbTtcclxuICAgIH1cclxuICAgIHJldHVybiByb290O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gX1NjYW5uZXIoXHJcbiAgICB1c2VfZXNjYXBlX21vZGU6IGJvb2xlYW4gPSBmYWxzZVxyXG4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoXHJcbiAgICAgICAgdG9rZW5pemVyOiBUb2tlbml6ZXIsXHJcbiAgICAgICAgc3RhcnQ6IG51bWJlciA9IHRva2VuaXplci5pbmRleFxyXG4gICAgKSB7XHJcbiAgICAgICAgbGV0IGVycm9yOiBzdHJpbmc7XHJcbiAgICAgICAgbGV0IGxpbmVfbnVtYmVyID0gdG9rZW5pemVyLmxpbmVfbnVtYmVyO1xyXG4gICAgICAgIGxldCBsaW5lX3N0YXJ0ID0gdG9rZW5pemVyLmxpbmVfc3RhcnQ7XHJcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLnNjYW5fdHJlZTtcclxuICAgICAgICBsZXQgbm9kZXM6IEFycmF5PGFueT4gPSBbXTtcclxuICAgICAgICBsZXQgc3RyID0gXCJcIjtcclxuICAgICAgICBsZXQgY2hhcjogc3RyaW5nO1xyXG4gICAgICAgIGxldCBiYWNrc2xhc2hfY291bnQgPSAwO1xyXG4gICAgICAgIGxldCB0b2tlbjogVG9rZW47XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGlmICh1c2VfZXNjYXBlX21vZGUpIHtcclxuICAgICAgICAgICAgbGV0IGhhc19lc2NhcGU6IG51bWJlcjtcclxuICAgICAgICAgICAgd2hpbGUgKGNoYXIgPSB0b2tlbml6ZXIuaW5wdXRbdG9rZW5pemVyLmluZGV4KytdKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNfZXNjYXBlID0gYmFja3NsYXNoX2NvdW50ICUgMjtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBNQVJLUy5FU0NBUEUpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYWNrc2xhc2hfY291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX2VzY2FwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBfbmV4dChNQVJLUy5FU0NBUEUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja3NsYXNoX2NvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5pemVyLmlzTGluZVRlcm1pbmF0b3IoY2hhci5jaGFyQ29kZUF0KDApKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIuaW5kZXggLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBfbmV4dChoYXNfZXNjYXBlID8gYCR7TUFSS1MuRVNDQVBFfVxcbmAgOiBcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyLmluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplci5saW5lX251bWJlciArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIubGluZV9zdGFydCA9IHRva2VuaXplci5pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IF9uZXh0KCFoYXNfZXNjYXBlID8gY2hhciA6IE1BUktTLkVTQ0FQRSArIGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGFyID0gdG9rZW5pemVyLmlucHV0W3Rva2VuaXplci5pbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgYmFja3NsYXNoX2NvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuaXNMaW5lVGVybWluYXRvcihjaGFyLmNoYXJDb2RlQXQoMCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBfbmV4dChcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIuaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIubGluZV9udW1iZXIgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIubGluZV9zdGFydCA9IHRva2VuaXplci5pbmRleDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyLmluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBfbmV4dChjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHRva2VuID0gX25leHQoTUFSS1MuRU9GKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IF9nZXRfdG9rZW4odG9rZW5pemVyLmluZGV4KTtcclxuICAgICAgICAgICAgdG9rZW5pemVyLmVycih0b2tlbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIF9uZXh0KGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDAsIG5vZGU6IGFueSwgcmVzOiBhbnk7XHJcbiAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IG5vZGVzLmxlbmd0aDsgaW5kZXggKz0gMikge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2luZGV4XVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzID0gX2ZpbmFsbHkobm9kZSwgbm9kZXNbaW5kZXggKyAxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaW5kZXhdID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGluZGV4LCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlID0gcm9vdFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzID0gX2ZpbmFsbHkobm9kZSwgc3RyLmxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSwgc3RyLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIF9nZXRfdG9rZW4oZW5kX2luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgdG9rZW5pemVyLl9zY29wZXMgPSBzZWxmO1xyXG4gICAgICAgICAgICB0b2tlbml6ZXIuX3ZvbGF0aWxpdHkgPSBzdHIuc2xpY2UoMCwgZW5kX2luZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplci5jcmVhdGVUb2tlbihcclxuICAgICAgICAgICAgICAgIHNlbGYudHlwZSxcclxuICAgICAgICAgICAgICAgIFtzdGFydCwgdG9rZW5pemVyLmluZGV4XSxcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHsgbGluZTogbGluZV9udW1iZXIsIGNvbHVtbjogc3RhcnQgLSBsaW5lX3N0YXJ0IH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gX2ZpbmFsbHkobm9kZTogUmVjb3JkPHN0cmluZywgYW55PiwgZW5kX2luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgbm9kZVtNQVJLUy5FUlJPUl0gJiYgKGVycm9yID0gbm9kZVtNQVJLUy5FUlJPUl0pO1xyXG4gICAgICAgICAgICBsZXQgcGFydDogc3RyaW5nID0gbm9kZVtNQVJLUy5BVFRBQ0hdID8gbm9kZVtNQVJLUy5BVFRBQ0hdKHRva2VuaXplciwgc2VsZikgOiBub2RlW01BUktTLlNUUklOR107XHJcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlbmRfaW5kZXgpICsgcGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2Ugbm9kZVtNQVJLUy5FTkRdICYmIHRydWU6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVbTUFSS1MuRU5EXSA9PT0gdHJ1ZSB8fCBub2RlW01BUktTLkVORF0odG9rZW5pemVyLCBzZWxmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSBfZ2V0X3Rva2VuKGVuZF9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuaXplci5lcnIodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIG5vZGVbTUFSS1MuTkVYVF0gJiYgdHJ1ZTpcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXIuX3Njb3BlcyA9IHNlbGY7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyLl92b2xhdGlsaXR5ID0gc3RyLnNsaWNlKDAsIGVuZF9pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVbTUFSS1MuTkVYVF0odG9rZW5pemVyLCBzZWxmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHtcclxuICAgIGNyZWF0ZVNlYXJjaFRyZWUsIF9TY2FubmVyXHJcbn1cclxuXHJcblxyXG4vKipcclxuZnVuY3Rpb24gY3JlYXRlU2NhblRyZWUoZGF0YTogQXJyYXk8YW55PltdKSB7XHJcbiAgICBsZXQgcm9vdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xyXG4gICAgZm9yIChsZXQgYnJhbmNoIG9mIGRhdGEpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHJvb3Q7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxpbWl0ID0gYnJhbmNoLmxlbmd0aCAtIDEsIHBhcnQ6IHN0cmluZzsgaSA8IGxpbWl0OyBpKyspIHtcclxuICAgICAgICAgICAgcGFydCA9IGJyYW5jaFtpXTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGVbcGFydF0gfHwgKG5vZGVbcGFydF0gPSB7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhY3Rpb25zID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgbm9kZVthY3Rpb25zW2ldXSA9IGFjdGlvbnNbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByb290O1xyXG59XHJcblxyXG5cclxuXHJcbiAqLyJdLCJtYXBwaW5ncyI6Ijs7O0FBT0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNUNBO0FBQUE7QUFBQTtBQTZDQTtBQUNBO0FBQ0E7QUErSUE7QUE1SUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../js/lexical/head.ts\n");

/***/ }),

/***/ "../../js/lexical/index.ts":
/*!************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/lexical/index.ts ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.REGEXP_DESCRIPTOR = exports.TOKEN_TYPE_SET = exports.PUNCTUATORS = exports.TYPE_ENUMS = void 0;\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/lexical/head.ts\");\nvar TOKEN_TYPE_SET = [\n    [\n        \"Keyword\",\n        [\n            \"void\",\n            \"delete\",\n            \"new\",\n            \"class\", \"extends\",\n            \"function\",\n            \"throw\",\n            \"with\",\n            \"yield\",\n            \"in\", \"instanceof\", \"typeof\",\n            \"this\", \"super\",\n            \"var\", \"const\",\n            \"break\", \"continue\", \"return\",\n            \"if\", \"else\",\n            \"switch\", \"case\", \"default\",\n            \"try\", \"catch\", \"finally\",\n            \"do\", \"while\", \"for\",\n            \"await\",\n            \"import\", \"export\",\n            \"debugger\",\n            \"enum\" //用于错误检测\n        ]\n    ],\n    [\"Identifier\", [\"let\", \"async\"]],\n    [\"Boolean\", [\"true\", \"false\"]],\n    [\"Null\", [\"null\"]]\n];\nexports.TOKEN_TYPE_SET = TOKEN_TYPE_SET;\nvar octal_escape = (_a = {},\n    //_state: MATCH_STATUS.ATTACH,\n    _a[\" ATT\" /* ATTACH */] = function (tokenizer, self) {\n        var code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index - 1));\n        var value = 0;\n        code && (self.octal = true);\n        var len = code <= 3 ? 2 : 1;\n        while (true) {\n            value = value * 8 + code;\n            code = tokenizer.octalValue(tokenizer.input.charCodeAt(tokenizer.index));\n            if (code < 0 || --len < 0) {\n                break;\n            }\n            self.octal = true;\n            tokenizer.index += 1;\n        }\n        return String.fromCharCode(value);\n    },\n    _a);\nvar octal_escape_tree = {\n    \"\\\\0\": octal_escape,\n    \"\\\\1\": octal_escape,\n    \"\\\\2\": octal_escape,\n    \"\\\\3\": octal_escape,\n    \"\\\\4\": octal_escape,\n    \"\\\\5\": octal_escape,\n    \"\\\\6\": octal_escape,\n    \"\\\\7\": octal_escape,\n};\nvar strbase_scan_tree = (_b = {},\n    _b[\"\\\\\" /* ESCAPE */ + \"\\n\"] = (_c = {}, _c[\" STR\" /* STRING */] = \"\", _c),\n    _b[\"\\\\n\"] = (_d = {}, _d[\" STR\" /* STRING */] = \"\\n\", _d),\n    _b[\"\\\\r\"] = (_e = {}, _e[\" STR\" /* STRING */] = \"\\r\", _e),\n    _b[\"\\\\t\"] = (_f = {}, _f[\" STR\" /* STRING */] = \"\\t\", _f),\n    _b[\"\\\\b\"] = (_g = {}, _g[\" STR\" /* STRING */] = \"\\b\", _g),\n    _b[\"\\\\f\"] = (_h = {}, _h[\" STR\" /* STRING */] = \"\\f\", _h),\n    _b[\"\\\\v\"] = (_j = {}, _j[\" STR\" /* STRING */] = \"\\v\", _j),\n    _b[\"\\\\u\"] = (_k = {},\n        //_state: MATCH_STATUS.ATTACH,\n        _k[\" ATT\" /* ATTACH */] = function (tokenizer) {\n            if (tokenizer.input[tokenizer.index] === \"{\") {\n                tokenizer.index++;\n                var code = tokenizer.scanHex()[0];\n                if (tokenizer.input[tokenizer.index] === \"}\") {\n                    tokenizer.index++;\n                    if (code <= 0x10ffff) {\n                        return String.fromCharCode(code);\n                    }\n                }\n            }\n            else {\n                var _a = tokenizer.scanHex(4), code = _a[0], len = _a[1];\n                if (len === 4) {\n                    return String.fromCharCode(code);\n                }\n            }\n            return false;\n        },\n        _k),\n    _b[\"\\\\x\"] = (_l = {},\n        //_state: MATCH_STATUS.ATTACH,\n        _l[\" ATT\" /* ATTACH */] = function (tokenizer) {\n            var _a = tokenizer.scanHex(2), code = _a[0], len = _a[1];\n            if (len === 2) {\n                return String.fromCharCode(code);\n            }\n            return false;\n        },\n        _l),\n    _b);\nvar not_allow_octal_escape = (_m = {},\n    //_state: MATCH_STATUS.ERROR,\n    _m[\" ERR\" /* ERROR */] = \"Octal escape sequences are not allowed in template strings\",\n    _m);\n//let template_curly_stack = [];\nvar template_base = {\n    type: \"Template\",\n    scan_tree: __assign((_o = {}, _o[\"\" /* EOF */] = (_p = {},\n        //_state: MATCH_STATUS.END,\n        _p[\" ERR\" /* ERROR */] = \"Unexpected token\",\n        _p[\" END\" /* END */] = function (tokenizer) {\n            tokenizer.curly_stack.shift();\n            return true;\n        },\n        _p), _o[\"\\\\0\"] = (_q = {}, _q[\" STR\" /* STRING */] = \"\\0\", _q), _o[\"\\\\1\"] = not_allow_octal_escape, _o[\"\\\\2\"] = not_allow_octal_escape, _o[\"\\\\3\"] = not_allow_octal_escape, _o[\"\\\\4\"] = not_allow_octal_escape, _o[\"\\\\5\"] = not_allow_octal_escape, _o[\"\\\\6\"] = not_allow_octal_escape, _o[\"\\\\7\"] = not_allow_octal_escape, _o[\"`\"] = (_r = {},\n        _r[\" END\" /* END */] = function (tokenizer) {\n            tokenizer.curly_stack.shift();\n            return true;\n        },\n        _r), _o[\"$\"] = {\n        \"{\": (_s = {},\n            _s[\" END\" /* END */] = true,\n            _s)\n    }, _o), strbase_scan_tree),\n    scanner: head_1._Scanner(true)\n};\nvar PUNCTUATORS = [\n    {\n        key: \"\\\"\",\n        type: \"String\",\n        scan_tree: __assign(__assign({ '\"': (_t = {},\n                _t[\" END\" /* END */] = true,\n                _t), \"\\n\": (_u = {},\n                //_state: MATCH_STATUS.ERROR\n                _u[\" ERR\" /* ERROR */] = \"Invalid or unexpected token\",\n                _u) }, strbase_scan_tree), octal_escape_tree),\n        escape_scan: head_1._Scanner(true),\n        octal: false,\n        scanner: function (tokenizer, start) {\n            this.octal = false;\n            return this.escape_scan(tokenizer, start);\n        }\n    },\n    {\n        key: \"'\",\n        type: \"String\",\n        scan_tree: __assign(__assign({ \"'\": (_v = {},\n                _v[\" END\" /* END */] = true,\n                _v), \"\\n\": (_w = {},\n                //_state: MATCH_STATUS.ERROR\n                _w[\" ERR\" /* ERROR */] = \"Invalid or unexpected token\",\n                _w) }, strbase_scan_tree), octal_escape_tree),\n        escape_scan: head_1._Scanner(true),\n        octal: false,\n        scanner: function (tokenizer, start) {\n            this.octal = false;\n            return this.escape_scan(tokenizer, start);\n        }\n    },\n    __assign(__assign({ key: \"`\" }, template_base), { escape_scan: head_1._Scanner(true), scanner: function (tokenizer, start) {\n            tokenizer.curly_stack.unshift(\"`\");\n            return this.escape_scan(tokenizer, start);\n        } }),\n    __assign(__assign({ key: \"}\" }, template_base), { filter: function (tokenizer) {\n            return tokenizer.curly_stack[0] === \"`\";\n        } }),\n    {\n        key: '/*', bound: '*/', type: \"Comments\",\n        scan_tree: (_x = {\n                \"*\": {\n                    \"/\": (_y = {},\n                        //_state: MATCH_STATUS.END\n                        _y[\" END\" /* END */] = true,\n                        _y)\n                }\n            },\n            _x[\"\" /* EOF */] = (_z = {},\n                _z[\" END\" /* END */] = true,\n                _z[\" ERR\" /* ERROR */] = \"Unexpected token\",\n                _z),\n            _x),\n        scanner: head_1._Scanner(false)\n    },\n    {\n        key: '//', bound: '\\n', type: \"Comments\",\n        scan_tree: (_0 = {\n                \"\\n\": (_1 = {},\n                    _1[\" END\" /* END */] = true,\n                    _1)\n            },\n            _0[\"\" /* EOF */] = (_2 = {},\n                _2[\" END\" /* END */] = true,\n                _2),\n            _0),\n        scanner: head_1._Scanner(false)\n    },\n    //[\"(\", \")\"], [\"[\", \"]\"], [\"{\", \"}\"],\n    \"(\", \")\", \"[\", \"]\", \"{\", \"}\",\n    ';', '.', '?.',\n    '++', '--', '~', '!',\n    '**', '*', '/', '%',\n    '+', '-',\n    '<<', '>>', '>>>',\n    '<', '>', '<=', '>=', '==', '!=', '===', '!==',\n    '&',\n    '^',\n    '|',\n    '&&',\n    '||',\n    '?', \":\",\n    '=', '+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '&=', '|=', '^=',\n    '...',\n    ',',\n    '=>'\n];\nexports.PUNCTUATORS = PUNCTUATORS;\nvar REGEXP_DESCRIPTOR = {\n    key: '/', type: \"RegularExpression\",\n    scan_tree: (_3 = {\n            '/': (_4 = {},\n                _4[\" END\" /* END */] = function (tokenizer, self) {\n                    return !self.class_marker;\n                },\n                _4),\n            '[': (_5 = {},\n                _5[\" ATT\" /* ATTACH */] = function (tokenizer, self) {\n                    self.class_marker = true;\n                },\n                _5),\n            ']': (_6 = {},\n                _6[\" ATT\" /* ATTACH */] = function (tokenizer, self) {\n                    self.class_marker = false;\n                },\n                _6),\n            '\\n': (_7 = {},\n                _7[\" ERR\" /* ERROR */] = \"Invalid or unexpected token\",\n                _7),\n            '\\\\\\n': (_8 = {},\n                _8[\" ERR\" /* ERROR */] = \"Invalid or unexpected token\",\n                _8)\n        },\n        _3[\"\" /* EOF */] = (_9 = {},\n            _9[\" END\" /* END */] = true,\n            _9[\" ERR\" /* ERROR */] = \"Invalid or unexpected token\",\n            _9),\n        _3),\n    overload: true,\n    escape_scan: head_1._Scanner(true),\n    class_marker: false,\n    scanner: function (tokenizer, start) {\n        this.class_marker = false;\n        var token = this.escape_scan(tokenizer, start);\n        if (token) {\n            token.regex = {\n                pattern: token.value.slice(1, token.value[token.value.length - 1] !== \"/\" ? undefined : -1),\n                flags: \"\"\n            };\n            var start_1 = tokenizer.index;\n            var length_1 = 0;\n            do {\n                tokenizer.index += length_1;\n                length_1 = tokenizer.inIdentifierPart();\n            } while (length_1);\n            if (start_1 !== tokenizer.index) {\n                token.regex.flags = tokenizer.input.slice(start_1, tokenizer.index);\n                token.value += token.regex.flags;\n                token.range[1] += tokenizer.index - start_1;\n                token.loc.end.column += tokenizer.index - start_1;\n            }\n            return token;\n        }\n    }\n};\nexports.REGEXP_DESCRIPTOR = REGEXP_DESCRIPTOR;\n//const IS_RADIX = NUMERIC_TYPE.BINARY | NUMERIC_TYPE.OCTAL | NUMERIC_TYPE.HEX;\nvar TYPE_ENUMS = {\n    Identifier: \"Identifier\",\n    Keyword: \"Keyword\",\n    String: \"String\",\n    Boolean: \"Boolean\",\n    Numeric: \"Numeric\",\n    Punctuator: \"Punctuator\",\n    RegularExpression: \"RegularExpression\",\n    Template: \"Template\",\n    TemplateElement: \"TemplateElement\",\n    Comments: \"Comments\",\n    Null: \"Null\"\n};\nexports.TYPE_ENUMS = TYPE_ENUMS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvbGV4aWNhbC9pbmRleC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vbW50L2QvUHJvZ3JhbUZpbGVzL0dpdEh1Yi9EaXNvbi9qcy9sZXhpY2FsL2luZGV4LnRzPzZlYWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIFRva2VuLCBOVU1FUklDX1RZUEUsIE1BUktTXHJcbn0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcblxyXG5pbXBvcnQgVG9rZW5pemVyIGZyb20gJy4uL3Rva2VuaXplcidcclxuaW1wb3J0IHsgX1NjYW5uZXIsIGNyZWF0ZVNlYXJjaFRyZWUgfSBmcm9tICcuL2hlYWQnXHJcblxyXG5cclxubGV0IFRPS0VOX1RZUEVfU0VUID0gW1xyXG4gICAgW1xyXG4gICAgICAgIFwiS2V5d29yZFwiLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgXCJ2b2lkXCIsXHJcbiAgICAgICAgICAgIFwiZGVsZXRlXCIsXHJcbiAgICAgICAgICAgIFwibmV3XCIsXHJcbiAgICAgICAgICAgIFwiY2xhc3NcIiwgXCJleHRlbmRzXCIsXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIixcclxuICAgICAgICAgICAgXCJ0aHJvd1wiLFxyXG4gICAgICAgICAgICBcIndpdGhcIixcclxuICAgICAgICAgICAgXCJ5aWVsZFwiLFxyXG4gICAgICAgICAgICBcImluXCIsIFwiaW5zdGFuY2VvZlwiLCBcInR5cGVvZlwiLFxyXG4gICAgICAgICAgICBcInRoaXNcIiwgXCJzdXBlclwiLFxyXG4gICAgICAgICAgICBcInZhclwiLCBcImNvbnN0XCIsLy8gXCJsZXRcIixcclxuICAgICAgICAgICAgXCJicmVha1wiLCBcImNvbnRpbnVlXCIsIFwicmV0dXJuXCIsXHJcbiAgICAgICAgICAgIFwiaWZcIiwgXCJlbHNlXCIsXHJcbiAgICAgICAgICAgIFwic3dpdGNoXCIsIFwiY2FzZVwiLCBcImRlZmF1bHRcIixcclxuICAgICAgICAgICAgXCJ0cnlcIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIixcclxuICAgICAgICAgICAgXCJkb1wiLCBcIndoaWxlXCIsIFwiZm9yXCIsXHJcbiAgICAgICAgICAgIFwiYXdhaXRcIiwvKlwiYXN5bmNcIiwqL1xyXG4gICAgICAgICAgICBcImltcG9ydFwiLCBcImV4cG9ydFwiLFxyXG4gICAgICAgICAgICBcImRlYnVnZ2VyXCIsXHJcblxyXG4gICAgICAgICAgICBcImVudW1cIi8v55So5LqO6ZSZ6K+v5qOA5rWLXHJcbiAgICAgICAgXVxyXG4gICAgXSxcclxuICAgIFtcIklkZW50aWZpZXJcIiwgW1wibGV0XCIsIFwiYXN5bmNcIl1dLC8v5L2/IFVuaWNvZGVFc2NhcGUg55qE5oOF5Ya16IO96KKr5qOA5rWL5Yiw5oql6ZSZXHJcbiAgICBbXCJCb29sZWFuXCIsIFtcInRydWVcIiwgXCJmYWxzZVwiXV0sXHJcbiAgICBbXCJOdWxsXCIsIFtcIm51bGxcIl1dXHJcbl07XHJcblxyXG5cclxubGV0IG9jdGFsX2VzY2FwZSA9IHtcclxuICAgIC8vX3N0YXRlOiBNQVRDSF9TVEFUVVMuQVRUQUNILFxyXG4gICAgW01BUktTLkFUVEFDSF0odG9rZW5pemVyOiBUb2tlbml6ZXIsIHNlbGY6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgICAgICBsZXQgY29kZSA9IHRva2VuaXplci5vY3RhbFZhbHVlKHRva2VuaXplci5pbnB1dC5jaGFyQ29kZUF0KHRva2VuaXplci5pbmRleCAtIDEpKTtcclxuICAgICAgICBsZXQgdmFsdWUgPSAwO1xyXG4gICAgICAgIGNvZGUgJiYgKHNlbGYub2N0YWwgPSB0cnVlKTtcclxuICAgICAgICBsZXQgbGVuID0gY29kZSA8PSAzID8gMiA6IDE7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDggKyBjb2RlO1xyXG4gICAgICAgICAgICBjb2RlID0gdG9rZW5pemVyLm9jdGFsVmFsdWUodG9rZW5pemVyLmlucHV0LmNoYXJDb2RlQXQodG9rZW5pemVyLmluZGV4KSk7XHJcbiAgICAgICAgICAgIGlmIChjb2RlIDwgMCB8fCAtLWxlbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYub2N0YWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB0b2tlbml6ZXIuaW5kZXggKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5sZXQgb2N0YWxfZXNjYXBlX3RyZWUgPSB7XHJcbiAgICBcIlxcXFwwXCI6IG9jdGFsX2VzY2FwZSxcclxuICAgIFwiXFxcXDFcIjogb2N0YWxfZXNjYXBlLFxyXG4gICAgXCJcXFxcMlwiOiBvY3RhbF9lc2NhcGUsXHJcbiAgICBcIlxcXFwzXCI6IG9jdGFsX2VzY2FwZSxcclxuICAgIFwiXFxcXDRcIjogb2N0YWxfZXNjYXBlLFxyXG4gICAgXCJcXFxcNVwiOiBvY3RhbF9lc2NhcGUsXHJcbiAgICBcIlxcXFw2XCI6IG9jdGFsX2VzY2FwZSxcclxuICAgIFwiXFxcXDdcIjogb2N0YWxfZXNjYXBlLFxyXG59XHJcblxyXG5sZXQgc3RyYmFzZV9zY2FuX3RyZWUgPSB7XHJcbiAgICBbTUFSS1MuRVNDQVBFICsgXCJcXG5cIl06IHsgW01BUktTLlNUUklOR106IFwiXCIgfSxcclxuICAgIFwiXFxcXG5cIjogeyBbTUFSS1MuU1RSSU5HXTogXCJcXG5cIiB9LFxyXG4gICAgXCJcXFxcclwiOiB7IFtNQVJLUy5TVFJJTkddOiBcIlxcclwiIH0sXHJcbiAgICBcIlxcXFx0XCI6IHsgW01BUktTLlNUUklOR106IFwiXFx0XCIgfSxcclxuICAgIFwiXFxcXGJcIjogeyBbTUFSS1MuU1RSSU5HXTogXCJcXGJcIiB9LFxyXG4gICAgXCJcXFxcZlwiOiB7IFtNQVJLUy5TVFJJTkddOiBcIlxcZlwiIH0sXHJcbiAgICBcIlxcXFx2XCI6IHsgW01BUktTLlNUUklOR106IFwiXFx2XCIgfSxcclxuICAgIFwiXFxcXHVcIjoge1xyXG4gICAgICAgIC8vX3N0YXRlOiBNQVRDSF9TVEFUVVMuQVRUQUNILFxyXG4gICAgICAgIFtNQVJLUy5BVFRBQ0hdKHRva2VuaXplcjogVG9rZW5pemVyKSB7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbml6ZXIuaW5wdXRbdG9rZW5pemVyLmluZGV4XSA9PT0gXCJ7XCIpIHtcclxuICAgICAgICAgICAgICAgIHRva2VuaXplci5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgbGV0IFtjb2RlXSA9IHRva2VuaXplci5zY2FuSGV4KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5pemVyLmlucHV0W3Rva2VuaXplci5pbmRleF0gPT09IFwifVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5pemVyLmluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPD0gMHgxMGZmZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IFtjb2RlLCBsZW5dID0gdG9rZW5pemVyLnNjYW5IZXgoNCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcIlxcXFx4XCI6IHtcclxuICAgICAgICAvL19zdGF0ZTogTUFUQ0hfU1RBVFVTLkFUVEFDSCxcclxuICAgICAgICBbTUFSS1MuQVRUQUNIXSh0b2tlbml6ZXI6IFRva2VuaXplcikge1xyXG4gICAgICAgICAgICBsZXQgW2NvZGUsIGxlbl0gPSB0b2tlbml6ZXIuc2NhbkhleCgyKTtcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmxldCBub3RfYWxsb3dfb2N0YWxfZXNjYXBlID0ge1xyXG4gICAgLy9fc3RhdGU6IE1BVENIX1NUQVRVUy5FUlJPUixcclxuICAgIFtNQVJLUy5FUlJPUl06IFwiT2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5nc1wiXHJcbn1cclxuXHJcbi8vbGV0IHRlbXBsYXRlX2N1cmx5X3N0YWNrID0gW107XHJcbmxldCB0ZW1wbGF0ZV9iYXNlID0ge1xyXG4gICAgdHlwZTogXCJUZW1wbGF0ZVwiLFxyXG4gICAgc2Nhbl90cmVlOiB7XHJcbiAgICAgICAgW01BUktTLkVPRl06IHtcclxuICAgICAgICAgICAgLy9fc3RhdGU6IE1BVENIX1NUQVRVUy5FTkQsXHJcbiAgICAgICAgICAgIFtNQVJLUy5FUlJPUl06IFwiVW5leHBlY3RlZCB0b2tlblwiLFxyXG4gICAgICAgICAgICBbTUFSS1MuRU5EXSh0b2tlbml6ZXI6IFRva2VuaXplcikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5pemVyLmN1cmx5X3N0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJcXFxcMFwiOiB7IFtNQVJLUy5TVFJJTkddOiBcIlxcMFwiIH0sXHJcbiAgICAgICAgXCJcXFxcMVwiOiBub3RfYWxsb3dfb2N0YWxfZXNjYXBlLFxyXG4gICAgICAgIFwiXFxcXDJcIjogbm90X2FsbG93X29jdGFsX2VzY2FwZSxcclxuICAgICAgICBcIlxcXFwzXCI6IG5vdF9hbGxvd19vY3RhbF9lc2NhcGUsXHJcbiAgICAgICAgXCJcXFxcNFwiOiBub3RfYWxsb3dfb2N0YWxfZXNjYXBlLFxyXG4gICAgICAgIFwiXFxcXDVcIjogbm90X2FsbG93X29jdGFsX2VzY2FwZSxcclxuICAgICAgICBcIlxcXFw2XCI6IG5vdF9hbGxvd19vY3RhbF9lc2NhcGUsXHJcbiAgICAgICAgXCJcXFxcN1wiOiBub3RfYWxsb3dfb2N0YWxfZXNjYXBlLFxyXG4gICAgICAgIFwiYFwiOiB7XHJcbiAgICAgICAgICAgIFtNQVJLUy5FTkRdKHRva2VuaXplcjogVG9rZW5pemVyKSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbml6ZXIuY3VybHlfc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcIiRcIjoge1xyXG4gICAgICAgICAgICBcIntcIjoge1xyXG4gICAgICAgICAgICAgICAgW01BUktTLkVORF06IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4uc3RyYmFzZV9zY2FuX3RyZWVcclxuICAgIH0sXHJcbiAgICBzY2FubmVyOiBfU2Nhbm5lcih0cnVlKVxyXG59XHJcbmNvbnN0IFBVTkNUVUFUT1JTOiBBcnJheTxhbnk+ID0gW1xyXG4gICAge1xyXG4gICAgICAgIGtleTogYFwiYCwgdHlwZTogXCJTdHJpbmdcIixcclxuICAgICAgICBzY2FuX3RyZWU6IHtcclxuICAgICAgICAgICAgJ1wiJzoge1xyXG4gICAgICAgICAgICAgICAgW01BUktTLkVORF06IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJcXG5cIjoge1xyXG4gICAgICAgICAgICAgICAgLy9fc3RhdGU6IE1BVENIX1NUQVRVUy5FUlJPUlxyXG4gICAgICAgICAgICAgICAgW01BUktTLkVSUk9SXTogXCJJbnZhbGlkIG9yIHVuZXhwZWN0ZWQgdG9rZW5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAuLi5zdHJiYXNlX3NjYW5fdHJlZSxcclxuICAgICAgICAgICAgLi4ub2N0YWxfZXNjYXBlX3RyZWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzY2FwZV9zY2FuOiBfU2Nhbm5lcih0cnVlKSxcclxuICAgICAgICBvY3RhbDogZmFsc2UsXHJcbiAgICAgICAgc2Nhbm5lcih0b2tlbml6ZXI6IFRva2VuaXplciwgc3RhcnQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLm9jdGFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVzY2FwZV9zY2FuKHRva2VuaXplciwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAga2V5OiBgJ2AsIHR5cGU6IFwiU3RyaW5nXCIsXHJcbiAgICAgICAgc2Nhbl90cmVlOiB7XHJcbiAgICAgICAgICAgIFwiJ1wiOiB7XHJcbiAgICAgICAgICAgICAgICBbTUFSS1MuRU5EXTogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIlxcblwiOiB7XHJcbiAgICAgICAgICAgICAgICAvL19zdGF0ZTogTUFUQ0hfU1RBVFVTLkVSUk9SXHJcbiAgICAgICAgICAgICAgICBbTUFSS1MuRVJST1JdOiBcIkludmFsaWQgb3IgdW5leHBlY3RlZCB0b2tlblwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC4uLnN0cmJhc2Vfc2Nhbl90cmVlLFxyXG4gICAgICAgICAgICAuLi5vY3RhbF9lc2NhcGVfdHJlZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXNjYXBlX3NjYW46IF9TY2FubmVyKHRydWUpLFxyXG4gICAgICAgIG9jdGFsOiBmYWxzZSxcclxuICAgICAgICBzY2FubmVyKHRva2VuaXplcjogVG9rZW5pemVyLCBzdGFydDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2N0YWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlX3NjYW4odG9rZW5pemVyLCBzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBrZXk6IFwiYFwiLFxyXG4gICAgICAgIC4uLnRlbXBsYXRlX2Jhc2UsXHJcbiAgICAgICAgZXNjYXBlX3NjYW46IF9TY2FubmVyKHRydWUpLFxyXG4gICAgICAgIHNjYW5uZXIodG9rZW5pemVyOiBUb2tlbml6ZXIsIHN0YXJ0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgdG9rZW5pemVyLmN1cmx5X3N0YWNrLnVuc2hpZnQoXCJgXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGVfc2Nhbih0b2tlbml6ZXIsIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGtleTogXCJ9XCIsXHJcbiAgICAgICAgLi4udGVtcGxhdGVfYmFzZSxcclxuICAgICAgICBmaWx0ZXIodG9rZW5pemVyOiBUb2tlbml6ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuaXplci5jdXJseV9zdGFja1swXSA9PT0gXCJgXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBrZXk6ICcvKicsIGJvdW5kOiAnKi8nLCB0eXBlOiBcIkNvbW1lbnRzXCIsXHJcbiAgICAgICAgc2Nhbl90cmVlOiB7XHJcbiAgICAgICAgICAgIFwiKlwiOiB7XHJcbiAgICAgICAgICAgICAgICBcIi9cIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vX3N0YXRlOiBNQVRDSF9TVEFUVVMuRU5EXHJcbiAgICAgICAgICAgICAgICAgICAgW01BUktTLkVORF06IHRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW01BUktTLkVPRl06IHtcclxuICAgICAgICAgICAgICAgIFtNQVJLUy5FTkRdOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgW01BUktTLkVSUk9SXTogXCJVbmV4cGVjdGVkIHRva2VuXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2Nhbm5lcjogX1NjYW5uZXIoZmFsc2UpXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIGtleTogJy8vJywgYm91bmQ6ICdcXG4nLCB0eXBlOiBcIkNvbW1lbnRzXCIsXHJcbiAgICAgICAgc2Nhbl90cmVlOiB7XHJcbiAgICAgICAgICAgIFwiXFxuXCI6IHtcclxuICAgICAgICAgICAgICAgIFtNQVJLUy5FTkRdOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtNQVJLUy5FT0ZdOiB7XHJcbiAgICAgICAgICAgICAgICBbTUFSS1MuRU5EXTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2FubmVyOiBfU2Nhbm5lcihmYWxzZSlcclxuICAgIH0sXHJcblxyXG4gICAgLy9bXCIoXCIsIFwiKVwiXSwgW1wiW1wiLCBcIl1cIl0sIFtcIntcIiwgXCJ9XCJdLFxyXG5cclxuICAgIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsXHJcbiAgICAnOycsICcuJywgJz8uJyxcclxuICAgICcrKycsICctLScsICd+JywgJyEnLFxyXG4gICAgJyoqJywgJyonLCAnLycsICclJyxcclxuICAgICcrJywgJy0nLFxyXG4gICAgJzw8JywgJz4+JywgJz4+PicsXHJcbiAgICAnPCcsICc+JywgJzw9JywgJz49JywgJz09JywgJyE9JywgJz09PScsICchPT0nLFxyXG4gICAgJyYnLFxyXG4gICAgJ14nLFxyXG4gICAgJ3wnLFxyXG4gICAgJyYmJyxcclxuICAgICd8fCcsXHJcbiAgICAnPycsIFwiOlwiLFxyXG4gICAgJz0nLCAnKz0nLCAnLT0nLCAnKj0nLCAnLz0nLCAnJT0nLCAnKio9JywgJzw8PScsICc+Pj0nLCAnPj4+PScsICcmPScsICd8PScsICdePScsXHJcbiAgICAnLi4uJyxcclxuICAgICcsJyxcclxuICAgICc9PidcclxuXTtcclxuXHJcbmNvbnN0IFJFR0VYUF9ERVNDUklQVE9SID0ge1xyXG4gICAga2V5OiAnLycsIHR5cGU6IFwiUmVndWxhckV4cHJlc3Npb25cIixcclxuICAgIHNjYW5fdHJlZToge1xyXG4gICAgICAgICcvJzoge1xyXG4gICAgICAgICAgICBbTUFSS1MuRU5EXSh0b2tlbml6ZXI6IFRva2VuaXplciwgc2VsZjogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFzZWxmLmNsYXNzX21hcmtlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ1snOiB7XHJcbiAgICAgICAgICAgIFtNQVJLUy5BVFRBQ0hdKHRva2VuaXplcjogVG9rZW5pemVyLCBzZWxmOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmNsYXNzX21hcmtlciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICddJzoge1xyXG4gICAgICAgICAgICBbTUFSS1MuQVRUQUNIXSh0b2tlbml6ZXI6IFRva2VuaXplciwgc2VsZjogUmVjb3JkPHN0cmluZywgYW55Pikge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jbGFzc19tYXJrZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ1xcbic6IHtcclxuICAgICAgICAgICAgW01BUktTLkVSUk9SXTogXCJJbnZhbGlkIG9yIHVuZXhwZWN0ZWQgdG9rZW5cIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ1xcXFxcXG4nOiB7XHJcbiAgICAgICAgICAgIFtNQVJLUy5FUlJPUl06IFwiSW52YWxpZCBvciB1bmV4cGVjdGVkIHRva2VuXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtNQVJLUy5FT0ZdOiB7XHJcbiAgICAgICAgICAgIFtNQVJLUy5FTkRdOiB0cnVlLFxyXG4gICAgICAgICAgICBbTUFSS1MuRVJST1JdOiBcIkludmFsaWQgb3IgdW5leHBlY3RlZCB0b2tlblwiXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG92ZXJsb2FkOiB0cnVlLFxyXG4gICAgZXNjYXBlX3NjYW46IF9TY2FubmVyKHRydWUpLFxyXG4gICAgY2xhc3NfbWFya2VyOiBmYWxzZSxcclxuICAgIHNjYW5uZXIodG9rZW5pemVyOiBUb2tlbml6ZXIsIHN0YXJ0OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmNsYXNzX21hcmtlciA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMuZXNjYXBlX3NjYW4odG9rZW5pemVyLCBzdGFydCk7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRva2VuLnJlZ2V4ID0ge1xyXG4gICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4udmFsdWUuc2xpY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgMSwgdG9rZW4udmFsdWVbdG9rZW4udmFsdWUubGVuZ3RoIC0gMV0gIT09IFwiL1wiID8gdW5kZWZpbmVkIDogLTFcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBmbGFnczogXCJcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0b2tlbml6ZXIuaW5kZXg7XHJcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbml6ZXIuaW5kZXggKz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdG9rZW5pemVyLmluSWRlbnRpZmllclBhcnQoKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAobGVuZ3RoKVxyXG4gICAgICAgICAgICBpZiAoc3RhcnQgIT09IHRva2VuaXplci5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4ucmVnZXguZmxhZ3MgPSB0b2tlbml6ZXIuaW5wdXQuc2xpY2Uoc3RhcnQsIHRva2VuaXplci5pbmRleClcclxuICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlICs9IHRva2VuLnJlZ2V4LmZsYWdzO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4ucmFuZ2VbMV0gKz0gdG9rZW5pemVyLmluZGV4IC0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi5sb2MuZW5kLmNvbHVtbiArPSB0b2tlbml6ZXIuaW5kZXggLSBzdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vY29uc3QgSVNfUkFESVggPSBOVU1FUklDX1RZUEUuQklOQVJZIHwgTlVNRVJJQ19UWVBFLk9DVEFMIHwgTlVNRVJJQ19UWVBFLkhFWDtcclxuXHJcblxyXG5jb25zdCBUWVBFX0VOVU1TID0ge1xyXG4gICAgSWRlbnRpZmllcjogXCJJZGVudGlmaWVyXCIsXHJcbiAgICBLZXl3b3JkOiBcIktleXdvcmRcIixcclxuICAgIFN0cmluZzogXCJTdHJpbmdcIixcclxuICAgIEJvb2xlYW46IFwiQm9vbGVhblwiLFxyXG4gICAgTnVtZXJpYzogXCJOdW1lcmljXCIsXHJcbiAgICBQdW5jdHVhdG9yOiBcIlB1bmN0dWF0b3JcIixcclxuICAgIFJlZ3VsYXJFeHByZXNzaW9uOiBcIlJlZ3VsYXJFeHByZXNzaW9uXCIsXHJcbiAgICBUZW1wbGF0ZTogXCJUZW1wbGF0ZVwiLFxyXG4gICAgVGVtcGxhdGVFbGVtZW50OiBcIlRlbXBsYXRlRWxlbWVudFwiLFxyXG4gICAgQ29tbWVudHM6IFwiQ29tbWVudHNcIixcclxuICAgIE51bGw6IFwiTnVsbFwiXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IHtcclxuICAgIFRZUEVfRU5VTVMsXHJcbiAgICBQVU5DVFVBVE9SUyxcclxuICAgIFRPS0VOX1RZUEVfU0VULFxyXG4gICAgUkVHRVhQX0RFU0NSSVBUT1JcclxufVxyXG5cclxuXHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE4U0E7QUEzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrRkE7QUFoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkE7QUF0QkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../js/lexical/index.ts\n");

/***/ }),

/***/ "../../js/parser.ts":
/*!*****************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/parser.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tokenizer_1 = __webpack_require__(/*! ./tokenizer */ \"../../js/tokenizer.ts\");\nvar head_1 = __webpack_require__(/*! ./syntax/head */ \"../../js/syntax/head.ts\");\nvar Script = head_1.NODES.Script, Module = head_1.NODES.Module;\nvar default_1 = /** @class */ (function (_super) {\n    __extends(default_1, _super);\n    function default_1() {\n        var _this = _super.call(this) || this;\n        _this.TYPE_ALIAS = head_1.TYPE_ALIAS;\n        _this.padding_token = {\n            type: \"\" /* BOUNDARY */,\n            value: \"\" /* BOUNDARY */\n        };\n        _this.save_comments = false;\n        return _this;\n    }\n    Object.defineProperty(default_1.prototype, \"is_primary_expr_start\", {\n        get: function () {\n            if (this.tokens.length) {\n                var last_node = this.tokens[this.tokens.length - 1];\n                return this.isStatementListItem(last_node)\n                    || last_node.type === this.TYPE_ENUMS.Keyword\n                    || last_node.type === this.TYPE_ENUMS.Punctuator && !(/^\\{\\}|\\(\\)|\\[\\]$/.test(last_node.value));\n            }\n            else {\n                return true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    //token_hooks: Record<string, (token: Token, tokenizer?: Tokenizer) => Token> = token_hooks;\n    default_1.prototype.err = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.error_logs.push.apply(this.error_logs, args);\n    };\n    default_1.prototype.parse = function (input) {\n        return this.parseScript(input);\n    };\n    default_1.prototype.parseModule = function (input) {\n        var tokens = this._parse(input, 13 /* isModule */, true, 12 /* strict */, true);\n        var module = new Module(tokens);\n        if (tokens.length) {\n            head_1.attachLocation(module, tokens[0], tokens[tokens.length - 1]);\n        }\n        return module;\n    };\n    default_1.prototype.parseScript = function (input) {\n        var tokens = this._parse(input);\n        var script = new Script(tokens);\n        if (tokens.length) {\n            head_1.attachLocation(module, tokens[0], tokens[tokens.length - 1]);\n        }\n        return script;\n    };\n    default_1.prototype.parseExpression = function (context) {\n        context.wrap(14 /* isExpression */, true);\n        var res = this.parseNode(this.EXPRESSION_TREE, context, this.isExpression);\n        context.unwrap();\n        return res;\n    };\n    default_1.prototype.parseNode = function (match_tree, context, test) {\n        var tokens = context.tokens;\n        this.parseCustom(match_tree, context);\n        var res;\n        if (tokens.length) {\n            var index = 0;\n            if (test(tokens[0])) {\n                index = 1;\n                res = tokens[0];\n            }\n            if (tokens.length > index) {\n                this.err.apply(this, tokens.slice(index));\n            }\n        }\n        return res;\n    };\n    default_1.prototype.parseRangeAsNode = function (match_tree, context, left, lexcal_terminator, test) {\n        var res = this.parseRange(match_tree, context, left, lexcal_terminator, test);\n        if (!res.content) {\n            this.err(res);\n        }\n        return res.content;\n    };\n    default_1.prototype.parseRangeAsExpression = function (context, left, lexcal_terminator) {\n        context.wrap(14 /* isExpression */, true);\n        var res = this.parseRangeAsNode(this.EXPRESSION_TREE, context, left, lexcal_terminator, this.isExpression);\n        context.unwrap();\n        return res;\n    };\n    default_1.prototype._parse = function (input) {\n        var environments = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            environments[_i - 1] = arguments[_i];\n        }\n        //this.logs = [];\n        this.match_tree_stack = [];\n        this.context_stack = [];\n        this.init(input);\n        var context = head_1._Context(this);\n        environments.length && context.store.apply(context, environments);\n        //this.parseBlock(context);\n        var tokens = context.tokens;\n        this.parseCustom(this.SYNTAX_TREE, context);\n        if (tokens.length) {\n            if (!this.isStatementListItem(tokens[tokens.length - 1])) {\n                this.err(tokens.pop());\n            }\n        }\n        if (this.error_logs.length) {\n            console.warn(\"error:\", this.error_logs);\n        }\n        //console.log(\"logs:\", this.logs);\n        return this.tokens;\n    };\n    default_1.prototype.parseCustom = function (root, context, begin, test) {\n        if (begin === void 0) { begin = 0; }\n        var point = context.store(6 /* begin */, begin);\n        var cursor = begin - 1;\n        var backflow_tape = new Array(begin);\n        backflow_tape.push(cursor);\n        var extreme;\n        var state;\n        this.context_stack.unshift(context);\n        this.match_tree_stack.unshift(root);\n        while (true) {\n            if (cursor < begin || context.getToken(cursor)) {\n                if (!(extreme\n                    && (extreme[2 /* right */] < cursor\n                        && backflow_tape.length <= 3 + extreme[2 /* right */]\n                    //匹配边界断句\n                    )\n                    && ((state = this.finallize(context, extreme))\n                        || (extreme = undefined)))) {\n                    var longest = this.walk(root, context, cursor, backflow_tape, extreme === null || extreme === void 0 ? void 0 : extreme[2 /* right */]);\n                    //longest && this.logs.push(\"walk\", longest[MATCHED_RECORDS.left], longest[MATCHED_RECORDS.right], longest[MATCHED_RECORDS.matched][MATCHED.wrapper].name);\n                    if (longest) {\n                        var longest_precedence = longest[0 /* precedence */];\n                        var extreme_precedence = extreme && extreme[0 /* precedence */];\n                        if (( //如果该记录优先级为true，则立即处理\n                        longest_precedence[0 /* VALUE */] !== true\n                            || (extreme = longest, false)) && (!extreme_precedence\n                            || !(extreme_precedence[0 /* VALUE */] > longest_precedence[0 /* VALUE */]\n                                || extreme_precedence[1 /* RIGHT_ASSOCIATIVE */] === longest_precedence[0 /* VALUE */] //左结合\n                            )) || !(state = this.finallize(context, extreme))) {\n                            extreme = longest;\n                            //cursor += 1;\n                            //也可以单步步进，不过这样更效率一些也和当前收集器无冲突\n                            cursor += longest[2 /* right */] - longest[1 /* left */] || 1;\n                            continue;\n                        }\n                    }\n                    else {\n                        cursor += 1;\n                        continue;\n                    }\n                }\n            }\n            else if (!(extreme\n                && (state = this.finallize(context, extreme)))) {\n                break;\n            }\n            if (extreme) {\n                if (test\n                    && extreme[1 /* left */] <= begin\n                    && test(context.getToken(begin))) {\n                    context.restore(point);\n                    this.context_stack.shift();\n                    this.match_tree_stack.shift();\n                    return context.getToken(begin);\n                }\n                cursor = extreme[1 /* left */];\n            }\n            cursor >= begin && state !== -1 && (cursor = backflow_tape[cursor]);\n            state = 0;\n            extreme = undefined;\n            backflow_tape.splice(cursor + 1, backflow_tape.length - (cursor + 1));\n        }\n        this.context_stack.shift();\n        this.match_tree_stack.shift();\n        context.restore(point);\n    };\n    default_1.prototype.parseRange = function (match_tree, context, left, lexcal_terminator, test) {\n        var tokens = context.tokens;\n        this.terminator_stack.unshift(lexcal_terminator);\n        this.parseCustom(match_tree, context, left + 1);\n        this.terminator_stack.shift();\n        var before_token = tokens[left];\n        var after_token = tokens[tokens.length - 1];\n        var value = before_token.value;\n        var end = tokens.length - 1;\n        if (lexcal_terminator(after_token)) {\n            value += after_token.value;\n        }\n        else {\n            end += 1;\n            this.err(before_token);\n        }\n        var content = null, next = left + 1;\n        if (test) {\n            if (test(tokens[next])) {\n                content = tokens[next];\n                next += 1;\n            }\n            if (next < end) {\n                this.err.apply(this, this.tokens.splice(next, end - next));\n            }\n        }\n        else {\n            content = tokens.splice(next, end - next);\n        }\n        var res = {\n            type: this.TYPE_ENUMS.Punctuator,\n            value: value,\n            content: content\n        };\n        head_1.attachLocation(res, before_token, after_token);\n        tokens.splice(left, tokens.length - left, res);\n        return res;\n    };\n    default_1.prototype.walk = function (root, context, start, backflow_tape, minimum) {\n        var padding_token = this.padding_token;\n        var TYPE_ALIAS = this.TYPE_ALIAS;\n        var tokens = context.tokens;\n        var begin = context[6 /* begin */];\n        //let steps: Array<number> = [];\n        return explore(root, start);\n        function get_records(matched, end) {\n            if (!matched[5 /* filter */]\n                || matched[5 /* filter */](context, start, end)) {\n                return [\n                    matched[0 /* precedence */],\n                    start,\n                    end,\n                    matched\n                ];\n            }\n        }\n        function explore(parent, index) {\n            var res;\n            var matched;\n            if (parent[\" WAL\" /* WALKER */]) {\n                parent[\" WAL\" /* WALKER */](context, index - 1);\n            }\n            if (parent[\" TER\" /* TERMINAL */]) {\n                if (!(index - 1 <= minimum)) {\n                    matched = parent[\" END\" /* END */];\n                    if (matched && (res = get_records(matched, index - 1))) {\n                        minimum = index - 1;\n                    }\n                }\n                return res;\n            }\n            var token = index >= begin\n                ? context.getToken(index) || (index <= tokens.length && padding_token)\n                : padding_token;\n            if (!token) {\n                return;\n            }\n            var has_backflow = false;\n            if (backflow_tape.length <= index + 1) {\n                has_backflow = true;\n                backflow_tape.push(start);\n            }\n            var matched_node;\n            var alias = TYPE_ALIAS[token.type];\n            var cursor = 0, length = 1, type;\n            var longest;\n            var node;\n            var value_node, type_node;\n            if (alias) {\n                length = alias.length;\n                type = alias[cursor];\n            }\n            else {\n                type = token.type;\n            }\n            while (true) {\n                if (node = parent[type]) {\n                    res = undefined;\n                    if (!((value_node = node[token.value])\n                        && (res = explore(value_node, index + 1)))\n                        && !((type_node = node[\" TYPE\" /* TYPE_ONLY */])\n                            && (res = explore(type_node, index + 1)))\n                        && !(index <= minimum)) {\n                        if (matched = (matched_node = value_node) && matched_node[\" END\" /* END */]\n                            || (matched_node = type_node) && matched_node[\" END\" /* END */]) {\n                            if ((res = get_records(matched, index))) {\n                                minimum = index;\n                            }\n                            else if (has_backflow && index > start) {\n                                backflow_tape.splice(index + 1, backflow_tape.length - index - 1);\n                            }\n                        }\n                    }\n                    longest = res || longest;\n                }\n                if (++cursor >= length) {\n                    return longest;\n                }\n                else {\n                    type = alias[cursor];\n                }\n            }\n        }\n    };\n    default_1.prototype.createNode = function (context) {\n        var _a;\n        var left = context[2 /* left */];\n        var right = context[3 /* right */];\n        var matched = context[9 /* matched */];\n        var tokens = context.tokens;\n        var begin = context[6 /* begin */];\n        var node = new matched[2 /* wrapper */]();\n        var length = tokens.length;\n        var start = left, end = right < length ? right : length - 1;\n        var offset = left, key, pipes, nth;\n        var token, res;\n        context[0 /* collected */] = node;\n        function restore_volatility() {\n            context[2 /* left */] = left;\n            context[3 /* right */] = right;\n            context[9 /* matched */] = matched;\n            context[0 /* collected */] = node;\n        }\n        for (var _i = 0, _b = matched[1 /* props */]; _i < _b.length; _i++) {\n            var prop = _b[_i];\n            _a = prop, key = _a[0], nth = _a[1], pipes = _a[2];\n            if (key instanceof head_1.Mark) {\n                token = key.data(context, offset);\n                restore_volatility();\n                if (token === undefined) {\n                    continue;\n                }\n                key = key.key;\n            }\n            else {\n                token = offset >= begin && offset < length ? tokens[offset] : null;\n                for (var i in pipes) {\n                    res = pipes[i](context, token, offset);\n                    res === undefined || (token = res);\n                    restore_volatility();\n                }\n                if (key instanceof head_1.Cover) {\n                    if (key.value === null) {\n                        if (offset === start) {\n                            offset < end && (start = offset + 1);\n                        }\n                        else if (offset > begin && offset - 1 < end) {\n                            end = offset - 1;\n                        }\n                    }\n                    else if (offset < length && end < offset) {\n                        end = offset;\n                    }\n                    offset += 1;\n                    continue;\n                }\n                else if (offset < length && end < offset) {\n                    end = offset;\n                }\n                offset += 1;\n            }\n            if (nth <= 1) {\n                node[key] = nth === 0 ? token : [token];\n            }\n            else {\n                node[key].push(token);\n            }\n        }\n        start >= begin || (start = begin);\n        var start_token = tokens[start];\n        var end_token = tokens[end];\n        head_1.attachLocation(node, start_token, end_token);\n        context[4 /* start */] = start;\n        context[5 /* end */] = end;\n        return node;\n    };\n    default_1.prototype.getToken = function (index) {\n        return this.tokens.length > index ? this.tokens[index] : this.nextToken();\n    };\n    default_1.prototype.finallize = function (context, record) {\n        var left = record[1], right = record[2], matched = record[3] /*, steps*/;\n        var validator = matched[4 /* validator */];\n        var collected;\n        var start, end;\n        context[2 /* left */] = left;\n        context[3 /* right */] = right;\n        context[9 /* matched */] = matched;\n        var tokens = context.tokens;\n        var handler = matched[3 /* handler */];\n        //this.logs.push(\"finallize\", left, right, matched[MATCHED.wrapper].name);\n        if (!validator || (collected = validator(context)) === true) {\n            collected = this.createNode(context);\n            start = context[4 /* start */];\n            end = context[5 /* end */];\n            if (handler) {\n                collected = handler(context);\n            }\n        }\n        else if (collected) {\n            start = context[4 /* start */];\n            end = context[5 /* end */];\n        }\n        if (!collected) {\n            return collected === undefined || collected === false\n                ? 0\n                : (collected === null ? 1 : -1);\n        }\n        //debugger;\n        //this.logs.push(\"finallize\", collected);\n        var length = end - start + 1;\n        if (collected instanceof Array) {\n            tokens.splice.apply(tokens, __spreadArrays([start, length], collected));\n        }\n        else {\n            tokens.splice(start, length, collected);\n        }\n        return length;\n    };\n    return default_1;\n}(tokenizer_1.default));\nexports.default = default_1;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../astexplorer/website/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvcGFyc2VyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9tbnQvZC9Qcm9ncmFtRmlsZXMvR2l0SHViL0Rpc29uL2pzL3BhcnNlci50cz9lMjZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgVG9rZW5pemVyIGZyb20gXCIuL3Rva2VuaXplclwiXHJcbmltcG9ydCB7XHJcbiAgICBOb2RlUHJvcCxcclxuICAgIE1BVENIRUQsXHJcbiAgICBNYXRjaGVkLFxyXG4gICAgTUFUQ0hFRF9SRUNPUkRTLFxyXG4gICAgTWF0Y2hlZFJlY29yZHMsXHJcbiAgICBUb2tlbiwgTm9kZSwgUGlwZSxcclxuICAgIE1hcmsgYXMgTWFya0ludGVyZmFjZSxcclxuICAgIFNlYXJjaFRyZWUsIE5VTUVSSUNfVFlQRSwgQ29udGV4dCwgQ09OVEVYVCxcclxuICAgIFNvdXJjZUxvY2F0aW9uLFxyXG4gICAgUFJFQ0VERU5DRSwgUHJlY2VkZW5jZSwgVmFsaWRhdGUsIE1BUktTLCBNYXRjaFRyZWVcclxufSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XHJcblxyXG5pbXBvcnQgeyBfQ29udGV4dCwgVFlQRV9BTElBUywgTk9ERVMsIE1hcmssIENvdmVyLCBhdHRhY2hMb2NhdGlvbiB9IGZyb20gXCIuL3N5bnRheC9oZWFkXCI7XHJcblxyXG50eXBlIEV4dHJlbWUgPSBNYXRjaGVkUmVjb3JkcztcclxudHlwZSBMb25nZXN0ID0gTWF0Y2hlZFJlY29yZHM7XHJcblxyXG5jb25zdCB7IFNjcmlwdCwgTW9kdWxlIH0gPSBOT0RFUztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFRva2VuaXplciB7XHJcbiAgICBTWU5UQVhfVFJFRTogTWF0Y2hUcmVlO1xyXG4gICAgRVhQUkVTU0lPTl9UUkVFOiBNYXRjaFRyZWU7XHJcbiAgICBUWVBFX0FMSUFTOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4gPSBUWVBFX0FMSUFTO1xyXG4gICAgcGFkZGluZ190b2tlbjogVG9rZW4gPSB7XHJcbiAgICAgICAgdHlwZTogTUFSS1MuQk9VTkRBUlksXHJcbiAgICAgICAgdmFsdWU6IE1BUktTLkJPVU5EQVJZXHJcbiAgICB9O1xyXG4gICAgZXJyb3JfbG9nczogQXJyYXk8YW55PjtcclxuICAgIHNhdmVfY29tbWVudHMgPSBmYWxzZTtcclxuICAgIG1hdGNoX3RyZWVfc3RhY2s6IEFycmF5PE1hdGNoVHJlZT47XHJcbiAgICBjb250ZXh0X3N0YWNrOiBBcnJheTxDb250ZXh0PjtcclxuICAgIGlzRXhwcmVzc2lvbjogKHRva2VuOiBUb2tlbikgPT4gYm9vbGVhbjtcclxuICAgIGlzU3RhdGVtZW50OiAodG9rZW46IFRva2VuKSA9PiBib29sZWFuO1xyXG4gICAgaXNTdGF0ZW1lbnRMaXN0SXRlbTogKHRva2VuOiBUb2tlbikgPT4gYm9vbGVhbjtcclxuICAgIGdldCBpc19wcmltYXJ5X2V4cHJfc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbGFzdF9ub2RlOiBhbnkgPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdGF0ZW1lbnRMaXN0SXRlbShsYXN0X25vZGUpXHJcbiAgICAgICAgICAgICAgICB8fCBsYXN0X25vZGUudHlwZSA9PT0gdGhpcy5UWVBFX0VOVU1TLktleXdvcmRcclxuICAgICAgICAgICAgICAgIHx8IGxhc3Rfbm9kZS50eXBlID09PSB0aGlzLlRZUEVfRU5VTVMuUHVuY3R1YXRvciAmJiAhKC9eXFx7XFx9fFxcKFxcKXxcXFtcXF0kLy50ZXN0KGxhc3Rfbm9kZS52YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vdG9rZW5faG9va3M6IFJlY29yZDxzdHJpbmcsICh0b2tlbjogVG9rZW4sIHRva2VuaXplcj86IFRva2VuaXplcikgPT4gVG9rZW4+ID0gdG9rZW5faG9va3M7XHJcbiAgICBlcnIoLi4uYXJnczogYW55KSB7XHJcbiAgICAgICAgdGhpcy5lcnJvcl9sb2dzLnB1c2guYXBwbHkodGhpcy5lcnJvcl9sb2dzLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcbiAgICBwYXJzZShpbnB1dDogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY3JpcHQoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgcGFyc2VNb2R1bGUoaW5wdXQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLl9wYXJzZShpbnB1dCwgQ09OVEVYVC5pc01vZHVsZSwgdHJ1ZSwgQ09OVEVYVC5zdHJpY3QsIHRydWUpO1xyXG4gICAgICAgIGxldCBtb2R1bGUgPSBuZXcgTW9kdWxlKHRva2Vucyk7XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXR0YWNoTG9jYXRpb24obW9kdWxlLCB0b2tlbnNbMF0sIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kdWxlO1xyXG4gICAgfVxyXG4gICAgcGFyc2VTY3JpcHQoaW5wdXQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLl9wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgbGV0IHNjcmlwdCA9IG5ldyBTY3JpcHQodG9rZW5zKTtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBhdHRhY2hMb2NhdGlvbihtb2R1bGUsIHRva2Vuc1swXSwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY3JpcHQ7XHJcbiAgICB9XHJcbiAgICBwYXJzZUV4cHJlc3Npb24oY29udGV4dDogQ29udGV4dCk6IE5vZGUge1xyXG4gICAgICAgIGNvbnRleHQud3JhcChDT05URVhULmlzRXhwcmVzc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMucGFyc2VOb2RlKHRoaXMuRVhQUkVTU0lPTl9UUkVFLCBjb250ZXh0LCB0aGlzLmlzRXhwcmVzc2lvbik7XHJcbiAgICAgICAgY29udGV4dC51bndyYXAoKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcGFyc2VOb2RlKFxyXG4gICAgICAgIG1hdGNoX3RyZWU6IE1hdGNoVHJlZSxcclxuICAgICAgICBjb250ZXh0OiBDb250ZXh0LFxyXG4gICAgICAgIHRlc3Q6IChub2RlOiBOb2RlKSA9PiBib29sZWFuXHJcbiAgICApOiBOb2RlIHtcclxuICAgICAgICBsZXQgdG9rZW5zID0gY29udGV4dC50b2tlbnM7XHJcbiAgICAgICAgdGhpcy5wYXJzZUN1c3RvbShtYXRjaF90cmVlLCBjb250ZXh0KTtcclxuICAgICAgICBsZXQgcmVzOiBOb2RlO1xyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0KHRva2Vuc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHRva2Vuc1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVyciguLi50b2tlbnMuc2xpY2UoaW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcGFyc2VSYW5nZUFzTm9kZShcclxuICAgICAgICBtYXRjaF90cmVlOiBNYXRjaFRyZWUsXHJcbiAgICAgICAgY29udGV4dDogQ29udGV4dCxcclxuICAgICAgICBsZWZ0OiBudW1iZXIsXHJcbiAgICAgICAgbGV4Y2FsX3Rlcm1pbmF0b3I6IFZhbGlkYXRlLFxyXG4gICAgICAgIHRlc3Q6IChub2RlOiBOb2RlKSA9PiBib29sZWFuXHJcbiAgICApOiBOb2RlIHtcclxuICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZVJhbmdlKG1hdGNoX3RyZWUsIGNvbnRleHQsIGxlZnQsIGxleGNhbF90ZXJtaW5hdG9yLCB0ZXN0KTtcclxuICAgICAgICBpZiAoIXJlcy5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyKHJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXMuY29udGVudDtcclxuICAgIH1cclxuICAgIHBhcnNlUmFuZ2VBc0V4cHJlc3Npb24oXHJcbiAgICAgICAgY29udGV4dDogQ29udGV4dCxcclxuICAgICAgICBsZWZ0OiBudW1iZXIsXHJcbiAgICAgICAgbGV4Y2FsX3Rlcm1pbmF0b3I6IFZhbGlkYXRlLFxyXG4gICAgKTogTm9kZSB7XHJcbiAgICAgICAgY29udGV4dC53cmFwKENPTlRFWFQuaXNFeHByZXNzaW9uLCB0cnVlKTtcclxuICAgICAgICBsZXQgcmVzID0gdGhpcy5wYXJzZVJhbmdlQXNOb2RlKHRoaXMuRVhQUkVTU0lPTl9UUkVFLCBjb250ZXh0LCBsZWZ0LCBsZXhjYWxfdGVybWluYXRvciwgdGhpcy5pc0V4cHJlc3Npb24pO1xyXG4gICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHByaXZhdGUgX3BhcnNlKGlucHV0OiBzdHJpbmcsIC4uLmVudmlyb25tZW50czogQXJyYXk8bnVtYmVyIHwgYW55Pikge1xyXG4gICAgICAgIC8vdGhpcy5sb2dzID0gW107XHJcbiAgICAgICAgdGhpcy5tYXRjaF90cmVlX3N0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5jb250ZXh0X3N0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5pbml0KGlucHV0KTtcclxuICAgICAgICBsZXQgY29udGV4dCA9IF9Db250ZXh0KHRoaXMpO1xyXG4gICAgICAgIGVudmlyb25tZW50cy5sZW5ndGggJiYgY29udGV4dC5zdG9yZSguLi5lbnZpcm9ubWVudHMpO1xyXG4gICAgICAgIC8vdGhpcy5wYXJzZUJsb2NrKGNvbnRleHQpO1xyXG4gICAgICAgIGxldCB0b2tlbnMgPSBjb250ZXh0LnRva2VucztcclxuICAgICAgICB0aGlzLnBhcnNlQ3VzdG9tKFxyXG4gICAgICAgICAgICB0aGlzLlNZTlRBWF9UUkVFLFxyXG4gICAgICAgICAgICBjb250ZXh0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTdGF0ZW1lbnRMaXN0SXRlbSh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnIodG9rZW5zLnBvcCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lcnJvcl9sb2dzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJlcnJvcjpcIiwgdGhpcy5lcnJvcl9sb2dzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvZ3M6XCIsIHRoaXMubG9ncyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xyXG4gICAgfVxyXG4gICAgcGFyc2VDdXN0b20oXHJcbiAgICAgICAgcm9vdDogTWF0Y2hUcmVlLFxyXG4gICAgICAgIGNvbnRleHQ6IENvbnRleHQsXHJcbiAgICAgICAgYmVnaW46IG51bWJlciA9IDAsXHJcbiAgICAgICAgdGVzdD86IEZ1bmN0aW9uXHJcbiAgICApIHtcclxuICAgICAgICBsZXQgcG9pbnQgPSBjb250ZXh0LnN0b3JlKENPTlRFWFQuYmVnaW4sIGJlZ2luKTtcclxuICAgICAgICBsZXQgY3Vyc29yOiBudW1iZXIgPSBiZWdpbiAtIDE7XHJcbiAgICAgICAgbGV0IGJhY2tmbG93X3RhcGU6IEFycmF5PG51bWJlcj4gPSBuZXcgQXJyYXkoYmVnaW4pO1xyXG4gICAgICAgIGJhY2tmbG93X3RhcGUucHVzaChjdXJzb3IpO1xyXG4gICAgICAgIGxldCBleHRyZW1lOiBFeHRyZW1lO1xyXG4gICAgICAgIGxldCBzdGF0ZTogbnVtYmVyO1xyXG4gICAgICAgIHRoaXMuY29udGV4dF9zdGFjay51bnNoaWZ0KGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubWF0Y2hfdHJlZV9zdGFjay51bnNoaWZ0KHJvb3QpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJzb3IgPCBiZWdpbiB8fCBjb250ZXh0LmdldFRva2VuKGN1cnNvcikpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAhKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyZW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJlbWVbTUFUQ0hFRF9SRUNPUkRTLnJpZ2h0XSA8IGN1cnNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYmFja2Zsb3dfdGFwZS5sZW5ndGggPD0gMyArIGV4dHJlbWVbTUFUQ0hFRF9SRUNPUkRTLnJpZ2h0XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/ljLnphY3ovrnnlYzmlq3lj6VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUgPSB0aGlzLmZpbmFsbGl6ZShjb250ZXh0LCBleHRyZW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChleHRyZW1lID0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvbmdlc3QgPSB0aGlzLndhbGsoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Zsb3dfdGFwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmVtZT8uW01BVENIRURfUkVDT1JEUy5yaWdodF1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbG9uZ2VzdCAmJiB0aGlzLmxvZ3MucHVzaChcIndhbGtcIiwgbG9uZ2VzdFtNQVRDSEVEX1JFQ09SRFMubGVmdF0sIGxvbmdlc3RbTUFUQ0hFRF9SRUNPUkRTLnJpZ2h0XSwgbG9uZ2VzdFtNQVRDSEVEX1JFQ09SRFMubWF0Y2hlZF1bTUFUQ0hFRC53cmFwcGVyXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9uZ2VzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbG9uZ2VzdF9wcmVjZWRlbmNlID0gbG9uZ2VzdFtNQVRDSEVEX1JFQ09SRFMucHJlY2VkZW5jZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHRyZW1lX3ByZWNlZGVuY2UgPSBleHRyZW1lICYmIGV4dHJlbWVbTUFUQ0hFRF9SRUNPUkRTLnByZWNlZGVuY2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLy/lpoLmnpzor6XorrDlvZXkvJjlhYjnuqfkuLp0cnVl77yM5YiZ56uL5Y2z5aSE55CGXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdF9wcmVjZWRlbmNlW1BSRUNFREVOQ0UuVkFMVUVdICE9PSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGV4dHJlbWUgPSBsb25nZXN0LCBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFleHRyZW1lX3ByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAhKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyZW1lX3ByZWNlZGVuY2VbUFJFQ0VERU5DRS5WQUxVRV0gPiBsb25nZXN0X3ByZWNlZGVuY2VbUFJFQ0VERU5DRS5WQUxVRV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZXh0cmVtZV9wcmVjZWRlbmNlW1BSRUNFREVOQ0UuUklHSFRfQVNTT0NJQVRJVkVdID09PSBsb25nZXN0X3ByZWNlZGVuY2VbUFJFQ0VERU5DRS5WQUxVRV0gLy/lt6bnu5PlkIhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHx8ICEoc3RhdGUgPSB0aGlzLmZpbmFsbGl6ZShjb250ZXh0LCBleHRyZW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmVtZSA9IGxvbmdlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2N1cnNvciArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy/kuZ/lj6/ku6XljZXmraXmraXov5vvvIzkuI3ov4fov5nmoLfmm7TmlYjnjofkuIDkupvkuZ/lkozlvZPliY3mlLbpm4blmajml6DlhrLnqoFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSBsb25nZXN0W01BVENIRURfUkVDT1JEUy5yaWdodF0gLSBsb25nZXN0W01BVENIRURfUkVDT1JEUy5sZWZ0XSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgIShcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW1lXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgKHN0YXRlID0gdGhpcy5maW5hbGxpemUoY29udGV4dCwgZXh0cmVtZSkpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV4dHJlbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgJiYgZXh0cmVtZVtNQVRDSEVEX1JFQ09SRFMubGVmdF0gPD0gYmVnaW5cclxuICAgICAgICAgICAgICAgICAgICAmJiB0ZXN0KGNvbnRleHQuZ2V0VG9rZW4oYmVnaW4pKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRfc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoX3RyZWVfc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRUb2tlbihiZWdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSBleHRyZW1lW01BVENIRURfUkVDT1JEUy5sZWZ0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJzb3IgPj0gYmVnaW4gJiYgc3RhdGUgIT09IC0xICYmIChjdXJzb3IgPSBiYWNrZmxvd190YXBlW2N1cnNvcl0pO1xyXG4gICAgICAgICAgICBzdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgIGV4dHJlbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGJhY2tmbG93X3RhcGUuc3BsaWNlKGN1cnNvciArIDEsIGJhY2tmbG93X3RhcGUubGVuZ3RoIC0gKGN1cnNvciArIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250ZXh0X3N0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgdGhpcy5tYXRjaF90cmVlX3N0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKHBvaW50KTtcclxuICAgIH1cclxuICAgIHBhcnNlUmFuZ2UoXHJcbiAgICAgICAgbWF0Y2hfdHJlZTogTWF0Y2hUcmVlLFxyXG4gICAgICAgIGNvbnRleHQ6IENvbnRleHQsXHJcbiAgICAgICAgbGVmdDogbnVtYmVyLFxyXG4gICAgICAgIGxleGNhbF90ZXJtaW5hdG9yOiBWYWxpZGF0ZSxcclxuICAgICAgICB0ZXN0PzogKG5vZGU6IE5vZGUpID0+IGJvb2xlYW4sXHJcbiAgICApIHtcclxuICAgICAgICBsZXQgdG9rZW5zID0gY29udGV4dC50b2tlbnM7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdG9yX3N0YWNrLnVuc2hpZnQobGV4Y2FsX3Rlcm1pbmF0b3IpO1xyXG4gICAgICAgIHRoaXMucGFyc2VDdXN0b20oXHJcbiAgICAgICAgICAgIG1hdGNoX3RyZWUsXHJcbiAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgIGxlZnQgKyAxXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnRlcm1pbmF0b3Jfc3RhY2suc2hpZnQoKTtcclxuICAgICAgICBsZXQgYmVmb3JlX3Rva2VuID0gdG9rZW5zW2xlZnRdO1xyXG4gICAgICAgIGxldCBhZnRlcl90b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYmVmb3JlX3Rva2VuLnZhbHVlO1xyXG4gICAgICAgIGxldCBlbmQgPSB0b2tlbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobGV4Y2FsX3Rlcm1pbmF0b3IoYWZ0ZXJfdG9rZW4pKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IGFmdGVyX3Rva2VuLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCArPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmVycihiZWZvcmVfdG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udGVudDogYW55ID0gbnVsbCwgbmV4dCA9IGxlZnQgKyAxO1xyXG4gICAgICAgIGlmICh0ZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXN0KHRva2Vuc1tuZXh0XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0b2tlbnNbbmV4dF07XHJcbiAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5leHQgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyKC4uLnRoaXMudG9rZW5zLnNwbGljZShuZXh0LCBlbmQgLSBuZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gdG9rZW5zLnNwbGljZShuZXh0LCBlbmQgLSBuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlczogVG9rZW4gPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuVFlQRV9FTlVNUy5QdW5jdHVhdG9yLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgY29udGVudFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXR0YWNoTG9jYXRpb24ocmVzLCBiZWZvcmVfdG9rZW4sIGFmdGVyX3Rva2VuKTtcclxuICAgICAgICB0b2tlbnMuc3BsaWNlKGxlZnQsIHRva2Vucy5sZW5ndGggLSBsZWZ0LCByZXMpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICB3YWxrKFxyXG4gICAgICAgIHJvb3Q6IE1hdGNoVHJlZSxcclxuICAgICAgICBjb250ZXh0OiBDb250ZXh0LFxyXG4gICAgICAgIHN0YXJ0OiBudW1iZXIsXHJcbiAgICAgICAgYmFja2Zsb3dfdGFwZTogQXJyYXk8bnVtYmVyPixcclxuICAgICAgICBtaW5pbXVtOiBudW1iZXJcclxuICAgICk6IExvbmdlc3Qge1xyXG4gICAgICAgIGxldCBwYWRkaW5nX3Rva2VuID0gdGhpcy5wYWRkaW5nX3Rva2VuO1xyXG4gICAgICAgIGxldCBUWVBFX0FMSUFTID0gdGhpcy5UWVBFX0FMSUFTO1xyXG4gICAgICAgIGxldCB0b2tlbnMgPSBjb250ZXh0LnRva2VucztcclxuICAgICAgICBsZXQgYmVnaW4gPSBjb250ZXh0W0NPTlRFWFQuYmVnaW5dO1xyXG4gICAgICAgIC8vbGV0IHN0ZXBzOiBBcnJheTxudW1iZXI+ID0gW107XHJcbiAgICAgICAgcmV0dXJuIGV4cGxvcmUoXHJcbiAgICAgICAgICAgIHJvb3QsXHJcbiAgICAgICAgICAgIHN0YXJ0XHJcbiAgICAgICAgKTtcclxuICAgICAgICBmdW5jdGlvbiBnZXRfcmVjb3JkcyhtYXRjaGVkOiBNYXRjaGVkLCBlbmQ6IG51bWJlcik6IE1hdGNoZWRSZWNvcmRzIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgIW1hdGNoZWRbTUFUQ0hFRC5maWx0ZXJdXHJcbiAgICAgICAgICAgICAgICB8fCBtYXRjaGVkW01BVENIRUQuZmlsdGVyXShjb250ZXh0LCBzdGFydCwgZW5kKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFtNQVRDSEVELnByZWNlZGVuY2VdLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZCxcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGV4cGxvcmUocGFyZW50OiBNYXRjaFRyZWUsIGluZGV4OiBudW1iZXIpOiBMb25nZXN0IHtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXM6IExvbmdlc3Q7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVkOiBNYXRjaGVkO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50W01BUktTLldBTEtFUl0pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtNQVJLUy5XQUxLRVJdKGNvbnRleHQsIGluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudFtNQVJLUy5URVJNSU5BTF0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGluZGV4IC0gMSA8PSBtaW5pbXVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBwYXJlbnRbTUFSS1MuRU5EXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCAmJiAocmVzID0gZ2V0X3JlY29yZHMobWF0Y2hlZCwgaW5kZXggLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bSA9IGluZGV4IC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgdG9rZW4gPSBpbmRleCA+PSBiZWdpblxyXG4gICAgICAgICAgICAgICAgPyBjb250ZXh0LmdldFRva2VuKGluZGV4KSB8fCAoaW5kZXggPD0gdG9rZW5zLmxlbmd0aCAmJiBwYWRkaW5nX3Rva2VuKVxyXG4gICAgICAgICAgICAgICAgOiBwYWRkaW5nX3Rva2VuO1xyXG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGhhc19iYWNrZmxvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYmFja2Zsb3dfdGFwZS5sZW5ndGggPD0gaW5kZXggKyAxKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNfYmFja2Zsb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYmFja2Zsb3dfdGFwZS5wdXNoKHN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbWF0Y2hlZF9ub2RlOiBNYXRjaFRyZWU7XHJcbiAgICAgICAgICAgIGxldCBhbGlhcyA9IFRZUEVfQUxJQVNbdG9rZW4udHlwZV07XHJcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSAwLCBsZW5ndGggPSAxLCB0eXBlOiBzdHJpbmcgfCBudW1iZXI7XHJcbiAgICAgICAgICAgIGxldCBsb25nZXN0OiBMb25nZXN0O1xyXG4gICAgICAgICAgICBsZXQgbm9kZTogTWF0Y2hUcmVlO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWVfbm9kZTogTWF0Y2hUcmVlLCB0eXBlX25vZGU6IE1hdGNoVHJlZTtcclxuICAgICAgICAgICAgaWYgKGFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBhbGlhcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gYWxpYXNbY3Vyc29yXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0b2tlbi50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9IHBhcmVudFt0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICEoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsdWVfbm9kZSA9IG5vZGVbdG9rZW4udmFsdWVdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHJlcyA9IGV4cGxvcmUodmFsdWVfbm9kZSwgaW5kZXggKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVfbm9kZSA9IG5vZGVbTUFSS1MuVFlQRV9PTkxZXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChyZXMgPSBleHBsb3JlKHR5cGVfbm9kZSwgaW5kZXggKyAxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhKGluZGV4IDw9IG1pbmltdW0pXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSAobWF0Y2hlZF9ub2RlID0gdmFsdWVfbm9kZSkgJiYgbWF0Y2hlZF9ub2RlW01BUktTLkVORF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChtYXRjaGVkX25vZGUgPSB0eXBlX25vZGUpICYmIG1hdGNoZWRfbm9kZVtNQVJLUy5FTkRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXMgPSBnZXRfcmVjb3JkcyhtYXRjaGVkLCBpbmRleCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc19iYWNrZmxvdyAmJiBpbmRleCA+IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2Zsb3dfdGFwZS5zcGxpY2UoaW5kZXggKyAxLCBiYWNrZmxvd190YXBlLmxlbmd0aCAtIGluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdCA9IHJlcyB8fCBsb25nZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCsrY3Vyc29yID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb25nZXN0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYWxpYXNbY3Vyc29yXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZU5vZGUoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgIGxldCBsZWZ0ID0gY29udGV4dFtDT05URVhULmxlZnRdO1xyXG4gICAgICAgIGxldCByaWdodCA9IGNvbnRleHRbQ09OVEVYVC5yaWdodF07XHJcbiAgICAgICAgbGV0IG1hdGNoZWQgPSBjb250ZXh0W0NPTlRFWFQubWF0Y2hlZF07XHJcbiAgICAgICAgbGV0IHRva2VucyA9IGNvbnRleHQudG9rZW5zO1xyXG4gICAgICAgIGxldCBiZWdpbiA9IGNvbnRleHRbQ09OVEVYVC5iZWdpbl07XHJcbiAgICAgICAgbGV0IG5vZGU6IGFueSA9IG5ldyBtYXRjaGVkW01BVENIRUQud3JhcHBlcl0oKTtcclxuICAgICAgICBsZXQgbGVuZ3RoID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3RhcnQgPSBsZWZ0LCBlbmQgPSByaWdodCA8IGxlbmd0aCA/IHJpZ2h0IDogbGVuZ3RoIC0gMTtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gbGVmdCwga2V5OiBzdHJpbmcgfCBDb3ZlciB8IE1hcmssIHBpcGVzOiBBcnJheTxQaXBlPiwgbnRoOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHRva2VuOiBhbnksIHJlczogYW55O1xyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5jb2xsZWN0ZWRdID0gbm9kZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZV92b2xhdGlsaXR5KCkge1xyXG4gICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQubGVmdF0gPSBsZWZ0O1xyXG4gICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQucmlnaHRdID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5tYXRjaGVkXSA9IG1hdGNoZWQ7XHJcbiAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5jb2xsZWN0ZWRdID0gbm9kZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG1hdGNoZWRbTUFUQ0hFRC5wcm9wc10pIHtcclxuICAgICAgICAgICAgW2tleSwgbnRoLCBwaXBlc10gPSBwcm9wIGFzIGFueTtcclxuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hcmspIHtcclxuICAgICAgICAgICAgICAgIHRva2VuID0ga2V5LmRhdGEoY29udGV4dCwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHJlc3RvcmVfdm9sYXRpbGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IG9mZnNldCA+PSBiZWdpbiAmJiBvZmZzZXQgPCBsZW5ndGggPyB0b2tlbnNbb2Zmc2V0XSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBwaXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHBpcGVzW2ldKGNvbnRleHQsIHRva2VuLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9PT0gdW5kZWZpbmVkIHx8ICh0b2tlbiA9IHJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZV92b2xhdGlsaXR5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQ292ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPCBlbmQgJiYgKHN0YXJ0ID0gb2Zmc2V0ICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID4gYmVnaW4gJiYgb2Zmc2V0IC0gMSA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gb2Zmc2V0IC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0IDwgbGVuZ3RoICYmIGVuZCA8IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCBsZW5ndGggJiYgZW5kIDwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG50aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlW2tleV0gPSBudGggPT09IDAgPyB0b2tlbiA6IFt0b2tlbl07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlW2tleV0ucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0ID49IGJlZ2luIHx8IChzdGFydCA9IGJlZ2luKTtcclxuXHJcbiAgICAgICAgbGV0IHN0YXJ0X3Rva2VuID0gdG9rZW5zW3N0YXJ0XTtcclxuICAgICAgICBsZXQgZW5kX3Rva2VuID0gdG9rZW5zW2VuZF07XHJcbiAgICAgICAgYXR0YWNoTG9jYXRpb24obm9kZSwgc3RhcnRfdG9rZW4sIGVuZF90b2tlbik7XHJcbiAgICAgICAgY29udGV4dFtDT05URVhULnN0YXJ0XSA9IHN0YXJ0O1xyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5lbmRdID0gZW5kO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5sZW5ndGggPiBpbmRleCA/IHRoaXMudG9rZW5zW2luZGV4XSA6IHRoaXMubmV4dFRva2VuKCk7XHJcbiAgICB9XHJcbiAgICBmaW5hbGxpemUoXHJcbiAgICAgICAgY29udGV4dDogQ29udGV4dCxcclxuICAgICAgICByZWNvcmQ6IEV4dHJlbWVcclxuICAgICkge1xyXG4gICAgICAgIGxldCBbLCBsZWZ0LCByaWdodCwgbWF0Y2hlZC8qLCBzdGVwcyovXSA9IHJlY29yZDtcclxuICAgICAgICBsZXQgdmFsaWRhdG9yID0gbWF0Y2hlZFtNQVRDSEVELnZhbGlkYXRvcl07XHJcbiAgICAgICAgbGV0IGNvbGxlY3RlZDogYW55O1xyXG4gICAgICAgIGxldCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcjtcclxuICAgICAgICBjb250ZXh0W0NPTlRFWFQubGVmdF0gPSBsZWZ0O1xyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5yaWdodF0gPSByaWdodDtcclxuICAgICAgICBjb250ZXh0W0NPTlRFWFQubWF0Y2hlZF0gPSBtYXRjaGVkO1xyXG4gICAgICAgIGxldCB0b2tlbnMgPSBjb250ZXh0LnRva2VucztcclxuICAgICAgICBsZXQgaGFuZGxlciA9IG1hdGNoZWRbTUFUQ0hFRC5oYW5kbGVyXTtcclxuICAgICAgICAvL3RoaXMubG9ncy5wdXNoKFwiZmluYWxsaXplXCIsIGxlZnQsIHJpZ2h0LCBtYXRjaGVkW01BVENIRUQud3JhcHBlcl0ubmFtZSk7XHJcbiAgICAgICAgaWYgKCF2YWxpZGF0b3IgfHwgKGNvbGxlY3RlZCA9IHZhbGlkYXRvcihjb250ZXh0KSkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY29sbGVjdGVkID0gdGhpcy5jcmVhdGVOb2RlKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBzdGFydCA9IGNvbnRleHRbQ09OVEVYVC5zdGFydF07XHJcbiAgICAgICAgICAgIGVuZCA9IGNvbnRleHRbQ09OVEVYVC5lbmRdO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkID0gaGFuZGxlcihjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gY29udGV4dFtDT05URVhULnN0YXJ0XTtcclxuICAgICAgICAgICAgZW5kID0gY29udGV4dFtDT05URVhULmVuZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQgPT09IHVuZGVmaW5lZCB8fCBjb2xsZWN0ZWQgPT09IGZhbHNlXHJcbiAgICAgICAgICAgICAgICA/IDBcclxuICAgICAgICAgICAgICAgIDogKGNvbGxlY3RlZCA9PT0gbnVsbCA/IDEgOiAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vZGVidWdnZXI7XHJcbiAgICAgICAgLy90aGlzLmxvZ3MucHVzaChcImZpbmFsbGl6ZVwiLCBjb2xsZWN0ZWQpO1xyXG4gICAgICAgIGxldCBsZW5ndGggPSBlbmQgLSBzdGFydCArIDE7XHJcbiAgICAgICAgaWYgKGNvbGxlY3RlZCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2Uoc3RhcnQsIGxlbmd0aCwgLi4uY29sbGVjdGVkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKHN0YXJ0LCBsZW5ndGgsIGNvbGxlY3RlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFjQTtBQUtBO0FBR0E7QUFBQTtBQTZCQTtBQUFBO0FBMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFzQkE7QUFoQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../js/parser.ts\n");

/***/ }),

/***/ "../../js/syntax/declaration.ts":
/*!*****************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/declaration.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/syntax/head.ts\");\n//import { Expressions, UNIT_EXPRESSION_TREE } from './expression';\nvar Grouping = head_1.NODES.Grouping;\nfunction get_variable_declarator(context, id, init, range, loc) {\n    var parser = context[1 /* parser */];\n    if (id instanceof Grouping) {\n        parser.err(id);\n    }\n    else if (context[12 /* strict */]) {\n        init || head_1.validateBinding(context, id);\n    }\n    if (id.name === \"let\") {\n        var kind = context.tokens[context[6 /* begin */] - 1];\n        if (kind.value === \"let\" || kind.value === \"const\") {\n            parser.err(id);\n        }\n    }\n    return {\n        type: \"VariableDeclarator\",\n        id: id, init: init, range: range, loc: loc\n    };\n}\nvar VariableDeclarators = {\n    Success: {\n        handler: [\n            head_1.join_content,\n            function (context) {\n                var collected = context[0];\n                head_1.validateLineTerminator(context);\n                collected.content = head_1.join_content(context).content;\n                return collected;\n            }\n        ],\n        precedence: [true, 0],\n        collector: [\n            {\n                success: head_1._Or(\"Success\", \"\" /* BOUNDARY */),\n                content: head_1._Or(head_1._Pattern(\"Identifier\").pipe(function (context, identifier) {\n                    return get_variable_declarator(context, identifier, null, identifier.range, identifier.loc);\n                }), head_1._Pattern(\"AssignmentPattern\").pipe(function (context, pattern) {\n                    return get_variable_declarator(context, pattern.left, pattern.right, pattern.range, pattern.loc);\n                })),\n                _next: head_1._NonCollecting(\"Punctuator ,\"),\n            },\n            [\n                [\"type\", head_1._Mark(\"VariableDeclarators\")],\n                [\"_next\", head_1._Option(\"Punctuator ;\")]\n            ]\n        ]\n    }\n};\nvar VARIABLE_DECLARATOR_TREE;\nhead_1.async_getter.get(\"UNIT_EXPRESSION_TREE\", function (UNIT_EXPRESSION_TREE) {\n    VARIABLE_DECLARATOR_TREE = head_1.createMatchTree(VariableDeclarators, UNIT_EXPRESSION_TREE);\n});\nfunction reinterpreat_expression_as_declaration(context, expr) {\n    var collected = context[0], parser = context[1];\n    expr.type = collected.type;\n    if (expr.id) {\n        if (head_1.isRestrictedWord(expr.id.name)) {\n            parser.err(expr.id);\n        }\n    }\n    else {\n        parser.err(expr);\n    }\n    for (var key in expr) {\n        collected[key] = expr[key];\n    }\n    return expr.id;\n}\nvar Declarations = head_1.async_getter.Declarations = {\n    \"ClassDeclaration\": {\n        filter: function (context, left, right) {\n            var tokens = context.tokens;\n            return !(tokens[right] instanceof Grouping);\n        },\n        collector: [\n            {\n                _prev: head_1._NonCapturing(head_1.TOPLEVEL_ITEM_PATTERN),\n                id: head_1._Pattern(\"ClassExpression\").pipe(reinterpreat_expression_as_declaration)\n            }\n        ]\n    },\n    \"FunctionDeclaration\": {\n        filter: \"ClassDeclaration\",\n        collector: [\n            {\n                _prev: head_1._NonCapturing(head_1.TOPLEVEL_ITEM_PATTERN),\n                id: head_1._Pattern(\"FunctionExpression\").pipe(reinterpreat_expression_as_declaration)\n            }\n        ]\n    },\n    \"VariableDeclaration\": [\n        {\n            validator: [\n                function (context) {\n                    var parser = context[1], left = context[2];\n                    context.wrap(18 /* bindingElement */, true);\n                    var res = parser.parseCustom(VARIABLE_DECLARATOR_TREE, context, left + 1, function (node) { return node.type === \"VariableDeclarators\"; });\n                    context.unwrap();\n                    return res && 0;\n                },\n                null\n            ],\n            collector: [\n                {\n                    //_: _NonCapturing(TOPLEVEL_ITEM_PATTERN),\n                    kind: head_1._Or(\"Keyword var const let\", \"Identifier let\").pipe(function (context, token) {\n                        return token.name === undefined ? token.value : token.name;\n                    }),\n                    declarations: head_1._Or(\"Identifier\", \"Punctuator [ {\")\n                },\n                [\n                    [\"declarations\", head_1._Pattern(\"VariableDeclarators\").pipe(function (context, token) {\n                            return token.content;\n                        })],\n                ]\n            ]\n        }\n    ]\n};\nhead_1.async_getter.get(\"Declarations\", function (declarations) {\n    for (var type_name in declarations) {\n        type_name && (head_1.TYPE_ALIAS[type_name] = [type_name, \"[Declaration]\"]);\n    }\n});\nexports.default = Declarations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L2RlY2xhcmF0aW9uLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9tbnQvZC9Qcm9ncmFtRmlsZXMvR2l0SHViL0Rpc29uL2pzL3N5bnRheC9kZWNsYXJhdGlvbi50cz9mZDJiIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuaW1wb3J0IHtcclxuICAgIENvbnRleHQsIENPTlRFWFQsIFNvdXJjZUxvY2F0aW9uLCBOb2RlLCBUb2tlbiwgTUFSS1MsIE1hdGNoVHJlZVxyXG59IGZyb20gJy4uL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQge1xyXG4gICAgYXN5bmNfZ2V0dGVyLFxyXG4gICAgX1B1bmN0dWF0b3IsXHJcbiAgICBfS2V5d29yZCxcclxuICAgIF9JZGVudGlmaWVyLFxyXG4gICAgX1BhdHRlcm4sXHJcbiAgICBpc1Jlc3RyaWN0ZWRXb3JkLFxyXG4gICAgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOLFxyXG4gICAgVE9QTEVWRUxfSVRFTV9QQVRURVJOLFxyXG4gICAgX09wdGlvbiwgX09yLCBfU2VyaWVzLCBfTm9uQ29sbGVjdGluZywgX01hcmssIE5PREVTLCBUWVBFX0FMSUFTLFxyXG4gICAgdmFsaWRhdGVCaW5kaW5nLCB2YWxpZGF0ZUxpbmVUZXJtaW5hdG9yLCBjcmVhdGVNYXRjaFRyZWUsIGpvaW5fY29udGVudCwgX05vbkNhcHR1cmluZ1xyXG59IGZyb20gJy4vaGVhZCdcclxuLy9pbXBvcnQgeyBFeHByZXNzaW9ucywgVU5JVF9FWFBSRVNTSU9OX1RSRUUgfSBmcm9tICcuL2V4cHJlc3Npb24nO1xyXG5cclxubGV0IEdyb3VwaW5nID0gTk9ERVMuR3JvdXBpbmc7XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0X3ZhcmlhYmxlX2RlY2xhcmF0b3IoY29udGV4dDogQ29udGV4dCwgaWQ6IE5vZGUsIGluaXQ6IE5vZGUsIHJhbmdlOiBbbnVtYmVyLCBudW1iZXJdLCBsb2M6IFNvdXJjZUxvY2F0aW9uKTogTm9kZSB7XHJcbiAgICBsZXQgcGFyc2VyID0gY29udGV4dFtDT05URVhULnBhcnNlcl07XHJcbiAgICBpZiAoaWQgaW5zdGFuY2VvZiBHcm91cGluZykge1xyXG4gICAgICAgIHBhcnNlci5lcnIoaWQpO1xyXG4gICAgfSBlbHNlIGlmIChjb250ZXh0W0NPTlRFWFQuc3RyaWN0XSkge1xyXG4gICAgICAgIGluaXQgfHwgdmFsaWRhdGVCaW5kaW5nKGNvbnRleHQsIGlkKTtcclxuICAgIH0gaWYgKGlkLm5hbWUgPT09IFwibGV0XCIpIHtcclxuICAgICAgICBsZXQga2luZCA9IGNvbnRleHQudG9rZW5zW2NvbnRleHRbQ09OVEVYVC5iZWdpbl0gLSAxXTtcclxuICAgICAgICBpZiAoa2luZC52YWx1ZSA9PT0gXCJsZXRcIiB8fCBraW5kLnZhbHVlID09PSBcImNvbnN0XCIpIHtcclxuICAgICAgICAgICAgcGFyc2VyLmVycihpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFxyXG4gICAgICAgIGlkLCBpbml0LCByYW5nZSwgbG9jXHJcbiAgICB9O1xyXG59XHJcblxyXG5sZXQgVmFyaWFibGVEZWNsYXJhdG9ycyA9IHtcclxuICAgIFN1Y2Nlc3M6IHtcclxuICAgICAgICBoYW5kbGVyOiBbXHJcbiAgICAgICAgICAgIGpvaW5fY29udGVudCxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbY29sbGVjdGVkXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUxpbmVUZXJtaW5hdG9yKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLmNvbnRlbnQgPSBqb2luX2NvbnRlbnQoY29udGV4dCkuY29udGVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHByZWNlZGVuY2U6IFt0cnVlLCAwXSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX09yKFwiU3VjY2Vzc1wiLCBNQVJLUy5CT1VOREFSWSksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgX1BhdHRlcm4oXCJJZGVudGlmaWVyXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBpZGVudGlmaWVyOiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3ZhcmlhYmxlX2RlY2xhcmF0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllci5yYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLmxvY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX1BhdHRlcm4oXCJBc3NpZ25tZW50UGF0dGVyblwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgcGF0dGVybjogTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldF92YXJpYWJsZV9kZWNsYXJhdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4ucmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5yYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmxvY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBfbmV4dDogX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yICxcIiksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFtcInR5cGVcIiwgX01hcmsoXCJWYXJpYWJsZURlY2xhcmF0b3JzXCIpXSxcclxuICAgICAgICAgICAgICAgIFtcIl9uZXh0XCIsIF9PcHRpb24oXCJQdW5jdHVhdG9yIDtcIildXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5sZXQgVkFSSUFCTEVfREVDTEFSQVRPUl9UUkVFOiBNYXRjaFRyZWU7XHJcblxyXG5hc3luY19nZXR0ZXIuZ2V0KFxyXG4gICAgXCJVTklUX0VYUFJFU1NJT05fVFJFRVwiLFxyXG4gICAgZnVuY3Rpb24gKFVOSVRfRVhQUkVTU0lPTl9UUkVFOiBNYXRjaFRyZWUpIHtcclxuICAgICAgICBWQVJJQUJMRV9ERUNMQVJBVE9SX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoVmFyaWFibGVEZWNsYXJhdG9ycywgVU5JVF9FWFBSRVNTSU9OX1RSRUUpO1xyXG4gICAgfVxyXG4pO1xyXG5cclxuZnVuY3Rpb24gcmVpbnRlcnByZWF0X2V4cHJlc3Npb25fYXNfZGVjbGFyYXRpb24oY29udGV4dDogQ29udGV4dCwgZXhwcjogTm9kZSkge1xyXG4gICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgZXhwci50eXBlID0gY29sbGVjdGVkLnR5cGU7XHJcbiAgICBpZiAoZXhwci5pZCkge1xyXG4gICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKGV4cHIuaWQubmFtZSkpIHtcclxuICAgICAgICAgICAgcGFyc2VyLmVycihleHByLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnNlci5lcnIoZXhwcik7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gZXhwcikge1xyXG4gICAgICAgIGNvbGxlY3RlZFtrZXldID0gZXhwcltrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHIuaWQ7XHJcbn1cclxuXHJcbmNvbnN0IERlY2xhcmF0aW9uczogUmVjb3JkPHN0cmluZywgYW55PiA9IGFzeW5jX2dldHRlci5EZWNsYXJhdGlvbnMgPSB7XHJcbiAgICBcIkNsYXNzRGVjbGFyYXRpb25cIjogeyAvLzw9IENsYXNzRXhwcmVzc2lvblxyXG4gICAgICAgIGZpbHRlcihjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IHRva2VucyA9IGNvbnRleHQudG9rZW5zO1xyXG4gICAgICAgICAgICByZXR1cm4gISh0b2tlbnNbcmlnaHRdIGluc3RhbmNlb2YgR3JvdXBpbmcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFRPUExFVkVMX0lURU1fUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICBpZDogX1BhdHRlcm4oXCJDbGFzc0V4cHJlc3Npb25cIikucGlwZShyZWludGVycHJlYXRfZXhwcmVzc2lvbl9hc19kZWNsYXJhdGlvbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjoge1xyXG4gICAgICAgIGZpbHRlcjogXCJDbGFzc0RlY2xhcmF0aW9uXCIsXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFRPUExFVkVMX0lURU1fUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICBpZDogX1BhdHRlcm4oXCJGdW5jdGlvbkV4cHJlc3Npb25cIikucGlwZShyZWludGVycHJlYXRfZXhwcmVzc2lvbl9hc19kZWNsYXJhdGlvbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yOiBbXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBbLCBwYXJzZXIsIGxlZnRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LndyYXAoQ09OVEVYVC5iaW5kaW5nRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHBhcnNlci5wYXJzZUN1c3RvbShcclxuICAgICAgICAgICAgICAgICAgICAgICAgVkFSSUFCTEVfREVDTEFSQVRPUl9UUkVFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICsgMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGU6IE5vZGUpID0+IG5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JzXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcyAmJiAwO1xyXG4gICAgICAgICAgICAgICAgfSwgbnVsbFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL186IF9Ob25DYXB0dXJpbmcoVE9QTEVWRUxfSVRFTV9QQVRURVJOKSxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBfT3IoXCJLZXl3b3JkIHZhciBjb25zdCBsZXRcIiwgXCJJZGVudGlmaWVyIGxldFwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZSA9PT0gdW5kZWZpbmVkID8gdG9rZW4udmFsdWUgOiB0b2tlbi5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUHVuY3R1YXRvciBbIHtcIlxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgW1wiZGVjbGFyYXRpb25zXCIsIF9QYXR0ZXJuKFwiVmFyaWFibGVEZWNsYXJhdG9yc1wiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uY29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICldLFxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5cclxufTtcclxuYXN5bmNfZ2V0dGVyLmdldChcIkRlY2xhcmF0aW9uc1wiLCBmdW5jdGlvbiAoZGVjbGFyYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICBmb3IgKGNvbnN0IHR5cGVfbmFtZSBpbiBkZWNsYXJhdGlvbnMpIHtcclxuICAgICAgICB0eXBlX25hbWUgJiYgKFRZUEVfQUxJQVNbdHlwZV9uYW1lXSA9IFt0eXBlX25hbWUsIFwiW0RlY2xhcmF0aW9uXVwiXSk7XHJcbiAgICB9XHJcblxyXG59KVxyXG5leHBvcnQgZGVmYXVsdCBEZWNsYXJhdGlvbnM7XHJcbiJdLCJtYXBwaW5ncyI6Ijs7QUFLQTtBQVlBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFPQTtBQUlBO0FBT0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../js/syntax/declaration.ts\n");

/***/ }),

/***/ "../../js/syntax/expression.ts":
/*!****************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/expression.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse_params = exports.parseObjectPattern = exports.parseArrayPattern = exports.Expressions = exports.PrimaryExpressions = void 0;\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/syntax/head.ts\");\nvar pattern_1 = __webpack_require__(/*! ./pattern */ \"../../js/syntax/pattern.ts\");\nObject.defineProperty(exports, \"parseArrayPattern\", { enumerable: true, get: function () { return pattern_1.parseArrayPattern; } });\nObject.defineProperty(exports, \"parseObjectPattern\", { enumerable: true, get: function () { return pattern_1.parseObjectPattern; } });\nvar Grouping = head_1.NODES.Grouping;\ninit_token_hooks();\nfunction walk_primary_expression(context, index) {\n    context[1 /* parser */].parseRange(PRIMARY_EXPRESSION_TREE, context, index, head_1.is_right_parentheses);\n}\nvar ARGUMENTS_PATTERN = head_1._Or(head_1._Punctuator(\"(\").walk(walk_primary_expression), \"Punctuator ()\").pipe(function (context, token, index) {\n    var parser = context[1 /* parser */];\n    var store = context.store(18 /* bindingElement */, false, 19 /* spreadElement */, true, 7 /* tokens */, token.content);\n    var res = parser.parseNode(ARGUMENTS_TREE, context, function (node) { return node.type === \"Success\"; });\n    context.restore(store);\n    return res ? res.content : [];\n});\nvar PARAMS_PATTERN = head_1._Or(head_1._Punctuator(\"(\").walk(function (context, left) {\n    var parser = context[1 /* parser */];\n    var store = context.store(18 /* bindingElement */, true, 19 /* spreadElement */, true, 10 /* bindingSet */, []);\n    parser.parseRange(PARAMS_TREE, context, left, head_1.is_right_parentheses, function (node) { return node.type === \"Success\"; }).type = \"Params\";\n    context.restore(store);\n}), head_1._Pattern(\"Params\")).pipe(function (context, token, left) {\n    var collected = context[0], parser = context[1];\n    var kind = collected.kind;\n    var params = token.content ? token.content.content : [];\n    var params_count = kind === \"get\" ? 0 : kind === \"set\" ? 1 : false;\n    if (params_count !== false && params.length !== params_count) {\n        parser.err.apply(parser, params.splice(params_count, params.length - params_count));\n    }\n    return params;\n});\nvar BODY_PATTERN = head_1._Or(head_1._Punctuator(\"{\").walk(function (context, left) {\n    var generator = !!this.generator, async = !!this.async;\n    var parser = context[1 /* parser */];\n    var body_context = head_1._Context(parser);\n    body_context[15 /* inFunctionBody */] = left + 1;\n    body_context[12 /* strict */] = context[12 /* strict */];\n    body_context[21 /* allowYield */] = generator;\n    body_context[20 /* allowAwait */] = async;\n    var node = parser.parseRange(parser.SYNTAX_TREE, body_context, left, head_1.is_right_braces);\n    node.type = \"Body\";\n    node.generator = generator;\n    node.async = async;\n    var block = new head_1.NODES.BlockStatement();\n    block.body = node.content;\n    head_1.attachLocation(block, node);\n    node.content = block;\n}, true), \"Body\");\nvar FUNCTION_BODY_PATTERN = head_1._Or(BODY_PATTERN).pipe(function (context, token) {\n    return token.content;\n});\nvar PrimaryExpressions = {\n    \"\": [\n        {\n            collector: {\n                type: head_1._Mark(\"Punctuator\"),\n                value: head_1._Mark(\"{}\"),\n                content: head_1._Punctuator(\"{\").pipe(function (context, token, left) {\n                    return context[1 /* parser */].parseRange(PROPERTIES_TREE, context, left, head_1.is_right_braces).content || [];\n                })\n            }\n        },\n        {\n            collector: {\n                type: head_1._Mark(\"Punctuator\"),\n                value: head_1._Mark(\"()\"),\n                content: head_1._Punctuator(\"(\").walk(walk_primary_expression).pipe(function (context, token, index) {\n                    return token.content;\n                })\n            }\n        },\n        {\n            collector: {\n                type: head_1._Mark(\"Punctuator\"),\n                value: head_1._Mark(\"[]\"),\n                content: head_1._Punctuator(\"[\").pipe(function (context, node, index) {\n                    return context[1 /* parser */].parseRange(PRIMARY_EXPRESSION_TREE, context, index, head_1.is_right_brackets).content;\n                })\n            }\n        },\n    ],\n    \"Identifier\": [],\n    \"Literal\": [ //已在 tokenizer => token_hooks 中处理\n    ],\n    \"ThisExpression\": {\n        collector: {\n            token: head_1._NonCollecting(\"Keyword this\")\n        }\n    },\n    \"TemplateLiteral\": {\n        filter: function (context, left, right) {\n            var value = context.getToken(right).value;\n            return value[0] === \"`\";\n        },\n        collector: [\n            {\n                _: head_1._NonCapturing(head_1._Option(\"[Expression]\")),\n                expressions: head_1._Mark(function () { return []; }),\n                quasis: head_1._Pattern(\"Template\").pipe(function (context, token, index) {\n                    var collected = context[0], parser = context[1];\n                    var value;\n                    var expressions = collected.expressions;\n                    var quasis = [];\n                    var tail = false;\n                    var end;\n                    while (true) {\n                        token = context.getToken(index);\n                        value = token.value;\n                        token.value = \"\";\n                        if (value[value.length - 1] === \"`\") {\n                            end = -1;\n                            tail = true;\n                        }\n                        else {\n                            end = -2;\n                            tail = false;\n                        }\n                        quasis.push({\n                            type: \"TemplateElement\",\n                            value: {\n                                raw: value.slice(1, end),\n                                cooked: parser._volatility\n                            },\n                            tail: tail\n                        });\n                        if (tail) {\n                            break;\n                        }\n                        expressions.push(parser.parseRangeAsExpression(context, index, function (token) {\n                            return token.type === parser.TYPE_ENUMS.Template\n                                && token.value[0] === \"}\";\n                        }));\n                    }\n                    return quasis;\n                }),\n            }\n        ]\n    },\n    \"FunctionExpression\": [\n        {\n            collector: [\n                {\n                    async: head_1._Or(head_1._Series(head_1._Mark(true), head_1._NonCollecting(\"Keyword async\")), head_1._Mark(false)),\n                    __: head_1._NonCollecting(\"Keyword function\"),\n                    generator: head_1._Or(head_1._Series(head_1._Mark(true), head_1._NonCollecting(\"Punctuator *\")), head_1._Mark(false)),\n                    id: head_1._Or(head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, head_1._Mark(null)),\n                    params: PARAMS_PATTERN,\n                    body: FUNCTION_BODY_PATTERN,\n                    expression: head_1._Mark(false)\n                }\n            ]\n        },\n        {\n            validator: function (context) {\n                var parser = context[1], left = context[2];\n                context[4 /* start */] = context[5 /* end */] = left;\n                return head_1.reinterpretIdentifierAsKeyword(context.getToken(left));\n                //return parser.parseKeyword(context.getToken(left));\n            },\n            filter: [\n                function () {\n                    return false;\n                },\n                head_1.isAligned\n            ],\n            collector: [\n                { _: head_1._Series(\"Identifier async\", \"Identifier\") },\n                {\n                    async: \"Identifier async\",\n                    _next: head_1._NonCapturing(\"Keyword function\"),\n                },\n                {\n                    async: \"Identifier async\",\n                    params: head_1._NonCapturing(head_1._Punctuator(\"(\").walk(walk_primary_expression), \"Punctuator ()\", \"Identifier\"),\n                    token: head_1._NonCapturing(\"Punctuator =>\"),\n                },\n            ]\n        }\n    ],\n    \"ArrowFunctionExpression\": {\n        handler: [\n            null,\n            function (context) {\n                var collected = context[0], parser = context[1], left = context[2], right = context[3];\n                var token = context.getToken(right);\n                token.value = \"_=>\";\n                var body_context = head_1._Context(parser);\n                body_context[12 /* strict */] = context[12 /* strict */];\n                body_context[20 /* allowAwait */] = collected.async;\n                if (parser.parseCustom(parser.EXPRESSION_TREE, body_context, left, function (node) { return true; })) {\n                    return null;\n                }\n            },\n            null\n        ],\n        precedence: [3, true, new Number(3)],\n        collector: [\n            {\n                async: head_1._Or(head_1._Series(head_1._Mark(true), head_1._NonCollecting(\"Keyword async\")), head_1._Mark(false)),\n                generator: head_1._Mark(false),\n                id: head_1._Mark(null),\n                params: head_1._Or(head_1._Punctuator(\"()\").pipe(function (context, token) {\n                    context.wrap(7 /* tokens */, token.content);\n                    var res = parse_params(context, token.content);\n                    context.unwrap();\n                    return res;\n                }), head_1._Pattern(\"Identifier\").pipe(function (context, token) {\n                    head_1.validateAssignment(context, token);\n                    return [token];\n                })),\n                token: head_1._NonCollecting(\"Punctuator =>\"),\n                body: FUNCTION_BODY_PATTERN,\n                expression: head_1._Mark(false)\n            },\n            [\"body\", head_1._Mark()],\n            [\n                //_=>作用为隔断匹配，使后续的表达式使用当前方法声明的环境\n                [\"token\", head_1._NonCollecting(\"Punctuator _=>\")],\n                [\"body\", \"[Expression]\"],\n                [\"expression\", head_1._Mark(true)]\n            ]\n        ]\n    },\n    \"ClassExpression\": {\n        collector: [\n            {\n                _: head_1._NonCollecting(\"Keyword class\"),\n                id: head_1._Or(head_1.IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, head_1._Mark(null)),\n                superClass: head_1._Or(head_1._Series(head_1._NonCollecting(\"Keyword extends\"), head_1.IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN), head_1._Mark(null)),\n                body: head_1._Punctuator(\"{\").pipe(function (context, token, left) {\n                    var _a;\n                    var parser = context[1 /* parser */];\n                    var res = parser.parseRange(METHOD_DEFINITIONS_TREE, context, left, head_1.is_right_braces, function (node) { return node.type === \"Success\"; });\n                    return {\n                        type: \"ClassBody\",\n                        body: ((_a = res.content) === null || _a === void 0 ? void 0 : _a.content) || [],\n                        range: res.range,\n                        loc: res.loc\n                    };\n                })\n            }\n        ]\n    },\n    \"Super\": {\n        validator: function (context) {\n            var parser = context[1], left = context[2], right = context[3];\n            if (!context[15 /* inFunctionBody */] || right === left) {\n                parser.err(context.getToken(left));\n            }\n            return true;\n        },\n        collector: {\n            token: head_1._NonCollecting(\"Keyword super\"),\n            _next: head_1._NonCapturing(\"Punctuator ( . [\")\n        }\n    },\n};\nexports.PrimaryExpressions = PrimaryExpressions;\nvar Expressions = head_1.async_getter.Expressions = __assign(__assign({}, PrimaryExpressions), { \"\": PrimaryExpressions[\"\"].concat({\n        validator: function (context) {\n            var parser = context[1 /* parser */];\n            var left = context[2 /* left */];\n            var token = context.getToken(left);\n            var store = context.store(10 /* bindingSet */, null, 18 /* bindingElement */, false, 7 /* tokens */, token.content);\n            var grouping = new Grouping(parser.parseExpression(context));\n            context.restore(store);\n            context[4 /* start */] = context[5 /* end */] = left;\n            return grouping;\n        },\n        collector: {\n            token: \"Punctuator ()\"\n        }\n    }), \"ArrayExpression\": {\n        precedence: 20,\n        collector: {\n            elements: head_1._Punctuator(\"[]\").pipe(function (context, node, index) {\n                var store = context.store(19 /* spreadElement */, true, 18 /* bindingElement */, false);\n                var res = head_1.parse_and_extract(ARRAY_ELEMENTS_TREE, context, node);\n                context.restore(store);\n                return res;\n            }),\n        }\n    }, \"ObjectExpression\": {\n        precedence: 20,\n        collector: {\n            properties: head_1._Punctuator(\"{}\").pipe(function (context, node, index) {\n                return head_1.parse_and_extract(OBJECT_PROPERTIES_TREE, context, node);\n                //return node.content || [];\n            }),\n        }\n    }, \"TaggedTemplateExpression\": {\n        collector: [\n            {\n                tag: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                quasi: \"TemplateLiteral\"\n            }\n        ]\n    }, \"MemberExpression\": [\n        {\n            precedence: 20,\n            collector: {\n                object: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                property: head_1._Series(head_1._NonCollecting(\"Punctuator .\"), head_1._Or(\"Identifier\", head_1._Pattern(\"Keyword\").pipe(function (context, token) {\n                    return head_1.reinterpretKeywordAsIdentifier(token);\n                    //return context[CONTEXT.parser].parseIdentifier(token);\n                }))),\n                computed: head_1._Mark(false)\n            }\n        },\n        {\n            filter: \"CallExpression\",\n            precedence: 20,\n            collector: {\n                object: head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\n                property: head_1._Or(head_1._Punctuator(\"[\").pipe(function (context, token, left) {\n                    var store = context.store(18 /* bindingElement */, false);\n                    var res = context[1 /* parser */].parseRangeAsExpression(context, left, head_1.is_right_brackets);\n                    context.restore(store);\n                    return res;\n                }), head_1._Punctuator(\"[]\").pipe(function (context, token, left) {\n                    var store = context.store(7 /* tokens */, token.content, 18 /* bindingElement */, false);\n                    var res = context[1 /* parser */].parseExpression(context);\n                    context.restore(store);\n                    return res;\n                })),\n                computed: head_1._Mark(true)\n            }\n        }\n    ], \"MetaProperty\": {\n        handler: function (_a) {\n            var collected = _a[0];\n            collected.meta.type = \"Identifier\";\n            return collected;\n        },\n        collector: [\n            {\n                meta: \"Keyword import\",\n                _: head_1._NonCollecting(\"Punctuator .\"),\n                property: \"Identifier meta\"\n            },\n            {\n                meta: \"Keyword new\",\n                _: head_1._NonCollecting(\"Punctuator .\"),\n                property: \"Identifier target\"\n            }\n        ]\n    }, \"NewExpression\": {\n        precedence: new Number(20) /*_Precedence(20, PRECEDENCE_FEATURES.RIGHT_TERMINAL)*/,\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword new\"),\n                callee: head_1._Or(head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, head_1._Pattern(\"ArrowFunctionExpression\").pipe(function (context, token) {\n                    context[1 /* parser */].err(token);\n                })),\n                arguments: head_1._Or(head_1._Mark(function () { return []; }), ARGUMENTS_PATTERN)\n            }\n        ]\n    }, \"CallExpression\": {\n        precedence: 20 /* _Precedence(20, PRECEDENCE_FEATURES.RIGHT_TERMINAL)*/,\n        filter: function (context, left) {\n            var tokens = context.tokens;\n            var first_token = tokens[left], second_token = tokens[left + 1];\n            if (second_token === context[8 /* rightAssociativeNode */]) {\n                return false;\n            }\n            var first_token_type = first_token.type;\n            if (first_token instanceof Grouping\n                || first_token_type !== \"ArrowFunctionExpression\") {\n                return true;\n            }\n        },\n        collector: {\n            callee: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n            arguments: ARGUMENTS_PATTERN\n        }\n    }, \"UpdateExpression\": [\n        {\n            handler: function (context) {\n                var collected = context[0];\n                collected.operator = collected.operator.value;\n                return collected;\n            },\n            precedence: 17,\n            collector: {\n                operator: \"Punctuator ++ --\",\n                argument: head_1._Or(\"MemberExpression\", head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\n                prefix: head_1._Mark(true),\n            }\n        },\n        {\n            validator: function (context) {\n                var collected = context[1 /* parser */].createNode(context);\n                collected.operator = collected.operator.value;\n                return collected;\n            },\n            filter: function (context, left, right) {\n                return head_1.isAligned(context, left, left + 1);\n            },\n            precedence: 18,\n            collector: {\n                argument: head_1._Or(\"MemberExpression\", head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\n                operator: \"Punctuator ++ --\",\n                prefix: head_1._Mark(false),\n                _: head_1._Option(head_1._NonCapturing(head_1._Punctuator(\"[\", \"(\").pipe(function (context, token) {\n                    context[8 /* rightAssociativeNode */] = token;\n                }), head_1._Punctuator(\".\").pipe(function (context, token) {\n                    context[1 /* parser */].err(token);\n                })))\n            }\n        }\n    ], \"AwaitExpression\": [\n        {\n            precedence: 17,\n            filter: function (context) {\n                return context[20 /* allowAwait */];\n            },\n            collector: {\n                token: head_1._NonCollecting(\"Keyword await\"),\n                argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN\n            }\n        },\n        {\n            handler: function (_a) {\n                var token = _a[0].token;\n                return head_1.reinterpretKeywordAsIdentifier(token);\n                //return parser.parseIdentifier(collected.token);\n            },\n            filter: function (context) {\n                return !context[20 /* allowAwait */];\n            },\n            collector: {\n                token: \"Keyword await\",\n            }\n        },\n    ], \"UnaryExpression\": {\n        handler: function (context) {\n            var collected = context[0];\n            collected.operator = collected.operator.value;\n            return collected;\n        },\n        precedence: 17,\n        collector: [\n            {\n                operator: head_1._Or(\"Punctuator ~ ! + -\", \"Keyword delete void typeof\"),\n                argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                prefix: head_1._Mark(true)\n            }\n        ]\n    }, \"BinaryExpression\": {\n        handler: function (context) {\n            var collected = context[0];\n            collected.operator = collected.operator.value;\n            return collected;\n        },\n        validator: function (context) {\n            return context[3 /* right */] - context[2 /* left */] >= 2;\n        },\n        precedence: [16, 15, 14, 13, 12, 11, 10, 9, 8, 7],\n        collector: [\n            {\n                left: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                operator: \"Punctuator **\",\n                right: head_1._Option(head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN)\n            },\n            [\"operator\", \"Punctuator * / %\"],\n            [\"operator\", \"Punctuator + -\"],\n            [\"operator\", \"Punctuator << >> >>>\"],\n            [\"operator\", head_1._Or(\"Punctuator < <= > >=\", \"Keyword in instanceof\")],\n            [\"operator\", \"Punctuator == != === !==\"],\n            [\"operator\", \"Punctuator &\"],\n            [\"operator\", \"Punctuator ^\"],\n            [\"operator\", \"Punctuator |\"],\n            [\"operator\", \"Punctuator ??\"]\n        ]\n    }, \"LogicalExpression\": {\n        validator: function (context) {\n            if (context[3 /* right */] - context[2 /* left */] === 2) {\n                var collected = context[1 /* parser */].createNode(context);\n                collected.operator = collected.operator.value;\n                return collected;\n            }\n        },\n        precedence: [6, 5],\n        collector: [\n            {\n                left: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                operator: \"Punctuator &&\",\n                right: head_1._Option(head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN)\n            },\n            [\"operator\", \"Punctuator ||\"]\n        ]\n    }, \"ConditionalExpression\": [\n        {\n            validator: function (context) {\n                var parser = context[1], left = context[2], right = context[3];\n                if (right - left >= 4) {\n                    return true;\n                }\n                if (!context[14 /* isExpression */] || context[18 /* bindingElement */]) {\n                    var store = context.store(14 /* isExpression */, true, 18 /* bindingElement */, null);\n                    parser.parseCustom(parser.EXPRESSION_TREE, context, left, function (node) { return node.type === \"ConditionalExpression\"; });\n                    context.restore(store);\n                    return null;\n                }\n            },\n            precedence: new Number(3),\n            collector: [\n                {\n                    test: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                    token: head_1._NonCollecting(\"Punctuator ?\")\n                },\n                [\"consequent\", head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN],\n                [\"_\", head_1._NonCollecting(\"Punctuator :\")],\n                [\"alternate\", head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN]\n            ]\n        },\n    ], \"YieldExpression\": [\n        {\n            /*filter(context: Context) {\n                return context[CONTEXT.allowYield];\n            },*/\n            precedence: 2,\n            collector: [\n                {\n                    token: head_1._NonCollecting(\"Keyword yield\"),\n                    _: head_1._NonCollecting(\"Punctuator *\"),\n                    argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                    delegate: head_1._Mark(true)\n                },\n                {\n                    token: head_1._NonCollecting(\"Keyword yield\"),\n                    argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                    delegate: head_1._Mark(false)\n                }\n            ]\n        },\n    ], \"AssignmentExpression\": {\n        validator: \"LogicalExpression\",\n        precedence: new Number(3),\n        collector: {\n            left: head_1._Or(head_1._Or(\"[Expression]\").pipe(function (context, expr) {\n                context[1 /* parser */].err(expr);\n            }), \"AssignmentExpression\", \"MemberExpression\", \"AssignmentPattern\", \"ArrayPattern\", \"ObjectPattern\", head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\n            operator: head_1.ASSIGNMENT_PUNCTUATORS_PATTERN,\n            right: head_1._Option(\"[Expression]\") //占位避免错误断句\n        }\n    }, \"SequenceExpression\": {\n        handler: function (context) {\n            var collected = context[0];\n            var expressions = collected.expressions;\n            if (expressions[0] instanceof head_1.NODES.SequenceExpression) {\n                expressions[0].expressions.push(expressions[1]);\n                collected.expressions = expressions[0].expressions;\n            }\n            return collected;\n        },\n        validator: function (context) {\n            var left = context[2], right = context[3];\n            if (right - left === 2) {\n                return true;\n            }\n        },\n        precedence: 1,\n        collector: {\n            expressions: head_1._Series(head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, head_1._NonCollecting(\"Punctuator ,\"), head_1._Option(head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN))\n        }\n    } });\nexports.Expressions = Expressions;\nvar COMPUTED_PROPERTY_NAME_PATTERN = head_1._Punctuator(\"[]\").pipe(function (context, token) {\n    var collected = context[0], parser = context[1];\n    collected.computed = true;\n    context.wrap(7 /* tokens */, token.content);\n    var res = parser.parseExpression(context);\n    context.unwrap();\n    return res;\n});\nvar LITERAL_PROPERTY_NAME_PATTERN = head_1._Or(\"Identifier\", \"Keyword\", \"Literal\").pipe(function (context, key) {\n    var parser = context[1];\n    if (key instanceof Grouping) {\n        parser.err(key);\n    }\n    else {\n        switch (key.type) {\n            case \"Keyword\":\n                return head_1.reinterpretKeywordAsIdentifier(key);\n            //return parser.parseIdentifier(key);\n            case \"Literal\":\n                if (key.regex) {\n                    parser.err(key);\n                }\n                break;\n        }\n    }\n});\nvar PROPERTY_NAME_PATTERN = head_1._Or(COMPUTED_PROPERTY_NAME_PATTERN, LITERAL_PROPERTY_NAME_PATTERN);\nvar MethodDefinitions = __assign(__assign({}, head_1._SuccessCollector(head_1._Pattern(\"MethodDefinition\"))), { \"\": {\n        validator: function (context) {\n            context[4 /* start */] = context[5 /* end */] = context[3 /* right */];\n            return [];\n        },\n        collector: {\n            _: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n            __: \"Punctuator ;\"\n        }\n    }, MethodDefinition: {\n        handler: function (context) {\n            var collected = context[0];\n            var value = collected.value;\n            collected.kind = value.kind;\n            delete value.kind;\n            collected.computed = value.computed;\n            delete value.computed;\n            collected.key = value.key;\n            delete value.key;\n            return collected;\n        },\n        collector: [\n            {\n                _prev: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n                key: head_1._Mark(\"\"),\n                static: head_1._Mark(true),\n                computed: head_1._Mark(false),\n                _static: head_1._NonCollecting(\"Identifier static\"),\n                value: \"FunctionExpression\",\n                kind: head_1._Mark(\"\"),\n            },\n            [\n                [\"static\", head_1._Mark(false)],\n                [\"_static\", head_1._Mark()]\n            ]\n        ]\n    }, FunctionExpression: {\n        collector: [\n            {\n                _prev: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n                static: head_1._Option(head_1._NonCapturing(\"Identifier static\")),\n                async: head_1._Or(head_1._Series(head_1._Mark(true), head_1._NonCollecting(\"Identifier async\")), head_1._Mark(false)),\n                generator: head_1._Or(head_1._Series(head_1._Mark(true), head_1._NonCollecting(\"Punctuator *\")), head_1._Mark(false)),\n                kind: head_1._Mark(\"method\"),\n                computed: head_1._Mark(false),\n                key: PROPERTY_NAME_PATTERN,\n                id: head_1._Mark(null),\n                params: PARAMS_PATTERN,\n                expression: head_1._Mark(false),\n                body: FUNCTION_BODY_PATTERN\n            },\n            [\n                [\"generator\", head_1._Mark(false)],\n                [\n                    \"kind\",\n                    head_1._Or(\"Identifier get set\").pipe(function (context, token, left) {\n                        return token.value;\n                    })\n                ]\n            ]\n        ]\n    } });\nvar Arguments = {\n    \"Success\": {\n        handler: head_1.join_content,\n        //precedence: 0,\n        collector: {\n            success: head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */), \"Success\"),\n            content: head_1._Or(\"SpreadElement\", head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN),\n            _: head_1._Or(head_1._NonCollecting(\"Punctuator ,\"), \"\" /* BOUNDARY */, head_1._NonCapturing(\"Punctuator )\")),\n        }\n    }\n};\nvar Params = {\n    \"Success\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            if (collected.content instanceof Grouping) {\n                parser.err(collected.content);\n            }\n            return head_1.join_content(context);\n        },\n        collector: [\n            {\n                success: head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */), \"Success\"),\n                content: \"AssignmentPattern\",\n                _: head_1._Or(head_1._NonCollecting(\"Punctuator ,\", \"\" /* BOUNDARY */), head_1._NonCapturing(\"Punctuator )\")),\n            },\n            [\n                \"content\",\n                head_1._Or(\"Identifier\").pipe(function (context, token) {\n                    head_1.validateBinding(context, token);\n                })\n            ],\n            [\"content\", head_1._Or(\"ArrayPattern\", \"ObjectPattern\")],\n            [\n                [\"content\", \"RestElement\"],\n                [\"_\", head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */), head_1._NonCapturing(\"Punctuator )\"))]\n            ]\n        ]\n    }\n};\nvar ArrayElements = {\n    \"Success\": {\n        handler: head_1.join_content,\n        precedence: 0,\n        collector: [\n            {\n                success: head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */), \"Success\"),\n                content: head_1._Or(\"SpreadElement\", head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN),\n                _: head_1._NonCollecting(\"Punctuator ,\", \"\" /* BOUNDARY */),\n            },\n            [\n                [\"content\", head_1._Mark(null)],\n                [\"_\", head_1._NonCollecting(\"Punctuator ,\")]\n            ]\n        ]\n    }\n};\nvar Properties = {\n    \"Property\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1], left = context[2], right = context[3];\n            var _a = collected.value, params = _a[0], body = _a[1];\n            var expr = new head_1.NODES.FunctionExpression();\n            expr.id = null;\n            expr.params = params;\n            expr.body = body.content;\n            expr.generator = body.generator;\n            expr.expression = false;\n            expr.async = body.async;\n            head_1.attachLocation(expr, collected, context.getToken(right - 1));\n            collected.value = expr;\n            collected.type = \"ObjectProperty\";\n            return collected;\n        },\n        collector: [\n            {\n                _prev: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Punctuator ,\", \"ObjectProperty\"),\n                async: head_1._Option(head_1._NonCollecting(\"Identifier async\")),\n                generator: head_1._Option(head_1._NonCollecting(\"Punctuator *\")),\n                kind: head_1._Mark(\"init\"),\n                computed: head_1._Mark(false),\n                key: PROPERTY_NAME_PATTERN,\n                value: head_1._Series(PARAMS_PATTERN, BODY_PATTERN),\n                _next: head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */, \"Punctuator ,\"), head_1._NonCapturing(\"Punctuator }\")),\n                //_NonCapturing(MATCH_MARKS.BOUNDARY, \"Punctuator ,\", \"Punctuator }\"),\n                method: head_1._Mark(true),\n                shorthand: head_1._Mark(false)\n            },\n            [\n                [\"async\", head_1._Mark()],\n                [\"generator\", head_1._Mark()],\n                [\n                    \"kind\", head_1._Or(head_1._Series(head_1._NonCollecting(\"Identifier get\"), head_1._Mark(\"get\")), head_1._Series(head_1._NonCollecting(\"Identifier set\"), head_1._Mark(\"set\")))\n                ],\n                [\"method\", head_1._Mark(false)]\n            ]\n        ]\n    }\n};\nvar ObjectProperties = __assign(__assign({}, head_1._SuccessCollector(head_1._Or(\"Property\", head_1._Or(\"ObjectProperty\").pipe(function (context, token) {\n    token.type = \"Property\";\n})))), { \"Property\": {\n        collector: [\n            {\n                _prev: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n                key: PROPERTY_NAME_PATTERN,\n                value: head_1._Series(head_1._NonCollecting(\"Punctuator :\"), head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN),\n                _next: head_1._Or(head_1._NonCollecting(\"\" /* BOUNDARY */, \"Punctuator ,\"), head_1._NonCapturing(\"Punctuator }\")),\n                kind: head_1._Mark(\"init\"),\n                computed: head_1._Mark(false),\n                method: head_1._Mark(false),\n                shorthand: head_1._Mark(false),\n            },\n            [\n                [\"key\", \"Identifier\"],\n                [\"value\", window.test1 = head_1._Mark(function (context) {\n                        return context[0 /* collected */].key;\n                    })],\n                [\"shorthand\", head_1._Mark(true)]\n            ]\n        ]\n    } });\n/*\nlet PRIMARY_EXPRESSION_TREE = createMatchTree(\n    PrimaryExpressions\n)\nlet METHOD_DEFINITIONS_TREE = createMatchTree(\n    MethodDefinitions, PRIMARY_EXPRESSION_TREE\n);\nlet PROPERTIES_TREE = createMatchTree(\n    Properties,\n    PRIMARY_EXPRESSION_TREE\n);*/\nvar PRIMARY_EXPRESSION_TREE, METHOD_DEFINITIONS_TREE, PROPERTIES_TREE, UNIT_EXPRESSION_TREE, ARRAY_ELEMENTS_TREE, OBJECT_PROPERTIES_TREE, PARAMS_TREE, ARGUMENTS_TREE, EXPRESSION_TREE;\nhead_1.async_getter.get(\"Patterns\", function (Patterns) {\n    PRIMARY_EXPRESSION_TREE = head_1.createMatchTree(PrimaryExpressions);\n    METHOD_DEFINITIONS_TREE = head_1.createMatchTree(MethodDefinitions, PRIMARY_EXPRESSION_TREE);\n    PROPERTIES_TREE = head_1.createMatchTree(Properties, PRIMARY_EXPRESSION_TREE);\n    UNIT_EXPRESSION_TREE = head_1.createMatchTree([Expressions, Patterns], undefined, [\"SequenceExpression\"]);\n    ARRAY_ELEMENTS_TREE = head_1.createMatchTree(ArrayElements, UNIT_EXPRESSION_TREE);\n    OBJECT_PROPERTIES_TREE = head_1.createMatchTree(ObjectProperties, UNIT_EXPRESSION_TREE);\n    PARAMS_TREE = head_1.createMatchTree(Params, UNIT_EXPRESSION_TREE);\n    ARGUMENTS_TREE = head_1.createMatchTree(Arguments, UNIT_EXPRESSION_TREE);\n    EXPRESSION_TREE = head_1.createMatchTree({ SequenceExpression: Expressions.SequenceExpression }, UNIT_EXPRESSION_TREE);\n    head_1.async_getter.EXPRESSION_TREE = EXPRESSION_TREE;\n    head_1.async_getter.UNIT_EXPRESSION_TREE = UNIT_EXPRESSION_TREE;\n});\nhead_1.async_getter.get(\"Expressions\", function (expressions) {\n    for (var type_name in expressions) {\n        if (type_name) {\n            head_1.TYPE_ALIAS[type_name] = [type_name, \"[Expression]\"];\n        }\n    }\n});\nexports.default = Expressions;\nfunction parse_params(context, tokens) {\n    if (tokens.length) {\n        var parser = context[1 /* parser */];\n        var restore = context.store(7 /* tokens */, tokens, 18 /* bindingElement */, true);\n        context[12 /* strict */] && context.wrap(10 /* bindingSet */, []);\n        parser.parseCustom(PARAMS_TREE, context);\n        context.restore(restore);\n        return head_1.extract_success(parser, tokens);\n    }\n    return [];\n}\nexports.parse_params = parse_params;\nfunction init_token_hooks() {\n    function getLiteral(parse_value, token, tokenizer) {\n        return {\n            type: \"Literal\",\n            value: parse_value(token, tokenizer),\n            raw: token.value,\n            range: token.range,\n            loc: token.loc\n        };\n    }\n    var getStringLiteral = getLiteral.bind(null, function (token, tokenizer) { return tokenizer._volatility; });\n    var getRegularLiteral = getLiteral.bind(null, function (token, tokenizer) {\n        var regex = token.regex;\n        try {\n            return new RegExp(regex.pattern, regex.flags);\n        }\n        catch (e) {\n            return null;\n        }\n    });\n    head_1.token_hooks.Keyword = function (token, parser) {\n        var context = parser.context_stack[0];\n        if (!context[21 /* allowYield */] && token.value === \"yield\") {\n            return head_1.reinterpretKeywordAsIdentifier(token);\n        }\n        return token;\n    };\n    head_1.token_hooks.Identifier = head_1.reinterpretKeywordAsIdentifier;\n    head_1.token_hooks.Numeric = getLiteral.bind(null, function (token) { return Number(token.value); });\n    head_1.token_hooks.Boolean = getLiteral.bind(null, function (token) { return token.value === \"true\"; });\n    head_1.token_hooks.String = function (token, parser) {\n        token = getStringLiteral(token, parser);\n        if (parser._scopes.octal && parser.context_stack[0][12 /* strict */]) {\n            parser.err(token);\n        }\n        return token;\n    };\n    head_1.token_hooks.Null = getLiteral.bind(null, function () { return null; });\n    head_1.token_hooks.RegularExpression = function (token, tokenizer) {\n        var res = getRegularLiteral(token, tokenizer);\n        res.regex = token.regex;\n        return res;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L2V4cHJlc3Npb24udHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL21udC9kL1Byb2dyYW1GaWxlcy9HaXRIdWIvRGlzb24vanMvc3ludGF4L2V4cHJlc3Npb24udHM/MGViNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgTm9kZSwgVG9rZW4sIENvbnRleHQsIENPTlRFWFQsIE1BVENIRUQsIE1hdGNoVHJlZSwgTUFSS1NcclxufSBmcm9tICcuLi9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHtcclxuICAgIGFzeW5jX2dldHRlcixcclxuICAgIHRva2VuX2hvb2tzLFxyXG4gICAgX1B1bmN0dWF0b3IsXHJcbiAgICBfS2V5d29yZCxcclxuICAgIF9JZGVudGlmaWVyLFxyXG4gICAgX1BhdHRlcm4sXHJcbiAgICBfVmFsaWRhdGUsXHJcbiAgICBpc19yaWdodF9wYXJlbnRoZXNlcyxcclxuICAgIGlzX3JpZ2h0X2JyYWNrZXRzLFxyXG4gICAgaXNfcmlnaHRfYnJhY2VzLFxyXG4gICAgY3JlYXRlTWF0Y2hUcmVlLFxyXG4gICAgX09wdGlvbiwgX09yLCBfU2VyaWVzLCBfTm9uQ29sbGVjdGluZywgX05vbkNhcHR1cmluZywgX01hcmssXHJcbiAgICBUWVBFX0FMSUFTLCBfQ29udGV4dCwgX0xvb3AsIE5PREVTLCB2YWxpZGF0ZUlkZW50aWZpZXIsIHZhbGlkYXRlQXNzaWdubWVudCxcclxuICAgIHZhbGlkYXRlQmluZGluZywgdmFsaWRhdGVMaW5lVGVybWluYXRvciwgQVNTSUdOTUVOVF9QVU5DVFVBVE9SU19QQVRURVJOLCBfU3VjY2Vzc0NvbGxlY3Rvciwgam9pbl9jb250ZW50LFxyXG5cclxuICAgIElERU5USUZJRVJfT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICBFWFBSRVNTSU9OX09SX1ZBTElEQVRFX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgSURFTlRJRklFUl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgIEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICBUT1BMRVZFTF9JVEVNX1BBVFRFUk4sXHJcbiAgICBpc0FsaWduZWQsXHJcbiAgICBhdHRhY2hMb2NhdGlvbixcclxuXHJcbiAgICByZWludGVycHJldElkZW50aWZpZXJBc0tleXdvcmQsXHJcbiAgICByZWludGVycHJldEtleXdvcmRBc0lkZW50aWZpZXIsXHJcblxyXG4gICAgZXh0cmFjdF9zdWNjZXNzLFxyXG4gICAgcGFyc2VfYW5kX2V4dHJhY3QsXHJcbn0gZnJvbSAnLi9oZWFkJ1xyXG5cclxuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInXHJcbmltcG9ydCBUb2tlbml6ZXIgZnJvbSAnLi4vdG9rZW5pemVyJ1xyXG5cclxuaW1wb3J0IHtcclxuICAgIHBhcnNlQXJyYXlQYXR0ZXJuLFxyXG4gICAgcGFyc2VPYmplY3RQYXR0ZXJuXHJcbn0gZnJvbSAnLi9wYXR0ZXJuJztcclxuY29uc3QgR3JvdXBpbmcgPSBOT0RFUy5Hcm91cGluZztcclxuXHJcbmluaXRfdG9rZW5faG9va3MoKTtcclxuXHJcbmZ1bmN0aW9uIHdhbGtfcHJpbWFyeV9leHByZXNzaW9uKGNvbnRleHQ6IENvbnRleHQsIGluZGV4OiBudW1iZXIpIHtcclxuICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLnBhcnNlUmFuZ2UoUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUUsIGNvbnRleHQsIGluZGV4LCBpc19yaWdodF9wYXJlbnRoZXNlcyk7XHJcbn1cclxuXHJcblxyXG5jb25zdCBBUkdVTUVOVFNfUEFUVEVSTiA9IF9PcihcclxuICAgIF9QdW5jdHVhdG9yKFwiKFwiKS53YWxrKFxyXG4gICAgICAgIHdhbGtfcHJpbWFyeV9leHByZXNzaW9uXHJcbiAgICApLFxyXG4gICAgXCJQdW5jdHVhdG9yICgpXCJcclxuKS5waXBlKFxyXG4gICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKFxyXG4gICAgICAgICAgICBDT05URVhULmJpbmRpbmdFbGVtZW50LCBmYWxzZSxcclxuICAgICAgICAgICAgQ09OVEVYVC5zcHJlYWRFbGVtZW50LCB0cnVlLFxyXG4gICAgICAgICAgICBDT05URVhULnRva2VucywgdG9rZW4uY29udGVudFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlci5wYXJzZU5vZGUoQVJHVU1FTlRTX1RSRUUsIGNvbnRleHQsIGZ1bmN0aW9uIChub2RlOiBUb2tlbikgeyByZXR1cm4gbm9kZS50eXBlID09PSBcIlN1Y2Nlc3NcIjsgfSlcclxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiByZXMgPyByZXMuY29udGVudCA6IFtdO1xyXG4gICAgfVxyXG4pO1xyXG5cclxuXHJcbmNvbnN0IFBBUkFNU19QQVRURVJOID0gX09yKFxyXG4gICAgX1B1bmN0dWF0b3IoXCIoXCIpLndhbGsoXHJcbiAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIGxlZnQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICBsZXQgcGFyc2VyID0gY29udGV4dFtDT05URVhULnBhcnNlcl07XHJcbiAgICAgICAgICAgIGxldCBzdG9yZSA9IGNvbnRleHQuc3RvcmUoXHJcbiAgICAgICAgICAgICAgICBDT05URVhULmJpbmRpbmdFbGVtZW50LCB0cnVlLFxyXG4gICAgICAgICAgICAgICAgQ09OVEVYVC5zcHJlYWRFbGVtZW50LCB0cnVlLFxyXG4gICAgICAgICAgICAgICAgQ09OVEVYVC5iaW5kaW5nU2V0LCBbXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBwYXJzZXIucGFyc2VSYW5nZShcclxuICAgICAgICAgICAgICAgIFBBUkFNU19UUkVFLCBjb250ZXh0LCBsZWZ0LCBpc19yaWdodF9wYXJlbnRoZXNlcyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChub2RlOiBUb2tlbikgeyByZXR1cm4gbm9kZS50eXBlID09PSBcIlN1Y2Nlc3NcIjsgfVxyXG4gICAgICAgICAgICApLnR5cGUgPSBcIlBhcmFtc1wiO1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoc3RvcmUpO1xyXG4gICAgICAgIH1cclxuICAgICksIF9QYXR0ZXJuKFwiUGFyYW1zXCIpXHJcbikucGlwZShcclxuICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4sIGxlZnQ6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICBsZXQga2luZCA9IGNvbGxlY3RlZC5raW5kO1xyXG4gICAgICAgIGxldCBwYXJhbXMgPSB0b2tlbi5jb250ZW50ID8gdG9rZW4uY29udGVudC5jb250ZW50IDogW107XHJcbiAgICAgICAgbGV0IHBhcmFtc19jb3VudCA9IGtpbmQgPT09IFwiZ2V0XCIgPyAwIDoga2luZCA9PT0gXCJzZXRcIiA/IDEgOiBmYWxzZTtcclxuICAgICAgICBpZiAocGFyYW1zX2NvdW50ICE9PSBmYWxzZSAmJiBwYXJhbXMubGVuZ3RoICE9PSBwYXJhbXNfY291bnQpIHtcclxuICAgICAgICAgICAgcGFyc2VyLmVyciguLi5wYXJhbXMuc3BsaWNlKHBhcmFtc19jb3VudCwgcGFyYW1zLmxlbmd0aCAtIHBhcmFtc19jb3VudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfVxyXG4pO1xyXG5jb25zdCBCT0RZX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBfUHVuY3R1YXRvcihcIntcIikud2FsayhcclxuICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgbGVmdDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGxldCBnZW5lcmF0b3IgPSAhIXRoaXMuZ2VuZXJhdG9yLCBhc3luYyA9ICEhdGhpcy5hc3luYztcclxuICAgICAgICAgICAgbGV0IHBhcnNlciA9IGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdO1xyXG4gICAgICAgICAgICBsZXQgYm9keV9jb250ZXh0ID0gX0NvbnRleHQocGFyc2VyKTtcclxuICAgICAgICAgICAgYm9keV9jb250ZXh0W0NPTlRFWFQuaW5GdW5jdGlvbkJvZHldID0gbGVmdCArIDE7XHJcbiAgICAgICAgICAgIGJvZHlfY29udGV4dFtDT05URVhULnN0cmljdF0gPSBjb250ZXh0W0NPTlRFWFQuc3RyaWN0XTtcclxuICAgICAgICAgICAgYm9keV9jb250ZXh0W0NPTlRFWFQuYWxsb3dZaWVsZF0gPSBnZW5lcmF0b3I7XHJcbiAgICAgICAgICAgIGJvZHlfY29udGV4dFtDT05URVhULmFsbG93QXdhaXRdID0gYXN5bmM7XHJcblxyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHBhcnNlci5wYXJzZVJhbmdlKFxyXG4gICAgICAgICAgICAgICAgcGFyc2VyLlNZTlRBWF9UUkVFLCBib2R5X2NvbnRleHQsIGxlZnQsIGlzX3JpZ2h0X2JyYWNlc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBub2RlLnR5cGUgPSBcIkJvZHlcIjtcclxuICAgICAgICAgICAgbm9kZS5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcbiAgICAgICAgICAgIG5vZGUuYXN5bmMgPSBhc3luYztcclxuICAgICAgICAgICAgbGV0IGJsb2NrID0gbmV3IE5PREVTLkJsb2NrU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJsb2NrLmJvZHkgPSBub2RlLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGF0dGFjaExvY2F0aW9uKGJsb2NrLCBub2RlKTtcclxuICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gYmxvY2s7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cnVlXHJcbiAgICApLCBcIkJvZHlcIlxyXG4pO1xyXG5jb25zdCBGVU5DVElPTl9CT0RZX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBCT0RZX1BBVFRFUk5cclxuKS5waXBlKFxyXG4gICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgIHJldHVybiB0b2tlbi5jb250ZW50O1xyXG4gICAgfVxyXG4pO1xyXG5cclxuY29uc3QgUHJpbWFyeUV4cHJlc3Npb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG4gICAgXCJcIjogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBfTWFyayhcIlB1bmN0dWF0b3JcIiksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogX01hcmsoXCJ7fVwiKSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9QdW5jdHVhdG9yKFwie1wiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4sIGxlZnQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtDT05URVhULnBhcnNlcl0ucGFyc2VSYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBST1BFUlRJRVNfVFJFRSwgY29udGV4dCwgbGVmdCwgaXNfcmlnaHRfYnJhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkuY29udGVudCB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBfTWFyayhcIlB1bmN0dWF0b3JcIiksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogX01hcmsoXCIoKVwiKSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9QdW5jdHVhdG9yKFwiKFwiKS53YWxrKFxyXG4gICAgICAgICAgICAgICAgICAgIHdhbGtfcHJpbWFyeV9leHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICApLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4uY29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBfTWFyayhcIlB1bmN0dWF0b3JcIiksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogX01hcmsoXCJbXVwiKSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9QdW5jdHVhdG9yKFwiW1wiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBub2RlOiBOb2RlLCBpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5wYXJzZVJhbmdlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUUsIGNvbnRleHQsIGluZGV4LCBpc19yaWdodF9icmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIF0sXHJcbiAgICBcIklkZW50aWZpZXJcIjogW1xyXG4gICAgXSxcclxuICAgIFwiTGl0ZXJhbFwiOiBbLy/lt7LlnKggdG9rZW5pemVyID0+IHRva2VuX2hvb2tzIOS4reWkhOeQhlxyXG4gICAgXSxcclxuICAgIFwiVGhpc0V4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIHRoaXNcIilcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCJUZW1wbGF0ZUxpdGVyYWxcIjoge1xyXG4gICAgICAgIGZpbHRlcihjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29udGV4dC5nZXRUb2tlbihyaWdodCkudmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVswXSA9PT0gXCJgXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXzogX05vbkNhcHR1cmluZyhfT3B0aW9uKFwiW0V4cHJlc3Npb25dXCIpKSxcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBfTWFyaygoKSA9PiBbXSksXHJcbiAgICAgICAgICAgICAgICBxdWFzaXM6IF9QYXR0ZXJuKFwiVGVtcGxhdGVcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuLCBpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlOiBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHByZXNzaW9ucyA9IGNvbGxlY3RlZC5leHByZXNzaW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHF1YXNpcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFpbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kOiBudW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbnRleHQuZ2V0VG9rZW4oaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gXCJgXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gLTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhc2lzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlRlbXBsYXRlRWxlbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB2YWx1ZS5zbGljZSgxLCBlbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkOiBwYXJzZXIuX3ZvbGF0aWxpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucGFyc2VSYW5nZUFzRXhwcmVzc2lvbihjb250ZXh0LCBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IHBhcnNlci5UWVBFX0VOVU1TLlRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdG9rZW4udmFsdWVbMF0gPT09IFwifVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWFzaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOiBbXHJcblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhfTWFyayh0cnVlKSwgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGFzeW5jXCIpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX01hcmsoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBfXzogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGZ1bmN0aW9uXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvcjogX09yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKF9NYXJrKHRydWUpLCBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgKlwiKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9NYXJrKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IF9PcihJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLCBfTWFyayhudWxsKSksXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBQQVJBTVNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgICAgICBib2R5OiBGVU5DVElPTl9CT0RZX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogX01hcmsoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbLCBwYXJzZXIsIGxlZnRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5zdGFydF0gPSBjb250ZXh0W0NPTlRFWFQuZW5kXSA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVpbnRlcnByZXRJZGVudGlmaWVyQXNLZXl3b3JkKGNvbnRleHQuZ2V0VG9rZW4obGVmdCkpXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBwYXJzZXIucGFyc2VLZXl3b3JkKGNvbnRleHQuZ2V0VG9rZW4obGVmdCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWx0ZXI6IFtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXNBbGlnbmVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICAgICAgeyBfOiBfU2VyaWVzKFwiSWRlbnRpZmllciBhc3luY1wiLCBcIklkZW50aWZpZXJcIikgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3luYzogXCJJZGVudGlmaWVyIGFzeW5jXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgX25leHQ6IF9Ob25DYXB0dXJpbmcoXCJLZXl3b3JkIGZ1bmN0aW9uXCIpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3luYzogXCJJZGVudGlmaWVyIGFzeW5jXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBfTm9uQ2FwdHVyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcIihcIikud2FsayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtfcHJpbWFyeV9leHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICksIFwiUHVuY3R1YXRvciAoKVwiLCBcIklkZW50aWZpZXJcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IF9Ob25DYXB0dXJpbmcoXCJQdW5jdHVhdG9yID0+XCIpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6IHtcclxuICAgICAgICBoYW5kbGVyOiBbXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgW2NvbGxlY3RlZCwgcGFyc2VyLCBsZWZ0LCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gY29udGV4dC5nZXRUb2tlbihyaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IFwiXz0+XCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm9keV9jb250ZXh0ID0gX0NvbnRleHQocGFyc2VyKTtcclxuICAgICAgICAgICAgICAgIGJvZHlfY29udGV4dFtDT05URVhULnN0cmljdF0gPSBjb250ZXh0W0NPTlRFWFQuc3RyaWN0XTtcclxuICAgICAgICAgICAgICAgIGJvZHlfY29udGV4dFtDT05URVhULmFsbG93QXdhaXRdID0gY29sbGVjdGVkLmFzeW5jO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5wYXJzZUN1c3RvbShcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLkVYUFJFU1NJT05fVFJFRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keV9jb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZTogTm9kZSkgPT4gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcmVjZWRlbmNlOiBbMywgdHJ1ZSwgbmV3IE51bWJlcigzKV0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHsvL+WNoOS9jeS9vyAoKSDkuI3kvJrooqvljZXni6zmlLbpm4bkuLrooajovr7lvI9cclxuICAgICAgICAgICAgICAgIGFzeW5jOiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhfTWFyayh0cnVlKSwgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGFzeW5jXCIpKSxcclxuICAgICAgICAgICAgICAgICAgICBfTWFyayhmYWxzZSlcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IF9NYXJrKGZhbHNlKSxcclxuICAgICAgICAgICAgICAgIGlkOiBfTWFyayhudWxsKSxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogX09yKFxyXG4gICAgICAgICAgICAgICAgICAgIF9QdW5jdHVhdG9yKFwiKClcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC53cmFwKENPTlRFWFQudG9rZW5zLCB0b2tlbi5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBwYXJzZV9wYXJhbXMoY29udGV4dCwgdG9rZW4uY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVud3JhcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX1BhdHRlcm4oXCJJZGVudGlmaWVyXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQXNzaWdubWVudChjb250ZXh0LCB0b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yID0+XCIpLFxyXG4gICAgICAgICAgICAgICAgYm9keTogRlVOQ1RJT05fQk9EWV9QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogX01hcmsoZmFsc2UpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImJvZHlcIiwgX01hcmsoKV0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIC8vXz0+5L2c55So5Li66ZqU5pat5Yy56YWN77yM5L2/5ZCO57ut55qE6KGo6L6+5byP5L2/55So5b2T5YmN5pa55rOV5aOw5piO55qE546v5aKDXHJcbiAgICAgICAgICAgICAgICBbXCJ0b2tlblwiLCBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgXz0+XCIpXSwvL1wiUHVuY3R1YXRvciBfPT5cIlxyXG4gICAgICAgICAgICAgICAgW1wiYm9keVwiLCBcIltFeHByZXNzaW9uXVwiXSxcclxuICAgICAgICAgICAgICAgIFtcImV4cHJlc3Npb25cIiwgX01hcmsodHJ1ZSldXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJDbGFzc0V4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgY2xhc3NcIiksXHJcbiAgICAgICAgICAgICAgICBpZDogX09yKElERU5USUZJRVJfT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sIF9NYXJrKG51bGwpKSxcclxuICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3M6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgZXh0ZW5kc1wiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSURFTlRJRklFUl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTlxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX01hcmsobnVsbClcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBib2R5OlxyXG4gICAgICAgICAgICAgICAgICAgIF9QdW5jdHVhdG9yKFwie1wiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuLCBsZWZ0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBwYXJzZXIucGFyc2VSYW5nZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNRVRIT0RfREVGSU5JVElPTlNfVFJFRSwgY29udGV4dCwgbGVmdCwgaXNfcmlnaHRfYnJhY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChub2RlOiBUb2tlbikgeyByZXR1cm4gbm9kZS50eXBlID09PSBcIlN1Y2Nlc3NcIjsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiQ2xhc3NCb2R5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcmVzLmNvbnRlbnQ/LmNvbnRlbnQgfHwgW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJlcy5yYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHJlcy5sb2NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJTdXBlclwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFssIHBhcnNlciwgbGVmdCwgcmlnaHRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0W0NPTlRFWFQuaW5GdW5jdGlvbkJvZHldIHx8IHJpZ2h0ID09PSBsZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGNvbnRleHQuZ2V0VG9rZW4obGVmdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgc3VwZXJcIiksXHJcbiAgICAgICAgICAgIF9uZXh0OiBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciAoIC4gW1wiKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn1cclxuXHJcbmNvbnN0IEV4cHJlc3Npb25zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gYXN5bmNfZ2V0dGVyLkV4cHJlc3Npb25zID0ge1xyXG4gICAgLi4uUHJpbWFyeUV4cHJlc3Npb25zLFxyXG4gICAgXCJcIjogUHJpbWFyeUV4cHJlc3Npb25zW1wiXCJdLmNvbmNhdChcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRvcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VyID0gY29udGV4dFtDT05URVhULnBhcnNlcl07XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IGNvbnRleHRbQ09OVEVYVC5sZWZ0XTtcclxuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IGNvbnRleHQuZ2V0VG9rZW4obGVmdCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKFxyXG4gICAgICAgICAgICAgICAgICAgIENPTlRFWFQuYmluZGluZ1NldCwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBDT05URVhULmJpbmRpbmdFbGVtZW50LCBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBDT05URVhULnRva2VucywgdG9rZW4uY29udGVudFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGxldCBncm91cGluZyA9IG5ldyBHcm91cGluZyhcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGNvbnRleHQpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKHN0b3JlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5zdGFydF0gPSBjb250ZXh0W0NPTlRFWFQuZW5kXSA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBpbmc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IFwiUHVuY3R1YXRvciAoKVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApLFxyXG4gICAgXCJBcnJheUV4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIHByZWNlZGVuY2U6IDIwLFxyXG4gICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICBlbGVtZW50czogX1B1bmN0dWF0b3IoXCJbXVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIG5vZGU6IE5vZGUsIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT05URVhULnNwcmVhZEVsZW1lbnQsIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTlRFWFQuYmluZGluZ0VsZW1lbnQsIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gcGFyc2VfYW5kX2V4dHJhY3QoQVJSQVlfRUxFTUVOVFNfVFJFRSwgY29udGV4dCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKHN0b3JlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgXCJPYmplY3RFeHByZXNzaW9uXCI6IHtcclxuICAgICAgICBwcmVjZWRlbmNlOiAyMCxcclxuICAgICAgICBjb2xsZWN0b3I6IHtcclxuICAgICAgICAgICAgcHJvcGVydGllczogX1B1bmN0dWF0b3IoXCJ7fVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIG5vZGU6IE5vZGUsIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VfYW5kX2V4dHJhY3QoT0JKRUNUX1BST1BFUlRJRVNfVFJFRSwgY29udGV4dCwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gbm9kZS5jb250ZW50IHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApLFxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0YWc6IEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICBxdWFzaTogXCJUZW1wbGF0ZUxpdGVyYWxcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIFwiTWVtYmVyRXhwcmVzc2lvblwiOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAyMCxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSWRlbnRpZmllclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfUGF0dGVybihcIktleXdvcmRcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVpbnRlcnByZXRLZXl3b3JkQXNJZGVudGlmaWVyKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5wYXJzZUlkZW50aWZpZXIodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBfTWFyayhmYWxzZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmaWx0ZXI6IFwiQ2FsbEV4cHJlc3Npb25cIixcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMjAsXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBFWFBSRVNTSU9OX09SX1ZBTElEQVRFX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcIltcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiwgbGVmdDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKENPTlRFWFQuYmluZGluZ0VsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5wYXJzZVJhbmdlQXNFeHByZXNzaW9uKGNvbnRleHQsIGxlZnQsIGlzX3JpZ2h0X2JyYWNrZXRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZShzdG9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcIltdXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4sIGxlZnQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0b3JlID0gY29udGV4dC5zdG9yZShDT05URVhULnRva2VucywgdG9rZW4uY29udGVudCwgQ09OVEVYVC5iaW5kaW5nRWxlbWVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLnBhcnNlRXhwcmVzc2lvbihjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZShzdG9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBfTWFyayh0cnVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuXHJcbiAgICBcIk1ldGFQcm9wZXJ0eVwiOiB7XHJcbiAgICAgICAgaGFuZGxlcihbY29sbGVjdGVkXTogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQubWV0YS50eXBlID0gXCJJZGVudGlmaWVyXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWV0YTogXCJLZXl3b3JkIGltcG9ydFwiLFxyXG4gICAgICAgICAgICAgICAgXzogX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yIC5cIiksXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTogXCJJZGVudGlmaWVyIG1ldGFcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtZXRhOiBcIktleXdvcmQgbmV3XCIsXHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLlwiKSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcIklkZW50aWZpZXIgdGFyZ2V0XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIk5ld0V4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIHByZWNlZGVuY2U6IG5ldyBOdW1iZXIoMjApLypfUHJlY2VkZW5jZSgyMCwgUFJFQ0VERU5DRV9GRUFUVVJFUy5SSUdIVF9URVJNSU5BTCkqLywvL21lbWJlcmV4cHJlc3Npb24gbmV3IE51bWJlcigyMClcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCBuZXdcIiksXHJcbiAgICAgICAgICAgICAgICBjYWxsZWU6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICBFWFBSRVNTSU9OX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgICAgIF9QYXR0ZXJuKFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtDT05URVhULnBhcnNlcl0uZXJyKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IF9PcihfTWFyaygoKSA9PiBbXSksIEFSR1VNRU5UU19QQVRURVJOKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIFwiQ2FsbEV4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIHByZWNlZGVuY2U6IDIwLyogX1ByZWNlZGVuY2UoMjAsIFBSRUNFREVOQ0VfRkVBVFVSRVMuUklHSFRfVEVSTUlOQUwpKi8sXHJcbiAgICAgICAgZmlsdGVyKGNvbnRleHQ6IENvbnRleHQsIGxlZnQ6IG51bWJlcikge1xyXG4gICAgICAgICAgICBsZXQgdG9rZW5zID0gY29udGV4dC50b2tlbnM7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdF90b2tlbiA9IHRva2Vuc1tsZWZ0XSwgc2Vjb25kX3Rva2VuID0gdG9rZW5zW2xlZnQgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHNlY29uZF90b2tlbiA9PT0gY29udGV4dFtDT05URVhULnJpZ2h0QXNzb2NpYXRpdmVOb2RlXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmaXJzdF90b2tlbl90eXBlID0gZmlyc3RfdG9rZW4udHlwZTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgZmlyc3RfdG9rZW4gaW5zdGFuY2VvZiBHcm91cGluZ1xyXG4gICAgICAgICAgICAgICAgfHwgZmlyc3RfdG9rZW5fdHlwZSAhPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICBjYWxsZWU6IEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICAgICAgICAgIGFyZ3VtZW50czogQVJHVU1FTlRTX1BBVFRFUk5cclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIFwiVXBkYXRlRXhwcmVzc2lvblwiOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbY29sbGVjdGVkXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWQub3BlcmF0b3IgPSBjb2xsZWN0ZWQub3BlcmF0b3IudmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNyxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJQdW5jdHVhdG9yICsrIC0tXCIsXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogX09yKFwiTWVtYmVyRXhwcmVzc2lvblwiLCBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOKSxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogX01hcmsodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAvKl86IF8rK2EoYikqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRvcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGVkID0gY29udGV4dFtDT05URVhULnBhcnNlcl0uY3JlYXRlTm9kZShjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5vcGVyYXRvciA9IGNvbGxlY3RlZC5vcGVyYXRvci52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbHRlcihjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0FsaWduZWQoY29udGV4dCwgbGVmdCwgbGVmdCArIDEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxOCxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogX09yKFwiTWVtYmVyRXhwcmVzc2lvblwiLCBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOKSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIlB1bmN0dWF0b3IgKysgLS1cIixcclxuICAgICAgICAgICAgICAgIHByZWZpeDogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgXzogX09wdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBfTm9uQ2FwdHVyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcIltcIiwgXCIoXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtDT05URVhULnJpZ2h0QXNzb2NpYXRpdmVOb2RlXSA9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcIi5cIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5lcnIodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFwiQXdhaXRFeHByZXNzaW9uXCI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE3LFxyXG4gICAgICAgICAgICBmaWx0ZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5hbGxvd0F3YWl0XTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGF3YWl0XCIpLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoYW5kbGVyKFt7IHRva2VuIH1dOiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVpbnRlcnByZXRLZXl3b3JkQXNJZGVudGlmaWVyKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHBhcnNlci5wYXJzZUlkZW50aWZpZXIoY29sbGVjdGVkLnRva2VuKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmlsdGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhY29udGV4dFtDT05URVhULmFsbG93QXdhaXRdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiBcIktleXdvcmQgYXdhaXRcIixcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICBdLFxyXG4gICAgXCJVbmFyeUV4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQub3BlcmF0b3IgPSBjb2xsZWN0ZWQub3BlcmF0b3IudmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVjZWRlbmNlOiAxNyxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IF9PcihcIlB1bmN0dWF0b3IgfiAhICsgLVwiLCBcIktleXdvcmQgZGVsZXRlIHZvaWQgdHlwZW9mXCIpLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IF9NYXJrKHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJCaW5hcnlFeHByZXNzaW9uXCI6IHtcclxuICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgY29sbGVjdGVkLm9wZXJhdG9yID0gY29sbGVjdGVkLm9wZXJhdG9yLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5yaWdodF0gLSBjb250ZXh0W0NPTlRFWFQubGVmdF0gPj0gMlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlY2VkZW5jZTogWzE2LCAxNSwgMTQsIDEzLCAxMiwgMTEsIDEwLCA5LCA4LCA3XSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBgUHVuY3R1YXRvciAqKmAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogX09wdGlvbihFWFBSRVNTSU9OX09SX1ZBTElEQVRFX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXCJvcGVyYXRvclwiLCBgUHVuY3R1YXRvciAqIC8gJWBdLFxyXG4gICAgICAgICAgICBbXCJvcGVyYXRvclwiLCBgUHVuY3R1YXRvciArIC1gXSxcclxuICAgICAgICAgICAgW1wib3BlcmF0b3JcIiwgYFB1bmN0dWF0b3IgPDwgPj4gPj4+YF0sXHJcbiAgICAgICAgICAgIFtcIm9wZXJhdG9yXCIsIF9PcihgUHVuY3R1YXRvciA8IDw9ID4gPj1gLCBgS2V5d29yZCBpbiBpbnN0YW5jZW9mYCldLFxyXG4gICAgICAgICAgICBbXCJvcGVyYXRvclwiLCBgUHVuY3R1YXRvciA9PSAhPSA9PT0gIT09YF0sXHJcbiAgICAgICAgICAgIFtcIm9wZXJhdG9yXCIsIGBQdW5jdHVhdG9yICZgXSxcclxuICAgICAgICAgICAgW1wib3BlcmF0b3JcIiwgYFB1bmN0dWF0b3IgXmBdLFxyXG4gICAgICAgICAgICBbXCJvcGVyYXRvclwiLCBgUHVuY3R1YXRvciB8YF0sXHJcbiAgICAgICAgICAgIFtcIm9wZXJhdG9yXCIsIGBQdW5jdHVhdG9yID8/YF1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJMb2dpY2FsRXhwcmVzc2lvblwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHRbQ09OVEVYVC5yaWdodF0gLSBjb250ZXh0W0NPTlRFWFQubGVmdF0gPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0ZWQgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5jcmVhdGVOb2RlKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLm9wZXJhdG9yID0gY29sbGVjdGVkLm9wZXJhdG9yLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlY2VkZW5jZTogWzYsIDVdLFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBFWFBSRVNTSU9OX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiUHVuY3R1YXRvciAmJlwiLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IF9PcHRpb24oRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW1wib3BlcmF0b3JcIiwgXCJQdW5jdHVhdG9yIHx8XCJdXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRvcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgWywgcGFyc2VyLCBsZWZ0LCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRbQ09OVEVYVC5pc0V4cHJlc3Npb25dIHx8IGNvbnRleHRbQ09OVEVYVC5iaW5kaW5nRWxlbWVudF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKENPTlRFWFQuaXNFeHByZXNzaW9uLCB0cnVlLCBDT05URVhULmJpbmRpbmdFbGVtZW50LCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIucGFyc2VDdXN0b20oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5FWFBSRVNTSU9OX1RSRUUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlOiBOb2RlKSA9PiBub2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZShzdG9yZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IG5ldyBOdW1iZXIoMyksLy/kuI4gQXNzaWdubWVudCDkuLrlj7PkvJjlhYhcclxuICAgICAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVzdDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTiwvL0VYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciA/XCIpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgW1wiY29uc2VxdWVudFwiLCBFWFBSRVNTSU9OX09SX1ZBTElEQVRFX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOXSxcclxuICAgICAgICAgICAgICAgIFtcIl9cIiwgX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yIDpcIildLFxyXG4gICAgICAgICAgICAgICAgW1wiYWx0ZXJuYXRlXCIsIEVYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk5dXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgXSxcclxuICAgIFwiWWllbGRFeHByZXNzaW9uXCI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8qZmlsdGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W0NPTlRFWFQuYWxsb3dZaWVsZF07XHJcbiAgICAgICAgICAgIH0sKi9cclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMixcclxuICAgICAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCB5aWVsZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgKlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogX01hcmsodHJ1ZSlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCB5aWVsZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogX01hcmsoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qe1xyXG4gICAgICAgICAgICBoYW5kbGVyKFt7IHRva2VuIH1dOiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVpbnRlcnByZXRLZXl3b3JkQXNJZGVudGlmaWVyKHRva2VuKVxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcGFyc2VyLnBhcnNlSWRlbnRpZmllcihjb2xsZWN0ZWQudG9rZW4pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWx0ZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFjb250ZXh0W0NPTlRFWFQuYWxsb3dZaWVsZF07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IFwiS2V5d29yZCB5aWVsZFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCovXHJcbiAgICBdLFxyXG4gICAgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yOiBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXHJcbiAgICAgICAgcHJlY2VkZW5jZTogbmV3IE51bWJlcigzKSwvL1JpZ2h0LWFzc29jaWF0aXZlXHJcbiAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IF9PcihcclxuICAgICAgICAgICAgICAgIF9PcihcIltFeHByZXNzaW9uXVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBleHByOiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycihleHByKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxyXG4gICAgICAgICAgICAgICAgXCJNZW1iZXJFeHByZXNzaW9uXCIsXHJcbiAgICAgICAgICAgICAgICBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsXHJcbiAgICAgICAgICAgICAgICBcIkFycmF5UGF0dGVyblwiLFxyXG4gICAgICAgICAgICAgICAgXCJPYmplY3RQYXR0ZXJuXCIsXHJcbiAgICAgICAgICAgICAgICBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgIG9wZXJhdG9yOiBBU1NJR05NRU5UX1BVTkNUVUFUT1JTX1BBVFRFUk4sXHJcbiAgICAgICAgICAgIHJpZ2h0OiBfT3B0aW9uKFwiW0V4cHJlc3Npb25dXCIpLy/ljaDkvY3pgb/lhY3plJnor6/mlq3lj6VcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgZXhwcmVzc2lvbnM6IEFycmF5PE5vZGU+ID0gY29sbGVjdGVkLmV4cHJlc3Npb25zO1xyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnNbMF0gaW5zdGFuY2VvZiBOT0RFUy5TZXF1ZW5jZUV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zWzBdLmV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbnNbMV0pO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnNbMF0uZXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YWxpZGF0b3IoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgWywgLCBsZWZ0LCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlY2VkZW5jZTogMSxcclxuICAgICAgICBjb2xsZWN0b3I6IHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbnM6IF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICBFWFBSRVNTSU9OX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yICxcIiksXHJcbiAgICAgICAgICAgICAgICBfT3B0aW9uKEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4pXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBDT01QVVRFRF9QUk9QRVJUWV9OQU1FX1BBVFRFUk4gPSBfUHVuY3R1YXRvcihcIltdXCIpLnBpcGUoXHJcbiAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgIGNvbGxlY3RlZC5jb21wdXRlZCA9IHRydWU7XHJcbiAgICAgICAgY29udGV4dC53cmFwKENPTlRFWFQudG9rZW5zLCB0b2tlbi5jb250ZW50KVxyXG4gICAgICAgIGxldCByZXMgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuKTtcclxuXHJcbmNvbnN0IExJVEVSQUxfUFJPUEVSVFlfTkFNRV9QQVRURVJOID0gX09yKFwiSWRlbnRpZmllclwiLCBcIktleXdvcmRcIiwgXCJMaXRlcmFsXCIpLnBpcGUoXHJcbiAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwga2V5OiBUb2tlbikge1xyXG4gICAgICAgIGxldCBbLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgR3JvdXBpbmcpIHtcclxuICAgICAgICAgICAgcGFyc2VyLmVycihrZXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJLZXl3b3JkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlaW50ZXJwcmV0S2V5d29yZEFzSWRlbnRpZmllcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gcGFyc2VyLnBhcnNlSWRlbnRpZmllcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkxpdGVyYWxcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnJlZ2V4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbmNvbnN0IFBST1BFUlRZX05BTUVfUEFUVEVSTiA9IF9PcihDT01QVVRFRF9QUk9QRVJUWV9OQU1FX1BBVFRFUk4sIExJVEVSQUxfUFJPUEVSVFlfTkFNRV9QQVRURVJOKTtcclxuXHJcblxyXG5jb25zdCBNZXRob2REZWZpbml0aW9ucyA9IHtcclxuICAgIC4uLl9TdWNjZXNzQ29sbGVjdG9yKF9QYXR0ZXJuKFwiTWV0aG9kRGVmaW5pdGlvblwiKSksXHJcbiAgICBcIlwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgY29udGV4dFtDT05URVhULnN0YXJ0XSA9IGNvbnRleHRbQ09OVEVYVC5lbmRdID0gY29udGV4dFtDT05URVhULnJpZ2h0XTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgIF86IF9Ob25DYXB0dXJpbmcoTUFSS1MuQk9VTkRBUlksIFwiU3VjY2Vzc1wiKSxcclxuICAgICAgICAgICAgX186IFwiUHVuY3R1YXRvciA7XCJcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgTWV0aG9kRGVmaW5pdGlvbjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gY29sbGVjdGVkO1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQua2luZCA9IHZhbHVlLmtpbmQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZS5raW5kO1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQuY29tcHV0ZWQgPSB2YWx1ZS5jb21wdXRlZDtcclxuICAgICAgICAgICAgZGVsZXRlIHZhbHVlLmNvbXB1dGVkO1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQua2V5ID0gdmFsdWUua2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgdmFsdWUua2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBrZXk6IF9NYXJrKFwiXCIpLFxyXG4gICAgICAgICAgICAgICAgc3RhdGljOiBfTWFyayh0cnVlKSxcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBfTWFyayhmYWxzZSksXHJcbiAgICAgICAgICAgICAgICBfc3RhdGljOiBfTm9uQ29sbGVjdGluZyhcIklkZW50aWZpZXIgc3RhdGljXCIpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXHJcbiAgICAgICAgICAgICAgICBraW5kOiBfTWFyayhcIlwiKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgW1wic3RhdGljXCIsIF9NYXJrKGZhbHNlKV0sXHJcbiAgICAgICAgICAgICAgICBbXCJfc3RhdGljXCIsIF9NYXJrKCldXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uOiB7XHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBzdGF0aWM6IF9PcHRpb24oX05vbkNhcHR1cmluZyhcIklkZW50aWZpZXIgc3RhdGljXCIpKSxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhfTWFyayh0cnVlKSwgX05vbkNvbGxlY3RpbmcoXCJJZGVudGlmaWVyIGFzeW5jXCIpKSxcclxuICAgICAgICAgICAgICAgICAgICBfTWFyayhmYWxzZSlcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKF9NYXJrKHRydWUpLCBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgKlwiKSksXHJcbiAgICAgICAgICAgICAgICAgICAgX01hcmsoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAga2luZDogX01hcmsoXCJtZXRob2RcIiksXHJcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAga2V5OiBQUk9QRVJUWV9OQU1FX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICBpZDogX01hcmsobnVsbCksXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFBBUkFNU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgYm9keTogRlVOQ1RJT05fQk9EWV9QQVRURVJOXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFtcImdlbmVyYXRvclwiLCBfTWFyayhmYWxzZSldLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIFwia2luZFwiLCBfT3IoXCJJZGVudGlmaWVyIGdldCBzZXRcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiwgbGVmdDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IEFyZ3VtZW50cyA9IHtcclxuICAgIFwiU3VjY2Vzc1wiOiB7XHJcbiAgICAgICAgaGFuZGxlcjogam9pbl9jb250ZW50LFxyXG4gICAgICAgIC8vcHJlY2VkZW5jZTogMCxcclxuICAgICAgICBjb2xsZWN0b3I6IHtcclxuICAgICAgICAgICAgc3VjY2VzczogX09yKF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZKSwgXCJTdWNjZXNzXCIpLFxyXG4gICAgICAgICAgICBjb250ZW50OiBfT3IoXCJTcHJlYWRFbGVtZW50XCIsIEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4pLFxyXG4gICAgICAgICAgICBfOiBfT3IoX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yICxcIiksIE1BUktTLkJPVU5EQVJZLCBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciApXCIpKSxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IFBhcmFtcyA9IHtcclxuICAgIFwiU3VjY2Vzc1wiOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKGNvbGxlY3RlZC5jb250ZW50IGluc3RhbmNlb2YgR3JvdXBpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoY29sbGVjdGVkLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBqb2luX2NvbnRlbnQoY29udGV4dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX09yKF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZKSwgXCJTdWNjZXNzXCIpLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJBc3NpZ25tZW50UGF0dGVyblwiLFxyXG4gICAgICAgICAgICAgICAgXzogX09yKF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciAsXCIsIE1BUktTLkJPVU5EQVJZKSwgX05vbkNhcHR1cmluZyhcIlB1bmN0dWF0b3IgKVwiKSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFwiY29udGVudFwiLCBfT3IoXCJJZGVudGlmaWVyXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJpbmRpbmcoY29udGV4dCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgW1wiY29udGVudFwiLCBfT3IoXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgW1wiY29udGVudFwiLCBcIlJlc3RFbGVtZW50XCJdLFxyXG4gICAgICAgICAgICAgICAgW1wiX1wiLCBfT3IoX05vbkNvbGxlY3RpbmcoTUFSS1MuQk9VTkRBUlkpLCBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciApXCIpKV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgQXJyYXlFbGVtZW50cyA9IHtcclxuICAgIFwiU3VjY2Vzc1wiOiB7XHJcbiAgICAgICAgaGFuZGxlcjogam9pbl9jb250ZW50LFxyXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IF9PcihfTm9uQ29sbGVjdGluZyhNQVJLUy5CT1VOREFSWSksIFwiU3VjY2Vzc1wiKSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9PcihcIlNwcmVhZEVsZW1lbnRcIiwgRVhQUkVTU0lPTl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLFwiLCBNQVJLUy5CT1VOREFSWSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFtcImNvbnRlbnRcIiwgX01hcmsobnVsbCldLFxyXG4gICAgICAgICAgICAgICAgW1wiX1wiLCBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLFwiKV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgUHJvcGVydGllcyA9IHtcclxuICAgIFwiUHJvcGVydHlcIjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZCwgcGFyc2VyLCBsZWZ0LCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyB2YWx1ZTogW3BhcmFtcywgYm9keV0gfSA9IGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgbGV0IGV4cHIgPSBuZXcgTk9ERVMuRnVuY3Rpb25FeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIGV4cHIuaWQgPSBudWxsO1xyXG4gICAgICAgICAgICBleHByLnBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICAgICAgZXhwci5ib2R5ID0gYm9keS5jb250ZW50O1xyXG4gICAgICAgICAgICBleHByLmdlbmVyYXRvciA9IGJvZHkuZ2VuZXJhdG9yO1xyXG4gICAgICAgICAgICBleHByLmV4cHJlc3Npb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgZXhwci5hc3luYyA9IGJvZHkuYXN5bmM7XHJcbiAgICAgICAgICAgIGF0dGFjaExvY2F0aW9uKGV4cHIsIGNvbGxlY3RlZCwgY29udGV4dC5nZXRUb2tlbihyaWdodCAtIDEpKTtcclxuICAgICAgICAgICAgY29sbGVjdGVkLnZhbHVlID0gZXhwcjtcclxuICAgICAgICAgICAgY29sbGVjdGVkLnR5cGUgPSBcIk9iamVjdFByb3BlcnR5XCJcclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcHJldjogX05vbkNhcHR1cmluZyhNQVJLUy5CT1VOREFSWSwgXCJQdW5jdHVhdG9yICxcIiwgXCJPYmplY3RQcm9wZXJ0eVwiKSxcclxuICAgICAgICAgICAgICAgIGFzeW5jOiBfT3B0aW9uKF9Ob25Db2xsZWN0aW5nKFwiSWRlbnRpZmllciBhc3luY1wiKSksXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0b3I6IF9PcHRpb24oX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yICpcIikpLFxyXG4gICAgICAgICAgICAgICAga2luZDogX01hcmsoXCJpbml0XCIpLFxyXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IF9NYXJrKGZhbHNlKSxcclxuICAgICAgICAgICAgICAgIGtleTogUFJPUEVSVFlfTkFNRV9QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IF9TZXJpZXMoUEFSQU1TX1BBVFRFUk4sIEJPRFlfUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICBfbmV4dDogX09yKFxyXG4gICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZLCBcIlB1bmN0dWF0b3IgLFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciB9XCIpXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgLy9fTm9uQ2FwdHVyaW5nKE1BVENIX01BUktTLkJPVU5EQVJZLCBcIlB1bmN0dWF0b3IgLFwiLCBcIlB1bmN0dWF0b3IgfVwiKSxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogX01hcmsodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IF9NYXJrKGZhbHNlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbXCJhc3luY1wiLCBfTWFyaygpXSxcclxuICAgICAgICAgICAgICAgIFtcImdlbmVyYXRvclwiLCBfTWFyaygpXSxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBcImtpbmRcIiwgX09yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKF9Ob25Db2xsZWN0aW5nKFwiSWRlbnRpZmllciBnZXRcIiksIF9NYXJrKFwiZ2V0XCIpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhfTm9uQ29sbGVjdGluZyhcIklkZW50aWZpZXIgc2V0XCIpLCBfTWFyayhcInNldFwiKSlcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICBdLC8vXCJJZGVudGlmaWVyIGdldCBzZXRcIlxyXG4gICAgICAgICAgICAgICAgW1wibWV0aG9kXCIsIF9NYXJrKGZhbHNlKV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgT2JqZWN0UHJvcGVydGllcyA9IHtcclxuICAgIC4uLl9TdWNjZXNzQ29sbGVjdG9yKF9PcihcclxuICAgICAgICBcIlByb3BlcnR5XCIsXHJcbiAgICAgICAgX09yKFwiT2JqZWN0UHJvcGVydHlcIikucGlwZShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiUHJvcGVydHlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIClcclxuICAgICkpLFxyXG4gICAgXCJQcm9wZXJ0eVwiOiB7XHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBrZXk6IFBST1BFUlRZX05BTUVfUEFUVEVSTiwvL1wiVGVtcGxhdGVMaXRlcmFsXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciA6XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIEVYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk5cclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBfbmV4dDogX09yKF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZLCBcIlB1bmN0dWF0b3IgLFwiKSwgX05vbkNhcHR1cmluZyhcIlB1bmN0dWF0b3IgfVwiKSksXHJcbiAgICAgICAgICAgICAgICBraW5kOiBfTWFyayhcImluaXRcIiksXHJcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBfTWFyayhmYWxzZSksXHJcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IF9NYXJrKGZhbHNlKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgW1wia2V5XCIsIFwiSWRlbnRpZmllclwiXSxcclxuICAgICAgICAgICAgICAgIFtcInZhbHVlXCIsICh3aW5kb3cgYXMgYW55KS50ZXN0MSA9IF9NYXJrKGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5jb2xsZWN0ZWRdLmtleTtcclxuICAgICAgICAgICAgICAgIH0pXSxcclxuICAgICAgICAgICAgICAgIFtcInNob3J0aGFuZFwiLCBfTWFyayh0cnVlKV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufVxyXG4vKlxyXG5sZXQgUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICBQcmltYXJ5RXhwcmVzc2lvbnNcclxuKVxyXG5sZXQgTUVUSE9EX0RFRklOSVRJT05TX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICBNZXRob2REZWZpbml0aW9ucywgUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUVcclxuKTtcclxubGV0IFBST1BFUlRJRVNfVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShcclxuICAgIFByb3BlcnRpZXMsXHJcbiAgICBQUklNQVJZX0VYUFJFU1NJT05fVFJFRVxyXG4pOyovXHJcblxyXG5sZXQgUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUU6IE1hdGNoVHJlZSxcclxuICAgIE1FVEhPRF9ERUZJTklUSU9OU19UUkVFOiBNYXRjaFRyZWUsXHJcbiAgICBQUk9QRVJUSUVTX1RSRUU6IE1hdGNoVHJlZSxcclxuICAgIFVOSVRfRVhQUkVTU0lPTl9UUkVFOiBNYXRjaFRyZWUsXHJcbiAgICBBUlJBWV9FTEVNRU5UU19UUkVFOiBNYXRjaFRyZWUsXHJcbiAgICBPQkpFQ1RfUFJPUEVSVElFU19UUkVFOiBNYXRjaFRyZWUsXHJcbiAgICBQQVJBTVNfVFJFRTogTWF0Y2hUcmVlLFxyXG4gICAgQVJHVU1FTlRTX1RSRUU6IE1hdGNoVHJlZSxcclxuICAgIEVYUFJFU1NJT05fVFJFRTogTWF0Y2hUcmVlO1xyXG5cclxuXHJcblxyXG5hc3luY19nZXR0ZXIuZ2V0KFxyXG4gICAgXCJQYXR0ZXJuc1wiLFxyXG4gICAgZnVuY3Rpb24gKFBhdHRlcm5zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICAgICAgUFJJTUFSWV9FWFBSRVNTSU9OX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICAgICAgICAgIFByaW1hcnlFeHByZXNzaW9uc1xyXG4gICAgICAgIClcclxuICAgICAgICBNRVRIT0RfREVGSU5JVElPTlNfVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShcclxuICAgICAgICAgICAgTWV0aG9kRGVmaW5pdGlvbnMsIFBSSU1BUllfRVhQUkVTU0lPTl9UUkVFXHJcbiAgICAgICAgKTtcclxuICAgICAgICBQUk9QRVJUSUVTX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICAgICAgICAgIFByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgIFBSSU1BUllfRVhQUkVTU0lPTl9UUkVFXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBVTklUX0VYUFJFU1NJT05fVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShcclxuICAgICAgICAgICAgW0V4cHJlc3Npb25zLCBQYXR0ZXJuc10sXHJcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgW1wiU2VxdWVuY2VFeHByZXNzaW9uXCJdXHJcbiAgICAgICAgKTtcclxuICAgICAgICBBUlJBWV9FTEVNRU5UU19UUkVFID0gY3JlYXRlTWF0Y2hUcmVlKEFycmF5RWxlbWVudHMsIFVOSVRfRVhQUkVTU0lPTl9UUkVFKTtcclxuXHJcbiAgICAgICAgT0JKRUNUX1BST1BFUlRJRVNfVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShcclxuICAgICAgICAgICAgT2JqZWN0UHJvcGVydGllcyxcclxuICAgICAgICAgICAgVU5JVF9FWFBSRVNTSU9OX1RSRUVcclxuICAgICAgICApO1xyXG4gICAgICAgIFBBUkFNU19UUkVFID0gY3JlYXRlTWF0Y2hUcmVlKFxyXG4gICAgICAgICAgICBQYXJhbXMsXHJcbiAgICAgICAgICAgIFVOSVRfRVhQUkVTU0lPTl9UUkVFXHJcbiAgICAgICAgKTtcclxuICAgICAgICBBUkdVTUVOVFNfVFJFRSA9IGNyZWF0ZU1hdGNoVHJlZShcclxuICAgICAgICAgICAgQXJndW1lbnRzLFxyXG4gICAgICAgICAgICBVTklUX0VYUFJFU1NJT05fVFJFRVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgRVhQUkVTU0lPTl9UUkVFID0gY3JlYXRlTWF0Y2hUcmVlKFxyXG4gICAgICAgICAgICB7IFNlcXVlbmNlRXhwcmVzc2lvbjogRXhwcmVzc2lvbnMuU2VxdWVuY2VFeHByZXNzaW9uIH1cclxuICAgICAgICAgICAgLCBVTklUX0VYUFJFU1NJT05fVFJFRVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXN5bmNfZ2V0dGVyLkVYUFJFU1NJT05fVFJFRSA9IEVYUFJFU1NJT05fVFJFRTtcclxuICAgICAgICBhc3luY19nZXR0ZXIuVU5JVF9FWFBSRVNTSU9OX1RSRUUgPSBVTklUX0VYUFJFU1NJT05fVFJFRTtcclxuICAgIH1cclxuKVxyXG5cclxuXHJcbmFzeW5jX2dldHRlci5nZXQoXCJFeHByZXNzaW9uc1wiLCBmdW5jdGlvbiAoZXhwcmVzc2lvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgIGZvciAoY29uc3QgdHlwZV9uYW1lIGluIGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgaWYgKHR5cGVfbmFtZSkge1xyXG4gICAgICAgICAgICBUWVBFX0FMSUFTW3R5cGVfbmFtZV0gPSBbdHlwZV9uYW1lLCBcIltFeHByZXNzaW9uXVwiXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5leHBvcnQgZGVmYXVsdCBFeHByZXNzaW9ucztcclxuZXhwb3J0IHtcclxuICAgIFByaW1hcnlFeHByZXNzaW9ucyxcclxuICAgIEV4cHJlc3Npb25zLFxyXG4gICAgcGFyc2VBcnJheVBhdHRlcm4sXHJcbiAgICBwYXJzZU9iamVjdFBhdHRlcm4sXHJcbiAgICBwYXJzZV9wYXJhbXNcclxufTtcclxuZnVuY3Rpb24gcGFyc2VfcGFyYW1zKGNvbnRleHQ6IENvbnRleHQsIHRva2VuczogQXJyYXk8VG9rZW4+KSB7Ly9cclxuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHBhcnNlciA9IGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdO1xyXG4gICAgICAgIGxldCByZXN0b3JlID0gY29udGV4dC5zdG9yZShcclxuICAgICAgICAgICAgQ09OVEVYVC50b2tlbnMsIHRva2VucyxcclxuICAgICAgICAgICAgQ09OVEVYVC5iaW5kaW5nRWxlbWVudCwgdHJ1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29udGV4dFtDT05URVhULnN0cmljdF0gJiYgY29udGV4dC53cmFwKENPTlRFWFQuYmluZGluZ1NldCwgW10pO1xyXG4gICAgICAgIHBhcnNlci5wYXJzZUN1c3RvbShQQVJBTVNfVFJFRSwgY29udGV4dCk7XHJcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKHJlc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBleHRyYWN0X3N1Y2Nlc3MocGFyc2VyLCB0b2tlbnMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaW5pdF90b2tlbl9ob29rcygpIHtcclxuICAgIGZ1bmN0aW9uIGdldExpdGVyYWwocGFyc2VfdmFsdWU6ICh0b2tlbjogVG9rZW4sIHRva2VuaXplcjogVG9rZW5pemVyKSA9PiBhbnksIHRva2VuOiBUb2tlbiwgdG9rZW5pemVyOiBUb2tlbml6ZXIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBcIkxpdGVyYWxcIixcclxuICAgICAgICAgICAgdmFsdWU6IHBhcnNlX3ZhbHVlKHRva2VuLCB0b2tlbml6ZXIpLFxyXG4gICAgICAgICAgICByYXc6IHRva2VuLnZhbHVlLFxyXG4gICAgICAgICAgICByYW5nZTogdG9rZW4ucmFuZ2UsXHJcbiAgICAgICAgICAgIGxvYzogdG9rZW4ubG9jXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBnZXRTdHJpbmdMaXRlcmFsID0gZ2V0TGl0ZXJhbC5iaW5kKG51bGwsICh0b2tlbjogVG9rZW4sIHRva2VuaXplcjogVG9rZW5pemVyKSA9PiB0b2tlbml6ZXIuX3ZvbGF0aWxpdHkpO1xyXG4gICAgbGV0IGdldFJlZ3VsYXJMaXRlcmFsID0gZ2V0TGl0ZXJhbC5iaW5kKG51bGwsICh0b2tlbjogVG9rZW4sIHRva2VuaXplcjogVG9rZW5pemVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHJlZ2V4ID0gdG9rZW4ucmVnZXg7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgucGF0dGVybiwgcmVnZXguZmxhZ3MpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdG9rZW5faG9va3MuS2V5d29yZCA9IGZ1bmN0aW9uICh0b2tlbjogVG9rZW4sIHBhcnNlcjogUGFyc2VyKSB7XHJcbiAgICAgICAgbGV0IGNvbnRleHQgPSBwYXJzZXIuY29udGV4dF9zdGFja1swXTtcclxuICAgICAgICBpZiAoIWNvbnRleHRbQ09OVEVYVC5hbGxvd1lpZWxkXSAmJiB0b2tlbi52YWx1ZSA9PT0gXCJ5aWVsZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWludGVycHJldEtleXdvcmRBc0lkZW50aWZpZXIodG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9O1xyXG4gICAgdG9rZW5faG9va3MuSWRlbnRpZmllciA9IHJlaW50ZXJwcmV0S2V5d29yZEFzSWRlbnRpZmllcjtcclxuICAgIHRva2VuX2hvb2tzLk51bWVyaWMgPSBnZXRMaXRlcmFsLmJpbmQobnVsbCwgKHRva2VuOiBUb2tlbikgPT4gTnVtYmVyKHRva2VuLnZhbHVlKSk7XHJcbiAgICB0b2tlbl9ob29rcy5Cb29sZWFuID0gZ2V0TGl0ZXJhbC5iaW5kKG51bGwsICh0b2tlbjogVG9rZW4pID0+IHRva2VuLnZhbHVlID09PSBcInRydWVcIik7XHJcbiAgICB0b2tlbl9ob29rcy5TdHJpbmcgPSBmdW5jdGlvbiAodG9rZW46IFRva2VuLCBwYXJzZXI6IFBhcnNlcikge1xyXG4gICAgICAgIHRva2VuID0gZ2V0U3RyaW5nTGl0ZXJhbCh0b2tlbiwgcGFyc2VyKTtcclxuICAgICAgICBpZiAocGFyc2VyLl9zY29wZXMub2N0YWwgJiYgcGFyc2VyLmNvbnRleHRfc3RhY2tbMF1bQ09OVEVYVC5zdHJpY3RdKSB7XHJcbiAgICAgICAgICAgIHBhcnNlci5lcnIodG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9O1xyXG4gICAgdG9rZW5faG9va3MuTnVsbCA9IGdldExpdGVyYWwuYmluZChudWxsLCAoKSA9PiBudWxsKTtcclxuICAgIHRva2VuX2hvb2tzLlJlZ3VsYXJFeHByZXNzaW9uID0gZnVuY3Rpb24gKHRva2VuOiBUb2tlbiwgdG9rZW5pemVyOiBUb2tlbml6ZXIpIHtcclxuICAgICAgICBsZXQgcmVzID0gZ2V0UmVndWxhckxpdGVyYWwodG9rZW4sIHRva2VuaXplcik7XHJcbiAgICAgICAgcmVzLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUdBO0FBa0NBO0FBNGtDQTtBQUNBO0FBemtDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFPQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTs7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb3VCQTtBQWx1QkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUE0VUE7QUF6VUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBRUE7QUFZQTtBQUdBO0FBR0E7QUFHQTtBQUtBO0FBS0E7QUFFQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../js/syntax/expression.ts\n");

/***/ }),

/***/ "../../js/syntax/head.ts":
/*!**********************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/head.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._Loop = exports._Mark = exports._NonCollecting = exports._NonCapturing = exports._Series = exports._Or = exports._Option = exports._Context = exports.validateAssignment = exports.validateIdentifier = exports.isStrictModeReservedWord = exports.isFutureReservedWord = exports.isRestrictedWord = exports.createMatchTree = exports.TYPE_ALIAS = exports.NODES = exports.validateLineTerminator = exports.validateBinding = exports.ASSIGNMENT_PUNCTUATORS_PATTERN = exports.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = exports.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = exports.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = exports.IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = exports.join_content = exports._SuccessCollector = exports.TOPLEVEL_ITEM_PATTERN = exports.RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN = exports.STATEMANT_LIST_ITEM_PATTERN = exports.isAligned = exports.Mark = exports.Cover = exports.attachLocation = exports.reinterpretKeywordAsIdentifier = exports.reinterpretIdentifierAsKeyword = exports._Validate = exports.is_right_braces = exports.is_right_brackets = exports.is_right_parentheses = exports._Pattern = exports._Identifier = exports._Keyword = exports._Punctuator = exports.parse_and_extract = exports.extract_success = exports.get_inner_group = exports.parse_next_statement = exports.token_hooks = exports.async_getter = void 0;\nvar index_1 = __webpack_require__(/*! ../lexical/index */ \"../../js/lexical/index.ts\");\nvar type_punctuator = index_1.TYPE_ENUMS.Punctuator;\nvar type_keyword = index_1.TYPE_ENUMS.Keyword;\nvar type_identifier = index_1.TYPE_ENUMS.Identifier;\nfunction _Punctuator() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    values.unshift(type_punctuator);\n    return _Or(values);\n}\nexports._Punctuator = _Punctuator;\nfunction _Keyword() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    values.unshift(type_keyword);\n    return _Or(values);\n}\nexports._Keyword = _Keyword;\nfunction _Identifier() {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    values.unshift(type_identifier);\n    return _Or(values);\n}\nexports._Identifier = _Identifier;\nfunction _Pattern() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return _Or(args);\n}\nexports._Pattern = _Pattern;\nvar OPERATOR_ID = 0;\nfunction _calc_nth(props, key) {\n    var nth = 0;\n    if (!(key instanceof Cover) && props.length) {\n        key instanceof Mark && (key = key.key);\n        for (var i = props.length - 1; i >= 0; i--) {\n            var prop = props[i], _key = prop[0];\n            if (_key === key\n                || _key instanceof Mark\n                    && _key.key === key\n                    && (_key.value !== undefined || _key.data !== Mark.prototype.data)) {\n                if (prop[1] === 0) {\n                    prop = props[i] = [prop[0], 1, prop[2]];\n                }\n                nth = prop[1] + 1;\n            }\n            else if (!(_key instanceof Cover && _key.origin === key)) {\n                break;\n            }\n        }\n    }\n    return nth;\n}\nvar Operator = /** @class */ (function () {\n    function Operator(operands) {\n        this.operands = operands;\n        this.sub_operators = [];\n    }\n    Operator.prototype.pipe = function (pipe) {\n        if (this._pipes) {\n            this._pipes.push(pipe);\n        }\n        else {\n            this._pipes = [pipe];\n        }\n        return this;\n    };\n    Operator.prototype.walk = function (walker, bind_env) {\n        this._walker = walker;\n        this._bind_env = !!bind_env;\n        return this;\n    };\n    Object.defineProperty(Operator.prototype, \"factors\", {\n        get: function () {\n            if (!this._factors) {\n                this._factors = [];\n                for (var _i = 0, _a = this.operands; _i < _a.length; _i++) {\n                    var operand = _a[_i];\n                    if (operand instanceof Operator || operand instanceof Mark) {\n                        this._factors.push(operand);\n                    }\n                    else {\n                        var parts = typeof operand === \"string\" ?\n                            operand.replace(/^\\s+|\\s+$/g, \"\").split(/\\s+/) :\n                            operand;\n                        this._factors.push([\n                            parts[0],\n                            parts.length > 1\n                                ? parts.slice(1)\n                                : [\" TYPE\" /* TYPE_ONLY */]\n                        ]);\n                    }\n                }\n            }\n            return this._factors;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Operator.prototype.map = function (parents, factor, key, pipes) {\n        var result = [];\n        var _pipes = pipes\n            ? this._pipes ?\n                this._pipes.concat(pipes)\n                : pipes\n            : this._pipes;\n        if (factor instanceof Operator || factor instanceof Mark) {\n            return factor.attach(parents, key, _pipes);\n        }\n        else {\n            var type = factor[0], values = factor[1];\n            for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {\n                var prev_item = parents_1[_i];\n                var root = prev_item[0], props = prev_item[1];\n                props = props.slice();\n                props.push([key, _calc_nth(props, key), _pipes]);\n                var parent_1 = this.getNode(root, type);\n                var walker = this._walker;\n                if (walker && this._bind_env) {\n                    walker = walker.bind(props.reduce(function (res, prop) {\n                        var key = prop[0];\n                        if (key instanceof Mark) {\n                            res[key.key] = key.value;\n                        }\n                        else {\n                            res[key instanceof Cover ? key.origin : key] = true;\n                        }\n                        return res;\n                    }, {}));\n                }\n                for (var _a = 0, values_1 = values; _a < values_1.length; _a++) {\n                    var value = values_1[_a];\n                    var value_node = this.getNode(parent_1, value, root);\n                    if (value_node[\" WAL\" /* WALKER */]\n                        && value_node[\" WAL\" /* WALKER */] !== walker) {\n                        console.warn(\"conflict:\", value_node, value_node[\" WAL\" /* WALKER */], walker);\n                    }\n                    if (walker) {\n                        value_node[\" WAL\" /* WALKER */] = walker;\n                    }\n                    result.push([\n                        value_node,\n                        props,\n                        null /*[root, factor[0], value, prev_item]//Loop*/\n                    ]);\n                }\n            }\n        }\n        return result;\n    };\n    Operator.prototype.getNode = function (parent, key, root) {\n        var _a;\n        var child = parent[key];\n        if (child) {\n            if (child[\" ID\" /* IDENTIFIER */] !== OPERATOR_ID) {\n                parent[key] = child = __assign({}, child);\n                child[\" ID\" /* IDENTIFIER */] = OPERATOR_ID;\n            }\n            return child;\n        }\n        child = parent[key] = (_a = {},\n            _a[\" ID\" /* IDENTIFIER */] = OPERATOR_ID,\n            _a);\n        if (root) {\n            child[\" DEEP\" /* DEEPTH */] = root[\" DEEP\" /* DEEPTH */] + 1;\n            root[\" TER\" /* TERMINAL */] = false;\n            child[\" TER\" /* TERMINAL */] = true;\n            /*if (root[MATCH_MARKS.MATCH_END]) {\n                root[MATCH_MARKS.MATCH_END][MATCHED_RECORDS.precedence][PRECEDENCE.TERMINAL] = false;\n            }*/\n        }\n        return child;\n    };\n    Operator.prototype.setWrap = function (records) {\n        throw 'not used';\n        for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n            var record = records_1[_i];\n            var prev_item = record, curr_item = prev_item;\n            while ((curr_item = prev_item[2] && prev_item[2][3]) && curr_item[2]) {\n                prev_item = curr_item;\n            }\n            if (prev_item[2]) {\n                var linked = prev_item[2];\n                var node = this.getNode(record[0], linked[1]);\n                if (node[linked[2]] && node[linked[2]] !== prev_item[0]) {\n                    throw node[linked[2]];\n                }\n                node[linked[2]] = prev_item[0];\n            }\n        }\n        return records;\n    };\n    Operator.prototype.getDeepNodes = function (parents, key, pipes) {\n        var children = parents, factors = this.factors;\n        for (var _i = 0, factors_1 = factors; _i < factors_1.length; _i++) {\n            var factor = factors_1[_i];\n            children = this.map(children, factor, key, pipes);\n        }\n        return children;\n    };\n    Operator.prototype.getNextNodes = function (parents, key, pipes) {\n        var children = [], factors = this.factors;\n        for (var _i = 0, factors_2 = factors; _i < factors_2.length; _i++) {\n            var factor = factors_2[_i];\n            Array.prototype.push.apply(children, this.map(parents, factor, key, pipes));\n        }\n        return children;\n    };\n    return Operator;\n}());\nvar Option = /** @class */ (function (_super) {\n    __extends(Option, _super);\n    function Option() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Option.prototype.attach = function (parents, key, pipes) {\n        var children = this.getNextNodes(parents, key, pipes).concat(parents);\n        return children;\n    };\n    return Option;\n}(Operator));\nvar Or = /** @class */ (function (_super) {\n    __extends(Or, _super);\n    function Or() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Or.prototype.attach = function (parents, key, pipes) {\n        return this.getNextNodes(parents, key, pipes);\n    };\n    return Or;\n}(Operator));\nvar Series = /** @class */ (function (_super) {\n    __extends(Series, _super);\n    function Series() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Series.prototype.attach = function (parents, key, pipes) {\n        return this.getDeepNodes(parents, key, pipes);\n    };\n    return Series;\n}(Operator));\n/*\nclass And extends Operator  {\n    attach(parents: IterationRecord, key: string) {\n        throw \"not used\";\n        return [];\n    }\n}\nclass Not extends Operator {\n    attach(parents: IterationRecord, key: string) {\n        throw \"not used\";\n        return [];\n        \n    }\n}*/\nvar Cover = /** @class */ (function () {\n    function Cover(origin, value) {\n        this.origin = origin;\n        this.value = value;\n        if (origin instanceof Cover) {\n            this.origin = origin.origin;\n        }\n    }\n    return Cover;\n}());\nexports.Cover = Cover;\nvar NonCapturing = /** @class */ (function (_super) {\n    __extends(NonCapturing, _super);\n    function NonCapturing() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NonCapturing.prototype.attach = function (parents, key, pipes) {\n        return this.getNextNodes(parents, new Cover(key, null), pipes);\n    };\n    return NonCapturing;\n}(Operator));\nvar NonCollecting = /** @class */ (function (_super) {\n    __extends(NonCollecting, _super);\n    function NonCollecting() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NonCollecting.prototype.attach = function (parents, key, pipes) {\n        return this.getNextNodes(parents, new Cover(key, \"\"), pipes);\n    };\n    return NonCollecting;\n}(Operator));\nvar Loop = /** @class */ (function (_super) {\n    __extends(Loop, _super);\n    function Loop() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    //Loop 内部的 Option 可能会导致 Loop 取值混乱(当前用不到这种情况，不处理这种情况能减少消耗)\n    Loop.prototype.attach = function (parents, key) {\n        throw 'not used';\n        //有点耗费性能，不是很必要用这个，已在parser核心部分去除Loop的支持\n        var baks = [];\n        for (var _i = 0, parents_2 = parents; _i < parents_2.length; _i++) {\n            var parent_2 = parents_2[_i];\n            baks.push(parent_2[2]);\n            parent_2[2] = null;\n        }\n        var res = this.setWrap(this.getNextNodes(parents, key));\n        for (var index in parents) {\n            parents[index][2] = baks[index];\n        }\n        return res;\n    };\n    return Loop;\n}(Operator));\nvar Mark = /** @class */ (function () {\n    function Mark(value) {\n        if (typeof value === \"function\") {\n            this.data = value;\n        }\n        else {\n            this.value = value;\n        }\n    }\n    Mark.prototype.data = function (context, index) {\n        return this.value;\n    };\n    Mark.prototype.attach = function (parents, key, pipes) {\n        var value = this.value;\n        if (!(key instanceof Cover) && (value !== undefined || this.data !== Mark.prototype.data)) {\n            if (key === \"type\") {\n                Mark.MATCHED_RECORD[2 /* wrapper */] = _get_wrapper_function(value);\n                ;\n            }\n            else {\n                var result = [];\n                this.key = key;\n                for (var _i = 0, parents_3 = parents; _i < parents_3.length; _i++) {\n                    var parent_3 = parents_3[_i];\n                    var props = parent_3[1].slice();\n                    props.push([this, _calc_nth(props, this), undefined]);\n                    result.push([parent_3[0], props, parent_3[2]]);\n                }\n                return result;\n            }\n        }\n        return parents;\n    };\n    return Mark;\n}());\nexports.Mark = Mark;\nfunction _Option() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new Option(some);\n}\nexports._Option = _Option;\n/*\nfunction _Not(...some: Operands) {\n    return new Not(some);\n}\nfunction _And(...some: Operands) {\n    return new And(some);\n}*/\nfunction _Or() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new Or(some);\n}\nexports._Or = _Or;\nfunction _Series() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new Series(some);\n}\nexports._Series = _Series;\nfunction _NonCapturing() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new NonCapturing(some);\n}\nexports._NonCapturing = _NonCapturing;\nfunction _NonCollecting() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new NonCollecting(some);\n}\nexports._NonCollecting = _NonCollecting;\nfunction _Loop() {\n    var some = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        some[_i] = arguments[_i];\n    }\n    return new Loop(some);\n}\nexports._Loop = _Loop;\nfunction _Mark(some) {\n    return new Mark(some);\n}\nexports._Mark = _Mark;\nvar NODES = {\n    Grouping: function (node, grouping) {\n        this.type = \"Grouping\";\n        for (var key in node) {\n            this[key] = node[key];\n        }\n        if (grouping) {\n            this.range = grouping.range;\n            this.loc = grouping.loc;\n        }\n    },\n    Directive: function (type, expression, directive, range, loc) {\n        this.type = type;\n        this.expression = expression;\n        this.directive = directive;\n        this.range = range;\n        this.loc = loc;\n    },\n    Script: function (body) {\n        this.type = \"Program\";\n        this.sourceType = \"script\";\n        this.body = body;\n    },\n    Module: function (body) {\n        this.type = \"Program\";\n        this.sourceType = \"module\";\n        this.body = body;\n    }\n};\nexports.NODES = NODES;\nfunction _get_adapt(data, index) {\n    return data instanceof Array ? index < data.length\n        ? data[index]\n        : data[data.length - 1] : data;\n}\nfunction _get_wrapper_function(type) {\n    return NODES[type]\n        || (NODES[type]\n            = type ? eval(\"(function \" + type + \"(){this.type=\\\"\" + type + \"\\\"})\") : function () { });\n}\nfunction createMatchTree(data, root, block_list, prevent_update) {\n    var _a;\n    if (block_list === void 0) { block_list = []; }\n    if (prevent_update === void 0) { prevent_update = false; }\n    prevent_update || (OPERATOR_ID += 1);\n    root = root ? prevent_update ? root : __assign({}, root) : (_a = {}, _a[\" DEEP\" /* DEEPTH */] = -1, _a);\n    if (data instanceof Array) {\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n            var item = data_1[_i];\n            root = createMatchTree(item, root, block_list, true);\n        }\n    }\n    else {\n        for (var type in data) {\n            var wrapper = _get_wrapper_function(type);\n            for (var _b = 0, _c = data[type] instanceof Array ? data[type] : [data[type]]; _b < _c.length; _b++) {\n                var item = _c[_b];\n                var collectors = item.collector, handlers = item.handler, overload = item.overload, _d = item.precedence /*PRECEDENCE_FEATURES.IMMEDIATE*/, precedences = _d === void 0 ? true : _d /*PRECEDENCE_FEATURES.IMMEDIATE*/, filters = item.filter, validators = item.validator;\n                if (!collectors || ~block_list.indexOf(type)) {\n                    continue;\n                }\n                typeof filters === \"string\" && (filters = data[filters].filter);\n                typeof handlers === \"string\" && (handlers = data[handlers].handler);\n                typeof validators === \"string\" && (validators = data[validators].validator);\n                collectors instanceof Array || (collectors = [collectors]);\n                for (var index = 0; index < collectors.length; index++) {\n                    var collector = collectors[index];\n                    var precedence = _get_adapt(precedences, index);\n                    var handler = _get_adapt(handlers, index);\n                    var filter = _get_adapt(filters, index);\n                    var validator = _get_adapt(validators, index);\n                    Mark.MATCHED_RECORD = [\n                        [precedence instanceof Number ? Number(precedence) : precedence, precedence],\n                        null,\n                        wrapper,\n                        handler,\n                        validator,\n                        filter\n                    ];\n                    if (collector instanceof Array) {\n                        var _collector = __assign({}, collectors[index - 1]);\n                        collector[0] && !(collector[0] instanceof Array) && (collector = [collector]);\n                        for (var _e = 0, collector_1 = collector; _e < collector_1.length; _e++) {\n                            var _f = collector_1[_e], key = _f[0], value = _f[1];\n                            _collector[key] = value;\n                        }\n                        collectors[index] = collector = _collector;\n                    }\n                    var nodes = [[root, [], null]];\n                    //保证所有 key 都是同类型字符开头(否则可能会出现遍历顺序与定义顺序不同)\n                    for (var key in collector) {\n                        var operator = collector[key];\n                        if (!(operator instanceof Operator || operator instanceof Mark)) {\n                            operator = _Or(operator);\n                        }\n                        nodes = operator.attach(nodes, key);\n                    }\n                    for (var _g = 0, nodes_1 = nodes; _g < nodes_1.length; _g++) {\n                        var _h = nodes_1[_g], last_node = _h[0], props = _h[1];\n                        var matched_record = Mark.MATCHED_RECORD.slice();\n                        matched_record[1 /* props */] = props;\n                        if (!overload && last_node[\" END\" /* END */]) {\n                            console.warn(\"conflict:\", last_node, last_node[\" END\" /* END */], matched_record);\n                        }\n                        last_node[\" END\" /* END */] = matched_record;\n                    }\n                }\n            }\n        }\n    }\n    return root;\n}\nexports.createMatchTree = createMatchTree;\nfunction _Context(parser) {\n    var state_stack = [];\n    var context = new Array(22 /* length */);\n    context[1 /* parser */] = parser;\n    context[11 /* labelSet */] = [];\n    //context[CONTEXT.tokens] = tokens;\n    context.wrap = wrap;\n    context.unwrap = unwrap;\n    context.store = store;\n    context.restore = restore;\n    context.getToken = getToken;\n    Object.defineProperty(context, \"tokens\", {\n        get: function () {\n            return this[7 /* tokens */] || this[1 /* parser */].tokens;\n        }\n    });\n    return context;\n    function getToken(index) {\n        var tokens = this[7 /* tokens */];\n        return !tokens ? this[1 /* parser */].getToken(index) : tokens[index];\n        //return context[CONTEXT.tokens][index];\n    }\n    function wrap(key, value) {\n        state_stack.push(context[key], key);\n        context[key] = value;\n        return context;\n    }\n    ;\n    function unwrap() {\n        context[state_stack.pop()] = state_stack.pop();\n        return context;\n    }\n    ;\n    function store() {\n        var restore_point = state_stack.length;\n        for (var index = 0; index < arguments.length; index += 2) {\n            wrap(arguments[index], arguments[index + 1]);\n        }\n        return restore_point;\n    }\n    function restore(point) {\n        while (state_stack.length > point) {\n            unwrap();\n        }\n        return state_stack.length;\n    }\n}\nexports._Context = _Context;\nvar FutureReservedWord = [\"enum\", \"export\", \"import\", \"super\"];\nvar StrictModeReservedWord = [\n    \"implements\", \"interface\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"let\"\n];\nvar RestrictedWord = [\"eval\", \"arguments\"];\nfunction isFutureReservedWord(id) {\n    return FutureReservedWord.indexOf(id) >= 0;\n}\nexports.isFutureReservedWord = isFutureReservedWord;\nfunction isStrictModeReservedWord(id) {\n    return StrictModeReservedWord.indexOf(id) >= 0;\n}\nexports.isStrictModeReservedWord = isStrictModeReservedWord;\nfunction isRestrictedWord(id) {\n    return RestrictedWord.indexOf(id) >= 0;\n}\nexports.isRestrictedWord = isRestrictedWord;\nfunction _if_strict_throw_err(context, token) {\n    if (context[12 /* strict */]) {\n        context[1 /* parser */].err(token);\n    }\n}\nfunction _if_reserved_throw_err(context, token) {\n    validateIdentifier(context, token);\n}\nvar THROW_RESTRICT_WORDS_PATTERN = _Or(\"Identifier eval arguments\").pipe(_if_strict_throw_err);\nvar THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier implements interface package private protected public static yield let\").pipe(_if_strict_throw_err);\nvar IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\", THROW_STRICT_RESERVED_WORDS_PATTERN);\nexports.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN;\nvar EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = _Or(\"[Expression]\", THROW_STRICT_RESERVED_WORDS_PATTERN);\nexports.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN = EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN;\nvar IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\"Identifier\").pipe(_if_reserved_throw_err);\nexports.IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN;\nvar EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = _Or(\"[Expression]\", IDENTIFIER_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN);\nexports.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN = EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN;\n/*const STRICT_RESERVED_WORDS = _Or(\n    \"Identifier implements interface package private protected public static yield let\"\n);*/\nfunction validateIdentifier(context, node) {\n    if (context[12 /* strict */]) {\n        if (!isStrictModeReservedWord(node.name)) {\n            return true;\n        }\n        context[1 /* parser */].err(node);\n        return false;\n    }\n}\nexports.validateIdentifier = validateIdentifier;\nfunction validateAssignment(context, node) {\n    if (context[12 /* strict */]) {\n        if (!(isRestrictedWord(node.name)\n            || isStrictModeReservedWord(node.name))) {\n            return true;\n        }\n        context[1 /* parser */].err(node);\n        return false;\n    }\n}\nexports.validateAssignment = validateAssignment;\nfunction validateBinding(context, node) {\n    if (validateAssignment(context, node) === true) {\n        var binding_set = context[10 /* bindingSet */];\n        if (binding_set) {\n            binding_set.push(node.name);\n            if (binding_set.indexOf(node.name) !== binding_set.length - 1) {\n                context[1 /* parser */].err(node);\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.validateBinding = validateBinding;\nfunction validateLineTerminator(context) {\n    var collected = context[0], parser = context[1], right = context[3];\n    if (collected._next) {\n        delete collected._next;\n    }\n    else {\n        var next_token = context.getToken(right + 1);\n        if (next_token\n            && !(next_token.type === type_punctuator && next_token.value === \"}\")\n            && next_token.loc.start.line === collected.loc.end.line) {\n            parser.err(next_token);\n        }\n    }\n    return collected;\n}\nexports.validateLineTerminator = validateLineTerminator;\nfunction _SuccessCollector(pattern) {\n    return {\n        Success: {\n            handler: join_content,\n            precedence: 0,\n            collector: [\n                {\n                    success: _Or(_NonCollecting(\"\" /* BOUNDARY */), \"Success\"),\n                    content: pattern,\n                }\n            ]\n        }\n    };\n}\nexports._SuccessCollector = _SuccessCollector;\nvar join_content = function (_a) {\n    var collected = _a[0];\n    var success = collected.success, content = collected.content;\n    if (success) {\n        success.content.push(content);\n        return success;\n    }\n    else {\n        collected.content = [content];\n        return collected;\n    }\n};\nexports.join_content = join_content;\nvar TYPE_ALIAS = {};\nexports.TYPE_ALIAS = TYPE_ALIAS;\nvar ASSIGNMENT_PUNCTUATORS_PATTERN = _Or(\"Punctuator = += -= **= *= /= %= <<= >>= >>>= &= ^= |=\");\nexports.ASSIGNMENT_PUNCTUATORS_PATTERN = ASSIGNMENT_PUNCTUATORS_PATTERN;\nvar MODULE_ITEM_PATTERN = _Or(\"ImportDeclaration\", \"ExportAllDeclaration\", \"ExportNamedDeclaration\", \"ExportDefaultDeclaration\");\nvar STATEMANT_LIST_ITEM_PATTERN = _Or(\"[Declaration]\", \"[Statement]\");\nexports.STATEMANT_LIST_ITEM_PATTERN = STATEMANT_LIST_ITEM_PATTERN;\nvar RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN = _Or(\"SwitchCase\", MODULE_ITEM_PATTERN, STATEMANT_LIST_ITEM_PATTERN);\nexports.RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN = RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN;\nvar TOPLEVEL_ITEM_PATTERN = _Or(\"\" /* BOUNDARY */, \"SwitchCase\", MODULE_ITEM_PATTERN, STATEMANT_LIST_ITEM_PATTERN);\nexports.TOPLEVEL_ITEM_PATTERN = TOPLEVEL_ITEM_PATTERN;\nfunction isAligned(context, left, right) {\n    var tokens = context.tokens;\n    for (var index = left; index < right; index++) {\n        if (tokens[index].loc.end.line !== tokens[index + 1].loc.start.line) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isAligned = isAligned;\nfunction attachLocation(source, start, end) {\n    if (end === void 0) { end = start; }\n    source.range = [start.range[0], end.range[1]];\n    source.loc = {\n        start: start.loc.start,\n        end: end.loc.end\n    };\n}\nexports.attachLocation = attachLocation;\nfunction reinterpretKeywordAsIdentifier(_a, tokenizer) {\n    var value = _a.value, range = _a.range, loc = _a.loc;\n    var name = tokenizer ? tokenizer._volatility : value;\n    var identifier = {\n        type: \"Identifier\",\n        name: name, range: range, loc: loc\n    };\n    Object.defineProperty(identifier, \"value\", {\n        configurable: true,\n        enumerable: false,\n        value: name\n    });\n    return identifier;\n}\nexports.reinterpretKeywordAsIdentifier = reinterpretKeywordAsIdentifier;\nfunction reinterpretIdentifierAsKeyword(_a) {\n    var value = _a.value, range = _a.range, loc = _a.loc;\n    return {\n        type: \"Keyword\",\n        value: value,\n        range: range,\n        loc: loc\n    };\n}\nexports.reinterpretIdentifierAsKeyword = reinterpretIdentifierAsKeyword;\nfunction _Validate(type, value) {\n    return function (token) {\n        return token.type === type && token.value === value;\n    };\n}\nexports._Validate = _Validate;\nvar is_right_parentheses = _Validate(type_punctuator, \")\");\nexports.is_right_parentheses = is_right_parentheses;\nvar is_right_brackets = _Validate(type_punctuator, \"]\");\nexports.is_right_brackets = is_right_brackets;\nvar is_right_braces = _Validate(type_punctuator, \"}\");\nexports.is_right_braces = is_right_braces;\nfunction extract_success(parser, nodes) {\n    var res = nodes;\n    if (nodes.length) {\n        var index = 0;\n        if (nodes[0].type === \"Success\") {\n            index = 1;\n            res = nodes[0].content;\n        }\n        else {\n            res = [];\n        }\n        if (nodes.length > index) {\n            parser.err.apply(parser, nodes.slice(index));\n        }\n    }\n    return res;\n}\nexports.extract_success = extract_success;\nfunction parse_and_extract(match_tree, context, node) {\n    var parser = context[1];\n    var tokens = node.content;\n    if (tokens.length) {\n        context.wrap(7 /* tokens */, tokens);\n        //context[CONTEXT.tokens] = tokens;\n        parser.parseCustom(match_tree, context);\n        tokens = extract_success(parser, tokens);\n        context.unwrap();\n    }\n    return tokens;\n}\nexports.parse_and_extract = parse_and_extract;\nfunction get_inner_group(token) {\n    while (token.content.length === 1\n        && token.content[0].value === \"()\"\n        && token.content[0].type === type_punctuator) {\n        token = token.content[0];\n    }\n    return token;\n}\nexports.get_inner_group = get_inner_group;\nfunction parse_next_statement(context, start) {\n    if (start === void 0) { start = context[3 /* right */] + 1; }\n    var parser = context[1 /* parser */];\n    if (parser.parseCustom(parser.SYNTAX_TREE, context, start, parser.isStatementListItem)) {\n        return 0;\n    }\n}\nexports.parse_next_statement = parse_next_statement;\nvar token_hooks = {};\nexports.token_hooks = token_hooks;\nfunction AsyncGetter() {\n    var await_tasks = {};\n    var async_data = {};\n    var is_open = false;\n    var async_mapper = {\n        open: function () {\n            is_open = true;\n            var tasks = [];\n            for (var key in await_tasks) {\n                if (async_data.hasOwnProperty(key)) {\n                    var data = async_data[key];\n                    for (var _i = 0, _a = await_tasks[key]; _i < _a.length; _i++) {\n                        var task = _a[_i];\n                        tasks.push([task, data]);\n                    }\n                }\n            }\n            for (var _b = 0, tasks_1 = tasks; _b < tasks_1.length; _b++) {\n                var task = tasks_1[_b];\n                task[0](task[1]);\n            }\n        },\n        get: function (key, callback) {\n            if (await_tasks[key]) {\n                await_tasks[key].push(callback);\n                if (is_open && async_data.hasOwnProperty(key)) {\n                    callback(async_data[key]);\n                }\n            }\n            else {\n                if (async_mapper.hasOwnProperty(key)) {\n                    async_data[key] = async_mapper[key];\n                    is_open && callback(async_data[key]);\n                }\n                Object.defineProperty(async_mapper, key, {\n                    enumerable: true,\n                    configurable: true,\n                    set: function (data) {\n                        if (async_data.hasOwnProperty(key)) {\n                            debugger;\n                        }\n                        async_data[key] = data;\n                        if (is_open) {\n                            for (var _i = 0, _a = await_tasks[key]; _i < _a.length; _i++) {\n                                var cbfun = _a[_i];\n                                cbfun(data);\n                            }\n                        }\n                    },\n                    get: function () {\n                        return async_data[key];\n                    }\n                });\n                await_tasks[key] = [callback];\n            }\n        }\n    };\n    return async_mapper;\n}\nvar async_getter = AsyncGetter();\nexports.async_getter = async_getter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L2hlYWQudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL21udC9kL1Byb2dyYW1GaWxlcy9HaXRIdWIvRGlzb24vanMvc3ludGF4L2hlYWQudHM/YmIxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcblxyXG5pbXBvcnQge1xyXG4gICAgTm9kZVByb3AsXHJcbiAgICBDb3ZlciBhcyBDb3ZlckludGVyZmFjZSxcclxuICAgIE1hcmsgYXMgTWFya0ludGVyZmFjZSxcclxuICAgIE5vZGUsIFBpcGUsIENvbm5lY3RvcixcclxuICAgIE1hdGNoZWQsIENPTlRFWFQsIENvbnRleHQsIFRva2VuLCBTb3VyY2VMb2NhdGlvbixcclxuICAgIE1BVENIRUQsXHJcbiAgICBNQVJLUyxcclxuICAgIC8qUFJFQ0VERU5DRV9GRUFUVVJFUywqLyBQUkVDRURFTkNFLCBQcmVjZWRlbmNlIGFzIFByZWNlZGVuY2VJbnRlcmZhY2UsIE1BVENIRURfUkVDT1JEUywgVmFsaWRhdGVcclxufSBmcm9tICcuLi9pbnRlcmZhY2VzJztcclxuXHJcblxyXG5pbXBvcnQge1xyXG4gICAgVFlQRV9FTlVNU1xyXG59IGZyb20gXCIuLi9sZXhpY2FsL2luZGV4XCI7XHJcblxyXG5pbXBvcnQgVG9rZW5pemVyIGZyb20gXCIuLi90b2tlbml6ZXJcIlxyXG5sZXQgdHlwZV9wdW5jdHVhdG9yID0gVFlQRV9FTlVNUy5QdW5jdHVhdG9yO1xyXG5sZXQgdHlwZV9rZXl3b3JkID0gVFlQRV9FTlVNUy5LZXl3b3JkO1xyXG5sZXQgdHlwZV9pZGVudGlmaWVyID0gVFlQRV9FTlVNUy5JZGVudGlmaWVyO1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9QdW5jdHVhdG9yKC4uLnZhbHVlczogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikge1xyXG4gICAgdmFsdWVzLnVuc2hpZnQodHlwZV9wdW5jdHVhdG9yKTtcclxuICAgIHJldHVybiBfT3IodmFsdWVzKTtcclxufVxyXG5mdW5jdGlvbiBfS2V5d29yZCguLi52YWx1ZXM6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pIHtcclxuICAgIHZhbHVlcy51bnNoaWZ0KHR5cGVfa2V5d29yZCk7XHJcbiAgICByZXR1cm4gX09yKHZhbHVlcyk7XHJcbn1cclxuZnVuY3Rpb24gX0lkZW50aWZpZXIoLi4udmFsdWVzOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KSB7XHJcbiAgICB2YWx1ZXMudW5zaGlmdCh0eXBlX2lkZW50aWZpZXIpO1xyXG4gICAgcmV0dXJuIF9Pcih2YWx1ZXMpO1xyXG59XHJcbmZ1bmN0aW9uIF9QYXR0ZXJuKC4uLmFyZ3M6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pIHtcclxuICAgIHJldHVybiBfT3IoYXJncyk7XHJcbn1cclxuXHJcbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJ1xyXG5sZXQgT1BFUkFUT1JfSUQgPSAwO1xyXG5cclxuZnVuY3Rpb24gX2NhbGNfbnRoKHByb3BzOiBBcnJheTxOb2RlUHJvcD4sIGtleTogc3RyaW5nIHwgTWFyayB8IENvdmVyKSB7XHJcbiAgICBsZXQgbnRoID0gMDtcclxuICAgIGlmICghKGtleSBpbnN0YW5jZW9mIENvdmVyKSAmJiBwcm9wcy5sZW5ndGgpIHtcclxuICAgICAgICBrZXkgaW5zdGFuY2VvZiBNYXJrICYmIChrZXkgPSBrZXkua2V5KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wc1tpXSwgX2tleSA9IHByb3BbMF07XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIF9rZXkgPT09IGtleVxyXG4gICAgICAgICAgICAgICAgfHwgX2tleSBpbnN0YW5jZW9mIE1hcmtcclxuICAgICAgICAgICAgICAgICYmIF9rZXkua2V5ID09PSBrZXlcclxuICAgICAgICAgICAgICAgICYmIChfa2V5LnZhbHVlICE9PSB1bmRlZmluZWQgfHwgX2tleS5kYXRhICE9PSBNYXJrLnByb3RvdHlwZS5kYXRhKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wWzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IHByb3BzW2ldID0gW3Byb3BbMF0sIDEsIHByb3BbMl1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbnRoID0gcHJvcFsxXSArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAhKF9rZXkgaW5zdGFuY2VvZiBDb3ZlciAmJiBfa2V5Lm9yaWdpbiA9PT0ga2V5KVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG50aDtcclxufVxyXG5cclxuYWJzdHJhY3QgY2xhc3MgT3BlcmF0b3Ige1xyXG4gICAgcHJpdmF0ZSBfZmFjdG9yczogQXJyYXk8W3N0cmluZyB8IG51bWJlciwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPl0gfCBPcGVyYXRvciB8IE1hcms+O1xyXG4gICAgcHJpdmF0ZSBfcGlwZXM6IEFycmF5PFBpcGU+O1xyXG4gICAgcHJpdmF0ZSBfd2Fsa2VyOiBDb25uZWN0b3I7XHJcbiAgICBwcml2YXRlIF9iaW5kX2VudjogYm9vbGVhbjtcclxuICAgIHB1YmxpYyBzdWJfb3BlcmF0b3JzID0gW107XHJcbiAgICBwdWJsaWMgdGVzdDogKHRva2VuOiBUb2tlbiwgaW5kZXg/OiBudW1iZXIpID0+IGJvb2xlYW47XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgb3BlcmFuZHM6IE9wZXJhbmRzKSB7IH1cclxuICAgIHB1YmxpYyBwaXBlKHBpcGU6IFBpcGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGlwZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGlwZXMucHVzaChwaXBlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9waXBlcyA9IFtwaXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgd2Fsayh3YWxrZXI6IENvbm5lY3RvciwgYmluZF9lbnY/OiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fd2Fsa2VyID0gd2Fsa2VyO1xyXG4gICAgICAgIHRoaXMuX2JpbmRfZW52ID0gISFiaW5kX2VudjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgZmFjdG9ycygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZhY3RvcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmFjdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wZXJhbmQgb2YgdGhpcy5vcGVyYW5kcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhbmQgaW5zdGFuY2VvZiBPcGVyYXRvciB8fCBvcGVyYW5kIGluc3RhbmNlb2YgTWFyaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhY3RvcnMucHVzaChvcGVyYW5kKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IHR5cGVvZiBvcGVyYW5kID09PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmFuZC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKS5zcGxpdCgvXFxzKy8pIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmFuZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYWN0b3JzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID4gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcGFydHMuc2xpY2UoMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtNQVJLUy5UWVBFX09OTFldXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9mYWN0b3JzO1xyXG4gICAgfVxyXG4gICAgYWJzdHJhY3QgYXR0YWNoKHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCwga2V5OiBzdHJpbmcgfCBDb3ZlciwgcGlwZXM/OiBBcnJheTxQaXBlPik6IEl0ZXJhdGlvblJlY29yZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgbWFwKFxyXG4gICAgICAgIHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCxcclxuICAgICAgICBmYWN0b3I6IFtzdHJpbmcgfCBudW1iZXIsIEFycmF5PHN0cmluZyB8IG51bWJlcj5dIHwgT3BlcmF0b3IgfCBNYXJrLFxyXG4gICAgICAgIGtleTogc3RyaW5nIHwgQ292ZXIsXHJcbiAgICAgICAgcGlwZXM/OiBBcnJheTxQaXBlPlxyXG4gICAgKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDogSXRlcmF0aW9uUmVjb3JkID0gW107XHJcbiAgICAgICAgbGV0IF9waXBlcyA9IHBpcGVzXHJcbiAgICAgICAgICAgID8gdGhpcy5fcGlwZXMgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGlwZXMuY29uY2F0KHBpcGVzKVxyXG4gICAgICAgICAgICAgICAgOiBwaXBlc1xyXG4gICAgICAgICAgICA6IHRoaXMuX3BpcGVzO1xyXG4gICAgICAgIGlmIChmYWN0b3IgaW5zdGFuY2VvZiBPcGVyYXRvciB8fCBmYWN0b3IgaW5zdGFuY2VvZiBNYXJrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3IuYXR0YWNoKHBhcmVudHMsIGtleSwgX3BpcGVzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdHlwZSA9IGZhY3RvclswXSwgdmFsdWVzID0gZmFjdG9yWzFdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXZfaXRlbSBvZiBwYXJlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgW3Jvb3QsIHByb3BzXSA9IHByZXZfaXRlbTtcclxuICAgICAgICAgICAgICAgIHByb3BzID0gcHJvcHMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goW2tleSwgX2NhbGNfbnRoKHByb3BzLCBrZXkpLCBfcGlwZXNdKTtcclxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmdldE5vZGUocm9vdCwgdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHdhbGtlciA9IHRoaXMuX3dhbGtlcjtcclxuICAgICAgICAgICAgICAgIGlmICh3YWxrZXIgJiYgdGhpcy5fYmluZF9lbnYpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIuYmluZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMucmVkdWNlKChyZXMsIHByb3ApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hcmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5LmtleV0gPSBrZXkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXkgaW5zdGFuY2VvZiBDb3ZlciA/IGtleS5vcmlnaW4gOiBrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVfbm9kZSA9IHRoaXMuZ2V0Tm9kZShwYXJlbnQsIHZhbHVlLCByb290KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX25vZGVbTUFSS1MuV0FMS0VSXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB2YWx1ZV9ub2RlW01BUktTLldBTEtFUl0gIT09IHdhbGtlclxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbmZsaWN0OlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfbm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX25vZGVbTUFSS1MuV0FMS0VSXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGtlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX25vZGVbTUFSS1MuV0FMS0VSXSA9IHdhbGtlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlX25vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwvKltyb290LCBmYWN0b3JbMF0sIHZhbHVlLCBwcmV2X2l0ZW1dLy9Mb29wKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGdldE5vZGUocGFyZW50OiBhbnksIGtleTogc3RyaW5nIHwgbnVtYmVyLCByb290PzogYW55KSB7XHJcbiAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50W2tleV07XHJcbiAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFtNQVJLUy5JREVOVElGSUVSXSAhPT0gT1BFUkFUT1JfSUQpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFtrZXldID0gY2hpbGQgPSB7IC4uLmNoaWxkIH07XHJcbiAgICAgICAgICAgICAgICBjaGlsZFtNQVJLUy5JREVOVElGSUVSXSA9IE9QRVJBVE9SX0lEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoaWxkID0gcGFyZW50W2tleV0gPSB7XHJcbiAgICAgICAgICAgIFtNQVJLUy5JREVOVElGSUVSXTogT1BFUkFUT1JfSURcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChyb290KSB7XHJcbiAgICAgICAgICAgIGNoaWxkW01BUktTLkRFRVBUSF0gPSByb290W01BUktTLkRFRVBUSF0gKyAxO1xyXG4gICAgICAgICAgICByb290W01BUktTLlRFUk1JTkFMXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjaGlsZFtNQVJLUy5URVJNSU5BTF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAvKmlmIChyb290W01BVENIX01BUktTLk1BVENIX0VORF0pIHtcclxuICAgICAgICAgICAgICAgIHJvb3RbTUFUQ0hfTUFSS1MuTUFUQ0hfRU5EXVtNQVRDSEVEX1JFQ09SRFMucHJlY2VkZW5jZV1bUFJFQ0VERU5DRS5URVJNSU5BTF0gPSBmYWxzZTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBzZXRXcmFwKHJlY29yZHM6IEl0ZXJhdGlvblJlY29yZCkgey8vTG9vcFxyXG4gICAgICAgIHRocm93ICdub3QgdXNlZCc7XHJcbiAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xyXG4gICAgICAgICAgICBsZXQgcHJldl9pdGVtID0gcmVjb3JkLCBjdXJyX2l0ZW0gPSBwcmV2X2l0ZW07XHJcbiAgICAgICAgICAgIHdoaWxlICgoY3Vycl9pdGVtID0gcHJldl9pdGVtWzJdICYmIHByZXZfaXRlbVsyXVszXSkgJiYgY3Vycl9pdGVtWzJdKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2X2l0ZW0gPSBjdXJyX2l0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZfaXRlbVsyXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmtlZCA9IHByZXZfaXRlbVsyXTtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5nZXROb2RlKHJlY29yZFswXSwgbGlua2VkWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlW2xpbmtlZFsyXV0gJiYgbm9kZVtsaW5rZWRbMl1dICE9PSBwcmV2X2l0ZW1bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBub2RlW2xpbmtlZFsyXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlW2xpbmtlZFsyXV0gPSBwcmV2X2l0ZW1bMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZ2V0RGVlcE5vZGVzKHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCwga2V5OiBzdHJpbmcgfCBDb3ZlciwgcGlwZXM/OiBBcnJheTxQaXBlPikge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHBhcmVudHMsIGZhY3RvcnMgPSB0aGlzLmZhY3RvcnM7XHJcbiAgICAgICAgZm9yIChjb25zdCBmYWN0b3Igb2YgZmFjdG9ycykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMubWFwKGNoaWxkcmVuLCBmYWN0b3IsIGtleSwgcGlwZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZ2V0TmV4dE5vZGVzKHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCwga2V5OiBzdHJpbmcgfCBDb3ZlciwgcGlwZXM/OiBBcnJheTxQaXBlPikge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBmYWN0b3JzID0gdGhpcy5mYWN0b3JzO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmFjdG9yIG9mIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY2hpbGRyZW4sIHRoaXMubWFwKHBhcmVudHMsIGZhY3Rvciwga2V5LCBwaXBlcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9XHJcbn1cclxuXHJcbnR5cGUgT3BlcmFuZCA9IHN0cmluZyB8IC8qbnVtYmVyIHwqLyBPcGVyYXRvciB8IE1hcmsgfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+O1xyXG50eXBlIE9wZXJhbmRzID0gQXJyYXk8T3BlcmFuZD47XHJcbnR5cGUgSXRlcmF0aW9uUmVjb3JkSXRlbSA9IFtcclxuICAgIFJlY29yZDxzdHJpbmcsIGFueT4sXHJcbiAgICBBcnJheTxOb2RlUHJvcD4sXHJcbiAgICBbUmVjb3JkPHN0cmluZywgYW55Piwgc3RyaW5nLCBzdHJpbmcsIEl0ZXJhdGlvblJlY29yZEl0ZW1dIHwgbnVsbFxyXG5dXHJcbnR5cGUgSXRlcmF0aW9uUmVjb3JkID0gQXJyYXk8SXRlcmF0aW9uUmVjb3JkSXRlbT47XHJcblxyXG5jbGFzcyBPcHRpb24gZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZywgcGlwZXM/OiBBcnJheTxQaXBlPikge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuZ2V0TmV4dE5vZGVzKHBhcmVudHMsIGtleSwgcGlwZXMpLmNvbmNhdChwYXJlbnRzKTtcclxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgT3IgZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZywgcGlwZXM/OiBBcnJheTxQaXBlPikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHROb2RlcyhwYXJlbnRzLCBrZXksIHBpcGVzKTtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgU2VyaWVzIGV4dGVuZHMgT3BlcmF0b3Ige1xyXG4gICAgYXR0YWNoKHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCwga2V5OiBzdHJpbmcsIHBpcGVzPzogQXJyYXk8UGlwZT4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWVwTm9kZXMocGFyZW50cywga2V5LCBwaXBlcyk7XHJcbiAgICB9XHJcbn1cclxuLypcclxuY2xhc3MgQW5kIGV4dGVuZHMgT3BlcmF0b3IgIHtcclxuICAgIGF0dGFjaChwYXJlbnRzOiBJdGVyYXRpb25SZWNvcmQsIGtleTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgXCJub3QgdXNlZFwiO1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBOb3QgZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZykge1xyXG4gICAgICAgIHRocm93IFwibm90IHVzZWRcIjtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbn0qL1xyXG5jbGFzcyBDb3ZlciBpbXBsZW1lbnRzIENvdmVySW50ZXJmYWNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBvcmlnaW46IGFueSwgcHVibGljIHZhbHVlOiBhbnkpIHtcclxuICAgICAgICBpZiAob3JpZ2luIGluc3RhbmNlb2YgQ292ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBvcmlnaW4ub3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBOb25DYXB0dXJpbmcgZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZyB8IENvdmVyLCBwaXBlcz86IEFycmF5PFBpcGU+KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dE5vZGVzKHBhcmVudHMsIG5ldyBDb3ZlcihrZXksIG51bGwpLCBwaXBlcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIE5vbkNvbGxlY3RpbmcgZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZyB8IENvdmVyLCBwaXBlcz86IEFycmF5PFBpcGU+KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dE5vZGVzKHBhcmVudHMsIG5ldyBDb3ZlcihrZXksIFwiXCIpLCBwaXBlcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIExvb3AgZXh0ZW5kcyBPcGVyYXRvciB7XHJcbiAgICAvL0xvb3Ag5YaF6YOo55qEIE9wdGlvbiDlj6/og73kvJrlr7zoh7QgTG9vcCDlj5blgLzmt7fkubEo5b2T5YmN55So5LiN5Yiw6L+Z56eN5oOF5Ya177yM5LiN5aSE55CG6L+Z56eN5oOF5Ya16IO95YeP5bCR5raI6ICXKVxyXG4gICAgYXR0YWNoKHBhcmVudHM6IEl0ZXJhdGlvblJlY29yZCwga2V5OiBzdHJpbmcpIHtcclxuICAgICAgICB0aHJvdyAnbm90IHVzZWQnO1xyXG4gICAgICAgIC8v5pyJ54K56ICX6LS55oCn6IO977yM5LiN5piv5b6I5b+F6KaB55So6L+Z5Liq77yM5bey5ZyocGFyc2Vy5qC45b+D6YOo5YiG5Y676ZmkTG9vcOeahOaUr+aMgVxyXG4gICAgICAgIGxldCBiYWtzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50cykge1xyXG4gICAgICAgICAgICBiYWtzLnB1c2gocGFyZW50WzJdKTtcclxuICAgICAgICAgICAgcGFyZW50WzJdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuc2V0V3JhcCh0aGlzLmdldE5leHROb2RlcyhwYXJlbnRzLCBrZXkpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHBhcmVudHMpIHtcclxuICAgICAgICAgICAgcGFyZW50c1tpbmRleF1bMl0gPSBiYWtzW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTWFyayBpbXBsZW1lbnRzIE1hcmtJbnRlcmZhY2Uge1xyXG4gICAgc3RhdGljIE1BVENIRURfUkVDT1JEOiBNYXRjaGVkO1xyXG4gICAgcHVibGljIGtleTogc3RyaW5nO1xyXG4gICAgcHVibGljIHZhbHVlOiBhbnk7XHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZT86IGFueSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YShjb250ZXh0OiBDb250ZXh0LCBpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9XHJcbiAgICBhdHRhY2gocGFyZW50czogSXRlcmF0aW9uUmVjb3JkLCBrZXk6IHN0cmluZyB8IENvdmVyLCBwaXBlcz86IEFycmF5PFBpcGU+KSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBDb3ZlcikgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgdGhpcy5kYXRhICE9PSBNYXJrLnByb3RvdHlwZS5kYXRhKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xyXG4gICAgICAgICAgICAgICAgTWFyay5NQVRDSEVEX1JFQ09SRFtNQVRDSEVELndyYXBwZXJdID0gX2dldF93cmFwcGVyX2Z1bmN0aW9uKHZhbHVlKTs7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBJdGVyYXRpb25SZWNvcmQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9wcyA9IHBhcmVudFsxXS5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goW3RoaXMsIF9jYWxjX250aChwcm9wcywgdGhpcyksIHVuZGVmaW5lZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtwYXJlbnRbMF0sIHByb3BzLCBwYXJlbnRbMl1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9PcHRpb24oLi4uc29tZTogT3BlcmFuZHMpIHtcclxuICAgIHJldHVybiBuZXcgT3B0aW9uKHNvbWUpO1xyXG59XHJcbi8qXHJcbmZ1bmN0aW9uIF9Ob3QoLi4uc29tZTogT3BlcmFuZHMpIHtcclxuICAgIHJldHVybiBuZXcgTm90KHNvbWUpO1xyXG59XHJcbmZ1bmN0aW9uIF9BbmQoLi4uc29tZTogT3BlcmFuZHMpIHtcclxuICAgIHJldHVybiBuZXcgQW5kKHNvbWUpO1xyXG59Ki9cclxuZnVuY3Rpb24gX09yKC4uLnNvbWU6IE9wZXJhbmRzKSB7XHJcbiAgICByZXR1cm4gbmV3IE9yKHNvbWUpO1xyXG59XHJcbmZ1bmN0aW9uIF9TZXJpZXMoLi4uc29tZTogT3BlcmFuZHMpIHtcclxuICAgIHJldHVybiBuZXcgU2VyaWVzKHNvbWUpO1xyXG59XHJcbmZ1bmN0aW9uIF9Ob25DYXB0dXJpbmcoLi4uc29tZTogT3BlcmFuZHMpIHtcclxuICAgIHJldHVybiBuZXcgTm9uQ2FwdHVyaW5nKHNvbWUpO1xyXG59XHJcbmZ1bmN0aW9uIF9Ob25Db2xsZWN0aW5nKC4uLnNvbWU6IE9wZXJhbmRzKSB7XHJcbiAgICByZXR1cm4gbmV3IE5vbkNvbGxlY3Rpbmcoc29tZSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBfTG9vcCguLi5zb21lOiBPcGVyYW5kcykge1xyXG4gICAgcmV0dXJuIG5ldyBMb29wKHNvbWUpO1xyXG59XHJcbmZ1bmN0aW9uIF9NYXJrKHNvbWU/OiBhbnkpIHtcclxuICAgIHJldHVybiBuZXcgTWFyayhzb21lKTtcclxufVxyXG5sZXQgTk9ERVM6IFJlY29yZDxzdHJpbmcsICguLi5hcmdzOiBhbnkpID0+IHZvaWQ+ID0ge1xyXG4gICAgR3JvdXBpbmcobm9kZT86IFJlY29yZDxzdHJpbmcsIGFueT4sIGdyb3VwaW5nPzogVG9rZW4pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIkdyb3VwaW5nXCI7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzW2tleV0gPSBub2RlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChncm91cGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gZ3JvdXBpbmcucmFuZ2U7XHJcbiAgICAgICAgICAgIHRoaXMubG9jID0gZ3JvdXBpbmcubG9jO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBEaXJlY3RpdmUoXHJcbiAgICAgICAgdHlwZTogc3RyaW5nLFxyXG4gICAgICAgIGV4cHJlc3Npb246IE5vZGUsXHJcbiAgICAgICAgZGlyZWN0aXZlOiBzdHJpbmcsXHJcbiAgICAgICAgcmFuZ2U6IFtudW1iZXIsIG51bWJlcl0sXHJcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvblxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICB0aGlzLmxvYyA9IGxvYztcclxuICAgIH0sXHJcbiAgICBTY3JpcHQoYm9keTogQXJyYXk8Tm9kZT4pIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIlByb2dyYW1cIjtcclxuICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xyXG4gICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XHJcbiAgICB9LFxyXG4gICAgTW9kdWxlKGJvZHk6IEFycmF5PE5vZGU+KSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJQcm9ncmFtXCI7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gXCJtb2R1bGVcIjtcclxuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBfZ2V0X2FkYXB0KGRhdGE6IGFueSwgaW5kZXg6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBBcnJheSA/IGluZGV4IDwgZGF0YS5sZW5ndGhcclxuICAgICAgICA/IGRhdGFbaW5kZXhdXHJcbiAgICAgICAgOiBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gOiBkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRfd3JhcHBlcl9mdW5jdGlvbih0eXBlOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBOT0RFU1t0eXBlXVxyXG4gICAgICAgIHx8IChcclxuICAgICAgICAgICAgTk9ERVNbdHlwZV1cclxuICAgICAgICAgICAgPSB0eXBlID8gZXZhbChgKGZ1bmN0aW9uICR7dHlwZX0oKXt0aGlzLnR5cGU9XCIke3R5cGV9XCJ9KWApIDogZnVuY3Rpb24gKCkgeyB9XHJcbiAgICAgICAgKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgQXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj4sXHJcbiAgICByb290PzogUmVjb3JkPHN0cmluZywgYW55PixcclxuICAgIGJsb2NrX2xpc3Q6IEFycmF5PHN0cmluZz4gPSBbXSxcclxuICAgIHByZXZlbnRfdXBkYXRlID0gZmFsc2VcclxuKSB7XHJcbiAgICBwcmV2ZW50X3VwZGF0ZSB8fCAoT1BFUkFUT1JfSUQgKz0gMSk7XHJcbiAgICByb290ID0gcm9vdCA/IHByZXZlbnRfdXBkYXRlID8gcm9vdCA6IHsgLi4ucm9vdCB9IDogeyBbTUFSS1MuREVFUFRIXTogLTEgfTtcclxuXHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgcm9vdCA9IGNyZWF0ZU1hdGNoVHJlZShpdGVtLCByb290LCBibG9ja19saXN0LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gX2dldF93cmFwcGVyX2Z1bmN0aW9uKHR5cGUpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGRhdGFbdHlwZV0gaW5zdGFuY2VvZiBBcnJheSA/IGRhdGFbdHlwZV0gOiBbZGF0YVt0eXBlXV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yOiBjb2xsZWN0b3JzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IHByZWNlZGVuY2VzID0gdHJ1ZS8qUFJFQ0VERU5DRV9GRUFUVVJFUy5JTU1FRElBVEUqLyxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3JzXHJcbiAgICAgICAgICAgICAgICB9ID0gaXRlbTtcclxuICAgICAgICAgICAgICAgIGlmICghY29sbGVjdG9ycyB8fCB+YmxvY2tfbGlzdC5pbmRleE9mKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVycyA9PT0gXCJzdHJpbmdcIiAmJiAoZmlsdGVycyA9IGRhdGFbZmlsdGVyc10uZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBoYW5kbGVycyA9PT0gXCJzdHJpbmdcIiAmJiAoaGFuZGxlcnMgPSBkYXRhW2hhbmRsZXJzXS5oYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZGF0b3JzID09PSBcInN0cmluZ1wiICYmICh2YWxpZGF0b3JzID0gZGF0YVt2YWxpZGF0b3JzXS52YWxpZGF0b3IpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdG9ycyBpbnN0YW5jZW9mIEFycmF5IHx8IChjb2xsZWN0b3JzID0gW2NvbGxlY3RvcnNdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgY29sbGVjdG9ycy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29sbGVjdG9yID0gY29sbGVjdG9yc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVjZWRlbmNlOiBhbnkgPSBfZ2V0X2FkYXB0KHByZWNlZGVuY2VzLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhbmRsZXI6IE1hdGNoZWRbTUFUQ0hFRC5oYW5kbGVyXSA9IF9nZXRfYWRhcHQoaGFuZGxlcnMsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyOiBNYXRjaGVkW01BVENIRUQuZmlsdGVyXSA9IF9nZXRfYWRhcHQoZmlsdGVycywgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWxpZGF0b3I6IE1hdGNoZWRbTUFUQ0hFRC52YWxpZGF0b3JdID0gX2dldF9hZGFwdCh2YWxpZGF0b3JzLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgTWFyay5NQVRDSEVEX1JFQ09SRCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ByZWNlZGVuY2UgaW5zdGFuY2VvZiBOdW1iZXIgPyBOdW1iZXIocHJlY2VkZW5jZSkgOiBwcmVjZWRlbmNlLCBwcmVjZWRlbmNlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0b3IgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX2NvbGxlY3RvciA9IHsgLi4uY29sbGVjdG9yc1tpbmRleCAtIDFdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RvclswXSAmJiAhKGNvbGxlY3RvclswXSBpbnN0YW5jZW9mIEFycmF5KSAmJiAoY29sbGVjdG9yID0gW2NvbGxlY3Rvcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjb2xsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb2xsZWN0b3Jba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RvcnNbaW5kZXhdID0gY29sbGVjdG9yID0gX2NvbGxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlczogSXRlcmF0aW9uUmVjb3JkID0gW1tyb290LCBbXSwgbnVsbF1dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL+S/neivgeaJgOaciSBrZXkg6YO95piv5ZCM57G75Z6L5a2X56ym5byA5aS0KOWQpuWImeWPr+iDveS8muWHuueOsOmBjeWOhumhuuW6j+S4juWumuS5iemhuuW6j+S4jeWQjClcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb2xsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9wZXJhdG9yID0gY29sbGVjdG9yW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG9wZXJhdG9yIGluc3RhbmNlb2YgT3BlcmF0b3IgfHwgb3BlcmF0b3IgaW5zdGFuY2VvZiBNYXJrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBfT3Iob3BlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzID0gb3BlcmF0b3IuYXR0YWNoKG5vZGVzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbGFzdF9ub2RlLCBwcm9wc10gb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoZWRfcmVjb3JkID0gTWFyay5NQVRDSEVEX1JFQ09SRC5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkX3JlY29yZFtNQVRDSEVELnByb3BzXSA9IHByb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW92ZXJsb2FkICYmIGxhc3Rfbm9kZVtNQVJLUy5FTkRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb25mbGljdDpcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X25vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9ub2RlW01BUktTLkVORF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZF9yZWNvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9ub2RlW01BUktTLkVORF0gPSBtYXRjaGVkX3JlY29yZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcm9vdDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9Db250ZXh0KHBhcnNlcjogUGFyc2VyKTogQ29udGV4dCB7XHJcbiAgICBsZXQgc3RhdGVfc3RhY2sgPSBbXTtcclxuICAgIGxldCBjb250ZXh0OiBhbnkgPSBuZXcgQXJyYXkoQ09OVEVYVC5sZW5ndGgpO1xyXG4gICAgY29udGV4dFtDT05URVhULnBhcnNlcl0gPSBwYXJzZXI7XHJcbiAgICBjb250ZXh0W0NPTlRFWFQubGFiZWxTZXRdID0gW107XHJcbiAgICAvL2NvbnRleHRbQ09OVEVYVC50b2tlbnNdID0gdG9rZW5zO1xyXG4gICAgY29udGV4dC53cmFwID0gd3JhcDtcclxuICAgIGNvbnRleHQudW53cmFwID0gdW53cmFwO1xyXG4gICAgY29udGV4dC5zdG9yZSA9IHN0b3JlO1xyXG4gICAgY29udGV4dC5yZXN0b3JlID0gcmVzdG9yZTtcclxuICAgIGNvbnRleHQuZ2V0VG9rZW4gPSBnZXRUb2tlbjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0LCBcInRva2Vuc1wiLCB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tDT05URVhULnRva2Vuc10gfHwgdGhpc1tDT05URVhULnBhcnNlcl0udG9rZW5zO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICByZXR1cm4gY29udGV4dDtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUb2tlbihpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXNbQ09OVEVYVC50b2tlbnNdO1xyXG4gICAgICAgIHJldHVybiAhdG9rZW5zID8gdGhpc1tDT05URVhULnBhcnNlcl0uZ2V0VG9rZW4oaW5kZXgpIDogdG9rZW5zW2luZGV4XTtcclxuICAgICAgICAvL3JldHVybiBjb250ZXh0W0NPTlRFWFQudG9rZW5zXVtpbmRleF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3cmFwKGtleTogQ09OVEVYVCwgdmFsdWU6IGFueSkge1xyXG4gICAgICAgIHN0YXRlX3N0YWNrLnB1c2goY29udGV4dFtrZXldLCBrZXkpO1xyXG4gICAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHVud3JhcCgpIHtcclxuICAgICAgICBjb250ZXh0W3N0YXRlX3N0YWNrLnBvcCgpXSA9IHN0YXRlX3N0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHN0b3JlKCkge1xyXG4gICAgICAgIGxldCByZXN0b3JlX3BvaW50ID0gc3RhdGVfc3RhY2subGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCArPSAyKSB7XHJcbiAgICAgICAgICAgIHdyYXAoYXJndW1lbnRzW2luZGV4XSwgYXJndW1lbnRzW2luZGV4ICsgMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdG9yZV9wb2ludDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc3RvcmUocG9pbnQ6IG51bWJlcikge1xyXG4gICAgICAgIHdoaWxlIChzdGF0ZV9zdGFjay5sZW5ndGggPiBwb2ludCkge1xyXG4gICAgICAgICAgICB1bndyYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlX3N0YWNrLmxlbmd0aDtcclxuICAgIH1cclxufVxyXG5jb25zdCBGdXR1cmVSZXNlcnZlZFdvcmQgPSBbXCJlbnVtXCIsIFwiZXhwb3J0XCIsIFwiaW1wb3J0XCIsIFwic3VwZXJcIl07XHJcbmNvbnN0IFN0cmljdE1vZGVSZXNlcnZlZFdvcmQgPSBbXHJcbiAgICBcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCIsIFwibGV0XCJcclxuXTtcclxuY29uc3QgUmVzdHJpY3RlZFdvcmQgPSBbXCJldmFsXCIsIFwiYXJndW1lbnRzXCJdO1xyXG5cclxuZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQ6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIEZ1dHVyZVJlc2VydmVkV29yZC5pbmRleE9mKGlkKSA+PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gU3RyaWN0TW9kZVJlc2VydmVkV29yZC5pbmRleE9mKGlkKSA+PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQ6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIFJlc3RyaWN0ZWRXb3JkLmluZGV4T2YoaWQpID49IDA7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBfaWZfc3RyaWN0X3Rocm93X2Vycihjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgIGlmIChjb250ZXh0W0NPTlRFWFQuc3RyaWN0XSkge1xyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycih0b2tlbik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2lmX3Jlc2VydmVkX3Rocm93X2Vycihjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgIHZhbGlkYXRlSWRlbnRpZmllcihjb250ZXh0LCB0b2tlbik7XHJcbn1cclxuY29uc3QgVEhST1dfUkVTVFJJQ1RfV09SRFNfUEFUVEVSTiA9IF9PcihcclxuICAgIFwiSWRlbnRpZmllciBldmFsIGFyZ3VtZW50c1wiXHJcbikucGlwZShfaWZfc3RyaWN0X3Rocm93X2Vycik7XHJcbmNvbnN0IFRIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOID0gX09yKFxyXG4gICAgXCJJZGVudGlmaWVyIGltcGxlbWVudHMgaW50ZXJmYWNlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZCBsZXRcIlxyXG4pLnBpcGUoX2lmX3N0cmljdF90aHJvd19lcnIpO1xyXG5cclxuY29uc3QgSURFTlRJRklFUl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTiA9IF9PcihcIklkZW50aWZpZXJcIiwgVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4pO1xyXG5jb25zdCBFWFBSRVNTSU9OX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOID0gX09yKFwiW0V4cHJlc3Npb25dXCIsIFRIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOKTtcclxuXHJcbmNvbnN0IElERU5USUZJRVJfT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4gPSBfT3IoXCJJZGVudGlmaWVyXCIpLnBpcGUoX2lmX3Jlc2VydmVkX3Rocm93X2Vycik7XHJcbmNvbnN0IEVYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBcIltFeHByZXNzaW9uXVwiLFxyXG4gICAgSURFTlRJRklFUl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTlxyXG4pO1xyXG5cclxuXHJcbi8qY29uc3QgU1RSSUNUX1JFU0VSVkVEX1dPUkRTID0gX09yKFxyXG4gICAgXCJJZGVudGlmaWVyIGltcGxlbWVudHMgaW50ZXJmYWNlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZCBsZXRcIlxyXG4pOyovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlSWRlbnRpZmllcihjb250ZXh0OiBDb250ZXh0LCBub2RlOiBOb2RlKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICAgY29udGV4dFtDT05URVhULnN0cmljdF1cclxuICAgICkge1xyXG4gICAgICAgIGlmICghaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKG5vZGUubmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycihub2RlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVBc3NpZ25tZW50KGNvbnRleHQ6IENvbnRleHQsIG5vZGU6IE5vZGUpIHtcclxuICAgIGlmIChcclxuICAgICAgICBjb250ZXh0W0NPTlRFWFQuc3RyaWN0XVxyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKCEoXHJcbiAgICAgICAgICAgIGlzUmVzdHJpY3RlZFdvcmQobm9kZS5uYW1lKVxyXG4gICAgICAgICAgICB8fCBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobm9kZS5uYW1lKVxyXG4gICAgICAgICkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycihub2RlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVCaW5kaW5nKGNvbnRleHQ6IENvbnRleHQsIG5vZGU6IE5vZGUpIHtcclxuICAgIGlmICh2YWxpZGF0ZUFzc2lnbm1lbnQoY29udGV4dCwgbm9kZSkgPT09IHRydWUpIHtcclxuICAgICAgICBsZXQgYmluZGluZ19zZXQgPSBjb250ZXh0W0NPTlRFWFQuYmluZGluZ1NldF07XHJcbiAgICAgICAgaWYgKGJpbmRpbmdfc2V0KSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdfc2V0LnB1c2gobm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKGJpbmRpbmdfc2V0LmluZGV4T2Yobm9kZS5uYW1lKSAhPT0gYmluZGluZ19zZXQubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dFtDT05URVhULnBhcnNlcl0uZXJyKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTGluZVRlcm1pbmF0b3IoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlciwgLCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgaWYgKGNvbGxlY3RlZC5fbmV4dCkge1xyXG4gICAgICAgIGRlbGV0ZSBjb2xsZWN0ZWQuX25leHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBuZXh0X3Rva2VuID0gY29udGV4dC5nZXRUb2tlbihyaWdodCArIDEpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgbmV4dF90b2tlblxyXG4gICAgICAgICAgICAmJiAhKG5leHRfdG9rZW4udHlwZSA9PT0gdHlwZV9wdW5jdHVhdG9yICYmIG5leHRfdG9rZW4udmFsdWUgPT09IFwifVwiKVxyXG4gICAgICAgICAgICAmJiBuZXh0X3Rva2VuLmxvYy5zdGFydC5saW5lID09PSBjb2xsZWN0ZWQubG9jLmVuZC5saW5lXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHBhcnNlci5lcnIobmV4dF90b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbGxlY3RlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gX1N1Y2Nlc3NDb2xsZWN0b3IocGF0dGVybjogc3RyaW5nIHwgT3BlcmF0b3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgU3VjY2Vzczoge1xyXG4gICAgICAgICAgICBoYW5kbGVyOmpvaW5fY29udGVudCxcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMCxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogX09yKF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZKSwgXCJTdWNjZXNzXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhdHRlcm4sXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5sZXQgam9pbl9jb250ZW50ID0gZnVuY3Rpb24gKFtjb2xsZWN0ZWRdOiBDb250ZXh0KSB7XHJcbiAgICBsZXQgeyBzdWNjZXNzLCBjb250ZW50IH0gPSBjb2xsZWN0ZWQ7XHJcbiAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgIHN1Y2Nlc3MuY29udGVudC5wdXNoKGNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb2xsZWN0ZWQuY29udGVudCA9IFtjb250ZW50XTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgfVxyXG59O1xyXG5cclxubGV0IFRZUEVfQUxJQVMgPSB7fTtcclxuXHJcbmNvbnN0IEFTU0lHTk1FTlRfUFVOQ1RVQVRPUlNfUEFUVEVSTiA9IF9PcihcIlB1bmN0dWF0b3IgPSArPSAtPSAqKj0gKj0gLz0gJT0gPDw9ID4+PSA+Pj49ICY9IF49IHw9XCIpO1xyXG5cclxuXHJcbmNvbnN0IE1PRFVMRV9JVEVNX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBcIkltcG9ydERlY2xhcmF0aW9uXCIsXHJcbiAgICBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsXHJcbiAgICBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIixcclxuICAgIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCJcclxuKTtcclxuY29uc3QgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOID0gX09yKFwiW0RlY2xhcmF0aW9uXVwiLCBcIltTdGF0ZW1lbnRdXCIpO1xyXG5cclxuY29uc3QgUklHSFRfU0lERV9UT1BMRVZFTF9JVEVNX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBcIlN3aXRjaENhc2VcIixcclxuICAgIE1PRFVMRV9JVEVNX1BBVFRFUk4sXHJcbiAgICBTVEFURU1BTlRfTElTVF9JVEVNX1BBVFRFUk5cclxuKTtcclxuY29uc3QgVE9QTEVWRUxfSVRFTV9QQVRURVJOID0gX09yKFxyXG4gICAgTUFSS1MuQk9VTkRBUlksXHJcbiAgICBcIlN3aXRjaENhc2VcIixcclxuICAgIE1PRFVMRV9JVEVNX1BBVFRFUk4sXHJcbiAgICBTVEFURU1BTlRfTElTVF9JVEVNX1BBVFRFUk5cclxuKTtcclxuXHJcbmZ1bmN0aW9uIGlzQWxpZ25lZChjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpIHtcclxuICAgIGxldCB0b2tlbnMgPSBjb250ZXh0LnRva2VucztcclxuICAgIGZvciAobGV0IGluZGV4ID0gbGVmdDsgaW5kZXggPCByaWdodDsgaW5kZXgrKykge1xyXG4gICAgICAgIGlmICh0b2tlbnNbaW5kZXhdLmxvYy5lbmQubGluZSAhPT0gdG9rZW5zW2luZGV4ICsgMV0ubG9jLnN0YXJ0LmxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRhY2hMb2NhdGlvbihzb3VyY2U6IE5vZGUsIHN0YXJ0OiBOb2RlLCBlbmQ6IE5vZGUgPSBzdGFydCkge1xyXG4gICAgc291cmNlLnJhbmdlID0gW3N0YXJ0LnJhbmdlWzBdLCBlbmQucmFuZ2VbMV1dO1xyXG4gICAgc291cmNlLmxvYyA9IHtcclxuICAgICAgICBzdGFydDogc3RhcnQubG9jLnN0YXJ0LFxyXG4gICAgICAgIGVuZDogZW5kLmxvYy5lbmRcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZWludGVycHJldEtleXdvcmRBc0lkZW50aWZpZXIoeyB2YWx1ZSwgcmFuZ2UsIGxvYyB9OiBUb2tlbiwgdG9rZW5pemVyPzogVG9rZW5pemVyKTogTm9kZSB7XHJcbiAgICBsZXQgbmFtZSA9IHRva2VuaXplciA/IHRva2VuaXplci5fdm9sYXRpbGl0eSA6IHZhbHVlO1xyXG4gICAgbGV0IGlkZW50aWZpZXIgPSB7XHJcbiAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsIG5hbWUsIHJhbmdlLCBsb2NcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaWRlbnRpZmllciwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlOiBuYW1lXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpZGVudGlmaWVyO1xyXG59XHJcbmZ1bmN0aW9uIHJlaW50ZXJwcmV0SWRlbnRpZmllckFzS2V5d29yZCh7IHZhbHVlLCByYW5nZSwgbG9jIH06IFRva2VuKTogTm9kZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiS2V5d29yZFwiLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIHJhbmdlLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gX1ZhbGlkYXRlKHR5cGU6IHN0cmluZyB8IG51bWJlciwgdmFsdWU6IHN0cmluZyk6IFZhbGlkYXRlIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IHR5cGUgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxubGV0IGlzX3JpZ2h0X3BhcmVudGhlc2VzID0gX1ZhbGlkYXRlKHR5cGVfcHVuY3R1YXRvciwgXCIpXCIpO1xyXG5sZXQgaXNfcmlnaHRfYnJhY2tldHMgPSBfVmFsaWRhdGUodHlwZV9wdW5jdHVhdG9yLCBcIl1cIik7XHJcbmxldCBpc19yaWdodF9icmFjZXMgPSBfVmFsaWRhdGUodHlwZV9wdW5jdHVhdG9yLCBcIn1cIik7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3Rfc3VjY2VzcyhwYXJzZXI6IFBhcnNlciwgbm9kZXM6IEFycmF5PE5vZGU+KSB7XHJcbiAgICBsZXQgcmVzOiBBcnJheTxOb2RlPiA9IG5vZGVzO1xyXG4gICAgaWYgKG5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgaWYgKG5vZGVzWzBdLnR5cGUgPT09IFwiU3VjY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gMTtcclxuICAgICAgICAgICAgcmVzID0gbm9kZXNbMF0uY29udGVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgIHBhcnNlci5lcnIoLi4ubm9kZXMuc2xpY2UoaW5kZXgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZV9hbmRfZXh0cmFjdChtYXRjaF90cmVlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBjb250ZXh0OiBDb250ZXh0LCBub2RlOiBOb2RlKSB7XHJcbiAgICBsZXQgWywgcGFyc2VyXSA9IGNvbnRleHQ7XHJcbiAgICBsZXQgdG9rZW5zID0gbm9kZS5jb250ZW50O1xyXG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0LndyYXAoQ09OVEVYVC50b2tlbnMsIHRva2VucylcclxuICAgICAgICAvL2NvbnRleHRbQ09OVEVYVC50b2tlbnNdID0gdG9rZW5zO1xyXG4gICAgICAgIHBhcnNlci5wYXJzZUN1c3RvbShtYXRjaF90cmVlLCBjb250ZXh0KTtcclxuICAgICAgICB0b2tlbnMgPSBleHRyYWN0X3N1Y2Nlc3MocGFyc2VyLCB0b2tlbnMpXHJcbiAgICAgICAgY29udGV4dC51bndyYXAoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b2tlbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldF9pbm5lcl9ncm91cCh0b2tlbjogVG9rZW4pIHtcclxuICAgIHdoaWxlIChcclxuICAgICAgICB0b2tlbi5jb250ZW50Lmxlbmd0aCA9PT0gMVxyXG4gICAgICAgICYmIHRva2VuLmNvbnRlbnRbMF0udmFsdWUgPT09IFwiKClcIlxyXG4gICAgICAgICYmIHRva2VuLmNvbnRlbnRbMF0udHlwZSA9PT0gdHlwZV9wdW5jdHVhdG9yXHJcbiAgICApIHtcclxuICAgICAgICB0b2tlbiA9IHRva2VuLmNvbnRlbnRbMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9rZW47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlX25leHRfc3RhdGVtZW50KGNvbnRleHQ6IENvbnRleHQsIHN0YXJ0ID0gY29udGV4dFtDT05URVhULnJpZ2h0XSArIDEpIHtcclxuICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgIGlmIChcclxuICAgICAgICBwYXJzZXIucGFyc2VDdXN0b20oXHJcbiAgICAgICAgICAgIHBhcnNlci5TWU5UQVhfVFJFRSxcclxuICAgICAgICAgICAgY29udGV4dCxcclxuICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgIHBhcnNlci5pc1N0YXRlbWVudExpc3RJdGVtXHJcbiAgICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxubGV0IHRva2VuX2hvb2tzOiBSZWNvcmQ8c3RyaW5nLCAodG9rZW46IFRva2VuLCB0b2tlbml6ZXI/OiBUb2tlbml6ZXIgfCBQYXJzZXIpID0+IFRva2VuPiA9IHt9O1xyXG5mdW5jdGlvbiBBc3luY0dldHRlcigpIHtcclxuICAgIGxldCBhd2FpdF90YXNrcyA9IHt9O1xyXG4gICAgbGV0IGFzeW5jX2RhdGEgPSB7fTtcclxuICAgIGxldCBpc19vcGVuID0gZmFsc2U7XHJcbiAgICBsZXQgYXN5bmNfbWFwcGVyOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge1xyXG4gICAgICAgIG9wZW4oKSB7XHJcbiAgICAgICAgICAgIGlzX29wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgdGFza3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXdhaXRfdGFza3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhc3luY19kYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGFzeW5jX2RhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0YXNrIG9mIGF3YWl0X3Rhc2tzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChbdGFzaywgZGF0YV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcclxuICAgICAgICAgICAgICAgIHRhc2tbMF0odGFza1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldChrZXk6IHN0cmluZywgY2FsbGJhY2s6IChkYXRhOiBhbnkpID0+IGFueSkge1xyXG4gICAgICAgICAgICBpZiAoYXdhaXRfdGFza3Nba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXRfdGFza3Nba2V5XS5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc19vcGVuICYmIGFzeW5jX2RhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGFzeW5jX2RhdGFba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmNfbWFwcGVyLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3luY19kYXRhW2tleV0gPSBhc3luY19tYXBwZXJba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpc19vcGVuICYmIGNhbGxiYWNrKGFzeW5jX2RhdGFba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXN5bmNfbWFwcGVyLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQoZGF0YTogYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3luY19kYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jX2RhdGFba2V5XSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19vcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNiZnVuIG9mIGF3YWl0X3Rhc2tzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYmZ1bihkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNfZGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXRfdGFza3Nba2V5XSA9IFtjYWxsYmFja107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFzeW5jX21hcHBlcjtcclxufVxyXG5sZXQgYXN5bmNfZ2V0dGVyID0gQXN5bmNHZXR0ZXIoKTtcclxuZXhwb3J0IHtcclxuICAgIGFzeW5jX2dldHRlcixcclxuICAgIHRva2VuX2hvb2tzLFxyXG4gICAgcGFyc2VfbmV4dF9zdGF0ZW1lbnQsXHJcbiAgICBnZXRfaW5uZXJfZ3JvdXAsXHJcbiAgICBleHRyYWN0X3N1Y2Nlc3MsXHJcbiAgICBwYXJzZV9hbmRfZXh0cmFjdCxcclxuICAgIF9QdW5jdHVhdG9yLFxyXG4gICAgX0tleXdvcmQsXHJcbiAgICBfSWRlbnRpZmllcixcclxuICAgIF9QYXR0ZXJuLFxyXG4gICAgaXNfcmlnaHRfcGFyZW50aGVzZXMsXHJcbiAgICBpc19yaWdodF9icmFja2V0cyxcclxuICAgIGlzX3JpZ2h0X2JyYWNlcyxcclxuICAgIF9WYWxpZGF0ZSxcclxuICAgIHJlaW50ZXJwcmV0SWRlbnRpZmllckFzS2V5d29yZCxcclxuICAgIHJlaW50ZXJwcmV0S2V5d29yZEFzSWRlbnRpZmllcixcclxuICAgIGF0dGFjaExvY2F0aW9uLFxyXG4gICAgQ292ZXIsXHJcbiAgICBNYXJrLCBpc0FsaWduZWQsXHJcbiAgICBTVEFURU1BTlRfTElTVF9JVEVNX1BBVFRFUk4sXHJcbiAgICBSSUdIVF9TSURFX1RPUExFVkVMX0lURU1fUEFUVEVSTixcclxuICAgIFRPUExFVkVMX0lURU1fUEFUVEVSTixcclxuICAgIF9TdWNjZXNzQ29sbGVjdG9yLFxyXG4gICAgam9pbl9jb250ZW50LFxyXG4gICAgSURFTlRJRklFUl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgIEVYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgIEFTU0lHTk1FTlRfUFVOQ1RVQVRPUlNfUEFUVEVSTixcclxuICAgIHZhbGlkYXRlQmluZGluZywgdmFsaWRhdGVMaW5lVGVybWluYXRvcixcclxuICAgIE5PREVTLFxyXG4gICAgVFlQRV9BTElBUyxcclxuICAgIGNyZWF0ZU1hdGNoVHJlZSxcclxuICAgIGlzUmVzdHJpY3RlZFdvcmQsXHJcbiAgICBpc0Z1dHVyZVJlc2VydmVkV29yZCxcclxuICAgIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCxcclxuICAgIHZhbGlkYXRlSWRlbnRpZmllcixcclxuICAgIHZhbGlkYXRlQXNzaWdubWVudCxcclxuICAgIF9Db250ZXh0LFxyXG4gICAgX09wdGlvbiwgX09yLCBfU2VyaWVzLCBfTm9uQ2FwdHVyaW5nLCBfTm9uQ29sbGVjdGluZywgX01hcmssIF9Mb29wLFxyXG59XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUEwMUJBO0FBejFCQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUF1MUJBO0FBdDFCQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFvMUJBO0FBbjFCQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBazFCQTtBQS8wQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFBQTtBQUZBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFXQTtBQUFBO0FBQUE7O0FBS0E7QUFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBSUE7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBOztBQUlBO0FBSEE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQW9tQkE7QUFubUJBO0FBQUE7QUFBQTs7QUFJQTtBQUhBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7O0FBSUE7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBOztBQWdCQTtBQWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFzaUJBO0FBcGlCQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBdWpCQTtBQXRqQkE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQTZpQkE7QUE1aUJBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUEwaUJBO0FBemlCQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBdWlCQTtBQXRpQkE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQW9pQkE7QUFqaUJBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUEraEJBO0FBOWhCQTtBQUNBO0FBQ0E7QUE0aEJBO0FBM2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ2ZBO0FBL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUE2WUE7QUEzWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9XQTtBQW5XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBdVZBO0FBdFZBO0FBQ0E7QUFDQTtBQXFWQTtBQXBWQTtBQUNBO0FBQ0E7QUFnVkE7QUE3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQXVUQTtBQXRUQTtBQXVUQTtBQXJUQTtBQWtUQTtBQWpUQTtBQWtUQTtBQTVTQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTBTQTtBQXpTQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTZSQTtBQTVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdRQTtBQXZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3UEE7QUF0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQWlPQTtBQS9OQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1TkE7QUFyTkE7QUE2TkE7QUEzTkE7QUF3TkE7QUFyTkE7QUFNQTtBQXNNQTtBQXBNQTtBQXFNQTtBQWhNQTtBQWlNQTtBQTFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUErS0E7QUE3S0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFLQTtBQWxLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0pBO0FBckpBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTZJQTtBQTNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0lBO0FBbklBO0FBZ0lBO0FBL0hBO0FBZ0lBO0FBL0hBO0FBZ0lBO0FBNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxR0E7QUFuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUZBO0FBdkZBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUE0RUE7QUExRUE7QUFBQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUE2REE7QUE1REE7QUEyREE7QUExREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../js/syntax/head.ts\n");

/***/ }),

/***/ "../../js/syntax/module_declaration.ts":
/*!************************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/module_declaration.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/syntax/head.ts\");\nvar Grouping = head_1.NODES.Grouping;\nvar STRING_LITERAL_PATTERN = head_1._Or(\"Literal\").pipe(function (context, token) {\n    if (token instanceof Grouping || typeof token.value !== \"string\") {\n        context[1 /* parser */].err(token);\n    }\n});\nvar ImportSpecifiers = __assign(__assign({}, head_1._SuccessCollector(head_1._Pattern(\"ImportSpecifier\"))), { \n    /*\"Success\": {\n        handler: join_content,\n        precedence: 0,\n        collector: [\n            {\n                success: _Or(MARKS.BOUNDARY, \"Success\"),\n                content: \"ImportSpecifier\",\n            }\n        ]\n    },*/\n    ImportSpecifier: {\n        collector: {\n            _prev: head_1._NonCapturing(\"Success\", \"\" /* BOUNDARY */),\n            imported: \"Identifier\",\n            local: head_1._Or(head_1._Series(head_1._NonCollecting(\"Identifier as\"), \"Identifier\", head_1._NonCollecting(\"Punctuator ,\", \"\" /* BOUNDARY */)), head_1._Or(\"Punctuator ,\", \"\" /* BOUNDARY */).pipe(function (context) {\n                var collected = context[0];\n                return collected.imported;\n            }))\n        }\n    } });\nvar IMPORT_SPECIFIERS_TREE = head_1.createMatchTree(ImportSpecifiers);\nvar EXPORT_SPECIFIERS_TREE = head_1.createMatchTree(__assign(__assign({}, head_1._SuccessCollector(head_1._Pattern(\"ExportSpecifier\"))), { ExportSpecifier: {\n        collector: {\n            _prev: head_1._NonCapturing(\"Success\", \"\" /* BOUNDARY */),\n            local: \"Identifier\",\n            exported: head_1._Or(head_1._Series(head_1._NonCollecting(\"Identifier as\"), \"Identifier\", head_1._NonCollecting(\"Punctuator ,\", \"\" /* BOUNDARY */)), head_1._Or(\"Punctuator ,\", \"\" /* BOUNDARY */).pipe(function (context) {\n                var collected = context[0];\n                return collected.local;\n            }))\n        }\n    } }));\nvar ModuleDeclarations = {\n    \"ImportDeclaration\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            if (!context[13 /* isModule */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword import\"),\n                specifiers: head_1._Or(head_1._Punctuator(\"{}\").pipe(function (context, token) {\n                    return head_1.parse_and_extract(IMPORT_SPECIFIERS_TREE, context, token);\n                }), head_1._Series(head_1._NonCollecting(\"Punctuator *\"), head_1._NonCollecting(\"Identifier as\"), head_1._Identifier().pipe(function (context, token) {\n                    return [\n                        {\n                            type: \"ImportNamespaceSpecifier\",\n                            local: token\n                        }\n                    ];\n                })), head_1._Series(head_1._Identifier().pipe(function (context, Identifier) {\n                    return {\n                        type: \"ImportDefaultSpecifier\",\n                        local: Identifier\n                    };\n                }), head_1._Option(head_1._Series(head_1._NonCollecting(\"Punctuator ,\"), head_1._Or(head_1._Series(head_1._Punctuator(\"{}\").pipe(function (context, token) {\n                    return head_1.parse_and_extract(IMPORT_SPECIFIERS_TREE, context, token);\n                }), head_1._Mark(function (context) {\n                    var collected = context[0];\n                    var specifiers = collected.specifiers;\n                    specifiers.splice.apply(specifiers, __spreadArrays([1, 1], specifiers[1]));\n                })), head_1._Series(head_1._NonCollecting(\"Punctuator *\"), head_1._NonCollecting(\"Identifier as\"), head_1._Identifier().pipe(function (context, token) {\n                    return {\n                        type: \"ImportNamespaceSpecifier\",\n                        local: token\n                    };\n                }))))), head_1._Mark(function () { }) //使结果收集为数组\n                )),\n                _: head_1._NonCollecting(\"Identifier from\"),\n                source: STRING_LITERAL_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            }\n        ]\n    },\n    \"ExportAllDeclaration\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            if (!context[13 /* isModule */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        collector: {\n            _: head_1._NonCollecting(head_1._Series(\"Keyword export\", \"Punctuator *\", \"Identifier from\")),\n            source: STRING_LITERAL_PATTERN,\n            _next: head_1._Option(\"Punctuator ;\"),\n        },\n    },\n    \"ExportNamedDeclaration\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            collected.declaration || head_1.validateLineTerminator(context);\n            if (!context[13 /* isModule */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        collector: [\n            {\n                _: head_1._NonCollecting(\"Keyword export\"),\n                declaration: \"VariableDeclaration\",\n                specifiers: head_1._Mark(function () { return []; }),\n                source: head_1._Mark(null)\n            },\n            {\n                _: head_1._NonCollecting(\"Keyword export\"),\n                declaration: head_1._Mark(null),\n                specifiers: head_1._Punctuator(\"{}\").pipe(function (context, token) {\n                    return head_1.parse_and_extract(EXPORT_SPECIFIERS_TREE, context, token);\n                }),\n                source: head_1._Mark(null),\n                _next: head_1._Option(\"Punctuator ;\")\n            }\n        ]\n    },\n    \"ExportDefaultDeclaration\": {\n        handler: function (context) {\n            var collected = context[0];\n            head_1.validateLineTerminator(context);\n            if (!context[13 /* isModule */]) {\n                context[1 /* parser */].err(collected);\n            }\n            return collected;\n        },\n        precedence: 1.5,\n        collector: [\n            {\n                type: head_1._Mark(\"ExportDefaultDeclaration\"),\n                _: head_1._NonCollecting(\"Keyword export\"),\n                __: head_1._NonCollecting(\"Keyword default\"),\n                declaration: \"[Expression]\",\n                _next: head_1._Option(\"Punctuator ;\")\n            }\n        ]\n    }\n};\nexports.default = ModuleDeclarations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L21vZHVsZV9kZWNsYXJhdGlvbi50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vbW50L2QvUHJvZ3JhbUZpbGVzL0dpdEh1Yi9EaXNvbi9qcy9zeW50YXgvbW9kdWxlX2RlY2xhcmF0aW9uLnRzP2RkYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIENvbnRleHQsIENPTlRFWFQsIFRva2VuLCBOb2RlXHJcbiAgICAsIE1BUktTXHJcbn0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7XHJcbiAgICBhc3luY19nZXR0ZXIsXHJcbiAgICBfUHVuY3R1YXRvcixcclxuICAgIF9LZXl3b3JkLFxyXG4gICAgX0lkZW50aWZpZXIsXHJcbiAgICBfUGF0dGVybixcclxuICAgIF9PcHRpb24sIF9PciwgX1NlcmllcywgX05vbkNvbGxlY3RpbmcsIF9NYXJrLCBUWVBFX0FMSUFTLFxyXG4gICAgdmFsaWRhdGVMaW5lVGVybWluYXRvciwgTk9ERVMsIF9Ob25DYXB0dXJpbmcsIF9TdWNjZXNzQ29sbGVjdG9yLCBjcmVhdGVNYXRjaFRyZWUsXHJcblxyXG4gICAgZXh0cmFjdF9zdWNjZXNzLFxyXG4gICAgcGFyc2VfYW5kX2V4dHJhY3QsXHJcbn0gZnJvbSAnLi9oZWFkJ1xyXG5sZXQgR3JvdXBpbmcgPSBOT0RFUy5Hcm91cGluZztcclxuXHJcbmNvbnN0IFNUUklOR19MSVRFUkFMX1BBVFRFUk4gPSBfT3IoXCJMaXRlcmFsXCIpLnBpcGUoXHJcbiAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgR3JvdXBpbmcgfHwgdHlwZW9mIHRva2VuLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycih0b2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pXHJcblxyXG5sZXQgSW1wb3J0U3BlY2lmaWVycyA9IHtcclxuICAgIC4uLl9TdWNjZXNzQ29sbGVjdG9yKF9QYXR0ZXJuKFwiSW1wb3J0U3BlY2lmaWVyXCIpKSxcclxuICAgIC8qXCJTdWNjZXNzXCI6IHtcclxuICAgICAgICBoYW5kbGVyOiBqb2luX2NvbnRlbnQsXHJcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX09yKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIkltcG9ydFNwZWNpZmllclwiLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfSwqL1xyXG4gICAgSW1wb3J0U3BlY2lmaWVyOiB7XHJcbiAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFwiU3VjY2Vzc1wiLCBNQVJLUy5CT1VOREFSWSksXHJcbiAgICAgICAgICAgIGltcG9ydGVkOiBcIklkZW50aWZpZXJcIixcclxuICAgICAgICAgICAgbG9jYWw6IF9PcihcclxuICAgICAgICAgICAgICAgIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJJZGVudGlmaWVyIGFzXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiSWRlbnRpZmllclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciAsXCIsIE1BUktTLkJPVU5EQVJZKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIF9PcihcIlB1bmN0dWF0b3IgLFwiLCBNQVJLUy5CT1VOREFSWSkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkLmltcG9ydGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IElNUE9SVF9TUEVDSUZJRVJTX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoSW1wb3J0U3BlY2lmaWVycyk7XHJcbmNvbnN0IEVYUE9SVF9TUEVDSUZJRVJTX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoe1xyXG4gICAgLi4uX1N1Y2Nlc3NDb2xsZWN0b3IoX1BhdHRlcm4oXCJFeHBvcnRTcGVjaWZpZXJcIikpLFxyXG4gICAgRXhwb3J0U3BlY2lmaWVyOiB7XHJcbiAgICAgICAgY29sbGVjdG9yOiB7XHJcbiAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFwiU3VjY2Vzc1wiLCBNQVJLUy5CT1VOREFSWSksXHJcbiAgICAgICAgICAgIGxvY2FsOiBcIklkZW50aWZpZXJcIixcclxuICAgICAgICAgICAgZXhwb3J0ZWQ6IF9PcihcclxuICAgICAgICAgICAgICAgIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJJZGVudGlmaWVyIGFzXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiSWRlbnRpZmllclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciAsXCIsIE1BUktTLkJPVU5EQVJZKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIF9PcihcIlB1bmN0dWF0b3IgLFwiLCBNQVJLUy5CT1VOREFSWSkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkLmxvY2FsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5jb25zdCBNb2R1bGVEZWNsYXJhdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XHJcbiAgICBcIkltcG9ydERlY2xhcmF0aW9uXCI6IHtcclxuICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUxpbmVUZXJtaW5hdG9yKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHRbQ09OVEVYVC5pc01vZHVsZV0pIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoY29sbGVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgaW1wb3J0XCIpLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyczogX09yKFxyXG4gICAgICAgICAgICAgICAgICAgIF9QdW5jdHVhdG9yKFwie31cIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlX2FuZF9leHRyYWN0KElNUE9SVF9TUEVDSUZJRVJTX1RSRUUsIGNvbnRleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yICpcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiSWRlbnRpZmllciBhc1wiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX0lkZW50aWZpZXIoKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbDogdG9rZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX0lkZW50aWZpZXIoKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIElkZW50aWZpZXI6IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsOiBJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfT3B0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfUHVuY3R1YXRvcihcInt9XCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VfYW5kX2V4dHJhY3QoSU1QT1JUX1NQRUNJRklFUlNfVFJFRSwgY29udGV4dCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTWFyayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BlY2lmaWVycyA9IGNvbGxlY3RlZC5zcGVjaWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnNwbGljZSgxLCAxLCAuLi5zcGVjaWZpZXJzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgKlwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiSWRlbnRpZmllciBhc1wiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9JZGVudGlmaWVyKCkucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWw6IHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9NYXJrKGZ1bmN0aW9uICgpIHsgfSkvL+S9v+e7k+aenOaUtumbhuS4uuaVsOe7hFxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIklkZW50aWZpZXIgZnJvbVwiKSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogU1RSSU5HX0xJVEVSQUxfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsaWRhdGVMaW5lVGVybWluYXRvcihjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0W0NPTlRFWFQuaXNNb2R1bGVdKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGNvbGxlY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhfU2VyaWVzKFwiS2V5d29yZCBleHBvcnRcIiwgXCJQdW5jdHVhdG9yICpcIiwgXCJJZGVudGlmaWVyIGZyb21cIikpLFxyXG4gICAgICAgICAgICBzb3VyY2U6IFNUUklOR19MSVRFUkFMX1BBVFRFUk4sXHJcbiAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6IHtcclxuICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBjb2xsZWN0ZWQuZGVjbGFyYXRpb24gfHwgdmFsaWRhdGVMaW5lVGVybWluYXRvcihjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0W0NPTlRFWFQuaXNNb2R1bGVdKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGNvbGxlY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgZXhwb3J0XCIpLFxyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyczogX01hcmsoKCkgPT4gW10pLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBfTWFyayhudWxsKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgZXhwb3J0XCIpLFxyXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IF9NYXJrKG51bGwpLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyczogX1B1bmN0dWF0b3IoXCJ7fVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlX2FuZF9leHRyYWN0KEVYUE9SVF9TUEVDSUZJRVJTX1RSRUUsIGNvbnRleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgc291cmNlOiBfTWFyayhudWxsKSxcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUxpbmVUZXJtaW5hdG9yKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHRbQ09OVEVYVC5pc01vZHVsZV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycihjb2xsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVjZWRlbmNlOiAxLjUsXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IF9NYXJrKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpLFxyXG4gICAgICAgICAgICAgICAgXzogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGV4cG9ydFwiKSxcclxuICAgICAgICAgICAgICAgIF9fOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgZGVmYXVsdFwiKSxcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiBcIltFeHByZXNzaW9uXVwiLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9PcHRpb24oXCJQdW5jdHVhdG9yIDtcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufVxyXG5leHBvcnQgZGVmYXVsdCBNb2R1bGVEZWNsYXJhdGlvbnM7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBO0FBWUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../js/syntax/module_declaration.ts\n");

/***/ }),

/***/ "../../js/syntax/pattern.ts":
/*!*************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/pattern.ts ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseObjectPattern = exports.parseArrayPattern = exports.Patterns = void 0;\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/syntax/head.ts\");\n//import { UNIT_EXPRESSION_TREE } from './expression';\nvar Grouping = head_1.NODES.Grouping;\nvar UNIT_EXPRESSION_TREE;\nvar PETTERN_ELEMENTS_TREE;\nvar PATTERN_PROPERTIES_TREE;\n//console.log(123123, UNIT_EXPRESSION_TREE, UNIT_EXPRESSION_TREE);\nhead_1.async_getter.get(\"UNIT_EXPRESSION_TREE\", function (data) {\n    UNIT_EXPRESSION_TREE = data;\n    PETTERN_ELEMENTS_TREE = head_1.createMatchTree(PatternElements, UNIT_EXPRESSION_TREE);\n    PATTERN_PROPERTIES_TREE = head_1.createMatchTree(PatternProperties, UNIT_EXPRESSION_TREE);\n});\nvar Patterns = head_1.async_getter.Patterns = {\n    ArrayPattern: {\n        handler: function (context) {\n            var collected = context[0];\n            collected.is_binding || context.wrap(10 /* bindingSet */, null);\n            var res = parseArrayPattern(context, collected.elements);\n            collected.is_binding || context.unwrap();\n            return res;\n        },\n        precedence: 20,\n        filter: [\n            null,\n            function (context) {\n                return context[18 /* bindingElement */] /* === context[CONTEXT.tokens]*/;\n            }\n        ],\n        collector: [\n            {\n                elements: head_1._Or(\"Punctuator []\"),\n                _next: head_1._NonCapturing(head_1.ASSIGNMENT_PUNCTUATORS_PATTERN),\n            },\n            {\n                _prev: head_1._NonCapturing(\"Punctuator  ...\", \"\" /* BOUNDARY */, \"Success\"),\n                elements: head_1._Or(\"Punctuator []\"),\n                is_binding: head_1._Mark(true)\n            }\n        ]\n    },\n    ObjectPattern: {\n        handler: function (context) {\n            var collected = context[0];\n            collected.is_binding || context.wrap(10 /* bindingSet */, null);\n            var res = parseObjectPattern(context, collected.properties);\n            collected.is_binding || context.unwrap();\n            return res;\n        },\n        precedence: 20,\n        filter: [\n            null, null,\n            function (context, left, right) {\n                return context[18 /* bindingElement */] /* === tokens*/\n                    || context[14 /* isExpression */];\n            },\n            function (context) {\n                return context[18 /* bindingElement */] /*=== context[CONTEXT.tokens]*/;\n            }\n        ],\n        collector: [\n            {\n                _prev: head_1._NonCapturing(head_1.ASSIGNMENT_PUNCTUATORS_PATTERN),\n                properties: head_1._Or(\"Punctuator {}\"),\n                _next: head_1._NonCapturing(head_1.ASSIGNMENT_PUNCTUATORS_PATTERN)\n            },\n            [\n                [\"_prev\", head_1._NonCapturing(\"Punctuator  ,\")],\n                [\"is_binding\", head_1._Mark(true)]\n            ],\n            [\"_prev\", head_1._Mark()],\n            [\n                [\"_prev\", head_1._NonCapturing(\"Punctuator ...\", \"\" /* BOUNDARY */, \"Success\")],\n                [\"_next\", head_1._Mark()],\n            ]\n        ]\n    },\n    AssignmentPattern: {\n        filter: function (context) {\n            return context[18 /* bindingElement */] /* === context[CONTEXT.tokens]*/;\n        },\n        precedence: 1.5,\n        collector: {\n            _: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n            left: head_1._Or(\"ArrayPattern\", \"ObjectPattern\", head_1._Or(\"Identifier\").pipe(function (context, identifier) {\n                if (identifier instanceof Grouping) {\n                    context[1 /* parser */].err(identifier);\n                }\n                else {\n                    head_1.validateBinding(context, identifier);\n                }\n            })),\n            __: head_1._NonCollecting(\"Punctuator =\"),\n            right: \"[Expression]\"\n        }\n    },\n    \"\": [\n        {\n            handler: function (context) {\n                var token = context[0].token, parser = context[1], left = context[2], right = context[3];\n                token = head_1.get_inner_group(token);\n                var store = context.store(7 /* tokens */, token.content, 18 /* bindingElement */, true, 10 /* bindingSet */, null);\n                var node = parser.parseNode(UNIT_EXPRESSION_TREE, context, function (node) { return parser.isExpression(node)\n                    || node.type === \"ArrayPattern\"\n                    || node.type === \"ObjectPattern\"\n                    || node.type === \"AssignmentPattern\"; });\n                context.restore(store);\n                if (!node) {\n                    parser.err(token);\n                }\n                return new Grouping(node, token);\n            },\n            collector: [\n                {\n                    _prev: head_1._NonCapturing(head_1._Series(\"Keyword export\", \"Keyword default\"), \"Punctuator ,\", \"Success\", head_1.TOPLEVEL_ITEM_PATTERN, head_1.ASSIGNMENT_PUNCTUATORS_PATTERN),\n                    token: head_1._Or(\"Punctuator ()\"),\n                    _next: head_1._NonCapturing(head_1.ASSIGNMENT_PUNCTUATORS_PATTERN)\n                }\n            ]\n        },\n        {\n            validator: function (context) {\n                var parser = context[1], right = context[3];\n                var argument = context.getToken(right);\n                argument instanceof Grouping && parser.err(argument);\n                return true;\n            },\n            filter: function (context) {\n                return context[19 /* spreadElement */];\n            },\n            precedence: 1.5,\n            collector: {\n                type: head_1._Mark(\"SpreadElement\"),\n                token: head_1._NonCollecting(\"Punctuator ...\"),\n                argument: \"[Expression]\"\n            }\n        },\n        {\n            validator: function (context) {\n                var parser = context[1], right = context[3];\n                var argument = context.getToken(right);\n                argument instanceof Grouping && parser.err(argument);\n                return true;\n            },\n            filter: function (context) {\n                return context[18 /* bindingElement */];\n            },\n            precedence: 1.5,\n            collector: {\n                type: head_1._Mark(\"RestElement\"),\n                token: head_1._NonCollecting(\"Punctuator ...\"),\n                argument: head_1._Or(head_1._Or(\"Identifier\").pipe(function (context, token) {\n                    head_1.validateBinding(context, token);\n                }), \"ArrayPattern\", \"ObjectPattern\")\n            }\n        }\n    ]\n};\nexports.Patterns = Patterns;\nfunction parseArrayPattern(context, token) {\n    var pattern = new head_1.NODES.ArrayPattern();\n    context.wrap(18 /* bindingElement */, true);\n    pattern.elements = head_1.parse_and_extract(PETTERN_ELEMENTS_TREE, context, token);\n    context.unwrap();\n    pattern.range = token.range;\n    pattern.loc = token.loc;\n    return pattern;\n}\nexports.parseArrayPattern = parseArrayPattern;\nfunction parseObjectPattern(context, token) {\n    var pattern = new head_1.NODES.ObjectPattern();\n    context.wrap(18 /* bindingElement */, true);\n    pattern.properties = head_1.parse_and_extract(PATTERN_PROPERTIES_TREE, context, token);\n    context.unwrap();\n    pattern.range = token.range;\n    pattern.loc = token.loc;\n    return pattern;\n}\nexports.parseObjectPattern = parseObjectPattern;\nvar PatternElements = {\n    Success: {\n        handler: head_1.join_content,\n        collector: [\n            {\n                success: head_1._Or(\"\" /* BOUNDARY */, \"Success\"),\n                content: head_1._Or(head_1._Or(\"Identifier\").pipe(function (context, identifier) {\n                    if (identifier instanceof Grouping) {\n                        context[1 /* parser */].err(identifier);\n                    }\n                    else {\n                        head_1.validateBinding(context, identifier);\n                    }\n                }), head_1._Or(\"ArrayPattern\", \"ObjectPattern\", \"AssignmentPattern\")),\n                _next: head_1._NonCollecting(head_1._Or(\"Punctuator ,\", \"\" /* BOUNDARY */))\n            },\n            [\n                [\"content\", \"RestElement\"],\n                [\"_next\", head_1._NonCollecting(\"\" /* BOUNDARY */)]\n            ],\n            {\n                success: head_1._Or(\"\" /* BOUNDARY */, \"Success\"),\n                content: head_1._Mark(null),\n                _next: head_1._NonCollecting(\"Punctuator ,\")\n            }\n        ]\n    }\n};\nvar PatternProperties = __assign(__assign({}, head_1._SuccessCollector(head_1._Pattern(\"Property\"))), { Property: [\n        {\n            collector: [\n                {\n                    _prev: head_1._NonCapturing(\"\" /* BOUNDARY */, \"Success\"),\n                    key: head_1._Or(\"Punctuator []\").pipe(function (context, token) {\n                        context.wrap(7 /* tokens */, token.content);\n                        var res = context[1 /* parser */].parseExpression(context);\n                        context.unwrap();\n                        return res;\n                    }),\n                    value: head_1._Series(head_1._NonCollecting(\"Punctuator :\"), head_1._Or(head_1._Or(\"Identifier\").pipe(function (context, token) {\n                        head_1.validateBinding(context, token);\n                    }), head_1._Or(\"Punctuator []\").pipe(parseArrayPattern), head_1._Or(\"Punctuator {}\").pipe(parseObjectPattern)), head_1._Option(head_1._Series(head_1._NonCollecting(\"Punctuator =\"), \"[Expression]\")), head_1._Mark(function (context) {\n                        var collected = context[0];\n                        var value = collected.value;\n                        if (value.length > 1) {\n                            var _value = new head_1.NODES.AssignmentPattern();\n                            _value.left = value[0];\n                            _value.right = value[1];\n                            head_1.attachLocation(_value, value[0], value[1]);\n                            collected.value = _value;\n                        }\n                        else {\n                            collected.value = value[0];\n                        }\n                        return undefined;\n                    })),\n                    _next: head_1._NonCollecting(\"\" /* BOUNDARY */, \"Punctuator ,\"),\n                    computed: head_1._Mark(true),\n                    kind: head_1._Mark(\"init\"),\n                    method: head_1._Mark(false),\n                    shorthand: head_1._Mark(false),\n                },\n                [\n                    [\n                        \"key\",\n                        head_1._Or(\"Identifier\").pipe(function (context, identifier) {\n                            if (identifier instanceof Grouping) {\n                                context[1 /* parser */].err(identifier);\n                            }\n                        })\n                    ],\n                    [\"computed\", head_1._Mark(false)]\n                ],\n                [\n                    [\n                        \"value\",\n                        head_1._Or(head_1._Series(head_1._NonCollecting(\"Punctuator =\"), \"[Expression]\").pipe(function (context, token) {\n                            var collected = context[0];\n                            var left = collected.key;\n                            var res = new head_1.NODES.AssignmentPattern();\n                            res.left = left;\n                            res.right = token;\n                            head_1.attachLocation(res, left, token);\n                            return res;\n                        }), head_1._Mark(function (context) {\n                            return context[0 /* collected */].key;\n                        }))\n                    ],\n                    [\n                        \"shorthand\",\n                        head_1._Mark(function (context) {\n                            head_1.validateBinding(context, context[0 /* collected */].key);\n                            return true;\n                        })\n                    ]\n                ]\n            ]\n        },\n        {\n            validator: function () {\n                return false;\n            },\n            precedence: new Number(3),\n            collector: {\n                __: head_1._Series(head_1._Or(\"\" /* BOUNDARY */, \"Success\"), head_1._Or(\"Punctuator []\", \"Identifier\"), \"Punctuator :\", head_1._Or(\"Identifier\", \"Punctuator [] {}\"), \"Punctuator =\")\n            }\n        }\n    ] });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L3BhdHRlcm4udHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL21udC9kL1Byb2dyYW1GaWxlcy9HaXRIdWIvRGlzb24vanMvc3ludGF4L3BhdHRlcm4udHM/MmIwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuaW1wb3J0IHtcclxuICAgIE5vZGUsIFRva2VuLCBDb250ZXh0LCBDT05URVhULCBNQVJLUywgTWF0Y2hUcmVlXHJcbn0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7XHJcbiAgICBhc3luY19nZXR0ZXIsXHJcbiAgICBhdHRhY2hMb2NhdGlvbixcclxuICAgIGNyZWF0ZU1hdGNoVHJlZSxcclxuICAgIF9PcHRpb24sIF9PciwgX1NlcmllcywgX05vbkNvbGxlY3RpbmcsIF9Ob25DYXB0dXJpbmcsIF9NYXJrLFxyXG4gICAgVFlQRV9BTElBUywgX0NvbnRleHQsIF9Mb29wLCBOT0RFUyxcclxuICAgIHZhbGlkYXRlQmluZGluZywgdmFsaWRhdGVMaW5lVGVybWluYXRvciwgQVNTSUdOTUVOVF9QVU5DVFVBVE9SU19QQVRURVJOLCBfU3VjY2Vzc0NvbGxlY3Rvciwgam9pbl9jb250ZW50LCBUT1BMRVZFTF9JVEVNX1BBVFRFUk4sXHJcbiAgICBleHRyYWN0X3N1Y2Nlc3MsXHJcbiAgICBwYXJzZV9hbmRfZXh0cmFjdCxcclxuICAgIGdldF9pbm5lcl9ncm91cCxcclxuICAgIF9QYXR0ZXJuLFxyXG59IGZyb20gJy4vaGVhZCdcclxuXHJcbi8vaW1wb3J0IHsgVU5JVF9FWFBSRVNTSU9OX1RSRUUgfSBmcm9tICcuL2V4cHJlc3Npb24nO1xyXG5jb25zdCBHcm91cGluZyA9IE5PREVTLkdyb3VwaW5nO1xyXG5cclxubGV0IFVOSVRfRVhQUkVTU0lPTl9UUkVFOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5sZXQgUEVUVEVSTl9FTEVNRU5UU19UUkVFOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG5sZXQgUEFUVEVSTl9QUk9QRVJUSUVTX1RSRUU6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcblxyXG4vL2NvbnNvbGUubG9nKDEyMzEyMywgVU5JVF9FWFBSRVNTSU9OX1RSRUUsIFVOSVRfRVhQUkVTU0lPTl9UUkVFKTtcclxuXHJcbmFzeW5jX2dldHRlci5nZXQoXCJVTklUX0VYUFJFU1NJT05fVFJFRVwiLCBmdW5jdGlvbiAoZGF0YTogTWF0Y2hUcmVlKSB7XHJcbiAgICBVTklUX0VYUFJFU1NJT05fVFJFRSA9IGRhdGE7XHJcbiAgICBQRVRURVJOX0VMRU1FTlRTX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICAgICAgUGF0dGVybkVsZW1lbnRzLFxyXG4gICAgICAgIFVOSVRfRVhQUkVTU0lPTl9UUkVFXHJcbiAgICApO1xyXG4gICAgUEFUVEVSTl9QUk9QRVJUSUVTX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoXHJcbiAgICAgICAgUGF0dGVyblByb3BlcnRpZXMsXHJcbiAgICAgICAgVU5JVF9FWFBSRVNTSU9OX1RSRUVcclxuICAgICk7XHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IFBhdHRlcm5zOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gYXN5bmNfZ2V0dGVyLlBhdHRlcm5zID0ge1xyXG4gICAgQXJyYXlQYXR0ZXJuOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbGxlY3RlZC5pc19iaW5kaW5nIHx8IGNvbnRleHQud3JhcChDT05URVhULmJpbmRpbmdTZXQsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gcGFyc2VBcnJheVBhdHRlcm4oY29udGV4dCwgY29sbGVjdGVkLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgY29sbGVjdGVkLmlzX2JpbmRpbmcgfHwgY29udGV4dC51bndyYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZWNlZGVuY2U6IDIwLFxyXG4gICAgICAgIGZpbHRlcjogW1xyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5iaW5kaW5nRWxlbWVudF0vKiA9PT0gY29udGV4dFtDT05URVhULnRva2Vuc10qLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBfT3IoXCJQdW5jdHVhdG9yIFtdXCIpLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9Ob25DYXB0dXJpbmcoQVNTSUdOTUVOVF9QVU5DVFVBVE9SU19QQVRURVJOKSwvLys9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciAgLi4uXCIsIE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50czogX09yKFwiUHVuY3R1YXRvciBbXVwiKSxcclxuICAgICAgICAgICAgICAgIGlzX2JpbmRpbmc6IF9NYXJrKHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgT2JqZWN0UGF0dGVybjoge1xyXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbGxlY3RlZC5pc19iaW5kaW5nIHx8IGNvbnRleHQud3JhcChDT05URVhULmJpbmRpbmdTZXQsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gcGFyc2VPYmplY3RQYXR0ZXJuKGNvbnRleHQsIGNvbGxlY3RlZC5wcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgY29sbGVjdGVkLmlzX2JpbmRpbmcgfHwgY29udGV4dC51bndyYXAoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZWNlZGVuY2U6IDIwLFxyXG4gICAgICAgIGZpbHRlcjogW1xyXG4gICAgICAgICAgICBudWxsLCBudWxsLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgbGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtDT05URVhULmJpbmRpbmdFbGVtZW50XS8qID09PSB0b2tlbnMqL1xyXG4gICAgICAgICAgICAgICAgICAgIHx8IGNvbnRleHRbQ09OVEVYVC5pc0V4cHJlc3Npb25dO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5iaW5kaW5nRWxlbWVudF0gLyo9PT0gY29udGV4dFtDT05URVhULnRva2Vuc10qLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKEFTU0lHTk1FTlRfUFVOQ1RVQVRPUlNfUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfT3IoXCJQdW5jdHVhdG9yIHt9XCIpLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9Ob25DYXB0dXJpbmcoQVNTSUdOTUVOVF9QVU5DVFVBVE9SU19QQVRURVJOKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbXCJfcHJldlwiLCBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciAgLFwiKV0sXHJcbiAgICAgICAgICAgICAgICBbXCJpc19iaW5kaW5nXCIsIF9NYXJrKHRydWUpXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbXCJfcHJldlwiLCBfTWFyaygpXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgW1wiX3ByZXZcIiwgX05vbkNhcHR1cmluZyhcIlB1bmN0dWF0b3IgLi4uXCIsIE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIildLFxyXG4gICAgICAgICAgICAgICAgW1wiX25leHRcIiwgX01hcmsoKV0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgQXNzaWdubWVudFBhdHRlcm46IHtcclxuICAgICAgICBmaWx0ZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dFtDT05URVhULmJpbmRpbmdFbGVtZW50XS8qID09PSBjb250ZXh0W0NPTlRFWFQudG9rZW5zXSovO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJlY2VkZW5jZTogMS41LFxyXG4gICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICBfOiBfTm9uQ2FwdHVyaW5nKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgIGxlZnQ6IF9PcihcclxuICAgICAgICAgICAgICAgIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLFxyXG4gICAgICAgICAgICAgICAgX09yKFwiSWRlbnRpZmllclwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBpZGVudGlmaWVyOiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgR3JvdXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLmVycihpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQmluZGluZyhjb250ZXh0LCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgX186IF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciA9XCIpLFxyXG4gICAgICAgICAgICByaWdodDogXCJbRXhwcmVzc2lvbl1cIlxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcIlwiOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbeyB0b2tlbiB9LCBwYXJzZXIsIGxlZnQsIHJpZ2h0XSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGdldF9pbm5lcl9ncm91cCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKFxyXG4gICAgICAgICAgICAgICAgICAgIENPTlRFWFQudG9rZW5zLCB0b2tlbi5jb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIENPTlRFWFQuYmluZGluZ0VsZW1lbnQsIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgQ09OVEVYVC5iaW5kaW5nU2V0LCBudWxsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJzZXIucGFyc2VOb2RlKFxyXG4gICAgICAgICAgICAgICAgICAgIFVOSVRfRVhQUkVTU0lPTl9UUkVFLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9PiBwYXJzZXIuaXNFeHByZXNzaW9uKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZShzdG9yZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXBpbmcobm9kZSwgdG9rZW4pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcHJldjogX05vbkNhcHR1cmluZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhcIktleXdvcmQgZXhwb3J0XCIsIFwiS2V5d29yZCBkZWZhdWx0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlB1bmN0dWF0b3IgLFwiLCBcIlN1Y2Nlc3NcIiwgVE9QTEVWRUxfSVRFTV9QQVRURVJOLCBBU1NJR05NRU5UX1BVTkNUVUFUT1JTX1BBVFRFUk5cclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBfT3IoXCJQdW5jdHVhdG9yICgpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIF9uZXh0OiBfTm9uQ2FwdHVyaW5nKEFTU0lHTk1FTlRfUFVOQ1RVQVRPUlNfUEFUVEVSTilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBbLCBwYXJzZXIsICwgcmlnaHRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCBhcmd1bWVudCA9IGNvbnRleHQuZ2V0VG9rZW4ocmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQgaW5zdGFuY2VvZiBHcm91cGluZyAmJiBwYXJzZXIuZXJyKGFyZ3VtZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWx0ZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbQ09OVEVYVC5zcHJlYWRFbGVtZW50XTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMS41LFxyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IF9NYXJrKFwiU3ByZWFkRWxlbWVudFwiKSxcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLi4uXCIpLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwiW0V4cHJlc3Npb25dXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB2YWxpZGF0b3IoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IFssIHBhcnNlciwgLCByaWdodF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGFyZ3VtZW50ID0gY29udGV4dC5nZXRUb2tlbihyaWdodCk7XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudCBpbnN0YW5jZW9mIEdyb3VwaW5nICYmIHBhcnNlci5lcnIoYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W0NPTlRFWFQuYmluZGluZ0VsZW1lbnRdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxLjUsXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogX01hcmsoXCJSZXN0RWxlbWVudFwiKSxcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLi4uXCIpLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IF9PcihfT3IoXCJJZGVudGlmaWVyXCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJpbmRpbmcoY29udGV4dCwgdG9rZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKSwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdXHJcbn07XHJcbmV4cG9ydCB7XHJcbiAgICBQYXR0ZXJucyxcclxuICAgIHBhcnNlQXJyYXlQYXR0ZXJuLFxyXG4gICAgcGFyc2VPYmplY3RQYXR0ZXJuXHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZUFycmF5UGF0dGVybihjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pOiBOb2RlIHtcclxuICAgIGxldCBwYXR0ZXJuID0gbmV3IE5PREVTLkFycmF5UGF0dGVybigpO1xyXG4gICAgY29udGV4dC53cmFwKENPTlRFWFQuYmluZGluZ0VsZW1lbnQsIHRydWUpO1xyXG4gICAgcGF0dGVybi5lbGVtZW50cyA9IHBhcnNlX2FuZF9leHRyYWN0KFBFVFRFUk5fRUxFTUVOVFNfVFJFRSwgY29udGV4dCwgdG9rZW4pO1xyXG4gICAgY29udGV4dC51bndyYXAoKTtcclxuICAgIHBhdHRlcm4ucmFuZ2UgPSB0b2tlbi5yYW5nZTtcclxuICAgIHBhdHRlcm4ubG9jID0gdG9rZW4ubG9jO1xyXG4gICAgcmV0dXJuIHBhdHRlcm47XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VPYmplY3RQYXR0ZXJuKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbik6IE5vZGUge1xyXG4gICAgbGV0IHBhdHRlcm4gPSBuZXcgTk9ERVMuT2JqZWN0UGF0dGVybigpO1xyXG4gICAgY29udGV4dC53cmFwKENPTlRFWFQuYmluZGluZ0VsZW1lbnQsIHRydWUpO1xyXG4gICAgcGF0dGVybi5wcm9wZXJ0aWVzID0gcGFyc2VfYW5kX2V4dHJhY3QoUEFUVEVSTl9QUk9QRVJUSUVTX1RSRUUsIGNvbnRleHQsIHRva2VuKTtcclxuICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICBwYXR0ZXJuLnJhbmdlID0gdG9rZW4ucmFuZ2U7XHJcbiAgICBwYXR0ZXJuLmxvYyA9IHRva2VuLmxvYztcclxuICAgIHJldHVybiBwYXR0ZXJuO1xyXG59XHJcblxyXG5sZXQgUGF0dGVybkVsZW1lbnRzID0ge1xyXG4gICAgU3VjY2Vzczoge1xyXG4gICAgICAgIGhhbmRsZXI6IGpvaW5fY29udGVudCxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX09yKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgX09yKFwiSWRlbnRpZmllclwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgaWRlbnRpZmllcjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgR3JvdXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5lcnIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQmluZGluZyhjb250ZXh0LCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX09yKFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9Ob25Db2xsZWN0aW5nKF9PcihcIlB1bmN0dWF0b3IgLFwiLCBNQVJLUy5CT1VOREFSWSkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFtcImNvbnRlbnRcIiwgXCJSZXN0RWxlbWVudFwiXSxcclxuICAgICAgICAgICAgICAgIFtcIl9uZXh0XCIsIF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZKV1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogX09yKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBfTWFyayhudWxsKSxcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgLFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY29uc3QgUGF0dGVyblByb3BlcnRpZXMgPSB7XHJcbiAgICAuLi5fU3VjY2Vzc0NvbGxlY3RvcihfUGF0dGVybihcIlByb3BlcnR5XCIpKSxcclxuICAgIFByb3BlcnR5OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcHJldjogX05vbkNhcHR1cmluZyhNQVJLUy5CT1VOREFSWSwgXCJTdWNjZXNzXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleTogX09yKFwiUHVuY3R1YXRvciBbXVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LndyYXAoQ09OVEVYVC50b2tlbnMsIHRva2VuLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGNvbnRleHRbQ09OVEVYVC5wYXJzZXJdLnBhcnNlRXhwcmVzc2lvbihjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yIDpcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIklkZW50aWZpZXJcIikucGlwZShmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCaW5kaW5nKGNvbnRleHQsIHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX09yKFwiUHVuY3R1YXRvciBbXVwiKS5waXBlKHBhcnNlQXJyYXlQYXR0ZXJuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIlB1bmN0dWF0b3Ige31cIikucGlwZShwYXJzZU9iamVjdFBhdHRlcm4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfT3B0aW9uKF9TZXJpZXMoX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yID1cIiksIFwiW0V4cHJlc3Npb25dXCIpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX01hcmsoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbY29sbGVjdGVkXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUgfSA9IGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgX3ZhbHVlID0gbmV3IE5PREVTLkFzc2lnbm1lbnRQYXR0ZXJuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZS5sZWZ0ID0gdmFsdWVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZS5yaWdodCA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2hMb2NhdGlvbihfdmFsdWUsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC52YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQudmFsdWUgPSB2YWx1ZVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgX25leHQ6IF9Ob25Db2xsZWN0aW5nKE1BUktTLkJPVU5EQVJZLCBcIlB1bmN0dWF0b3IgLFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogX01hcmsodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogX01hcmsoXCJpbml0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZDogX01hcmsoZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia2V5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIklkZW50aWZpZXJcIikucGlwZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBpZGVudGlmaWVyOiBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBHcm91cGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5lcnIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICBbXCJjb21wdXRlZFwiLCBfTWFyayhmYWxzZSldXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiLCBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciA9XCIpLCBcIltFeHByZXNzaW9uXVwiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBjb2xsZWN0ZWQua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gbmV3IE5PREVTLkFzc2lnbm1lbnRQYXR0ZXJuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJpZ2h0ID0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaExvY2F0aW9uKHJlcywgbGVmdCwgdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTWFyayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtDT05URVhULmNvbGxlY3RlZF0ua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNob3J0aGFuZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfTWFyayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCaW5kaW5nKGNvbnRleHQsIGNvbnRleHRbQ09OVEVYVC5jb2xsZWN0ZWRdLmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFsaWRhdG9yKCkgey8v5Yy56YWN5Y2g5L2NXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IG5ldyBOdW1iZXIoMyksXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgX186IF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgX09yKE1BUktTLkJPVU5EQVJZLCBcIlN1Y2Nlc3NcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgX09yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlB1bmN0dWF0b3IgW11cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBcIlB1bmN0dWF0b3IgOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIF9PcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUHVuY3R1YXRvciBbXSB7fVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJQdW5jdHVhdG9yID1cIlxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG59XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFJQTtBQWFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../js/syntax/pattern.ts\n");

/***/ }),

/***/ "../../js/syntax/statement.ts":
/*!***************************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/syntax/statement.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar head_1 = __webpack_require__(/*! ./head */ \"../../js/syntax/head.ts\");\nvar expression_1 = __webpack_require__(/*! ./expression */ \"../../js/syntax/expression.ts\");\nvar declaration_1 = __webpack_require__(/*! ./declaration */ \"../../js/syntax/declaration.ts\");\nvar Grouping = head_1.NODES.Grouping;\nvar VariableDeclaration = declaration_1.default.VariableDeclaration;\nvar BLOCK_STATEMENT_PATTERN = head_1._Or(\"Block\", head_1._Or(\"Punctuator {\").walk(function (context, left) {\n    var parser = context[1 /* parser */];\n    parser.parseRange(parser.SYNTAX_TREE, context, left, head_1.is_right_braces).type = \"Block\";\n})).pipe(function (context, token) {\n    var res = new head_1.NODES.BlockStatement();\n    res.body = token.content;\n    head_1.attachLocation(res, token);\n    return res;\n});\nvar GROUPING_EXPRESSION = head_1._Or(\"Punctuator ()\", head_1._Punctuator(\"(\").walk(function (context, index) {\n    var parser = context[1];\n    var store = context.store(10 /* bindingSet */, null, 18 /* bindingElement */, false);\n    parser.parseRange(parser.EXPRESSION_TREE, context, index, head_1.is_right_parentheses, parser.isExpression);\n    context.restore(store);\n})).pipe(function (context, token) {\n    if (token.content) {\n        return token.content;\n    }\n    else {\n        context[1 /* parser */].err(token);\n        return null;\n    }\n});\nvar Statements = head_1.async_getter.Statements = {\n    \"\": {\n        handler: function (_a) {\n            var collected = _a[0], parser = _a[1];\n            parser.err(collected.error);\n            return [];\n        },\n        precedence: 0,\n        collector: [\n            {\n                error: head_1._Or(\"Punctuator\", \"Keyword\"),\n                _next: head_1._NonCapturing(head_1.RIGHT_SIDE_TOPLEVEL_ITEM_PATTERN, \"Punctuator }\"),\n            }\n        ]\n    },\n    \"BreakStatement\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            var label = collected.label;\n            if (label) {\n                if (label instanceof Grouping\n                    || context[11 /* labelSet */].indexOf(label.name) < 0) {\n                    parser.err(label);\n                }\n            }\n            else if (!context[16 /* inIteration */] && !context[17 /* inSwitch */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        filter: [\n            function (context, left) {\n                return head_1.isAligned(context, left, left + 1);\n            },\n            null,\n        ],\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword break\"),\n                label: head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            },\n            [\"label\", head_1._Mark(null)]\n        ]\n    },\n    \"ContinueStatement\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            var label = collected.label;\n            head_1.validateLineTerminator(context);\n            if (label) {\n                if (label instanceof Grouping\n                    || context[11 /* labelSet */].indexOf(label.name) < 0) {\n                    parser.err(label);\n                }\n            }\n            else if (!context[16 /* inIteration */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        filter: \"BreakStatement\",\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword continue\"),\n                label: head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            },\n            [\"label\", head_1._Mark(null)],\n        ]\n    },\n    \"ReturnStatement\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            if (!context[15 /* inFunctionBody */]) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        validator: function (context) {\n            var left = context[2], right = context[3];\n            if (left === right) {\n                var next_token = context.getToken(left + 1);\n                if (next_token && context.getToken(left).loc.end.line === next_token.loc.start.line) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        filter: \"BreakStatement\",\n        precedence: 0,\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword return\"),\n                argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            },\n            [\"argument\", head_1._Mark(null)]\n        ]\n    },\n    \"BlockStatement\": {\n        overload: true,\n        //precedence: 0,\n        collector: [\n            {\n                _prev: head_1._NonCapturing(head_1.TOPLEVEL_ITEM_PATTERN),\n                body: head_1._Punctuator(\"{\").pipe(function (context, token, left) {\n                    var parser = context[1 /* parser */];\n                    return parser.parseRange(parser.SYNTAX_TREE, context, left, head_1.is_right_braces).content;\n                })\n            }\n        ]\n    },\n    \"DoWhileStatement\": {\n        validator: \"ForStatement\",\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            //collected.test = parser.parseExpression(context, collected.test);\n            return collected;\n        },\n        collector: [\n            {\n                keyword: head_1._NonCollecting(\"Keyword do\"),\n            },\n            [\n                [\"body\", head_1.STATEMANT_LIST_ITEM_PATTERN],\n                [\"test\", head_1._Series(head_1._NonCollecting(\"Keyword while\"), GROUPING_EXPRESSION)],\n                [\"_next\", head_1._Option(\"Punctuator ;\")]\n            ]\n        ]\n    },\n    \"EmptyStatement\": [\n        {\n            collector: [\n                {\n                    _prev: head_1._NonCapturing(head_1.TOPLEVEL_ITEM_PATTERN),\n                    _: head_1._NonCollecting(\"Punctuator ;\")\n                }\n            ]\n        }\n    ],\n    \"ExpressionStatement\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1], left = context[2];\n            head_1.validateLineTerminator(context);\n            var begin = context[6 /* begin */];\n            if ((!context[7 /* tokens */] ||\n                context[15 /* inFunctionBody */] === begin)\n                && (begin >= left ||\n                    context.getToken(left - 1).directive)) {\n                var expression = collected.expression;\n                if (expression\n                    && expression.type === \"Literal\"\n                    && typeof expression.value === \"string\"\n                    && expression.raw.length > 2) {\n                    collected = new head_1.NODES.Directive(collected.type, expression, expression.raw.slice(1, -1), collected.range, collected.loc);\n                    if (collected.directive === \"use strict\") {\n                        context[12 /* strict */] = true;\n                    }\n                }\n            }\n            return collected;\n        },\n        precedence: 0,\n        collector: [\n            {\n                expression: head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            }\n        ]\n    },\n    \"ForStatement\": {\n        validator: [\n            function (context) {\n                context.wrap(16 /* inIteration */, true);\n                var res = head_1.parse_next_statement(context);\n                context.unwrap();\n                return res;\n            },\n            null\n        ],\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            var iterator = collected.iterator, body = collected.body, range = collected.range, loc = collected.loc;\n            collected = iterator.content;\n            if (collected) {\n                collected.body = body;\n                collected.range = range;\n                collected.loc = loc;\n                return collected;\n            }\n            else {\n                parser.err(iterator);\n                return [];\n            }\n        },\n        collector: [\n            {\n                keyword: head_1._NonCollecting(\"Keyword for\"),\n                iterator: head_1._Or(\"Punctuator ()\", head_1._Punctuator(\"(\").walk(function (context, left) {\n                    var parser = context[1 /* parser */];\n                    context.wrap(14 /* isExpression */, true);\n                    parser.parseRange(FOR_ITERATOR_TREE, context, left, head_1.is_right_parentheses, parser.isStatement);\n                    context.unwrap();\n                }))\n            },\n            [\"body\", head_1.STATEMANT_LIST_ITEM_PATTERN]\n        ]\n    },\n    \"ForInStatement\": { //ForStatement\n    },\n    \"ForOfStatement\": { //ForStatement\n    },\n    \"IfStatement\": {\n        validator: function (context) {\n            var left = context[2], right = context[3];\n            if ((right - left) % 2 === 1) {\n                return head_1.parse_next_statement(context);\n            }\n            return true;\n        },\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword if\"),\n                test: GROUPING_EXPRESSION,\n                consequent: head_1._Mark(null),\n                alternate: head_1._Mark(null)\n            },\n            [\"consequent\", head_1.STATEMANT_LIST_ITEM_PATTERN],\n            [\n                \"alternate\", head_1._Series(head_1._NonCollecting(\"Keyword else\"), head_1._Option(head_1.STATEMANT_LIST_ITEM_PATTERN))\n            ]\n        ]\n    },\n    \"LabeledStatement\": {\n        validator: [\n            function (context) {\n                var parser = context[1], left = context[2];\n                var label = context.getToken(left);\n                var label_name = label.name;\n                var label_set = context[11 /* labelSet */];\n                if (label_set.indexOf(label_name) >= 0) {\n                    parser.err(label);\n                }\n                label_set.unshift(label_name);\n                var res = head_1.parse_next_statement(context);\n                label_set.shift();\n                return res;\n            },\n            null\n        ],\n        precedence: 0,\n        collector: [\n            {\n                label: head_1._Series(head_1.IDENTIFIER_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, head_1._NonCollecting(\"Punctuator :\"))\n            },\n            [\"body\", head_1.STATEMANT_LIST_ITEM_PATTERN]\n        ]\n    },\n    \"SwitchStatement\": [\n        {\n            collector: [\n                {\n                    token: head_1._NonCollecting(\"Keyword switch\"),\n                    discriminant: GROUPING_EXPRESSION,\n                    cases: head_1._Punctuator(\"{\").pipe(function (context, token, left) {\n                        var parser = context[1 /* parser */];\n                        context.wrap(17 /* inSwitch */, true);\n                        var cases = parser.parseRange(parser.SYNTAX_TREE, context, left, head_1.is_right_braces).content;\n                        context.unwrap();\n                        var has_default = false;\n                        for (var _i = 0, cases_1 = cases; _i < cases_1.length; _i++) {\n                            var item = cases_1[_i];\n                            if (item.type === \"SwitchCase\") {\n                                if (item.test) {\n                                    continue;\n                                }\n                                if (!has_default) {\n                                    has_default = true;\n                                    continue;\n                                }\n                            }\n                            parser.err(item);\n                        }\n                        return cases;\n                    })\n                }\n            ]\n        },\n        {\n            handler: function (_a) {\n                var collected = _a[0];\n                collected.consequent = [];\n                return collected;\n            },\n            precedence: 0,\n            filter: function (content) {\n                return content[17 /* inSwitch */] /*=== content[CONTEXT.tokens]*/;\n            },\n            collector: [\n                {\n                    type: head_1._Mark(\"SwitchCase\"),\n                    test: head_1._Or(head_1._Series(head_1._NonCollecting(\"Keyword case\"), head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN), head_1._Series(head_1._NonCollecting(\"Keyword default\"), head_1._Mark(null))),\n                    __: head_1._NonCollecting(\"Punctuator :\")\n                },\n            ]\n        },\n        {\n            handler: function (_a) {\n                var collected = _a[0];\n                collected.token.consequent.push(collected.consequent);\n                return collected.token;\n            },\n            collector: {\n                token: \"SwitchCase\",\n                consequent: head_1.STATEMANT_LIST_ITEM_PATTERN\n            }\n        }\n    ],\n    \"ThrowStatement\": {\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            head_1.validateLineTerminator(context);\n            if (collected.loc.start.line !== collected.argument.loc.start.line) {\n                parser.err(collected);\n            }\n            return collected;\n        },\n        precedence: 0,\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword throw\"),\n                argument: head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN,\n                _next: head_1._Option(\"Punctuator ;\")\n            }\n        ]\n    },\n    \"TryStatement\": {\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword try\"),\n                block: BLOCK_STATEMENT_PATTERN /*\"Punctuator {}\"*/,\n                handler: head_1._Series(head_1._NonCollecting(\"Keyword catch\"), \"Punctuator ()\", BLOCK_STATEMENT_PATTERN, head_1._Mark(function (context) {\n                    var collected = context[0], parser = context[1];\n                    var _a = collected.handler, param = _a[0], body = _a[1];\n                    var params = expression_1.parse_params(context, param.content);\n                    if (params.length !== 1) {\n                        parser.err(param);\n                    }\n                    collected.handler = {\n                        type: \"CatchClause\",\n                        param: params[0],\n                        body: body\n                    };\n                })),\n                finalizer: head_1._Mark(null)\n            },\n            [\"finalizer\", head_1._Series(head_1._NonCollecting(\"Keyword finally\"), BLOCK_STATEMENT_PATTERN)],\n            [\"handler\", head_1._Mark(null)],\n        ]\n    },\n    \"WhileStatement\": {\n        validator: \"ForStatement\",\n        /*handler(context: Context) {\n            let [collected, parser] = context;\n            //collected.test = parser.parseExpression(context, collected.test);\n            return collected;\n        },*/\n        collector: [\n            {\n                token: head_1._NonCollecting(\"Keyword while\"),\n                test: GROUPING_EXPRESSION\n            },\n            [\"body\", head_1.STATEMANT_LIST_ITEM_PATTERN]\n        ]\n    },\n    \"WithStatement\": {\n        validator: [\n            head_1.parse_next_statement,\n            null\n        ],\n        handler: function (context) {\n            var collected = context[0], parser = context[1];\n            if (context[12 /* strict */]) {\n                parser.err(collected);\n            }\n            //collected.object = parser.parseExpression(context, collected.object);\n            return collected;\n        },\n        collector: [\n            {\n                token: \"Keyword with\",\n                object: \"Punctuator ()\"\n            },\n            [\"body\", head_1.STATEMANT_LIST_ITEM_PATTERN]\n        ]\n    }\n};\nhead_1.async_getter.get(\"Statements\", function (statements) {\n    for (var type_name in statements) {\n        if (type_name) {\n            type_name && (head_1.TYPE_ALIAS[type_name] = [type_name, \"[Statement]\"]);\n        }\n    }\n});\nexports.default = Statements;\nvar ForIterator = {\n    VariableDeclaration: VariableDeclaration,\n    ForStatement: [\n        {\n            collector: [\n                {\n                    init: head_1._Or(\"VariableDeclaration\", head_1._Series(head_1._NonCollecting(\"\" /* BOUNDARY */), head_1._Or(head_1.EXPRESSION_OR_THROW_STRICT_RESERVED_WORDS_PATTERN, head_1._Mark(null)), //EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS\n                    head_1._NonCollecting(\"Punctuator ;\"))),\n                    test: head_1._Series(head_1._Or(head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, head_1._Mark(null)), head_1._NonCollecting(\"Punctuator ;\")),\n                    update: head_1._Series(head_1._Or(head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, head_1._Mark(null)), head_1._NonCapturing(\"Punctuator )\")),\n                    body: head_1._Mark(null)\n                }\n            ]\n        },\n        {\n            handler: function (context) {\n                var collected = context[0], parser = context[1];\n                var left = collected.left;\n                var kind, declarator;\n                if (left instanceof Array) {\n                    kind = left[0], declarator = left[1];\n                }\n                else {\n                    declarator = left;\n                }\n                if (declarator.value === \"()\" && declarator.type === \"Punctuator\") {\n                    var wrapper = declarator;\n                    declarator = head_1.get_inner_group(declarator);\n                    if (declarator.content.length > 0) {\n                        if (kind) {\n                            parser.err(declarator);\n                        }\n                        else if (declarator.content.length > 1) {\n                            parser.err.apply(parser, declarator.content.slice(1));\n                        }\n                        declarator = new Grouping(declarator.content[0], wrapper);\n                    }\n                }\n                if (declarator.type === \"Punctuator\") {\n                    switch (declarator.value) {\n                        case \"{}\":\n                            declarator = expression_1.parseObjectPattern(context, declarator);\n                            break;\n                        case \"[]\":\n                            declarator = expression_1.parseArrayPattern(context, declarator);\n                            break;\n                        default:\n                            parser.err(declarator);\n                            declarator = null;\n                    }\n                }\n                else if (declarator.type !== \"Identifier\") {\n                    parser.err(declarator);\n                    declarator = null;\n                }\n                else {\n                    head_1.validateAssignment(context, declarator);\n                }\n                if (kind) {\n                    left = new head_1.NODES.VariableDeclaration();\n                    left.declarations = [\n                        {\n                            type: \"VariableDeclarator\",\n                            id: declarator,\n                            init: null\n                        }\n                    ];\n                    left.kind = kind.value;\n                    left.range = [kind.range[0], declarator.range[1]];\n                    left.loc = {\n                        start: kind.loc.start,\n                        end: declarator.loc.end\n                    };\n                    collected.left = left;\n                }\n                else {\n                    collected.left = declarator;\n                }\n                return collected;\n            },\n            validator: function (context) {\n                return context[3 /* right */] >= context.tokens.length - 1;\n            },\n            filter: [function () { return false; }, null],\n            precedence: 1.5,\n            collector: [\n                {\n                    _: head_1._Series(//和 VariableDeclaration 不冲突的占位 \n                    \"\" /* BOUNDARY */, head_1._Or(head_1._Series(head_1._Or(\"Keyword var const let\"), head_1._Or(\"Identifier\", \"Punctuator {} [] ()\")), head_1._Series(\"Identifier let\", head_1._Or(\"Identifier\", \"Punctuator {} ()\"))))\n                },\n                {\n                    type: head_1._Mark(\"ForOfStatement\"),\n                    _prev: head_1._NonCollecting(\"\" /* BOUNDARY */),\n                    left: head_1._Series(head_1._Option(head_1._Or(\"Identifier let\", \"Keyword var const let\")), head_1._Or(\"Identifier\", \"Punctuator {} [] ()\")),\n                    token: head_1._NonCollecting(\"Identifier of\"),\n                    right: head_1._Option(head_1._Series(head_1.EXPRESSION_OR_VALIDATE_STRICT_RESERVED_WORDS_PATTERN, head_1._Option(head_1._NonCapturing(\"Punctuator )\")))),\n                    body: head_1._Mark(null),\n                },\n                [\n                    [\"type\", head_1._Mark(\"ForInStatement\")],\n                    [\"token\", head_1._NonCollecting(\"Keyword in\")],\n                    [\"each\", head_1._Mark(false)]\n                ]\n            ]\n        }\n    ]\n};\nvar FOR_ITERATOR_TREE;\nhead_1.async_getter.get(\"EXPRESSION_TREE\", function (EXPRESSION_TREE) {\n    FOR_ITERATOR_TREE = head_1.createMatchTree(ForIterator, EXPRESSION_TREE);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvc3ludGF4L3N0YXRlbWVudC50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vbW50L2QvUHJvZ3JhbUZpbGVzL0dpdEh1Yi9EaXNvbi9qcy9zeW50YXgvc3RhdGVtZW50LnRzP2IwNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmltcG9ydCB7XHJcbiAgICBDb250ZXh0LCBDT05URVhULCBOb2RlLCBUb2tlbiwgTUFSS1MsIE1hdGNoVHJlZVxyXG59IGZyb20gJy4uL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQge1xyXG4gICAgYXN5bmNfZ2V0dGVyLFxyXG4gICAgX1B1bmN0dWF0b3IsXHJcbiAgICBfS2V5d29yZCxcclxuICAgIF9JZGVudGlmaWVyLFxyXG4gICAgX1BhdHRlcm4sXHJcbiAgICBpc19yaWdodF9wYXJlbnRoZXNlcyxcclxuICAgIGlzX3JpZ2h0X2JyYWNrZXRzLFxyXG4gICAgaXNfcmlnaHRfYnJhY2VzLFxyXG4gICAgY3JlYXRlTWF0Y2hUcmVlLFxyXG4gICAgTk9ERVMsXHJcbiAgICBfT3B0aW9uLCBfT3IsIF9TZXJpZXMsIF9Ob25Db2xsZWN0aW5nLCBfTWFyaywgX0xvb3AsIFRZUEVfQUxJQVMsXHJcbiAgICB2YWxpZGF0ZUJpbmRpbmcsIHZhbGlkYXRlTGluZVRlcm1pbmF0b3IsIF9Ob25DYXB0dXJpbmcsXHJcbiAgICB2YWxpZGF0ZUlkZW50aWZpZXIsIHZhbGlkYXRlQXNzaWdubWVudCxcclxuICAgIFNUQVRFTUFOVF9MSVNUX0lURU1fUEFUVEVSTixcclxuICAgIFRPUExFVkVMX0lURU1fUEFUVEVSTixcclxuICAgIFJJR0hUX1NJREVfVE9QTEVWRUxfSVRFTV9QQVRURVJOLFxyXG4gICAgRVhQUkVTU0lPTl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgIElERU5USUZJRVJfT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sXHJcbiAgICBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgIGlzQWxpZ25lZCxcclxuICAgIGF0dGFjaExvY2F0aW9uLFxyXG4gICAgZ2V0X2lubmVyX2dyb3VwLFxyXG4gICAgcGFyc2VfbmV4dF9zdGF0ZW1lbnQsXHJcbn0gZnJvbSAnLi9oZWFkJ1xyXG5pbXBvcnQge1xyXG4gICAgcGFyc2VBcnJheVBhdHRlcm4sXHJcbiAgICBwYXJzZU9iamVjdFBhdHRlcm4sXHJcbiAgICBwYXJzZV9wYXJhbXNcclxufSBmcm9tICcuL2V4cHJlc3Npb24nO1xyXG5pbXBvcnQgRGVjbGFyYXRpb24gZnJvbSAnLi9kZWNsYXJhdGlvbic7XHJcblxyXG5jb25zdCBHcm91cGluZyA9IE5PREVTLkdyb3VwaW5nO1xyXG5sZXQgeyBWYXJpYWJsZURlY2xhcmF0aW9uIH0gPSBEZWNsYXJhdGlvbjtcclxuXHJcblxyXG5sZXQgQkxPQ0tfU1RBVEVNRU5UX1BBVFRFUk4gPSBfT3IoXHJcbiAgICBcIkJsb2NrXCIsXHJcbiAgICBfT3IoXCJQdW5jdHVhdG9yIHtcIikud2FsayhcclxuICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgbGVmdDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgICAgICAgICAgcGFyc2VyLnBhcnNlUmFuZ2UocGFyc2VyLlNZTlRBWF9UUkVFLCBjb250ZXh0LCBsZWZ0LCBpc19yaWdodF9icmFjZXMpLnR5cGUgPSBcIkJsb2NrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgKVxyXG4pLnBpcGUoXHJcbiAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBOT0RFUy5CbG9ja1N0YXRlbWVudCgpO1xyXG4gICAgICAgIHJlcy5ib2R5ID0gdG9rZW4uY29udGVudDtcclxuICAgICAgICBhdHRhY2hMb2NhdGlvbihyZXMsIHRva2VuKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4pXHJcblxyXG5sZXQgR1JPVVBJTkdfRVhQUkVTU0lPTiA9IF9PcihcclxuICAgIFwiUHVuY3R1YXRvciAoKVwiLFxyXG4gICAgX1B1bmN0dWF0b3IoXCIoXCIpLndhbGsoXHJcbiAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIGluZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IFssIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgc3RvcmUgPSBjb250ZXh0LnN0b3JlKFxyXG4gICAgICAgICAgICAgICAgQ09OVEVYVC5iaW5kaW5nU2V0LCBudWxsLFxyXG4gICAgICAgICAgICAgICAgQ09OVEVYVC5iaW5kaW5nRWxlbWVudCwgZmFsc2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcGFyc2VyLnBhcnNlUmFuZ2UocGFyc2VyLkVYUFJFU1NJT05fVFJFRSwgY29udGV4dCwgaW5kZXgsIGlzX3JpZ2h0X3BhcmVudGhlc2VzLCBwYXJzZXIuaXNFeHByZXNzaW9uKTtcclxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKHN0b3JlKTtcclxuICAgICAgICB9XHJcbiAgICApXHJcbikucGlwZShcclxuICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCB0b2tlbjogVG9rZW4pIHtcclxuICAgICAgICBpZiAodG9rZW4uY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4uY29udGVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQucGFyc2VyXS5lcnIodG9rZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbilcclxuXHJcbmNvbnN0IFN0YXRlbWVudHM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSBhc3luY19nZXR0ZXIuU3RhdGVtZW50cyA9IHtcclxuICAgIFwiXCI6IHtcclxuICAgICAgICBoYW5kbGVyKFtjb2xsZWN0ZWQsIHBhcnNlcl06IENvbnRleHQpIHtcclxuICAgICAgICAgICAgcGFyc2VyLmVycihjb2xsZWN0ZWQuZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcjogX09yKFwiUHVuY3R1YXRvclwiLCBcIktleXdvcmRcIiksXHJcbiAgICAgICAgICAgICAgICBfbmV4dDogX05vbkNhcHR1cmluZyhSSUdIVF9TSURFX1RPUExFVkVMX0lURU1fUEFUVEVSTiwgXCJQdW5jdHVhdG9yIH1cIiksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJCcmVha1N0YXRlbWVudFwiOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsaWRhdGVMaW5lVGVybWluYXRvcihjb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGxhYmVsID0gY29sbGVjdGVkLmxhYmVsO1xyXG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbCBpbnN0YW5jZW9mIEdyb3VwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgY29udGV4dFtDT05URVhULmxhYmVsU2V0XS5pbmRleE9mKGxhYmVsLm5hbWUpIDwgMFxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVycihsYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbnRleHRbQ09OVEVYVC5pbkl0ZXJhdGlvbl0gJiYgIWNvbnRleHRbQ09OVEVYVC5pblN3aXRjaF0pIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoY29sbGVjdGVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmlsdGVyOiBbXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0FsaWduZWQoY29udGV4dCwgbGVmdCwgbGVmdCArIDEpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgYnJlYWtcIiksXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogSURFTlRJRklFUl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImxhYmVsXCIsIF9NYXJrKG51bGwpXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkNvbnRpbnVlU3RhdGVtZW50XCI6IHtcclxuICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBjb2xsZWN0ZWQubGFiZWw7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlTGluZVRlcm1pbmF0b3IoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsIGluc3RhbmNlb2YgR3JvdXBpbmdcclxuICAgICAgICAgICAgICAgICAgICB8fCBjb250ZXh0W0NPTlRFWFQubGFiZWxTZXRdLmluZGV4T2YobGFiZWwubmFtZSkgPCAwXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY29udGV4dFtDT05URVhULmluSXRlcmF0aW9uXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VyLmVycihjb2xsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWx0ZXI6IFwiQnJlYWtTdGF0ZW1lbnRcIixcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCBjb250aW51ZVwiKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9PcHRpb24oXCJQdW5jdHVhdG9yIDtcIilcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW1wibGFiZWxcIiwgX01hcmsobnVsbCldLFxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIlJldHVyblN0YXRlbWVudFwiOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsaWRhdGVMaW5lVGVybWluYXRvcihjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0W0NPTlRFWFQuaW5GdW5jdGlvbkJvZHldKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGNvbGxlY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbGlkYXRvcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbLCAsIGxlZnQsIHJpZ2h0XSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRfdG9rZW4gPSBjb250ZXh0LmdldFRva2VuKGxlZnQgKyAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0X3Rva2VuICYmIGNvbnRleHQuZ2V0VG9rZW4obGVmdCkubG9jLmVuZC5saW5lID09PSBuZXh0X3Rva2VuLmxvYy5zdGFydC5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmlsdGVyOiBcIkJyZWFrU3RhdGVtZW50XCIsXHJcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCByZXR1cm5cIiksXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImFyZ3VtZW50XCIsIF9NYXJrKG51bGwpXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkJsb2NrU3RhdGVtZW50XCI6IHtcclxuICAgICAgICBvdmVybG9hZDogdHJ1ZSwvL+WSjCBPYmplY3RQYXR0ZXJuIOaUtumbhuWZqOaciemHjeWPoO+8jOWcqOWtmOWcqCBCbG9ja1N0YXRlbWVudCDnmoTnjq/looPvvIwgT2JqZWN0UGF0dGVybiDnmoQgZmlsdGVyIOS4jeS8mui/lOWbniB0cnVl77yM6L+Z6YeM5by65Yi26KaG55uWXHJcbiAgICAgICAgLy9wcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcHJldjogX05vbkNhcHR1cmluZyhUT1BMRVZFTF9JVEVNX1BBVFRFUk4pLFxyXG4gICAgICAgICAgICAgICAgYm9keTogX1B1bmN0dWF0b3IoXCJ7XCIpLnBpcGUoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbnRleHQ6IENvbnRleHQsIHRva2VuOiBUb2tlbiwgbGVmdDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVJhbmdlKHBhcnNlci5TWU5UQVhfVFJFRSwgY29udGV4dCwgbGVmdCwgaXNfcmlnaHRfYnJhY2VzKS5jb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkRvV2hpbGVTdGF0ZW1lbnRcIjoge1xyXG4gICAgICAgIHZhbGlkYXRvcjogXCJGb3JTdGF0ZW1lbnRcIixcclxuICAgICAgICBoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUxpbmVUZXJtaW5hdG9yKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAvL2NvbGxlY3RlZC50ZXN0ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihjb250ZXh0LCBjb2xsZWN0ZWQudGVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5d29yZDogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGRvXCIpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbXCJib2R5XCIsIFNUQVRFTUFOVF9MSVNUX0lURU1fUEFUVEVSTl0sXHJcbiAgICAgICAgICAgICAgICBbXCJ0ZXN0XCIsIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIHdoaWxlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIEdST1VQSU5HX0VYUFJFU1NJT05cclxuICAgICAgICAgICAgICAgICldLFxyXG4gICAgICAgICAgICAgICAgW1wiX25leHRcIiwgX09wdGlvbihcIlB1bmN0dWF0b3IgO1wiKV1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkVtcHR5U3RhdGVtZW50XCI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ2FwdHVyaW5nKFRPUExFVkVMX0lURU1fUEFUVEVSTiksXHJcbiAgICAgICAgICAgICAgICAgICAgXzogX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yIDtcIilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjoge1xyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZCwgcGFyc2VyLCBsZWZ0XSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlTGluZVRlcm1pbmF0b3IoY29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBiZWdpbiA9IGNvbnRleHRbQ09OVEVYVC5iZWdpbl07XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgICAgICAhY29udGV4dFtDT05URVhULnRva2Vuc10gfHxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQuaW5GdW5jdGlvbkJvZHldID09PSBiZWdpblxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgJiYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID49IGxlZnQgfHxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmdldFRva2VuKGxlZnQgLSAxKS5kaXJlY3RpdmVcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXhwcmVzc2lvbiA9IGNvbGxlY3RlZC5leHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAgICAmJiBleHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgdHlwZW9mIGV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgICAgICAmJiBleHByZXNzaW9uLnJhdy5sZW5ndGggPiAyXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQgPSBuZXcgTk9ERVMuRGlyZWN0aXZlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwgLTEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5sb2NcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWQuZGlyZWN0aXZlID09PSBcInVzZSBzdHJpY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W0NPTlRFWFQuc3RyaWN0XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBFWFBSRVNTSU9OX09SX1ZBTElEQVRFX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgX25leHQ6IF9PcHRpb24oXCJQdW5jdHVhdG9yIDtcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkZvclN0YXRlbWVudFwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yOiBbXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LndyYXAoQ09OVEVYVC5pbkl0ZXJhdGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gcGFyc2VfbmV4dF9zdGF0ZW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnVud3JhcCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgaXRlcmF0b3IsIGJvZHksIHJhbmdlLCBsb2MgfSA9IGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgY29sbGVjdGVkID0gaXRlcmF0b3IuY29udGVudDtcclxuICAgICAgICAgICAgaWYgKGNvbGxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLmJvZHkgPSBib2R5O1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLnJhbmdlID0gcmFuZ2U7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWQubG9jID0gbG9jO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAga2V5d29yZDogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGZvclwiKSxcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yOiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgXCJQdW5jdHVhdG9yICgpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgX1B1bmN0dWF0b3IoXCIoXCIpLndhbGsoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0LCBsZWZ0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQud3JhcChDT05URVhULmlzRXhwcmVzc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIucGFyc2VSYW5nZShGT1JfSVRFUkFUT1JfVFJFRSwgY29udGV4dCwgbGVmdCwgaXNfcmlnaHRfcGFyZW50aGVzZXMsIHBhcnNlci5pc1N0YXRlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImJvZHlcIiwgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkZvckluU3RhdGVtZW50XCI6IHsvL0ZvclN0YXRlbWVudFxyXG4gICAgfSxcclxuICAgIFwiRm9yT2ZTdGF0ZW1lbnRcIjogey8vRm9yU3RhdGVtZW50XHJcbiAgICB9LFxyXG4gICAgXCJJZlN0YXRlbWVudFwiOiB7XHJcbiAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFssICwgbGVmdCwgcmlnaHRdID0gY29udGV4dDtcclxuICAgICAgICAgICAgaWYgKChyaWdodCAtIGxlZnQpICUgMiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlX25leHRfc3RhdGVtZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgaWZcIiksXHJcbiAgICAgICAgICAgICAgICB0ZXN0OiBHUk9VUElOR19FWFBSRVNTSU9OLFxyXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogX01hcmsobnVsbCksXHJcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGU6IF9NYXJrKG51bGwpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImNvbnNlcXVlbnRcIiwgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOXSxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgXCJhbHRlcm5hdGVcIiwgX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgZWxzZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBfT3B0aW9uKFNUQVRFTUFOVF9MSVNUX0lURU1fUEFUVEVSTilcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIkxhYmVsZWRTdGF0ZW1lbnRcIjoge1xyXG4gICAgICAgIHZhbGlkYXRvcjogW1xyXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IFssIHBhcnNlciwgbGVmdF0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gY29udGV4dC5nZXRUb2tlbihsZWZ0KTtcclxuICAgICAgICAgICAgICAgIGxldCBsYWJlbF9uYW1lID0gbGFiZWwubmFtZTtcclxuICAgICAgICAgICAgICAgIGxldCBsYWJlbF9zZXQgPSBjb250ZXh0W0NPTlRFWFQubGFiZWxTZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsX3NldC5pbmRleE9mKGxhYmVsX25hbWUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhYmVsX3NldC51bnNoaWZ0KGxhYmVsX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IHBhcnNlX25leHRfc3RhdGVtZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgbGFiZWxfc2V0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgXSxcclxuICAgICAgICBwcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbDogX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICBJREVOVElGSUVSX09SX1RIUk9XX1NUUklDVF9SRVNFUlZFRF9XT1JEU19QQVRURVJOLFxyXG4gICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiUHVuY3R1YXRvciA6XCIpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImJvZHlcIiwgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOXVxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIlN3aXRjaFN0YXRlbWVudFwiOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIHN3aXRjaFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBkaXNjcmltaW5hbnQ6IEdST1VQSU5HX0VYUFJFU1NJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZXM6IF9QdW5jdHVhdG9yKFwie1wiKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY29udGV4dDogQ29udGV4dCwgdG9rZW46IFRva2VuLCBsZWZ0OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSBjb250ZXh0W0NPTlRFWFQucGFyc2VyXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC53cmFwKENPTlRFWFQuaW5Td2l0Y2gsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhc2VzID0gcGFyc2VyLnBhcnNlUmFuZ2UocGFyc2VyLlNZTlRBWF9UUkVFLCBjb250ZXh0LCBsZWZ0LCBpc19yaWdodF9icmFjZXMpLmNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudW53cmFwKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc19kZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2FzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcIlN3aXRjaENhc2VcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc19kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfZGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoW2NvbGxlY3RlZF06IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5jb25zZXF1ZW50ID0gW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgICAgICBmaWx0ZXIoY29udGVudDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRbQ09OVEVYVC5pblN3aXRjaF0gLyo9PT0gY29udGVudFtDT05URVhULnRva2Vuc10qLztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogX01hcmsoXCJTd2l0Y2hDYXNlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRlc3Q6IF9PcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9Ob25Db2xsZWN0aW5nKFwiS2V5d29yZCBjYXNlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGRlZmF1bHRcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTWFyayhudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBfXzogX05vbkNvbGxlY3RpbmcoXCJQdW5jdHVhdG9yIDpcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaGFuZGxlcihbY29sbGVjdGVkXTogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGVkLnRva2VuLmNvbnNlcXVlbnQucHVzaChjb2xsZWN0ZWQuY29uc2VxdWVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQudG9rZW47XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbGxlY3Rvcjoge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IFwiU3dpdGNoQ2FzZVwiLFxyXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgXCJUaHJvd1N0YXRlbWVudFwiOiB7XHJcbiAgICAgICAgaGFuZGxlcihjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGxldCBbY29sbGVjdGVkLCBwYXJzZXJdID0gY29udGV4dDtcclxuICAgICAgICAgICAgdmFsaWRhdGVMaW5lVGVybWluYXRvcihjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvbGxlY3RlZC5sb2Muc3RhcnQubGluZSAhPT0gY29sbGVjdGVkLmFyZ3VtZW50LmxvYy5zdGFydC5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGNvbGxlY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZWNlZGVuY2U6IDAsXHJcbiAgICAgICAgY29sbGVjdG9yOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRva2VuOiBfTm9uQ29sbGVjdGluZyhcIktleXdvcmQgdGhyb3dcIiksXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogRVhQUkVTU0lPTl9PUl9USFJPV19TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgIF9uZXh0OiBfT3B0aW9uKFwiUHVuY3R1YXRvciA7XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJUcnlTdGF0ZW1lbnRcIjoge1xyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIHRyeVwiKSxcclxuICAgICAgICAgICAgICAgIGJsb2NrOiBCTE9DS19TVEFURU1FTlRfUEFUVEVSTi8qXCJQdW5jdHVhdG9yIHt9XCIqLyxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGNhdGNoXCIpLCBcIlB1bmN0dWF0b3IgKClcIiwgQkxPQ0tfU1RBVEVNRU5UX1BBVFRFUk4sXHJcbiAgICAgICAgICAgICAgICAgICAgX01hcmsoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjb250ZXh0OiBDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgW2NvbGxlY3RlZCwgcGFyc2VyXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgW3BhcmFtLCBib2R5XSA9IGNvbGxlY3RlZC5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHBhcnNlX3BhcmFtcyhjb250ZXh0LCBwYXJhbS5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVycihwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQuaGFuZGxlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNhdGNoQ2xhdXNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW06IHBhcmFtc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIGZpbmFsaXplcjogX01hcmsobnVsbClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgW1wiZmluYWxpemVyXCIsIF9TZXJpZXMoX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGZpbmFsbHlcIiksIEJMT0NLX1NUQVRFTUVOVF9QQVRURVJOKV0sXHJcbiAgICAgICAgICAgIFtcImhhbmRsZXJcIiwgX01hcmsobnVsbCldLFxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBcIldoaWxlU3RhdGVtZW50XCI6IHtcclxuICAgICAgICB2YWxpZGF0b3I6IFwiRm9yU3RhdGVtZW50XCIsXHJcbiAgICAgICAgLypoYW5kbGVyKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAvL2NvbGxlY3RlZC50ZXN0ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihjb250ZXh0LCBjb2xsZWN0ZWQudGVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSwqL1xyXG4gICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIHdoaWxlXCIpLFxyXG4gICAgICAgICAgICAgICAgdGVzdDogR1JPVVBJTkdfRVhQUkVTU0lPTlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbXCJib2R5XCIsIFNUQVRFTUFOVF9MSVNUX0lURU1fUEFUVEVSTl1cclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAgXCJXaXRoU3RhdGVtZW50XCI6IHtcclxuICAgICAgICB2YWxpZGF0b3I6IFtcclxuICAgICAgICAgICAgcGFyc2VfbmV4dF9zdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIG51bGxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgW2NvbGxlY3RlZCwgcGFyc2VyXSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0W0NPTlRFWFQuc3RyaWN0XSkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VyLmVycihjb2xsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29sbGVjdGVkLm9iamVjdCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oY29udGV4dCwgY29sbGVjdGVkLm9iamVjdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdG9rZW46IFwiS2V5d29yZCB3aXRoXCIsXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IFwiUHVuY3R1YXRvciAoKVwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFtcImJvZHlcIiwgU1RBVEVNQU5UX0xJU1RfSVRFTV9QQVRURVJOXVxyXG4gICAgICAgIF1cclxuICAgIH1cclxufTtcclxuXHJcbmFzeW5jX2dldHRlci5nZXQoXCJTdGF0ZW1lbnRzXCIsIGZ1bmN0aW9uIChzdGF0ZW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XHJcbiAgICBmb3IgKGNvbnN0IHR5cGVfbmFtZSBpbiBzdGF0ZW1lbnRzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVfbmFtZSkge1xyXG4gICAgICAgICAgICB0eXBlX25hbWUgJiYgKFRZUEVfQUxJQVNbdHlwZV9uYW1lXSA9IFt0eXBlX25hbWUsIFwiW1N0YXRlbWVudF1cIl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcbmV4cG9ydCBkZWZhdWx0IFN0YXRlbWVudHM7XHJcblxyXG5sZXQgRm9ySXRlcmF0b3IgPSB7XHJcbiAgICBWYXJpYWJsZURlY2xhcmF0aW9uLFxyXG4gICAgRm9yU3RhdGVtZW50OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb2xsZWN0b3I6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbml0OiBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX05vbkNvbGxlY3RpbmcoTUFSS1MuQk9VTkRBUlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX09yKEVYUFJFU1NJT05fT1JfVEhST1dfU1RSSUNUX1JFU0VSVkVEX1dPUkRTX1BBVFRFUk4sIF9NYXJrKG51bGwpKSwvL0VYUFJFU1NJT05fT1JfVkFMSURBVEVfU1RSSUNUX1JFU0VSVkVEX1dPUkRTXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgO1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXN0OiBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfT3IoRVhQUkVTU0lPTl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTiwgX01hcmsobnVsbCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ29sbGVjdGluZyhcIlB1bmN0dWF0b3IgO1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfT3IoRVhQUkVTU0lPTl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTiwgX01hcmsobnVsbCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfTm9uQ2FwdHVyaW5nKFwiUHVuY3R1YXRvciApXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICBib2R5OiBfTWFyayhudWxsKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoY29udGV4dDogQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IFtjb2xsZWN0ZWQsIHBhcnNlcl0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgbGVmdCB9ID0gY29sbGVjdGVkO1xyXG4gICAgICAgICAgICAgICAgbGV0IGtpbmQ6IE5vZGUsIGRlY2xhcmF0b3I6IE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgW2tpbmQsIGRlY2xhcmF0b3JdID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRvciA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRvci52YWx1ZSA9PT0gXCIoKVwiICYmIGRlY2xhcmF0b3IudHlwZSA9PT0gXCJQdW5jdHVhdG9yXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRlY2xhcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRvciA9IGdldF9pbm5lcl9ncm91cChkZWNsYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRvci5jb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoZGVjbGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRvci5jb250ZW50Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnIoLi4uZGVjbGFyYXRvci5jb250ZW50LnNsaWNlKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdG9yID0gbmV3IEdyb3VwaW5nKGRlY2xhcmF0b3IuY29udGVudFswXSwgd3JhcHBlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0b3IudHlwZSA9PT0gXCJQdW5jdHVhdG9yXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGRlY2xhcmF0b3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInt9XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdG9yID0gcGFyc2VPYmplY3RQYXR0ZXJuKGNvbnRleHQsIGRlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJbXVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRvciA9IHBhcnNlQXJyYXlQYXR0ZXJuKGNvbnRleHQsIGRlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyKGRlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWNsYXJhdG9yLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVycihkZWNsYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdG9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBc3NpZ25tZW50KGNvbnRleHQsIGRlY2xhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IE5PREVTLlZhcmlhYmxlRGVjbGFyYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0LmRlY2xhcmF0aW9ucyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkZWNsYXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0LmtpbmQgPSBraW5kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQucmFuZ2UgPSBba2luZC5yYW5nZVswXSwgZGVjbGFyYXRvci5yYW5nZVsxXV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdC5sb2MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBraW5kLmxvYy5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBkZWNsYXJhdG9yLmxvYy5lbmRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLmxlZnQgPSBkZWNsYXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmFsaWRhdG9yKGNvbnRleHQ6IENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W0NPTlRFWFQucmlnaHRdID49IGNvbnRleHQudG9rZW5zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbHRlcjogW2Z1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH0sIG51bGxdLFxyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxLjUsXHJcbiAgICAgICAgICAgIGNvbGxlY3RvcjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF86IF9TZXJpZXMoLy/lkowgVmFyaWFibGVEZWNsYXJhdGlvbiDkuI3lhrLnqoHnmoTljaDkvY0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1BUktTLkJPVU5EQVJZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfT3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIktleXdvcmQgdmFyIGNvbnN0IGxldFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfT3IoXCJJZGVudGlmaWVyXCIsIFwiUHVuY3R1YXRvciB7fSBbXSAoKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9TZXJpZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVyIGxldFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIklkZW50aWZpZXJcIiwgXCJQdW5jdHVhdG9yIHt9ICgpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfTWFyayhcIkZvck9mU3RhdGVtZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIF9wcmV2OiBfTm9uQ29sbGVjdGluZyhNQVJLUy5CT1VOREFSWSksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogX1NlcmllcyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgX09wdGlvbihfT3IoXCJJZGVudGlmaWVyIGxldFwiLCBcIktleXdvcmQgdmFyIGNvbnN0IGxldFwiKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9PcihcIklkZW50aWZpZXJcIiwgXCJQdW5jdHVhdG9yIHt9IFtdICgpXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogX05vbkNvbGxlY3RpbmcoXCJJZGVudGlmaWVyIG9mXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBfT3B0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfU2VyaWVzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQUkVTU0lPTl9PUl9WQUxJREFURV9TVFJJQ1RfUkVTRVJWRURfV09SRFNfUEFUVEVSTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9PcHRpb24oX05vbkNhcHR1cmluZyhcIlB1bmN0dWF0b3IgKVwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogX01hcmsobnVsbCksXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIFtcInR5cGVcIiwgX01hcmsoXCJGb3JJblN0YXRlbWVudFwiKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1widG9rZW5cIiwgX05vbkNvbGxlY3RpbmcoXCJLZXl3b3JkIGluXCIpXSxcclxuICAgICAgICAgICAgICAgICAgICBbXCJlYWNoXCIsIF9NYXJrKGZhbHNlKV1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgXVxyXG5cclxuICAgICAgICB9XHJcbiAgICBdXHJcbn07XHJcbmxldCBGT1JfSVRFUkFUT1JfVFJFRTogTWF0Y2hUcmVlO1xyXG5hc3luY19nZXR0ZXIuZ2V0KFwiRVhQUkVTU0lPTl9UUkVFXCIsIGZ1bmN0aW9uIChFWFBSRVNTSU9OX1RSRUU6IE1hdGNoVHJlZSkge1xyXG4gICAgRk9SX0lURVJBVE9SX1RSRUUgPSBjcmVhdGVNYXRjaFRyZWUoRm9ySXRlcmF0b3IsIEVYUFJFU1NJT05fVFJFRSk7XHJcbn0pO1xyXG4iXSwibWFwcGluZ3MiOiI7O0FBSUE7QUEwQkE7QUFLQTtBQUVBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../js/syntax/statement.ts\n");

/***/ }),

/***/ "../../js/tokenizer.ts":
/*!********************************************************!*\
  !*** /mnt/d/ProgramFiles/GitHub/Dison/js/tokenizer.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar character_1 = __webpack_require__(/*! ./character */ \"../../js/character.ts\");\nvar interfaces_1 = __webpack_require__(/*! ./interfaces */ \"../../js/interfaces.ts\");\nvar default_1 = /** @class */ (function (_super) {\n    __extends(default_1, _super);\n    function default_1(options) {\n        var _this = _super.call(this) || this;\n        _this.token_hooks = {};\n        _this.save_comments = true;\n        for (var key in options) {\n            _this[key] = options[key];\n        }\n        return _this;\n        //console.log(333, TOKEN_TYPES,TOKEN_TYPE_MAP);\n    }\n    default_1.prototype.err = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        //debugger;\n        this.error_logs.push.apply(this.error_logs, arguments);\n    };\n    default_1.prototype.init = function (input) {\n        this.line_number = 0;\n        this.line_start = 0;\n        this.index = 0;\n        this.input = input;\n        this.end = this.input.length;\n        this.error_logs = [];\n        this.tokens = [];\n        this.terminator_stack = [];\n        this.curly_stack = [];\n    };\n    default_1.prototype.tokenize = function (input) {\n        this.init(input);\n        while (this.nextToken())\n            ;\n        return this.tokens;\n    };\n    default_1.prototype.nextToken = function () {\n        while (this.index < this.end\n            && (this.terminator_stack.length === 0\n                || this.tokens.length === 0\n                || !this.terminator_stack[0](this.tokens[this.tokens.length - 1]))) {\n            var token = this._nextToken();\n            if (token) {\n                var hook = this.token_hooks[token.type];\n                hook && (token = hook(token, this));\n                if (this.save_comments || token.type !== this.TYPE_ENUMS.Comments) {\n                    this.tokens.push(token);\n                    return token;\n                }\n            }\n            else if (this.index < this.end) {\n                this.err(this.createToken(\"error\", [this.index, ++this.index]));\n            }\n        }\n    };\n    default_1.prototype.createToken = function (type, range, value, start, end) {\n        if (value === void 0) { value = this.input.slice(range[0], range[1]); }\n        if (start === void 0) { start = {\n            line: this.line_number,\n            column: range[0] - this.line_start\n        }; }\n        if (end === void 0) { end = {\n            line: this.line_number,\n            column: range[1] - this.line_start\n        }; }\n        return {\n            type: type,\n            value: value,\n            range: range,\n            loc: {\n                start: start, end: end\n            }\n        };\n    };\n    default_1.prototype.match = function (node) {\n        var start = this.index, end = this.index;\n        var prev_node;\n        do {\n            prev_node = node;\n            node = prev_node[this.input[end++]];\n        } while (node);\n        var target = prev_node[\" END\" /* END */];\n        if (target && (target.type || (target = target(this)))) {\n            this.index = end - 1;\n            return target.scanner ?\n                target.scanner(this, start) :\n                this.createToken(this.TYPE_ENUMS[target.type] || target.type, [start, this.index], target.key);\n        }\n    };\n    default_1.prototype.nextIdentifier = function () {\n        var length = this.inIdentifierStart();\n        var token;\n        if (length > 0) {\n            var start = this.index;\n            var str = \"\";\n            do {\n                str += length === 1 ? this.input[this.index] : this._volatility;\n                this.index += length;\n                length = this.inIdentifierPart();\n            } while (length > 0);\n            var type = this.TOKEN_TYPE_MAPPERS[\" \" + str];\n            token = this.createToken(this.TYPE_ENUMS[type || \"Identifier\"], [start, this.index]);\n            this._volatility = str;\n            if (type && str.length !== this.index - start) {\n                this.err(token);\n            }\n        }\n        if (length < 0) {\n            this.err(this.createToken(\"error\", [this.index, this.index -= length]));\n        }\n        return token;\n    };\n    Object.defineProperty(default_1.prototype, \"is_primary_expr_start\", {\n        /*get maybe_regex() {\n            if (this.input[this.index] === \"/\") {\n                let is_primary_expr_start = (this as any).is_primary_expr_start;\n                return is_primary_expr_start !== undefined\n                    ? is_primary_expr_start\n                    : !this.tokens.length || this.tokens[this.tokens.length - 1].type === TOKEN_TYPE_ENUMS.Punctuator;\n            }\n        }*/\n        get: function () {\n            if (this.tokens.length) {\n                var last_node = this.tokens[this.tokens.length - 1];\n                return last_node.type === this.TYPE_ENUMS.Keyword\n                    || last_node.type === this.TYPE_ENUMS.Punctuator && last_node.content === undefined;\n            }\n            else {\n                return true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    default_1.prototype.nextPunctuator = function () {\n        return this.match(!this.is_primary_expr_start ? this.PUNCTUATORS_TREE : this.PRIMARY_EXPR_START_PUNCTUATORS_TREE);\n    };\n    default_1.prototype.nextNumeric = function () {\n        var _this = this;\n        var start = this.index;\n        var ch = this.input.charCodeAt(this.index);\n        var number;\n        var flags = 4 /* DECIMAL */;\n        var _get_token = function () {\n            _this._volatility = flags & 2 /* OCTAL */ ? (flags & ~4 /* DECIMAL */) : flags;\n            return _this.createToken(_this.TYPE_ENUMS.Numeric, [start, _this.index]);\n        };\n        var _get_error = function (message) {\n            if (message === void 0) { message = \"Invalid or unexpected token\"; }\n            var error = _get_token();\n            error.error = message;\n            error.input = _this.input.slice(start, _this.index + 1);\n            _this.err(error);\n            return error;\n        };\n        var decimalValue = this.decimalValue;\n        switch (ch) {\n            case 0x2e: //\".\"\n                if (decimalValue(this.input.charCodeAt(this.index + 1)) >= 0) {\n                    this.index += 1;\n                    flags |= 32 /* FLOAT */;\n                    break;\n                }\n                else {\n                    return;\n                }\n            case 0x30: //\"0\"\n                flags = interfaces_1.NUMERIC_KEYWORD_MAPPINGS[this.input[++this.index]];\n                if (!flags) {\n                    number = decimalValue(this.input.charCodeAt(this.index));\n                    if (number >= 0) {\n                        flags = 4 /* DECIMAL */;\n                        number < 8 && (flags |= 2 /* OCTAL */);\n                    }\n                    else if (!this.inIdentifierStart()) {\n                        flags = 4 /* DECIMAL */;\n                        return _get_token();\n                    }\n                    else {\n                        return _get_error();\n                    }\n                }\n                break;\n            default:\n                if (decimalValue(ch) < 0) {\n                    return;\n                }\n        }\n        if (flags & 4 /* DECIMAL */) {\n            while ((ch = this.input.charCodeAt(++this.index))) {\n                number = decimalValue(ch);\n                if (number >= 0) {\n                    number < 8 || (flags &= ~2 /* OCTAL */);\n                    continue;\n                }\n                switch (ch) {\n                    case 0x65: //\"e\"\n                    case 0x45: //\"E\"\n                        if (!(flags & (64 /* E */ | 2 /* OCTAL */))) {\n                            flags |= 64 /* E */;\n                            ch = this.input.charCodeAt(this.index + 1);\n                            if (ch === 0x2b || ch === 0x2d) { //+ -\n                                this.index += 1;\n                            }\n                            continue;\n                        }\n                        else {\n                            return _get_error();\n                        }\n                    case 0x2e: //\".\"\n                        if (!(flags & (32 /* FLOAT */ | 64 /* E */ | 2 /* OCTAL */))) {\n                            flags |= 32 /* FLOAT */;\n                            continue;\n                        }\n                    default:\n                        return this.inIdentifierStart()\n                            ? _get_error()\n                            : _get_token();\n                }\n            }\n            return _get_token();\n        }\n        else {\n            var test = flags & 8 /* HEX */\n                ? this.hexValue : (flags & 1 /* BINARY */\n                ? this.binaryValue\n                : this.octalValue);\n            while (test(this.input.charCodeAt(++this.index)) >= 0)\n                ;\n            return this.index > start + 3 && !this.inIdentifierStart()\n                ? _get_token()\n                : _get_error();\n        }\n    };\n    default_1.prototype.skipNonsenses = function () {\n        for (var cp = void 0; this.index < this.end; this.index++) {\n            cp = this.input.charCodeAt(this.index);\n            switch (true) {\n                case this.isWhiteSpace(cp):\n                    break;\n                case this.isLineTerminator(cp):\n                    this.line_number++;\n                    this.line_start = this.index + 1;\n                    break;\n                default:\n                    return true;\n            }\n        }\n    };\n    default_1.prototype._nextToken = function () {\n        return this.skipNonsenses() && (this.nextIdentifier() ||\n            this.nextNumeric() ||\n            this.nextPunctuator());\n    };\n    return default_1;\n}(character_1.default));\nexports.default = default_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vanMvdG9rZW5pemVyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9tbnQvZC9Qcm9ncmFtRmlsZXMvR2l0SHViL0Rpc29uL2pzL3Rva2VuaXplci50cz8zZWZhIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5cclxuaW1wb3J0IENoYXJhY3RlciBmcm9tICcuL2NoYXJhY3RlcidcclxuaW1wb3J0IHtcclxuICAgIFBvc2l0aW9uLCBTb3VyY2VMb2NhdGlvbiwgVG9rZW4sIFNlYXJjaFRyZWUsIE5VTUVSSUNfVFlQRSwgVmFsaWRhdGUsIE5VTUVSSUNfS0VZV09SRF9NQVBQSU5HUywgTUFSS1NcclxufSBmcm9tIFwiLi9pbnRlcmZhY2VzXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDaGFyYWN0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucz86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcclxuICAgICAgICBzdXBlcigpXHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coMzMzLCBUT0tFTl9UWVBFUyxUT0tFTl9UWVBFX01BUCk7XHJcbiAgICB9XHJcbiAgICB0b2tlbnM6IEFycmF5PFRva2VuPjtcclxuICAgIGN1cmx5X3N0YWNrOiBBcnJheTxhbnk+O1xyXG4gICAgVFlQRV9FTlVNUzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPjtcclxuICAgIFRPS0VOX1RZUEVfTUFQUEVSUzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPjtcclxuICAgIFBVTkNUVUFUT1JTX1RSRUU6IFNlYXJjaFRyZWU7XHJcbiAgICBQUklNQVJZX0VYUFJfU1RBUlRfUFVOQ1RVQVRPUlNfVFJFRTogU2VhcmNoVHJlZTtcclxuICAgIHB1YmxpYyB0b2tlbl9ob29rczogUmVjb3JkPHN0cmluZywgKHRva2VuOiBUb2tlbiwgdG9rZW5pemVyOiB0aGlzKSA9PiBUb2tlbj4gPSB7fTtcclxuICAgIHB1YmxpYyBsaW5lX251bWJlcjogbnVtYmVyO1xyXG4gICAgcHVibGljIGxpbmVfc3RhcnQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBzYXZlX2NvbW1lbnRzOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyBlcnJvcl9sb2dzOiBBcnJheTxhbnk+O1xyXG4gICAgcHVibGljIHRlcm1pbmF0b3Jfc3RhY2s6IEFycmF5PFZhbGlkYXRlPjtcclxuICAgIGVyciguLi5hcmdzOiBhbnkpIHtcclxuICAgICAgICAvL2RlYnVnZ2VyO1xyXG4gICAgICAgIHRoaXMuZXJyb3JfbG9ncy5wdXNoLmFwcGx5KHRoaXMuZXJyb3JfbG9ncywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGluaXQoaW5wdXQ6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMubGluZV9udW1iZXIgPSAwO1xyXG4gICAgICAgIHRoaXMubGluZV9zdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy5pbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5lcnJvcl9sb2dzID0gW107XHJcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcclxuICAgICAgICB0aGlzLnRlcm1pbmF0b3Jfc3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cmx5X3N0YWNrID0gW107XHJcbiAgICB9XHJcbiAgICB0b2tlbml6ZShpbnB1dDogc3RyaW5nKTogQXJyYXk8VG9rZW4+IHtcclxuICAgICAgICB0aGlzLmluaXQoaW5wdXQpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLm5leHRUb2tlbigpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnM7XHJcbiAgICB9XHJcbiAgICBuZXh0VG9rZW4oKSB7XHJcbiAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgICB0aGlzLmluZGV4IDwgdGhpcy5lbmRcclxuICAgICAgICAgICAgJiYgKFxyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdG9yX3N0YWNrLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy50b2tlbnMubGVuZ3RoID09PSAwXHJcbiAgICAgICAgICAgICAgICB8fCAhdGhpcy50ZXJtaW5hdG9yX3N0YWNrWzBdKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMuX25leHRUb2tlbigpO1xyXG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGxldCBob29rID0gdGhpcy50b2tlbl9ob29rc1t0b2tlbi50eXBlXTtcclxuICAgICAgICAgICAgICAgIGhvb2sgJiYgKHRva2VuID0gaG9vayh0b2tlbiwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2F2ZV9jb21tZW50cyB8fCB0b2tlbi50eXBlICE9PSB0aGlzLlRZUEVfRU5VTVMuQ29tbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmRleCA8IHRoaXMuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycih0aGlzLmNyZWF0ZVRva2VuKFwiZXJyb3JcIiwgW3RoaXMuaW5kZXgsICsrdGhpcy5pbmRleF0pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlVG9rZW4oXHJcbiAgICAgICAgdHlwZTogc3RyaW5nIHwgbnVtYmVyLFxyXG4gICAgICAgIHJhbmdlOiBbbnVtYmVyLCBudW1iZXJdLFxyXG4gICAgICAgIHZhbHVlOiBhbnkgPSB0aGlzLmlucHV0LnNsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSksXHJcbiAgICAgICAgc3RhcnQ6IFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVfbnVtYmVyLFxyXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlWzBdIC0gdGhpcy5saW5lX3N0YXJ0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbmQ6IFBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVfbnVtYmVyLFxyXG4gICAgICAgICAgICBjb2x1bW46IHJhbmdlWzFdIC0gdGhpcy5saW5lX3N0YXJ0XHJcbiAgICAgICAgfSxcclxuICAgICk6IFRva2VuIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgcmFuZ2UsXHJcbiAgICAgICAgICAgIGxvYzoge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQsIGVuZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIG1hdGNoKG5vZGU6IFNlYXJjaFRyZWUpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4LCBlbmQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgIGxldCBwcmV2X25vZGU6IFRva2VuO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcHJldl9ub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZSA9IHByZXZfbm9kZVt0aGlzLmlucHV0W2VuZCsrXV07XHJcbiAgICAgICAgfSB3aGlsZSAobm9kZSlcclxuICAgICAgICBsZXQgdGFyZ2V0OiBhbnkgPSBwcmV2X25vZGVbTUFSS1MuRU5EXTtcclxuICAgICAgICBpZiAodGFyZ2V0ICYmICh0YXJnZXQudHlwZSB8fCAodGFyZ2V0ID0gdGFyZ2V0KHRoaXMpKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGVuZCAtIDE7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2Nhbm5lciA/XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2Nhbm5lcih0aGlzLCBzdGFydCkgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb2tlbihcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLlRZUEVfRU5VTVNbdGFyZ2V0LnR5cGVdIHx8IHRhcmdldC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIFtzdGFydCwgdGhpcy5pbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmtleVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXh0SWRlbnRpZmllcigpOiBUb2tlbiB8IHZvaWQge1xyXG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmluSWRlbnRpZmllclN0YXJ0KCk7XHJcbiAgICAgICAgbGV0IHRva2VuOiBUb2tlbjtcclxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IGxlbmd0aCA9PT0gMSA/IHRoaXMuaW5wdXRbdGhpcy5pbmRleF0gOiB0aGlzLl92b2xhdGlsaXR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmluSWRlbnRpZmllclBhcnQoKTtcclxuICAgICAgICAgICAgfSB3aGlsZSAobGVuZ3RoID4gMClcclxuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLlRPS0VOX1RZUEVfTUFQUEVSU1tcIiBcIiArIHN0cl07XHJcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5jcmVhdGVUb2tlbihcclxuICAgICAgICAgICAgICAgIHRoaXMuVFlQRV9FTlVNU1t0eXBlIHx8IFwiSWRlbnRpZmllclwiXSxcclxuICAgICAgICAgICAgICAgIFtzdGFydCwgdGhpcy5pbmRleF1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5fdm9sYXRpbGl0eSA9IHN0cjtcclxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgc3RyLmxlbmd0aCAhPT0gdGhpcy5pbmRleCAtIHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycih0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnIodGhpcy5jcmVhdGVUb2tlbihcImVycm9yXCIsIFt0aGlzLmluZGV4LCB0aGlzLmluZGV4IC09IGxlbmd0aF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VuO1xyXG4gICAgfVxyXG4gICAgLypnZXQgbWF5YmVfcmVnZXgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5pbmRleF0gPT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgIGxldCBpc19wcmltYXJ5X2V4cHJfc3RhcnQgPSAodGhpcyBhcyBhbnkpLmlzX3ByaW1hcnlfZXhwcl9zdGFydDtcclxuICAgICAgICAgICAgcmV0dXJuIGlzX3ByaW1hcnlfZXhwcl9zdGFydCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IGlzX3ByaW1hcnlfZXhwcl9zdGFydFxyXG4gICAgICAgICAgICAgICAgOiAhdGhpcy50b2tlbnMubGVuZ3RoIHx8IHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09IFRPS0VOX1RZUEVfRU5VTVMuUHVuY3R1YXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9Ki9cclxuICAgIGdldCBpc19wcmltYXJ5X2V4cHJfc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbGFzdF9ub2RlOiBhbnkgPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3Rfbm9kZS50eXBlID09PSB0aGlzLlRZUEVfRU5VTVMuS2V5d29yZFxyXG4gICAgICAgICAgICAgICAgfHwgbGFzdF9ub2RlLnR5cGUgPT09IHRoaXMuVFlQRV9FTlVNUy5QdW5jdHVhdG9yICYmIGxhc3Rfbm9kZS5jb250ZW50ID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV4dFB1bmN0dWF0b3IoKTogVG9rZW4gfCB2b2lkIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCghdGhpcy5pc19wcmltYXJ5X2V4cHJfc3RhcnQgPyB0aGlzLlBVTkNUVUFUT1JTX1RSRUUgOiB0aGlzLlBSSU1BUllfRVhQUl9TVEFSVF9QVU5DVFVBVE9SU19UUkVFKTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0TnVtZXJpYygpOiBUb2tlbiB8IHZvaWQge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgbGV0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xyXG4gICAgICAgIGxldCBudW1iZXI6IG51bWJlcjtcclxuICAgICAgICBsZXQgZmxhZ3MgPSBOVU1FUklDX1RZUEUuREVDSU1BTDtcclxuICAgICAgICBsZXQgX2dldF90b2tlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdm9sYXRpbGl0eSA9IGZsYWdzICYgTlVNRVJJQ19UWVBFLk9DVEFMID8gKGZsYWdzICYgfk5VTUVSSUNfVFlQRS5ERUNJTUFMKSA6IGZsYWdzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0aGlzLlRZUEVfRU5VTVMuTnVtZXJpYywgW3N0YXJ0LCB0aGlzLmluZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBfZ2V0X2Vycm9yID0gKG1lc3NhZ2U6IHN0cmluZyA9IFwiSW52YWxpZCBvciB1bmV4cGVjdGVkIHRva2VuXCIpID0+IHtcclxuICAgICAgICAgICAgbGV0IGVycm9yID0gX2dldF90b2tlbigpO1xyXG4gICAgICAgICAgICBlcnJvci5lcnJvciA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGVycm9yLmlucHV0ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5pbmRleCArIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmVycihlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlY2ltYWxWYWx1ZSA9IHRoaXMuZGVjaW1hbFZhbHVlO1xyXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcclxuICAgICAgICAgICAgY2FzZSAweDJlOi8vXCIuXCJcclxuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsVmFsdWUodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSBOVU1FUklDX1RZUEUuRkxPQVQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAweDMwOi8vXCIwXCJcclxuICAgICAgICAgICAgICAgIGZsYWdzID0gTlVNRVJJQ19LRVlXT1JEX01BUFBJTkdTW3RoaXMuaW5wdXRbKyt0aGlzLmluZGV4XV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZsYWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gZGVjaW1hbFZhbHVlKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlciA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gTlVNRVJJQ19UWVBFLkRFQ0lNQUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciA8IDggJiYgKGZsYWdzIHw9IE5VTUVSSUNfVFlQRS5PQ1RBTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pbklkZW50aWZpZXJTdGFydCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzID0gTlVNRVJJQ19UWVBFLkRFQ0lNQUw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0X3Rva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRfZXJyb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsVmFsdWUoY2gpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZsYWdzICYgTlVNRVJJQ19UWVBFLkRFQ0lNQUwpIHtcclxuICAgICAgICAgICAgd2hpbGUgKChjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuaW5kZXgpKSkge1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyID0gZGVjaW1hbFZhbHVlKGNoKVxyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyIDwgOCB8fCAoZmxhZ3MgJj0gfk5VTUVSSUNfVFlQRS5PQ1RBTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDY1Oi8vXCJlXCJcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4NDU6Ly9cIkVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmbGFncyAmIChOVU1FUklDX1RZUEUuRSB8IE5VTUVSSUNfVFlQRS5PQ1RBTCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSBOVU1FUklDX1RZUEUuRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgyYiB8fCBjaCA9PT0gMHgyZCkgey8vKyAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dldF9lcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDJlOi8vXCIuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiAoTlVNRVJJQ19UWVBFLkZMT0FUIHwgTlVNRVJJQ19UWVBFLkUgfCBOVU1FUklDX1RZUEUuT0NUQUwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgfD0gTlVNRVJJQ19UWVBFLkZMT0FUO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbklkZW50aWZpZXJTdGFydCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9nZXRfZXJyb3IoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfZ2V0X3Rva2VuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRfdG9rZW4oKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdGVzdCA9IGZsYWdzICYgTlVNRVJJQ19UWVBFLkhFWFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmhleFZhbHVlIDogKFxyXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzICYgTlVNRVJJQ19UWVBFLkJJTkFSWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYmluYXJ5VmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm9jdGFsVmFsdWVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0ZXN0KHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuaW5kZXgpKSA+PSAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPiBzdGFydCArIDMgJiYgIXRoaXMuaW5JZGVudGlmaWVyU3RhcnQoKVxyXG4gICAgICAgICAgICAgICAgPyBfZ2V0X3Rva2VuKClcclxuICAgICAgICAgICAgICAgIDogX2dldF9lcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNraXBOb25zZW5zZXMoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgY3A6IG51bWJlcjsgdGhpcy5pbmRleCA8IHRoaXMuZW5kOyB0aGlzLmluZGV4KyspIHtcclxuICAgICAgICAgICAgY3AgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLmlzV2hpdGVTcGFjZShjcCk6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuaXNMaW5lVGVybWluYXRvcihjcCk6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lX251bWJlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZV9zdGFydCA9IHRoaXMuaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByaXZhdGUgX25leHRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5za2lwTm9uc2Vuc2VzKCkgJiYgKFxyXG4gICAgICAgICAgICB0aGlzLm5leHRJZGVudGlmaWVyKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5uZXh0TnVtZXJpYygpIHx8XHJcbiAgICAgICAgICAgIHRoaXMubmV4dFB1bmN0dWF0b3IoKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFhQTtBQUdBO0FBZEE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFhQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQVJBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBOzsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../js/tokenizer.ts\n");

/***/ })

}]);