(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[71],{

/***/ "./node_modules/@humanwhocodes/momoa/api.js":
/*!**************************************************!*\
  !*** ./node_modules/@humanwhocodes/momoa/api.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    // normalize line endings\n    text = text.replace(/\\n\\r?/g, \"\\n\");\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        while (token && token.value !== \"}\") {\n\n            // add the value into the array\n            members.push(parseProperty(token));\n\n            token = next();\n\n            if (token.value === \",\") {\n                token = next();\n            } else {\n                break;\n            }\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        while (token && token.value !== \"]\") {\n\n            // add the value into the array\n            elements.push(parseValue(token));\n\n            token = next();\n            \n            if (token.value === \",\") {\n                token = next();\n            } else {\n                break;\n            }\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGh1bWFud2hvY29kZXMvbW9tb2EvYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BodW1hbndob2NvZGVzL21vbW9hL2FwaS5qcz9jM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEpTT04gc3ludGF4IGhlbHBlcnNcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcmVkZWZpbmVkIFRva2Vuc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBMQlJBQ0tFVCA9IFwiW1wiO1xuY29uc3QgUkJSQUNLRVQgPSBcIl1cIjtcbmNvbnN0IExCUkFDRSA9IFwie1wiO1xuY29uc3QgUkJSQUNFID0gXCJ9XCI7XG5jb25zdCBDT0xPTiA9IFwiOlwiO1xuY29uc3QgQ09NTUEgPSBcIixcIjtcblxuY29uc3QgVFJVRSA9IFwidHJ1ZVwiO1xuY29uc3QgRkFMU0UgPSBcImZhbHNlXCI7XG5jb25zdCBOVUxMID0gXCJudWxsXCI7XG5cbmNvbnN0IFFVT1RFID0gXCJcXFwiXCI7XG5cbmNvbnN0IGV4cGVjdGVkS2V5d29yZHMgPSBuZXcgTWFwKFtcbiAgICBbXCJ0XCIsIFRSVUVdLFxuICAgIFtcImZcIiwgRkFMU0VdLFxuICAgIFtcIm5cIiwgTlVMTF1cbl0pO1xuXG5jb25zdCBlc2NhcGVUb0NoYXIgPSBuZXcgTWFwKFtcbiAgICBbUVVPVEUsIFFVT1RFXSxcbiAgICBbXCJcXFxcXCIsIFwiXFxcXFwiXSxcbiAgICBbXCIvXCIsIFwiL1wiXSxcbiAgICBbXCJiXCIsIFwiXFxiXCJdLFxuICAgIFtcIm5cIiwgXCJcXG5cIl0sXG4gICAgW1wiZlwiLCBcIlxcZlwiXSxcbiAgICBbXCJyXCIsIFwiXFxyXCJdLFxuICAgIFtcInRcIiwgXCJcXHRcIl1cbl0pO1xuXG5jb25zdCBrbm93blRva2VuVHlwZXMgPSBuZXcgTWFwKFtcbiAgICBbTEJSQUNLRVQsIFwiUHVuY3R1YXRvclwiXSxcbiAgICBbUkJSQUNLRVQsIFwiUHVuY3R1YXRvclwiXSxcbiAgICBbTEJSQUNFLCBcIlB1bmN0dWF0b3JcIl0sXG4gICAgW1JCUkFDRSwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtDT0xPTiwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtDT01NQSwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtUUlVFLCBcIkJvb2xlYW5cIl0sXG4gICAgW0ZBTFNFLCBcIkJvb2xlYW5cIl0sXG4gICAgW05VTEwsIFwiTnVsbFwiXVxuXSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBKU09OIHRva2VuaXphdGlvbi9wYXJzaW5nIGVycm9yc1xuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgYXR0YWNoZXMgbG9jYXRpb24gdG8gYW4gZXJyb3IuXG4gKi9cbmNsYXNzIEVycm9yV2l0aExvY2F0aW9uIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UgdG8gcmVwb3J0LiBcbiAgICAgKiBAcGFyYW0ge2ludH0gbG9jLmxpbmUgVGhlIGxpbmUgb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAqIEBwYXJhbSB7aW50fSBsb2MuY29sdW1uIFRoZSBjb2x1bW4gaW4gdGhlIGxpbmUgd2hlcmUgdGhlIGVycm9yIG9jY3VycnJlZC5cbiAgICAgKiBAcGFyYW0ge2ludH0gbG9jLmluZGV4IFRoZSBpbmRleCBpbiB0aGUgc3RyaW5nIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGxpbmUsIGNvbHVtbiwgaW5kZXggfSkge1xuICAgICAgICBzdXBlcihgJHsgbWVzc2FnZSB9ICgkeyBsaW5lIH06JHsgY29sdW1ufSlgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpbmUgb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICogQHByb3BlcnR5IGxpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2x1bW4gb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICogQHByb3BlcnR5IGNvbHVtblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICAgICAqIEB0eXBlIGludFxuICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiB1bmV4cGVjdGVkIGNoYXJhY3RlciBpcyBmb3VuZCBkdXJpbmcgdG9rZW5pemluZy5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZENoYXIgZXh0ZW5kcyBFcnJvcldpdGhMb2NhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1bmV4cGVjdGVkIFRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgZm91bmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvYyBUaGUgbG9jYXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBmb3VuZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodW5leHBlY3RlZCwgbG9jKSB7XG4gICAgICAgIHN1cGVyKGBVbmV4cGVjdGVkIGNoYXJhY3RlciAkeyB1bmV4cGVjdGVkIH0gZm91bmQuYCwgbG9jKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYW4gdW5leHBlY3RlZCB0b2tlbiBpcyBmb3VuZCBkdXJpbmcgcGFyc2luZy5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZFRva2VuIGV4dGVuZHMgRXJyb3JXaXRoTG9jYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgVGhlIGNoYXJhY3RlciB0aGF0IHdhcyBleHBlY3RlZC4gXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVuZXhwZWN0ZWQgVGhlIGNoYXJhY3RlciB0aGF0IHdhcyBmb3VuZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jIFRoZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGZvdW5kIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgICBzdXBlcihgVW5leHBlY3RlZCB0b2tlbiAkeyB0b2tlbi50eXBlIH0oJHsgdG9rZW4udmFsdWUgfSkgZm91bmQuYCwgdG9rZW4ubG9jLnN0YXJ0KTtcbiAgICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGVuZCBvZiBpbnB1dCBpcyBmb3VuZCB3aGVyZSBpdCBpc24ndCBleHBlY3RlZC5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZEVPRiBleHRlbmRzIEVycm9yV2l0aExvY2F0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvYyBUaGUgbG9jYXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBmb3VuZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jKSB7XG4gICAgICAgIHN1cGVyKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgZm91bmQuXCIsIGxvYyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSlNPTiB0b2tlbml6ZXJcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFFVT1RFJDEgPSBcIlxcXCJcIjtcbmNvbnN0IFNMQVNIID0gXCIvXCI7XG5jb25zdCBTVEFSID0gXCIqXCI7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBjb21tZW50czogZmFsc2UsXG4gICAgcmFuZ2VzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgICByZXR1cm4gL1tcXHNcXG5dLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGMpIHtcbiAgICByZXR1cm4gYyA+PSBcIjBcIiAmJiBjIDw9IFwiOVwiO1xufVxuXG5mdW5jdGlvbiBpc0hleERpZ2l0KGMpIHtcbiAgICByZXR1cm4gaXNEaWdpdChjKSB8fCAvW2EtZl0vaS50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aXZlRGlnaXQoYykge1xuICAgIHJldHVybiBjID49IFwiMVwiICYmIGMgPD0gXCI5XCI7XG59XG5cbmZ1bmN0aW9uIGlzS2V5d29yZFN0YXJ0KGMpIHtcbiAgICByZXR1cm4gL1t0Zm5dLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc051bWJlclN0YXJ0KGMpIHtcbiAgICByZXR1cm4gaXNEaWdpdChjKSB8fCBjID09PSBcIi5cIiB8fCBjID09PSBcIi1cIjtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWFpblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdG9rZW5zIHJlcHJlc2VudGluZyB0aGUgc291cmNlIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgc291cmNlIHRleHQgdG8gdG9rZW5pemUuXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9IEFuIGl0ZXJhdG9yIG92ZXIgdGhlIHRva2Vucy4gXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHRleHQsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG5cbiAgICAvLyBub3JtYWxpemUgbGluZSBlbmRpbmdzXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuXFxyPy9nLCBcIlxcblwiKTtcblxuICAgIGxldCBvZmZzZXQgPSAtMTtcbiAgICBsZXQgbGluZSA9IDE7XG4gICAgbGV0IGNvbHVtbiA9IDA7XG4gICAgbGV0IG5ld0xpbmUgPSBmYWxzZTtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUb2tlbih0b2tlblR5cGUsIHZhbHVlLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBzdGFydExvYy5vZmZzZXQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGxldCByYW5nZSA9IG9wdGlvbnMucmFuZ2VzID8ge1xuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydExvYy5vZmZzZXQsIGVuZE9mZnNldF1cbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR5cGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydExvYyxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZExvYyB8fCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0TG9jLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRMb2MuY29sdW1uICsgdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGVuZE9mZnNldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5yYW5nZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGxldCBjID0gdGV4dC5jaGFyQXQoKytvZmZzZXQpO1xuICAgIFxuICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIG5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHVtbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgIG5ld0xpbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IHNlZSBhIFxcciwganVzdCBpZ25vcmUgdXBjb21pbmcgXFxuXG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQob2Zmc2V0ICsgMSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICBjb2x1bW4sXG4gICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkS2V5d29yZChjKSB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBleHBlY3RlZCBrZXl3b3JkXG4gICAgICAgIGxldCB2YWx1ZSA9IGV4cGVjdGVkS2V5d29yZHMuZ2V0KGMpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCBhY3R1YWxseSBleGlzdHNcbiAgICAgICAgaWYgKHRleHQuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB2YWx1ZS5sZW5ndGgpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb2x1bW4gKz0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBjOiBuZXh0KCkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IHVuZXhwZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtqXSAhPT0gdGV4dC5jaGFyQXQob2Zmc2V0ICsgaikpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKG5leHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoYykge1xuICAgICAgICBsZXQgdmFsdWUgPSBjO1xuICAgICAgICBjID0gbmV4dCgpO1xuXG4gICAgICAgIHdoaWxlIChjICE9PSBRVU9URSQxKSB7XG5cbiAgICAgICAgICAgIC8vIGVzY2FwZXNcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVUb0NoYXIuaGFzKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcInVcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0hleERpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgKz0gYztcblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgYzogbmV4dCgpIH07XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiByZWFkTnVtYmVyKGMpIHtcblxuICAgICAgICBsZXQgdmFsdWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIE51bWJlciBtYXkgc3RhcnQgd2l0aCBhIG1pbnVzIGJ1dCBub3QgYSBwbHVzXG4gICAgICAgIGlmIChjID09PSBcIi1cIikge1xuXG4gICAgICAgICAgICB2YWx1ZSArPSBjO1xuXG4gICAgICAgICAgICBjID0gbmV4dCgpO1xuXG4gICAgICAgICAgICAvLyBOZXh0IGRpZ2l0IGNhbm5vdCBiZSB6ZXJvXG4gICAgICAgICAgICBpZiAoIWlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKGMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkZWNpbWFsIHBvaW50IG9yIG5vdGhpbmdcbiAgICAgICAgaWYgKGMgPT09IFwiMFwiKSB7XG5cbiAgICAgICAgICAgIHZhbHVlICs9IGM7XG5cbiAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNQb3NpdGl2ZURpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZChjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGlzRGlnaXQoYykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludCBtYXkgYmUgZm9sbG93ZWQgYnkgYW55IG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgaWYgKGMgPT09IFwiLlwiKSB7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICB9IHdoaWxlIChpc0RpZ2l0KGMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cG9uZW50IGlzIGFsd2F5cyBsYXN0XG4gICAgICAgIGlmIChjID09PSBcImVcIiB8fCBjID09PSBcIkVcIikge1xuXG4gICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAgICAgaWYgKGMgPT09IFwiK1wiIHx8IGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBpbiBlaXRoZXIgYSBzaW5nbGUtbGluZSBvciBtdWx0aS1saW5lIGNvbW1lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGMgVGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgY29tbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tbWVudCBzdHJpbmcuXG4gICAgICogQHRocm93cyB7VW5leHBlY3RlZENoYXJ9IHdoZW4gdGhlIGNvbW1lbnQgY2Fubm90IGJlIHJlYWQuXG4gICAgICogQHRocm93cyB7VW5leHBlY3RlZEVPRn0gd2hlbiBFT0YgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIGNvbW1lbnQgaXNcbiAgICAgKiAgICAgIGZpbmFsaXplZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29tbWVudChjKSB7XG5cbiAgICAgICAgbGV0IHZhbHVlID0gYztcblxuICAgICAgICAvLyBuZXh0IGNoYXJhY3RlciBkZXRlcm1pbmVzIHNpbmdsZS0gb3IgbXVsdGktbGluZVxuICAgICAgICBjID0gbmV4dCgpO1xuXG4gICAgICAgIC8vIHNpbmdsZS1saW5lIGNvbW1lbnRzXG4gICAgICAgIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYyAmJiBjICE9PSBcIlxcclwiICYmIGMgIT09IFwiXFxuXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbXVsdGktbGluZSBjb21tZW50c1xuICAgICAgICBpZiAoYyA9PT0gU1RBUikge1xuXG4gICAgICAgICAgICB3aGlsZSAoYykge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlbmQgb2YgY29tbWVudFxuICAgICAgICAgICAgICAgIGlmIChjID09PSBTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2VuZCBvZiBjb21tZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBTTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBzaW5nbGUtbGluZSBjb21tZW50IGZ1bmN0aW9uYWxpdHkgY3VlcyB1cCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIG5leHQgY2hhcmFjdGVyLCBzbyB3ZSBkbyB0aGUgc2FtZSBoZXJlIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzcGxpdHRpbmcgbG9naWMgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgYyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bmV4cGVjdGVkRU9GKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3ZlIG1hZGUgaXQgaGVyZSwgdGhlcmUncyBhbiBpbnZhbGlkIGNoYXJhY3RlclxuICAgICAgICB1bmV4cGVjdGVkKGMpOyAgICAgICAgXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgdGhyb3dpbmcgdW5leHBlY3RlZCBjaGFyYWN0ZXIgZXJyb3JzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjIFRoZSB1bmV4cGVjdGVkIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKiBAdGhyb3dzIHtVbmV4cGVjdGVkQ2hhcn0gYWx3YXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoYykge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENoYXIoYywgbG9jYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciB0aHJvd2luZyB1bmV4cGVjdGVkIEVPRiBlcnJvcnMuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICogQHRocm93cyB7VW5leHBlY3RlZEVPRn0gYWx3YXlzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXhwZWN0ZWRFT0YoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkRU9GKGxvY2F0ZSgpKTtcbiAgICB9XG5cbiAgICBsZXQgYyA9IG5leHQoKTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCB0ZXh0Lmxlbmd0aCkge1xuXG4gICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb2NhdGUoKTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgZWFzeSBjYXNlXG4gICAgICAgIGlmIChrbm93blRva2VuVHlwZXMuaGFzKGMpKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihrbm93blRva2VuVHlwZXMuZ2V0KGMpLCBjLCBzdGFydCkpO1xuICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmRTdGFydChjKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZEtleXdvcmQoYyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBjID0gcmVzdWx0LmM7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihrbm93blRva2VuVHlwZXMuZ2V0KHZhbHVlKSwgdmFsdWUsIHN0YXJ0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXJTdGFydChjKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZE51bWJlcihjKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGMgPSByZXN1bHQuYztcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFwiTnVtYmVyXCIsIHZhbHVlLCBzdGFydCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFFVT1RFJDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRTdHJpbmcoYyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBjID0gcmVzdWx0LmM7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihcIlN0cmluZ1wiLCB2YWx1ZSwgc3RhcnQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBTTEFTSCAmJiBvcHRpb25zLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkQ29tbWVudChjKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGMgPSByZXN1bHQuYztcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKHZhbHVlLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IFwiTGluZUNvbW1lbnRcIiA6IFwiQmxvY2tDb21tZW50XCIsIHZhbHVlLCBzdGFydCwgbG9jYXRlKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoYyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuXG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBNb21vYSBKU09OIEFTVCB0eXBlc1xuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cbmNvbnN0IHR5cGVzID0ge1xuICAgIGRvY3VtZW50KGJvZHksIHBhcnRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRG9jdW1lbnRcIixcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3RyaW5nKHZhbHVlLCBwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlN0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbnVtYmVyKHZhbHVlLCBwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk51bWJlclwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYm9vbGVhbih2YWx1ZSwgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJCb29sZWFuXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBudWxsKHBhcnRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTnVsbFwiLFxuICAgICAgICAgICAgdmFsdWU6IFwibnVsbFwiLFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFycmF5KGVsZW1lbnRzLCBwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICAgIC4uLnBhcnRzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3QobWVtYmVycywgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJPYmplY3RcIixcbiAgICAgICAgICAgIG1lbWJlcnMsXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbWVtYmVyKG5hbWUsIHZhbHVlLCBwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk1lbWJlclwiLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuXG59O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSlNPTiBwYXJzZXJcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyQxID0ge1xuICAgIHRva2VuczogZmFsc2UsXG4gICAgY29tbWVudHM6IGZhbHNlLFxuICAgIHJhbmdlczogZmFsc2Vcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBKU09OLWVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZywgaW50ZXJwcmV0aW5nIGVhY2hcbiAqIGVzY2FwZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuIFRoZSBzdHJpbmcgdG9rZW4gdG8gY29udmVydCBpbnRvIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIEphdmFTY3JpcHQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh0b2tlbikge1xuICAgIFxuICAgIC8vIHNsaWNlIG9mZiB0aGUgcXVvdGF0aW9uIG1hcmtzXG4gICAgbGV0IHZhbHVlID0gdG9rZW4udmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGxldCBlc2NhcGVJbmRleCA9IHZhbHVlLmluZGV4T2YoXCJcXFxcXCIpO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuXG4gICAgLy8gV2hpbGUgdGhlcmUgYXJlIGVzY2FwZXMsIGludGVycHJldCB0aGVtIHRvIGJ1aWxkIHVwIHRoZSByZXN1bHRcbiAgICB3aGlsZSAoZXNjYXBlSW5kZXggPj0gMCkge1xuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgdGV4dCB0aGF0IGhhcHBlbmVkIGJlZm9yZSB0aGUgZXNjYXBlXG4gICAgICAgIHJlc3VsdCArPSB2YWx1ZS5zbGljZShsYXN0SW5kZXgsIGVzY2FwZUluZGV4KTtcblxuICAgICAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciBpbW1lZGlhdGVseSBhZnRlciB0aGUgXFxcbiAgICAgICAgY29uc3QgZXNjYXBlQ2hhciA9IHZhbHVlLmNoYXJBdChlc2NhcGVJbmRleCArIDEpO1xuICAgICAgICBcbiAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBub24tVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzIGZpcnN0XG4gICAgICAgIGlmIChlc2NhcGVUb0NoYXIuaGFzKGVzY2FwZUNoYXIpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlVG9DaGFyLmdldChlc2NhcGVDaGFyKTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGVzY2FwZUluZGV4ICsgMjtcbiAgICAgICAgfSBlbHNlIGlmIChlc2NhcGVDaGFyID09PSBcInVcIikge1xuICAgICAgICAgICAgY29uc3QgaGV4Q29kZSA9IHZhbHVlLnNsaWNlKGVzY2FwZUluZGV4ICsgMiwgZXNjYXBlSW5kZXggKyA2KTtcbiAgICAgICAgICAgIGlmIChoZXhDb2RlLmxlbmd0aCA8IDQgfHwgL1teMC05YS1mXS9pLnRlc3QoaGV4Q29kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIFxcXFx1JHsgaGV4Q29kZX0uYCxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdG9rZW4ubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRva2VuLmxvYy5zdGFydC5jb2x1bW4gKyBlc2NhcGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdG9rZW4ubG9jLnN0YXJ0Lm9mZnNldCArIGVzY2FwZUluZGV4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXhDb2RlLCAxNikpO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gZXNjYXBlSW5kZXggKyA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aExvY2F0aW9uKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIGVzY2FwZSBcXFxcJHsgZXNjYXBlQ2hhciB9LmAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiB0b2tlbi5sb2Muc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0b2tlbi5sb2Muc3RhcnQuY29sdW1uICsgZXNjYXBlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdG9rZW4ubG9jLnN0YXJ0Lm9mZnNldCArIGVzY2FwZUluZGV4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIGVzY2FwZUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIlxcXFxcIiwgbGFzdEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgc3RyaW5nIHZhbHVlXG4gICAgcmVzdWx0ICs9IHZhbHVlLnNsaWNlKGxhc3RJbmRleCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIEphdmFTY3JpcHQgdmFsdWUgcmVwcmVzZW50ZWQgYnkgYSBKU09OIHRva2VuLlxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW4gVGhlIEpTT04gdG9rZW4gdG8gZ2V0IGEgdmFsdWUgZm9yLlxuICogQHJldHVybnMgeyp9IEEgbnVtYmVyLCBzdHJpbmcsIGJvb2xlYW4sIG9yIGBudWxsYC4gXG4gKi9cbmZ1bmN0aW9uIGdldExpdGVyYWxWYWx1ZSh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIFxuICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgcmV0dXJuIE51bWJlcih0b2tlbi52YWx1ZSk7XG5cbiAgICBjYXNlIFwiTnVsbFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIGdldFN0cmluZ1ZhbHVlKHRva2VuKTtcbiAgICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE1haW4gRnVuY3Rpb25cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50b2tlbnM9ZmFsc2VdIERldGVybWluZXMgaWYgdG9rZW5zIGFyZSByZXR1cm5lZCBpblxuICogICAgICB0aGUgQVNULiBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29tbWVudHM9ZmFsc2VdIERldGVybWluZXMgaWYgY29tbWVudHMgYXJlIGFsbG93ZWRcbiAqICAgICAgaW4gdGhlIEpTT04uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJhbmdlcz1mYWxzZV0gRGV0ZXJtaW5lcyBpZiByYW5nZXMgd2lsbCBiZSByZXR1cm5lZFxuICogICAgICBpbiBhZGRpdGlvbiB0byBgbG9jYCBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIEFTVCByZXByZXNlbnRpbmcgdGhlIHBhcnNlZCBKU09OLlxuICogQHRocm93cyB7RXJyb3J9IFdoZW4gdGhlcmUgaXMgYSBwYXJzaW5nIGVycm9yLiBcbiAqL1xuZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5ERUZBVUxUX09QVElPTlMkMSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUodGV4dCwge1xuICAgICAgICBjb21tZW50czogISFvcHRpb25zLmNvbW1lbnRzLFxuICAgICAgICByYW5nZXM6ICEhb3B0aW9ucy5yYW5nZXNcbiAgICB9KTtcbiAgICBsZXQgdG9rZW5JbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0Tm9Db21tZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vuc1t0b2tlbkluZGV4KytdO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0U2tpcENvbW1lbnRzKCkge1xuICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0b2tlbnNbdG9rZW5JbmRleCsrXTtcbiAgICAgICAgaWYgKG5leHRUb2tlbiAmJiBuZXh0VG9rZW4udHlwZS5lbmRzV2l0aChcIkNvbW1lbnRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0U2tpcENvbW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dFRva2VuO1xuXG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIGNvcnJlY3Qgd2F5IHRvIGV2YWx1YXRlIHRva2VucyBiYXNlZCBvbiBwcmVzZW5jZSBvZiBjb21tZW50c1xuICAgIGNvbnN0IG5leHQgPSBvcHRpb25zLmNvbW1lbnRzID8gbmV4dFNraXBDb21tZW50cyA6IG5leHROb0NvbW1lbnRzO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0VG9rZW5WYWx1ZSh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0VG9rZW5UeXBlKHRva2VuLCB0eXBlKSB7XG4gICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJhbmdlcyA/IHtcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQub2Zmc2V0LCBlbmQub2Zmc2V0XVxuICAgICAgICB9IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpdGVyYWxOb2RlKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gY3JlYXRlUmFuZ2UodG9rZW4ubG9jLnN0YXJ0LCB0b2tlbi5sb2MuZW5kKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRMaXRlcmFsVmFsdWUodG9rZW4pLFxuICAgICAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udG9rZW4ubG9jLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udG9rZW4ubG9jLmVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5yYW5nZVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eSh0b2tlbikge1xuICAgICAgICBhc3NlcnRUb2tlblR5cGUodG9rZW4sIFwiU3RyaW5nXCIpO1xuICAgICAgICBjb25zdCBuYW1lID0gY3JlYXRlTGl0ZXJhbE5vZGUodG9rZW4pO1xuXG4gICAgICAgIHRva2VuID0gbmV4dCgpO1xuICAgICAgICBhc3NlcnRUb2tlblZhbHVlKHRva2VuLCBcIjpcIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VWYWx1ZSgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IGNyZWF0ZVJhbmdlKG5hbWUubG9jLnN0YXJ0LCB2YWx1ZS5sb2MuZW5kKTtcblxuICAgICAgICByZXR1cm4gdHlwZXMubWVtYmVyKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5uYW1lLmxvYy5zdGFydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLmxvYy5lbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3QoZmlyc3RUb2tlbikge1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0b2tlbiBtdXN0IGJlIGEgeyBvciBlbHNlIGl0J3MgYW4gZXJyb3JcbiAgICAgICAgYXNzZXJ0VG9rZW5WYWx1ZShmaXJzdFRva2VuLCBcIntcIik7XG5cbiAgICAgICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgICAgICBsZXQgdG9rZW4gPSBuZXh0KCk7XG5cbiAgICAgICAgd2hpbGUgKHRva2VuICYmIHRva2VuLnZhbHVlICE9PSBcIn1cIikge1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIGludG8gdGhlIGFycmF5XG4gICAgICAgICAgICBtZW1iZXJzLnB1c2gocGFyc2VQcm9wZXJ0eSh0b2tlbikpO1xuXG4gICAgICAgICAgICB0b2tlbiA9IG5leHQoKTtcblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSBcIixcIikge1xuICAgICAgICAgICAgICAgIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydFRva2VuVmFsdWUodG9rZW4sIFwifVwiKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBjcmVhdGVSYW5nZShmaXJzdFRva2VuLmxvYy5zdGFydCwgdG9rZW4ubG9jLmVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzLm9iamVjdChtZW1iZXJzLCB7XG4gICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5maXJzdFRva2VuLmxvYy5zdGFydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRva2VuLmxvYy5lbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycmF5KGZpcnN0VG9rZW4pIHtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdG9rZW4gbXVzdCBiZSBhIFsgb3IgZWxzZSBpdCdzIGFuIGVycm9yXG4gICAgICAgIGFzc2VydFRva2VuVmFsdWUoZmlyc3RUb2tlbiwgXCJbXCIpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGxldCB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICh0b2tlbiAmJiB0b2tlbi52YWx1ZSAhPT0gXCJdXCIpIHtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSB2YWx1ZSBpbnRvIHRoZSBhcnJheVxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVZhbHVlKHRva2VuKSk7XG5cbiAgICAgICAgICAgIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0VG9rZW5WYWx1ZSh0b2tlbiwgXCJdXCIpO1xuICAgICAgICBjb25zdCByYW5nZSA9IGNyZWF0ZVJhbmdlKGZpcnN0VG9rZW4ubG9jLnN0YXJ0LCB0b2tlbi5sb2MuZW5kKTtcblxuICAgICAgICByZXR1cm4gdHlwZXMuYXJyYXkoZWxlbWVudHMsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQXJyYXlcIixcbiAgICAgICAgICAgIGVsZW1lbnRzLFxuICAgICAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmlyc3RUb2tlbi5sb2Muc3RhcnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAuLi50b2tlbi5sb2MuZW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnJhbmdlXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUodG9rZW4pIHtcblxuICAgICAgICB0b2tlbiA9IHRva2VuIHx8IG5leHQoKTtcbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJCb29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgY2FzZSBcIk51bGxcIjpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXRlcmFsTm9kZSh0b2tlbik7XG5cbiAgICAgICAgY2FzZSBcIlB1bmN0dWF0b3JcIjpcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QodG9rZW4pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheSh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKmZhbGxzIHRocm91Z2gqL1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgXG4gICAgY29uc3QgZG9jQm9keSA9IHBhcnNlVmFsdWUoKTtcbiAgICBcbiAgICBjb25zdCB1bmV4cGVjdGVkVG9rZW4gPSBuZXh0KCk7XG4gICAgaWYgKHVuZXhwZWN0ZWRUb2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFRva2VuKHVuZXhwZWN0ZWRUb2tlbik7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGNvbnN0IGRvY1BhcnRzID0ge1xuICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgLi4uZG9jQm9keS5sb2MuZW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuXG4gICAgaWYgKG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgIGRvY1BhcnRzLnRva2VucyA9IHRva2VucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgZG9jUGFydHMucmFuZ2UgPSBjcmVhdGVSYW5nZShkb2NQYXJ0cy5sb2Muc3RhcnQsIGRvY1BhcnRzLmxvYy5lbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlcy5kb2N1bWVudChkb2NCb2R5LCBkb2NQYXJ0cyk7XG5cbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYXZlcnNhbCBhcHByb2FjaGVzIGZvciBNb21vYSBKU09OIEFTVC5cbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEYXRhXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGNoaWxkS2V5cyA9IG5ldyBNYXAoW1xuICAgIFtcIkRvY3VtZW50XCIsIFtcImJvZHlcIl1dLFxuICAgIFtcIk9iamVjdFwiLCBbXCJtZW1iZXJzXCJdXSxcbiAgICBbXCJNZW1iZXJcIiwgW1wibmFtZVwiLCBcInZhbHVlXCJdXSxcbiAgICBbXCJBcnJheVwiLCBbXCJlbGVtZW50c1wiXV0sXG4gICAgW1wiU3RyaW5nXCIsIFtdXSxcbiAgICBbXCJOdW1iZXJcIiwgW11dLFxuICAgIFtcIkJvb2xlYW5cIiwgW11dLFxuICAgIFtcIk51bGxcIiwgW11dXG5dKTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIGlmIG5vdC4gXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBBU1Qgbm9kZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgbm9kZSwgZmFsc2UgaWYgbm90LiBcbiAqL1xuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiAodHlwZW9mIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVHJhdmVyc2VzIGFuIEFTVCBmcm9tIHRoZSBnaXZlbiBub2RlLlxuICogQHBhcmFtIHtOb2RlfSByb290IFRoZSBub2RlIHRvIHRyYXZlcnNlIGZyb20gXG4gKiBAcGFyYW0ge09iamVjdH0gdmlzaXRvciBBbiBvYmplY3Qgd2l0aCBhbiBgZW50ZXJgIGFuZCBgZXhpdGAgbWV0aG9kLiBcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgdmlzaXRzIGEgbm9kZS5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gdmlzaXQuXG4gICAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCBvZiB0aGUgbm9kZSB0byB2aXNpdC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2aXNpdE5vZGUobm9kZSwgcGFyZW50KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpdG9yLmVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZpc2l0b3IuZW50ZXIobm9kZSwgcGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNoaWxkS2V5cy5nZXQobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleV07XG5cbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChjaGlsZCA9PiB2aXNpdE5vZGUoY2hpbGQsIG5vZGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXROb2RlKHZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZpc2l0b3IuZXhpdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2aXNpdG9yLmV4aXQobm9kZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZpc2l0Tm9kZShyb290KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdpdmVuIEFTVC5cbiAqIEBwYXJhbSB7Tm9kZX0gcm9vdCBUaGUgcm9vdCBBU1Qgbm9kZSB0byB0cmF2ZXJzZS4gXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXSBBIGZpbHRlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggc3RlcHMgdG9cbiAqICAgICAgcmV0dXJuO1xuICogQHJldHVybnMge0l0ZXJhdG9yfSBBbiBpdGVyYXRvciBvdmVyIHRoZSBBU1QuICBcbiAqL1xuZnVuY3Rpb24gaXRlcmF0b3Iocm9vdCwgZmlsdGVyID0gKCkgPT4gdHJ1ZSkge1xuXG4gICAgY29uc3QgdHJhdmVyc2FsID0gW107XG5cbiAgICB0cmF2ZXJzZShyb290LCB7XG4gICAgICAgIGVudGVyKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgdHJhdmVyc2FsLnB1c2goeyBub2RlLCBwYXJlbnQsIHBoYXNlOiBcImVudGVyXCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGV4aXQobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwucHVzaCh7IG5vZGUsIHBhcmVudCwgcGhhc2U6IFwiZXhpdFwiIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhdmVyc2FsLmZpbHRlcihmaWx0ZXIpLnZhbHVlcygpO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXZhbHVhdG9yIGZvciBNb21vYSBBU1QuXG4gKiBAYXV0aG9yIE5pY2hvbGFzIEMuIFpha2FzXG4gKi9cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEV2YWx1YXRlcyBhIE1vbW9hIEFTVCBub2RlIGludG8gYSBKYXZhU2NyaXB0IHZhbHVlLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGludGVycGV0LlxuICogQHJldHVybnMgeyp9IFRoZSBKYXZhU2NyaXB0IHZhbHVlIGZvciB0aGUgbm9kZS4gXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG5cbiAgICBjYXNlIFwiTnVsbFwiOlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgXCJBcnJheVwiOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5tYXAoZXZhbHVhdGUpO1xuXG4gICAgY2FzZSBcIk9iamVjdFwiOiB7XG5cbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XG5cbiAgICAgICAgbm9kZS5tZW1iZXJzLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgICAgICAgIG9iamVjdFtldmFsdWF0ZShtZW1iZXIubmFtZSldID0gZXZhbHVhdGUobWVtYmVyLnZhbHVlKTtcbiAgICAgICAgfSk7ICAgIFxuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSAgICBcblxuICAgIGNhc2UgXCJEb2N1bWVudFwiOlxuICAgICAgICByZXR1cm4gZXZhbHVhdGUobm9kZS5ib2R5KTtcblxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXZhbHVhdGUgb2JqZWN0IHByb3BlcnR5IG91dHNpZGUgb2YgYW4gb2JqZWN0LlwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGUgJHsgbm9kZS50eXBlIH0uYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUHJpbnRlciBmb3IgTW9tb2EgQVNULlxuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIE1vbW9hIEFTVCBiYWNrIGludG8gYSBKU09OIHN0cmluZy5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBwcmludC5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5pbmRlbnQ9MF0gVGhlIG51bWJlciBvZiBzcGFjZXMgdG8gaW5kZW50IGVhY2ggbGluZS4gSWZcbiAqICAgICAgZ3JlYXRlciB0aGFuIDAsIHRoZW4gbmV3bGluZXMgYW5kIGluZGVudHMgd2lsbCBiZSBhZGRlZCB0byBvdXRwdXQuIFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIEFTVC5cbiAqL1xuZnVuY3Rpb24gcHJpbnQobm9kZSwgeyBpbmRlbnQgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBpbmRlbnQpO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRmlsZSBkZWZpbmluZyB0aGUgaW50ZXJmYWNlIG9mIHRoZSBwYWNrYWdlLlxuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcbmV4cG9ydHMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucHJpbnQgPSBwcmludDtcbmV4cG9ydHMudG9rZW5pemUgPSB0b2tlbml6ZTtcbmV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@humanwhocodes/momoa/api.js\n");

/***/ })

}]);