(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[82],{

/***/ "./node_modules/luaparse/luaparse.js":
/*!*******************************************!*\
  !*** ./node_modules/luaparse/luaparse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global === 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (true) {\n    // defined as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ {}\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = '0.2.1';\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    return {\n        type: NumericLiteral\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part i optional.\n    if ('.' === input.charAt(index)) {\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return (digit + fraction) * binaryExponent;\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    if ('.' === input.charAt(index)) {\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n    // Exponent part is optional.\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return parseFloat(input.slice(tokenStart, index));\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets ≥ 128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = Array.apply(null, scopes[scopeDepth++]);\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVhcGFyc2UvbHVhcGFyc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbHVhcGFyc2UvbHVhcGFyc2UuanM/OTFhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgZXhwb3J0czp0cnVlLCBtb2R1bGU6dHJ1ZSwgcmVxdWlyZTp0cnVlLCBkZWZpbmU6dHJ1ZSwgZ2xvYmFsOnRydWUgKi9cblxuKGZ1bmN0aW9uIChyb290LCBuYW1lLCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogdHJ1ZVxuICAgICAgLCAnb2JqZWN0JzogdHJ1ZVxuICAgIH1cbiAgICAvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2BcbiAgICAsIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0c1xuICAgIC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG4gICAgLCBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlXG4gICAgLy8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSwgYW5kXG4gICAgLy8gdXNlIGl0IGFzIGB3aW5kb3dgXG4gICAgLCBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWxcbiAgICAvLyBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2BcbiAgICAsIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG4gICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uXG4gIC8vIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGRlZmluZS5hbWQpIHtcbiAgICAvLyBkZWZpbmVkIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICAvLyBJbiBjYXNlIHRoZSBzb3VyY2UgaGFzIGJlZW4gcHJvY2Vzc2VkIGFuZCB3cmFwcGVkIGluIGEgZGVmaW5lIG1vZHVsZSB1c2VcbiAgICAvLyB0aGUgc3VwcGxpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgICBpZiAoZnJlZUV4cG9ydHMgJiYgbW9kdWxlRXhwb3J0cykgZmFjdG9yeShmcmVlTW9kdWxlLmV4cG9ydHMpO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuXG4gIC8vIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobW9kdWxlRXhwb3J0cykgZmFjdG9yeShmcmVlTW9kdWxlLmV4cG9ydHMpO1xuICAgIC8vIGluIFJpbmdvSlMgdjAuNy4wLVxuICAgIGVsc2UgZmFjdG9yeShmcmVlRXhwb3J0cyk7XG4gIH1cbiAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gIGVsc2Uge1xuICAgIGZhY3RvcnkoKHJvb3RbbmFtZV0gPSB7fSkpO1xuICB9XG59KHRoaXMsICdsdWFwYXJzZScsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBleHBvcnRzLnZlcnNpb24gPSAnMC4yLjEnO1xuXG4gIHZhciBpbnB1dCwgb3B0aW9ucywgbGVuZ3RoLCBmZWF0dXJlcywgZW5jb2RpbmdNb2RlO1xuXG4gIC8vIE9wdGlvbnMgY2FuIGJlIHNldCBlaXRoZXIgZ2xvYmFsbHkgb24gdGhlIHBhcnNlciBvYmplY3QgdGhyb3VnaFxuICAvLyBkZWZhdWx0T3B0aW9ucywgb3IgZHVyaW5nIHRoZSBwYXJzZSBjYWxsLlxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIEV4cGxpY2l0bHkgdGVsbCB0aGUgcGFyc2VyIHdoZW4gdGhlIGlucHV0IGVuZHMuXG4gICAgICB3YWl0OiBmYWxzZVxuICAgIC8vIFN0b3JlIGNvbW1lbnRzIGFzIGFuIGFycmF5IGluIHRoZSBjaHVuayBvYmplY3QuXG4gICAgLCBjb21tZW50czogdHJ1ZVxuICAgIC8vIFRyYWNrIGlkZW50aWZpZXIgc2NvcGVzIGJ5IGFkZGluZyBhbiBpc0xvY2FsIGF0dHJpYnV0ZSB0byBlYWNoXG4gICAgLy8gaWRlbnRpZmllci1ub2RlLlxuICAgICwgc2NvcGU6IGZhbHNlXG4gICAgLy8gU3RvcmUgbG9jYXRpb24gaW5mb3JtYXRpb24gb24gZWFjaCBzeW50YXggbm9kZSBhc1xuICAgIC8vIGBsb2M6IHsgc3RhcnQ6IHsgbGluZSwgY29sdW1uIH0sIGVuZDogeyBsaW5lLCBjb2x1bW4gfSB9YC5cbiAgICAsIGxvY2F0aW9uczogZmFsc2VcbiAgICAvLyBTdG9yZSB0aGUgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgbG9jYXRpb25zIG9uIGVhY2ggc3ludGF4IG5vZGUgYXNcbiAgICAvLyBgcmFuZ2U6IFtzdGFydCwgZW5kXWAuXG4gICAgLCByYW5nZXM6IGZhbHNlXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIHN5bnRheCBub2RlIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgICAvLyBUaGUgbm9kZSB3aGljaCBoYXMgYmVlbiBjcmVhdGVkIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBvbmx5IHBhcmFtZXRlci5cbiAgICAsIG9uQ3JlYXRlTm9kZTogbnVsbFxuICAgIC8vIEEgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBuZXcgc2NvcGUgaXMgY3JlYXRlZC5cbiAgICAsIG9uQ3JlYXRlU2NvcGU6IG51bGxcbiAgICAvLyBBIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBjdXJyZW50IHNjb3BlIGlzIGRlc3Ryb3llZC5cbiAgICAsIG9uRGVzdHJveVNjb3BlOiBudWxsXG4gICAgLy8gQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIGxvY2FsIHZhcmlhYmxlIGlzIGRlY2xhcmVkIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgIC8vIFRoZSB2YXJpYWJsZSdzIG5hbWUgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyXG4gICAgLCBvbkxvY2FsRGVjbGFyYXRpb246IG51bGxcbiAgICAvLyBUaGUgdmVyc2lvbiBvZiBMdWEgdGFyZ2V0ZWQgYnkgdGhlIHBhcnNlciAoc3RyaW5nOyBhbGxvd2VkIHZhbHVlcyBhcmVcbiAgICAvLyAnNS4xJywgJzUuMicsICc1LjMnKS5cbiAgICAsIGx1YVZlcnNpb246ICc1LjEnXG4gICAgLy8gRW5jb2RpbmcgbW9kZTogaG93IHRvIGludGVycHJldCBjb2RlIHVuaXRzIGhpZ2hlciB0aGFuIFUrMDA3RiBpbiBpbnB1dFxuICAgICwgZW5jb2RpbmdNb2RlOiAnbm9uZSdcbiAgfTtcblxuICBmdW5jdGlvbiBlbmNvZGVVVEY4KGNvZGVwb2ludCwgaGlnaE1hc2spIHtcbiAgICBoaWdoTWFzayA9IGhpZ2hNYXNrIHx8IDA7XG5cbiAgICBpZiAoY29kZXBvaW50IDwgMHg4MCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZXBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVwb2ludCA8IDB4ODAwKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgaGlnaE1hc2sgfCAweGMwIHwgIChjb2RlcG9pbnQgPj4gIDYpICAgICAgICAsXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICggY29kZXBvaW50ICAgICAgICAmIDB4M2YpXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZXBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIGhpZ2hNYXNrIHwgMHhlMCB8ICAoY29kZXBvaW50ID4+IDEyKSAgICAgICAgLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoKGNvZGVwb2ludCA+PiAgNikgJiAweDNmKSxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKCBjb2RlcG9pbnQgICAgICAgICYgMHgzZilcbiAgICAgICk7XG4gICAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChjb2RlcG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIGhpZ2hNYXNrIHwgMHhmMCB8ICAoY29kZXBvaW50ID4+IDE4KSAgICAgICAgLFxuICAgICAgICBoaWdoTWFzayB8IDB4ODAgfCAoKGNvZGVwb2ludCA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgaGlnaE1hc2sgfCAweDgwIHwgKChjb2RlcG9pbnQgPj4gIDYpICYgMHgzZiksXG4gICAgICAgIGhpZ2hNYXNrIHwgMHg4MCB8ICggY29kZXBvaW50ICAgICAgICAmIDB4M2YpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBMdWEgNS40IGFsbG93cyB1cCB0byBzaXgtYnl0ZSBzZXF1ZW5jZXMsIGFzIGluIFVURi04OjE5OTNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvSGV4KG51bSwgZGlnaXRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bS50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBkaWdpdHMpXG4gICAgICByZXN1bHQgPSAnMCcgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2hhcnMocngpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcbiAgICAgIHZhciBtID0gcnguZXhlYyhzKTtcbiAgICAgIGlmICghbSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuaW52YWxpZENvZGVVbml0LCB0b0hleChtWzBdLmNoYXJDb2RlQXQoMCksIDQpLnRvVXBwZXJDYXNlKCkpO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5jb2RpbmdNb2RlcyA9IHtcbiAgICAvLyBgcHNldWRvLWxhdGluMWAgZW5jb2RpbmcgbW9kZTogYXNzdW1lIHRoZSBpbnB1dCB3YXMgZGVjb2RlZCB3aXRoIHRoZSBsYXRpbjEgZW5jb2RpbmdcbiAgICAvLyBXQVJOSU5HOiBsYXRpbjEgZG9lcyAqKk5PVCoqIG1lYW4gY3AxMjUyIGhlcmUgbGlrZSBpbiB0aGUgYm9uZS1oZWFkZWQgV0hBVFdHIHN0YW5kYXJkO1xuICAgIC8vIGl0IG1lYW5zIHRydWUgSVNPL0lFQyA4ODU5LTEgaWRlbnRpdHktbWFwcGVkIHRvIEJhc2ljIExhdGluIGFuZCBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2tzXG4gICAgJ3BzZXVkby1sYXRpbjEnOiB7XG4gICAgICBmaXh1cDogY2hlY2tDaGFycygvW15cXHgwMC1cXHhmZl0vKSxcbiAgICAgIGVuY29kZUJ5dGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZW5jb2RlVVRGODogZnVuY3Rpb24gKGNvZGVwb2ludCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVRGOChjb2RlcG9pbnQpO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgLy8gYHgtdXNlci1kZWZpbmVkYCBlbmNvZGluZyBtb2RlOiBhc3N1bWUgdGhlIGlucHV0IHdhcyBkZWNvZGVkIHdpdGggdGhlIFdIQVRXRyBgeC11c2VyLWRlZmluZWRgIGVuY29kaW5nXG4gICAgJ3gtdXNlci1kZWZpbmVkJzoge1xuICAgICAgZml4dXA6IGNoZWNrQ2hhcnMoL1teXFx4MDAtXFx4N2ZcXHVmNzgwLVxcdWY3ZmZdLyksXG4gICAgICBlbmNvZGVCeXRlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ODApXG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgfCAweGY3MDApO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZW5jb2RlVVRGODogZnVuY3Rpb24gKGNvZGVwb2ludCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVRGOChjb2RlcG9pbnQsIDB4ZjcwMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGBub25lYCBlbmNvZGluZyBtb2RlOiBkaXNyZWdhcmQgaW50cmVwcmV0YXRpb24gb2Ygc3RyaW5nIGxpdGVyYWxzLCBsZWF2ZSBpZGVudGlmaWVycyBhcy1pc1xuICAgICdub25lJzoge1xuICAgICAgZGlzY2FyZFN0cmluZ3M6IHRydWUsXG4gICAgICBmaXh1cDogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9LFxuICAgICAgZW5jb2RlQnl0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0sXG4gICAgICBlbmNvZGVVVEY4OiBmdW5jdGlvbiAoY29kZXBvaW50KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGF2YWlsYWJsZSB0b2tlbnMgZXhwcmVzc2VkIGFzIGVudW0gZmxhZ3Mgc28gdGhleSBjYW4gYmUgY2hlY2tlZCB3aXRoXG4gIC8vIGJpdHdpc2Ugb3BlcmF0aW9ucy5cblxuICB2YXIgRU9GID0gMSwgU3RyaW5nTGl0ZXJhbCA9IDIsIEtleXdvcmQgPSA0LCBJZGVudGlmaWVyID0gOFxuICAgICwgTnVtZXJpY0xpdGVyYWwgPSAxNiwgUHVuY3R1YXRvciA9IDMyLCBCb29sZWFuTGl0ZXJhbCA9IDY0XG4gICAgLCBOaWxMaXRlcmFsID0gMTI4LCBWYXJhcmdMaXRlcmFsID0gMjU2O1xuXG4gIGV4cG9ydHMudG9rZW5UeXBlcyA9IHsgRU9GOiBFT0YsIFN0cmluZ0xpdGVyYWw6IFN0cmluZ0xpdGVyYWxcbiAgICAsIEtleXdvcmQ6IEtleXdvcmQsIElkZW50aWZpZXI6IElkZW50aWZpZXIsIE51bWVyaWNMaXRlcmFsOiBOdW1lcmljTGl0ZXJhbFxuICAgICwgUHVuY3R1YXRvcjogUHVuY3R1YXRvciwgQm9vbGVhbkxpdGVyYWw6IEJvb2xlYW5MaXRlcmFsXG4gICAgLCBOaWxMaXRlcmFsOiBOaWxMaXRlcmFsLCBWYXJhcmdMaXRlcmFsOiBWYXJhcmdMaXRlcmFsXG4gIH07XG5cbiAgLy8gQXMgdGhpcyBwYXJzZXIgaXMgYSBiaXQgZGlmZmVyZW50IGZyb20gbHVhcyBvd24sIHRoZSBlcnJvciBtZXNzYWdlc1xuICAvLyB3aWxsIGJlIGRpZmZlcmVudCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAgdmFyIGVycm9ycyA9IGV4cG9ydHMuZXJyb3JzID0ge1xuICAgICAgdW5leHBlY3RlZDogJ3VuZXhwZWN0ZWQgJTEgXFwnJTJcXCcgbmVhciBcXCclM1xcJydcbiAgICAsIHVuZXhwZWN0ZWRFT0Y6ICd1bmV4cGVjdGVkIHN5bWJvbCBuZWFyIFxcJzxlb2Y+XFwnJ1xuICAgICwgZXhwZWN0ZWQ6ICdcXCclMVxcJyBleHBlY3RlZCBuZWFyIFxcJyUyXFwnJ1xuICAgICwgZXhwZWN0ZWRUb2tlbjogJyUxIGV4cGVjdGVkIG5lYXIgXFwnJTJcXCcnXG4gICAgLCB1bmZpbmlzaGVkU3RyaW5nOiAndW5maW5pc2hlZCBzdHJpbmcgbmVhciBcXCclMVxcJydcbiAgICAsIG1hbGZvcm1lZE51bWJlcjogJ21hbGZvcm1lZCBudW1iZXIgbmVhciBcXCclMVxcJydcbiAgICAsIGRlY2ltYWxFc2NhcGVUb29MYXJnZTogJ2RlY2ltYWwgZXNjYXBlIHRvbyBsYXJnZSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgaW52YWxpZEVzY2FwZTogJ2ludmFsaWQgZXNjYXBlIHNlcXVlbmNlIG5lYXIgXFwnJTFcXCcnXG4gICAgLCBoZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQ6ICdoZXhhZGVjaW1hbCBkaWdpdCBleHBlY3RlZCBuZWFyIFxcJyUxXFwnJ1xuICAgICwgYnJhY2VFeHBlY3RlZDogJ21pc3NpbmcgXFwnJTFcXCcgbmVhciBcXCclMlxcJydcbiAgICAsIHRvb0xhcmdlQ29kZXBvaW50OiAnVVRGLTggdmFsdWUgdG9vIGxhcmdlIG5lYXIgXFwnJTFcXCcnXG4gICAgLCB1bmZpbmlzaGVkTG9uZ1N0cmluZzogJ3VuZmluaXNoZWQgbG9uZyBzdHJpbmcgKHN0YXJ0aW5nIGF0IGxpbmUgJTEpIG5lYXIgXFwnJTJcXCcnXG4gICAgLCB1bmZpbmlzaGVkTG9uZ0NvbW1lbnQ6ICd1bmZpbmlzaGVkIGxvbmcgY29tbWVudCAoc3RhcnRpbmcgYXQgbGluZSAlMSkgbmVhciBcXCclMlxcJydcbiAgICAsIGFtYmlndW91c1N5bnRheDogJ2FtYmlndW91cyBzeW50YXggKGZ1bmN0aW9uIGNhbGwgeCBuZXcgc3RhdGVtZW50KSBuZWFyIFxcJyUxXFwnJ1xuICAgICwgbm9Mb29wVG9CcmVhazogJ25vIGxvb3AgdG8gYnJlYWsgbmVhciBcXCclMVxcJydcbiAgICAsIGxhYmVsQWxyZWFkeURlZmluZWQ6ICdsYWJlbCBcXCclMVxcJyBhbHJlYWR5IGRlZmluZWQgb24gbGluZSAlMidcbiAgICAsIGxhYmVsTm90VmlzaWJsZTogJ25vIHZpc2libGUgbGFiZWwgXFwnJTFcXCcgZm9yIDxnb3RvPidcbiAgICAsIGdvdG9KdW1wSW5Mb2NhbFNjb3BlOiAnPGdvdG8gJTE+IGp1bXBzIGludG8gdGhlIHNjb3BlIG9mIGxvY2FsIFxcJyUyXFwnJ1xuICAgICwgY2Fubm90VXNlVmFyYXJnOiAnY2Fubm90IHVzZSBcXCcuLi5cXCcgb3V0c2lkZSBhIHZhcmFyZyBmdW5jdGlvbiBuZWFyIFxcJyUxXFwnJ1xuICAgICwgaW52YWxpZENvZGVVbml0OiAnY29kZSB1bml0IFUrJTEgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgZW5jb2RpbmcgbW9kZSdcbiAgfTtcblxuICAvLyAjIyMgQWJzdHJhY3QgU3ludGF4IFRyZWVcbiAgLy9cbiAgLy8gVGhlIGRlZmF1bHQgQVNUIHN0cnVjdHVyZSBpcyBpbnNwaXJlZCBieSB0aGUgTW96aWxsYSBQYXJzZXIgQVBJIGJ1dCBjYW5cbiAgLy8gZWFzaWx5IGJlIGN1c3RvbWl6ZWQgYnkgb3ZlcnJpZGluZyB0aGVzZSBmdW5jdGlvbnMuXG5cbiAgdmFyIGFzdCA9IGV4cG9ydHMuYXN0ID0ge1xuICAgICAgbGFiZWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdMYWJlbFN0YXRlbWVudCdcbiAgICAgICAgLCBsYWJlbDogbGFiZWxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBicmVha1N0YXRlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdCcmVha1N0YXRlbWVudCdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBnb3RvU3RhdGVtZW50OiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnR290b1N0YXRlbWVudCdcbiAgICAgICAgLCBsYWJlbDogbGFiZWxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCByZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1JldHVyblN0YXRlbWVudCdcbiAgICAgICAgLCAnYXJndW1lbnRzJzogYXJnc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGlmU3RhdGVtZW50OiBmdW5jdGlvbihjbGF1c2VzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdJZlN0YXRlbWVudCdcbiAgICAgICAgLCBjbGF1c2VzOiBjbGF1c2VzXG4gICAgICB9O1xuICAgIH1cbiAgICAsIGlmQ2xhdXNlOiBmdW5jdGlvbihjb25kaXRpb24sIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0lmQ2xhdXNlJ1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG4gICAgLCBlbHNlaWZDbGF1c2U6IGZ1bmN0aW9uKGNvbmRpdGlvbiwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRWxzZWlmQ2xhdXNlJ1xuICAgICAgICAsIGNvbmRpdGlvbjogY29uZGl0aW9uXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG4gICAgLCBlbHNlQ2xhdXNlOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdFbHNlQ2xhdXNlJ1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCB3aGlsZVN0YXRlbWVudDogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdXaGlsZVN0YXRlbWVudCdcbiAgICAgICAgLCBjb25kaXRpb246IGNvbmRpdGlvblxuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBkb1N0YXRlbWVudDogZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRG9TdGF0ZW1lbnQnXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHJlcGVhdFN0YXRlbWVudDogZnVuY3Rpb24oY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdSZXBlYXRTdGF0ZW1lbnQnXG4gICAgICAgICwgY29uZGl0aW9uOiBjb25kaXRpb25cbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgbG9jYWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHZhcmlhYmxlcywgaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnTG9jYWxTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGVzOiB2YXJpYWJsZXNcbiAgICAgICAgLCBpbml0OiBpbml0XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgYXNzaWdubWVudFN0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGVzLCBpbml0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdBc3NpZ25tZW50U3RhdGVtZW50J1xuICAgICAgICAsIHZhcmlhYmxlczogdmFyaWFibGVzXG4gICAgICAgICwgaW5pdDogaW5pdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGNhbGxTdGF0ZW1lbnQ6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0NhbGxTdGF0ZW1lbnQnXG4gICAgICAgICwgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGZ1bmN0aW9uU3RhdGVtZW50OiBmdW5jdGlvbihpZGVudGlmaWVyLCBwYXJhbWV0ZXJzLCBpc0xvY2FsLCBib2R5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdGdW5jdGlvbkRlY2xhcmF0aW9uJ1xuICAgICAgICAsIGlkZW50aWZpZXI6IGlkZW50aWZpZXJcbiAgICAgICAgLCBpc0xvY2FsOiBpc0xvY2FsXG4gICAgICAgICwgcGFyYW1ldGVyczogcGFyYW1ldGVyc1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBmb3JOdW1lcmljU3RhdGVtZW50OiBmdW5jdGlvbih2YXJpYWJsZSwgc3RhcnQsIGVuZCwgc3RlcCwgYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnRm9yTnVtZXJpY1N0YXRlbWVudCdcbiAgICAgICAgLCB2YXJpYWJsZTogdmFyaWFibGVcbiAgICAgICAgLCBzdGFydDogc3RhcnRcbiAgICAgICAgLCBlbmQ6IGVuZFxuICAgICAgICAsIHN0ZXA6IHN0ZXBcbiAgICAgICAgLCBib2R5OiBib2R5XG4gICAgICB9O1xuICAgIH1cblxuICAgICwgZm9yR2VuZXJpY1N0YXRlbWVudDogZnVuY3Rpb24odmFyaWFibGVzLCBpdGVyYXRvcnMsIGJvZHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0ZvckdlbmVyaWNTdGF0ZW1lbnQnXG4gICAgICAgICwgdmFyaWFibGVzOiB2YXJpYWJsZXNcbiAgICAgICAgLCBpdGVyYXRvcnM6IGl0ZXJhdG9yc1xuICAgICAgICAsIGJvZHk6IGJvZHlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjaHVuazogZnVuY3Rpb24oYm9keSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ2h1bmsnXG4gICAgICAgICwgYm9keTogYm9keVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGlkZW50aWZpZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInXG4gICAgICAgICwgbmFtZTogbmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIGxpdGVyYWw6IGZ1bmN0aW9uKHR5cGUsIHZhbHVlLCByYXcpIHtcbiAgICAgIHR5cGUgPSAodHlwZSA9PT0gU3RyaW5nTGl0ZXJhbCkgPyAnU3RyaW5nTGl0ZXJhbCdcbiAgICAgICAgOiAodHlwZSA9PT0gTnVtZXJpY0xpdGVyYWwpID8gJ051bWVyaWNMaXRlcmFsJ1xuICAgICAgICA6ICh0eXBlID09PSBCb29sZWFuTGl0ZXJhbCkgPyAnQm9vbGVhbkxpdGVyYWwnXG4gICAgICAgIDogKHR5cGUgPT09IE5pbExpdGVyYWwpID8gJ05pbExpdGVyYWwnXG4gICAgICAgIDogJ1ZhcmFyZ0xpdGVyYWwnO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgICAgLCByYXc6IHJhd1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAsIHRhYmxlS2V5OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUtleSdcbiAgICAgICAgLCBrZXk6IGtleVxuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLCB0YWJsZUtleVN0cmluZzogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVLZXlTdHJpbmcnXG4gICAgICAgICwga2V5OiBrZXlcbiAgICAgICAgLCB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgICwgdGFibGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1RhYmxlVmFsdWUnXG4gICAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cblxuXG4gICAgLCB0YWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbjogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdUYWJsZUNvbnN0cnVjdG9yRXhwcmVzc2lvbidcbiAgICAgICAgLCBmaWVsZHM6IGZpZWxkc1xuICAgICAgfTtcbiAgICB9XG4gICAgLCBiaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciB0eXBlID0gKCdhbmQnID09PSBvcGVyYXRvciB8fCAnb3InID09PSBvcGVyYXRvcikgP1xuICAgICAgICAnTG9naWNhbEV4cHJlc3Npb24nIDpcbiAgICAgICAgJ0JpbmFyeUV4cHJlc3Npb24nO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgICAgLCBsZWZ0OiBsZWZ0XG4gICAgICAgICwgcmlnaHQ6IHJpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICAsIHVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdVbmFyeUV4cHJlc3Npb24nXG4gICAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICAgICwgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICAsIG1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKGJhc2UsIGluZGV4ZXIsIGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nXG4gICAgICAgICwgaW5kZXhlcjogaW5kZXhlclxuICAgICAgICAsIGlkZW50aWZpZXI6IGlkZW50aWZpZXJcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgaW5kZXhFeHByZXNzaW9uOiBmdW5jdGlvbihiYXNlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnSW5kZXhFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCBpbmRleDogaW5kZXhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJncykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnQ2FsbEV4cHJlc3Npb24nXG4gICAgICAgICwgYmFzZTogYmFzZVxuICAgICAgICAsICdhcmd1bWVudHMnOiBhcmdzXG4gICAgICB9O1xuICAgIH1cblxuICAgICwgdGFibGVDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJncykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnVGFibGVDYWxsRXhwcmVzc2lvbidcbiAgICAgICAgLCBiYXNlOiBiYXNlXG4gICAgICAgICwgJ2FyZ3VtZW50cyc6IGFyZ3NcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBzdHJpbmdDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24oYmFzZSwgYXJndW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ1N0cmluZ0NhbGxFeHByZXNzaW9uJ1xuICAgICAgICAsIGJhc2U6IGJhc2VcbiAgICAgICAgLCBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLCBjb21tZW50OiBmdW5jdGlvbih2YWx1ZSwgcmF3KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdDb21tZW50J1xuICAgICAgICAsIHZhbHVlOiB2YWx1ZVxuICAgICAgICAsIHJhdzogcmF3XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBXcmFwIHVwIHRoZSBub2RlIG9iamVjdC5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlKG5vZGUpIHtcbiAgICAvLyBQb3AgYSBgTWFya2VyYCBvZmYgdGhlIGxvY2F0aW9uLWFycmF5IGFuZCBhdHRhY2ggaXRzIGxvY2F0aW9uIGRhdGEuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBsb2NhdGlvbnMucG9wKCk7XG4gICAgICBsb2NhdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgbG9jYXRpb24uYmxlc3Mobm9kZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9uQ3JlYXRlTm9kZSkgb3B0aW9ucy5vbkNyZWF0ZU5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLVxuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgO1xuXG4gIHZhciBpbmRleE9mID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGFycmF5LCBlbGVtZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IGVsZW1lbnQpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKVxuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH07XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHJldHVybiB0aGUgaW5kZXggb2YgYW4gb2JqZWN0XG4gIC8vIHdpdGggYSBtYXRjaGluZyBwcm9wZXJ0eS5cblxuICBmdW5jdGlvbiBpbmRleE9mT2JqZWN0KGFycmF5LCBwcm9wZXJ0eSwgZWxlbWVudCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFycmF5W2ldW3Byb3BlcnR5XSA9PT0gZWxlbWVudCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIEEgc3ByaW50ZiBpbXBsZW1lbnRhdGlvbiB1c2luZyAlaW5kZXggKGJlZ2lubmluZyBhdCAxKSB0byBpbnB1dFxuICAvLyBhcmd1bWVudHMgaW4gdGhlIGZvcm1hdCBzdHJpbmcuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBVbmV4cGVjdGVkIGZ1bmN0aW9uIGluIHRva2VuXG4gIC8vICAgICBzcHJpbnRmKCdVbmV4cGVjdGVkICUyIGluICUxLicsICd0b2tlbicsICdmdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHNwcmludGYoZm9ybWF0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICByZXR1cm4gJycgKyBhcmdzW2luZGV4IC0gMV0gfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIC8vIFBvbHlmaWxsIGZvciBgT2JqZWN0LmFzc2lnbmAuXG5cbiAgdmFyIGFzc2lnbiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICwgc3JjLCBwcm9wO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHNyYyA9IGFyZ3NbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc3JjKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgcHJvcCkpIHtcbiAgICAgICAgICBkZXN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKE9iamVjdC5hc3NpZ24pXG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuICAvLyAjIyMgRXJyb3IgZnVuY3Rpb25zXG5cbiAgLy8gWFhYOiBFbGltaW5hdGUgdGhpcyBmdW5jdGlvbiBhbmQgY2hhbmdlIHRoZSBlcnJvciB0eXBlIHRvIGJlIGRpZmZlcmVudCBmcm9tIFN5bnRheEVycm9yLlxuICAvLyBUaGlzIHdpbGwgdW5mb3J0dW5hdGVseSBiZSBhIGJyZWFraW5nIGNoYW5nZSwgYmVjYXVzZSBzb21lIGRvd25zdHJlYW0gdXNlcnMgZGVwZW5kXG4gIC8vIG9uIHRoZSBlcnJvciB0aHJvd24gYmVpbmcgYW4gaW5zdGFuY2Ugb2YgU3ludGF4RXJyb3IuIEZvciBleGFtcGxlLCB0aGUgQWNlIGVkaXRvcjpcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL2FjZS9ibG9iLzRjN2U1ZWIzZjVkNWNhOTQzNDg0N2JlNTE4MzRhNGU0MTY2MWI4NTIvbGliL2FjZS9tb2RlL2x1YV93b3JrZXIuanMjTDU1PlxuXG4gIGZ1bmN0aW9uIGZpeHVwRXJyb3IoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghT2JqZWN0LmNyZWF0ZSlcbiAgICAgIHJldHVybiBlO1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKGUsIHtcbiAgICAgICdsaW5lJzogeyAnd3JpdGFibGUnOiB0cnVlLCB2YWx1ZTogZS5saW5lIH0sXG4gICAgICAnaW5kZXgnOiB7ICd3cml0YWJsZSc6IHRydWUsIHZhbHVlOiBlLmluZGV4IH0sXG4gICAgICAnY29sdW1uJzogeyAnd3JpdGFibGUnOiB0cnVlLCB2YWx1ZTogZS5jb2x1bW4gfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gIyMjIyBSYWlzZSBhbiBleGNlcHRpb24uXG4gIC8vXG4gIC8vIFJhaXNlIGFuIGV4Y2VwdGlvbiBieSBwYXNzaW5nIGEgdG9rZW4sIGEgc3RyaW5nIGZvcm1hdCBhbmQgaXRzIHBhcmFtdGVycy5cbiAgLy9cbiAgLy8gVGhlIHBhc3NlZCB0b2tlbnMgbG9jYXRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGFkZGVkIHRvIHRoZSBlcnJvclxuICAvLyBtZXNzYWdlIGlmIGl0IGV4aXN0cywgaWYgbm90IGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbGV4ZXJzIGN1cnJlbnRcbiAgLy8gcG9zaXRpb24uXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBbMTowXSBleHBlY3RlZCBbIG5lYXIgKFxuICAvLyAgICAgcmFpc2UodG9rZW4sIFwiZXhwZWN0ZWQgJTEgbmVhciAlMlwiLCAnWycsIHRva2VuLnZhbHVlKTtcblxuICBmdW5jdGlvbiByYWlzZSh0b2tlbikge1xuICAgIHZhciBtZXNzYWdlID0gc3ByaW50Zi5hcHBseShudWxsLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICAsIGVycm9yLCBjb2w7XG5cbiAgICBpZiAodG9rZW4gPT09IG51bGwgfHwgdHlwZW9mIHRva2VuLmxpbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2wgPSBpbmRleCAtIGxpbmVTdGFydCArIDE7XG4gICAgICBlcnJvciA9IGZpeHVwRXJyb3IobmV3IFN5bnRheEVycm9yKHNwcmludGYoJ1slMTolMl0gJTMnLCBsaW5lLCBjb2wsIG1lc3NhZ2UpKSk7XG4gICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgZXJyb3IubGluZSA9IGxpbmU7XG4gICAgICBlcnJvci5jb2x1bW4gPSBjb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbCA9IHRva2VuLnJhbmdlWzBdIC0gdG9rZW4ubGluZVN0YXJ0O1xuICAgICAgZXJyb3IgPSBmaXh1cEVycm9yKG5ldyBTeW50YXhFcnJvcihzcHJpbnRmKCdbJTE6JTJdICUzJywgdG9rZW4ubGluZSwgY29sLCBtZXNzYWdlKSkpO1xuICAgICAgZXJyb3IubGluZSA9IHRva2VuLmxpbmU7XG4gICAgICBlcnJvci5pbmRleCA9IHRva2VuLnJhbmdlWzBdO1xuICAgICAgZXJyb3IuY29sdW1uID0gY29sO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuVmFsdWUodG9rZW4pIHtcbiAgICB2YXIgcmF3ID0gaW5wdXQuc2xpY2UodG9rZW4ucmFuZ2VbMF0sIHRva2VuLnJhbmdlWzFdKTtcbiAgICBpZiAocmF3KVxuICAgICAgcmV0dXJuIHJhdztcbiAgICByZXR1cm4gdG9rZW4udmFsdWU7XG4gIH1cblxuICAvLyAjIyMjIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBleHBlY3RlZCA8bmFtZT4gbmVhciAnMCdcbiAgLy8gICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4nLCB0b2tlbik7XG5cbiAgZnVuY3Rpb24gcmFpc2VVbmV4cGVjdGVkVG9rZW4odHlwZSwgdG9rZW4pIHtcbiAgICByYWlzZSh0b2tlbiwgZXJyb3JzLmV4cGVjdGVkVG9rZW4sIHR5cGUsIHRva2VuVmFsdWUodG9rZW4pKTtcbiAgfVxuXG4gIC8vICMjIyMgUmFpc2UgYSBnZW5lcmFsIHVuZXhwZWN0ZWQgZXJyb3JcbiAgLy9cbiAgLy8gVXNhZ2Ugc2hvdWxkIHBhc3MgZWl0aGVyIGEgdG9rZW4gb2JqZWN0IG9yIGEgc3ltYm9sIHN0cmluZyB3aGljaCB3YXNcbiAgLy8gZXhwZWN0ZWQuIFdlIGNhbiBhbHNvIHNwZWNpZnkgYSBuZWFyYnkgdG9rZW4gc3VjaCBhcyA8ZW9mPiwgdGhpcyB3aWxsXG4gIC8vIGRlZmF1bHQgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgdG9rZW4uXG4gIC8vXG4gIC8vIEV4YW1wbGU6XG4gIC8vXG4gIC8vICAgICAvLyBVbmV4cGVjdGVkIHN5bWJvbCAnZW5kJyBuZWFyICc8ZW9mPidcbiAgLy8gICAgIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAvL1xuICAvLyBJZiB0aGVyZSdzIG5vIHRva2VuIGluIHRoZSBidWZmZXIgaXQgbWVhbnMgd2UgaGF2ZSByZWFjaGVkIDxlb2Y+LlxuXG4gIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoZm91bmQpIHtcbiAgICB2YXIgbmVhciA9IHRva2VuVmFsdWUobG9va2FoZWFkKTtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBmb3VuZC50eXBlKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHN3aXRjaCAoZm91bmQudHlwZSkge1xuICAgICAgICBjYXNlIFN0cmluZ0xpdGVyYWw6ICAgdHlwZSA9ICdzdHJpbmcnOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtleXdvcmQ6ICAgICAgICAgdHlwZSA9ICdrZXl3b3JkJzsgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIElkZW50aWZpZXI6ICAgICAgdHlwZSA9ICdpZGVudGlmaWVyJzsgIGJyZWFrO1xuICAgICAgICBjYXNlIE51bWVyaWNMaXRlcmFsOiAgdHlwZSA9ICdudW1iZXInOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFB1bmN0dWF0b3I6ICAgICAgdHlwZSA9ICdzeW1ib2wnOyAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJvb2xlYW5MaXRlcmFsOiAgdHlwZSA9ICdib29sZWFuJzsgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5pbExpdGVyYWw6XG4gICAgICAgICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZCwgJ3N5bWJvbCcsICduaWwnLCBuZWFyKTtcbiAgICAgICAgY2FzZSBFT0Y6XG4gICAgICAgICAgcmV0dXJuIHJhaXNlKGZvdW5kLCBlcnJvcnMudW5leHBlY3RlZEVPRik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFpc2UoZm91bmQsIGVycm9ycy51bmV4cGVjdGVkLCB0eXBlLCB0b2tlblZhbHVlKGZvdW5kKSwgbmVhcik7XG4gICAgfVxuICAgIHJldHVybiByYWlzZShmb3VuZCwgZXJyb3JzLnVuZXhwZWN0ZWQsICdzeW1ib2wnLCBmb3VuZCwgbmVhcik7XG4gIH1cblxuICAvLyBMZXhlclxuICAvLyAtLS0tLVxuICAvL1xuICAvLyBUaGUgbGV4ZXIsIG9yIHRoZSB0b2tlbml6ZXIgcmVhZHMgdGhlIGlucHV0IHN0cmluZyBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXG4gIC8vIGFuZCBkZXJpdmVzIGEgdG9rZW4gbGVmdC1yaWdodC4gVG8gYmUgYXMgZWZmaWNpZW50IGFzIHBvc3NpYmxlIHRoZSBsZXhlclxuICAvLyBwcmlvcml0aXplcyB0aGUgY29tbW9uIGNhc2VzIHN1Y2ggYXMgaWRlbnRpZmllcnMuIEl0IGFsc28gd29ya3Mgd2l0aFxuICAvLyBjaGFyYWN0ZXIgY29kZXMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzIGFzIHN0cmluZyBjb21wYXJpc29ucyB3YXMgdGhlXG4gIC8vIGJpZ2dlc3QgYm90dGxlbmVjayBvZiB0aGUgcGFyc2VyLlxuICAvL1xuICAvLyBJZiBgb3B0aW9ucy5jb21tZW50c2AgaXMgZW5hYmxlZCwgYWxsIGNvbW1lbnRzIGVuY291bnRlcmVkIHdpbGwgYmUgc3RvcmVkXG4gIC8vIGluIGFuIGFycmF5IHdoaWNoIGxhdGVyIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGNodW5rIG9iamVjdC4gSWYgZGlzYWJsZWQsXG4gIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgZGlzcmVnYXJkZWQuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGxleGVyIGhhcyBkZXJpdmVkIGEgdmFsaWQgdG9rZW4sIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgaXRzIHZhbHVlIGFuZCBhcyB3ZWxsIGFzIGl0cyBwb3NpdGlvbiBpbiB0aGUgaW5wdXQgc3RyaW5nICh0aGlzXG4gIC8vIGlzIGFsd2F5cyBlbmFibGVkIHRvIHByb3ZpZGUgcHJvcGVyIGRlYnVnIG1lc3NhZ2VzKS5cbiAgLy9cbiAgLy8gYGxleCgpYCBzdGFydHMgbGV4aW5nIGFuZCByZXR1cm5zIHRoZSBmb2xsb3dpbmcgdG9rZW4gaW4gdGhlIHN0cmVhbS5cblxuICB2YXIgaW5kZXhcbiAgICAsIHRva2VuXG4gICAgLCBwcmV2aW91c1Rva2VuXG4gICAgLCBsb29rYWhlYWRcbiAgICAsIGNvbW1lbnRzXG4gICAgLCB0b2tlblN0YXJ0XG4gICAgLCBsaW5lXG4gICAgLCBsaW5lU3RhcnQ7XG5cbiAgZXhwb3J0cy5sZXggPSBsZXg7XG5cbiAgZnVuY3Rpb24gbGV4KCkge1xuICAgIHNraXBXaGl0ZVNwYWNlKCk7XG5cbiAgICAvLyBTa2lwIGNvbW1lbnRzIGJlZ2lubmluZyB3aXRoIC0tXG4gICAgd2hpbGUgKDQ1ID09PSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSAmJlxuICAgICAgICAgICA0NSA9PT0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpKSB7XG4gICAgICBzY2FuQ29tbWVudCgpO1xuICAgICAgc2tpcFdoaXRlU3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ID49IGxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgdHlwZSA6IEVPRlxuICAgICAgLCB2YWx1ZTogJzxlb2Y+J1xuICAgICAgLCBsaW5lOiBsaW5lXG4gICAgICAsIGxpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbaW5kZXgsIGluZGV4XVxuICAgIH07XG5cbiAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KVxuICAgICAgLCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgLy8gTWVtb3JpemUgdGhlIHJhbmdlIGluZGV4IHdoZXJlIHRoZSB0b2tlbiBiZWdpbnMuXG4gICAgdG9rZW5TdGFydCA9IGluZGV4O1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaGFyQ29kZSkpIHJldHVybiBzY2FuSWRlbnRpZmllck9yS2V5d29yZCgpO1xuXG4gICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgY2FzZSAzOTogY2FzZSAzNDogLy8gJ1wiXG4gICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIDQ4OiBjYXNlIDQ5OiBjYXNlIDUwOiBjYXNlIDUxOiBjYXNlIDUyOiBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMC05XG4gICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcblxuICAgICAgY2FzZSA0NjogLy8gLlxuICAgICAgICAvLyBJZiB0aGUgZG90IGlzIGZvbGxvd2VkIGJ5IGEgZGlnaXQgaXQncyBhIGZsb2F0LlxuICAgICAgICBpZiAoaXNEZWNEaWdpdChuZXh0KSkgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICBpZiAoNDYgPT09IG5leHQpIHtcbiAgICAgICAgICBpZiAoNDYgPT09IGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAyKSkgcmV0dXJuIHNjYW5WYXJhcmdMaXRlcmFsKCk7XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignLicpO1xuXG4gICAgICBjYXNlIDYxOiAvLyA9XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc9PScpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz0nKTtcblxuICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICBpZiAoZmVhdHVyZXMuYml0d2lzZU9wZXJhdG9ycylcbiAgICAgICAgICBpZiAoNjIgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPj4nKTtcbiAgICAgICAgaWYgKDYxID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJz49Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignPicpO1xuXG4gICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgIGlmIChmZWF0dXJlcy5iaXR3aXNlT3BlcmF0b3JzKVxuICAgICAgICAgIGlmICg2MCA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc8PCcpO1xuICAgICAgICBpZiAoNjEgPT09IG5leHQpIHJldHVybiBzY2FuUHVuY3R1YXRvcignPD0nKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCc8Jyk7XG5cbiAgICAgIGNhc2UgMTI2OiAvLyB+XG4gICAgICAgIGlmICg2MSA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCd+PScpO1xuICAgICAgICBpZiAoIWZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignficpO1xuXG4gICAgICBjYXNlIDU4OiAvLyA6XG4gICAgICAgIGlmIChmZWF0dXJlcy5sYWJlbHMpXG4gICAgICAgICAgaWYgKDU4ID09PSBuZXh0KSByZXR1cm4gc2NhblB1bmN0dWF0b3IoJzo6Jyk7XG4gICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcignOicpO1xuXG4gICAgICBjYXNlIDkxOiAvLyBbXG4gICAgICAgIC8vIENoZWNrIGZvciBhIG11bHRpbGluZSBzdHJpbmcsIHRoZXkgYmVnaW4gd2l0aCBbPSBvciBbW1xuICAgICAgICBpZiAoOTEgPT09IG5leHQgfHwgNjEgPT09IG5leHQpIHJldHVybiBzY2FuTG9uZ1N0cmluZ0xpdGVyYWwoKTtcbiAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCdbJyk7XG5cbiAgICAgIGNhc2UgNDc6IC8vIC9cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVnZXIgZGl2aXNpb24gb3AgKC8vKVxuICAgICAgICBpZiAoZmVhdHVyZXMuaW50ZWdlckRpdmlzaW9uKVxuICAgICAgICAgIGlmICg0NyA9PT0gbmV4dCkgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCcvLycpO1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoJy8nKTtcblxuICAgICAgY2FzZSAzODogY2FzZSAxMjQ6IC8vICYgfFxuICAgICAgICBpZiAoIWZlYXR1cmVzLmJpdHdpc2VPcGVyYXRvcnMpXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgICBjYXNlIDQyOiBjYXNlIDk0OiBjYXNlIDM3OiBjYXNlIDQ0OiBjYXNlIDEyMzogY2FzZSAxMjU6XG4gICAgICBjYXNlIDkzOiBjYXNlIDQwOiBjYXNlIDQxOiBjYXNlIDU5OiBjYXNlIDM1OiBjYXNlIDQ1OlxuICAgICAgY2FzZSA0MzogLy8gKiBeICUgLCB7IH0gXSAoICkgOyAjIC0gK1xuICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZXhwZWN0ZWQoaW5wdXQuY2hhckF0KGluZGV4KSk7XG4gIH1cblxuICAvLyBXaGl0ZXNwYWNlIGhhcyBubyBzZW1hbnRpYyBtZWFuaW5nIGluIGx1YSBzbyBzaW1wbHkgc2tpcCBhaGVhZCB3aGlsZVxuICAvLyB0cmFja2luZyB0aGUgZW5jb3VudGVkIG5ld2xpbmVzLiBBbnkga2luZCBvZiBlb2wgc2VxdWVuY2UgaXMgY291bnRlZCBhcyBhXG4gIC8vIHNpbmdsZSBsaW5lLlxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVFT0woKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleClcbiAgICAgICwgcGVla0NoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpKSB7XG4gICAgICAvLyBDb3VudCBcXG5cXHIgYW5kIFxcclxcbiBhcyBvbmUgbmV3bGluZS5cbiAgICAgIGlmICgxMCA9PT0gY2hhckNvZGUgJiYgMTMgPT09IHBlZWtDaGFyQ29kZSkgKytpbmRleDtcbiAgICAgIGlmICgxMyA9PT0gY2hhckNvZGUgJiYgMTAgPT09IHBlZWtDaGFyQ29kZSkgKytpbmRleDtcbiAgICAgICsrbGluZTtcbiAgICAgIGxpbmVTdGFydCA9ICsraW5kZXg7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpdGVTcGFjZSgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaGFyQ29kZSkpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbnN1bWVFT0woKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmaWVycywga2V5d29yZHMsIGJvb2xlYW5zIGFuZCBuaWwgYWxsIGxvb2sgdGhlIHNhbWUgc3ludGF4IHdpc2UuIFdlXG4gIC8vIHNpbXBseSBnbyB0aHJvdWdoIHRoZW0gb25lIGJ5IG9uZSBhbmQgZGVmYXVsdGluZyB0byBhbiBpZGVudGlmaWVyIGlmIG5vXG4gIC8vIHByZXZpb3VzIGNhc2UgbWF0Y2hlZC5cblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllck9yS2V5d29yZCgpIHtcbiAgICB2YXIgdmFsdWUsIHR5cGU7XG5cbiAgICAvLyBTbGljaW5nIHRoZSBpbnB1dCBzdHJpbmcgaXMgcHJlZmVyZWQgYmVmb3JlIHN0cmluZyBjb25jYXRlbmF0aW9uIGluIGFcbiAgICAvLyBsb29wIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KGlucHV0LmNoYXJDb2RlQXQoKytpbmRleCkpKTtcbiAgICB2YWx1ZSA9IGVuY29kaW5nTW9kZS5maXh1cChpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgLy8gRGVjaWRlIG9uIHRoZSB0b2tlbiB0eXBlIGFuZCBwb3NzaWJseSBjYXN0IHRoZSB2YWx1ZS5cbiAgICBpZiAoaXNLZXl3b3JkKHZhbHVlKSkge1xuICAgICAgdHlwZSA9IEtleXdvcmQ7XG4gICAgfSBlbHNlIGlmICgndHJ1ZScgPT09IHZhbHVlIHx8ICdmYWxzZScgPT09IHZhbHVlKSB7XG4gICAgICB0eXBlID0gQm9vbGVhbkxpdGVyYWw7XG4gICAgICB2YWx1ZSA9ICgndHJ1ZScgPT09IHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCduaWwnID09PSB2YWx1ZSkge1xuICAgICAgdHlwZSA9IE5pbExpdGVyYWw7XG4gICAgICB2YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSBJZGVudGlmaWVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gT25jZSBhIHB1bmN0dWF0b3IgcmVhY2hlcyB0aGlzIGZ1bmN0aW9uIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlblxuICAvLyB2YWxpZGF0ZWQgc28gd2Ugc2ltcGx5IHJldHVybiBpdCBhcyBhIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKHZhbHVlKSB7XG4gICAgaW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFB1bmN0dWF0b3JcbiAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gQSB2YXJhcmcgbGl0ZXJhbCBjb25zaXN0cyBvZiB0aHJlZSBkb3RzLlxuXG4gIGZ1bmN0aW9uIHNjYW5WYXJhcmdMaXRlcmFsKCkge1xuICAgIGluZGV4ICs9IDM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVmFyYXJnTGl0ZXJhbFxuICAgICAgLCB2YWx1ZTogJy4uLidcbiAgICAgICwgbGluZTogbGluZVxuICAgICAgLCBsaW5lU3RhcnQ6IGxpbmVTdGFydFxuICAgICAgLCByYW5nZTogW3Rva2VuU3RhcnQsIGluZGV4XVxuICAgIH07XG4gIH1cblxuICAvLyBGaW5kIHRoZSBzdHJpbmcgbGl0ZXJhbCBieSBtYXRjaGluZyB0aGUgZGVsaW1pdGVyIG1hcmtzIHVzZWQuXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgdmFyIGRlbGltaXRlciA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKylcbiAgICAgICwgYmVnaW5MaW5lID0gbGluZVxuICAgICAgLCBiZWdpbkxpbmVTdGFydCA9IGxpbmVTdGFydFxuICAgICAgLCBzdHJpbmdTdGFydCA9IGluZGV4XG4gICAgICAsIHN0cmluZyA9IGVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncyA/IG51bGwgOiAnJ1xuICAgICAgLCBjaGFyQ29kZTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlmIChkZWxpbWl0ZXIgPT09IGNoYXJDb2RlKSBicmVhaztcbiAgICAgIC8vIEVPRiBvciBgXFxuYCB0ZXJtaW5hdGVzIGEgc3RyaW5nIGxpdGVyYWwuIElmIHdlIGhhdmVuJ3QgZm91bmQgdGhlXG4gICAgICAvLyBlbmRpbmcgZGVsaW1pdGVyIGJ5IG5vdywgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIHx8IGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpKSB7XG4gICAgICAgIHN0cmluZyArPSBpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKTtcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLnVuZmluaXNoZWRTdHJpbmcsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4IC0gMSkpO1xuICAgICAgfVxuICAgICAgaWYgKDkyID09PSBjaGFyQ29kZSkgeyAvLyBiYWNrc2xhc2hcbiAgICAgICAgaWYgKCFlbmNvZGluZ01vZGUuZGlzY2FyZFN0cmluZ3MpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlRXNjYXBlID0gaW5wdXQuc2xpY2Uoc3RyaW5nU3RhcnQsIGluZGV4IC0gMSk7XG4gICAgICAgICAgc3RyaW5nICs9IGVuY29kaW5nTW9kZS5maXh1cChiZWZvcmVFc2NhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlc2NhcGVWYWx1ZSA9IHJlYWRFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBpZiAoIWVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncylcbiAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlVmFsdWU7XG4gICAgICAgIHN0cmluZ1N0YXJ0ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZW5jb2RpbmdNb2RlLmRpc2NhcmRTdHJpbmdzKSB7XG4gICAgICBzdHJpbmcgKz0gZW5jb2RpbmdNb2RlLmVuY29kZUJ5dGUobnVsbCk7XG4gICAgICBzdHJpbmcgKz0gZW5jb2RpbmdNb2RlLmZpeHVwKGlucHV0LnNsaWNlKHN0cmluZ1N0YXJ0LCBpbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTdHJpbmdMaXRlcmFsXG4gICAgICAsIHZhbHVlOiBzdHJpbmdcbiAgICAgICwgbGluZTogYmVnaW5MaW5lXG4gICAgICAsIGxpbmVTdGFydDogYmVnaW5MaW5lU3RhcnRcbiAgICAgICwgbGFzdExpbmU6IGxpbmVcbiAgICAgICwgbGFzdExpbmVTdGFydDogbGluZVN0YXJ0XG4gICAgICAsIHJhbmdlOiBbdG9rZW5TdGFydCwgaW5kZXhdXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cGVjdCBhIG11bHRpbGluZSBzdHJpbmcgbGl0ZXJhbCBhbmQgcmV0dXJuIGl0IGFzIGEgcmVndWxhciBzdHJpbmdcbiAgLy8gbGl0ZXJhbCwgaWYgaXQgZG9lc24ndCB2YWxpZGF0ZSBpbnRvIGEgdmFsaWQgbXVsdGlsaW5lIHN0cmluZywgdGhyb3cgYW5cbiAgLy8gZXhjZXB0aW9uLlxuXG4gIGZ1bmN0aW9uIHNjYW5Mb25nU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICB2YXIgYmVnaW5MaW5lID0gbGluZVxuICAgICAgLCBiZWdpbkxpbmVTdGFydCA9IGxpbmVTdGFydFxuICAgICAgLCBzdHJpbmcgPSByZWFkTG9uZ1N0cmluZyhmYWxzZSk7XG4gICAgLy8gRmFpbCBpZiBpdCdzIG5vdCBhIG11bHRpbGluZSBsaXRlcmFsLlxuICAgIGlmIChmYWxzZSA9PT0gc3RyaW5nKSByYWlzZSh0b2tlbiwgZXJyb3JzLmV4cGVjdGVkLCAnWycsIHRva2VuVmFsdWUodG9rZW4pKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFN0cmluZ0xpdGVyYWxcbiAgICAgICwgdmFsdWU6IGVuY29kaW5nTW9kZS5kaXNjYXJkU3RyaW5ncyA/IG51bGwgOiBlbmNvZGluZ01vZGUuZml4dXAoc3RyaW5nKVxuICAgICAgLCBsaW5lOiBiZWdpbkxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBiZWdpbkxpbmVTdGFydFxuICAgICAgLCBsYXN0TGluZTogbGluZVxuICAgICAgLCBsYXN0TGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gTnVtZXJpYyBsaXRlcmFscyB3aWxsIGJlIHJldHVybmVkIGFzIGZsb2F0aW5nLXBvaW50IG51bWJlcnMgaW5zdGVhZCBvZlxuICAvLyBzdHJpbmdzLiBUaGUgcmF3IHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQgZnJvbSBzbGljaW5nIHRoZSBpbnB1dCBzdHJpbmdcbiAgLy8gbGF0ZXIgb24gaW4gdGhlIHByb2Nlc3MuXG4gIC8vXG4gIC8vIElmIGEgaGV4YWRlY2ltYWwgbnVtYmVyIGlzIGVuY291bnRlcmVkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZC5cblxuICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgdmFyIGNoYXJhY3RlciA9IGlucHV0LmNoYXJBdChpbmRleClcbiAgICAgICwgbmV4dCA9IGlucHV0LmNoYXJBdChpbmRleCArIDEpO1xuXG4gICAgdmFyIHZhbHVlID0gKCcwJyA9PT0gY2hhcmFjdGVyICYmICd4WCcuaW5kZXhPZihuZXh0IHx8IG51bGwpID49IDApID9cbiAgICAgIHJlYWRIZXhMaXRlcmFsKCkgOiByZWFkRGVjTGl0ZXJhbCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTnVtZXJpY0xpdGVyYWxcbiAgICAgICwgdmFsdWU6IHZhbHVlXG4gICAgICAsIGxpbmU6IGxpbmVcbiAgICAgICwgbGluZVN0YXJ0OiBsaW5lU3RhcnRcbiAgICAgICwgcmFuZ2U6IFt0b2tlblN0YXJ0LCBpbmRleF1cbiAgICB9O1xuICB9XG5cbiAgLy8gTHVhIGhleGFkZWNpbWFscyBoYXZlIGFuIG9wdGlvbmFsIGZyYWN0aW9uIHBhcnQgYW5kIGFuIG9wdGlvbmFsIGJpbmFyeVxuICAvLyBleG9wb25lbnQgcGFydC4gVGhlc2UgYXJlIG5vdCBpbmNsdWRlZCBpbiBKYXZhU2NyaXB0IHNvIHdlIHdpbGwgY29tcHV0ZVxuICAvLyBhbGwgdGhyZWUgcGFydHMgc2VwYXJhdGVseSBhbmQgdGhlbiBzdW0gdGhlbSB1cCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvblxuICAvLyB3aXRoIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuICAvL1xuICAvLyAgICAgRGlnaXQgOj0gdG9EZWMoZGlnaXQpXG4gIC8vICAgICBGcmFjdGlvbiA6PSB0b0RlYyhmcmFjdGlvbikgLyAxNiBeIGZyYWN0aW9uQ291bnRcbiAgLy8gICAgIEJpbmFyeUV4cCA6PSAyIF4gYmluYXJ5RXhwXG4gIC8vICAgICBOdW1iZXIgOj0gKCBEaWdpdCArIEZyYWN0aW9uICkgKiBCaW5hcnlFeHBcblxuICBmdW5jdGlvbiByZWFkSGV4TGl0ZXJhbCgpIHtcbiAgICB2YXIgZnJhY3Rpb24gPSAwIC8vIGRlZmF1bHRzIHRvIDAgYXMgaXQgZ2V0cyBzdW1tZWRcbiAgICAgICwgYmluYXJ5RXhwb25lbnQgPSAxIC8vIGRlZmF1bHRzIHRvIDEgYXMgaXQgZ2V0cyBtdWx0aXBsaWVkXG4gICAgICAsIGJpbmFyeVNpZ24gPSAxIC8vIHBvc2l0aXZlXG4gICAgICAsIGRpZ2l0LCBmcmFjdGlvblN0YXJ0LCBleHBvbmVudFN0YXJ0LCBkaWdpdFN0YXJ0O1xuXG4gICAgZGlnaXRTdGFydCA9IGluZGV4ICs9IDI7IC8vIFNraXAgMHggcGFydFxuXG4gICAgLy8gQSBtaW5pbXVtIG9mIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgaWYgKCFpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5tYWxmb3JtZWROdW1iZXIsIGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG5cbiAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgLy8gQ29udmVydCB0aGUgaGV4YWRlY2ltYWwgZGlnaXQgdG8gYmFzZSAxMC5cbiAgICBkaWdpdCA9IHBhcnNlSW50KGlucHV0LnNsaWNlKGRpZ2l0U3RhcnQsIGluZGV4KSwgMTYpO1xuXG4gICAgLy8gRnJhY3Rpb24gcGFydCBpIG9wdGlvbmFsLlxuICAgIGlmICgnLicgPT09IGlucHV0LmNoYXJBdChpbmRleCkpIHtcbiAgICAgIGZyYWN0aW9uU3RhcnQgPSArK2luZGV4O1xuXG4gICAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgICBmcmFjdGlvbiA9IGlucHV0LnNsaWNlKGZyYWN0aW9uU3RhcnQsIGluZGV4KTtcblxuICAgICAgLy8gRW1wdHkgZnJhY3Rpb24gcGFydHMgc2hvdWxkIGRlZmF1bHQgdG8gMCwgb3RoZXJzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICAgIC8vIDAueCBmb3JtIHNvIHdlIGNhbiB1c2Ugc3VtbWF0aW9uIGF0IHRoZSBlbmQuXG4gICAgICBmcmFjdGlvbiA9IChmcmFjdGlvblN0YXJ0ID09PSBpbmRleCkgPyAwXG4gICAgICAgIDogcGFyc2VJbnQoZnJhY3Rpb24sIDE2KSAvIE1hdGgucG93KDE2LCBpbmRleCAtIGZyYWN0aW9uU3RhcnQpO1xuICAgIH1cblxuICAgIC8vIEJpbmFyeSBleHBvbmVudHMgYXJlIG9wdGlvbmFsXG4gICAgaWYgKCdwUCcuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApIHtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIC8vIFNpZ24gcGFydCBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMSAocG9zaXRpdmUpLlxuICAgICAgaWYgKCcrLScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApXG4gICAgICAgIGJpbmFyeVNpZ24gPSAoJysnID09PSBpbnB1dC5jaGFyQXQoaW5kZXgrKykpID8gMSA6IC0xO1xuXG4gICAgICBleHBvbmVudFN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIC8vIFRoZSBiaW5hcnkgZXhwb25lbnQgc2lnbiByZXF1aXJlcyBhIGRlY2ltYWwgZGlnaXQuXG4gICAgICBpZiAoIWlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKVxuICAgICAgICByYWlzZShudWxsLCBlcnJvcnMubWFsZm9ybWVkTnVtYmVyLCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgICB3aGlsZSAoaXNEZWNEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpICsraW5kZXg7XG4gICAgICBiaW5hcnlFeHBvbmVudCA9IGlucHV0LnNsaWNlKGV4cG9uZW50U3RhcnQsIGluZGV4KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiaW5hcnkgZXhwb25lbnQgb2YgdGhlIG51bWJlci5cbiAgICAgIGJpbmFyeUV4cG9uZW50ID0gTWF0aC5wb3coMiwgYmluYXJ5RXhwb25lbnQgKiBiaW5hcnlTaWduKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGRpZ2l0ICsgZnJhY3Rpb24pICogYmluYXJ5RXhwb25lbnQ7XG4gIH1cblxuICAvLyBEZWNpbWFsIG51bWJlcnMgYXJlIGV4YWN0bHkgdGhlIHNhbWUgaW4gTHVhIGFuZCBpbiBKYXZhU2NyaXB0LCBiZWNhdXNlIG9mXG4gIC8vIHRoaXMgd2UgY2hlY2sgd2hlcmUgdGhlIHRva2VuIGVuZHMgYW5kIHRoZW4gcGFyc2UgaXQgd2l0aCBuYXRpdmVcbiAgLy8gZnVuY3Rpb25zLlxuXG4gIGZ1bmN0aW9uIHJlYWREZWNMaXRlcmFsKCkge1xuICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgKytpbmRleDtcbiAgICAvLyBGcmFjdGlvbiBwYXJ0IGlzIG9wdGlvbmFsXG4gICAgaWYgKCcuJyA9PT0gaW5wdXQuY2hhckF0KGluZGV4KSkge1xuICAgICAgKytpbmRleDtcbiAgICAgIC8vIEZyYWN0aW9uIHBhcnQgZGVmYXVsdHMgdG8gMFxuICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIH1cbiAgICAvLyBFeHBvbmVudCBwYXJ0IGlzIG9wdGlvbmFsLlxuICAgIGlmICgnZUUnLmluZGV4T2YoaW5wdXQuY2hhckF0KGluZGV4KSB8fCBudWxsKSA+PSAwKSB7XG4gICAgICArK2luZGV4O1xuICAgICAgLy8gU2lnbiBwYXJ0IGlzIG9wdGlvbmFsLlxuICAgICAgaWYgKCcrLScuaW5kZXhPZihpbnB1dC5jaGFyQXQoaW5kZXgpIHx8IG51bGwpID49IDApICsraW5kZXg7XG4gICAgICAvLyBBbiBleHBvbmVudCBpcyByZXF1aXJlZCB0byBjb250YWluIGF0IGxlYXN0IG9uZSBkZWNpbWFsIGRpZ2l0LlxuICAgICAgaWYgKCFpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLm1hbGZvcm1lZE51bWJlciwgaW5wdXQuc2xpY2UodG9rZW5TdGFydCwgaW5kZXgpKTtcblxuICAgICAgd2hpbGUgKGlzRGVjRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSArK2luZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KGlucHV0LnNsaWNlKHRva2VuU3RhcnQsIGluZGV4KSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVW5pY29kZUVzY2FwZVNlcXVlbmNlKCkge1xuICAgIHZhciBzZXF1ZW5jZVN0YXJ0ID0gaW5kZXgrKztcblxuICAgIGlmIChpbnB1dC5jaGFyQXQoaW5kZXgrKykgIT09ICd7JylcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5icmFjZUV4cGVjdGVkLCAneycsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG4gICAgaWYgKCFpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSlcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5oZXhhZGVjaW1hbERpZ2l0RXhwZWN0ZWQsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4KSk7XG5cbiAgICB3aGlsZSAoaW5wdXQuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MzApICsraW5kZXg7XG4gICAgdmFyIGVzY1N0YXJ0ID0gaW5kZXg7XG5cbiAgICB3aGlsZSAoaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgICBpZiAoaW5kZXggLSBlc2NTdGFydCA+IDYpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy50b29MYXJnZUNvZGVwb2ludCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGlucHV0LmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoYiAhPT0gJ30nKSB7XG4gICAgICBpZiAoKGIgPT09ICdcIicpIHx8IChiID09PSBcIidcIikpXG4gICAgICAgIHJhaXNlKG51bGwsIGVycm9ycy5icmFjZUV4cGVjdGVkLCAnfScsICdcXFxcJyArIGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQsIGluZGV4LS0pKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICB9XG5cbiAgICB2YXIgY29kZXBvaW50ID0gcGFyc2VJbnQoaW5wdXQuc2xpY2UoZXNjU3RhcnQsIGluZGV4IC0gMSkgfHwgJzAnLCAxNik7XG4gICAgdmFyIGZyYWcgPSAnXFxcXCcgKyBpbnB1dC5zbGljZShzZXF1ZW5jZVN0YXJ0LCBpbmRleCk7XG5cbiAgICBpZiAoY29kZXBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgIHJhaXNlKG51bGwsIGVycm9ycy50b29MYXJnZUNvZGVwb2ludCwgZnJhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kaW5nTW9kZS5lbmNvZGVVVEY4KGNvZGVwb2ludCwgZnJhZyk7XG4gIH1cblxuICAvLyBUcmFuc2xhdGUgZXNjYXBlIHNlcXVlbmNlcyB0byB0aGUgYWN0dWFsIGNoYXJhY3RlcnMuXG4gIGZ1bmN0aW9uIHJlYWRFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICB2YXIgc2VxdWVuY2VTdGFydCA9IGluZGV4O1xuICAgIHN3aXRjaCAoaW5wdXQuY2hhckF0KGluZGV4KSkge1xuICAgICAgLy8gTHVhIGFsbG93IHRoZSBmb2xsb3dpbmcgZXNjYXBlIHNlcXVlbmNlcy5cbiAgICAgIGNhc2UgJ2EnOiArK2luZGV4OyByZXR1cm4gJ1xceDA3JztcbiAgICAgIGNhc2UgJ24nOiArK2luZGV4OyByZXR1cm4gJ1xcbic7XG4gICAgICBjYXNlICdyJzogKytpbmRleDsgcmV0dXJuICdcXHInO1xuICAgICAgY2FzZSAndCc6ICsraW5kZXg7IHJldHVybiAnXFx0JztcbiAgICAgIGNhc2UgJ3YnOiArK2luZGV4OyByZXR1cm4gJ1xceDBiJztcbiAgICAgIGNhc2UgJ2InOiArK2luZGV4OyByZXR1cm4gJ1xcYic7XG4gICAgICBjYXNlICdmJzogKytpbmRleDsgcmV0dXJuICdcXGYnO1xuXG4gICAgICAvLyBCYWNrc2xhc2ggYXQgdGhlIGVuZCBvZiB0aGUgbGluZS4gV2UgdHJlYXQgYWxsIGxpbmUgZW5kaW5ncyBhcyBlcXVpdmFsZW50LFxuICAgICAgLy8gYW5kIGFzIHJlcHJlc2VudGluZyB0aGUgW0xGXSBjaGFyYWN0ZXIgKGNvZGUgMTApLiBMdWEgNS4xIHRocm91Z2ggNS4zXG4gICAgICAvLyBoYXZlIGJlZW4gdmVyaWZpZWQgdG8gYmVoYXZlIHRoZSBzYW1lIHdheS5cbiAgICAgIGNhc2UgJ1xccic6XG4gICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjb25zdW1lRU9MKCk7XG4gICAgICAgIHJldHVybiAnXFxuJztcblxuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICAvLyBcXGRkZCwgd2hlcmUgZGRkIGlzIGEgc2VxdWVuY2Ugb2YgdXAgdG8gdGhyZWUgZGVjaW1hbCBkaWdpdHMuXG4gICAgICAgIHdoaWxlIChpc0RlY0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSAmJiBpbmRleCAtIHNlcXVlbmNlU3RhcnQgPCAzKSArK2luZGV4O1xuXG4gICAgICAgIHZhciBmcmFnID0gaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpO1xuICAgICAgICB2YXIgZGRkID0gcGFyc2VJbnQoZnJhZywgMTApO1xuICAgICAgICBpZiAoZGRkID4gMjU1KSB7XG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmRlY2ltYWxFc2NhcGVUb29MYXJnZSwgJ1xcXFwnICsgZGRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RpbmdNb2RlLmVuY29kZUJ5dGUoZGRkLCAnXFxcXCcgKyBmcmFnKTtcblxuICAgICAgY2FzZSAneic6XG4gICAgICAgIGlmIChmZWF0dXJlcy5za2lwV2hpdGVzcGFjZUVzY2FwZSkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgc2tpcFdoaXRlU3BhY2UoKTtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3gnOlxuICAgICAgICBpZiAoZmVhdHVyZXMuaGV4RXNjYXBlcykge1xuICAgICAgICAgIC8vIFxceFhYLCB3aGVyZSBYWCBpcyBhIHNlcXVlbmNlIG9mIGV4YWN0bHkgdHdvIGhleGFkZWNpbWFsIGRpZ2l0c1xuICAgICAgICAgIGlmIChpc0hleERpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXggKyAxKSkgJiZcbiAgICAgICAgICAgICAgaXNIZXhEaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMikpKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kaW5nTW9kZS5lbmNvZGVCeXRlKHBhcnNlSW50KGlucHV0LnNsaWNlKHNlcXVlbmNlU3RhcnQgKyAxLCBpbmRleCksIDE2KSwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmFpc2UobnVsbCwgZXJyb3JzLmhleGFkZWNpbWFsRGlnaXRFeHBlY3RlZCwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXggKyAyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3UnOlxuICAgICAgICBpZiAoZmVhdHVyZXMudW5pY29kZUVzY2FwZXMpXG4gICAgICAgICAgcmV0dXJuIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1xcXFwnOiBjYXNlICdcIic6IGNhc2UgXCInXCI6XG4gICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG4gICAgfVxuXG4gICAgaWYgKGZlYXR1cmVzLnN0cmljdEVzY2FwZXMpXG4gICAgICByYWlzZShudWxsLCBlcnJvcnMuaW52YWxpZEVzY2FwZSwgJ1xcXFwnICsgaW5wdXQuc2xpY2Uoc2VxdWVuY2VTdGFydCwgaW5kZXggKyAxKSk7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJBdChpbmRleCsrKTtcbiAgfVxuXG4gIC8vIENvbW1lbnRzIGJlZ2luIHdpdGggLS0gYWZ0ZXIgd2hpY2ggaXQgd2lsbCBiZSBkZWNpZGVkIGlmIHRoZXkgYXJlXG4gIC8vIG11bHRpbGluZSBjb21tZW50cyBvciBub3QuXG4gIC8vXG4gIC8vIFRoZSBtdWx0aWxpbmUgZnVuY3Rpb25hbGl0eSB3b3JrcyB0aGUgZXhhY3Qgc2FtZSB3YXkgYXMgd2l0aCBzdHJpbmdcbiAgLy8gbGl0ZXJhbHMgc28gd2UgcmV1c2UgdGhlIGZ1bmN0aW9uYWxpdHkuXG5cbiAgZnVuY3Rpb24gc2NhbkNvbW1lbnQoKSB7XG4gICAgdG9rZW5TdGFydCA9IGluZGV4O1xuICAgIGluZGV4ICs9IDI7IC8vIC0tXG5cbiAgICB2YXIgY2hhcmFjdGVyID0gaW5wdXQuY2hhckF0KGluZGV4KVxuICAgICAgLCBjb250ZW50ID0gJydcbiAgICAgICwgaXNMb25nID0gZmFsc2VcbiAgICAgICwgY29tbWVudFN0YXJ0ID0gaW5kZXhcbiAgICAgICwgbGluZVN0YXJ0Q29tbWVudCA9IGxpbmVTdGFydFxuICAgICAgLCBsaW5lQ29tbWVudCA9IGxpbmU7XG5cbiAgICBpZiAoJ1snID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgIGNvbnRlbnQgPSByZWFkTG9uZ1N0cmluZyh0cnVlKTtcbiAgICAgIC8vIFRoaXMgd2Fzbid0IGEgbXVsdGlsaW5lIGNvbW1lbnQgYWZ0ZXIgYWxsLlxuICAgICAgaWYgKGZhbHNlID09PSBjb250ZW50KSBjb250ZW50ID0gY2hhcmFjdGVyO1xuICAgICAgZWxzZSBpc0xvbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBTY2FuIHVudGlsIG5leHQgbGluZSBhcyBsb25nIGFzIGl0J3Mgbm90IGEgbXVsdGlsaW5lIGNvbW1lbnQuXG4gICAgaWYgKCFpc0xvbmcpIHtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihpbnB1dC5jaGFyQ29kZUF0KGluZGV4KSkpIGJyZWFrO1xuICAgICAgICArK2luZGV4O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIGNvbnRlbnQgPSBpbnB1dC5zbGljZShjb21tZW50U3RhcnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jb21tZW50cykge1xuICAgICAgdmFyIG5vZGUgPSBhc3QuY29tbWVudChjb250ZW50LCBpbnB1dC5zbGljZSh0b2tlblN0YXJ0LCBpbmRleCkpO1xuXG4gICAgICAvLyBgTWFya2VyYHMgZGVwZW5kIG9uIHRva2VucyBhdmFpbGFibGUgaW4gdGhlIHBhcnNlciBhbmQgYXMgY29tbWVudHMgYXJlXG4gICAgICAvLyBpbnRlcmNlcHRlZCBpbiB0aGUgbGV4ZXIgYWxsIGxvY2F0aW9uIGRhdGEgaXMgc2V0IG1hbnVhbGx5LlxuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgIG5vZGUubG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogbGluZUNvbW1lbnQsIGNvbHVtbjogdG9rZW5TdGFydCAtIGxpbmVTdGFydENvbW1lbnQgfVxuICAgICAgICAgICwgZW5kOiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnQgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgIG5vZGUucmFuZ2UgPSBbdG9rZW5TdGFydCwgaW5kZXhdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub25DcmVhdGVOb2RlKSBvcHRpb25zLm9uQ3JlYXRlTm9kZShub2RlKTtcbiAgICAgIGNvbW1lbnRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhIG11bHRpbGluZSBzdHJpbmcgYnkgY2FsY3VsYXRpbmcgdGhlIGRlcHRoIG9mIGA9YCBjaGFyYWN0ZXJzIGFuZFxuICAvLyB0aGVuIGFwcGVuZGluZyB1bnRpbCBhbiBlcXVhbCBkZXB0aCBpcyBmb3VuZC5cblxuICBmdW5jdGlvbiByZWFkTG9uZ1N0cmluZyhpc0NvbW1lbnQpIHtcbiAgICB2YXIgbGV2ZWwgPSAwXG4gICAgICAsIGNvbnRlbnQgPSAnJ1xuICAgICAgLCB0ZXJtaW5hdG9yID0gZmFsc2VcbiAgICAgICwgY2hhcmFjdGVyLCBzdHJpbmdTdGFydCwgZmlyc3RMaW5lID0gbGluZTtcblxuICAgICsraW5kZXg7IC8vIFtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGVwdGggb2YgdGhlIGNvbW1lbnQuXG4gICAgd2hpbGUgKCc9JyA9PT0gaW5wdXQuY2hhckF0KGluZGV4ICsgbGV2ZWwpKSArK2xldmVsO1xuICAgIC8vIEV4aXQsIHRoaXMgaXMgbm90IGEgbG9uZyBzdHJpbmcgYWZ0ZXJhbGwuXG4gICAgaWYgKCdbJyAhPT0gaW5wdXQuY2hhckF0KGluZGV4ICsgbGV2ZWwpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpbmRleCArPSBsZXZlbCArIDE7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIGEgbmV3bGluZSwgaWdub3JlIGl0IGFuZCBiZWdpbiBvbiBuZXh0IGxpbmUuXG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoaW5wdXQuY2hhckNvZGVBdChpbmRleCkpKSBjb25zdW1lRU9MKCk7XG5cbiAgICBzdHJpbmdTdGFydCA9IGluZGV4O1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgLy8gVG8ga2VlcCB0cmFjayBvZiBsaW5lIG51bWJlcnMgcnVuIHRoZSBgY29uc3VtZUVPTCgpYCB3aGljaCBpbmNyZW1lbnRzXG4gICAgICAvLyBpdHMgY291bnRlci5cbiAgICAgIHdoaWxlIChpc0xpbmVUZXJtaW5hdG9yKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpKSkgY29uc3VtZUVPTCgpO1xuXG4gICAgICBjaGFyYWN0ZXIgPSBpbnB1dC5jaGFyQXQoaW5kZXgrKyk7XG5cbiAgICAgIC8vIE9uY2UgdGhlIGRlbGltaXRlciBpcyBmb3VuZCwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBkZXB0aCBjb3VudCBhbmQgc2VlXG4gICAgICAvLyBpZiBpdCBtYXRjaGVzLlxuICAgICAgaWYgKCddJyA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgIHRlcm1pbmF0b3IgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVsOyArK2kpIHtcbiAgICAgICAgICBpZiAoJz0nICE9PSBpbnB1dC5jaGFyQXQoaW5kZXggKyBpKSkgdGVybWluYXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnXScgIT09IGlucHV0LmNoYXJBdChpbmRleCArIGxldmVsKSkgdGVybWluYXRvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG11bHRpbGluZSBzdHJpbmcuIEdldCBvdXQgbm93LlxuICAgICAgaWYgKHRlcm1pbmF0b3IpIHtcbiAgICAgICAgY29udGVudCArPSBpbnB1dC5zbGljZShzdHJpbmdTdGFydCwgaW5kZXggLSAxKTtcbiAgICAgICAgaW5kZXggKz0gbGV2ZWwgKyAxO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZShudWxsLCBpc0NvbW1lbnQgP1xuICAgICAgICAgICAgICAgIGVycm9ycy51bmZpbmlzaGVkTG9uZ0NvbW1lbnQgOlxuICAgICAgICAgICAgICAgIGVycm9ycy51bmZpbmlzaGVkTG9uZ1N0cmluZyxcbiAgICAgICAgICBmaXJzdExpbmUsICc8ZW9mPicpO1xuICB9XG5cbiAgLy8gIyMgTGV4IGZ1bmN0aW9ucyBhbmQgaGVscGVycy5cblxuICAvLyBSZWFkIHRoZSBuZXh0IHRva2VuLlxuICAvL1xuICAvLyBUaGlzIGlzIGFjdHVhbGx5IGRvbmUgYnkgc2V0dGluZyB0aGUgY3VycmVudCB0b2tlbiB0byB0aGUgbG9va2FoZWFkIGFuZFxuICAvLyByZWFkaW5nIGluIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuLlxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgIGxvb2thaGVhZCA9IGxleCgpO1xuICB9XG5cbiAgLy8gQ29uc3VtZSBhIHRva2VuIGlmIGl0cyB2YWx1ZSBtYXRjaGVzLiBPbmNlIGNvbnN1bWVkIG9yIG5vdCwgcmV0dXJuIHRoZVxuICAvLyBzdWNjZXNzIG9mIHRoZSBvcGVyYXRpb24uXG5cbiAgZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdmFsdWUgdG8gbWF0Y2guIElmIG5vdCwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdG9rZW4udmFsdWUpIG5leHQoKTtcbiAgICBlbHNlIHJhaXNlKHRva2VuLCBlcnJvcnMuZXhwZWN0ZWQsIHZhbHVlLCB0b2tlblZhbHVlKHRva2VuKSk7XG4gIH1cblxuICAvLyAjIyMgVmFsaWRhdGlvbiBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gOSA9PT0gY2hhckNvZGUgfHwgMzIgPT09IGNoYXJDb2RlIHx8IDB4QiA9PT0gY2hhckNvZGUgfHwgMHhDID09PSBjaGFyQ29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gMTAgPT09IGNoYXJDb2RlIHx8IDEzID09PSBjaGFyQ29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjRGlnaXQoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTc7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykgfHwgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMikgfHwgKGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKTtcbiAgfVxuXG4gIC8vIEZyb20gW0x1YSA1LjJdKGh0dHA6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4yL21hbnVhbC5odG1sIzguMSkgb253YXJkc1xuICAvLyBpZGVudGlmaWVycyBjYW5ub3QgdXNlICdsb2NhbGUtZGVwZW5kZW50JyBsZXR0ZXJzIChpLmUuIGRlcGVuZGVudCBvbiB0aGUgQyBsb2NhbGUpLlxuICAvLyBPbiB0aGUgb3RoZXIgaGFuZCwgTHVhSklUIGFsbG93cyBhcmJpdHJhcnkgb2N0ZXRzIOKJpSAxMjggaW4gaWRlbnRpZmllcnMuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2hhckNvZGUpIHtcbiAgICBpZiAoKGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwKSB8fCAoY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyKSB8fCA5NSA9PT0gY2hhckNvZGUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZmVhdHVyZXMuZXh0ZW5kZWRJZGVudGlmaWVycyAmJiBjaGFyQ29kZSA+PSAxMjgpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoYXJDb2RlKSB7XG4gICAgaWYgKChjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA5MCkgfHwgKGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMikgfHwgOTUgPT09IGNoYXJDb2RlIHx8IChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZmVhdHVyZXMuZXh0ZW5kZWRJZGVudGlmaWVycyAmJiBjaGFyQ29kZSA+PSAxMjgpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBbMy4xIExleGljYWwgQ29udmVudGlvbnNdKGh0dHA6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4yL21hbnVhbC5odG1sIzMuMSlcbiAgLy9cbiAgLy8gYHRydWVgLCBgZmFsc2VgIGFuZCBgbmlsYCB3aWxsIG5vdCBiZSBjb25zaWRlcmVkIGtleXdvcmRzLCBidXQgbGl0ZXJhbHMuXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuICdkbycgPT09IGlkIHx8ICdpZicgPT09IGlkIHx8ICdpbicgPT09IGlkIHx8ICdvcicgPT09IGlkO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gJ2FuZCcgPT09IGlkIHx8ICdlbmQnID09PSBpZCB8fCAnZm9yJyA9PT0gaWQgfHwgJ25vdCcgPT09IGlkO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBpZiAoJ2Vsc2UnID09PSBpZCB8fCAndGhlbicgPT09IGlkKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZmVhdHVyZXMubGFiZWxzICYmICFmZWF0dXJlcy5jb250ZXh0dWFsR290bylcbiAgICAgICAgICByZXR1cm4gKCdnb3RvJyA9PT0gaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiAnYnJlYWsnID09PSBpZCB8fCAnbG9jYWwnID09PSBpZCB8fCAndW50aWwnID09PSBpZCB8fCAnd2hpbGUnID09PSBpZDtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuICdlbHNlaWYnID09PSBpZCB8fCAncmVwZWF0JyA9PT0gaWQgfHwgJ3JldHVybicgPT09IGlkO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PT0gaWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5hcnkodG9rZW4pIHtcbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkgcmV0dXJuICcjLX4nLmluZGV4T2YodG9rZW4udmFsdWUpID49IDA7XG4gICAgaWYgKEtleXdvcmQgPT09IHRva2VuLnR5cGUpIHJldHVybiAnbm90JyA9PT0gdG9rZW4udmFsdWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIHRva2VuIHN5bnRhY3RpY2FsbHkgY2xvc2VzIGEgYmxvY2suXG5cbiAgZnVuY3Rpb24gaXNCbG9ja0ZvbGxvdyh0b2tlbikge1xuICAgIGlmIChFT0YgPT09IHRva2VuLnR5cGUpIHJldHVybiB0cnVlO1xuICAgIGlmIChLZXl3b3JkICE9PSB0b2tlbi50eXBlKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgY2FzZSAnZWxzZSc6IGNhc2UgJ2Vsc2VpZic6XG4gICAgICBjYXNlICdlbmQnOiBjYXNlICd1bnRpbCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjb3BlXG4gIC8vIC0tLS0tXG5cbiAgLy8gU3RvcmUgZWFjaCBibG9jayBzY29wZSBhcyBhIGFuIGFycmF5IG9mIGlkZW50aWZpZXIgbmFtZXMuIEVhY2ggc2NvcGUgaXNcbiAgLy8gc3RvcmVkIGluIGFuIEZJTE8tYXJyYXkuXG4gIHZhciBzY29wZXNcbiAgICAvLyBUaGUgY3VycmVudCBzY29wZSBpbmRleFxuICAgICwgc2NvcGVEZXB0aFxuICAgIC8vIEEgbGlzdCBvZiBhbGwgZ2xvYmFsIGlkZW50aWZpZXIgbm9kZXMuXG4gICAgLCBnbG9iYWxzO1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBzY29wZSBpbmhlcml0aW5nIGFsbCBkZWNsYXJhdGlvbnMgZnJvbSB0aGUgcHJldmlvdXMgc2NvcGUuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKCkge1xuICAgIHZhciBzY29wZSA9IEFycmF5LmFwcGx5KG51bGwsIHNjb3Blc1tzY29wZURlcHRoKytdKTtcbiAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgaWYgKG9wdGlvbnMub25DcmVhdGVTY29wZSkgb3B0aW9ucy5vbkNyZWF0ZVNjb3BlKCk7XG4gIH1cblxuICAvLyBFeGl0IGFuZCByZW1vdmUgdGhlIGN1cnJlbnQgc2NvcGUuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lTY29wZSgpIHtcbiAgICB2YXIgc2NvcGUgPSBzY29wZXMucG9wKCk7XG4gICAgLS1zY29wZURlcHRoO1xuICAgIGlmIChvcHRpb25zLm9uRGVzdHJveVNjb3BlKSBvcHRpb25zLm9uRGVzdHJveVNjb3BlKCk7XG4gIH1cblxuICAvLyBBZGQgaWRlbnRpZmllciBuYW1lIHRvIHRoZSBjdXJyZW50IHNjb3BlIGlmIGl0IGRvZXNudCBhbHJlYWR5IGV4aXN0LlxuICBmdW5jdGlvbiBzY29wZUlkZW50aWZpZXJOYW1lKG5hbWUpIHtcbiAgICBpZiAob3B0aW9ucy5vbkxvY2FsRGVjbGFyYXRpb24pIG9wdGlvbnMub25Mb2NhbERlY2xhcmF0aW9uKG5hbWUpO1xuICAgIGlmICgtMSAhPT0gaW5kZXhPZihzY29wZXNbc2NvcGVEZXB0aF0sIG5hbWUpKSByZXR1cm47XG4gICAgc2NvcGVzW3Njb3BlRGVwdGhdLnB1c2gobmFtZSk7XG4gIH1cblxuICAvLyBBZGQgaWRlbnRpZmllciB0byB0aGUgY3VycmVudCBzY29wZVxuICBmdW5jdGlvbiBzY29wZUlkZW50aWZpZXIobm9kZSkge1xuICAgIHNjb3BlSWRlbnRpZmllck5hbWUobm9kZS5uYW1lKTtcbiAgICBhdHRhY2hTY29wZShub2RlLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBzY29wZSBpbmZvcm1hdGlvbiB0byBub2RlLiBJZiB0aGUgbm9kZSBpcyBnbG9iYWwsIHN0b3JlIGl0IGluIHRoZVxuICAvLyBnbG9iYWxzIGFycmF5IHNvIHdlIGNhbiByZXR1cm4gdGhlIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICBmdW5jdGlvbiBhdHRhY2hTY29wZShub2RlLCBpc0xvY2FsKSB7XG4gICAgaWYgKCFpc0xvY2FsICYmIC0xID09PSBpbmRleE9mT2JqZWN0KGdsb2JhbHMsICduYW1lJywgbm9kZS5uYW1lKSlcbiAgICAgIGdsb2JhbHMucHVzaChub2RlKTtcblxuICAgIG5vZGUuaXNMb2NhbCA9IGlzTG9jYWw7XG4gIH1cblxuICAvLyBJcyB0aGUgaWRlbnRpZmllciBuYW1lIGF2YWlsYWJsZSBpbiB0aGlzIHNjb3BlLlxuICBmdW5jdGlvbiBzY29wZUhhc05hbWUobmFtZSkge1xuICAgIHJldHVybiAoLTEgIT09IGluZGV4T2Yoc2NvcGVzW3Njb3BlRGVwdGhdLCBuYW1lKSk7XG4gIH1cblxuICAvLyBMb2NhdGlvbiB0cmFja2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBMb2NhdGlvbnMgYXJlIHN0b3JlZCBpbiBGSUxPLWFycmF5IGFzIGEgYE1hcmtlcmAgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgYm90aFxuICAvLyBgbG9jYCBhbmQgYHJhbmdlYCBkYXRhLiBPbmNlIGEgYE1hcmtlcmAgaXMgcG9wcGVkIG9mZiB0aGUgbGlzdCBhbiBlbmRcbiAgLy8gbG9jYXRpb24gaXMgYWRkZWQgYW5kIHRoZSBkYXRhIGlzIGF0dGFjaGVkIHRvIGEgc3ludGF4IG5vZGUuXG5cbiAgdmFyIGxvY2F0aW9ucyA9IFtdXG4gICAgLCB0cmFja0xvY2F0aW9ucztcblxuICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbk1hcmtlcigpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtlcih0b2tlbik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXJrZXIodG9rZW4pIHtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHRoaXMubG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBsaW5lOiB0b2tlbi5saW5lXG4gICAgICAgICAgLCBjb2x1bW46IHRva2VuLnJhbmdlWzBdIC0gdG9rZW4ubGluZVN0YXJ0XG4gICAgICAgIH1cbiAgICAgICAgLCBlbmQ6IHtcbiAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAsIGNvbHVtbjogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpIHRoaXMucmFuZ2UgPSBbdG9rZW4ucmFuZ2VbMF0sIDBdO1xuICB9XG5cbiAgLy8gQ29tcGxldGUgdGhlIGxvY2F0aW9uIGRhdGEgc3RvcmVkIGluIHRoZSBgTWFya2VyYCBieSBhZGRpbmcgdGhlIGxvY2F0aW9uXG4gIC8vIG9mIHRoZSAqcHJldmlvdXMgdG9rZW4qIGFzIGFuIGVuZCBsb2NhdGlvbi5cbiAgTWFya2VyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgdGhpcy5sb2MuZW5kLmxpbmUgPSBwcmV2aW91c1Rva2VuLmxhc3RMaW5lIHx8IHByZXZpb3VzVG9rZW4ubGluZTtcbiAgICAgIHRoaXMubG9jLmVuZC5jb2x1bW4gPSBwcmV2aW91c1Rva2VuLnJhbmdlWzFdIC0gKHByZXZpb3VzVG9rZW4ubGFzdExpbmVTdGFydCB8fCBwcmV2aW91c1Rva2VuLmxpbmVTdGFydCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcykge1xuICAgICAgdGhpcy5yYW5nZVsxXSA9IHByZXZpb3VzVG9rZW4ucmFuZ2VbMV07XG4gICAgfVxuICB9O1xuXG4gIE1hcmtlci5wcm90b3R5cGUuYmxlc3MgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICh0aGlzLmxvYykge1xuICAgICAgdmFyIGxvYyA9IHRoaXMubG9jO1xuICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogbG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsb2Muc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGxpbmU6IGxvYy5lbmQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGxvYy5lbmQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLnJhbmdlKSB7XG4gICAgICBub2RlLnJhbmdlID0gW1xuICAgICAgICB0aGlzLnJhbmdlWzBdLFxuICAgICAgICB0aGlzLnJhbmdlWzFdXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgYE1hcmtlcmAgYW5kIGFkZCBpdCB0byB0aGUgRklMTy1hcnJheS5cbiAgZnVuY3Rpb24gbWFya0xvY2F0aW9uKCkge1xuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnB1c2goY3JlYXRlTG9jYXRpb25NYXJrZXIoKSk7XG4gIH1cblxuICAvLyBQdXNoIGFuIGFyYml0cmFyeSBgTWFya2VyYCBvYmplY3Qgb250byB0aGUgRklMTy1hcnJheS5cbiAgZnVuY3Rpb24gcHVzaExvY2F0aW9uKG1hcmtlcikge1xuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgfVxuXG4gIC8vIENvbnRyb2wgZmxvdyB0cmFja2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQSBjb250ZXh0IG9iamVjdCB0aGF0IHZhbGlkYXRlcyBsb29wIGJyZWFrcyBhbmQgYGdvdG9gLWJhc2VkIGNvbnRyb2wgZmxvdy5cblxuICBmdW5jdGlvbiBGdWxsRmxvd0NvbnRleHQoKSB7XG4gICAgdGhpcy5zY29wZXMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdHb3RvcyA9IFtdO1xuICB9XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5pc0luTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuc2NvcGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSAtLT4gMCkge1xuICAgICAgaWYgKHRoaXMuc2NvcGVzW2ldLmlzTG9vcClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLnB1c2hTY29wZSA9IGZ1bmN0aW9uIChpc0xvb3ApIHtcbiAgICB2YXIgc2NvcGUgPSB7XG4gICAgICBsYWJlbHM6IHt9LFxuICAgICAgbG9jYWxzOiBbXSxcbiAgICAgIGRlZmVycmVkR290b3M6IFtdLFxuICAgICAgaXNMb29wOiAhIWlzTG9vcFxuICAgIH07XG4gICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0dvdG9zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdGhlR290byA9IHRoaXMucGVuZGluZ0dvdG9zW2ldO1xuICAgICAgaWYgKHRoZUdvdG8ubWF4RGVwdGggPj0gdGhpcy5zY29wZXMubGVuZ3RoKVxuICAgICAgICBpZiAoLS10aGVHb3RvLm1heERlcHRoIDw9IDApXG4gICAgICAgICAgcmFpc2UodGhlR290by50b2tlbiwgZXJyb3JzLmxhYmVsTm90VmlzaWJsZSwgdGhlR290by50YXJnZXQpO1xuICAgIH1cblxuICAgIHRoaXMuc2NvcGVzLnBvcCgpO1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkR290byA9IGZ1bmN0aW9uICh0YXJnZXQsIHRva2VuKSB7XG4gICAgdmFyIGxvY2FsQ291bnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2NvcGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3Blc1tpXTtcbiAgICAgIGxvY2FsQ291bnRzLnB1c2goc2NvcGUubG9jYWxzLmxlbmd0aCk7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjb3BlLmxhYmVscywgdGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0dvdG9zLnB1c2goe1xuICAgICAgbWF4RGVwdGg6IHRoaXMuc2NvcGVzLmxlbmd0aCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgbG9jYWxDb3VudHM6IGxvY2FsQ291bnRzXG4gICAgfSk7XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMYWJlbCA9IGZ1bmN0aW9uIChuYW1lLCB0b2tlbikge1xuICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjb3BlLmxhYmVscywgbmFtZSkpIHtcbiAgICAgIHJhaXNlKHRva2VuLCBlcnJvcnMubGFiZWxBbHJlYWR5RGVmaW5lZCwgbmFtZSwgc2NvcGUubGFiZWxzW25hbWVdLmxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3R290b3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdHb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdGhlR290byA9IHRoaXMucGVuZGluZ0dvdG9zW2ldO1xuXG4gICAgICAgIGlmICh0aGVHb3RvLm1heERlcHRoID49IHRoaXMuc2NvcGVzLmxlbmd0aCAmJiB0aGVHb3RvLnRhcmdldCA9PT0gbmFtZSkge1xuICAgICAgICAgIGlmICh0aGVHb3RvLmxvY2FsQ291bnRzW3RoaXMuc2NvcGVzLmxlbmd0aCAtIDFdIDwgc2NvcGUubG9jYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2NvcGUuZGVmZXJyZWRHb3Rvcy5wdXNoKHRoZUdvdG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0dvdG9zLnB1c2godGhlR290byk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGVuZGluZ0dvdG9zID0gbmV3R290b3M7XG4gICAgfVxuXG4gICAgc2NvcGUubGFiZWxzW25hbWVdID0ge1xuICAgICAgbG9jYWxDb3VudDogc2NvcGUubG9jYWxzLmxlbmd0aCxcbiAgICAgIGxpbmU6IHRva2VuLmxpbmVcbiAgICB9O1xuICB9O1xuXG4gIEZ1bGxGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTG9jYWwgPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4pIHtcbiAgICB0aGlzLmN1cnJlbnRTY29wZSgpLmxvY2Fscy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0b2tlbjogdG9rZW5cbiAgICB9KTtcbiAgfTtcblxuICBGdWxsRmxvd0NvbnRleHQucHJvdG90eXBlLmN1cnJlbnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZXNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV07XG4gIH07XG5cbiAgRnVsbEZsb3dDb250ZXh0LnByb3RvdHlwZS5yYWlzZURlZmVycmVkRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgdmFyIGJhZHMgPSBzY29wZS5kZWZlcnJlZEdvdG9zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFkcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHRoZUdvdG8gPSBiYWRzW2ldO1xuICAgICAgcmFpc2UodGhlR290by50b2tlbiwgZXJyb3JzLmdvdG9KdW1wSW5Mb2NhbFNjb3BlLCB0aGVHb3RvLnRhcmdldCwgc2NvcGUubG9jYWxzW3RoZUdvdG8ubG9jYWxDb3VudHNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV1dLm5hbWUpO1xuICAgIH1cbiAgICAvLyBXb3VsZCBiZSBkZWFkIGNvZGUgY3VycmVudGx5LCBidXQgbWF5IGJlIHVzZWZ1bCBsYXRlclxuICAgIC8vIGlmIChiYWRzLmxlbmd0aClcbiAgICAvLyAgIHNjb3BlLmRlZmVycmVkR290b3MgPSBbXTtcbiAgfTtcblxuICAvLyBTaW1wbGlmaWVkIGNvbnRleHQgdGhhdCBvbmx5IGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgbG9vcCBicmVha3MuXG5cbiAgZnVuY3Rpb24gTG9vcEZsb3dDb250ZXh0KCkge1xuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIHRoaXMubG9vcExldmVscyA9IFtdO1xuICB9XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5pc0luTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmxvb3BMZXZlbHMubGVuZ3RoO1xuICB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUucHVzaFNjb3BlID0gZnVuY3Rpb24gKGlzTG9vcCkge1xuICAgICsrdGhpcy5sZXZlbDtcbiAgICBpZiAoaXNMb29wKVxuICAgICAgdGhpcy5sb29wTGV2ZWxzLnB1c2godGhpcy5sZXZlbCk7XG4gIH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5wb3BTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGV2ZWxzID0gdGhpcy5sb29wTGV2ZWxzO1xuICAgIHZhciBsZXZsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGlmIChsZXZsZW4pIHtcbiAgICAgIGlmIChsZXZlbHNbbGV2bGVuIC0gMV0gPT09IHRoaXMubGV2ZWwpXG4gICAgICAgIGxldmVscy5wb3AoKTtcbiAgICB9XG4gICAgLS10aGlzLmxldmVsO1xuICB9O1xuXG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkR290byA9XG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUuYWRkTGFiZWwgPVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuJyk7IH07XG5cbiAgTG9vcEZsb3dDb250ZXh0LnByb3RvdHlwZS5hZGRMb2NhbCA9XG4gIExvb3BGbG93Q29udGV4dC5wcm90b3R5cGUucmFpc2VEZWZlcnJlZEVycm9ycyA9XG4gIGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIG1ha2VGbG93Q29udGV4dCgpIHtcbiAgICByZXR1cm4gZmVhdHVyZXMubGFiZWxzID8gbmV3IEZ1bGxGbG93Q29udGV4dCgpIDogbmV3IExvb3BGbG93Q29udGV4dCgpO1xuICB9XG5cbiAgLy8gUGFyc2UgZnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIENodW5rIGlzIHRoZSBtYWluIHByb2dyYW0gb2JqZWN0LiBTeW50YWN0aWNhbGx5IGl0J3MgdGhlIHNhbWUgYXMgYSBibG9jay5cbiAgLy9cbiAgLy8gICAgIGNodW5rIDo6PSBibG9ja1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ2h1bmsoKSB7XG4gICAgbmV4dCgpO1xuICAgIG1hcmtMb2NhdGlvbigpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIHZhciBmbG93Q29udGV4dCA9IG1ha2VGbG93Q29udGV4dCgpO1xuICAgIGZsb3dDb250ZXh0LmFsbG93VmFyYXJnID0gdHJ1ZTtcbiAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUoKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGlmIChFT0YgIT09IHRva2VuLnR5cGUpIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgIC8vIElmIHRoZSBib2R5IGlzIGVtcHR5IG5vIHByZXZpb3VzVG9rZW4gZXhpc3RzIHdoZW4gZmluaXNoTm9kZSBydW5zLlxuICAgIGlmICh0cmFja0xvY2F0aW9ucyAmJiAhYm9keS5sZW5ndGgpIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuY2h1bmsoYm9keSkpO1xuICB9XG5cbiAgLy8gQSBibG9jayBjb250YWlucyBhIGxpc3Qgb2Ygc3RhdGVtZW50cyB3aXRoIGFuIG9wdGlvbmFsIHJldHVybiBzdGF0ZW1lbnRcbiAgLy8gYXMgaXRzIGxhc3Qgc3RhdGVtZW50LlxuICAvL1xuICAvLyAgICAgYmxvY2sgOjo9IHtzdGF0fSBbcmV0c3RhdF1cblxuICBmdW5jdGlvbiBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGJsb2NrID0gW11cbiAgICAgICwgc3RhdGVtZW50O1xuXG4gICAgd2hpbGUgKCFpc0Jsb2NrRm9sbG93KHRva2VuKSkge1xuICAgICAgLy8gUmV0dXJuIGhhcyB0byBiZSB0aGUgbGFzdCBzdGF0ZW1lbnQgaW4gYSBibG9jay5cbiAgICAgIC8vIExpa2V3aXNlICdicmVhaycgaW4gTHVhIG9sZGVyIHRoYW4gNS4yXG4gICAgICBpZiAoJ3JldHVybicgPT09IHRva2VuLnZhbHVlIHx8ICghZmVhdHVyZXMucmVsYXhlZEJyZWFrICYmICdicmVhaycgPT09IHRva2VuLnZhbHVlKSkge1xuICAgICAgICBibG9jay5wdXNoKHBhcnNlU3RhdGVtZW50KGZsb3dDb250ZXh0KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgY29uc3VtZSgnOycpO1xuICAgICAgLy8gU3RhdGVtZW50cyBhcmUgb25seSBhZGRlZCBpZiB0aGV5IGFyZSByZXR1cm5lZCwgdGhpcyBhbGxvd3MgdXMgdG9cbiAgICAgIC8vIGlnbm9yZSBzb21lIHN0YXRlbWVudHMsIHN1Y2ggYXMgRW1wdHlTdGF0ZW1lbnQuXG4gICAgICBpZiAoc3RhdGVtZW50KSBibG9jay5wdXNoKHN0YXRlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRG9lc24ndCByZWFsbHkgbmVlZCBhbiBhc3Qgbm9kZVxuICAgIHJldHVybiBibG9jaztcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSB0d28gdHlwZXMgb2Ygc3RhdGVtZW50cywgc2ltcGxlIGFuZCBjb21wb3VuZC5cbiAgLy9cbiAgLy8gICAgIHN0YXRlbWVudCA6Oj0gYnJlYWsgfCBnb3RvIHwgZG8gfCB3aGlsZSB8IHJlcGVhdCB8IHJldHVyblxuICAvLyAgICAgICAgICB8IGlmIHwgZm9yIHwgZnVuY3Rpb24gfCBsb2NhbCB8IGxhYmVsIHwgYXNzaWdubWVudFxuICAvLyAgICAgICAgICB8IGZ1bmN0aW9uY2FsbCB8ICc7J1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgbWFya0xvY2F0aW9uKCk7XG5cbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgaWYgKGNvbnN1bWUoJzo6JykpIHJldHVybiBwYXJzZUxhYmVsU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGEgYDtgIGlzIGVuY291bnRlZCwgc2ltcGx5IGVhdCBpdCB3aXRob3V0IHN0b3JpbmcgaXQuXG4gICAgaWYgKGZlYXR1cmVzLmVtcHR5U3RhdGVtZW50KSB7XG4gICAgICBpZiAoY29uc3VtZSgnOycpKSB7XG4gICAgICAgIGlmICh0cmFja0xvY2F0aW9ucykgbG9jYXRpb25zLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmxvd0NvbnRleHQucmFpc2VEZWZlcnJlZEVycm9ycygpO1xuXG4gICAgaWYgKEtleXdvcmQgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbG9jYWwnOiAgICBuZXh0KCk7IHJldHVybiBwYXJzZUxvY2FsU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAnaWYnOiAgICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUlmU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAncmV0dXJuJzogICBuZXh0KCk7IHJldHVybiBwYXJzZVJldHVyblN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzogbmV4dCgpO1xuICAgICAgICAgIHZhciBuYW1lID0gcGFyc2VGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKG5hbWUpO1xuICAgICAgICBjYXNlICd3aGlsZSc6ICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICdmb3InOiAgICAgIG5leHQoKTsgcmV0dXJuIHBhcnNlRm9yU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgICAgY2FzZSAncmVwZWF0JzogICBuZXh0KCk7IHJldHVybiBwYXJzZVJlcGVhdFN0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2JyZWFrJzogICAgbmV4dCgpO1xuICAgICAgICAgIGlmICghZmxvd0NvbnRleHQuaXNJbkxvb3AoKSlcbiAgICAgICAgICAgIHJhaXNlKHRva2VuLCBlcnJvcnMubm9Mb29wVG9CcmVhaywgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUJyZWFrU3RhdGVtZW50KCk7XG4gICAgICAgIGNhc2UgJ2RvJzogICAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VEb1N0YXRlbWVudChmbG93Q29udGV4dCk7XG4gICAgICAgIGNhc2UgJ2dvdG8nOiAgICAgbmV4dCgpOyByZXR1cm4gcGFyc2VHb3RvU3RhdGVtZW50KGZsb3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmVhdHVyZXMuY29udGV4dHVhbEdvdG8gJiZcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gSWRlbnRpZmllciAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dvdG8nICYmXG4gICAgICAgIGxvb2thaGVhZC50eXBlID09PSBJZGVudGlmaWVyICYmIGxvb2thaGVhZC52YWx1ZSAhPT0gJ2dvdG8nKSB7XG4gICAgICBuZXh0KCk7IHJldHVybiBwYXJzZUdvdG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbm1lbnRzIG1lbW9yaXplcyB0aGUgbG9jYXRpb24gYW5kIHB1c2hlcyBpdCBtYW51YWxseSBmb3Igd3JhcHBlciBub2Rlcy5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIGxvY2F0aW9ucy5wb3AoKTtcblxuICAgIHJldHVybiBwYXJzZUFzc2lnbm1lbnRPckNhbGxTdGF0ZW1lbnQoZmxvd0NvbnRleHQpO1xuICB9XG5cbiAgLy8gIyMgU3RhdGVtZW50c1xuXG4gIC8vICAgICBsYWJlbCA6Oj0gJzo6JyBOYW1lICc6OidcblxuICBmdW5jdGlvbiBwYXJzZUxhYmVsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG5hbWVUb2tlbiA9IHRva2VuXG4gICAgICAsIGxhYmVsID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgc2NvcGVJZGVudGlmaWVyTmFtZSgnOjonICsgbmFtZVRva2VuLnZhbHVlICsgJzo6Jyk7XG4gICAgICBhdHRhY2hTY29wZShsYWJlbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwZWN0KCc6OicpO1xuXG4gICAgZmxvd0NvbnRleHQuYWRkTGFiZWwobmFtZVRva2VuLnZhbHVlLCBuYW1lVG9rZW4pO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5sYWJlbFN0YXRlbWVudChsYWJlbCkpO1xuICB9XG5cbiAgLy8gICAgIGJyZWFrIDo6PSAnYnJlYWsnXG5cbiAgZnVuY3Rpb24gcGFyc2VCcmVha1N0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuYnJlYWtTdGF0ZW1lbnQoKSk7XG4gIH1cblxuICAvLyAgICAgZ290byA6Oj0gJ2dvdG8nIE5hbWVcblxuICBmdW5jdGlvbiBwYXJzZUdvdG9TdGF0ZW1lbnQoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgbmFtZSA9IHRva2VuLnZhbHVlXG4gICAgICAsIGdvdG9Ub2tlbiA9IHByZXZpb3VzVG9rZW5cbiAgICAgICwgbGFiZWwgPSBwYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIGZsb3dDb250ZXh0LmFkZEdvdG8obmFtZSwgZ290b1Rva2VuKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZ290b1N0YXRlbWVudChsYWJlbCkpO1xuICB9XG5cbiAgLy8gICAgIGRvIDo6PSAnZG8nIGJsb2NrICdlbmQnXG5cbiAgZnVuY3Rpb24gcGFyc2VEb1N0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgIHZhciBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZG9TdGF0ZW1lbnQoYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHdoaWxlIDo6PSAnd2hpbGUnIGV4cCAnZG8nIGJsb2NrICdlbmQnXG5cbiAgZnVuY3Rpb24gcGFyc2VXaGlsZVN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgZXhwZWN0KCdkbycpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgIGV4cGVjdCgnZW5kJyk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LndoaWxlU3RhdGVtZW50KGNvbmRpdGlvbiwgYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHJlcGVhdCA6Oj0gJ3JlcGVhdCcgYmxvY2sgJ3VudGlsJyBleHBcblxuICBmdW5jdGlvbiBwYXJzZVJlcGVhdFN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSh0cnVlKTtcbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGV4cGVjdCgndW50aWwnKTtcbiAgICBmbG93Q29udGV4dC5yYWlzZURlZmVycmVkRXJyb3JzKCk7XG4gICAgdmFyIGNvbmRpdGlvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QucmVwZWF0U3RhdGVtZW50KGNvbmRpdGlvbiwgYm9keSkpO1xuICB9XG5cbiAgLy8gICAgIHJldHN0YXQgOjo9ICdyZXR1cm4nIFtleHAgeycsJyBleHB9XSBbJzsnXVxuXG4gIGZ1bmN0aW9uIHBhcnNlUmV0dXJuU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG5cbiAgICBpZiAoJ2VuZCcgIT09IHRva2VuLnZhbHVlKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBpZiAobnVsbCAhPSBleHByZXNzaW9uKSBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgd2hpbGUgKGNvbnN1bWUoJywnKSkge1xuICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3VtZSgnOycpOyAvLyBncmFtbWFyIHRlbGxzIHVzIDsgaXMgb3B0aW9uYWwgaGVyZS5cbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnJldHVyblN0YXRlbWVudChleHByZXNzaW9ucykpO1xuICB9XG5cbiAgLy8gICAgIGlmIDo6PSAnaWYnIGV4cCAndGhlbicgYmxvY2sge2VsaWZ9IFsnZWxzZScgYmxvY2tdICdlbmQnXG4gIC8vICAgICBlbGlmIDo6PSAnZWxzZWlmJyBleHAgJ3RoZW4nIGJsb2NrXG5cbiAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciBjbGF1c2VzID0gW11cbiAgICAgICwgY29uZGl0aW9uXG4gICAgICAsIGJvZHlcbiAgICAgICwgbWFya2VyO1xuXG4gICAgLy8gSWZDbGF1c2VzIGJlZ2luIGF0IHRoZSBzYW1lIGxvY2F0aW9uIGFzIHRoZSBwYXJlbnQgSWZTdGF0ZW1lbnQuXG4gICAgLy8gSXQgZW5kcyBhdCB0aGUgc3RhcnQgb2YgYGVuZGAsIGBlbHNlYCwgb3IgYGVsc2VpZmAuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICBtYXJrZXIgPSBsb2NhdGlvbnNbbG9jYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb25zLnB1c2gobWFya2VyKTtcbiAgICB9XG4gICAgY29uZGl0aW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGV4cGVjdCgndGhlbicpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgIGJvZHkgPSBwYXJzZUJsb2NrKGZsb3dDb250ZXh0KTtcbiAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICBjbGF1c2VzLnB1c2goZmluaXNoTm9kZShhc3QuaWZDbGF1c2UoY29uZGl0aW9uLCBib2R5KSkpO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuICAgIHdoaWxlIChjb25zdW1lKCdlbHNlaWYnKSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBjb25kaXRpb24gPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBleHBlY3QoJ3RoZW4nKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBjcmVhdGVTY29wZSgpO1xuICAgICAgZmxvd0NvbnRleHQucHVzaFNjb3BlKCk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGRlc3Ryb3lTY29wZSgpO1xuICAgICAgY2xhdXNlcy5wdXNoKGZpbmlzaE5vZGUoYXN0LmVsc2VpZkNsYXVzZShjb25kaXRpb24sIGJvZHkpKSk7XG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWUoJ2Vsc2UnKSkge1xuICAgICAgLy8gSW5jbHVkZSB0aGUgYGVsc2VgIGluIHRoZSBsb2NhdGlvbiBvZiBFbHNlQ2xhdXNlLlxuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSB7XG4gICAgICAgIG1hcmtlciA9IG5ldyBNYXJrZXIocHJldmlvdXNUb2tlbik7XG4gICAgICAgIGxvY2F0aW9ucy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuICAgICAgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgICAgZmxvd0NvbnRleHQucG9wU2NvcGUoKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcbiAgICAgIGNsYXVzZXMucHVzaChmaW5pc2hOb2RlKGFzdC5lbHNlQ2xhdXNlKGJvZHkpKSk7XG4gICAgfVxuXG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuaWZTdGF0ZW1lbnQoY2xhdXNlcykpO1xuICB9XG5cbiAgLy8gVGhlcmUgYXJlIHR3byB0eXBlcyBvZiBmb3Igc3RhdGVtZW50cywgZ2VuZXJpYyBhbmQgbnVtZXJpYy5cbiAgLy9cbiAgLy8gICAgIGZvciA6Oj0gTmFtZSAnPScgZXhwICcsJyBleHAgWycsJyBleHBdICdkbycgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIGZvciA6Oj0gbmFtZWxpc3QgJ2luJyBleHBsaXN0ICdkbycgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIG5hbWVsaXN0IDo6PSBOYW1lIHsnLCcgTmFtZX1cbiAgLy8gICAgIGV4cGxpc3QgOjo9IGV4cCB7JywnIGV4cH1cblxuICBmdW5jdGlvbiBwYXJzZUZvclN0YXRlbWVudChmbG93Q29udGV4dCkge1xuICAgIHZhciB2YXJpYWJsZSA9IHBhcnNlSWRlbnRpZmllcigpXG4gICAgICAsIGJvZHk7XG5cbiAgICAvLyBUaGUgc3RhcnQtaWRlbnRpZmllciBpcyBsb2NhbC5cblxuICAgIGlmIChvcHRpb25zLnNjb3BlKSB7XG4gICAgICBjcmVhdGVTY29wZSgpO1xuICAgICAgc2NvcGVJZGVudGlmaWVyKHZhcmlhYmxlKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgZXhwcmVzc2lvbiBpcyBmb2xsb3dlZCBieSBhIGA9YCBwdW5jdHVhdG9yLCB0aGlzIGlzIGFcbiAgICAvLyBOdW1lcmljIEZvciBTdGF0ZW1lbnQuXG4gICAgaWYgKGNvbnN1bWUoJz0nKSkge1xuICAgICAgLy8gU3RhcnQgZXhwcmVzc2lvblxuICAgICAgdmFyIHN0YXJ0ID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAvLyBFbmQgZXhwcmVzc2lvblxuICAgICAgdmFyIGVuZCA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIC8vIE9wdGlvbmFsIHN0ZXAgZXhwcmVzc2lvblxuICAgICAgdmFyIHN0ZXAgPSBjb25zdW1lKCcsJykgPyBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCkgOiBudWxsO1xuXG4gICAgICBleHBlY3QoJ2RvJyk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgZXhwZWN0KCdlbmQnKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmZvck51bWVyaWNTdGF0ZW1lbnQodmFyaWFibGUsIHN0YXJ0LCBlbmQsIHN0ZXAsIGJvZHkpKTtcbiAgICB9XG4gICAgLy8gSWYgbm90LCBpdCdzIGEgR2VuZXJpYyBGb3IgU3RhdGVtZW50XG4gICAgZWxzZSB7XG4gICAgICAvLyBUaGUgbmFtZWxpc3QgY2FuIGNvbnRhaW4gb25lIG9yIG1vcmUgaWRlbnRpZmllcnMuXG4gICAgICB2YXIgdmFyaWFibGVzID0gW3ZhcmlhYmxlXTtcbiAgICAgIHdoaWxlIChjb25zdW1lKCcsJykpIHtcbiAgICAgICAgdmFyaWFibGUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgLy8gRWFjaCB2YXJpYWJsZSBpbiB0aGUgbmFtZWxpc3QgaXMgbG9jYWxseSBzY29wZWQuXG4gICAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBzY29wZUlkZW50aWZpZXIodmFyaWFibGUpO1xuICAgICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgICB9XG4gICAgICBleHBlY3QoJ2luJyk7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gW107XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIGV4cHJlc3Npb25zIGluIHRoZSBleHBsaXN0LlxuICAgICAgZG8ge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgaXRlcmF0b3JzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgICBleHBlY3QoJ2RvJyk7XG4gICAgICBmbG93Q29udGV4dC5wdXNoU2NvcGUodHJ1ZSk7XG4gICAgICBib2R5ID0gcGFyc2VCbG9jayhmbG93Q29udGV4dCk7XG4gICAgICBmbG93Q29udGV4dC5wb3BTY29wZSgpO1xuICAgICAgZXhwZWN0KCdlbmQnKTtcbiAgICAgIGlmIChvcHRpb25zLnNjb3BlKSBkZXN0cm95U2NvcGUoKTtcblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmZvckdlbmVyaWNTdGF0ZW1lbnQodmFyaWFibGVzLCBpdGVyYXRvcnMsIGJvZHkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb2NhbCBzdGF0ZW1lbnRzIGNhbiBlaXRoZXIgYmUgdmFyaWFibGUgYXNzaWdubWVudHMgb3IgZnVuY3Rpb25cbiAgLy8gZGVmaW5pdGlvbnMuIElmIGEgZnVuY3Rpb24gZGVmaW5pdGlvbiBpcyBmb3VuZCwgaXQgd2lsbCBiZSBkZWxlZ2F0ZWQgdG9cbiAgLy8gYHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpYCB3aXRoIHRoZSBpc0xvY2FsIGZsYWcuXG4gIC8vXG4gIC8vIFRoaXMgQVNUIHN0cnVjdHVyZSBtaWdodCBjaGFuZ2UgaW50byBhIGxvY2FsIGFzc2lnbm1lbnQgd2l0aCBhIGZ1bmN0aW9uXG4gIC8vIGNoaWxkLlxuICAvL1xuICAvLyAgICAgbG9jYWwgOjo9ICdsb2NhbCcgJ2Z1bmN0aW9uJyBOYW1lIGZ1bmNkZWNsXG4gIC8vICAgICAgICB8ICdsb2NhbCcgTmFtZSB7JywnIE5hbWV9IFsnPScgZXhwIHsnLCcgZXhwfV1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG5hbWVcbiAgICAgICwgZGVjbFRva2VuID0gcHJldmlvdXNUb2tlbjtcblxuICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICB2YXIgdmFyaWFibGVzID0gW11cbiAgICAgICAgLCBpbml0ID0gW107XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgICAgIHZhcmlhYmxlcy5wdXNoKG5hbWUpO1xuICAgICAgICBmbG93Q29udGV4dC5hZGRMb2NhbChuYW1lLm5hbWUsIGRlY2xUb2tlbik7XG4gICAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgICBpZiAoY29uc3VtZSgnPScpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBpbml0LnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH0gd2hpbGUgKGNvbnN1bWUoJywnKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlY2xhcmF0aW9ucyBkb2Vzbid0IGV4aXN0IGJlZm9yZSB0aGUgc3RhdGVtZW50IGhhcyBiZWVuIGV2YWx1YXRlZC5cbiAgICAgIC8vIFRoZXJlZm9yZSBhc3NpZ25tZW50cyBjYW4ndCB1c2UgdGhlaXIgZGVjbGFyYXRvci4gQW5kIHRoZSBpZGVudGlmaWVyc1xuICAgICAgLy8gc2hvdWxkbid0IGJlIGFkZGVkIHRvIHRoZSBzY29wZSB1bnRpbCB0aGUgc3RhdGVtZW50IGlzIGNvbXBsZXRlLlxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YXJpYWJsZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgc2NvcGVJZGVudGlmaWVyKHZhcmlhYmxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmxvY2FsU3RhdGVtZW50KHZhcmlhYmxlcywgaW5pdCkpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZSgnZnVuY3Rpb24nKSkge1xuICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgZmxvd0NvbnRleHQuYWRkTG9jYWwobmFtZS5uYW1lLCBkZWNsVG9rZW4pO1xuXG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgICBzY29wZUlkZW50aWZpZXIobmFtZSk7XG4gICAgICAgIGNyZWF0ZVNjb3BlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lbWJlckV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBsb2NhbCBmdW5jdGlvbiBzdGF0ZW1lbnRzLlxuICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbihuYW1lLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJzxuYW1lPicsIHRva2VuKTtcbiAgICB9XG4gIH1cblxuICAvLyAgICAgYXNzaWdubWVudCA6Oj0gdmFybGlzdCAnPScgZXhwbGlzdFxuICAvLyAgICAgdmFyIDo6PSBOYW1lIHwgcHJlZml4ZXhwICdbJyBleHAgJ10nIHwgcHJlZml4ZXhwICcuJyBOYW1lXG4gIC8vICAgICB2YXJsaXN0IDo6PSB2YXIgeycsJyB2YXJ9XG4gIC8vICAgICBleHBsaXN0IDo6PSBleHAgeycsJyBleHB9XG4gIC8vXG4gIC8vICAgICBjYWxsIDo6PSBjYWxsZXhwXG4gIC8vICAgICBjYWxsZXhwIDo6PSBwcmVmaXhleHAgYXJncyB8IHByZWZpeGV4cCAnOicgTmFtZSBhcmdzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50T3JDYWxsU3RhdGVtZW50KGZsb3dDb250ZXh0KSB7XG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdG9rZW4gZm9yIGJldHRlciBlcnJvciBtZXNzYWdlcyBpbiBjYXNlXG4gICAgLy8gb2YgaW52YWxpZCBzdGF0ZW1lbnRcbiAgICB2YXIgcHJldmlvdXMgPSB0b2tlblxuICAgICAgLCBtYXJrZXIsIHN0YXJ0TWFya2VyO1xuICAgIHZhciBsdmFsdWUsIGJhc2UsIG5hbWU7XG5cbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xuXG4gICAgaWYgKHRyYWNrTG9jYXRpb25zKSBzdGFydE1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAgIGlmIChJZGVudGlmaWVyID09PSB0b2tlbi50eXBlKSB7XG4gICAgICAgIG5hbWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgYmFzZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCBzY29wZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGF0dGFjaFNjb3BlKGJhc2UsIHNjb3BlSGFzTmFtZShuYW1lKSk7XG4gICAgICAgIGx2YWx1ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCcoJyA9PT0gdG9rZW4udmFsdWUpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBiYXNlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgbHZhbHVlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGJvdGg6IGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5ld0Jhc2U7XG5cbiAgICAgICAgc3dpdGNoIChTdHJpbmdMaXRlcmFsID09PSB0b2tlbi50eXBlID8gJ1wiJyA6IHRva2VuLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICBsdmFsdWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgbHZhbHVlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayBib3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZSA9IHBhcnNlUHJlZml4RXhwcmVzc2lvblBhcnQoYmFzZSwgbWFya2VyLCBmbG93Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldHMucHVzaChiYXNlKTtcblxuICAgICAgaWYgKCcsJyAhPT0gdG9rZW4udmFsdWUpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBpZiAoIWx2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIG5leHQoKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmICh0YXJnZXRzLmxlbmd0aCA9PT0gMSAmJiBsdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmNhbGxTdGF0ZW1lbnQodGFyZ2V0c1swXSkpO1xuICAgIH0gZWxzZSBpZiAoIWx2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZXhwZWN0ZWQodG9rZW4pO1xuICAgIH1cblxuICAgIGV4cGVjdCgnPScpO1xuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgdmFsdWVzLnB1c2gocGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpKTtcbiAgICB9IHdoaWxlIChjb25zdW1lKCcsJykpO1xuXG4gICAgcHVzaExvY2F0aW9uKHN0YXJ0TWFya2VyKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuYXNzaWdubWVudFN0YXRlbWVudCh0YXJnZXRzLCB2YWx1ZXMpKTtcbiAgfVxuXG4gIC8vICMjIyBOb24tc3RhdGVtZW50c1xuXG4gIC8vICAgICBJZGVudGlmaWVyIDo6PSBOYW1lXG5cbiAgZnVuY3Rpb24gcGFyc2VJZGVudGlmaWVyKCkge1xuICAgIG1hcmtMb2NhdGlvbigpO1xuICAgIHZhciBpZGVudGlmaWVyID0gdG9rZW4udmFsdWU7XG4gICAgaWYgKElkZW50aWZpZXIgIT09IHRva2VuLnR5cGUpIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4nLCB0b2tlbik7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKGFzdC5pZGVudGlmaWVyKGlkZW50aWZpZXIpKTtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBmdW5jdGlvbnMgcGFyYW1ldGVycyBhbmQgYm9keSBibG9jay4gVGhlIG5hbWUgc2hvdWxkIGFscmVhZHlcbiAgLy8gaGF2ZSBiZWVuIHBhcnNlZCBhbmQgcGFzc2VkIHRvIHRoaXMgZGVjbGFyYXRpb24gZnVuY3Rpb24uIEJ5IHNlcGFyYXRpbmdcbiAgLy8gdGhpcyB3ZSBhbGxvdyBmb3IgYW5vbnltb3VzIGZ1bmN0aW9ucyBpbiBleHByZXNzaW9ucy5cbiAgLy9cbiAgLy8gRm9yIGxvY2FsIGZ1bmN0aW9ucyB0aGVyZSdzIGEgYm9vbGVhbiBwYXJhbWV0ZXIgd2hpY2ggbmVlZHMgdG8gYmUgc2V0XG4gIC8vIHdoZW4gcGFyc2luZyB0aGUgZGVjbGFyYXRpb24uXG4gIC8vXG4gIC8vICAgICBmdW5jZGVjbCA6Oj0gJygnIFtwYXJsaXN0XSAnKScgYmxvY2sgJ2VuZCdcbiAgLy8gICAgIHBhcmxpc3QgOjo9IE5hbWUgeycsJyBOYW1lfSB8IFsnLCcgJy4uLiddIHwgJy4uLidcblxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obmFtZSwgaXNMb2NhbCkge1xuICAgIHZhciBmbG93Q29udGV4dCA9IG1ha2VGbG93Q29udGV4dCgpO1xuICAgIGZsb3dDb250ZXh0LnB1c2hTY29wZSgpO1xuXG4gICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICBleHBlY3QoJygnKTtcblxuICAgIC8vIFRoZSBkZWNsYXJhdGlvbiBoYXMgYXJndW1lbnRzXG4gICAgaWYgKCFjb25zdW1lKCcpJykpIHtcbiAgICAgIC8vIEFyZ3VtZW50cyBhcmUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBpZGVudGlmaWVycywgb3B0aW9uYWxseSBlbmRpbmdcbiAgICAgIC8vIHdpdGggYSB2YXJhcmcuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoSWRlbnRpZmllciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAvLyBGdW5jdGlvbiBwYXJhbWV0ZXJzIGFyZSBsb2NhbC5cbiAgICAgICAgICBpZiAob3B0aW9ucy5zY29wZSkgc2NvcGVJZGVudGlmaWVyKHBhcmFtZXRlcik7XG5cbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocGFyYW1ldGVyKTtcblxuICAgICAgICAgIGlmIChjb25zdW1lKCcsJykpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGFyZ3VtZW50cyBhcmUgYWxsb3dlZCBhZnRlciBhIHZhcmFyZy5cbiAgICAgICAgZWxzZSBpZiAoVmFyYXJnTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgICAgIGZsb3dDb250ZXh0LmFsbG93VmFyYXJnID0gdHJ1ZTtcbiAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocGFyc2VQcmltYXJ5RXhwcmVzc2lvbihmbG93Q29udGV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8bmFtZT4gb3IgXFwnLi4uXFwnJywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHBhcnNlQmxvY2soZmxvd0NvbnRleHQpO1xuICAgIGZsb3dDb250ZXh0LnBvcFNjb3BlKCk7XG4gICAgZXhwZWN0KCdlbmQnKTtcbiAgICBpZiAob3B0aW9ucy5zY29wZSkgZGVzdHJveVNjb3BlKCk7XG5cbiAgICBpc0xvY2FsID0gaXNMb2NhbCB8fCBmYWxzZTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuZnVuY3Rpb25TdGF0ZW1lbnQobmFtZSwgcGFyYW1ldGVycywgaXNMb2NhbCwgYm9keSkpO1xuICB9XG5cbiAgLy8gUGFyc2UgdGhlIGZ1bmN0aW9uIG5hbWUgYXMgaWRlbnRpZmllcnMgYW5kIG1lbWJlciBleHByZXNzaW9ucy5cbiAgLy9cbiAgLy8gICAgIE5hbWUgeycuJyBOYW1lfSBbJzonIE5hbWVdXG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbk5hbWUoKSB7XG4gICAgdmFyIGJhc2UsIG5hbWUsIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICBiYXNlID0gcGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZSkge1xuICAgICAgYXR0YWNoU2NvcGUoYmFzZSwgc2NvcGVIYXNOYW1lKGJhc2UubmFtZSkpO1xuICAgICAgY3JlYXRlU2NvcGUoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY29uc3VtZSgnLicpKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIG5hbWUgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGJhc2UgPSBmaW5pc2hOb2RlKGFzdC5tZW1iZXJFeHByZXNzaW9uKGJhc2UsICcuJywgbmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChjb25zdW1lKCc6JykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgbmFtZSA9IHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgYmFzZSA9IGZpbmlzaE5vZGUoYXN0Lm1lbWJlckV4cHJlc3Npb24oYmFzZSwgJzonLCBuYW1lKSk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgc2NvcGVJZGVudGlmaWVyTmFtZSgnc2VsZicpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLy8gICAgIHRhYmxlY29uc3RydWN0b3IgOjo9ICd7JyBbZmllbGRsaXN0XSAnfSdcbiAgLy8gICAgIGZpZWxkbGlzdCA6Oj0gZmllbGQge2ZpZWxkc2VwIGZpZWxkfSBmaWVsZHNlcFxuICAvLyAgICAgZmllbGQgOjo9ICdbJyBleHAgJ10nICc9JyBleHAgfCBOYW1lID0gJ2V4cCcgfCBleHBcbiAgLy9cbiAgLy8gICAgIGZpZWxkc2VwIDo6PSAnLCcgfCAnOydcblxuICBmdW5jdGlvbiBwYXJzZVRhYmxlQ29uc3RydWN0b3IoZmxvd0NvbnRleHQpIHtcbiAgICB2YXIgZmllbGRzID0gW11cbiAgICAgICwga2V5LCB2YWx1ZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBtYXJrTG9jYXRpb24oKTtcbiAgICAgIGlmIChQdW5jdHVhdG9yID09PSB0b2tlbi50eXBlICYmIGNvbnN1bWUoJ1snKSkge1xuICAgICAgICBrZXkgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGV4cGVjdCgnXScpO1xuICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlS2V5KGtleSwgdmFsdWUpKSk7XG4gICAgICB9IGVsc2UgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgICAgaWYgKCc9JyA9PT0gbG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAga2V5ID0gcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgIGZpZWxkcy5wdXNoKGZpbmlzaE5vZGUoYXN0LnRhYmxlS2V5U3RyaW5nKGtleSwgdmFsdWUpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVWYWx1ZSh2YWx1ZSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgPT0gKHZhbHVlID0gcGFyc2VFeHByZXNzaW9uKGZsb3dDb250ZXh0KSkpIHtcbiAgICAgICAgICBsb2NhdGlvbnMucG9wKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLnB1c2goZmluaXNoTm9kZShhc3QudGFibGVWYWx1ZSh2YWx1ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgnLDsnLmluZGV4T2YodG9rZW4udmFsdWUpID49IDApIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBleHBlY3QoJ30nKTtcbiAgICByZXR1cm4gZmluaXNoTm9kZShhc3QudGFibGVDb25zdHJ1Y3RvckV4cHJlc3Npb24oZmllbGRzKSk7XG4gIH1cblxuICAvLyBFeHByZXNzaW9uIHBhcnNlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBFeHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkIGFuZCBhbHdheXMgcmV0dXJuIGEgdmFsdWUuIElmIG5vdGhpbmcgaXNcbiAgLy8gbWF0Y2hlZCBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gIC8vXG4gIC8vICAgICBleHAgOjo9ICh1bm9wIGV4cCB8IHByaW1hcnkgfCBwcmVmaXhleHAgKSB7IGJpbm9wIGV4cCB9XG4gIC8vXG4gIC8vICAgICBwcmltYXJ5IDo6PSBuaWwgfCBmYWxzZSB8IHRydWUgfCBOdW1iZXIgfCBTdHJpbmcgfCAnLi4uJ1xuICAvLyAgICAgICAgICB8IGZ1bmN0aW9uZGVmIHwgdGFibGVjb25zdHJ1Y3RvclxuICAvL1xuICAvLyAgICAgcHJlZml4ZXhwIDo6PSAoTmFtZSB8ICcoJyBleHAgJyknICkgeyAnWycgZXhwICddJ1xuICAvLyAgICAgICAgICB8ICcuJyBOYW1lIHwgJzonIE5hbWUgYXJncyB8IGFyZ3MgfVxuICAvL1xuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VTdWJFeHByZXNzaW9uKDAsIGZsb3dDb250ZXh0KTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIC8vIFBhcnNlIGFuIGV4cHJlc3Npb24gZXhwZWN0aW5nIGl0IHRvIGJlIHZhbGlkLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgIGlmIChudWxsID09IGV4cHJlc3Npb24pIHJhaXNlVW5leHBlY3RlZFRva2VuKCc8ZXhwcmVzc2lvbj4nLCB0b2tlbik7XG4gICAgZWxzZSByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG5cbiAgLy8gUmV0dXJuIHRoZSBwcmVjZWRlbmNlIHByaW9yaXR5IG9mIHRoZSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gQXMgdW5hcnkgYC1gIGNhbid0IGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBiaW5hcnkgYC1gLCB1bmFyeSBwcmVjZWRlbmNlXG4gIC8vIGlzbid0IGRlc2NyaWJlZCBpbiB0aGlzIHRhYmxlIGJ1dCBpbiBgcGFyc2VTdWJFeHByZXNzaW9uKClgIGl0c2VsZi5cbiAgLy9cbiAgLy8gQXMgdGhpcyBmdW5jdGlvbiBnZXRzIGhpdCBvbiBldmVyeSBleHByZXNzaW9uIGl0J3MgYmVlbiBvcHRpbWl6ZWQgZHVlIHRvXG4gIC8vIHRoZSBleHBlbnNpdmUgQ29tcGFyZUlDU3R1YiB3aGljaCB0b29rIH44JSBvZiB0aGUgcGFyc2UgdGltZS5cblxuICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKG9wZXJhdG9yKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gb3BlcmF0b3IuY2hhckNvZGVBdCgwKVxuICAgICAgLCBsZW5ndGggPSBvcGVyYXRvci5sZW5ndGg7XG5cbiAgICBpZiAoMSA9PT0gbGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgIGNhc2UgOTQ6IHJldHVybiAxMjsgLy8gXlxuICAgICAgICBjYXNlIDQyOiBjYXNlIDQ3OiBjYXNlIDM3OiByZXR1cm4gMTA7IC8vICogLyAlXG4gICAgICAgIGNhc2UgNDM6IGNhc2UgNDU6IHJldHVybiA5OyAvLyArIC1cbiAgICAgICAgY2FzZSAzODogcmV0dXJuIDY7IC8vICZcbiAgICAgICAgY2FzZSAxMjY6IHJldHVybiA1OyAvLyB+XG4gICAgICAgIGNhc2UgMTI0OiByZXR1cm4gNDsgLy8gfFxuICAgICAgICBjYXNlIDYwOiBjYXNlIDYyOiByZXR1cm4gMzsgLy8gPCA+XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgyID09PSBsZW5ndGgpIHtcbiAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgY2FzZSA0NzogcmV0dXJuIDEwOyAvLyAvL1xuICAgICAgICBjYXNlIDQ2OiByZXR1cm4gODsgLy8gLi5cbiAgICAgICAgY2FzZSA2MDogY2FzZSA2MjpcbiAgICAgICAgICAgIGlmKCc8PCcgPT09IG9wZXJhdG9yIHx8ICc+PicgPT09IG9wZXJhdG9yKSByZXR1cm4gNzsgLy8gPDwgPj5cbiAgICAgICAgICAgIHJldHVybiAzOyAvLyA8PSA+PVxuICAgICAgICBjYXNlIDYxOiBjYXNlIDEyNjogcmV0dXJuIDM7IC8vID09IH49XG4gICAgICAgIGNhc2UgMTExOiByZXR1cm4gMTsgLy8gb3JcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKDk3ID09PSBjaGFyQ29kZSAmJiAnYW5kJyA9PT0gb3BlcmF0b3IpIHJldHVybiAyO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gSW1wbGVtZW50IGFuIG9wZXJhdG9yLXByZWNlZGVuY2UgcGFyc2VyIHRvIGhhbmRsZSBiaW5hcnkgb3BlcmF0b3JcbiAgLy8gcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gV2UgdXNlIHRoaXMgYWxnb3JpdGhtIGJlY2F1c2UgaXQncyBjb21wYWN0LCBpdCdzIGZhc3QgYW5kIEx1YSBjb3JlIHVzZXNcbiAgLy8gdGhlIHNhbWUgc28gd2UgY2FuIGJlIHN1cmUgb3VyIGV4cHJlc3Npb25zIGFyZSBwYXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyXG4gIC8vIHdpdGhvdXQgZXhjZXNzaXZlIGFtb3VudHMgb2YgdGVzdHMuXG4gIC8vXG4gIC8vICAgICBleHAgOjo9ICh1bm9wIGV4cCB8IHByaW1hcnkgfCBwcmVmaXhleHAgKSB7IGJpbm9wIGV4cCB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWJFeHByZXNzaW9uKG1pblByZWNlZGVuY2UsIGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWVcbiAgICAvLyBUaGUgbGVmdC1oYW5kIHNpZGUgaW4gYmluYXJ5IG9wZXJhdGlvbnMuXG4gICAgICAsIGV4cHJlc3Npb24sIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIC8vIFVuYXJ5RXhwcmVzc2lvblxuICAgIGlmIChpc1VuYXJ5KHRva2VuKSkge1xuICAgICAgbWFya0xvY2F0aW9uKCk7XG4gICAgICBuZXh0KCk7XG4gICAgICB2YXIgYXJndW1lbnQgPSBwYXJzZVN1YkV4cHJlc3Npb24oMTAsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChhcmd1bWVudCA9PSBudWxsKSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPGV4cHJlc3Npb24+JywgdG9rZW4pO1xuICAgICAgZXhwcmVzc2lvbiA9IGZpbmlzaE5vZGUoYXN0LnVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpKTtcbiAgICB9XG4gICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikge1xuICAgICAgLy8gUHJpbWFyeUV4cHJlc3Npb25cbiAgICAgIGV4cHJlc3Npb24gPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcblxuICAgICAgLy8gUHJlZml4RXhwcmVzc2lvblxuICAgICAgaWYgKG51bGwgPT0gZXhwcmVzc2lvbikge1xuICAgICAgICBleHByZXNzaW9uID0gcGFyc2VQcmVmaXhFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyBub3QgYSB2YWxpZCBsZWZ0IGhhbmQgZXhwcmVzc2lvbi5cbiAgICBpZiAobnVsbCA9PSBleHByZXNzaW9uKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwcmVjZWRlbmNlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBvcGVyYXRvciA9IHRva2VuLnZhbHVlO1xuXG4gICAgICBwcmVjZWRlbmNlID0gKFB1bmN0dWF0b3IgPT09IHRva2VuLnR5cGUgfHwgS2V5d29yZCA9PT0gdG9rZW4udHlwZSkgP1xuICAgICAgICBiaW5hcnlQcmVjZWRlbmNlKG9wZXJhdG9yKSA6IDA7XG5cbiAgICAgIGlmIChwcmVjZWRlbmNlID09PSAwIHx8IHByZWNlZGVuY2UgPD0gbWluUHJlY2VkZW5jZSkgYnJlYWs7XG4gICAgICAvLyBSaWdodC1oYW5kIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG4gICAgICBpZiAoJ14nID09PSBvcGVyYXRvciB8fCAnLi4nID09PSBvcGVyYXRvcikgLS1wcmVjZWRlbmNlO1xuICAgICAgbmV4dCgpO1xuICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VTdWJFeHByZXNzaW9uKHByZWNlZGVuY2UsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChudWxsID09IHJpZ2h0KSByYWlzZVVuZXhwZWN0ZWRUb2tlbignPGV4cHJlc3Npb24+JywgdG9rZW4pO1xuICAgICAgLy8gUHVzaCBpbiB0aGUgbWFya2VyIGNyZWF0ZWQgYmVmb3JlIHRoZSBsb29wIHRvIHdyYXAgaXRzIGVudGlyZXR5LlxuICAgICAgaWYgKHRyYWNrTG9jYXRpb25zKSBsb2NhdGlvbnMucHVzaChtYXJrZXIpO1xuICAgICAgZXhwcmVzc2lvbiA9IGZpbmlzaE5vZGUoYXN0LmJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGV4cHJlc3Npb24sIHJpZ2h0KSk7XG5cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG4gIH1cblxuICAvLyAgICAgcHJlZml4ZXhwIDo6PSBwcmVmaXgge3N1ZmZpeH1cbiAgLy8gICAgIHByZWZpeCA6Oj0gTmFtZSB8ICcoJyBleHAgJyknXG4gIC8vICAgICBzdWZmaXggOjo9ICdbJyBleHAgJ10nIHwgJy4nIE5hbWUgfCAnOicgTmFtZSBhcmdzIHwgYXJnc1xuICAvL1xuICAvLyAgICAgYXJncyA6Oj0gJygnIFtleHBsaXN0XSAnKScgfCB0YWJsZWNvbnN0cnVjdG9yIHwgU3RyaW5nXG5cbiAgZnVuY3Rpb24gcGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydChiYXNlLCBtYXJrZXIsIGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGV4cHJlc3Npb24sIGlkZW50aWZpZXI7XG5cbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHBhcnNlRXhwZWN0ZWRFeHByZXNzaW9uKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICBleHBlY3QoJ10nKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuaW5kZXhFeHByZXNzaW9uKGJhc2UsIGV4cHJlc3Npb24pKTtcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGlkZW50aWZpZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnLicsIGlkZW50aWZpZXIpKTtcbiAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGlkZW50aWZpZXIgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBiYXNlID0gZmluaXNoTm9kZShhc3QubWVtYmVyRXhwcmVzc2lvbihiYXNlLCAnOicsIGlkZW50aWZpZXIpKTtcbiAgICAgICAgICAvLyBPbmNlIGEgOiBpcyBmb3VuZCwgdGhpcyBoYXMgdG8gYmUgYSBDYWxsRXhwcmVzc2lvbiwgb3RoZXJ3aXNlXG4gICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpO1xuICAgICAgICBjYXNlICcoJzogY2FzZSAneyc6IC8vIGFyZ3NcbiAgICAgICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihiYXNlLCBmbG93Q29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTdHJpbmdMaXRlcmFsID09PSB0b2tlbi50eXBlKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHJldHVybiBwYXJzZUNhbGxFeHByZXNzaW9uKGJhc2UsIGZsb3dDb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJlZml4RXhwcmVzc2lvbihmbG93Q29udGV4dCkge1xuICAgIHZhciBiYXNlLCBuYW1lLCBtYXJrZXI7XG5cbiAgICBpZiAodHJhY2tMb2NhdGlvbnMpIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAvLyBUaGUgcHJlZml4XG4gICAgaWYgKElkZW50aWZpZXIgPT09IHRva2VuLnR5cGUpIHtcbiAgICAgIG5hbWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGJhc2UgPSBwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIC8vIFNldCB0aGUgcGFyZW50IHNjb3BlLlxuICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpIGF0dGFjaFNjb3BlKGJhc2UsIHNjb3BlSGFzTmFtZShuYW1lKSk7XG4gICAgfSBlbHNlIGlmIChjb25zdW1lKCcoJykpIHtcbiAgICAgIGJhc2UgPSBwYXJzZUV4cGVjdGVkRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICBleHBlY3QoJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVGhlIHN1ZmZpeFxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXdCYXNlID0gcGFyc2VQcmVmaXhFeHByZXNzaW9uUGFydChiYXNlLCBtYXJrZXIsIGZsb3dDb250ZXh0KTtcbiAgICAgIGlmIChuZXdCYXNlID09PSBudWxsKVxuICAgICAgICBicmVhaztcbiAgICAgIGJhc2UgPSBuZXdCYXNlO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgLy8gICAgIGFyZ3MgOjo9ICcoJyBbZXhwbGlzdF0gJyknIHwgdGFibGVjb25zdHJ1Y3RvciB8IFN0cmluZ1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ2FsbEV4cHJlc3Npb24oYmFzZSwgZmxvd0NvbnRleHQpIHtcbiAgICBpZiAoUHVuY3R1YXRvciA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICBpZiAoIWZlYXR1cmVzLmVtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodG9rZW4ubGluZSAhPT0gcHJldmlvdXNUb2tlbi5saW5lKVxuICAgICAgICAgICAgICByYWlzZShudWxsLCBlcnJvcnMuYW1iaWd1b3VzU3ludGF4LCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgIC8vIExpc3Qgb2YgZXhwcmVzc2lvbnNcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbihmbG93Q29udGV4dCk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gZXhwcmVzc2lvbikgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICB3aGlsZSAoY29uc3VtZSgnLCcpKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHBlY3RlZEV4cHJlc3Npb24oZmxvd0NvbnRleHQpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QuY2FsbEV4cHJlc3Npb24oYmFzZSwgZXhwcmVzc2lvbnMpKTtcblxuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICBtYXJrTG9jYXRpb24oKTtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgdmFyIHRhYmxlID0gcGFyc2VUYWJsZUNvbnN0cnVjdG9yKGZsb3dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gZmluaXNoTm9kZShhc3QudGFibGVDYWxsRXhwcmVzc2lvbihiYXNlLCB0YWJsZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoU3RyaW5nTGl0ZXJhbCA9PT0gdG9rZW4udHlwZSkge1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LnN0cmluZ0NhbGxFeHByZXNzaW9uKGJhc2UsIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oZmxvd0NvbnRleHQpKSk7XG4gICAgfVxuXG4gICAgcmFpc2VVbmV4cGVjdGVkVG9rZW4oJ2Z1bmN0aW9uIGFyZ3VtZW50cycsIHRva2VuKTtcbiAgfVxuXG4gIC8vICAgICBwcmltYXJ5IDo6PSBTdHJpbmcgfCBOdW1lcmljIHwgbmlsIHwgdHJ1ZSB8IGZhbHNlXG4gIC8vICAgICAgICAgIHwgZnVuY3Rpb25kZWYgfCB0YWJsZWNvbnN0cnVjdG9yIHwgJy4uLidcblxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKGZsb3dDb250ZXh0KSB7XG4gICAgdmFyIGxpdGVyYWxzID0gU3RyaW5nTGl0ZXJhbCB8IE51bWVyaWNMaXRlcmFsIHwgQm9vbGVhbkxpdGVyYWwgfCBOaWxMaXRlcmFsIHwgVmFyYXJnTGl0ZXJhbFxuICAgICAgLCB2YWx1ZSA9IHRva2VuLnZhbHVlXG4gICAgICAsIHR5cGUgPSB0b2tlbi50eXBlXG4gICAgICAsIG1hcmtlcjtcblxuICAgIGlmICh0cmFja0xvY2F0aW9ucykgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcblxuICAgIGlmICh0eXBlID09PSBWYXJhcmdMaXRlcmFsICYmICFmbG93Q29udGV4dC5hbGxvd1ZhcmFyZykge1xuICAgICAgcmFpc2UodG9rZW4sIGVycm9ycy5jYW5ub3RVc2VWYXJhcmcsIHRva2VuLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAmIGxpdGVyYWxzKSB7XG4gICAgICBwdXNoTG9jYXRpb24obWFya2VyKTtcbiAgICAgIHZhciByYXcgPSBpbnB1dC5zbGljZSh0b2tlbi5yYW5nZVswXSwgdG9rZW4ucmFuZ2VbMV0pO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUoYXN0LmxpdGVyYWwodHlwZSwgdmFsdWUsIHJhdykpO1xuICAgIH0gZWxzZSBpZiAoS2V5d29yZCA9PT0gdHlwZSAmJiAnZnVuY3Rpb24nID09PSB2YWx1ZSkge1xuICAgICAgcHVzaExvY2F0aW9uKG1hcmtlcik7XG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAob3B0aW9ucy5zY29wZSkgY3JlYXRlU2NvcGUoKTtcbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24obnVsbCk7XG4gICAgfSBlbHNlIGlmIChjb25zdW1lKCd7JykpIHtcbiAgICAgIHB1c2hMb2NhdGlvbihtYXJrZXIpO1xuICAgICAgcmV0dXJuIHBhcnNlVGFibGVDb25zdHJ1Y3RvcihmbG93Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2VyXG4gIC8vIC0tLS0tLVxuXG4gIC8vIEV4cG9ydCB0aGUgbWFpbiBwYXJzZXIuXG4gIC8vXG4gIC8vICAgLSBgd2FpdGAgSG9sZCBwYXJzaW5nIHVudGlsIGVuZCgpIGlzIGNhbGxlZC4gRGVmYXVsdHMgdG8gZmFsc2VcbiAgLy8gICAtIGBjb21tZW50c2AgU3RvcmUgY29tbWVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gIC8vICAgLSBgc2NvcGVgIFRyYWNrIGlkZW50aWZpZXIgc2NvcGUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAvLyAgIC0gYGxvY2F0aW9uc2AgU3RvcmUgbG9jYXRpb24gaW5mb3JtYXRpb24uIERlZmF1bHRzIHRvIGZhbHNlLlxuICAvLyAgIC0gYHJhbmdlc2AgU3RvcmUgdGhlIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVyIGxvY2F0aW9ucy4gRGVmYXVsdHMgdG9cbiAgLy8gICAgIGZhbHNlLlxuICAvLyAgIC0gYG9uQ3JlYXRlTm9kZWAgQ2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gYSBzeW50YXggbm9kZSBpc1xuICAvLyAgICAgY3JlYXRlZC5cbiAgLy8gICAtIGBvbkNyZWF0ZVNjb3BlYCBDYWxsYmFjayB3aGljaCB3aWxsIGJlIGludm9rZWQgd2hlbiBhIG5ldyBzY29wZSBpc1xuICAvLyAgICAgY3JlYXRlZC5cbiAgLy8gICAtIGBvbkRlc3Ryb3lTY29wZWAgQ2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgLy8gICAgIGlzIGRlc3Ryb3llZC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgIHZhciBwYXJzZXIgPSByZXF1aXJlKCdsdWFwYXJzZXInKTtcbiAgLy8gICAgIHBhcnNlci5wYXJzZSgnaSA9IDAnKTtcblxuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgdmFyIHZlcnNpb25GZWF0dXJlcyA9IHtcbiAgICAnNS4xJzoge1xuICAgIH0sXG4gICAgJzUuMic6IHtcbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGVtcHR5U3RhdGVtZW50OiB0cnVlLFxuICAgICAgaGV4RXNjYXBlczogdHJ1ZSxcbiAgICAgIHNraXBXaGl0ZXNwYWNlRXNjYXBlOiB0cnVlLFxuICAgICAgc3RyaWN0RXNjYXBlczogdHJ1ZSxcbiAgICAgIHJlbGF4ZWRCcmVhazogdHJ1ZVxuICAgIH0sXG4gICAgJzUuMyc6IHtcbiAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgIGVtcHR5U3RhdGVtZW50OiB0cnVlLFxuICAgICAgaGV4RXNjYXBlczogdHJ1ZSxcbiAgICAgIHNraXBXaGl0ZXNwYWNlRXNjYXBlOiB0cnVlLFxuICAgICAgc3RyaWN0RXNjYXBlczogdHJ1ZSxcbiAgICAgIHVuaWNvZGVFc2NhcGVzOiB0cnVlLFxuICAgICAgYml0d2lzZU9wZXJhdG9yczogdHJ1ZSxcbiAgICAgIGludGVnZXJEaXZpc2lvbjogdHJ1ZSxcbiAgICAgIHJlbGF4ZWRCcmVhazogdHJ1ZVxuICAgIH0sXG4gICAgJ0x1YUpJVCc6IHtcbiAgICAgIC8vIFhYWDogTHVhSklUIGxhbmd1YWdlIGZlYXR1cmVzIG1heSBkZXBlbmQgb24gY29tcGlsYXRpb24gb3B0aW9uczsgbWF5IG5lZWQgdG9cbiAgICAgIC8vIHJldGhpbmsgaG93IHRvIGhhbmRsZSB0aGlzLiBTcGVjaWZpY2FsbHksIHRoZXJlIGlzIGEgTFVBSklUX0VOQUJMRV9MVUE1MkNPTVBBVFxuICAgICAgLy8gdGhhdCByZW1vdmVzIGNvbnRleHR1YWwgZ290by4gTWF5YmUgYWRkICdMdWFKSVQtNS4yY29tcGF0JyBhcyB3ZWxsP1xuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgY29udGV4dHVhbEdvdG86IHRydWUsXG4gICAgICBoZXhFc2NhcGVzOiB0cnVlLFxuICAgICAgc2tpcFdoaXRlc3BhY2VFc2NhcGU6IHRydWUsXG4gICAgICBzdHJpY3RFc2NhcGVzOiB0cnVlLFxuICAgICAgdW5pY29kZUVzY2FwZXM6IHRydWVcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2UoX2lucHV0LCBfb3B0aW9ucykge1xuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIF9vcHRpb25zICYmICdvYmplY3QnID09PSB0eXBlb2YgX2lucHV0KSB7XG4gICAgICBfb3B0aW9ucyA9IF9pbnB1dDtcbiAgICAgIF9pbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFfb3B0aW9ucykgX29wdGlvbnMgPSB7fTtcblxuICAgIGlucHV0ID0gX2lucHV0IHx8ICcnO1xuICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBfb3B0aW9ucyk7XG5cbiAgICAvLyBSZXdpbmQgdGhlIGxleGVyXG4gICAgaW5kZXggPSAwO1xuICAgIGxpbmUgPSAxO1xuICAgIGxpbmVTdGFydCA9IDA7XG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIC8vIFdoZW4gdHJhY2tpbmcgaWRlbnRpZmllciBzY29wZSwgaW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5IHNjb3BlLlxuICAgIHNjb3BlcyA9IFtbXV07XG4gICAgc2NvcGVEZXB0aCA9IDA7XG4gICAgZ2xvYmFscyA9IFtdO1xuICAgIGxvY2F0aW9ucyA9IFtdO1xuXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbkZlYXR1cmVzLCBvcHRpb25zLmx1YVZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZihcIkx1YSB2ZXJzaW9uICclMScgbm90IHN1cHBvcnRlZFwiLCBvcHRpb25zLmx1YVZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBmZWF0dXJlcyA9IGFzc2lnbih7fSwgdmVyc2lvbkZlYXR1cmVzW29wdGlvbnMubHVhVmVyc2lvbl0pO1xuICAgIGlmIChvcHRpb25zLmV4dGVuZGVkSWRlbnRpZmllcnMgIT09IHZvaWQgMClcbiAgICAgIGZlYXR1cmVzLmV4dGVuZGVkSWRlbnRpZmllcnMgPSAhIW9wdGlvbnMuZXh0ZW5kZWRJZGVudGlmaWVycztcblxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVuY29kaW5nTW9kZXMsIG9wdGlvbnMuZW5jb2RpbmdNb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoXCJFbmNvZGluZyBtb2RlICclMScgbm90IHN1cHBvcnRlZFwiLCBvcHRpb25zLmVuY29kaW5nTW9kZSkpO1xuICAgIH1cblxuICAgIGVuY29kaW5nTW9kZSA9IGVuY29kaW5nTW9kZXNbb3B0aW9ucy5lbmNvZGluZ01vZGVdO1xuXG4gICAgaWYgKG9wdGlvbnMuY29tbWVudHMpIGNvbW1lbnRzID0gW107XG4gICAgaWYgKCFvcHRpb25zLndhaXQpIHJldHVybiBlbmQoKTtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIC8vIFdyaXRlIHRvIHRoZSBzb3VyY2UgY29kZSBidWZmZXIgd2l0aG91dCBiZWdpbm5pbmcgdGhlIHBhcnNlLlxuICBleHBvcnRzLndyaXRlID0gd3JpdGU7XG5cbiAgZnVuY3Rpb24gd3JpdGUoX2lucHV0KSB7XG4gICAgaW5wdXQgKz0gU3RyaW5nKF9pbnB1dCk7XG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgLy8gU2VuZCBhbiBFT0YgYW5kIGJlZ2luIHBhcnNpbmcuXG4gIGV4cG9ydHMuZW5kID0gZW5kO1xuXG4gIGZ1bmN0aW9uIGVuZChfaW5wdXQpIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBfaW5wdXQpIHdyaXRlKF9pbnB1dCk7XG5cbiAgICAvLyBJZ25vcmUgc2hlYmFuZ3MuXG4gICAgaWYgKGlucHV0ICYmIGlucHV0LnN1YnN0cigwLCAyKSA9PT0gJyMhJykgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eLiovLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvLi9nLCAnICcpO1xuICAgIH0pO1xuXG4gICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHRyYWNrTG9jYXRpb25zID0gb3B0aW9ucy5sb2NhdGlvbnMgfHwgb3B0aW9ucy5yYW5nZXM7XG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIGEgbG9va2FoZWFkIHRva2VuLlxuICAgIGxvb2thaGVhZCA9IGxleCgpO1xuXG4gICAgdmFyIGNodW5rID0gcGFyc2VDaHVuaygpO1xuICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSBjaHVuay5jb21tZW50cyA9IGNvbW1lbnRzO1xuICAgIGlmIChvcHRpb25zLnNjb3BlKSBjaHVuay5nbG9iYWxzID0gZ2xvYmFscztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChsb2NhdGlvbnMubGVuZ3RoID4gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYXRpb24gdHJhY2tpbmcgZmFpbGVkLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnIGluIGx1YXBhcnNlJyk7XG5cbiAgICByZXR1cm4gY2h1bms7XG4gIH1cblxufSkpO1xuLyogdmltOiBzZXQgc3c9MiB0cz0yIGV0IHR3PTc5IDogKi9cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/luaparse/luaparse.js\n");

/***/ })

}]);