(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[79],{

/***/ "./node_modules/filbert/filbert.js":
/*!*****************************************!*\
  !*** ./node_modules/filbert/filbert.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Filbert is a Python parser written in JavaScript.\n//\n// Filbert was written by Matt Lott and released under an MIT\n// license. It was adatped from [Acorn](https://github.com/marijnh/acorn.git)\n// by Marijn Haverbeke.\n//\n// Git repository for Filbert are available at\n//\n//     https://github.com/differentmatt/filbert.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/differentmatt/filbert/issues\n\n(function(root, mod) {\n  if (true) return mod(exports); // CommonJS\n  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  mod(root.filbert || (root.filbert = {})); // Plain browser env\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.1\";\n\n  // The main exported interface (under `self.filbert` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile, nc;\n\n  exports.parse = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    nc = getNodeCreator(startNode, startNodeFrom, finishNode, unpackTuple);\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `languageVersion` indicates the Python version to parse. It\n    // is not currently in use, but will support 2 or 3 eventually.\n    languageVersion: 3,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Filbert to call that function with `(text, start,\n    // end)` parameters whenever a comment is skipped.\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback-that will corrupt its internal state.\n    onComment: null,\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // Python runtime library object name\n    runtimeParamName: \"__pythonRuntime\"\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n      options[opt] = defaultOptions[opt];\n    sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return {line: line, column: offset - cur};\n  };\n\n  // Filbert is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Filbert parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      lastEnd = tokEnd;\n      readToken(forceRegexp);\n      t.start = tokStart; t.end = tokEnd;\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n      t.type = tokType; t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function(pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `strict` indicates\n  // whether strict mode is on, and `bracketNesting` tracks the level\n  // of nesting within brackets for implicit lint continuation.\n\n  var inFunction, strict, bracketNesting;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // Used for name collision avoidance whend adding extra AST identifiers\n\n  var newAstIdCount = 0;\n\n  var indentHist = exports.indentHist = {\n    // Current indentation stack\n    indent: [],\n\n    // Number of dedent tokens left (i.e. if tokType == _dedent, dedentCount > 0)\n    // Multiple dedent tokens are read in at once, but processed individually in readToken()\n    dedentCount: 0,\n\n    init: function () { this.indent = []; this.dedentCount = 0; },\n    count: function () { return this.indent.length; },\n    len: function (i) { \n      if (typeof i === 'undefined' || i >= this.indent.length) i = this.indent.length - 1;\n      return this.indent[i].length; \n    },\n    isIndent: function(s) {\n      return this.indent.length === 0 || s.length > this.len();\n    },\n    isDedent: function(s) {\n      return this.indent.length > 0 && s.length < this.len();\n    },\n    addIndent: function (s) { this.indent.push(s); },\n    addDedent: function (s) {\n      this.dedentCount = 0;\n      for (var i = this.indent.length - 1; i >= 0 && s.length < this.indent[i].length; --i)\n        ++this.dedentCount;\n    },\n    updateDedent: function () { this.dedentCount = this.count(); },\n    pop: function () {\n      --this.dedentCount;\n      this.indent.pop();\n    },\n    undoIndent: function () { this.pop(); }\n  };\n\n  // ## Scope\n\n  // Collection of namespaces saved as a stack\n  // A namespace is a mapping of identifiers to 3 types: variables, functions, classes\n  // A namespace also knows whether it is for global, class, or function\n  // A new namespace is pushed at function and class start, and popped at their end\n  // Starts with a global namespace on the stack\n  // E.g. scope.namespaces ~ [{type: 'g', map:{x: 'v', MyClass: 'c'} }, ...]\n\n  // TODO: Not tracking built-in namespace\n  \n  var scope = exports.scope = {\n    namespaces: [],\n    init: function () { this.namespaces = [{ type: 'g', map: {} }]; },\n    current: function(offset) { \n      offset = offset || 0;\n      return this.namespaces[this.namespaces.length - offset - 1];\n    },\n    startClass: function (id) {\n      this.current().map[id] = 'c';\n      this.namespaces.push({ type: 'c', map: {}, className: id });\n    },\n    startFn: function (id) {\n      this.current().map[id] = 'f';\n      this.namespaces.push({ type: 'f', map: {}, fnName: id });\n    },\n    end: function () { this.namespaces.pop(); },\n    addVar: function (id) { this.current().map[id] = 'v'; },\n    exists: function (id) { return this.current().map.hasOwnProperty(id); },\n    isClass: function () { return this.current().type === 'c'; },\n    isUserFunction: function(name) {\n      // Loose match (i.e. order ignored)\n      // TODO: does not identify user-defined class methods\n      for (var i = this.namespaces.length - 1; i >= 0; i--)\n        for (var key in this.namespaces[i].map)\n          if (key === name && this.namespaces[i].map[key] === 'f')\n            return true;\n      return false;\n    },\n    isParentClass: function() { return this.current(1).type === 'c'; },\n    isNewObj: function (id) {\n      for (var i = this.namespaces.length - 1; i >= 0; i--)\n        if (this.namespaces[i].map[id] === 'c') return true;\n        else if (this.namespaces[i].map[id] === 'f') break;\n      return false;\n    },\n    getParentClassName: function () { return this.current(1).className; },\n    getThisReplace: function () { return this.current().thisReplace; },\n    setThisReplace: function (s) { this.current().thisReplace = s; }\n  };\n  \n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n  var _newline = {type: \"newline\"}, _indent = {type: \"indent\"}, _dedent = {type: \"dedent\"};\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  \n  var _dict = { keyword: \"dict\" };  // TODO: not a keyword\n  var _as = { keyword: \"as\" }, _assert = { keyword: \"assert\" }, _break = { keyword: \"break\" };\n  var _class = { keyword: \"class\" }, _continue = { keyword: \"continue\" };\n  var _def = { keyword: \"def\" }, _del = { keyword: \"del\" };\n  var _elif = { keyword: \"elif\", beforeExpr: true }, _else = { keyword: \"else\", beforeExpr: true };\n  var _except = { keyword: \"except\", beforeExpr: true }, _finally = {keyword: \"finally\"};\n  var _for = { keyword: \"for\" }, _from = { keyword: \"from\" }, _global = { keyword: \"global\" };\n  var _if = { keyword: \"if\" }, _import = { keyword: \"import\" };\n  var _lambda = {keyword: \"lambda\"}, _nonlocal = {keyword: \"nonlocal\"};\n  var _pass = { keyword: \"pass\" }, _raise = {keyword: \"raise\"};\n  var _return = { keyword: \"return\", beforeExpr: true }, _try = { keyword: \"try\" };\n  var _while = {keyword: \"while\"}, _with = {keyword: \"with\"}, _yield = {keyword: \"yield\"};\n\n  // The keywords that denote values.\n\n  var _none = {keyword: \"None\", atomValue: null}, _true = {keyword: \"True\", atomValue: true};\n  var _false = {keyword: \"False\", atomValue: false};\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n  // 'prec' is the operator precedence'\n\n  var _or = { keyword: \"or\", prec: 1, beforeExpr: true, rep: \"||\" };\n  var _and = { keyword: \"and\", prec: 2, beforeExpr: true, rep: \"&&\" };\n  var _not = { keyword: \"not\", prec: 3, prefix: true, beforeExpr: true, rep: \"!\" };\n  var _in = { keyword: \"in\", prec: 4, beforeExpr: true };\n  var _is = { keyword: \"is\", prec: 4, beforeExpr: true };\n\n  // Map keyword names to token types.\n\n  var keywordTypes = {\n    \"dict\": _dict,\n    \"False\": _false, \"None\": _none, \"True\": _true, \"and\": _and, \"as\": _as, \n    \"break\": _break, \"class\": _class, \"continue\": _continue, \"def\": _def, \"del\": _del,\n    \"elif\": _elif, \"else\": _else, \"except\": _except, \"finally\": _finally, \"for\": _for,\n    \"from\": _from, \"global\": _global, \"if\": _if, \"import\": _import, \"in\": _in, \"is\": _is, \n    \"lambda\": _lambda, \"nonlocal\": _nonlocal, \"not\": _not, \"or\": _or, \n    \"pass\": _pass, \"raise\": _raise, \"return\": _return, \"try\": _try, \"while\": _while, \n    \"with\": _with, \"yield\": _yield\n  };\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = { type: \":\", beforeExpr: true }, _dot = { type: \".\" }, _question = { type: \"?\", beforeExpr: true };\n  \n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `prec` specifies the precedence of this operator.\n  //\n  // `prefix` marks the operator as a prefix unary operator. \n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = { prec: 10, beforeExpr: true }, _eq = { isAssign: true, beforeExpr: true };\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _equality = { prec: 4, beforeExpr: true };\n  var _relational = {prec: 4, beforeExpr: true };\n  var _bitwiseOR = { prec: 5, beforeExpr: true };\n  var _bitwiseXOR = { prec: 6, beforeExpr: true };\n  var _bitwiseAND = { prec: 7, beforeExpr: true };\n  var _bitShift = { prec: 8, beforeExpr: true };\n  var _plusMin = { prec: 9, beforeExpr: true };\n  var _multiplyModulo = { prec: 10, beforeExpr: true };\n  var _floorDiv = { prec: 10, beforeExpr: true };\n  var _posNegNot = { prec: 11, prefix: true, beforeExpr: true };\n  var _bitwiseNOT = { prec: 11, prefix: true, beforeExpr: true };\n  var _exponentiation = { prec: 12, beforeExpr: true };\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n                      num: _num, regexp: _regexp, string: _string,\n                      newline: _newline, indent: _indent, dedent: _dedent,\n                      exponentiation: _exponentiation, floorDiv: _floorDiv, plusMin: _plusMin,\n                      posNegNot: _posNegNot, multiplyModulo: _multiplyModulo\n  };\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\", cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j)\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function(a, b) {return b.length - a.length;});\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n      // Otherwise, simply generate a flat `switch` statement.\n\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The forbidden variable names\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // Keywords\n  // TODO: dict isn't a keyword, it's a builtin\n\n  var isKeyword = makePredicate(\"dict False None True and as assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function Position() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    indentHist.init();\n    newAstIdCount = 0;\n    scope.init();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new Position;\n    tokType = type;\n    if (type === _parenL || type === _braceL || type === _bracketL) ++bracketNesting;\n    if (type === _parenR || type === _braceR || type === _bracketR) --bracketNesting;\n    if (type !== _newline) skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipLine() {\n    var ch = input.charCodeAt(++tokPos);\n    while (tokPos < inputLen && !isNewline(ch)) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new Position;\n    skipLine();\n    if (options.onComment)\n      options.onComment(input.slice(start + 1, tokPos), start, tokPos,\n                        startLoc, options.locations && new Position);\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 35) skipLineComment();\n      else if (ch === 92) {\n        ++tokPos;\n        if (isNewline(input.charCodeAt(tokPos))) {\n          if (input.charCodeAt(tokPos) === 13 && input.charCodeAt(tokPos+1) === 10) ++tokPos;\n          ++tokPos;\n          if (options.location) { tokLineStart = tokPos; ++tokCurLine; }\n        } else {\n          raise(tokPos, \"Unexpected character after line continuation character\");\n        }\n      }\n      else if (isSpace(ch)) ++tokPos;\n      else if (bracketNesting > 0 && isNewline(ch)) {\n        if (ch === 13 && input.charCodeAt(tokPos+1) === 10) ++tokPos;\n        ++tokPos;\n        if (options.location) { tokLineStart = tokPos; ++tokCurLine; }\n      }\n      else break;\n    }\n  }\n\n  function isSpace(ch) {\n    if (ch === 32 || // ' '\n      ch === 9 || ch === 11 || ch === 12 ||\n      ch === 160 || // '\\xa0'\n      ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n      return true;\n    }\n    return false;\n  }\n\n  function isNewline(ch) {\n    if (ch === 10 || ch === 13 ||\n      ch === 8232 || ch === 8233) {\n      return true;\n    }\n    return false;\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() { // '/'\n    if (tokRegexpAllowed) { ++tokPos; return readRegexp(); }\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 47) return finishOp(_floorDiv, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo(code) { // '*%'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 42 && next === code) return finishOp(_exponentiation, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n  \n  function readToken_pipe_amp(code) { // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() { // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) { // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) { // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next === 61) size = 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) { // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, 2);\n    return finishOp(_eq, 1);\n  }\n\n  // Parse indentation\n  // Possible output: _indent, _dedent, _eof, readToken()\n  // TODO: disallow unequal indents of same length (e.g. nested if/else block)\n\n  function readToken_indent() {\n    // Read indent, skip empty lines and comments\n    var indent = \"\";\n    var indentPos = tokPos;\n    var ch, next;\n    while (indentPos < inputLen) {\n      ch = input.charCodeAt(indentPos);\n      if (isSpace(ch)) {\n        indent += String.fromCharCode(ch);\n        ++indentPos;\n      } else if (isNewline(ch)) { // newline\n        indent = \"\";\n        if (ch === 13 && input.charCodeAt(indentPos + 1) === 10) ++indentPos;\n        ++indentPos;\n        tokPos = indentPos;\n        if (options.locations) {\n          tokLineStart = indentPos;\n          ++tokCurLine;\n        }\n      } else if (ch === 35) { // '#'\n        do {\n          next = input.charCodeAt(++indentPos);\n        } while (indentPos < inputLen && next !== 10);\n        // TODO: call onComment\n      } else {\n        break;\n      }\n    }\n\n    // Determine token type based on indent found versus indentation history\n    var type;\n    if (indent.length > 0) {\n      if (indentHist.isIndent(indent)) {\n        type = _indent;\n        if (indentHist.count() >= 1) tokStart += indentHist.len(indentHist.count() - 1);\n        indentHist.addIndent(indent);\n      } else if (indentHist.isDedent(indent)) {\n        type = _dedent;\n        indentHist.addDedent(indent);\n        var nextDedent = indentHist.count() - indentHist.dedentCount;\n        if (nextDedent >= 2) {\n          tokStart += indentHist.len(nextDedent) - indentHist.len(nextDedent - 1);\n        }\n      } else {\n        tokPos += indent.length;\n      }\n    } else if (indentPos >= inputLen) {\n      type = _eof;\n    } else if (indentHist.count() > 0) {\n      type = _dedent;\n      indentHist.updateDedent();\n    }\n\n    switch (type) {\n      case _indent: case _dedent: return finishOp(type, indentPos - ++tokPos);\n      case _eof:\n        tokPos = inputLen;\n        if (options.locations) tokStartLoc = new Position;\n        return finishOp(type, 0);\n      default:\n        tokType = null;\n        return readToken();\n    }\n  }\n\n  function getTokenFromCode(code) {\n    switch(code) {\n\n    case 13: case 10: case 8232: case 8233:\n      ++tokPos;\n      if (code === 13 && input.charCodeAt(tokPos) === 10) ++tokPos;\n      if (options.locations) {\n        ++tokCurLine;\n        tokLineStart = tokPos;\n      }\n      return finishToken(_newline);\n\n    case 35: // '#'\n      skipLineComment();\n      return readToken();\n\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n    case 46: // '.'\n      return readToken_dot();\n\n      // Punctuation tokens.\n    case 40: ++tokPos; return finishToken(_parenL);\n    case 41: ++tokPos; return finishToken(_parenR);\n    case 59: ++tokPos; return finishToken(_semi);\n    case 44: ++tokPos; return finishToken(_comma);\n    case 91: ++tokPos; return finishToken(_bracketL);\n    case 93: ++tokPos; return finishToken(_bracketR);\n    case 123: ++tokPos; return finishToken(_braceL);\n    case 125: ++tokPos; return finishToken(_braceR);\n    case 58: ++tokPos; return finishToken(_colon);\n    case 63: ++tokPos; return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n    case 48: // '0'\n      var next = input.charCodeAt(tokPos + 1);\n      if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return readNumber(false);\n\n      // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return readToken_slash(code);\n\n    case 42: case 37: // '*%'\n      return readToken_mult_modulo(code);\n\n    case 124: case 38: // '|&'\n      return readToken_pipe_amp(code);\n\n    case 94: // '^'\n      return readToken_caret();\n\n    case 43: case 45: // '+-'\n      return readToken_plus_min(code);\n\n    case 60: case 62: // '<>'\n      return readToken_lt_gt(code);\n\n    case 61: case 33: // '=!'\n      return readToken_eq_excl(code);\n\n    case 126: // '~'\n      return finishOp(_bitwiseNOT, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (tokType === _dedent) {\n      indentHist.pop();\n      if (indentHist.dedentCount > 0) return;\n    }\n\n    if (!forceRegexp) tokStart = tokPos;\n    else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new Position;\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n    if (tokType === _newline) return readToken_indent();\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\", escaped, inClass, start = tokPos, value;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;\n        else if (ch === \"]\" && inClass) inClass = false;\n        else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regular expression flag\");\n    try {\n      value = new RegExp(content, mods);\n    } catch (e) {\n      if (e instanceof SyntaxError) raise(start, \"Error parsing regular expression: \" + e.message);\n      raise(e);\n    }\n    return finishToken(_regexp, value);\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos), val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n      else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) { // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos), val;\n    if (isFloat) val = parseFloat(str);\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n    else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var ch = input.charCodeAt(tokPos);\n    var tripleQuoted = false;\n    if (ch === quote && input.charCodeAt(tokPos+1) === quote) {\n      tripleQuoted = true;\n      tokPos += 2;\n    }\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        if (tripleQuoted) {\n          if (input.charCodeAt(tokPos+1) === quote &&\n              input.charCodeAt(tokPos+2) === quote) {\n            tokPos += 3;\n            return finishToken(_string, out);\n          }\n        } else {\n          ++tokPos;\n          return finishToken(_string, out);\n        }\n      }\n      if (ch === 92) { // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n        if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\n          case 85: // 'U'\n            ch = readHexChar(8);\n            if (ch < 0xFFFF && (ch < 0xD800 || 0xDBFF < ch)) out += String.fromCharCode(ch); // If it's UTF-16\n            else { // If we need UCS-2\n              ch -= 0x10000;\n              out += String.fromCharCode((ch>>10)+0xd800)+String.fromCharCode((ch%0x400)+0xdc00);\n            }\n            break;\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n          case 10: // ' \\n'\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n            break;\n          default: out += '\\\\' + String.fromCharCode(ch); break; // Python doesn't remove slashes on failed escapes\n          }\n        }\n      } else {\n        if (isNewline(ch)) {\n          if (tripleQuoted) {\n            out += String.fromCharCode(ch);\n            ++tokPos;\n            if (ch === 13 && input.charCodeAt(tokPos) === 10) {\n              ++tokPos;\n              out += \"\\n\";\n            }\n            if (options.location) { tokLineStart = tokPos; ++tokCurLine; }\n          } else raise(tokStart, \"Unterminated string constant\");\n        } else {\n          out += String.fromCharCode(ch); // '\\'\n          ++tokPos;\n        }\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word, first = true, start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) { // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n          raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc && isKeyword(word))\n      type = keywordTypes[word];\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts - that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = tokStart;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function Node() {\n    this.type = null;\n  }\n\n  exports.Node = Node;\n\n  function SourceLocation() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new Node();\n    if (options.locations)\n      node.loc = new SourceLocation();\n    if (options.directSourceFile)\n      node.sourceFile = options.directSourceFile;\n    if (options.ranges)\n      node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    if (options.locations)\n      node.loc.end = lastEndLoc;\n    if (options.ranges)\n      node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new Node();\n    if (options.locations) {\n      node.loc = new SourceLocation();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges)\n      node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // ## Node creation utilities\n\n  var getNodeCreator = exports.getNodeCreator = function(startNode, startNodeFrom, finishNode, unpackTuple) {\n\n    return {\n\n      // Finish a node whose end offset information should be based on\n      // the end of another node.  For example, createNode* functions\n      // are used to create extra AST nodes which may be based on a single\n      // parsed user code node.\n\n      finishNodeFrom: function (endNode, node, type) {\n        node.type = type;\n        if (options.locations) node.loc.end = endNode.loc.end;\n        if (options.ranges) node.range[1] = endNode.range[1];\n        return node;\n      },\n\n      // Create an AST node using start offsets\n\n      createNodeFrom: function (startNode, type, props) {\n        var node = startNodeFrom(startNode);\n        for (var prop in props) node[prop] = props[prop];\n        return finishNode(node, type);\n      },\n\n      // Create an AST node using start and end offsets\n\n      createNodeSpan: function (startNode, endNode, type, props) {\n        var node = startNodeFrom(startNode);\n        for (var prop in props) node[prop] = props[prop];\n        return this.finishNodeFrom(endNode, node, type);\n      },\n\n      createGeneratedNodeSpan: function (startNode, endNode, type, props) {\n        var node = startNodeFrom(startNode);\n        for (var prop in props) node[prop] = props[prop];\n        node.userCode = false;\n        return this.finishNodeFrom(endNode, node, type);\n      },\n\n      // while (__formalsIndex < __params.formals.length) {\n      //   <argsId>.push(__params.formals[__formalsIndex++]); }\n      createNodeArgsWhileConsequent: function (argsId, s) {\n        var __realArgCountId  = this.createGeneratedNodeSpan(argsId, argsId, \"Identifier\", { name:  '__realArgCount' + s });\n        var __paramsFormals  = this.createGeneratedNodeSpan(argsId, argsId, \"Identifier\", { name:  'arguments' });\n        var __formalsIndexId = this.createGeneratedNodeSpan(argsId, argsId, \"Identifier\", { name: '__formalsIndex' + s });\n        return this.createGeneratedNodeSpan(argsId, argsId, \"WhileStatement\", {\n          test: this.createGeneratedNodeSpan(argsId, argsId, \"BinaryExpression\", {\n            operator: '<', left: __formalsIndexId,\n            right: __realArgCountId\n          }),\n          body: this.createGeneratedNodeSpan(argsId, argsId, \"BlockStatement\", {\n            body: [this.createGeneratedNodeSpan(argsId, argsId, \"ExpressionStatement\", {\n              expression: this.createGeneratedNodeSpan(argsId, argsId, \"CallExpression\", {\n                callee: this.createNodeMembIds(argsId, argsId.name, 'push'),\n                arguments: [this.createGeneratedNodeSpan(argsId, argsId, \"MemberExpression\", {\n                  computed: true, object: __paramsFormals,\n                  property: this.createGeneratedNodeSpan(argsId, argsId, \"UpdateExpression\", {\n                    operator: '++', prefix: false, argument: __formalsIndexId\n                  })\n                })]\n              })\n            })]\n          })\n        });\n      },\n\n      // { while (__formalsIndex < __args.length) {\n      //   <argsId>.push(__args[__formalsIndex++]); }}\n      createNodeArgsAlternate: function (argsId, s) {\n        var __args = '__args' + s;\n        var __formalsIndexId = this.createGeneratedNodeSpan(argsId, argsId, \"Identifier\", { name: '__formalsIndex' + s });\n        return this.createGeneratedNodeSpan(argsId, argsId, \"BlockStatement\", {\n          body: [this.createGeneratedNodeSpan(argsId, argsId, \"WhileStatement\", {\n            test: this.createGeneratedNodeSpan(argsId, argsId, \"BinaryExpression\", {\n              operator: '<', left: __formalsIndexId,\n              right: this.createNodeMembIds(argsId, __args, 'length')\n            }),\n            body: this.createGeneratedNodeSpan(argsId, argsId, \"BlockStatement\", {\n              body: [this.createGeneratedNodeSpan(argsId, argsId, \"ExpressionStatement\", {\n                expression: this.createGeneratedNodeSpan(argsId, argsId, \"CallExpression\", {\n                  callee: this.createNodeMembIds(argsId, argsId.name, 'push'),\n                  arguments: [this.createGeneratedNodeSpan(argsId, argsId, \"MemberExpression\", {\n                    computed: true,\n                    object: this.createGeneratedNodeSpan(argsId, argsId, \"Identifier\", { name: __args }),\n                    property: this.createGeneratedNodeSpan(argsId, argsId, \"UpdateExpression\", {\n                      operator: '++', prefix: false, argument: __formalsIndexId\n                    })\n                  })]\n                })\n              })]\n            })\n          })]\n        });\n      },\n\n      // return (function() {<body>}).call(this);\n      createNodeFnBodyIife: function (body) {\n        var iifeBody = this.createGeneratedNodeSpan(body, body, \"FunctionExpression\", {\n          params: [], defaults: [], body: body, generator: false, expression: false\n        });\n        var iifeCall = this.createGeneratedNodeSpan(body, body, \"CallExpression\", {\n          callee: this.createGeneratedNodeSpan(body, body, \"MemberExpression\", {\n            computed: false, object: iifeBody,\n            property: this.createGeneratedNodeSpan(body, body, \"Identifier\", { name: 'call' })\n          }),\n          arguments: [this.createGeneratedNodeSpan(body, body, \"ThisExpression\")]\n        });\n        return this.createGeneratedNodeSpan(body, body, \"ReturnStatement\", { argument: iifeCall });\n      },\n\n      // E.g. Math.pow(2, 3)\n\n      createNodeMemberCall: function (node, object, property, args) {\n        var objId = this.createNodeFrom(node, \"Identifier\", { name: object });\n        var propId = this.createNodeFrom(node, \"Identifier\", { name: property });\n        var member = this.createNodeFrom(node, \"MemberExpression\", { object: objId, property: propId, computed: false });\n        node.callee = member;\n        node.arguments = args;\n        return finishNode(node, \"CallExpression\");\n      },\n\n      // o.p\n      createNodeMembIds: function(r, o, p) {\n        return this.createNodeSpan(r, r, \"MemberExpression\", {\n          computed: false,\n          object: this.createNodeSpan(r, r, \"Identifier\", { name: o }),\n          property: this.createNodeSpan(r, r, \"Identifier\", { name: p })\n        })\n      },\n\n      // o[p]\n      createNodeMembIdLit: function(r, o, p) {\n        return this.createNodeSpan(r, r, \"MemberExpression\", {\n          computed: true,\n          object: this.createNodeSpan(r, r, \"Identifier\", { name: o }),\n          property: this.createNodeSpan(r, r, \"Literal\", { value: p })\n        })\n      },\n\n      // E.g. pyRuntime.ops.add\n\n      createNodeOpsCallee: function (node, fnName) {\n        var runtimeId = this.createGeneratedNodeSpan(node, node, \"Identifier\", { name: options.runtimeParamName });\n        var opsId = this.createGeneratedNodeSpan(node, node, \"Identifier\", { name: \"ops\" });\n        var addId = this.createGeneratedNodeSpan(node, node, \"Identifier\", { name: fnName });\n        var opsMember = this.createGeneratedNodeSpan(node, node, \"MemberExpression\", { object: runtimeId, property: opsId, computed: false });\n        return this.createGeneratedNodeSpan(node, node, \"MemberExpression\", { object: opsMember, property: addId, computed: false });\n      },\n\n      // E.g. pyRuntime.utils.add\n\n      createNodeRuntimeCall: function (r, mod, fn, args) {\n        return this.createNodeSpan(r, r, \"CallExpression\", {\n          callee: this.createNodeSpan(r, r, \"MemberExpression\", {\n            computed: false,\n            object: this.createNodeMembIds(r, options.runtimeParamName,  mod),\n            property: this.createNodeSpan(r, r, \"Identifier\", { name: fn })\n          }),\n          arguments: args\n        });\n      },\n\n      // Used to convert 'id = init' to 'var id = init'\n\n      createVarDeclFromId: function (refNode, id, init) {\n        var decl = startNodeFrom(refNode);\n        decl.id = id;\n        decl.init = init;\n        this.finishNodeFrom(refNode, decl, \"VariableDeclarator\");\n        var declDecl = startNodeFrom(refNode);\n        declDecl.kind = \"var\";\n        declDecl.declarations = [decl];\n        return this.finishNodeFrom(refNode, declDecl, \"VariableDeclaration\");\n      },\n\n      createGeneratedVarDeclFromId: function (refNode, id, init) {\n        var decl = startNodeFrom(refNode);\n        decl.id = id;\n        decl.init = init;\n        this.finishNodeFrom(refNode, decl, \"VariableDeclarator\");\n        var declDecl = startNodeFrom(refNode);\n        declDecl.kind = \"var\";\n        declDecl.declarations = [decl];\n        declDecl.userCode = false;\n        return this.finishNodeFrom(refNode, declDecl, \"VariableDeclaration\");\n      },\n\n      createClass: function(container, ctorNode, classParams, classBodyRefNode, classBlock) {\n        // Helper to identify class methods which were parsed onto the class prototype\n\n        function getPrototype(stmt) {\n          if (stmt.expression && stmt.expression.left && stmt.expression.left.object &&\n            stmt.expression.left.object.property && stmt.expression.left.object.property.name === \"prototype\")\n            return stmt.expression.left.property.name;\n          return null;\n        }\n\n        // Start building class constructor\n\n        var ctorBlock = startNodeFrom(classBlock);\n        ctorBlock.body = [];\n\n        // Add parent class constructor call\n\n        if (classParams.length === 1) {\n          var objId = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"Identifier\", { name: classParams[0].name });\n          var propertyId = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"Identifier\", { name: \"call\" });\n          var calleeMember = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"MemberExpression\", { object: objId, property: propertyId, computed: false });\n          var thisExpr = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"ThisExpression\");\n          var callExpr = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"CallExpression\", { callee: calleeMember, arguments: [thisExpr] });\n          var superExpr = this.createNodeSpan(classBodyRefNode, classBodyRefNode, \"ExpressionStatement\", { expression: callExpr });\n          ctorBlock.body.push(superExpr);\n        }\n\n        // Add non-function statements and contents of special '__init__' method\n\n        for (var i in classBlock.body) {\n          var stmt = classBlock.body[i];\n          var prototype = getPrototype(stmt);\n          if (!prototype) {\n            ctorBlock.body.push(stmt);\n          }\n          else if (prototype === \"__init__\") {\n            for (var j in stmt.expression.right.body.body)\n              ctorBlock.body.push(stmt.expression.right.body.body[j]);\n            ctorNode.params = stmt.expression.right.params;\n          }\n        }\n\n        // Finish class constructor\n\n        ctorNode.body = finishNode(ctorBlock, \"BlockStatement\");\n        finishNode(ctorNode, \"FunctionDeclaration\");\n        container.body.push(ctorNode);\n\n        // Add inheritance via 'MyClass.prototype = Object.create(ParentClass.prototype)'\n\n        if (classParams.length === 1) {\n          var childClassId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: ctorNode.id.name });\n          var childPrototypeId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: \"prototype\" });\n          var childPrototypeMember = this.createNodeSpan(ctorNode, ctorNode, \"MemberExpression\", { object: childClassId, property: childPrototypeId, computed: false });\n          var parentClassId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: classParams[0].name });\n          var parentPrototypeId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: \"prototype\" });\n          var parentPrototypeMember = this.createNodeSpan(ctorNode, ctorNode, \"MemberExpression\", { object: parentClassId, property: parentPrototypeId, computed: false });\n          var objClassId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: \"Object\" });\n          var objCreateId = this.createNodeSpan(ctorNode, ctorNode, \"Identifier\", { name: \"create\" });\n          var objPropertyMember = this.createNodeSpan(ctorNode, ctorNode, \"MemberExpression\", { object: objClassId, property: objCreateId, computed: false });\n          var callExpr = this.createNodeSpan(ctorNode, ctorNode, \"CallExpression\", { callee: objPropertyMember, arguments: [parentPrototypeMember] });\n          var assignExpr = this.createNodeSpan(ctorNode, ctorNode, \"AssignmentExpression\", { left: childPrototypeMember, operator: \"=\", right: callExpr });\n          var inheritanceExpr = this.createNodeSpan(ctorNode, ctorNode, \"ExpressionStatement\", { expression: assignExpr });\n          container.body.push(inheritanceExpr);\n        }\n\n        // Add class methods, which are already prototype assignments\n\n        for (var i in classBlock.body) {\n          var stmt = classBlock.body[i];\n          var prototype = getPrototype(stmt);\n          if (prototype && prototype !== \"__init__\")\n            container.body.push(stmt);\n        }\n\n        return finishNode(container, \"BlockStatement\");\n      },\n\n      // Create for loop\n      // \n      // Problem:\n      // 1. JavaScript for/in loop iterates on properties, which are the indexes for an Array\n      //    Python iterates on the list items themselves, not indexes\n      // 2. JavaScript for/in does not necessarily iterate in order\n      // Solution:\n      // Generate extra AST to do the right thing at runtime\n      // JavaScript for/in is used for dictionaries\n      // If iterating through an ordered sequence, return something like: \n      // { var __right = right; \n      //    if (__right instanceof Array) { \n      //      for(var __index=0; __index < __right.length; __index++) {\n      //        i = __right[__index]; \n      //        ...\n      //      } \n      //    } else { \n      //      for(i in __right){...} \n      //    }\n      // }\n      // When the loop target is a Tuple, it is unpacked into each for body in the example above.\n      // E.g. 'for k, v in __right: total += v' becomes:\n      // for (var __tmp in __right) {\n      //    k = __tmp[0];\n      //    v = __tmp[1];\n      //    total += v;\n      // }\n\n      // TODO: for/in on a string should go through items, not indexes. String obj and string literal.\n\n      createFor: function (node, init, tupleArgs, right, body) {\n        var forOrderedBody = body;\n        var forInBody = JSON.parse(JSON.stringify(forOrderedBody));\n\n        var tmpVarSuffix = newAstIdCount++;\n\n        var arrayId = this.createNodeSpan(node, node, \"Identifier\", { name: \"Array\" });\n        var lengthId = this.createNodeSpan(init, init, \"Identifier\", { name: \"length\" });\n        var zeroLit = this.createNodeSpan(init, init, \"Literal\", { value: 0 });\n\n        // var __rightN = right\n\n        var rightId = this.createNodeSpan(right, right, \"Identifier\", { name: \"__filbertRight\" + tmpVarSuffix });\n        var rightAssign = this.createVarDeclFromId(right, rightId, right);\n\n        // for(;;) and for(in) loops\n\n        var forRightId = this.createNodeSpan(init, init, \"Identifier\", { name: \"__filbertRight\" + tmpVarSuffix });\n\n        // for (var __indexN; __indexN < __rightN.length; ++__indexN)\n\n        var forOrderedIndexId = this.createNodeSpan(init, init, \"Identifier\", { name: \"__filbertIndex\" + tmpVarSuffix });\n        var forOrderedIndexDeclr = this.createNodeSpan(init, init, \"VariableDeclarator\", { id: forOrderedIndexId, init: zeroLit });\n        var forOrderedIndexDecln = this.createNodeSpan(init, init, \"VariableDeclaration\", { declarations: [forOrderedIndexDeclr], kind: \"var\" });\n        var forOrderedTestMember = this.createNodeSpan(init, init, \"MemberExpression\", { object: forRightId, property: lengthId, computed: false });\n        var forOrderedTestBinop = this.createNodeSpan(init, init, \"BinaryExpression\", { left: forOrderedIndexId, operator: \"<\", right: forOrderedTestMember });\n        var forOrderedUpdate = this.createNodeSpan(init, init, \"UpdateExpression\", { operator: \"++\", prefix: true, argument: forOrderedIndexId });\n        var forOrderedMember = this.createNodeSpan(init, init, \"MemberExpression\", { object: forRightId, property: forOrderedIndexId, computed: true });\n\n        if (tupleArgs) {\n          var varStmts = unpackTuple(tupleArgs, forOrderedMember);\n          for (var i = varStmts.length - 1; i >= 0; i--) forOrderedBody.body.unshift(varStmts[i]);\n        }\n        else {\n          if (init.type === \"Identifier\" && !scope.exists(init.name)) {\n            scope.addVar(init.name);\n            forOrderedBody.body.unshift(this.createVarDeclFromId(init, init, forOrderedMember));\n          } else {\n            var forOrderedInit = this.createNodeSpan(init, init, \"AssignmentExpression\", { operator: \"=\", left: init, right: forOrderedMember });\n            var forOrderedInitStmt = this.createNodeSpan(init, init, \"ExpressionStatement\", { expression: forOrderedInit });\n            forOrderedBody.body.unshift(forOrderedInitStmt);\n          }\n        }\n\n        var forOrdered = this.createNodeSpan(node, node, \"ForStatement\", { init: forOrderedIndexDecln, test: forOrderedTestBinop, update: forOrderedUpdate, body: forOrderedBody });\n        var forOrderedBlock = this.createNodeSpan(node, node, \"BlockStatement\", { body: [forOrdered] });\n\n        // for (init in __rightN)\n\n        var forInLeft = init;\n        if (tupleArgs) {\n          var varStmts = unpackTuple(tupleArgs, right);\n          forInLeft = varStmts[0];\n          for (var i = varStmts.length - 1; i > 0; i--) forInBody.body.unshift(varStmts[i]);\n        }\n        else if (init.type === \"Identifier\" && !scope.exists(init.name)) {\n          scope.addVar(init.name);\n          forInLeft = this.createVarDeclFromId(init, init, null);\n        }\n        var forIn = this.createNodeSpan(node, node, \"ForInStatement\", { left: forInLeft, right: forRightId, body: forInBody });\n        var forInBlock = this.createNodeSpan(node, node, \"BlockStatement\", { body: [forIn] });\n\n        // if ordered sequence then forOrdered else forIn\n\n        var ifRightId = this.createNodeSpan(node, node, \"Identifier\", { name: \"__filbertRight\" + tmpVarSuffix });\n        var ifTest = this.createNodeSpan(node, node, \"BinaryExpression\", { left: ifRightId, operator: \"instanceof\", right: arrayId });\n        var ifStmt = this.createNodeSpan(node, node, \"IfStatement\", { test: ifTest, consequent: forOrderedBlock, alternate: forInBlock });\n\n        node.body = [rightAssign, ifStmt];\n\n        return node;\n      },\n\n      // expr => __tmpList.push(expr);\n\n      createListCompPush: function (expr, tmpVarSuffix) {\n        var exprPushTmpListId = this.createNodeSpan(expr, expr, \"Identifier\", { name: \"__tmpList\" + tmpVarSuffix });\n        var exprPushId = this.createNodeSpan(expr, expr, \"Identifier\", { name: \"push\" });\n        var exprMember = this.createNodeSpan(expr, expr, \"MemberExpression\", { object: exprPushTmpListId, property: exprPushId, computed: false });\n        var exprCall = this.createNodeSpan(expr, expr, \"CallExpression\", { callee: exprMember, arguments: [expr] });\n        return this.createNodeSpan(expr, expr, \"ExpressionStatement\", { expression: exprCall });\n      },\n\n      //  (function() {\n      //    var _list = [];\n      //    ...\n      //    body\n      //    return _list;\n      //  }());\n\n      createListCompIife: function (node, body, tmpVarSuffix) {\n        var iifeRuntimeId = this.createNodeSpan(node, node, \"Identifier\", { name: options.runtimeParamName });\n        var iifeObjectsId = this.createNodeSpan(node, node, \"Identifier\", { name: \"objects\" });\n        var iifeObjMember = this.createNodeSpan(node, node, \"MemberExpression\", { object: iifeRuntimeId, property: iifeObjectsId, computed: false });\n        var iifeListId = this.createNodeSpan(node, node, \"Identifier\", { name: \"list\" });\n        var iifeListMember = this.createNodeSpan(node, node, \"MemberExpression\", { object: iifeObjMember, property: iifeListId, computed: false });\n        var iifeNewExpr = this.createNodeSpan(node, node, \"NewExpression\", { callee: iifeListMember, arguments: [] });\n        var iifeListId = this.createNodeSpan(node, node, \"Identifier\", { name: \"__tmpList\" + tmpVarSuffix });\n        var iifeListDecl = this.createVarDeclFromId(node, iifeListId, iifeNewExpr);\n\n        var iifeReturnListId = this.createNodeSpan(node, node, \"Identifier\", { name: \"__tmpList\" + tmpVarSuffix });\n        var iifeReturn = this.createNodeSpan(node, node, \"ReturnStatement\", { argument: iifeReturnListId });\n\n        var iifeBlock = this.createNodeSpan(node, node, \"BlockStatement\", { body: [iifeListDecl, body, iifeReturn] });\n        var fnExpr = this.createNodeSpan(node, node, \"FunctionExpression\", { params: [], defaults: [], body: iifeBlock, generator: false, expression: false });\n\n        return this.createNodeSpan(node, node, \"CallExpression\", { callee: fnExpr, arguments: [] });\n      }\n    };\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();\n    else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval - something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n      raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // Get args for a new tuple expression\n\n  function getTupleArgs(expr) {\n    if (expr.callee && expr.callee.object && expr.callee.object.object &&\n      expr.callee.object.object.name === options.runtimeParamName &&\n      expr.callee.property && expr.callee.property.name === \"tuple\")\n      return expr.arguments;\n    return null;\n  }\n\n  // Unpack an lvalue tuple into indivual variable assignments\n  // 'arg0, arg1 = right' becomes:\n  // var tmp = right\n  // arg0 = tmp[0]\n  // arg1 = tmp[1]\n  // ...\n\n  function unpackTuple(tupleArgs, right) {\n    if (!tupleArgs || tupleArgs.length < 1) unexpected();\n\n    var varStmts = [];\n\n    // var tmp = right\n\n    var tmpId = nc.createNodeSpan(right, right, \"Identifier\", { name: \"__filbertTmp\" + newAstIdCount++ });\n    var tmpDecl = nc.createVarDeclFromId(right, tmpId, right);\n    varStmts.push(tmpDecl);\n\n    // argN = tmp[N]\n\n    for (var i = 0; i < tupleArgs.length; i++) {\n      var lval = tupleArgs[i];\n      var subTupleArgs = getTupleArgs(lval);\n      if (subTupleArgs) {\n        var subLit = nc.createNodeSpan(right, right, \"Literal\", { value: i });\n        var subRight = nc.createNodeSpan(right, right, \"MemberExpression\", { object: tmpId, property: subLit, computed: true });\n        var subStmts = unpackTuple(subTupleArgs, subRight);\n        for (var j = 0; j < subStmts.length; j++) varStmts.push(subStmts[j]);\n      } else {\n        checkLVal(lval);\n        var indexId = nc.createNodeSpan(right, right, \"Literal\", { value: i });\n        var init = nc.createNodeSpan(right, right, \"MemberExpression\", { object: tmpId, property: indexId, computed: true });\n        if (lval.type === \"Identifier\" && !scope.exists(lval.name)) {\n          scope.addVar(lval.name);\n          var varDecl = nc.createVarDeclFromId(lval, lval, init);\n          varStmts.push(varDecl);\n        }\n        else {\n          var node = startNodeFrom(lval);\n          node.left = lval;\n          node.operator = \"=\";\n          node.right = init;\n          finishNode(node, \"AssignmentExpression\");\n          varStmts.push(nc.createNodeFrom(node, \"ExpressionStatement\", { expression: node }));\n        }\n      }\n    }\n\n    return varStmts;\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new Position;\n    inFunction = strict = null;\n    bracketNesting = 0;\n    readToken();\n    var node = program || startNode();\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      if (stmt) node.body.push(stmt);\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n      readToken(true);\n\n    var starttype = tokType, node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n\n    case _break:\n      next();\n      return finishNode(node, \"BreakStatement\");\n\n    case _continue:\n      next();\n      return finishNode(node, \"ContinueStatement\");\n\n    case _class:\n      next();\n      return parseClass(node);\n\n    case _def:\n      next();\n      return parseFunction(node);\n\n    case _for:\n      next();\n      return parseFor(node);\n\n    case _from: // Skipping from and import statements for now\n      skipLine();\n      next();\n      return parseStatement();\n\n    case _if: case _elif:\n      next();\n      if (tokType === _parenL) node.test = parseParenExpression();\n      else node.test = parseExpression();\n      expect(_colon);\n      node.consequent = parseSuite();\n      if (tokType === _elif) {\n        node.alternate = parseStatement();\n      }\n      else if (eat(_else)) {\n        expect(_colon);\n        eat(_colon);\n        node.alternate = parseSuite();\n      }\n      else {\n        node.alternate = null;\n      } \n      return finishNode(node, \"IfStatement\");\n\n    case _import: // Skipping from and import statements for now\n      skipLine();\n      next();\n      return parseStatement();\n\n    case _newline:\n      // TODO: parseStatement() should probably eat it's own newline\n      next();\n      return null;\n\n    case _pass:\n      next();\n      return finishNode(node, \"EmptyStatement\");\n\n    case _return:\n      if (!inFunction && !options.allowReturnOutsideFunction)\n        raise(tokStart, \"'return' outside of function\");\n      next();\n      if (tokType ===_newline || tokType === _eof) node.argument = null;\n      else { node.argument = parseExpression();}\n      return finishNode(node, \"ReturnStatement\");\n\n    case _try: // TODO, and remove parseBlock\n      next();\n      node.block = parseBlock();\n      node.handler = null;\n      if (tokType === _catch) {\n        var clause = startNode();\n        next();\n        expect(_parenL);\n        clause.param = parseIdent();\n        if (strict && isStrictBadIdWord(clause.param.name))\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n        expect(_parenR);\n        clause.guard = null;\n        clause.body = parseBlock();\n        node.handler = finishNode(clause, \"CatchClause\");\n      }\n      node.guardedHandlers = empty;\n      node.finalizer = eat(_finally) ? parseBlock() : null;\n      if (!node.handler && !node.finalizer)\n        raise(node.start, \"Missing catch or finally clause\");\n      return finishNode(node, \"TryStatement\");\n\n    case _while:\n      next();\n      if (tokType === _parenL) node.test = parseParenExpression();\n      else node.test = parseExpression();\n      expect(_colon);\n      node.body = parseSuite();\n      return finishNode(node, \"WhileStatement\");\n\n    case _with: // TODO\n      if (strict) raise(tokStart, \"'with' in strict mode\");\n      next();\n      node.object = parseParenExpression();\n      node.body = parseStatement();\n      return finishNode(node, \"WithStatement\");\n\n    case _semi:\n      next();\n      return finishNode(node, \"EmptyStatement\");\n\n      // Assume it's an ExpressionStatement. If an assign has been \n      // converted to a variable declaration, pass it up as is.\n\n    default:\n      var expr = parseExpression();\n      if (tokType !== _semi && tokType !== _newline && tokType !== _eof) unexpected();\n      if (expr.type === \"VariableDeclaration\" || expr.type === \"BlockStatement\") {\n        return expr;\n      } else {\n        node.expression = expr;\n        return finishNode(node, \"ExpressionStatement\");\n      }\n    }\n  }\n\n  // Parse indent-enclosed block of statements\n\n  function parseBlock() {\n    var node = startNode();\n    node.body = [];\n    while (tokType !== _dedent && tokType !== _eof) {\n      var stmt = parseStatement();\n      if (stmt) node.body.push(stmt);\n    }\n    if (tokType === _dedent) next();\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse 'suite' from Python grammar spec\n  // Will replace parseBlock eventually\n\n  function parseSuite() {\n    // NOTE: This is not strictly valid Python for this to be an empty block\n    var node = startNode();\n    node.body = [];\n    if (eat(_newline)) {\n      if (tokType === _indent) {\n        expect(_indent);\n        while (!eat(_dedent) && !eat(_eof)) {\n          var stmt = parseStatement();\n          if (stmt) node.body.push(stmt);\n        }\n      }\n    } else if (tokType !== _eof) {\n      node.body.push(parseStatement());\n      next();\n    }\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse for/in loop\n\n  function parseFor(node) {\n    var init = parseExpression(false, true);\n    var tupleArgs = getTupleArgs(init);\n    if (!tupleArgs) checkLVal(init);\n    expect(_in);\n    var right = parseExpression();\n    expect(_colon);\n    var body = parseSuite();\n    finishNode(node, \"BlockStatement\");\n    return nc.createFor(node, init, tupleArgs, right, body);\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    return parseMaybeAssign(noIn);\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // Add 'this.' to assignments in a class constructor.\n  // Convert identifier assignment to variable declaration if the\n  // identifier doesn't exist in this namespace yet.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeTuple(noIn);\n    if (tokType.isAssign) {\n      var tupleArgs = getTupleArgs(left);\n      if (tupleArgs) {\n        next();\n        var right = parseMaybeTuple(noIn);\n        var blockNode = startNodeFrom(left);\n        blockNode.body = unpackTuple(tupleArgs, right);\n        return finishNode(blockNode, \"BlockStatement\");\n      }\n\n      if (scope.isClass()) {\n        var thisExpr = nc.createNodeFrom(left, \"ThisExpression\");\n        left = nc.createNodeFrom(left, \"MemberExpression\", { object: thisExpr, property: left });\n      }\n\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeTuple(noIn);\n      checkLVal(left);\n\n      if (node.operator === '+=' || node.operator === '*=') {\n        var right = nc.createNodeSpan(node.right, node.right, \"CallExpression\");\n        right.callee = nc.createNodeOpsCallee(right, node.operator === '+=' ? \"add\" : \"multiply\");\n        right.arguments = [left, node.right];\n        node.right = right;\n        node.operator = '=';\n      }\n\n      if (left.type === \"Identifier\" && !scope.exists(left.name)) {\n        if (!node.operator || node.operator.length > 1) unexpected();\n        scope.addVar(left.name);\n        return nc.createVarDeclFromId(node.left, node.left, node.right);\n      }\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a tuple\n\n  function parseMaybeTuple(noIn) {\n    var expr = parseExprOps(noIn);\n    if (tokType === _comma) {\n      return parseTuple(noIn, expr);\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(noIn), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n  // Exponentiation is evaluated right-to-left, so 'prec >= minPrec'\n  // Exponentiation operator 'x**y' is replaced with 'Math.pow(x, y)'\n  // Floor division operator 'x//y' is replaced with 'Math.floor(x/y)'\n  // 'in' and 'not in' implemented via indexOf()\n\n  function parseExprOp(left, minPrec, noIn) {\n    var node, exprNode, right, op = tokType, val = tokVal;\n    var prec = op === _not ? _in.prec : op.prec;\n    if (op === _exponentiation && prec >= minPrec) {\n      node = startNodeFrom(left);\n      next();\n      right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);\n      exprNode = nc.createNodeMemberCall(node, \"Math\", \"pow\", [left, right]);\n      return parseExprOp(exprNode, minPrec, noIn);\n    } else if (prec != null && (!noIn || op !== _in)) {\n      if (prec > minPrec) {\n        next();\n        node = startNodeFrom(left);\n        if (op === _floorDiv) {\n          right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);\n          finishNode(node);\n          var binExpr = nc.createNodeSpan(node, node, \"BinaryExpression\", { left: left, operator: '/', right: right });\n          exprNode = nc.createNodeMemberCall(node, \"Math\", \"floor\", [binExpr]);\n        } else if (op === _in || op === _not) {\n          if (op === _in || eat(_in)) {\n            right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);\n            finishNode(node);\n            var notLit = nc.createNodeSpan(node, node, \"Literal\", { value: op === _not });\n            exprNode = nc.createNodeRuntimeCall(node, 'ops', 'in', [left, right, notLit]);\n          } else raise(tokPos, \"Expected 'not in' comparison operator\");\n        } else if (op === _plusMin && val === '+' || op === _multiplyModulo && val === '*') {\n          node.arguments = [left];\n          node.arguments.push(parseExprOp(parseMaybeUnary(noIn), prec, noIn));\n          finishNode(node, \"CallExpression\");\n          node.callee = nc.createNodeOpsCallee(node, op === _plusMin ? \"add\" : \"multiply\");\n          exprNode = node;\n        } else {\n          if (op === _is) {\n            if (eat(_not)) node.operator = \"!==\";\n            else node.operator = \"===\";\n          } else node.operator = op.rep != null ? op.rep : val;\n          node.left = left;\n          node.right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);\n          exprNode = finishNode(node, (op === _or || op === _and) ? \"LogicalExpression\" : \"BinaryExpression\");\n        }\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators.\n  // '-+' are prefixes here, with different precedence.\n\n  function parseMaybeUnary(noIn) {\n    if (tokType.prefix || tokType === _plusMin) {\n      var prec = tokType === _plusMin ? _posNegNot.prec : tokType.prec;\n      var node = startNode();\n      node.operator = tokType.rep != null ? tokType.rep : tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseExprOp(parseMaybeUnary(noIn), prec, noIn);\n      return finishNode(node, \"UnaryExpression\");\n    }\n    return parseSubscripts(parseExprAtom());\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseSubscripts(base, noCalls) {\n    var node = startNodeFrom(base);\n    if (eat(_dot)) {\n      var id = parseIdent(true);\n      if (pythonRuntime.imports[base.name] && pythonRuntime.imports[base.name][id.name]) {\n        // Calling a Python import function\n        // TODO: Unpack parameters into JavaScript-friendly parameters\n        var runtimeId = nc.createNodeSpan(base, base, \"Identifier\", { name: options.runtimeParamName });\n        var importsId = nc.createNodeSpan(base, base, \"Identifier\", { name: \"imports\" });\n        var runtimeMember = nc.createNodeSpan(base, base, \"MemberExpression\", { object: runtimeId, property: importsId, computed: false });\n        node.object = nc.createNodeSpan(base, base, \"MemberExpression\", { object: runtimeMember, property: base, computed: false });\n      } else if (base.name && base.name === scope.getThisReplace()) {\n        node.object = nc.createNodeSpan(base, base, \"ThisExpression\");\n      } else node.object = base;\n      node.property = id;\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var expr, isSlice = false;\n      if (eat(_colon)) isSlice = true;\n      else expr = parseExpression();\n      if (!isSlice && eat(_colon)) isSlice = true;\n      if (isSlice) return parseSlice(node, base, expr, noCalls);\n      var subscriptCall = nc.createNodeSpan(expr, expr, \"CallExpression\");\n      subscriptCall.callee = nc.createNodeOpsCallee(expr, \"subscriptIndex\");\n      subscriptCall.arguments = [base, expr];\n      node.object = base;\n      node.property = subscriptCall;\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      if (scope.isUserFunction(base.name)) {\n        // Unpack parameters into JavaScript-friendly parameters, further processed at runtime\n        var pl = parseParamsList();\n        \n        var args = [];\n        var other = [];\n        for ( var i = 0; i < pl.length; ++i ) {\n          if ( pl[i].isntFormal ) other.push(pl[i]);\n          else args.push(pl[i]);\n        }\n\n        if ( other.length > 0 ) {\n          var createParamsCall = nc.createNodeRuntimeCall(node, 'utils', 'createParamsObj', other);\n          args.push(createParamsCall);\n        }\n\n        node.arguments = args;\n      } else node.arguments = parseExprList(_parenR, false);\n\n\n      if ( base.name === 'len' && node.arguments.length === 1 ) {\n        node.type = \"MemberExpression\",\n        node.object = node.arguments[0];\n        node.property = nc.createNodeSpan(base, base, \"Identifier\", { name: \"length\"}),\n        node.computed = false;\n        delete node.arguments;\n        delete node.callee;\n        finishNode(node, \"MemberExpression\");\n        return node; \n      }\n\n      if (scope.isNewObj(base.name)) finishNode(node, \"NewExpression\");\n      else finishNode(node, \"CallExpression\");\n\n      if (pythonRuntime.functions[base.name]) {\n        // Calling a Python built-in function\n        // TODO: Unpack parameters into JavaScript-friendly parameters\n        if (base.type !== \"Identifier\") unexpected();\n        var runtimeId = nc.createNodeSpan(base, base, \"Identifier\", { name: options.runtimeParamName });\n        var functionsId = nc.createNodeSpan(base, base, \"Identifier\", { name: \"functions\" });\n        var runtimeMember = nc.createNodeSpan(base, base, \"MemberExpression\", { object: runtimeId, property: functionsId, computed: false });\n        node.callee = nc.createNodeSpan(base, base, \"MemberExpression\", { object: runtimeMember, property: base, computed: false });\n      } else node.callee = base;\n      return parseSubscripts(node, noCalls);\n    }\n    return base;\n  }\n\n  function parseSlice(node, base, start, noCalls) {\n    var end, step;\n    if (!start) start = nc.createNodeFrom(node, \"Literal\", { value: null });\n    if (tokType === _bracketR || eat(_colon)) {\n      end = nc.createNodeFrom(node, \"Literal\", { value: null });\n    } else {\n      end = parseExpression();\n      if (tokType !== _bracketR) expect(_colon);\n    }\n    if (tokType === _bracketR) step = nc.createNodeFrom(node, \"Literal\", { value: null });\n    else step = parseExpression();\n    expect(_bracketR);\n\n    node.arguments = [start, end, step];\n    var sliceId = nc.createNodeFrom(base, \"Identifier\", { name: \"_pySlice\" });\n    var memberExpr = nc.createNodeSpan(base, base, \"MemberExpression\", { object: base, property: sliceId, computed: false });\n    node.callee = memberExpr;\n    return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n  }\n\n  // Parse an atomic expression - either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n\n    case _dict:\n      next();\n      return parseDict(_parenR);\n\n    case _name:\n      return parseIdent();\n\n    case _num: case _string: case _regexp:\n      var node = startNode();\n      node.value = tokVal;\n      node.raw = input.slice(tokStart, tokEnd);\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _none: case _true: case _false:\n      var node = startNode();\n      node.value = tokType.atomValue;\n      node.raw = tokType.keyword;\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _parenL:\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n      next();\n      if (tokType === _parenR) {\n        // Empty tuple\n        var node = parseTuple(false);\n        eat(_parenR);\n        return node;\n      }\n      var val = parseMaybeTuple(false);\n      if (options.locations) {\n        val.loc.start = tokStartLoc1;\n        val.loc.end = tokEndLoc;\n      }\n      if (options.ranges)\n        val.range = [tokStart1, tokEnd];\n      expect(_parenR);\n      return val;\n\n    case _bracketL:\n      return parseList();\n\n    case _braceL:\n      return parseDict(_braceR);\n\n    case _indent:\n      raise(tokStart, \"Unexpected indent\");\n\n    default:\n      unexpected();\n    }\n  }\n\n  // Parse list\n\n  // Custom list object is used to simulate native Python list\n  // E.g. Python '[]' becomes JavaScript 'new __pythonRuntime.objects.list();'\n  // If list comprehension, build something like this:\n  //(function() {\n  //  var _list = [];\n  //  ...\n  //  _list.push(expr);\n  //  return _list;\n  //}());\n\n  function parseList() {\n    var node = startNode();\n    node.arguments = [];\n    next();\n\n    if (!eat(_bracketR)) {\n      var expr = parseExprOps(false);\n      if (tokType === _for || tokType === _if) {\n\n        // List comprehension\n        var tmpVarSuffix = newAstIdCount++;\n        expr = nc.createListCompPush(expr, tmpVarSuffix);\n        var body = parseCompIter(expr, true);\n        finishNode(node);\n        return nc.createListCompIife(node, body, tmpVarSuffix);\n\n      } else if (eat(_comma)) {\n        node.arguments = [expr].concat(parseExprList(_bracketR, true, false));\n      }\n      else {\n        expect(_bracketR);\n        node.arguments = [expr];\n      }\n    }\n\n    finishNode(node, \"NewExpression\");\n    var runtimeId = nc.createNodeSpan(node, node, \"Identifier\", { name: options.runtimeParamName });\n    var objectsId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"objects\" });\n    var runtimeMember = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeId, property: objectsId, computed: false });\n    var listId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"list\" });\n    node.callee = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeMember, property: listId, computed: false });\n    return node;\n  }\n\n  // Parse a comp_iter from Python language grammar\n  // Used to build list comprehensions\n  // 'expr' is the body to be used after unrolling the ifs and fors\n\n  function parseCompIter(expr, first) {\n    if (first && tokType !== _for) unexpected();\n    if (eat(_bracketR)) return expr;\n    var node = startNode();\n    if (eat(_for)) {\n      var init = parseExpression(false, true);\n      var tupleArgs = getTupleArgs(init);\n      if (!tupleArgs) checkLVal(init);\n      expect(_in);\n      var right = parseExpression();\n      var body = parseCompIter(expr, false);\n      var block = nc.createNodeSpan(body, body, \"BlockStatement\", { body: [body] });\n      finishNode(node, \"BlockStatement\");\n      return nc.createFor(node, init, tupleArgs, right, block);\n    } else if (eat(_if)) {\n      if (tokType === _parenL) node.test = parseParenExpression();\n      else node.test = parseExpression();\n      node.consequent = parseCompIter(expr, false);\n      return finishNode(node, \"IfStatement\");\n    } else unexpected();\n  }\n\n  // Parse class\n\n  function parseClass(ctorNode) {\n    // Container for class constructor and prototype functions\n    var container = startNodeFrom(ctorNode);\n    container.body = [];\n\n    // Parse class signature\n    ctorNode.id = parseIdent();\n    ctorNode.params = [];\n    var classParams = [];\n    if (eat(_parenL)) {\n      var first = true;\n      while (!eat(_parenR)) {\n        if (!first) expect(_comma); else first = false;\n        classParams.push(parseIdent());\n      }\n    }\n    if (classParams.length > 1) raise(tokPos, \"Multiple inheritance not supported\");\n    expect(_colon);\n\n    // Start new namespace for class body\n    scope.startClass(ctorNode.id.name);\n\n    // Save a reference for source ranges\n    var classBodyRefNode = finishNode(startNode());\n\n    // Parse class body\n    var classBlock = parseSuite();\n\n    // Generate additional AST to implement class\n    var classStmt = nc.createClass(container, ctorNode, classParams, classBodyRefNode, classBlock);\n\n    scope.end();\n\n    return classStmt;\n  }\n\n  // Parse dictionary\n  // Custom dict object used to simulate native Python dict\n  // E.g. \"{'k1':'v1', 'k2':'v2'}\" becomes \"new __pythonRuntime.objects.dict(['k1', 'v1'], ['k2', 'v2']);\"\n\n  function parseDict(tokClose) {\n    var node = startNode(), first = true, key, value;\n    node.arguments = [];\n    next();\n    while (!eat(tokClose)) {\n      if (!first) {\n        expect(_comma);\n      } else first = false;\n\n      if (tokClose === _braceR) {\n        key = parsePropertyName();\n        expect(_colon);\n        value = parseExprOps(false);\n      } else if (tokClose === _parenR) {\n        var keyId = parseIdent(true);\n        key = startNodeFrom(keyId);\n        key.value = keyId.name;\n        finishNode(key, \"Literal\");\n        expect(_eq);\n        value = parseExprOps(false);\n      } else unexpected();\n      node.arguments.push(nc.createNodeSpan(key, value, \"ArrayExpression\", { elements: [key, value] }));\n    }\n    finishNode(node, \"NewExpression\");\n\n    var runtimeId = nc.createNodeSpan(node, node, \"Identifier\", { name: options.runtimeParamName });\n    var objectsId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"objects\" });\n    var runtimeMember = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeId, property: objectsId, computed: false });\n    var listId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"dict\" });\n    node.callee = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeMember, property: listId, computed: false });\n\n    return node;\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  function parseFunction(node) {\n    // TODO: The node creation utilities used here are tightly coupled (e.g. variable names)\n\n    var suffix = newAstIdCount++;\n    node.id = parseIdent();\n    node.params = [];\n\n    // Parse parameters\n\n    var formals = [];     // In order, maybe with default value\n    var argsId = null;    // *args\n    var kwargsId = null;  // **kwargs\n    var defaultsFound = false;\n    var first = true;\n\n    scope.startFn(node.id.name);\n\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma); else first = false;\n      if (tokVal === '*') {\n        if (kwargsId) raise(tokPos, \"invalid syntax\");\n        next(); argsId = parseIdent();\n      } else if (tokVal === '**') {\n        next(); kwargsId = parseIdent();\n      } else {\n        if (kwargsId) raise(tokPos, \"invalid syntax\");\n        var paramId = parseIdent();\n        if (eat(_eq)) {\n          formals.push({ id: paramId, expr: parseExprOps(false) });\n          defaultsFound = true;\n        } else {\n          if (defaultsFound) raise(tokPos, \"non-default argument follows default argument\");\n          if (argsId) raise(tokPos, \"missing required keyword-only argument\");\n          formals.push({ id: paramId, expr: null });\n        }\n        scope.addVar(paramId.name);\n      }\n    }\n    expect(_colon);\n\n    // Start a new scope with regard to the `inFunction`\n    // flag (restore them to their old value afterwards).\n    // `inFunction` used to throw syntax error for stray `return`\n    var oldInFunc = inFunction = true;\n\n    // If class method, remove class instance var from params and save for 'this' replacement\n    if (scope.isParentClass()) {\n      var selfId = formals.shift();\n      scope.setThisReplace(selfId.id.name);\n    }\n\n    var body = parseSuite();\n    node.body = nc.createNodeSpan(body, body, \"BlockStatement\", { body: [] });\n\n    // Add runtime parameter processing\n    // The caller may pass a complex parameter object as a single parameter like this:\n    // {formals:[<expr>, <expr>, ...], keywords:{<id>:<expr>, <id>:<expr>, ...}}\n\n    var r = node.id;\n    var __hasParams = nc.createNodeSpan(r, r, \"Identifier\", { name: '__hasParams' + suffix });\n    var __params = nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: '__params' + suffix });\n    var __realArgCount = nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: '__realArgCount' + suffix });\n\n    if (formals.length > 0 || argsId || kwargsId) {\n      var argumentsLen = nc.createNodeSpan(r, r, \"BinaryExpression\", {\n        operator: '-',\n        left: nc.createNodeMembIds(r, 'arguments', 'length'),\n        right: nc.createNodeSpan(r, r, \"Literal\", { value: 1 })\n      });\n\n      var argumentsN = nc.createNodeSpan(r, r, \"MemberExpression\", {\n        computed: true, object: nc.createNodeSpan(r, r, \"Identifier\", { name: 'arguments' }),\n        property: argumentsLen\n      });\n\n      // var __hasParams = arguments.length === 1 && arguments[arguments.length-1].formals && arguments[arguments.length-1].keywords;\n      var setHasParams = nc.createNodeSpan(r, r, \"LogicalExpression\", {\n        operator: '&&',\n        left: nc.createNodeSpan(r, r, \"LogicalExpression\", {\n          operator: '&&',\n          left: nc.createNodeSpan(r, r, \"BinaryExpression\", {\n            operator: '>',\n            left: nc.createNodeMembIds(r, 'arguments', 'length'),\n            right: nc.createNodeSpan(r, r, \"Literal\", { value: 0 })\n          }),\n          right: argumentsN\n        }),\n        right: nc.createNodeSpan(r, r, \"MemberExpression\", {\n          computed: false, object: argumentsN,\n          property: nc.createNodeSpan(r, r, \"Identifier\", { name: 'keywords' }),\n        })\n      });\n\n      node.body.body.push(nc.createGeneratedVarDeclFromId(r, __hasParams, setHasParams));\n\n      //var __params = __hasParams ? arguments[arguments.length - 1].keywords : {};\n      var setParams = nc.createNodeSpan(r, r, \"ConditionalExpression\", {\n        test: __hasParams,\n        consequent: nc.createNodeSpan(r, r, \"MemberExpression\", {\n          computed: false, object: argumentsN,\n          property: nc.createNodeSpan(r, r, \"Identifier\", { name: 'keywords' }),\n        }),\n        alternate: nc.createNodeSpan(r, r, \"ObjectExpression\", { properties: [] })\n      });\n      node.body.body.push(nc.createGeneratedVarDeclFromId(r, __params, setParams));\n\n      // var __realArgCount = arguments.length - __params0 ? 0 : 1;\n      var setRealArgCount = (nc.createGeneratedVarDeclFromId(node.id,\n        __realArgCount,\n        nc.createNodeSpan(node.id, node.id, \"BinaryExpression\", {\n          operator: '-',\n          left: nc.createNodeMembIds(node.id, 'arguments', 'length'),\n          //right: nc.createNodeSpan(node.id, node.id, \"Literal\", { value: 0 })\n          right: nc.createNodeSpan(node.id, node.id, \"ConditionalExpression\", {\n            test: __hasParams,\n            consequent: nc.createNodeSpan(node.id, node.id, \"Literal\", { value: 1 }),\n            alternate: nc.createNodeSpan(node.id, node.id, \"Literal\", { value: 0 })\n          })\n        })\n      ));\n\n      node.body.body.push(setRealArgCount);\n    }\n\n    // Verify that argument names are not repeated\n    for (var i = 0; i < formals.length; ++i) {\n      node.params.push(formals[i].id);\n      for (var j = 0; j < i; ++j) if (formals[i].id.name === formals[j].id.name)\n        raise(formals[i].id.start, \"Argument name clash\");\n    }\n\n\n    for ( i = 0; i < formals.length; ++i) {\n      var argName = nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: formals[i].id.name });\n      var argNameStr = nc.createNodeSpan(node.id, node.id, \"Literal\", { value: formals[i].id.name });\n      var argSet = nc.createNodeSpan(node.id, node.id, \"AssignmentExpression\", {\n        operator: '=',\n        left: argName,\n        right: nc.createNodeSpan(node.id, node.id, \"ConditionalExpression\", {\n          test: nc.createNodeSpan(node.id, node.id, \"BinaryExpression\", { operator: 'in', left: argNameStr, right: __params }),\n          consequent: nc.createNodeSpan(node, node, \"MemberExpression\", { object: __params, property: argNameStr, computed: true }),\n          alternate: formals[i].expr ? formals[i].expr : nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: 'undefined' })\n        })\n      });\n\n      var argCheck = nc.createNodeSpan(node.id, node.id, \"IfStatement\", {\n        test: nc.createNodeSpan(node.id, node.id, \"BinaryExpression\", {\n          operator: '<',\n          left: __realArgCount,\n          right:  nc.createNodeSpan(node.id, node.id, \"Literal\", { value: i+1 })\n        }),\n        consequent: nc.createNodeSpan(node.id, node.id, \"ExpressionStatement\", { expression: argSet })\n      });\n\n      node.body.body.push(argCheck);\n    }\n\n    if (argsId) {\n      // var __formalsIndex = n;\n      node.body.body.push(nc.createGeneratedVarDeclFromId(node.id,\n        nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: '__formalsIndex' + suffix }),\n        nc.createNodeSpan(node.id, node.id, \"Literal\", { value: formals.length })));\n\n      // var <args> = [];\n      var argsAssign = nc.createGeneratedVarDeclFromId(argsId, argsId, nc.createNodeSpan(argsId, argsId, \"ArrayExpression\", { elements: [] }));\n      node.body.body.push(argsAssign);\n      node.body.body.push(nc.createNodeArgsWhileConsequent(argsId, suffix));\n      \n    }\n\n    if (kwargsId) {\n      for (var i = 0; i < formals.length; ++i) {\n        var formalDelete = nc.createNodeSpan(kwargsId, kwargsId, \"ExpressionStatement\", {\n          expression: nc.createNodeSpan(kwargsId, kwargsId, \"UnaryExpression\", {\n            operator: 'delete',\n            prefix: true,\n            argument: nc.createNodeSpan(kwargsId, kwargsId, \"MemberExpression\", {\n              object: __params,\n              property: nc.createNodeSpan(node.id, node.id, \"Identifier\", { name: formals[i].id.name }),\n              computed: false \n            })\n          })\n        });\n        node.body.body.push(formalDelete);\n      }\n\n      // var <kwargs> = {};\n      var kwargsAssign = nc.createGeneratedVarDeclFromId(kwargsId, kwargsId, __params);\n      node.body.body.push(kwargsAssign);\n    }\n\n    // Convert original body to 'return (function() {<body>}).call(this);';\n    //node.body.body.push(nc.createNodeFnBodyIife(body));\n\n    //Append real body to node\n    node.body.body.push.apply(node.body.body, body.body);\n\n    inFunction = oldInFunc;\n\n\n    // If class method, replace with prototype function literals\n    var retNode;\n    if (scope.isParentClass()) {\n      finishNode(node);\n      var classId = nc.createNodeSpan(node, node, \"Identifier\", { name: scope.getParentClassName() });\n      var prototypeId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"prototype\" });\n      var functionId = node.id;\n      var prototypeMember = nc.createNodeSpan(node, node, \"MemberExpression\", { object: classId, property: prototypeId, computed: false });\n      var functionMember = nc.createNodeSpan(node, node, \"MemberExpression\", { object: prototypeMember, property: functionId, computed: false });\n      var functionExpr = nc.createNodeSpan(node, node, \"FunctionExpression\", { body: node.body, params: node.params });\n      var assignExpr = nc.createNodeSpan(node, node, \"AssignmentExpression\", { left: functionMember, operator: \"=\", right: functionExpr });\n      retNode = nc.createNodeSpan(node, node, \"ExpressionStatement\", { expression: assignExpr });\n    } else retNode = finishNode(node, \"FunctionDeclaration\");\n\n    scope.end();\n\n    return retNode;\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [], first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);\n      else elts.push(parseExprOps(false));\n    }\n    return elts;\n  }\n\n  function parseParamsList() {\n    // In: expr, expr, ..., id=expr, id=expr, ...\n    // Out: expr, expr, ..., {id:expr, __kwp:true}, {id:expr, __kwp:true}, ...\n    var elts = [], first = true;\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma);\n      else first = false;\n      var expr = parseExprOps(false);\n      if (eat(_eq)) {\n        var right = parseExprOps(false);\n        var kwId = nc.createNodeSpan(expr, right, \"Identifier\", {name:\"__kwp\"});\n        var kwLit = nc.createNodeSpan(expr, right, \"Literal\", {value:true});\n        var left = nc.createNodeSpan(expr, right, \"ObjectExpression\", { properties: [] });\n        left.isntFormal = true;\n        left.properties.push({ type: \"Property\", key: expr, value: right, kind: \"init\" });\n        left.properties.push({ type: \"Property\", key: kwId, value: kwLit, kind: \"init\" });\n        expr = left;\n      }\n      elts.push(expr);\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  // TODO: liberal?\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    if (liberal) liberal = false;\n    if (tokType === _name) {\n      if (!liberal && strict && input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n        raise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n      node.name = tokVal;\n    } else if (liberal && tokType.keyword) {\n      node.name = tokType.keyword;\n    } else {\n      unexpected();\n    }\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n\n  function parseTuple(noIn, expr) {\n    var node = expr ? startNodeFrom(expr) : startNode();\n    node.arguments = expr ? [expr] : [];\n\n    // Tuple with single element has special trailing comma: t = 'hi',\n    // Look ahead and eat comma in this scenario\n    if (tokType === _comma) {\n      var oldPos = tokPos; skipSpace();\n      var newPos = tokPos; tokPos = oldPos;\n      if (newPos >= inputLen || input[newPos] === ';' || input[newPos] === ')' || newline.test(input[newPos]))\n        eat(_comma);\n    }\n\n    while (eat(_comma)) {\n      node.arguments.push(parseExprOps(noIn));\n    }\n    finishNode(node, \"NewExpression\");\n\n    var runtimeId = nc.createNodeSpan(node, node, \"Identifier\", { name: options.runtimeParamName });\n    var objectsId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"objects\" });\n    var runtimeMember = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeId, property: objectsId, computed: false });\n    var listId = nc.createNodeSpan(node, node, \"Identifier\", { name: \"tuple\" });\n    node.callee = nc.createNodeSpan(node, node, \"MemberExpression\", { object: runtimeMember, property: listId, computed: false });\n\n    return node;\n  }\n\n  // ## Python runtime library\n\n  var pythonRuntime = exports.pythonRuntime = {\n\n    // Shim JavaScript objects that impersonate Python equivalents\n\n    // TODO: use 'type' or isSequence instead of 'instanceof Array' to id these\n\n    internal: {\n      // Only used within runtime\n      isSeq: function (a) { return a && (a._type === \"list\" || a._type === \"tuple\"); },\n      slice: function (obj, start, end, step) {\n        if (step == null || step === 0) step = 1; // TODO: step === 0 is a runtime error\n        if (start == null) {\n          if (step < 0) start = obj.length - 1;\n          else start = 0;\n        } else if (start < 0) start += obj.length;\n        if (end == null) {\n          if (step < 0) end = -1;\n          else end = obj.length;\n        } else if (end < 0) end += obj.length;\n\n        var ret = new pythonRuntime.objects.list(), tmp, i;\n        if (step < 0) {\n          tmp = obj.slice(end + 1, start + 1);\n          for (i = tmp.length - 1; i >= 0; i += step) ret.append(tmp[i]);\n        } else {\n          tmp = obj.slice(start, end);\n          if (step === 1) ret = pythonRuntime.utils.createList(tmp);\n          else for (i = 0; i < tmp.length; i += step) ret.append(tmp[i]);\n        }\n        return ret;\n      },\n      isJSArray: Array.isArray || function(obj) {\n        return toString.call(obj) === '[object Array]';\n      }\n    },\n\n    utils: {\n      createDict: function () {\n        var ret = new pythonRuntime.objects.dict();\n        if (arguments.length === 1 && arguments[0] instanceof Object)\n          for (var k in arguments[0]) ret[k] = arguments[0][k];\n        else\n          throw TypeError(\"createDict expects a single JavaScript object\");\n        return ret;\n      },\n      createParamsObj: function () {\n        // In: expr, expr, ..., {id:expr, __kwp:true}, {id:expr, __kwp:true}, ...\n        // Out: {formals:[expr, expr, ...], keywords:{id:expr, id:expr, ...}}\n        var params = { formals: new pythonRuntime.objects.list(), keywords: new PythonDict() };\n        for (var i = 0; i < arguments.length; i++) {\n          if (arguments[i] && arguments[i].__kwp === true) {\n            for (var k in arguments[i])\n              if (k !== '__kwp') params.keywords[k] = arguments[i][k];\n          }\n          else params.formals.push(arguments[i]);\n        }\n        return params;\n      },\n      convertToList: function (list) {\n        Object.defineProperties(list, pythonRuntime.utils.listPropertyDescriptor);\n        return list;\n      },\n      convertToDict: function (dict) {\n        Object.defineProperties(dict, pythonRuntime.utils.dictPropertyDescriptor);\n        return dict;\n      }, \n      listPropertyDescriptor: {\n          \"_type\": {\n            get: function () { return 'list'; },\n            enumerable: false\n          },\n          \"_isPython\": {\n            get: function () { return true; },\n            enumerable: false\n          },\n          \"append\": {\n            value: function (x) {\n              this.push(x);\n            },\n            enumerable: false\n          },\n          \"clear\": {\n            value: function () {\n              this.splice(0, this.length);\n            },\n            enumerable: false\n          },\n          \"copy\": {\n            value: function () {\n              return this.slice(0);\n            },\n            enumerable: false\n          },\n          \"count\": {\n            value: function (x) {\n              var c = 0;\n              for (var i = 0; i < this.length; i++)\n                if (this[i] === x) c++;\n              return c;\n            },\n            enumerable: false\n          },\n          \"equals\": {\n            value: function (x) {\n              try {\n                if (this.length !== x.length) return false;\n                for (var i = 0; i < this.length; i++) {\n                  if (this[i].hasOwnProperty(\"equals\")) {\n                    if (!this[i].equals(x[i])) return false;\n                  } else if (this[i] !== x[i]) return false;\n                }\n                return true;\n              }\n              catch (e) { }\n              return false;\n            },\n            enumerable: false\n          },\n          \"extend\": {\n            value: function (L) {\n              for (var i = 0; i < L.length; i++) this.push(L[i]);\n            },\n            enumerable: false\n          },\n          \"index\": {\n            value: function (x) {\n              return this.indexOf(x);\n            },\n            enumerable: false\n          },\n          \"indexOf\": {\n            value: function (x, fromIndex) {\n              try {\n                for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n                  if (this[i].hasOwnProperty(\"equals\")) {\n                    if (this[i].equals(x)) return i;\n                  } else if (this[i] === x) return i;\n                }\n              }\n              catch (e) { }\n              return -1;\n            },\n            enumerable: false\n          },\n          \"insert\": {\n            value: function (i, x) {\n              this.splice(i, 0, x);\n            },\n            enumerable: false\n          },\n          \"pop\": {\n            value: function (i) {\n              if (!i)\n                i = this.length - 1;\n              var item = this[i];\n              this.splice(i, 1);\n              return item;\n            },\n            enumerable: false\n          },\n          \"_pySlice\": {\n            value: function (start, end, step) {\n              return pythonRuntime.internal.slice(this, start, end, step);\n            },\n            enumerable: false\n          },\n          \"remove\": {\n            value: function (x) {\n              this.splice(this.indexOf(x), 1);\n            },\n            enumerable: false\n          },\n          \"sort\": {\n            value: function(x, reverse) {\n              var list2 = this.slice(0);\n              var apply_key = function(a, numerical) {\n                var list3 = list2.map(x);\n                // construct a dict that maps the listay before and after the map\n                var mapping = {}\n                for(var i in list3) mapping[list3[i]] = list2[i];\n                if(numerical)\n                  list3.sort(function(a, b) { return a - b; });\n                else\n                  list3.sort()\n                for(var i in a) a[i] = mapping[list3[i]];\n              }\n              for(var i in this) {\n                if(typeof this[i] !== 'number' || !isFinite(this[i])) {\n                  if(typeof x != 'undefined') {\n                    apply_key(this, false);\n                  }\n                  else {\n                    list2.sort();\n                    for (var j in this) this[j] = list2[j];\n                  }\n                  if(reverse)\n                    this.reverse();\n                  return;\n                }\n              }\n              if(typeof x != 'undefined') {\n                apply_key(this, true);\n              }\n              else {\n                list2.sort(function(a, b) { return a - b; });\n                for(var i in this) this[i] = list2[i];\n              }\n              if(reverse)\n                this.reverse();\n            },\n            enumerable: false\n          },\n          \"toString\": {\n            value: function () {\n              return '[' + this.join(', ') + ']';\n            },\n            enumerable: false\n          }\n      },\n      createList: function () {\n        var ret = new pythonRuntime.objects.list();\n        if (arguments.length === 1 && arguments[0] instanceof Array)\n          for (var i in arguments[0]) ret.push(arguments[0][i]);\n        else\n          for (var i in arguments) ret.push(arguments[i]);\n        return ret;\n      },\n      dictPropertyDescriptor: {\n        \"_type\": {\n          get: function () { return 'dict';},\n          enumerable: false\n        },\n        \"_isPython\": {\n          get: function () { return true; },\n          enumerable: false\n        },\n        \"items\": {\n          value: function () {\n            var items = new pythonRuntime.objects.list();\n            for (var k in this) items.append(new pythonRuntime.objects.tuple(k, this[k]));\n            return items;\n          },\n          enumerable: false\n        },\n        \"length\": {\n          get: function () {\n            return Object.keys(this).length;\n          },\n          enumerable: false\n        },\n        \"clear\": {\n          value: function () {\n            for (var i in this) delete this[i];\n          },\n          enumerable: false\n        },\n        \"get\": {\n          value: function (key, def) {\n            if (key in this) return this[key];\n            else if (def !== undefined) return def;\n            return null;\n          },\n          enumerable: false\n        },\n        \"keys\": {\n          value: function () {\n            return Object.keys(this);\n          },\n          enumerable: false\n        },\n        \"pop\": {\n          value: function (key, def) {\n            var value;\n            if (key in this) {\n              value = this[key];\n              delete this[key];\n            } else if (def !== undefined) value = def;\n            else return new Error(\"KeyError\");\n            return value;\n          },\n          enumerable: false\n        }, \"values\": {\n          value: function () {\n            var values = new pythonRuntime.objects.list();\n            for (var key in this) values.append(this[key]);\n            return values;\n          },\n          enumerable: false\n        }\n      }\n    },\n    ops: {\n      add: function (a, b) {\n        if (typeof a === 'object' && pythonRuntime.internal.isSeq(a) && pythonRuntime.internal.isSeq(b)) {\n          if (a._type !== b._type)\n            throw TypeError(\"can only concatenate \" + a._type + \" (not '\" + b._type + \"') to \" + a._type);\n          var ret;\n          if (a._type === 'list') ret = new pythonRuntime.objects.list();\n          else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n          if (ret) {\n            for (var i = 0; i < a.length; i++) ret.push(a[i]);\n            for (var i = 0; i < b.length; i++) ret.push(b[i]);\n            return ret;\n          }\n        }\n        return a + b;\n      },\n      in: function (a, b, n) {\n        var r = b.hasOwnProperty('indexOf') ? b.indexOf(a) >= 0 : a in b;\n        return n ? !r : r;\n      },\n      multiply: function (a, b) {\n        // TODO: non-sequence operand must be an integer\n        if ( typeof a === 'object' ) {\n          if (pythonRuntime.internal.isSeq(a) && !isNaN(parseInt(b))) {\n            var ret;\n            if (a._type === 'list') ret = new pythonRuntime.objects.list();\n            else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n            if (ret) {\n              for (var i = 0; i < b; i++)\n                for (var j = 0; j < a.length; j++) ret.push(a[j]);\n              return ret;\n            }\n          } else if (pythonRuntime.internal.isSeq(b) && !isNaN(parseInt(a))) {\n            var ret;\n            if (b._type === 'list') ret = new pythonRuntime.objects.list();\n            else if (b._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n            if (ret) {\n              for (var i = 0; i < a; i++)\n                for (var j = 0; j < b.length; j++) ret.push(b[j]);\n              return ret;\n            }\n          }\n        }\n        return a * b;\n      },\n      subscriptIndex: function (o, i) {\n        if ( i >= 0 ) return i;\n        if ( pythonRuntime.internal.isSeq(o) ) return o.length + i;\n        if ( pythonRuntime.internal.isJSArray(o) ) return o.length + i;\n        if ( typeof o === \"string\" ) return o.length + i;\n        return i;\n      }\n    },\n\n    objects: {\n      dict: function () {\n        var obj = new PythonDict();\n        for (var i = 0; i < arguments.length; ++i ) obj[arguments[i][0]] = arguments[i][1];\n        return obj;\n      },\n      list: function () {\n        var arr = [];\n        arr.push.apply(arr, arguments);\n        pythonRuntime.utils.convertToList(arr);\n        return arr;\n      },\n      tuple: function () {\n        var arr = [];\n        arr.push.apply(arr, arguments);\n        Object.defineProperty(arr, \"_type\",\n        {\n          get: function () { return 'tuple'; },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"_isPython\",\n        {\n          get: function () { return true; },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"count\",\n        {\n          value: function (x) {\n            var c = 0;\n            for (var i = 0; i < this.length; i++)\n              if (this[i] === x) c++;\n            return c;\n          },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"equals\",\n        {\n          value: function (x) {\n            try {\n              if (this.length !== x.length) return false;\n              for (var i = 0; i < this.length; i++) {\n                if (this[i].hasOwnProperty(\"equals\")) {\n                  if (!this[i].equals(x[i])) return false;\n                } else if (this[i] !== x[i]) return false;\n              }\n              return true;\n            }\n            catch (e) { }\n            return false;\n          },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"index\",\n        {\n          value: function (x) {\n            return this.indexOf(x);\n          },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"indexOf\",\n        {\n          value: function (x, fromIndex) {\n            try {\n              for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n                if (this[i].hasOwnProperty(\"equals\")) {\n                  if (this[i].equals(x)) return i;\n                } else if (this[i] === x) return i;\n              }\n            }\n            catch (e) { }\n            return -1;\n          },\n          enumerable: false\n        });\n        Object.defineProperty(arr, \"_pySlice\",\n        {\n          value: function (start, end, step) { \n            return pythonRuntime.internal.slice(this, start, end, step);\n          },\n            enumerable: false\n        });\n        Object.defineProperty(arr, \"toString\",\n        {\n          value: function () {\n            var s = '(' + this.join(', ');\n            if (this.length === 1) s += ',';\n            s += ')';\n            return s;\n          },\n          enumerable: false\n        });\n        return arr;\n      }\n    },\n\n    // Python built-in functions\n\n    functions: {\n      abs: function(x) {\n        return Math.abs(x);\n      },\n      all: function(iterable) {\n        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) !== true) return false;\n        return true;\n      },\n      any: function(iterable) {\n        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) === true) return true;\n        return false;\n      },\n      ascii: function(obj) {\n        var s = pythonRuntime.functions.repr(obj),\n            asc = \"\",\n            code;\n        for (var i = 0; i < s.length; i++) {\n          code = s.charCodeAt(i);\n          if (code <= 127) asc += s[i];\n          else if (code <= 0xFF) asc += \"\\\\x\" + code.toString(16);\n          else if (0xD800 <= code && code <= 0xDBFF) { // UCS-2 for the astral chars\n            // if (i+1 >= s.length) throw \"High surrogate not followed by low surrogate\"; // Is this needed?\n            code = ((code-0xD800)*0x400)+(s.charCodeAt(++i)-0xDC00)+0x10000;\n            asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n          } else if (code <= 0xFFFF) asc += \"\\\\u\" + (\"0\"+code.toString(16)).slice(-4);\n          else if (code <= 0x10FFFF) asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n          else; // Invalid value, should probably throw something. It should never get here though as strings shouldn't contain them in the first place\n        }\n        return asc;\n      },\n      bool: function(x) {\n        return !(x === undefined || // No argument\n                 x === null || // None\n                 x === false || // False\n                 x === 0 || // Zero\n                 x.length === 0 || // Empty Sequence\n                 // TODO: Empty Mapping, needs more support for python mappings first\n                 (x.__bool__ !== undefined && x.__bool__() === false) || // If it has bool conversion defined\n                 (x.__len__ !== undefined && (x.__len__() === false || x.__len__() === 0))); // If it has length conversion defined\n      },\n      chr: function(i) {\n        return String.fromCharCode(i); // TODO: Error code for not 0 <= i <= 1114111\n      },\n      divmod: function(a, b) {\n        return pythonRuntime.objects.tuple(Math.floor(a/b), a%b);\n      },\n      enumerate: function(iterable, start) {\n        start = start || 0;\n        var ret = new pythonRuntime.objects.list();\n        for (var i in iterable) ret.push(new pythonRuntime.objects.tuple(start++, iterable[i]));\n        return ret;\n      },\n      filter: function(fn, iterable) {\n        fn = fn || function () { return true; };\n        var ret = new pythonRuntime.objects.list();\n        for (var i in iterable) if (fn(iterable[i])) ret.push(iterable[i]);\n        return ret;\n      },\n      float: function(x) {\n        if (x === undefined) return 0.0;\n        else if (typeof x == \"string\") { // TODO: Fix type check\n          x = x.trim().toLowerCase();\n          if ((/^[+-]?inf(inity)?$/i).exec(x) !== null) return Infinity*(x[0]===\"-\"?-1:1);\n          else if ((/^nan$/i).exec(x) !== null) return NaN;\n          else return parseFloat(x);\n        } else if (typeof x == \"number\") { // TODO: Fix type check\n          return x; // TODO: Get python types working right so we can return an actual float\n        } else {\n          if (x.__float__ !== undefined) return x.__float__();\n          else return null; // TODO: Throw TypeError: float() argument must be a string or a number, not '<type of x>'\n        }\n      },\n      hex: function(x) {\n        return x.toString(16);\n      },\n      int: function (s) {\n        return parseInt(s);\n      },\n      len: function (o) {\n        return o.length;\n      },\n      list: function (iterable) {\n        var ret = new pythonRuntime.objects.list();\n        if (iterable instanceof Array) for (var i in iterable) ret.push(iterable[i]);\n        else for (var i in iterable) ret.push(i);\n        return ret;\n      },\n      map: function(fn, iterable) {\n        // TODO: support additional iterables passed\n        var ret = new pythonRuntime.objects.list();\n        for (var i in iterable) ret.push(fn(iterable[i]));\n        return ret;\n      },\n      max: function(arg1, arg2) {\n        // TODO: support optional keyword-only arguments\n        // TODO: empty iterable raises Python ValueError\n        if (!arg2) { // iterable\n          var max = null;\n          for (var i in arg1) if (max === null || arg1[i] > max) max = arg1[i];\n          return max;\n        } else return arg1 >= arg2 ? arg1 : arg2;\n      },\n      min: function(arg1, arg2) {\n        // TODO: support optional keyword-only arguments\n        // TODO: empty iterable raises Python ValueError\n        if (!arg2) { // iterable\n          var max = null;\n          for (var i in arg1) if (max === null || arg1[i] < max) max = arg1[i];\n          return max;\n        } else return arg1 <= arg2 ? arg1 : arg2;\n      },\n      oct: function(x) {\n        return x.toString(8);\n      },\n      ord: function(c) {\n        return c.charCodeAt(0);\n      },\n      pow: function(x, y, z) {\n        return z ? Math.pow(x, y) % z : Math.pow(x, y);\n      },\n      print: function () {\n        var s = \"\";\n        for (var i = 0; i < arguments.length; i++)\n          s += i === 0 ? arguments[i] : \" \" + arguments[i];\n        console.log(s);\n      },\n      range: function (start, stop, step) {\n        if (stop === undefined) {\n          stop = start;\n          start = 0;\n          step = 1;\n        }\n        else if (step === undefined) step = 1;\n        var len = ~~((stop - start) / step); //~~ is a fast floor\n        var r = new Array(len);\n        var element = 0;\n        if (start < stop && step > 0 || start > stop && step < 0) {\n          var i = start;\n          while (i < stop && step > 0 || i > stop && step < 0) {\n            r[element++] = i;\n            i += step;\n          }\n        }\n        pythonRuntime.utils.convertToList(r);\n        return r;\n      },\n      repr: function (obj) {\n        if (typeof obj === 'string') return \"'\" + obj + \"'\"; // TODO: Patch until typesystem comes up.\n        if (obj.__repr__ !== undefined) return obj.__repr__();\n        else if (obj.__class__ !== undefined && obj.__class__.module !== undefined && obj.__class__.__name__) {\n          return '<'+obj.__class__.__module__+'.'+obj.__class__.__name__+' object>';\n        } else return obj.toString(); // Raise a please report warning here, we should never reach this piece of code\n      },\n      reversed: function (seq) {\n        var ret = new pythonRuntime.objects.list();\n        for (var i in seq) ret.push(seq[i]);\n        return ret.reverse();\n      },\n      round: function (num, ndigits) {\n        if (ndigits) {\n          var scale = Math.pow(10, ndigits);\n          return Math.round(num * scale) / scale;\n        }\n        return Math.round(num);\n      },\n      sorted: function (iterable, key, reverse) {\n        var ret = new pythonRuntime.objects.list();\n        for (var i in iterable) ret.push(iterable[i]);\n        if(key) ret.sort(key); else ret.sort();\n        if (reverse) ret.reverse();\n        return ret;\n      },\n      str: function (obj) {\n        return obj.toString();\n      },\n      sum: function (iterable, start) {\n        // TODO: start can't be a string\n        var ret = start || 0;\n        for (var i in iterable) ret += iterable[i];\n        return ret;\n      },\n      tuple: function (iterable) {\n        var ret = new pythonRuntime.objects.tuple();\n        for (var i in iterable) ret.push(iterable[i]);\n        return ret;\n      }\n    },\n\n    // Python imports\n    // TODO: from x import y, z\n\n    imports: {\n      random: {\n        random: function () { return Math.random(); }\n      }\n    }\n  };\n\n  function PythonDict() {\n\n  }\n\n  Object.defineProperties(PythonDict.prototype, pythonRuntime.utils.dictPropertyDescriptor);\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsYmVydC9maWxiZXJ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpbGJlcnQvZmlsYmVydC5qcz80ZWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGJlcnQgaXMgYSBQeXRob24gcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cbi8vXG4vLyBGaWxiZXJ0IHdhcyB3cml0dGVuIGJ5IE1hdHQgTG90dCBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBJdCB3YXMgYWRhdHBlZCBmcm9tIFtBY29ybl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0KVxuLy8gYnkgTWFyaWpuIEhhdmVyYmVrZS5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yeSBmb3IgRmlsYmVydCBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWZmZXJlbnRtYXR0L2ZpbGJlcnQuZ2l0XG4vL1xuLy8gUGxlYXNlIHVzZSB0aGUgW2dpdGh1YiBidWcgdHJhY2tlcl1bZ2hidF0gdG8gcmVwb3J0IGlzc3Vlcy5cbi8vXG4vLyBbZ2hidF06IGh0dHBzOi8vZ2l0aHViLmNvbS9kaWZmZXJlbnRtYXR0L2ZpbGJlcnQvaXNzdWVzXG5cbihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSByZXR1cm4gbW9kKGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCJdLCBtb2QpOyAvLyBBTURcbiAgbW9kKHJvb3QuZmlsYmVydCB8fCAocm9vdC5maWxiZXJ0ID0ge30pKTsgLy8gUGxhaW4gYnJvd3NlciBlbnZcbn0pKHRoaXMsIGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gXCIwLjUuMVwiO1xuXG4gIC8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuZmlsYmVydGAgd2hlbiBpbiB0aGVcbiAgLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbiAgLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4gIC8vIEFQSV1bYXBpXS5cbiAgLy9cbiAgLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuICB2YXIgb3B0aW9ucywgaW5wdXQsIGlucHV0TGVuLCBzb3VyY2VGaWxlLCBuYztcblxuICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oaW5wdCwgb3B0cykge1xuICAgIGlucHV0ID0gU3RyaW5nKGlucHQpOyBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgIGluaXRUb2tlblN0YXRlKCk7XG4gICAgbmMgPSBnZXROb2RlQ3JlYXRvcihzdGFydE5vZGUsIHN0YXJ0Tm9kZUZyb20sIGZpbmlzaE5vZGUsIHVucGFja1R1cGxlKTtcbiAgICByZXR1cm4gcGFyc2VUb3BMZXZlbChvcHRpb25zLnByb2dyYW0pO1xuICB9O1xuXG4gIC8vIEEgc2Vjb25kIG9wdGlvbmFsIGFyZ3VtZW50IGNhbiBiZSBnaXZlbiB0byBmdXJ0aGVyIGNvbmZpZ3VyZVxuICAvLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBgbGFuZ3VhZ2VWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIFB5dGhvbiB2ZXJzaW9uIHRvIHBhcnNlLiBJdFxuICAgIC8vIGlzIG5vdCBjdXJyZW50bHkgaW4gdXNlLCBidXQgd2lsbCBzdXBwb3J0IDIgb3IgMyBldmVudHVhbGx5LlxuICAgIGxhbmd1YWdlVmVyc2lvbjogMyxcbiAgICAvLyBXaGVuIGBhbGxvd1RyYWlsaW5nQ29tbWFzYCBpcyBmYWxzZSwgdGhlIHBhcnNlciB3aWxsIG5vdCBhbGxvd1xuICAgIC8vIHRyYWlsaW5nIGNvbW1hcyBpbiBhcnJheSBhbmQgb2JqZWN0IGxpdGVyYWxzLlxuICAgIGFsbG93VHJhaWxpbmdDb21tYXM6IHRydWUsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gICAgLy8gZXJyb3IuXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAgIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgLy8gbm9kZXMuXG4gICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgRmlsYmVydCB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBgKHRleHQsIHN0YXJ0LFxuICAgIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuXG4gICAgLy8gYHRleHRgIGlzIHRoZSBjb250ZW50IG9mIHRoZSBjb21tZW50LCBhbmQgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlXG4gICAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gICAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vIHBhc3NlZCwgdGhlIGZ1bGwgYHtsaW5lLCBjb2x1bW59YCBsb2NhdGlvbnMgb2YgdGhlIHN0YXJ0IGFuZFxuICAgIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gICAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNrLXRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgICAvLyBlbmRdYCBhcnJheSB3aXRoIHRoZSBzYW1lIG51bWJlcnMsIHNldCB0aGUgYHJhbmdlc2Agb3B0aW9uIHRvXG4gICAgLy8gYHRydWVgLlxuICAgIC8vXG4gICAgLy8gW3JhbmdlXTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzQ1Njc4XG4gICAgcmFuZ2VzOiBmYWxzZSxcbiAgICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAgIC8vIHBhc3NpbmcgdGhlIHRyZWUgcHJvZHVjZWQgYnkgcGFyc2luZyB0aGUgZmlyc3QgZmlsZSBhc1xuICAgIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gICAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAgIC8vIG9mIGFuIGV4aXN0aW5nIHBhcnNlIHRyZWUuXG4gICAgcHJvZ3JhbTogbnVsbCxcbiAgICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAgIC8vIGZpbGUgaW4gZXZlcnkgbm9kZSdzIGBsb2NgIG9iamVjdC5cbiAgICBzb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAgIC8vIGBsb2NhdGlvbnNgIGlzIG9uIG9yIG9mZi5cbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIC8vIFB5dGhvbiBydW50aW1lIGxpYnJhcnkgb2JqZWN0IG5hbWVcbiAgICBydW50aW1lUGFyYW1OYW1lOiBcIl9fcHl0aG9uUnVudGltZVwiXG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHQpKVxuICAgICAgb3B0aW9uc1tvcHRdID0gZGVmYXVsdE9wdGlvbnNbb3B0XTtcbiAgICBzb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlIHx8IG51bGw7XG4gIH1cblxuICAvLyBUaGUgYGdldExpbmVJbmZvYCBmdW5jdGlvbiBpcyBtb3N0bHkgdXNlZnVsIHdoZW4gdGhlXG4gIC8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4gIC8vIHdhbnQgdG8gZmluZCB0aGUgbGluZS9jb2x1bW4gcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gIC8vIG9mZnNldC4gYGlucHV0YCBzaG91bGQgYmUgdGhlIGNvZGUgc3RyaW5nIHRoYXQgdGhlIG9mZnNldCByZWZlcnNcbiAgLy8gaW50by5cblxuICB2YXIgZ2V0TGluZUluZm8gPSBleHBvcnRzLmdldExpbmVJbmZvID0gZnVuY3Rpb24oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIGxpbmVCcmVhay5sYXN0SW5kZXggPSBjdXI7XG4gICAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgKytsaW5lO1xuICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHtsaW5lOiBsaW5lLCBjb2x1bW46IG9mZnNldCAtIGN1cn07XG4gIH07XG5cbiAgLy8gRmlsYmVydCBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuICAvLyBUaGUgYHRva2VuaXplYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG4gIC8vIEJlY2F1c2UgdGhlIHRva2VuaXplciBpcyBvcHRpbWl6ZWQgZm9yIGJlaW5nIGVmZmljaWVudGx5IHVzZWQgYnlcbiAgLy8gdGhlIEZpbGJlcnQgcGFyc2VyIGl0c2VsZiwgdGhpcyBpbnRlcmZhY2UgaXMgc29tZXdoYXQgY3J1ZGUgYW5kIG5vdFxuICAvLyB2ZXJ5IG1vZHVsYXIuIFBlcmZvcm1pbmcgYW5vdGhlciBwYXJzZSBvciBjYWxsIHRvIGB0b2tlbml6ZWAgd2lsbFxuICAvLyByZXNldCB0aGUgaW50ZXJuYWwgc3RhdGUsIGFuZCBpbnZhbGlkYXRlIGV4aXN0aW5nIHRva2VuaXplcnMuXG5cbiAgZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uKGlucHQsIG9wdHMpIHtcbiAgICBpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgc2V0T3B0aW9ucyhvcHRzKTtcbiAgICBpbml0VG9rZW5TdGF0ZSgpO1xuXG4gICAgdmFyIHQgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRUb2tlbihmb3JjZVJlZ2V4cCkge1xuICAgICAgbGFzdEVuZCA9IHRva0VuZDtcbiAgICAgIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCk7XG4gICAgICB0LnN0YXJ0ID0gdG9rU3RhcnQ7IHQuZW5kID0gdG9rRW5kO1xuICAgICAgdC5zdGFydExvYyA9IHRva1N0YXJ0TG9jOyB0LmVuZExvYyA9IHRva0VuZExvYztcbiAgICAgIHQudHlwZSA9IHRva1R5cGU7IHQudmFsdWUgPSB0b2tWYWw7XG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgZ2V0VG9rZW4uanVtcFRvID0gZnVuY3Rpb24ocG9zLCByZUFsbG93ZWQpIHtcbiAgICAgIHRva1BvcyA9IHBvcztcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB0b2tDdXJMaW5lID0gMTtcbiAgICAgICAgdG9rTGluZVN0YXJ0ID0gbGluZUJyZWFrLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVhay5leGVjKGlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCBwb3MpIHtcbiAgICAgICAgICArK3Rva0N1ckxpbmU7XG4gICAgICAgICAgdG9rTGluZVN0YXJ0ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva1JlZ2V4cEFsbG93ZWQgPSByZUFsbG93ZWQ7XG4gICAgICBza2lwU3BhY2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBnZXRUb2tlbjtcbiAgfTtcblxuICAvLyBTdGF0ZSBpcyBrZXB0IGluIChjbG9zdXJlLSlnbG9iYWwgdmFyaWFibGVzLiBXZSBhbHJlYWR5IHNhdyB0aGVcbiAgLy8gYG9wdGlvbnNgLCBgaW5wdXRgLCBhbmQgYGlucHV0TGVuYCB2YXJpYWJsZXMgYWJvdmUuXG5cbiAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG5cbiAgdmFyIHRva1BvcztcblxuICAvLyBUaGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuXG4gIHZhciB0b2tTdGFydCwgdG9rRW5kO1xuXG4gIC8vIFdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyB0cnVlLCB0aGVzZSBob2xkIG9iamVjdHNcbiAgLy8gY29udGFpbmluZyB0aGUgdG9rZW5zIHN0YXJ0IGFuZCBlbmQgbGluZS9jb2x1bW4gcGFpcnMuXG5cbiAgdmFyIHRva1N0YXJ0TG9jLCB0b2tFbmRMb2M7XG5cbiAgLy8gVGhlIHR5cGUgYW5kIHZhbHVlIG9mIHRoZSBjdXJyZW50IHRva2VuLiBUb2tlbiB0eXBlcyBhcmUgb2JqZWN0cyxcbiAgLy8gbmFtZWQgYnkgdmFyaWFibGVzIGFnYWluc3Qgd2hpY2ggdGhleSBjYW4gYmUgY29tcGFyZWQsIGFuZFxuICAvLyBob2xkaW5nIHByb3BlcnRpZXMgdGhhdCBkZXNjcmliZSB0aGVtIChpbmRpY2F0aW5nLCBmb3IgZXhhbXBsZSxcbiAgLy8gdGhlIHByZWNlZGVuY2Ugb2YgYW4gaW5maXggb3BlcmF0b3IsIGFuZCB0aGUgb3JpZ2luYWwgbmFtZSBvZiBhXG4gIC8vIGtleXdvcmQgdG9rZW4pLiBUaGUga2luZCBvZiB2YWx1ZSB0aGF0J3MgaGVsZCBpbiBgdG9rVmFsYCBkZXBlbmRzXG4gIC8vIG9uIHRoZSB0eXBlIG9mIHRoZSB0b2tlbi4gRm9yIGxpdGVyYWxzLCBpdCBpcyB0aGUgbGl0ZXJhbCB2YWx1ZSxcbiAgLy8gZm9yIG9wZXJhdG9ycywgdGhlIG9wZXJhdG9yIG5hbWUsIGFuZCBzbyBvbi5cblxuICB2YXIgdG9rVHlwZSwgdG9rVmFsO1xuXG4gIC8vIEludGVyYWwgc3RhdGUgZm9yIHRoZSB0b2tlbml6ZXIuIFRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gZGl2aXNpb25cbiAgLy8gb3BlcmF0b3JzIGFuZCByZWd1bGFyIGV4cHJlc3Npb25zLCBpdCByZW1lbWJlcnMgd2hldGhlciB0aGUgbGFzdFxuICAvLyB0b2tlbiB3YXMgb25lIHRoYXQgaXMgYWxsb3dlZCB0byBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uLlxuICAvLyAoSWYgaXQgaXMsIGEgc2xhc2ggaXMgcHJvYmFibHkgYSByZWdleHAsIGlmIGl0IGlzbid0IGl0J3MgYVxuICAvLyBkaXZpc2lvbiBvcGVyYXRvci4gU2VlIHRoZSBgcGFyc2VTdGF0ZW1lbnRgIGZ1bmN0aW9uIGZvciBhXG4gIC8vIGNhdmVhdC4pXG5cbiAgdmFyIHRva1JlZ2V4cEFsbG93ZWQ7XG5cbiAgLy8gV2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIHRydWUsIHRoZXNlIGFyZSB1c2VkIHRvIGtlZXBcbiAgLy8gdHJhY2sgb2YgdGhlIGN1cnJlbnQgbGluZSwgYW5kIGtub3cgd2hlbiBhIG5ldyBsaW5lIGhhcyBiZWVuXG4gIC8vIGVudGVyZWQuXG5cbiAgdmFyIHRva0N1ckxpbmUsIHRva0xpbmVTdGFydDtcblxuICAvLyBUaGVzZSBzdG9yZSB0aGUgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyB1c2VmdWxcbiAgLy8gd2hlbiBmaW5pc2hpbmcgYSBub2RlIGFuZCBhc3NpZ25pbmcgaXRzIGBlbmRgIHBvc2l0aW9uLlxuXG4gIHZhciBsYXN0U3RhcnQsIGxhc3RFbmQsIGxhc3RFbmRMb2M7XG5cbiAgLy8gVGhpcyBpcyB0aGUgcGFyc2VyJ3Mgc3RhdGUuIGBpbkZ1bmN0aW9uYCBpcyB1c2VkIHRvIHJlamVjdFxuICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRzIG91dHNpZGUgb2YgZnVuY3Rpb25zLCBgc3RyaWN0YCBpbmRpY2F0ZXNcbiAgLy8gd2hldGhlciBzdHJpY3QgbW9kZSBpcyBvbiwgYW5kIGBicmFja2V0TmVzdGluZ2AgdHJhY2tzIHRoZSBsZXZlbFxuICAvLyBvZiBuZXN0aW5nIHdpdGhpbiBicmFja2V0cyBmb3IgaW1wbGljaXQgbGludCBjb250aW51YXRpb24uXG5cbiAgdmFyIGluRnVuY3Rpb24sIHN0cmljdCwgYnJhY2tldE5lc3Rpbmc7XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuICAvLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbiAgLy8gbWVzc2FnZS5cblxuICBmdW5jdGlvbiByYWlzZShwb3MsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbG9jID0gZ2V0TGluZUluZm8oaW5wdXQsIHBvcyk7XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIucG9zID0gcG9zOyBlcnIubG9jID0gbG9jOyBlcnIucmFpc2VkQXQgPSB0b2tQb3M7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgLy8gVXNlZCBmb3IgbmFtZSBjb2xsaXNpb24gYXZvaWRhbmNlIHdoZW5kIGFkZGluZyBleHRyYSBBU1QgaWRlbnRpZmllcnNcblxuICB2YXIgbmV3QXN0SWRDb3VudCA9IDA7XG5cbiAgdmFyIGluZGVudEhpc3QgPSBleHBvcnRzLmluZGVudEhpc3QgPSB7XG4gICAgLy8gQ3VycmVudCBpbmRlbnRhdGlvbiBzdGFja1xuICAgIGluZGVudDogW10sXG5cbiAgICAvLyBOdW1iZXIgb2YgZGVkZW50IHRva2VucyBsZWZ0IChpLmUuIGlmIHRva1R5cGUgPT0gX2RlZGVudCwgZGVkZW50Q291bnQgPiAwKVxuICAgIC8vIE11bHRpcGxlIGRlZGVudCB0b2tlbnMgYXJlIHJlYWQgaW4gYXQgb25jZSwgYnV0IHByb2Nlc3NlZCBpbmRpdmlkdWFsbHkgaW4gcmVhZFRva2VuKClcbiAgICBkZWRlbnRDb3VudDogMCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRlbnQgPSBbXTsgdGhpcy5kZWRlbnRDb3VudCA9IDA7IH0sXG4gICAgY291bnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZW50Lmxlbmd0aDsgfSxcbiAgICBsZW46IGZ1bmN0aW9uIChpKSB7IFxuICAgICAgaWYgKHR5cGVvZiBpID09PSAndW5kZWZpbmVkJyB8fCBpID49IHRoaXMuaW5kZW50Lmxlbmd0aCkgaSA9IHRoaXMuaW5kZW50Lmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnRbaV0ubGVuZ3RoOyBcbiAgICB9LFxuICAgIGlzSW5kZW50OiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnQubGVuZ3RoID09PSAwIHx8IHMubGVuZ3RoID4gdGhpcy5sZW4oKTtcbiAgICB9LFxuICAgIGlzRGVkZW50OiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRlbnQubGVuZ3RoID4gMCAmJiBzLmxlbmd0aCA8IHRoaXMubGVuKCk7XG4gICAgfSxcbiAgICBhZGRJbmRlbnQ6IGZ1bmN0aW9uIChzKSB7IHRoaXMuaW5kZW50LnB1c2gocyk7IH0sXG4gICAgYWRkRGVkZW50OiBmdW5jdGlvbiAocykge1xuICAgICAgdGhpcy5kZWRlbnRDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5pbmRlbnQubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHMubGVuZ3RoIDwgdGhpcy5pbmRlbnRbaV0ubGVuZ3RoOyAtLWkpXG4gICAgICAgICsrdGhpcy5kZWRlbnRDb3VudDtcbiAgICB9LFxuICAgIHVwZGF0ZURlZGVudDogZnVuY3Rpb24gKCkgeyB0aGlzLmRlZGVudENvdW50ID0gdGhpcy5jb3VudCgpOyB9LFxuICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgLS10aGlzLmRlZGVudENvdW50O1xuICAgICAgdGhpcy5pbmRlbnQucG9wKCk7XG4gICAgfSxcbiAgICB1bmRvSW5kZW50OiBmdW5jdGlvbiAoKSB7IHRoaXMucG9wKCk7IH1cbiAgfTtcblxuICAvLyAjIyBTY29wZVxuXG4gIC8vIENvbGxlY3Rpb24gb2YgbmFtZXNwYWNlcyBzYXZlZCBhcyBhIHN0YWNrXG4gIC8vIEEgbmFtZXNwYWNlIGlzIGEgbWFwcGluZyBvZiBpZGVudGlmaWVycyB0byAzIHR5cGVzOiB2YXJpYWJsZXMsIGZ1bmN0aW9ucywgY2xhc3Nlc1xuICAvLyBBIG5hbWVzcGFjZSBhbHNvIGtub3dzIHdoZXRoZXIgaXQgaXMgZm9yIGdsb2JhbCwgY2xhc3MsIG9yIGZ1bmN0aW9uXG4gIC8vIEEgbmV3IG5hbWVzcGFjZSBpcyBwdXNoZWQgYXQgZnVuY3Rpb24gYW5kIGNsYXNzIHN0YXJ0LCBhbmQgcG9wcGVkIGF0IHRoZWlyIGVuZFxuICAvLyBTdGFydHMgd2l0aCBhIGdsb2JhbCBuYW1lc3BhY2Ugb24gdGhlIHN0YWNrXG4gIC8vIEUuZy4gc2NvcGUubmFtZXNwYWNlcyB+IFt7dHlwZTogJ2cnLCBtYXA6e3g6ICd2JywgTXlDbGFzczogJ2MnfSB9LCAuLi5dXG5cbiAgLy8gVE9ETzogTm90IHRyYWNraW5nIGJ1aWx0LWluIG5hbWVzcGFjZVxuICBcbiAgdmFyIHNjb3BlID0gZXhwb3J0cy5zY29wZSA9IHtcbiAgICBuYW1lc3BhY2VzOiBbXSxcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7IHRoaXMubmFtZXNwYWNlcyA9IFt7IHR5cGU6ICdnJywgbWFwOiB7fSB9XTsgfSxcbiAgICBjdXJyZW50OiBmdW5jdGlvbihvZmZzZXQpIHsgXG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZXNbdGhpcy5uYW1lc3BhY2VzLmxlbmd0aCAtIG9mZnNldCAtIDFdO1xuICAgIH0sXG4gICAgc3RhcnRDbGFzczogZnVuY3Rpb24gKGlkKSB7XG4gICAgICB0aGlzLmN1cnJlbnQoKS5tYXBbaWRdID0gJ2MnO1xuICAgICAgdGhpcy5uYW1lc3BhY2VzLnB1c2goeyB0eXBlOiAnYycsIG1hcDoge30sIGNsYXNzTmFtZTogaWQgfSk7XG4gICAgfSxcbiAgICBzdGFydEZuOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHRoaXMuY3VycmVudCgpLm1hcFtpZF0gPSAnZic7XG4gICAgICB0aGlzLm5hbWVzcGFjZXMucHVzaCh7IHR5cGU6ICdmJywgbWFwOiB7fSwgZm5OYW1lOiBpZCB9KTtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24gKCkgeyB0aGlzLm5hbWVzcGFjZXMucG9wKCk7IH0sXG4gICAgYWRkVmFyOiBmdW5jdGlvbiAoaWQpIHsgdGhpcy5jdXJyZW50KCkubWFwW2lkXSA9ICd2JzsgfSxcbiAgICBleGlzdHM6IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdGhpcy5jdXJyZW50KCkubWFwLmhhc093blByb3BlcnR5KGlkKTsgfSxcbiAgICBpc0NsYXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmN1cnJlbnQoKS50eXBlID09PSAnYyc7IH0sXG4gICAgaXNVc2VyRnVuY3Rpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIC8vIExvb3NlIG1hdGNoIChpLmUuIG9yZGVyIGlnbm9yZWQpXG4gICAgICAvLyBUT0RPOiBkb2VzIG5vdCBpZGVudGlmeSB1c2VyLWRlZmluZWQgY2xhc3MgbWV0aG9kc1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubmFtZXNwYWNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubmFtZXNwYWNlc1tpXS5tYXApXG4gICAgICAgICAgaWYgKGtleSA9PT0gbmFtZSAmJiB0aGlzLm5hbWVzcGFjZXNbaV0ubWFwW2tleV0gPT09ICdmJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNQYXJlbnRDbGFzczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmN1cnJlbnQoMSkudHlwZSA9PT0gJ2MnOyB9LFxuICAgIGlzTmV3T2JqOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLm5hbWVzcGFjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGlmICh0aGlzLm5hbWVzcGFjZXNbaV0ubWFwW2lkXSA9PT0gJ2MnKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lc3BhY2VzW2ldLm1hcFtpZF0gPT09ICdmJykgYnJlYWs7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRQYXJlbnRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY3VycmVudCgxKS5jbGFzc05hbWU7IH0sXG4gICAgZ2V0VGhpc1JlcGxhY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY3VycmVudCgpLnRoaXNSZXBsYWNlOyB9LFxuICAgIHNldFRoaXNSZXBsYWNlOiBmdW5jdGlvbiAocykgeyB0aGlzLmN1cnJlbnQoKS50aGlzUmVwbGFjZSA9IHM7IH1cbiAgfTtcbiAgXG5cbiAgLy8gIyMgVG9rZW4gdHlwZXNcblxuICAvLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuICAvLyBhbGxvd3MgdGhlIHRva2VuaXplciB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gaXQgaGFzIGFib3V0IGFcbiAgLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbiAgLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4gIC8vIGVhc3kgdG8gcmVjb2duaXplLlxuXG4gIC8vIFRoZXNlIGFyZSB0aGUgZ2VuZXJhbCB0eXBlcy4gVGhlIGB0eXBlYCBwcm9wZXJ0eSBpcyBvbmx5IHVzZWQgdG9cbiAgLy8gbWFrZSB0aGVtIHJlY29nbml6ZWFibGUgd2hlbiBkZWJ1Z2dpbmcuXG5cbiAgdmFyIF9udW0gPSB7dHlwZTogXCJudW1cIn0sIF9yZWdleHAgPSB7dHlwZTogXCJyZWdleHBcIn0sIF9zdHJpbmcgPSB7dHlwZTogXCJzdHJpbmdcIn07XG4gIHZhciBfbmFtZSA9IHt0eXBlOiBcIm5hbWVcIn0sIF9lb2YgPSB7dHlwZTogXCJlb2ZcIn07XG4gIHZhciBfbmV3bGluZSA9IHt0eXBlOiBcIm5ld2xpbmVcIn0sIF9pbmRlbnQgPSB7dHlwZTogXCJpbmRlbnRcIn0sIF9kZWRlbnQgPSB7dHlwZTogXCJkZWRlbnRcIn07XG5cbiAgLy8gS2V5d29yZCB0b2tlbnMuIFRoZSBga2V5d29yZGAgcHJvcGVydHkgKGFsc28gdXNlZCBpbiBrZXl3b3JkLWxpa2VcbiAgLy8gb3BlcmF0b3JzKSBpbmRpY2F0ZXMgdGhhdCB0aGUgdG9rZW4gb3JpZ2luYXRlZCBmcm9tIGFuXG4gIC8vIGlkZW50aWZpZXItbGlrZSB3b3JkLCB3aGljaCBpcyB1c2VkIHdoZW4gcGFyc2luZyBwcm9wZXJ0eSBuYW1lcy5cbiAgLy9cbiAgLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbiAgLy8gZXhwcmVzc2lvbnMgYW5kIGRpdmlzaW9ucy4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGNhblxuICAvLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuICAvLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuICBcbiAgdmFyIF9kaWN0ID0geyBrZXl3b3JkOiBcImRpY3RcIiB9OyAgLy8gVE9ETzogbm90IGEga2V5d29yZFxuICB2YXIgX2FzID0geyBrZXl3b3JkOiBcImFzXCIgfSwgX2Fzc2VydCA9IHsga2V5d29yZDogXCJhc3NlcnRcIiB9LCBfYnJlYWsgPSB7IGtleXdvcmQ6IFwiYnJlYWtcIiB9O1xuICB2YXIgX2NsYXNzID0geyBrZXl3b3JkOiBcImNsYXNzXCIgfSwgX2NvbnRpbnVlID0geyBrZXl3b3JkOiBcImNvbnRpbnVlXCIgfTtcbiAgdmFyIF9kZWYgPSB7IGtleXdvcmQ6IFwiZGVmXCIgfSwgX2RlbCA9IHsga2V5d29yZDogXCJkZWxcIiB9O1xuICB2YXIgX2VsaWYgPSB7IGtleXdvcmQ6IFwiZWxpZlwiLCBiZWZvcmVFeHByOiB0cnVlIH0sIF9lbHNlID0geyBrZXl3b3JkOiBcImVsc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZSB9O1xuICB2YXIgX2V4Y2VwdCA9IHsga2V5d29yZDogXCJleGNlcHRcIiwgYmVmb3JlRXhwcjogdHJ1ZSB9LCBfZmluYWxseSA9IHtrZXl3b3JkOiBcImZpbmFsbHlcIn07XG4gIHZhciBfZm9yID0geyBrZXl3b3JkOiBcImZvclwiIH0sIF9mcm9tID0geyBrZXl3b3JkOiBcImZyb21cIiB9LCBfZ2xvYmFsID0geyBrZXl3b3JkOiBcImdsb2JhbFwiIH07XG4gIHZhciBfaWYgPSB7IGtleXdvcmQ6IFwiaWZcIiB9LCBfaW1wb3J0ID0geyBrZXl3b3JkOiBcImltcG9ydFwiIH07XG4gIHZhciBfbGFtYmRhID0ge2tleXdvcmQ6IFwibGFtYmRhXCJ9LCBfbm9ubG9jYWwgPSB7a2V5d29yZDogXCJub25sb2NhbFwifTtcbiAgdmFyIF9wYXNzID0geyBrZXl3b3JkOiBcInBhc3NcIiB9LCBfcmFpc2UgPSB7a2V5d29yZDogXCJyYWlzZVwifTtcbiAgdmFyIF9yZXR1cm4gPSB7IGtleXdvcmQ6IFwicmV0dXJuXCIsIGJlZm9yZUV4cHI6IHRydWUgfSwgX3RyeSA9IHsga2V5d29yZDogXCJ0cnlcIiB9O1xuICB2YXIgX3doaWxlID0ge2tleXdvcmQ6IFwid2hpbGVcIn0sIF93aXRoID0ge2tleXdvcmQ6IFwid2l0aFwifSwgX3lpZWxkID0ge2tleXdvcmQ6IFwieWllbGRcIn07XG5cbiAgLy8gVGhlIGtleXdvcmRzIHRoYXQgZGVub3RlIHZhbHVlcy5cblxuICB2YXIgX25vbmUgPSB7a2V5d29yZDogXCJOb25lXCIsIGF0b21WYWx1ZTogbnVsbH0sIF90cnVlID0ge2tleXdvcmQ6IFwiVHJ1ZVwiLCBhdG9tVmFsdWU6IHRydWV9O1xuICB2YXIgX2ZhbHNlID0ge2tleXdvcmQ6IFwiRmFsc2VcIiwgYXRvbVZhbHVlOiBmYWxzZX07XG5cbiAgLy8gU29tZSBrZXl3b3JkcyBhcmUgdHJlYXRlZCBhcyByZWd1bGFyIG9wZXJhdG9ycy4gYGluYCBzb21ldGltZXNcbiAgLy8gKHdoZW4gcGFyc2luZyBgZm9yYCkgbmVlZHMgdG8gYmUgdGVzdGVkIGFnYWluc3Qgc3BlY2lmaWNhbGx5LCBzb1xuICAvLyB3ZSBhc3NpZ24gYSB2YXJpYWJsZSBuYW1lIHRvIGl0IGZvciBxdWljayBjb21wYXJpbmcuXG4gIC8vICdwcmVjJyBpcyB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSdcblxuICB2YXIgX29yID0geyBrZXl3b3JkOiBcIm9yXCIsIHByZWM6IDEsIGJlZm9yZUV4cHI6IHRydWUsIHJlcDogXCJ8fFwiIH07XG4gIHZhciBfYW5kID0geyBrZXl3b3JkOiBcImFuZFwiLCBwcmVjOiAyLCBiZWZvcmVFeHByOiB0cnVlLCByZXA6IFwiJiZcIiB9O1xuICB2YXIgX25vdCA9IHsga2V5d29yZDogXCJub3RcIiwgcHJlYzogMywgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlLCByZXA6IFwiIVwiIH07XG4gIHZhciBfaW4gPSB7IGtleXdvcmQ6IFwiaW5cIiwgcHJlYzogNCwgYmVmb3JlRXhwcjogdHJ1ZSB9O1xuICB2YXIgX2lzID0geyBrZXl3b3JkOiBcImlzXCIsIHByZWM6IDQsIGJlZm9yZUV4cHI6IHRydWUgfTtcblxuICAvLyBNYXAga2V5d29yZCBuYW1lcyB0byB0b2tlbiB0eXBlcy5cblxuICB2YXIga2V5d29yZFR5cGVzID0ge1xuICAgIFwiZGljdFwiOiBfZGljdCxcbiAgICBcIkZhbHNlXCI6IF9mYWxzZSwgXCJOb25lXCI6IF9ub25lLCBcIlRydWVcIjogX3RydWUsIFwiYW5kXCI6IF9hbmQsIFwiYXNcIjogX2FzLCBcbiAgICBcImJyZWFrXCI6IF9icmVhaywgXCJjbGFzc1wiOiBfY2xhc3MsIFwiY29udGludWVcIjogX2NvbnRpbnVlLCBcImRlZlwiOiBfZGVmLCBcImRlbFwiOiBfZGVsLFxuICAgIFwiZWxpZlwiOiBfZWxpZiwgXCJlbHNlXCI6IF9lbHNlLCBcImV4Y2VwdFwiOiBfZXhjZXB0LCBcImZpbmFsbHlcIjogX2ZpbmFsbHksIFwiZm9yXCI6IF9mb3IsXG4gICAgXCJmcm9tXCI6IF9mcm9tLCBcImdsb2JhbFwiOiBfZ2xvYmFsLCBcImlmXCI6IF9pZiwgXCJpbXBvcnRcIjogX2ltcG9ydCwgXCJpblwiOiBfaW4sIFwiaXNcIjogX2lzLCBcbiAgICBcImxhbWJkYVwiOiBfbGFtYmRhLCBcIm5vbmxvY2FsXCI6IF9ub25sb2NhbCwgXCJub3RcIjogX25vdCwgXCJvclwiOiBfb3IsIFxuICAgIFwicGFzc1wiOiBfcGFzcywgXCJyYWlzZVwiOiBfcmFpc2UsIFwicmV0dXJuXCI6IF9yZXR1cm4sIFwidHJ5XCI6IF90cnksIFwid2hpbGVcIjogX3doaWxlLCBcbiAgICBcIndpdGhcIjogX3dpdGgsIFwieWllbGRcIjogX3lpZWxkXG4gIH07XG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuIEFnYWluLCB0aGUgYHR5cGVgIHByb3BlcnR5IGlzIHB1cmVseSBmb3IgZGVidWdnaW5nLlxuXG4gIHZhciBfYnJhY2tldEwgPSB7dHlwZTogXCJbXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfYnJhY2tldFIgPSB7dHlwZTogXCJdXCJ9LCBfYnJhY2VMID0ge3R5cGU6IFwie1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9icmFjZVIgPSB7dHlwZTogXCJ9XCJ9LCBfcGFyZW5MID0ge3R5cGU6IFwiKFwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3BhcmVuUiA9IHt0eXBlOiBcIilcIn07XG4gIHZhciBfY29tbWEgPSB7dHlwZTogXCIsXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfc2VtaSA9IHt0eXBlOiBcIjtcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfY29sb24gPSB7IHR5cGU6IFwiOlwiLCBiZWZvcmVFeHByOiB0cnVlIH0sIF9kb3QgPSB7IHR5cGU6IFwiLlwiIH0sIF9xdWVzdGlvbiA9IHsgdHlwZTogXCI/XCIsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBwcmVjYCBzcGVjaWZpZXMgdGhlIHByZWNlZGVuY2Ugb2YgdGhpcyBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYHByZWZpeGAgbWFya3MgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IHVuYXJ5IG9wZXJhdG9yLiBcbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIHZhciBfc2xhc2ggPSB7IHByZWM6IDEwLCBiZWZvcmVFeHByOiB0cnVlIH0sIF9lcSA9IHsgaXNBc3NpZ246IHRydWUsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9hc3NpZ24gPSB7aXNBc3NpZ246IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2VxdWFsaXR5ID0geyBwcmVjOiA0LCBiZWZvcmVFeHByOiB0cnVlIH07XG4gIHZhciBfcmVsYXRpb25hbCA9IHtwcmVjOiA0LCBiZWZvcmVFeHByOiB0cnVlIH07XG4gIHZhciBfYml0d2lzZU9SID0geyBwcmVjOiA1LCBiZWZvcmVFeHByOiB0cnVlIH07XG4gIHZhciBfYml0d2lzZVhPUiA9IHsgcHJlYzogNiwgYmVmb3JlRXhwcjogdHJ1ZSB9O1xuICB2YXIgX2JpdHdpc2VBTkQgPSB7IHByZWM6IDcsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9iaXRTaGlmdCA9IHsgcHJlYzogOCwgYmVmb3JlRXhwcjogdHJ1ZSB9O1xuICB2YXIgX3BsdXNNaW4gPSB7IHByZWM6IDksIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9tdWx0aXBseU1vZHVsbyA9IHsgcHJlYzogMTAsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9mbG9vckRpdiA9IHsgcHJlYzogMTAsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9wb3NOZWdOb3QgPSB7IHByZWM6IDExLCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWUgfTtcbiAgdmFyIF9iaXR3aXNlTk9UID0geyBwcmVjOiAxMSwgcHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlIH07XG4gIHZhciBfZXhwb25lbnRpYXRpb24gPSB7IHByZWM6IDEyLCBiZWZvcmVFeHByOiB0cnVlIH07XG5cbiAgLy8gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIHRva2VuIHR5cGVzIGZvciBleHRlcm5hbCB1c2VycyBvZiB0aGVcbiAgLy8gdG9rZW5pemVyLlxuXG4gIGV4cG9ydHMudG9rVHlwZXMgPSB7YnJhY2tldEw6IF9icmFja2V0TCwgYnJhY2tldFI6IF9icmFja2V0UiwgYnJhY2VMOiBfYnJhY2VMLCBicmFjZVI6IF9icmFjZVIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW5MOiBfcGFyZW5MLCBwYXJlblI6IF9wYXJlblIsIGNvbW1hOiBfY29tbWEsIHNlbWk6IF9zZW1pLCBjb2xvbjogX2NvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgIGRvdDogX2RvdCwgcXVlc3Rpb246IF9xdWVzdGlvbiwgc2xhc2g6IF9zbGFzaCwgZXE6IF9lcSwgbmFtZTogX25hbWUsIGVvZjogX2VvZixcbiAgICAgICAgICAgICAgICAgICAgICBudW06IF9udW0sIHJlZ2V4cDogX3JlZ2V4cCwgc3RyaW5nOiBfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld2xpbmU6IF9uZXdsaW5lLCBpbmRlbnQ6IF9pbmRlbnQsIGRlZGVudDogX2RlZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudGlhdGlvbjogX2V4cG9uZW50aWF0aW9uLCBmbG9vckRpdjogX2Zsb29yRGl2LCBwbHVzTWluOiBfcGx1c01pbixcbiAgICAgICAgICAgICAgICAgICAgICBwb3NOZWdOb3Q6IF9wb3NOZWdOb3QsIG11bHRpcGx5TW9kdWxvOiBfbXVsdGlwbHlNb2R1bG9cbiAgfTtcbiAgZm9yICh2YXIga3cgaW4ga2V5d29yZFR5cGVzKSBleHBvcnRzLnRva1R5cGVzW1wiX1wiICsga3ddID0ga2V5d29yZFR5cGVzW2t3XTtcblxuICAvLyBUaGlzIGlzIGEgdHJpY2sgdGFrZW4gZnJvbSBFc3ByaW1hLiBJdCB0dXJucyBvdXQgdGhhdCwgb25cbiAgLy8gbm9uLUNocm9tZSBicm93c2VycywgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZyBpcyBpbiBhIHNldCwgYVxuICAvLyBwcmVkaWNhdGUgY29udGFpbmluZyBhIGJpZyB1Z2x5IGBzd2l0Y2hgIHN0YXRlbWVudCBpcyBmYXN0ZXIgdGhhblxuICAvLyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYW5kIG9uIENocm9tZSB0aGUgdHdvIGFyZSBhYm91dCBvbiBwYXIuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyBgZXZhbGAgKG5vbi1sZXhpY2FsKSB0byBwcm9kdWNlIHN1Y2ggYVxuICAvLyBwcmVkaWNhdGUgZnJvbSBhIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgb2Ygd29yZHMuXG4gIC8vXG4gIC8vIEl0IHN0YXJ0cyBieSBzb3J0aW5nIHRoZSB3b3JkcyBieSBsZW5ndGguXG5cbiAgZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICAgIHdvcmRzID0gd29yZHMuc3BsaXQoXCIgXCIpO1xuICAgIHZhciBmID0gXCJcIiwgY2F0cyA9IFtdO1xuICAgIG91dDogZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYXRzLmxlbmd0aDsgKytqKVxuICAgICAgICBpZiAoY2F0c1tqXVswXS5sZW5ndGggPT0gd29yZHNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcbiAgICAgICAgICBjb250aW51ZSBvdXQ7XG4gICAgICAgIH1cbiAgICAgIGNhdHMucHVzaChbd29yZHNbaV1dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVRvKGFycikge1xuICAgICAgaWYgKGFyci5sZW5ndGggPT0gMSkgcmV0dXJuIGYgKz0gXCJyZXR1cm4gc3RyID09PSBcIiArIEpTT04uc3RyaW5naWZ5KGFyclswXSkgKyBcIjtcIjtcbiAgICAgIGYgKz0gXCJzd2l0Y2goc3RyKXtcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSBmICs9IFwiY2FzZSBcIiArIEpTT04uc3RyaW5naWZ5KGFycltpXSkgKyBcIjpcIjtcbiAgICAgIGYgKz0gXCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCI7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIHRocmVlIGxlbmd0aCBjYXRlZ29yaWVzLCBhbiBvdXRlclxuICAgIC8vIHN3aXRjaCBmaXJzdCBkaXNwYXRjaGVzIG9uIHRoZSBsZW5ndGhzLCB0byBzYXZlIG9uIGNvbXBhcmlzb25zLlxuXG4gICAgaWYgKGNhdHMubGVuZ3RoID4gMykge1xuICAgICAgY2F0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDt9KTtcbiAgICAgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNhdCA9IGNhdHNbaV07XG4gICAgICAgIGYgKz0gXCJjYXNlIFwiICsgY2F0WzBdLmxlbmd0aCArIFwiOlwiO1xuICAgICAgICBjb21wYXJlVG8oY2F0KTtcbiAgICAgIH1cbiAgICAgIGYgKz0gXCJ9XCI7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgc2ltcGx5IGdlbmVyYXRlIGEgZmxhdCBgc3dpdGNoYCBzdGF0ZW1lbnQuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGFyZVRvKHdvcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLCBmKTtcbiAgfVxuXG4gIC8vIFRoZSBmb3JiaWRkZW4gdmFyaWFibGUgbmFtZXNcblxuICB2YXIgaXNTdHJpY3RCYWRJZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiZXZhbCBhcmd1bWVudHNcIik7XG5cbiAgLy8gS2V5d29yZHNcbiAgLy8gVE9ETzogZGljdCBpc24ndCBhIGtleXdvcmQsIGl0J3MgYSBidWlsdGluXG5cbiAgdmFyIGlzS2V5d29yZCA9IG1ha2VQcmVkaWNhdGUoXCJkaWN0IEZhbHNlIE5vbmUgVHJ1ZSBhbmQgYXMgYXNzZXJ0IGJyZWFrIGNsYXNzIGNvbnRpbnVlIGRlZiBkZWwgZWxpZiBlbHNlIGV4Y2VwdCBmaW5hbGx5IGZvciBmcm9tIGdsb2JhbCBpZiBpbXBvcnQgaW4gaXMgbGFtYmRhIG5vbmxvY2FsIG5vdCBvciBwYXNzIHJhaXNlIHJldHVybiB0cnkgd2hpbGUgd2l0aCB5aWVsZFwiKTtcblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuXG4gIHZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgLy8gV2hldGhlciBhIHNpbmdsZSBjaGFyYWN0ZXIgZGVub3RlcyBhIG5ld2xpbmUuXG5cbiAgdmFyIG5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbiAgLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuICAvLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbiAgdmFyIGlzSWRlbnRpZmllclN0YXJ0ID0gZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKXJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfTtcblxuICAvLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgaXMgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXG4gIHZhciBpc0lkZW50aWZpZXJDaGFyID0gZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuICAgIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIGlmIChjb2RlIDwgMTIzKXJldHVybiB0cnVlO1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH07XG5cbiAgLy8gIyMgVG9rZW5pemVyXG5cbiAgLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4gIC8vIGB0b2tTdGFydExvY2AgYW5kIGB0b2tFbmRMb2NgIHByb3BlcnRpZXMuXG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgdGhpcy5saW5lID0gdG9rQ3VyTGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IHRva1BvcyAtIHRva0xpbmVTdGFydDtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSB0b2tlbiBzdGF0ZS4gVXNlZCBhdCB0aGUgc3RhcnQgb2YgYSBwYXJzZS5cblxuICBmdW5jdGlvbiBpbml0VG9rZW5TdGF0ZSgpIHtcbiAgICB0b2tDdXJMaW5lID0gMTtcbiAgICB0b2tQb3MgPSB0b2tMaW5lU3RhcnQgPSAwO1xuICAgIHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuICAgIGluZGVudEhpc3QuaW5pdCgpO1xuICAgIG5ld0FzdElkQ291bnQgPSAwO1xuICAgIHNjb3BlLmluaXQoKTtcbiAgfVxuXG4gIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGB0b2tFbmRgLCBgdG9rVmFsYCwgYW5kXG4gIC8vIGB0b2tSZWdleHBBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlciB0aGUgdG9rZW4sIHNvIHRoYXRcbiAgLy8gdGhlIG5leHQgb25lJ3MgYHRva1N0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZSByaWdodCBwb3NpdGlvbi5cblxuICBmdW5jdGlvbiBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0b2tFbmQgPSB0b2tQb3M7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB0b2tFbmRMb2MgPSBuZXcgUG9zaXRpb247XG4gICAgdG9rVHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGUgPT09IF9wYXJlbkwgfHwgdHlwZSA9PT0gX2JyYWNlTCB8fCB0eXBlID09PSBfYnJhY2tldEwpICsrYnJhY2tldE5lc3Rpbmc7XG4gICAgaWYgKHR5cGUgPT09IF9wYXJlblIgfHwgdHlwZSA9PT0gX2JyYWNlUiB8fCB0eXBlID09PSBfYnJhY2tldFIpIC0tYnJhY2tldE5lc3Rpbmc7XG4gICAgaWYgKHR5cGUgIT09IF9uZXdsaW5lKSBza2lwU3BhY2UoKTtcbiAgICB0b2tWYWwgPSB2YWw7XG4gICAgdG9rUmVnZXhwQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBMaW5lKCkge1xuICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuICAgIHdoaWxlICh0b2tQb3MgPCBpbnB1dExlbiAmJiAhaXNOZXdsaW5lKGNoKSkge1xuICAgICAgKyt0b2tQb3M7XG4gICAgICBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2lwTGluZUNvbW1lbnQoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdG9rUG9zO1xuICAgIHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBQb3NpdGlvbjtcbiAgICBza2lwTGluZSgpO1xuICAgIGlmIChvcHRpb25zLm9uQ29tbWVudClcbiAgICAgIG9wdGlvbnMub25Db21tZW50KGlucHV0LnNsaWNlKHN0YXJ0ICsgMSwgdG9rUG9zKSwgc3RhcnQsIHRva1BvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgUG9zaXRpb24pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuICAvLyB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cywgYW5kLlxuXG4gIGZ1bmN0aW9uIHNraXBTcGFjZSgpIHtcbiAgICB3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4pIHtcbiAgICAgIHZhciBjaCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAgIGlmIChjaCA9PT0gMzUpIHNraXBMaW5lQ29tbWVudCgpO1xuICAgICAgZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICAgICsrdG9rUG9zO1xuICAgICAgICBpZiAoaXNOZXdsaW5lKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSkpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSAxMyAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcysxKSA9PT0gMTApICsrdG9rUG9zO1xuICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9uKSB7IHRva0xpbmVTdGFydCA9IHRva1BvczsgKyt0b2tDdXJMaW5lOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFpc2UodG9rUG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIGFmdGVyIGxpbmUgY29udGludWF0aW9uIGNoYXJhY3RlclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNTcGFjZShjaCkpICsrdG9rUG9zO1xuICAgICAgZWxzZSBpZiAoYnJhY2tldE5lc3RpbmcgPiAwICYmIGlzTmV3bGluZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAxMyAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcysxKSA9PT0gMTApICsrdG9rUG9zO1xuICAgICAgICArK3Rva1BvcztcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb24pIHsgdG9rTGluZVN0YXJ0ID0gdG9rUG9zOyArK3Rva0N1ckxpbmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTcGFjZShjaCkge1xuICAgIGlmIChjaCA9PT0gMzIgfHwgLy8gJyAnXG4gICAgICBjaCA9PT0gOSB8fCBjaCA9PT0gMTEgfHwgY2ggPT09IDEyIHx8XG4gICAgICBjaCA9PT0gMTYwIHx8IC8vICdcXHhhMCdcbiAgICAgIGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZXdsaW5lKGNoKSB7XG4gICAgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMgfHxcbiAgICAgIGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbiAgLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4gIC8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4gIC8vIGludG8gaXQuXG4gIC8vXG4gIC8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbiAgLy9cbiAgLy8gVGhlIGBmb3JjZVJlZ2V4cGAgcGFyYW1ldGVyIGlzIHVzZWQgaW4gdGhlIG9uZSBjYXNlIHdoZXJlIHRoZVxuICAvLyBgdG9rUmVnZXhwQWxsb3dlZGAgdHJpY2sgZG9lcyBub3Qgd29yay4gU2VlIGBwYXJzZVN0YXRlbWVudGAuXG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcbiAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgcmV0dXJuIHJlYWROdW1iZXIodHJ1ZSk7XG4gICAgKyt0b2tQb3M7XG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKF9kb3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3NsYXNoKCkgeyAvLyAnLydcbiAgICBpZiAodG9rUmVnZXhwQWxsb3dlZCkgeyArK3Rva1BvczsgcmV0dXJuIHJlYWRSZWdleHAoKTsgfVxuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNDcpIHJldHVybiBmaW5pc2hPcChfZmxvb3JEaXYsIDIpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuICAgIHJldHVybiBmaW5pc2hPcChfc2xhc2gsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHsgLy8gJyolJ1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNDIgJiYgbmV4dCA9PT0gY29kZSkgcmV0dXJuIGZpbmlzaE9wKF9leHBvbmVudGlhdGlvbiwgMik7XG4gICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgcmV0dXJuIGZpbmlzaE9wKF9tdWx0aXBseU1vZHVsbywgMSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7IC8vICd8JidcbiAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG4gICAgcmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9iaXR3aXNlT1IgOiBfYml0d2lzZUFORCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7IC8vICdeJ1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICByZXR1cm4gZmluaXNoT3AoX2JpdHdpc2VYT1IsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpIHsgLy8gJystJ1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcbiAgICByZXR1cm4gZmluaXNoT3AoX3BsdXNNaW4sIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHsgLy8gJzw+J1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSAyO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgc2l6ZSkgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgc2l6ZSArIDEpO1xuICAgICAgcmV0dXJuIGZpbmlzaE9wKF9iaXRTaGlmdCwgc2l6ZSk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgc2l6ZSA9IDI7XG4gICAgcmV0dXJuIGZpbmlzaE9wKF9yZWxhdGlvbmFsLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHsgLy8gJz0hJ1xuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfZXF1YWxpdHksIDIpO1xuICAgIHJldHVybiBmaW5pc2hPcChfZXEsIDEpO1xuICB9XG5cbiAgLy8gUGFyc2UgaW5kZW50YXRpb25cbiAgLy8gUG9zc2libGUgb3V0cHV0OiBfaW5kZW50LCBfZGVkZW50LCBfZW9mLCByZWFkVG9rZW4oKVxuICAvLyBUT0RPOiBkaXNhbGxvdyB1bmVxdWFsIGluZGVudHMgb2Ygc2FtZSBsZW5ndGggKGUuZy4gbmVzdGVkIGlmL2Vsc2UgYmxvY2spXG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2luZGVudCgpIHtcbiAgICAvLyBSZWFkIGluZGVudCwgc2tpcCBlbXB0eSBsaW5lcyBhbmQgY29tbWVudHNcbiAgICB2YXIgaW5kZW50ID0gXCJcIjtcbiAgICB2YXIgaW5kZW50UG9zID0gdG9rUG9zO1xuICAgIHZhciBjaCwgbmV4dDtcbiAgICB3aGlsZSAoaW5kZW50UG9zIDwgaW5wdXRMZW4pIHtcbiAgICAgIGNoID0gaW5wdXQuY2hhckNvZGVBdChpbmRlbnRQb3MpO1xuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGluZGVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgKytpbmRlbnRQb3M7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV3bGluZShjaCkpIHsgLy8gbmV3bGluZVxuICAgICAgICBpbmRlbnQgPSBcIlwiO1xuICAgICAgICBpZiAoY2ggPT09IDEzICYmIGlucHV0LmNoYXJDb2RlQXQoaW5kZW50UG9zICsgMSkgPT09IDEwKSArK2luZGVudFBvcztcbiAgICAgICAgKytpbmRlbnRQb3M7XG4gICAgICAgIHRva1BvcyA9IGluZGVudFBvcztcbiAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgdG9rTGluZVN0YXJ0ID0gaW5kZW50UG9zO1xuICAgICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMzUpIHsgLy8gJyMnXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCgrK2luZGVudFBvcyk7XG4gICAgICAgIH0gd2hpbGUgKGluZGVudFBvcyA8IGlucHV0TGVuICYmIG5leHQgIT09IDEwKTtcbiAgICAgICAgLy8gVE9ETzogY2FsbCBvbkNvbW1lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZSB0b2tlbiB0eXBlIGJhc2VkIG9uIGluZGVudCBmb3VuZCB2ZXJzdXMgaW5kZW50YXRpb24gaGlzdG9yeVxuICAgIHZhciB0eXBlO1xuICAgIGlmIChpbmRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGluZGVudEhpc3QuaXNJbmRlbnQoaW5kZW50KSkge1xuICAgICAgICB0eXBlID0gX2luZGVudDtcbiAgICAgICAgaWYgKGluZGVudEhpc3QuY291bnQoKSA+PSAxKSB0b2tTdGFydCArPSBpbmRlbnRIaXN0LmxlbihpbmRlbnRIaXN0LmNvdW50KCkgLSAxKTtcbiAgICAgICAgaW5kZW50SGlzdC5hZGRJbmRlbnQoaW5kZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5kZW50SGlzdC5pc0RlZGVudChpbmRlbnQpKSB7XG4gICAgICAgIHR5cGUgPSBfZGVkZW50O1xuICAgICAgICBpbmRlbnRIaXN0LmFkZERlZGVudChpbmRlbnQpO1xuICAgICAgICB2YXIgbmV4dERlZGVudCA9IGluZGVudEhpc3QuY291bnQoKSAtIGluZGVudEhpc3QuZGVkZW50Q291bnQ7XG4gICAgICAgIGlmIChuZXh0RGVkZW50ID49IDIpIHtcbiAgICAgICAgICB0b2tTdGFydCArPSBpbmRlbnRIaXN0LmxlbihuZXh0RGVkZW50KSAtIGluZGVudEhpc3QubGVuKG5leHREZWRlbnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rUG9zICs9IGluZGVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRQb3MgPj0gaW5wdXRMZW4pIHtcbiAgICAgIHR5cGUgPSBfZW9mO1xuICAgIH0gZWxzZSBpZiAoaW5kZW50SGlzdC5jb3VudCgpID4gMCkge1xuICAgICAgdHlwZSA9IF9kZWRlbnQ7XG4gICAgICBpbmRlbnRIaXN0LnVwZGF0ZURlZGVudCgpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfaW5kZW50OiBjYXNlIF9kZWRlbnQ6IHJldHVybiBmaW5pc2hPcCh0eXBlLCBpbmRlbnRQb3MgLSArK3Rva1Bvcyk7XG4gICAgICBjYXNlIF9lb2Y6XG4gICAgICAgIHRva1BvcyA9IGlucHV0TGVuO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva1N0YXJ0TG9jID0gbmV3IFBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gZmluaXNoT3AodHlwZSwgMCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0b2tUeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlYWRUb2tlbigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaChjb2RlKSB7XG5cbiAgICBjYXNlIDEzOiBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdG9rUG9zO1xuICAgICAgaWYgKGNvZGUgPT09IDEzICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gMTApICsrdG9rUG9zO1xuICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdG9rQ3VyTGluZTtcbiAgICAgICAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9uZXdsaW5lKTtcblxuICAgIGNhc2UgMzU6IC8vICcjJ1xuICAgICAgc2tpcExpbmVDb21tZW50KCk7XG4gICAgICByZXR1cm4gcmVhZFRva2VuKCk7XG5cbiAgICAgIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgICAgIC8vIGJ5IGEgZGlnaXQuXG4gICAgY2FzZSA0NjogLy8gJy4nXG4gICAgICByZXR1cm4gcmVhZFRva2VuX2RvdCgpO1xuXG4gICAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gICAgY2FzZSA0MDogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcGFyZW5MKTtcbiAgICBjYXNlIDQxOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9wYXJlblIpO1xuICAgIGNhc2UgNTk6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3NlbWkpO1xuICAgIGNhc2UgNDQ6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2NvbW1hKTtcbiAgICBjYXNlIDkxOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFja2V0TCk7XG4gICAgY2FzZSA5MzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldFIpO1xuICAgIGNhc2UgMTIzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZUwpO1xuICAgIGNhc2UgMTI1OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9icmFjZVIpO1xuICAgIGNhc2UgNTg6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2NvbG9uKTtcbiAgICBjYXNlIDYzOiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9xdWVzdGlvbik7XG5cbiAgICAgIC8vICcweCcgaXMgYSBoZXhhZGVjaW1hbCBudW1iZXIuXG4gICAgY2FzZSA0ODogLy8gJzAnXG4gICAgICB2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG4gICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSByZXR1cm4gcmVhZEhleE51bWJlcigpO1xuICAgICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgICAgcmV0dXJuIHJlYWROdW1iZXIoZmFsc2UpO1xuXG4gICAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgICByZXR1cm4gcmVhZFN0cmluZyhjb2RlKTtcblxuICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHJldHVybiByZWFkVG9rZW5fc2xhc2goY29kZSk7XG5cbiAgICBjYXNlIDQyOiBjYXNlIDM3OiAvLyAnKiUnXG4gICAgICByZXR1cm4gcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuXG4gICAgY2FzZSAxMjQ6IGNhc2UgMzg6IC8vICd8JidcbiAgICAgIHJldHVybiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG5cbiAgICBjYXNlIDk0OiAvLyAnXidcbiAgICAgIHJldHVybiByZWFkVG9rZW5fY2FyZXQoKTtcblxuICAgIGNhc2UgNDM6IGNhc2UgNDU6IC8vICcrLSdcbiAgICAgIHJldHVybiByZWFkVG9rZW5fcGx1c19taW4oY29kZSk7XG5cbiAgICBjYXNlIDYwOiBjYXNlIDYyOiAvLyAnPD4nXG4gICAgICByZXR1cm4gcmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgICAgcmV0dXJuIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpO1xuXG4gICAgY2FzZSAxMjY6IC8vICd+J1xuICAgICAgcmV0dXJuIGZpbmlzaE9wKF9iaXR3aXNlTk9ULCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4oZm9yY2VSZWdleHApIHtcbiAgICBpZiAodG9rVHlwZSA9PT0gX2RlZGVudCkge1xuICAgICAgaW5kZW50SGlzdC5wb3AoKTtcbiAgICAgIGlmIChpbmRlbnRIaXN0LmRlZGVudENvdW50ID4gMCkgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZm9yY2VSZWdleHApIHRva1N0YXJ0ID0gdG9rUG9zO1xuICAgIGVsc2UgdG9rUG9zID0gdG9rU3RhcnQgKyAxO1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgdG9rU3RhcnRMb2MgPSBuZXcgUG9zaXRpb247XG4gICAgaWYgKGZvcmNlUmVnZXhwKSByZXR1cm4gcmVhZFJlZ2V4cCgpO1xuICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJldHVybiBmaW5pc2hUb2tlbihfZW9mKTtcbiAgICBpZiAodG9rVHlwZSA9PT0gX25ld2xpbmUpIHJldHVybiByZWFkVG9rZW5faW5kZW50KCk7XG5cbiAgICB2YXIgY29kZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKTtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykgcmV0dXJuIHJlYWRXb3JkKCk7XG5cbiAgICB2YXIgdG9rID0gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcblxuICAgIGlmICh0b2sgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgaGVyZSwgd2UgZWl0aGVyIGZvdW5kIGEgbm9uLUFTQ0lJIGlkZW50aWZpZXJcbiAgICAgIC8vIGNoYXJhY3Rlciwgb3Igc29tZXRoaW5nIHRoYXQncyBlbnRpcmVseSBkaXNhbGxvd2VkLlxuICAgICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIgfHwgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChjaCkpIHJldHVybiByZWFkV29yZCgpO1xuICAgICAgcmFpc2UodG9rUG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoT3AodHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSBpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIHNpemUpO1xuICAgIHRva1BvcyArPSBzaXplO1xuICAgIGZpbmlzaFRva2VuKHR5cGUsIHN0cik7XG4gIH1cblxuICAvLyBQYXJzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbi4gU29tZSBjb250ZXh0LWF3YXJlbmVzcyBpcyBuZWNlc3NhcnksXG4gIC8vIHNpbmNlIGEgJy8nIGluc2lkZSBhICdbXScgc2V0IGRvZXMgbm90IGVuZCB0aGUgZXhwcmVzc2lvbi5cblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKCkge1xuICAgIHZhciBjb250ZW50ID0gXCJcIiwgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0b2tQb3MsIHZhbHVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0b2tQb3MgPj0gaW5wdXRMZW4pIHJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG4gICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQodG9rUG9zKTtcbiAgICAgIGlmIChuZXdsaW5lLnRlc3QoY2gpKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgaW5DbGFzcyA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIGJyZWFrO1xuICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgfSBlbHNlIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICsrdG9rUG9zO1xuICAgIH1cbiAgICBjb250ZW50ID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gICAgKyt0b2tQb3M7XG4gICAgLy8gTmVlZCB0byB1c2UgYHJlYWRXb3JkMWAgYmVjYXVzZSAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkXG4gICAgLy8gaGVyZSAoZG9uJ3QgYXNrKS5cbiAgICB2YXIgbW9kcyA9IHJlYWRXb3JkMSgpO1xuICAgIGlmIChtb2RzICYmICEvXltnbXNpeV0qJC8udGVzdChtb2RzKSkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKGNvbnRlbnQsIG1vZHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHJhaXNlKHN0YXJ0LCBcIkVycm9yIHBhcnNpbmcgcmVndWxhciBleHByZXNzaW9uOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICByYWlzZShlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaFRva2VuKF9yZWdleHAsIHZhbHVlKTtcbiAgfVxuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4gIC8vIHdlcmUgcmVhZCwgdGhlIGludGVnZXIgdmFsdWUgb3RoZXJ3aXNlLiBXaGVuIGBsZW5gIGlzIGdpdmVuLCB0aGlzXG4gIC8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG4gIGZ1bmN0aW9uIHJlYWRJbnQocmFkaXgsIGxlbikge1xuICAgIHZhciBzdGFydCA9IHRva1BvcywgdG90YWwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgICAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyksIHZhbDtcbiAgICAgIGlmIChjb2RlID49IDk3KSB2YWwgPSBjb2RlIC0gOTcgKyAxMDsgLy8gYVxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA2NSkgdmFsID0gY29kZSAtIDY1ICsgMTA7IC8vIEFcbiAgICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgdmFsID0gY29kZSAtIDQ4OyAvLyAwLTlcbiAgICAgIGVsc2UgdmFsID0gSW5maW5pdHk7XG4gICAgICBpZiAodmFsID49IHJhZGl4KSBicmVhaztcbiAgICAgICsrdG9rUG9zO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cbiAgICBpZiAodG9rUG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0b2tQb3MgLSBzdGFydCAhPT0gbGVuKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRIZXhOdW1iZXIoKSB7XG4gICAgdG9rUG9zICs9IDI7IC8vIDB4XG4gICAgdmFyIHZhbCA9IHJlYWRJbnQoMTYpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgcmFpc2UodG9rU3RhcnQgKyAyLCBcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuICAgIHJldHVybiBmaW5pc2hUb2tlbihfbnVtLCB2YWwpO1xuICB9XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbiAgZnVuY3Rpb24gcmVhZE51bWJlcihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdG9rUG9zLCBpc0Zsb2F0ID0gZmFsc2UsIG9jdGFsID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0ODtcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgcmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ2KSB7XG4gICAgICArK3Rva1BvcztcbiAgICAgIHJlYWRJbnQoMTApO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgIGlmIChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpIHsgLy8gJ2VFJ1xuICAgICAgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSArK3Rva1BvczsgLy8gJystJ1xuICAgICAgaWYgKHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuXG4gICAgdmFyIHN0ciA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpLCB2YWw7XG4gICAgaWYgKGlzRmxvYXQpIHZhbCA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICBlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gICAgZWxzZSBpZiAoL1s4OV0vLnRlc3Qoc3RyKSB8fCBzdHJpY3QpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuICAgIGVsc2UgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgICByZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgfVxuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBmdW5jdGlvbiByZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgdG9rUG9zKys7XG4gICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgIHZhciB0cmlwbGVRdW90ZWQgPSBmYWxzZTtcbiAgICBpZiAoY2ggPT09IHF1b3RlICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKzEpID09PSBxdW90ZSkge1xuICAgICAgdHJpcGxlUXVvdGVkID0gdHJ1ZTtcbiAgICAgIHRva1BvcyArPSAyO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gXCJcIjtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZSh0b2tTdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICBpZiAodHJpcGxlUXVvdGVkKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKzEpID09PSBxdW90ZSAmJlxuICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcysyKSA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgIHRva1BvcyArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaFRva2VuKF9zdHJpbmcsIG91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdG9rUG9zO1xuICAgICAgICAgIHJldHVybiBmaW5pc2hUb2tlbihfc3RyaW5nLCBvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgICAgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcbiAgICAgICAgdmFyIG9jdGFsID0gL15bMC03XSsvLmV4ZWMoaW5wdXQuc2xpY2UodG9rUG9zLCB0b2tQb3MgKyAzKSk7XG4gICAgICAgIGlmIChvY3RhbCkgb2N0YWwgPSBvY3RhbFswXTtcbiAgICAgICAgd2hpbGUgKG9jdGFsICYmIHBhcnNlSW50KG9jdGFsLCA4KSA+IDI1NSkgb2N0YWwgPSBvY3RhbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChvY3RhbCA9PT0gXCIwXCIpIG9jdGFsID0gbnVsbDtcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgIGlmIChvY3RhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QpIHJhaXNlKHRva1BvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChvY3RhbCwgOCkpO1xuICAgICAgICAgIHRva1BvcyArPSBvY3RhbC5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlIDExMDogb3V0ICs9IFwiXFxuXCI7IGJyZWFrOyAvLyAnbicgLT4gJ1xcbidcbiAgICAgICAgICBjYXNlIDExNDogb3V0ICs9IFwiXFxyXCI7IGJyZWFrOyAvLyAncicgLT4gJ1xccidcbiAgICAgICAgICBjYXNlIDEyMDogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocmVhZEhleENoYXIoMikpOyBicmVhazsgLy8gJ3gnXG4gICAgICAgICAgY2FzZSAxMTc6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDQpKTsgYnJlYWs7IC8vICd1J1xuICAgICAgICAgIGNhc2UgODU6IC8vICdVJ1xuICAgICAgICAgICAgY2ggPSByZWFkSGV4Q2hhcig4KTtcbiAgICAgICAgICAgIGlmIChjaCA8IDB4RkZGRiAmJiAoY2ggPCAweEQ4MDAgfHwgMHhEQkZGIDwgY2gpKSBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vIElmIGl0J3MgVVRGLTE2XG4gICAgICAgICAgICBlbHNlIHsgLy8gSWYgd2UgbmVlZCBVQ1MtMlxuICAgICAgICAgICAgICBjaCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY2g+PjEwKSsweGQ4MDApK1N0cmluZy5mcm9tQ2hhckNvZGUoKGNoJTB4NDAwKSsweGRjMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTY6IG91dCArPSBcIlxcdFwiOyBicmVhazsgLy8gJ3QnIC0+ICdcXHQnXG4gICAgICAgICAgY2FzZSA5ODogb3V0ICs9IFwiXFxiXCI7IGJyZWFrOyAvLyAnYicgLT4gJ1xcYidcbiAgICAgICAgICBjYXNlIDExODogb3V0ICs9IFwiXFx1MDAwYlwiOyBicmVhazsgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICAgICAgICAgIGNhc2UgMTAyOiBvdXQgKz0gXCJcXGZcIjsgYnJlYWs7IC8vICdmJyAtPiAnXFxmJ1xuICAgICAgICAgIGNhc2UgNDg6IG91dCArPSBcIlxcMFwiOyBicmVhazsgLy8gMCAtPiAnXFwwJ1xuICAgICAgICAgIGNhc2UgMTM6IGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDEwKSArK3Rva1BvczsgLy8gJ1xcclxcbidcbiAgICAgICAgICBjYXNlIDEwOiAvLyAnIFxcbidcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykgeyB0b2tMaW5lU3RhcnQgPSB0b2tQb3M7ICsrdG9rQ3VyTGluZTsgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDogb3V0ICs9ICdcXFxcJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpOyBicmVhazsgLy8gUHl0aG9uIGRvZXNuJ3QgcmVtb3ZlIHNsYXNoZXMgb24gZmFpbGVkIGVzY2FwZXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld2xpbmUoY2gpKSB7XG4gICAgICAgICAgaWYgKHRyaXBsZVF1b3RlZCkge1xuICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIGlucHV0LmNoYXJDb2RlQXQodG9rUG9zKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb24pIHsgdG9rTGluZVN0YXJ0ID0gdG9rUG9zOyArK3Rva0N1ckxpbmU7IH1cbiAgICAgICAgICB9IGVsc2UgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vICdcXCdcbiAgICAgICAgICArK3Rva1BvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbiAgZnVuY3Rpb24gcmVhZEhleENoYXIobGVuKSB7XG4gICAgdmFyIG4gPSByZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSByYWlzZSh0b2tTdGFydCwgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuXG4gIHZhciBjb250YWluc0VzYztcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYGNvbnRhaW5zRXNjYFxuICAvLyB0byB3aGV0aGVyIHRoZSB3b3JkIGNvbnRhaW5lZCBhICdcXHUnIGVzY2FwZS5cbiAgLy9cbiAgLy8gT25seSBidWlsZHMgdXAgdGhlIHdvcmQgY2hhcmFjdGVyLWJ5LWNoYXJhY3RlciB3aGVuIGl0IGFjdHVhbGx5XG4gIC8vIGNvbnRhaW5lZHMgYW4gZXNjYXBlLCBhcyBhIG1pY3JvLW9wdGltaXphdGlvbi5cblxuICBmdW5jdGlvbiByZWFkV29yZDEoKSB7XG4gICAgY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCwgZmlyc3QgPSB0cnVlLCBzdGFydCA9IHRva1BvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zRXNjKSB3b3JkICs9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuICAgICAgICArK3Rva1BvcztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgICBpZiAoIWNvbnRhaW5zRXNjKSB3b3JkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gICAgICAgIGNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpICE9IDExNykgLy8gXCJ1XCJcbiAgICAgICAgICByYWlzZSh0b2tQb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTtcbiAgICAgICAgKyt0b2tQb3M7XG4gICAgICAgIHZhciBlc2MgPSByZWFkSGV4Q2hhcig0KTtcbiAgICAgICAgdmFyIGVzY1N0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjKTtcbiAgICAgICAgaWYgKCFlc2NTdHIpIHJhaXNlKHRva1BvcyAtIDEsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydChlc2MpIDogaXNJZGVudGlmaWVyQ2hhcihlc2MpKSlcbiAgICAgICAgICByYWlzZSh0b2tQb3MgLSA0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7XG4gICAgICAgIHdvcmQgKz0gZXNjU3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbnNFc2MgPyB3b3JkIDogaW5wdXQuc2xpY2Uoc3RhcnQsIHRva1Bvcyk7XG4gIH1cblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbiAgLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbiAgZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG4gICAgdmFyIHdvcmQgPSByZWFkV29yZDEoKTtcbiAgICB2YXIgdHlwZSA9IF9uYW1lO1xuICAgIGlmICghY29udGFpbnNFc2MgJiYgaXNLZXl3b3JkKHdvcmQpKVxuICAgICAgdHlwZSA9IGtleXdvcmRUeXBlc1t3b3JkXTtcbiAgICByZXR1cm4gZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gIH1cblxuICAvLyAjIyBQYXJzZXJcblxuICAvLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuICAvLyBzeW50YWN0aWMgZWxlbWVudHMsIGFuZCByZWN1cnNpdmVseSBjYWxsaW5nIHRob3NlLCBlYWNoIGZ1bmN0aW9uXG4gIC8vIGFkdmFuY2luZyB0aGUgaW5wdXQgc3RyZWFtIGFuZCByZXR1cm5pbmcgYW4gQVNUIG5vZGUuIFByZWNlZGVuY2VcbiAgLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbiAgLy8gaW5zdGVhZCBvZiBgKCF4KVsxXWAgaXMgaGFuZGxlZCBieSB0aGUgZmFjdCB0aGF0IHRoZSBwYXJzZXJcbiAgLy8gZnVuY3Rpb24gdGhhdCBwYXJzZXMgdW5hcnkgcHJlZml4IG9wZXJhdG9ycyBpcyBjYWxsZWQgZmlyc3QsIGFuZFxuICAvLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMgLSB0aGF0XG4gIC8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbiAgLy8gKnRoYXQqIGluIHRoZSB1bmFyeSBvcGVyYXRvciBub2RlLlxuICAvL1xuICAvLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4gIC8vIG9wZXJhdG9yIHByZWNlZGVuY2UsIGJlY2F1c2UgaXQgaXMgbXVjaCBtb3JlIGNvbXBhY3QgdGhhbiB1c2luZ1xuICAvLyB0aGUgdGVjaG5pcXVlIG91dGxpbmVkIGFib3ZlLCB3aGljaCB1c2VzIGRpZmZlcmVudCwgbmVzdGluZ1xuICAvLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4gIC8vIHByZWNlZGVuY2UgbGV2ZWxzIHRoYXQgSmF2YVNjcmlwdCBkZWZpbmVzLlxuICAvL1xuICAvLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG4gIC8vICMjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdG9rZW4uXG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBsYXN0U3RhcnQgPSB0b2tTdGFydDtcbiAgICBsYXN0RW5kID0gdG9rRW5kO1xuICAgIGxhc3RFbmRMb2MgPSB0b2tFbmRMb2M7XG4gICAgcmVhZFRva2VuKCk7XG4gIH1cblxuICAvLyBFbnRlciBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgdG9rZW4gdG8gcGxlYXNlIHBlZGFudGljXG4gIC8vIHRlc3RzIChcInVzZSBzdHJpY3RcIjsgMDEwOyAtLSBzaG91bGQgZmFpbCkuXG5cbiAgZnVuY3Rpb24gc2V0U3RyaWN0KHN0cmN0KSB7XG4gICAgc3RyaWN0ID0gc3RyY3Q7XG4gICAgdG9rUG9zID0gdG9rU3RhcnQ7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB3aGlsZSAodG9rUG9zIDwgdG9rTGluZVN0YXJ0KSB7XG4gICAgICAgIHRva0xpbmVTdGFydCA9IGlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRva0xpbmVTdGFydCAtIDIpICsgMTtcbiAgICAgICAgLS10b2tDdXJMaW5lO1xuICAgICAgfVxuICAgIH1cbiAgICBza2lwU3BhY2UoKTtcbiAgICByZWFkVG9rZW4oKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICB9XG5cbiAgZXhwb3J0cy5Ob2RlID0gTm9kZTtcblxuICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbigpIHtcbiAgICB0aGlzLnN0YXJ0ID0gdG9rU3RhcnRMb2M7XG4gICAgdGhpcy5lbmQgPSBudWxsO1xuICAgIGlmIChzb3VyY2VGaWxlICE9PSBudWxsKSB0aGlzLnNvdXJjZSA9IHNvdXJjZUZpbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydE5vZGUoKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIG5vZGUubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICAgIG5vZGUuc291cmNlRmlsZSA9IG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcbiAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICBub2RlLnJhbmdlID0gW3Rva1N0YXJ0LCAwXTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIG5vZGUubG9jLmVuZCA9IGxhc3RFbmRMb2M7XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgbm9kZS5yYW5nZVsxXSA9IGxhc3RFbmQ7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBTdGFydCBhIG5vZGUgd2hvc2Ugc3RhcnQgb2Zmc2V0IGluZm9ybWF0aW9uIHNob3VsZCBiZSBiYXNlZCBvblxuICAvLyB0aGUgc3RhcnQgb2YgYW5vdGhlciBub2RlLiBGb3IgZXhhbXBsZSwgYSBiaW5hcnkgb3BlcmF0b3Igbm9kZSBpc1xuICAvLyBvbmx5IHN0YXJ0ZWQgYWZ0ZXIgaXRzIGxlZnQtaGFuZCBzaWRlIGhhcyBhbHJlYWR5IGJlZW4gcGFyc2VkLlxuXG4gIGZ1bmN0aW9uIHN0YXJ0Tm9kZUZyb20ob3RoZXIpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICBub2RlLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgbm9kZS5sb2Muc3RhcnQgPSBvdGhlci5sb2Muc3RhcnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIG5vZGUucmFuZ2UgPSBbb3RoZXIucmFuZ2VbMF0sIDBdO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyAjIyBOb2RlIGNyZWF0aW9uIHV0aWxpdGllc1xuXG4gIHZhciBnZXROb2RlQ3JlYXRvciA9IGV4cG9ydHMuZ2V0Tm9kZUNyZWF0b3IgPSBmdW5jdGlvbihzdGFydE5vZGUsIHN0YXJ0Tm9kZUZyb20sIGZpbmlzaE5vZGUsIHVucGFja1R1cGxlKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvLyBGaW5pc2ggYSBub2RlIHdob3NlIGVuZCBvZmZzZXQgaW5mb3JtYXRpb24gc2hvdWxkIGJlIGJhc2VkIG9uXG4gICAgICAvLyB0aGUgZW5kIG9mIGFub3RoZXIgbm9kZS4gIEZvciBleGFtcGxlLCBjcmVhdGVOb2RlKiBmdW5jdGlvbnNcbiAgICAgIC8vIGFyZSB1c2VkIHRvIGNyZWF0ZSBleHRyYSBBU1Qgbm9kZXMgd2hpY2ggbWF5IGJlIGJhc2VkIG9uIGEgc2luZ2xlXG4gICAgICAvLyBwYXJzZWQgdXNlciBjb2RlIG5vZGUuXG5cbiAgICAgIGZpbmlzaE5vZGVGcm9tOiBmdW5jdGlvbiAoZW5kTm9kZSwgbm9kZSwgdHlwZSkge1xuICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIG5vZGUubG9jLmVuZCA9IGVuZE5vZGUubG9jLmVuZDtcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlWzFdID0gZW5kTm9kZS5yYW5nZVsxXTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LFxuXG4gICAgICAvLyBDcmVhdGUgYW4gQVNUIG5vZGUgdXNpbmcgc3RhcnQgb2Zmc2V0c1xuXG4gICAgICBjcmVhdGVOb2RlRnJvbTogZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKHN0YXJ0Tm9kZSk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIG5vZGVbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBDcmVhdGUgYW4gQVNUIG5vZGUgdXNpbmcgc3RhcnQgYW5kIGVuZCBvZmZzZXRzXG5cbiAgICAgIGNyZWF0ZU5vZGVTcGFuOiBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCB0eXBlLCBwcm9wcykge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oc3RhcnROb2RlKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykgbm9kZVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlRnJvbShlbmROb2RlLCBub2RlLCB0eXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuOiBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCB0eXBlLCBwcm9wcykge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oc3RhcnROb2RlKTtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykgbm9kZVtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICBub2RlLnVzZXJDb2RlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVGcm9tKGVuZE5vZGUsIG5vZGUsIHR5cGUpO1xuICAgICAgfSxcblxuICAgICAgLy8gd2hpbGUgKF9fZm9ybWFsc0luZGV4IDwgX19wYXJhbXMuZm9ybWFscy5sZW5ndGgpIHtcbiAgICAgIC8vICAgPGFyZ3NJZD4ucHVzaChfX3BhcmFtcy5mb3JtYWxzW19fZm9ybWFsc0luZGV4KytdKTsgfVxuICAgICAgY3JlYXRlTm9kZUFyZ3NXaGlsZUNvbnNlcXVlbnQ6IGZ1bmN0aW9uIChhcmdzSWQsIHMpIHtcbiAgICAgICAgdmFyIF9fcmVhbEFyZ0NvdW50SWQgID0gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogICdfX3JlYWxBcmdDb3VudCcgKyBzIH0pO1xuICAgICAgICB2YXIgX19wYXJhbXNGb3JtYWxzICA9IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYXJnc0lkLCBhcmdzSWQsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6ICAnYXJndW1lbnRzJyB9KTtcbiAgICAgICAgdmFyIF9fZm9ybWFsc0luZGV4SWQgPSB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiAnX19mb3JtYWxzSW5kZXgnICsgcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYXJnc0lkLCBhcmdzSWQsIFwiV2hpbGVTdGF0ZW1lbnRcIiwge1xuICAgICAgICAgIHRlc3Q6IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYXJnc0lkLCBhcmdzSWQsIFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogJzwnLCBsZWZ0OiBfX2Zvcm1hbHNJbmRleElkLFxuICAgICAgICAgICAgcmlnaHQ6IF9fcmVhbEFyZ0NvdW50SWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBib2R5OiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgICAgICAgICAgIGJvZHk6IFt0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwge1xuICAgICAgICAgICAgICBleHByZXNzaW9uOiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICBjYWxsZWU6IHRoaXMuY3JlYXRlTm9kZU1lbWJJZHMoYXJnc0lkLCBhcmdzSWQubmFtZSwgJ3B1c2gnKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsIG9iamVjdDogX19wYXJhbXNGb3JtYWxzLFxuICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYXJnc0lkLCBhcmdzSWQsIFwiVXBkYXRlRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnKysnLCBwcmVmaXg6IGZhbHNlLCBhcmd1bWVudDogX19mb3JtYWxzSW5kZXhJZFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgLy8geyB3aGlsZSAoX19mb3JtYWxzSW5kZXggPCBfX2FyZ3MubGVuZ3RoKSB7XG4gICAgICAvLyAgIDxhcmdzSWQ+LnB1c2goX19hcmdzW19fZm9ybWFsc0luZGV4KytdKTsgfX1cbiAgICAgIGNyZWF0ZU5vZGVBcmdzQWx0ZXJuYXRlOiBmdW5jdGlvbiAoYXJnc0lkLCBzKSB7XG4gICAgICAgIHZhciBfX2FyZ3MgPSAnX19hcmdzJyArIHM7XG4gICAgICAgIHZhciBfX2Zvcm1hbHNJbmRleElkID0gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogJ19fZm9ybWFsc0luZGV4JyArIHMgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgICAgICAgICBib2R5OiBbdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJXaGlsZVN0YXRlbWVudFwiLCB7XG4gICAgICAgICAgICB0ZXN0OiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICAgICAgICAgICAgICBvcGVyYXRvcjogJzwnLCBsZWZ0OiBfX2Zvcm1hbHNJbmRleElkLFxuICAgICAgICAgICAgICByaWdodDogdGhpcy5jcmVhdGVOb2RlTWVtYklkcyhhcmdzSWQsIF9fYXJncywgJ2xlbmd0aCcpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJvZHk6IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYXJnc0lkLCBhcmdzSWQsIFwiQmxvY2tTdGF0ZW1lbnRcIiwge1xuICAgICAgICAgICAgICBib2R5OiBbdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxlZTogdGhpcy5jcmVhdGVOb2RlTWVtYklkcyhhcmdzSWQsIGFyZ3NJZC5uYW1lLCAncHVzaCcpLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogX19hcmdzIH0pLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3BhbihhcmdzSWQsIGFyZ3NJZCwgXCJVcGRhdGVFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJysrJywgcHJlZml4OiBmYWxzZSwgYXJndW1lbnQ6IF9fZm9ybWFsc0luZGV4SWRcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyByZXR1cm4gKGZ1bmN0aW9uKCkgezxib2R5Pn0pLmNhbGwodGhpcyk7XG4gICAgICBjcmVhdGVOb2RlRm5Cb2R5SWlmZTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgdmFyIGlpZmVCb2R5ID0gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3Bhbihib2R5LCBib2R5LCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgcGFyYW1zOiBbXSwgZGVmYXVsdHM6IFtdLCBib2R5OiBib2R5LCBnZW5lcmF0b3I6IGZhbHNlLCBleHByZXNzaW9uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlpZmVDYWxsID0gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3Bhbihib2R5LCBib2R5LCBcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICBjYWxsZWU6IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYm9keSwgYm9keSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSwgb2JqZWN0OiBpaWZlQm9keSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGJvZHksIGJvZHksIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6ICdjYWxsJyB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGFyZ3VtZW50czogW3RoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4oYm9keSwgYm9keSwgXCJUaGlzRXhwcmVzc2lvblwiKV1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKGJvZHksIGJvZHksIFwiUmV0dXJuU3RhdGVtZW50XCIsIHsgYXJndW1lbnQ6IGlpZmVDYWxsIH0pO1xuICAgICAgfSxcblxuICAgICAgLy8gRS5nLiBNYXRoLnBvdygyLCAzKVxuXG4gICAgICBjcmVhdGVOb2RlTWVtYmVyQ2FsbDogZnVuY3Rpb24gKG5vZGUsIG9iamVjdCwgcHJvcGVydHksIGFyZ3MpIHtcbiAgICAgICAgdmFyIG9iaklkID0gdGhpcy5jcmVhdGVOb2RlRnJvbShub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBvYmplY3QgfSk7XG4gICAgICAgIHZhciBwcm9wSWQgPSB0aGlzLmNyZWF0ZU5vZGVGcm9tKG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IHByb3BlcnR5IH0pO1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5jcmVhdGVOb2RlRnJvbShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IG9iaklkLCBwcm9wZXJ0eTogcHJvcElkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgICAgIG5vZGUuY2FsbGVlID0gbWVtYmVyO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgICB9LFxuXG4gICAgICAvLyBvLnBcbiAgICAgIGNyZWF0ZU5vZGVNZW1iSWRzOiBmdW5jdGlvbihyLCBvLCBwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5vZGVTcGFuKHIsIHIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBvIH0pLFxuICAgICAgICAgIHByb3BlcnR5OiB0aGlzLmNyZWF0ZU5vZGVTcGFuKHIsIHIsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IHAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sXG5cbiAgICAgIC8vIG9bcF1cbiAgICAgIGNyZWF0ZU5vZGVNZW1iSWRMaXQ6IGZ1bmN0aW9uKHIsIG8sIHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogbyB9KSxcbiAgICAgICAgICBwcm9wZXJ0eTogdGhpcy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkxpdGVyYWxcIiwgeyB2YWx1ZTogcCB9KVxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgLy8gRS5nLiBweVJ1bnRpbWUub3BzLmFkZFxuXG4gICAgICBjcmVhdGVOb2RlT3BzQ2FsbGVlOiBmdW5jdGlvbiAobm9kZSwgZm5OYW1lKSB7XG4gICAgICAgIHZhciBydW50aW1lSWQgPSB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IG9wdGlvbnMucnVudGltZVBhcmFtTmFtZSB9KTtcbiAgICAgICAgdmFyIG9wc0lkID0gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIm9wc1wiIH0pO1xuICAgICAgICB2YXIgYWRkSWQgPSB0aGlzLmNyZWF0ZUdlbmVyYXRlZE5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IGZuTmFtZSB9KTtcbiAgICAgICAgdmFyIG9wc01lbWJlciA9IHRoaXMuY3JlYXRlR2VuZXJhdGVkTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lSWQsIHByb3BlcnR5OiBvcHNJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW5lcmF0ZWROb2RlU3Bhbihub2RlLCBub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IG9wc01lbWJlciwgcHJvcGVydHk6IGFkZElkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBFLmcuIHB5UnVudGltZS51dGlscy5hZGRcblxuICAgICAgY3JlYXRlTm9kZVJ1bnRpbWVDYWxsOiBmdW5jdGlvbiAociwgbW9kLCBmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICBjYWxsZWU6IHRoaXMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIG9iamVjdDogdGhpcy5jcmVhdGVOb2RlTWVtYklkcyhyLCBvcHRpb25zLnJ1bnRpbWVQYXJhbU5hbWUsICBtb2QpLFxuICAgICAgICAgICAgcHJvcGVydHk6IHRoaXMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogZm4gfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBVc2VkIHRvIGNvbnZlcnQgJ2lkID0gaW5pdCcgdG8gJ3ZhciBpZCA9IGluaXQnXG5cbiAgICAgIGNyZWF0ZVZhckRlY2xGcm9tSWQ6IGZ1bmN0aW9uIChyZWZOb2RlLCBpZCwgaW5pdCkge1xuICAgICAgICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZUZyb20ocmVmTm9kZSk7XG4gICAgICAgIGRlY2wuaWQgPSBpZDtcbiAgICAgICAgZGVjbC5pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlRnJvbShyZWZOb2RlLCBkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKTtcbiAgICAgICAgdmFyIGRlY2xEZWNsID0gc3RhcnROb2RlRnJvbShyZWZOb2RlKTtcbiAgICAgICAgZGVjbERlY2wua2luZCA9IFwidmFyXCI7XG4gICAgICAgIGRlY2xEZWNsLmRlY2xhcmF0aW9ucyA9IFtkZWNsXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUZyb20ocmVmTm9kZSwgZGVjbERlY2wsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUdlbmVyYXRlZFZhckRlY2xGcm9tSWQ6IGZ1bmN0aW9uIChyZWZOb2RlLCBpZCwgaW5pdCkge1xuICAgICAgICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZUZyb20ocmVmTm9kZSk7XG4gICAgICAgIGRlY2wuaWQgPSBpZDtcbiAgICAgICAgZGVjbC5pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlRnJvbShyZWZOb2RlLCBkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKTtcbiAgICAgICAgdmFyIGRlY2xEZWNsID0gc3RhcnROb2RlRnJvbShyZWZOb2RlKTtcbiAgICAgICAgZGVjbERlY2wua2luZCA9IFwidmFyXCI7XG4gICAgICAgIGRlY2xEZWNsLmRlY2xhcmF0aW9ucyA9IFtkZWNsXTtcbiAgICAgICAgZGVjbERlY2wudXNlckNvZGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUZyb20ocmVmTm9kZSwgZGVjbERlY2wsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgIH0sXG5cbiAgICAgIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbihjb250YWluZXIsIGN0b3JOb2RlLCBjbGFzc1BhcmFtcywgY2xhc3NCb2R5UmVmTm9kZSwgY2xhc3NCbG9jaykge1xuICAgICAgICAvLyBIZWxwZXIgdG8gaWRlbnRpZnkgY2xhc3MgbWV0aG9kcyB3aGljaCB3ZXJlIHBhcnNlZCBvbnRvIHRoZSBjbGFzcyBwcm90b3R5cGVcblxuICAgICAgICBmdW5jdGlvbiBnZXRQcm90b3R5cGUoc3RtdCkge1xuICAgICAgICAgIGlmIChzdG10LmV4cHJlc3Npb24gJiYgc3RtdC5leHByZXNzaW9uLmxlZnQgJiYgc3RtdC5leHByZXNzaW9uLmxlZnQub2JqZWN0ICYmXG4gICAgICAgICAgICBzdG10LmV4cHJlc3Npb24ubGVmdC5vYmplY3QucHJvcGVydHkgJiYgc3RtdC5leHByZXNzaW9uLmxlZnQub2JqZWN0LnByb3BlcnR5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RtdC5leHByZXNzaW9uLmxlZnQucHJvcGVydHkubmFtZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IGJ1aWxkaW5nIGNsYXNzIGNvbnN0cnVjdG9yXG5cbiAgICAgICAgdmFyIGN0b3JCbG9jayA9IHN0YXJ0Tm9kZUZyb20oY2xhc3NCbG9jayk7XG4gICAgICAgIGN0b3JCbG9jay5ib2R5ID0gW107XG5cbiAgICAgICAgLy8gQWRkIHBhcmVudCBjbGFzcyBjb25zdHJ1Y3RvciBjYWxsXG5cbiAgICAgICAgaWYgKGNsYXNzUGFyYW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciBvYmpJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY2xhc3NCb2R5UmVmTm9kZSwgY2xhc3NCb2R5UmVmTm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogY2xhc3NQYXJhbXNbMF0ubmFtZSB9KTtcbiAgICAgICAgICB2YXIgcHJvcGVydHlJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY2xhc3NCb2R5UmVmTm9kZSwgY2xhc3NCb2R5UmVmTm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJjYWxsXCIgfSk7XG4gICAgICAgICAgdmFyIGNhbGxlZU1lbWJlciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY2xhc3NCb2R5UmVmTm9kZSwgY2xhc3NCb2R5UmVmTm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBvYmpJZCwgcHJvcGVydHk6IHByb3BlcnR5SWQsIGNvbXB1dGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICB2YXIgdGhpc0V4cHIgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGNsYXNzQm9keVJlZk5vZGUsIGNsYXNzQm9keVJlZk5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgICAgICAgdmFyIGNhbGxFeHByID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjbGFzc0JvZHlSZWZOb2RlLCBjbGFzc0JvZHlSZWZOb2RlLCBcIkNhbGxFeHByZXNzaW9uXCIsIHsgY2FsbGVlOiBjYWxsZWVNZW1iZXIsIGFyZ3VtZW50czogW3RoaXNFeHByXSB9KTtcbiAgICAgICAgICB2YXIgc3VwZXJFeHByID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjbGFzc0JvZHlSZWZOb2RlLCBjbGFzc0JvZHlSZWZOb2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgeyBleHByZXNzaW9uOiBjYWxsRXhwciB9KTtcbiAgICAgICAgICBjdG9yQmxvY2suYm9keS5wdXNoKHN1cGVyRXhwcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbm9uLWZ1bmN0aW9uIHN0YXRlbWVudHMgYW5kIGNvbnRlbnRzIG9mIHNwZWNpYWwgJ19faW5pdF9fJyBtZXRob2RcblxuICAgICAgICBmb3IgKHZhciBpIGluIGNsYXNzQmxvY2suYm9keSkge1xuICAgICAgICAgIHZhciBzdG10ID0gY2xhc3NCbG9jay5ib2R5W2ldO1xuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGUoc3RtdCk7XG4gICAgICAgICAgaWYgKCFwcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGN0b3JCbG9jay5ib2R5LnB1c2goc3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHByb3RvdHlwZSA9PT0gXCJfX2luaXRfX1wiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIHN0bXQuZXhwcmVzc2lvbi5yaWdodC5ib2R5LmJvZHkpXG4gICAgICAgICAgICAgIGN0b3JCbG9jay5ib2R5LnB1c2goc3RtdC5leHByZXNzaW9uLnJpZ2h0LmJvZHkuYm9keVtqXSk7XG4gICAgICAgICAgICBjdG9yTm9kZS5wYXJhbXMgPSBzdG10LmV4cHJlc3Npb24ucmlnaHQucGFyYW1zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmlzaCBjbGFzcyBjb25zdHJ1Y3RvclxuXG4gICAgICAgIGN0b3JOb2RlLmJvZHkgPSBmaW5pc2hOb2RlKGN0b3JCbG9jaywgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICAgICAgZmluaXNoTm9kZShjdG9yTm9kZSwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpO1xuICAgICAgICBjb250YWluZXIuYm9keS5wdXNoKGN0b3JOb2RlKTtcblxuICAgICAgICAvLyBBZGQgaW5oZXJpdGFuY2UgdmlhICdNeUNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50Q2xhc3MucHJvdG90eXBlKSdcblxuICAgICAgICBpZiAoY2xhc3NQYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFyIGNoaWxkQ2xhc3NJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY3Rvck5vZGUsIGN0b3JOb2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBjdG9yTm9kZS5pZC5uYW1lIH0pO1xuICAgICAgICAgIHZhciBjaGlsZFByb3RvdHlwZUlkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwicHJvdG90eXBlXCIgfSk7XG4gICAgICAgICAgdmFyIGNoaWxkUHJvdG90eXBlTWVtYmVyID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogY2hpbGRDbGFzc0lkLCBwcm9wZXJ0eTogY2hpbGRQcm90b3R5cGVJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgIHZhciBwYXJlbnRDbGFzc0lkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IGNsYXNzUGFyYW1zWzBdLm5hbWUgfSk7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3RvdHlwZUlkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwicHJvdG90eXBlXCIgfSk7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3RvdHlwZU1lbWJlciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY3Rvck5vZGUsIGN0b3JOb2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IHBhcmVudENsYXNzSWQsIHByb3BlcnR5OiBwYXJlbnRQcm90b3R5cGVJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgIHZhciBvYmpDbGFzc0lkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwiT2JqZWN0XCIgfSk7XG4gICAgICAgICAgdmFyIG9iakNyZWF0ZUlkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwiY3JlYXRlXCIgfSk7XG4gICAgICAgICAgdmFyIG9ialByb3BlcnR5TWVtYmVyID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogb2JqQ2xhc3NJZCwgcHJvcGVydHk6IG9iakNyZWF0ZUlkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgICAgICAgdmFyIGNhbGxFeHByID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIiwgeyBjYWxsZWU6IG9ialByb3BlcnR5TWVtYmVyLCBhcmd1bWVudHM6IFtwYXJlbnRQcm90b3R5cGVNZW1iZXJdIH0pO1xuICAgICAgICAgIHZhciBhc3NpZ25FeHByID0gdGhpcy5jcmVhdGVOb2RlU3BhbihjdG9yTm9kZSwgY3Rvck5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgeyBsZWZ0OiBjaGlsZFByb3RvdHlwZU1lbWJlciwgb3BlcmF0b3I6IFwiPVwiLCByaWdodDogY2FsbEV4cHIgfSk7XG4gICAgICAgICAgdmFyIGluaGVyaXRhbmNlRXhwciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oY3Rvck5vZGUsIGN0b3JOb2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgeyBleHByZXNzaW9uOiBhc3NpZ25FeHByIH0pO1xuICAgICAgICAgIGNvbnRhaW5lci5ib2R5LnB1c2goaW5oZXJpdGFuY2VFeHByKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjbGFzcyBtZXRob2RzLCB3aGljaCBhcmUgYWxyZWFkeSBwcm90b3R5cGUgYXNzaWdubWVudHNcblxuICAgICAgICBmb3IgKHZhciBpIGluIGNsYXNzQmxvY2suYm9keSkge1xuICAgICAgICAgIHZhciBzdG10ID0gY2xhc3NCbG9jay5ib2R5W2ldO1xuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGUoc3RtdCk7XG4gICAgICAgICAgaWYgKHByb3RvdHlwZSAmJiBwcm90b3R5cGUgIT09IFwiX19pbml0X19cIilcbiAgICAgICAgICAgIGNvbnRhaW5lci5ib2R5LnB1c2goc3RtdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShjb250YWluZXIsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgICB9LFxuXG4gICAgICAvLyBDcmVhdGUgZm9yIGxvb3BcbiAgICAgIC8vIFxuICAgICAgLy8gUHJvYmxlbTpcbiAgICAgIC8vIDEuIEphdmFTY3JpcHQgZm9yL2luIGxvb3AgaXRlcmF0ZXMgb24gcHJvcGVydGllcywgd2hpY2ggYXJlIHRoZSBpbmRleGVzIGZvciBhbiBBcnJheVxuICAgICAgLy8gICAgUHl0aG9uIGl0ZXJhdGVzIG9uIHRoZSBsaXN0IGl0ZW1zIHRoZW1zZWx2ZXMsIG5vdCBpbmRleGVzXG4gICAgICAvLyAyLiBKYXZhU2NyaXB0IGZvci9pbiBkb2VzIG5vdCBuZWNlc3NhcmlseSBpdGVyYXRlIGluIG9yZGVyXG4gICAgICAvLyBTb2x1dGlvbjpcbiAgICAgIC8vIEdlbmVyYXRlIGV4dHJhIEFTVCB0byBkbyB0aGUgcmlnaHQgdGhpbmcgYXQgcnVudGltZVxuICAgICAgLy8gSmF2YVNjcmlwdCBmb3IvaW4gaXMgdXNlZCBmb3IgZGljdGlvbmFyaWVzXG4gICAgICAvLyBJZiBpdGVyYXRpbmcgdGhyb3VnaCBhbiBvcmRlcmVkIHNlcXVlbmNlLCByZXR1cm4gc29tZXRoaW5nIGxpa2U6IFxuICAgICAgLy8geyB2YXIgX19yaWdodCA9IHJpZ2h0OyBcbiAgICAgIC8vICAgIGlmIChfX3JpZ2h0IGluc3RhbmNlb2YgQXJyYXkpIHsgXG4gICAgICAvLyAgICAgIGZvcih2YXIgX19pbmRleD0wOyBfX2luZGV4IDwgX19yaWdodC5sZW5ndGg7IF9faW5kZXgrKykge1xuICAgICAgLy8gICAgICAgIGkgPSBfX3JpZ2h0W19faW5kZXhdOyBcbiAgICAgIC8vICAgICAgICAuLi5cbiAgICAgIC8vICAgICAgfSBcbiAgICAgIC8vICAgIH0gZWxzZSB7IFxuICAgICAgLy8gICAgICBmb3IoaSBpbiBfX3JpZ2h0KXsuLi59IFxuICAgICAgLy8gICAgfVxuICAgICAgLy8gfVxuICAgICAgLy8gV2hlbiB0aGUgbG9vcCB0YXJnZXQgaXMgYSBUdXBsZSwgaXQgaXMgdW5wYWNrZWQgaW50byBlYWNoIGZvciBib2R5IGluIHRoZSBleGFtcGxlIGFib3ZlLlxuICAgICAgLy8gRS5nLiAnZm9yIGssIHYgaW4gX19yaWdodDogdG90YWwgKz0gdicgYmVjb21lczpcbiAgICAgIC8vIGZvciAodmFyIF9fdG1wIGluIF9fcmlnaHQpIHtcbiAgICAgIC8vICAgIGsgPSBfX3RtcFswXTtcbiAgICAgIC8vICAgIHYgPSBfX3RtcFsxXTtcbiAgICAgIC8vICAgIHRvdGFsICs9IHY7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIFRPRE86IGZvci9pbiBvbiBhIHN0cmluZyBzaG91bGQgZ28gdGhyb3VnaCBpdGVtcywgbm90IGluZGV4ZXMuIFN0cmluZyBvYmogYW5kIHN0cmluZyBsaXRlcmFsLlxuXG4gICAgICBjcmVhdGVGb3I6IGZ1bmN0aW9uIChub2RlLCBpbml0LCB0dXBsZUFyZ3MsIHJpZ2h0LCBib2R5KSB7XG4gICAgICAgIHZhciBmb3JPcmRlcmVkQm9keSA9IGJvZHk7XG4gICAgICAgIHZhciBmb3JJbkJvZHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGZvck9yZGVyZWRCb2R5KSk7XG5cbiAgICAgICAgdmFyIHRtcFZhclN1ZmZpeCA9IG5ld0FzdElkQ291bnQrKztcblxuICAgICAgICB2YXIgYXJyYXlJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJBcnJheVwiIH0pO1xuICAgICAgICB2YXIgbGVuZ3RoSWQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGluaXQsIGluaXQsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwibGVuZ3RoXCIgfSk7XG4gICAgICAgIHZhciB6ZXJvTGl0ID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihpbml0LCBpbml0LCBcIkxpdGVyYWxcIiwgeyB2YWx1ZTogMCB9KTtcblxuICAgICAgICAvLyB2YXIgX19yaWdodE4gPSByaWdodFxuXG4gICAgICAgIHZhciByaWdodElkID0gdGhpcy5jcmVhdGVOb2RlU3BhbihyaWdodCwgcmlnaHQsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwiX19maWxiZXJ0UmlnaHRcIiArIHRtcFZhclN1ZmZpeCB9KTtcbiAgICAgICAgdmFyIHJpZ2h0QXNzaWduID0gdGhpcy5jcmVhdGVWYXJEZWNsRnJvbUlkKHJpZ2h0LCByaWdodElkLCByaWdodCk7XG5cbiAgICAgICAgLy8gZm9yKDs7KSBhbmQgZm9yKGluKSBsb29wc1xuXG4gICAgICAgIHZhciBmb3JSaWdodElkID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihpbml0LCBpbml0LCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIl9fZmlsYmVydFJpZ2h0XCIgKyB0bXBWYXJTdWZmaXggfSk7XG5cbiAgICAgICAgLy8gZm9yICh2YXIgX19pbmRleE47IF9faW5kZXhOIDwgX19yaWdodE4ubGVuZ3RoOyArK19faW5kZXhOKVxuXG4gICAgICAgIHZhciBmb3JPcmRlcmVkSW5kZXhJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oaW5pdCwgaW5pdCwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJfX2ZpbGJlcnRJbmRleFwiICsgdG1wVmFyU3VmZml4IH0pO1xuICAgICAgICB2YXIgZm9yT3JkZXJlZEluZGV4RGVjbHIgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGluaXQsIGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIHsgaWQ6IGZvck9yZGVyZWRJbmRleElkLCBpbml0OiB6ZXJvTGl0IH0pO1xuICAgICAgICB2YXIgZm9yT3JkZXJlZEluZGV4RGVjbG4gPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGluaXQsIGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCB7IGRlY2xhcmF0aW9uczogW2Zvck9yZGVyZWRJbmRleERlY2xyXSwga2luZDogXCJ2YXJcIiB9KTtcbiAgICAgICAgdmFyIGZvck9yZGVyZWRUZXN0TWVtYmVyID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihpbml0LCBpbml0LCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IGZvclJpZ2h0SWQsIHByb3BlcnR5OiBsZW5ndGhJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgZm9yT3JkZXJlZFRlc3RCaW5vcCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oaW5pdCwgaW5pdCwgXCJCaW5hcnlFeHByZXNzaW9uXCIsIHsgbGVmdDogZm9yT3JkZXJlZEluZGV4SWQsIG9wZXJhdG9yOiBcIjxcIiwgcmlnaHQ6IGZvck9yZGVyZWRUZXN0TWVtYmVyIH0pO1xuICAgICAgICB2YXIgZm9yT3JkZXJlZFVwZGF0ZSA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oaW5pdCwgaW5pdCwgXCJVcGRhdGVFeHByZXNzaW9uXCIsIHsgb3BlcmF0b3I6IFwiKytcIiwgcHJlZml4OiB0cnVlLCBhcmd1bWVudDogZm9yT3JkZXJlZEluZGV4SWQgfSk7XG4gICAgICAgIHZhciBmb3JPcmRlcmVkTWVtYmVyID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihpbml0LCBpbml0LCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IGZvclJpZ2h0SWQsIHByb3BlcnR5OiBmb3JPcmRlcmVkSW5kZXhJZCwgY29tcHV0ZWQ6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKHR1cGxlQXJncykge1xuICAgICAgICAgIHZhciB2YXJTdG10cyA9IHVucGFja1R1cGxlKHR1cGxlQXJncywgZm9yT3JkZXJlZE1lbWJlcik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHZhclN0bXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBmb3JPcmRlcmVkQm9keS5ib2R5LnVuc2hpZnQodmFyU3RtdHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChpbml0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFzY29wZS5leGlzdHMoaW5pdC5uYW1lKSkge1xuICAgICAgICAgICAgc2NvcGUuYWRkVmFyKGluaXQubmFtZSk7XG4gICAgICAgICAgICBmb3JPcmRlcmVkQm9keS5ib2R5LnVuc2hpZnQodGhpcy5jcmVhdGVWYXJEZWNsRnJvbUlkKGluaXQsIGluaXQsIGZvck9yZGVyZWRNZW1iZXIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvck9yZGVyZWRJbml0ID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihpbml0LCBpbml0LCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIHsgb3BlcmF0b3I6IFwiPVwiLCBsZWZ0OiBpbml0LCByaWdodDogZm9yT3JkZXJlZE1lbWJlciB9KTtcbiAgICAgICAgICAgIHZhciBmb3JPcmRlcmVkSW5pdFN0bXQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGluaXQsIGluaXQsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7IGV4cHJlc3Npb246IGZvck9yZGVyZWRJbml0IH0pO1xuICAgICAgICAgICAgZm9yT3JkZXJlZEJvZHkuYm9keS51bnNoaWZ0KGZvck9yZGVyZWRJbml0U3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvck9yZGVyZWQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiRm9yU3RhdGVtZW50XCIsIHsgaW5pdDogZm9yT3JkZXJlZEluZGV4RGVjbG4sIHRlc3Q6IGZvck9yZGVyZWRUZXN0Qmlub3AsIHVwZGF0ZTogZm9yT3JkZXJlZFVwZGF0ZSwgYm9keTogZm9yT3JkZXJlZEJvZHkgfSk7XG4gICAgICAgIHZhciBmb3JPcmRlcmVkQmxvY2sgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIiwgeyBib2R5OiBbZm9yT3JkZXJlZF0gfSk7XG5cbiAgICAgICAgLy8gZm9yIChpbml0IGluIF9fcmlnaHROKVxuXG4gICAgICAgIHZhciBmb3JJbkxlZnQgPSBpbml0O1xuICAgICAgICBpZiAodHVwbGVBcmdzKSB7XG4gICAgICAgICAgdmFyIHZhclN0bXRzID0gdW5wYWNrVHVwbGUodHVwbGVBcmdzLCByaWdodCk7XG4gICAgICAgICAgZm9ySW5MZWZ0ID0gdmFyU3RtdHNbMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHZhclN0bXRzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGZvckluQm9keS5ib2R5LnVuc2hpZnQodmFyU3RtdHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIXNjb3BlLmV4aXN0cyhpbml0Lm5hbWUpKSB7XG4gICAgICAgICAgc2NvcGUuYWRkVmFyKGluaXQubmFtZSk7XG4gICAgICAgICAgZm9ySW5MZWZ0ID0gdGhpcy5jcmVhdGVWYXJEZWNsRnJvbUlkKGluaXQsIGluaXQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JJbiA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJGb3JJblN0YXRlbWVudFwiLCB7IGxlZnQ6IGZvckluTGVmdCwgcmlnaHQ6IGZvclJpZ2h0SWQsIGJvZHk6IGZvckluQm9keSB9KTtcbiAgICAgICAgdmFyIGZvckluQmxvY2sgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIiwgeyBib2R5OiBbZm9ySW5dIH0pO1xuXG4gICAgICAgIC8vIGlmIG9yZGVyZWQgc2VxdWVuY2UgdGhlbiBmb3JPcmRlcmVkIGVsc2UgZm9ySW5cblxuICAgICAgICB2YXIgaWZSaWdodElkID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIl9fZmlsYmVydFJpZ2h0XCIgKyB0bXBWYXJTdWZmaXggfSk7XG4gICAgICAgIHZhciBpZlRlc3QgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7IGxlZnQ6IGlmUmlnaHRJZCwgb3BlcmF0b3I6IFwiaW5zdGFuY2VvZlwiLCByaWdodDogYXJyYXlJZCB9KTtcbiAgICAgICAgdmFyIGlmU3RtdCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZlN0YXRlbWVudFwiLCB7IHRlc3Q6IGlmVGVzdCwgY29uc2VxdWVudDogZm9yT3JkZXJlZEJsb2NrLCBhbHRlcm5hdGU6IGZvckluQmxvY2sgfSk7XG5cbiAgICAgICAgbm9kZS5ib2R5ID0gW3JpZ2h0QXNzaWduLCBpZlN0bXRdO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcblxuICAgICAgLy8gZXhwciA9PiBfX3RtcExpc3QucHVzaChleHByKTtcblxuICAgICAgY3JlYXRlTGlzdENvbXBQdXNoOiBmdW5jdGlvbiAoZXhwciwgdG1wVmFyU3VmZml4KSB7XG4gICAgICAgIHZhciBleHByUHVzaFRtcExpc3RJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oZXhwciwgZXhwciwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJfX3RtcExpc3RcIiArIHRtcFZhclN1ZmZpeCB9KTtcbiAgICAgICAgdmFyIGV4cHJQdXNoSWQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKGV4cHIsIGV4cHIsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwicHVzaFwiIH0pO1xuICAgICAgICB2YXIgZXhwck1lbWJlciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4oZXhwciwgZXhwciwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBleHByUHVzaFRtcExpc3RJZCwgcHJvcGVydHk6IGV4cHJQdXNoSWQsIGNvbXB1dGVkOiBmYWxzZSB9KTtcbiAgICAgICAgdmFyIGV4cHJDYWxsID0gdGhpcy5jcmVhdGVOb2RlU3BhbihleHByLCBleHByLCBcIkNhbGxFeHByZXNzaW9uXCIsIHsgY2FsbGVlOiBleHByTWVtYmVyLCBhcmd1bWVudHM6IFtleHByXSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTm9kZVNwYW4oZXhwciwgZXhwciwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHsgZXhwcmVzc2lvbjogZXhwckNhbGwgfSk7XG4gICAgICB9LFxuXG4gICAgICAvLyAgKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICAgdmFyIF9saXN0ID0gW107XG4gICAgICAvLyAgICAuLi5cbiAgICAgIC8vICAgIGJvZHlcbiAgICAgIC8vICAgIHJldHVybiBfbGlzdDtcbiAgICAgIC8vICB9KCkpO1xuXG4gICAgICBjcmVhdGVMaXN0Q29tcElpZmU6IGZ1bmN0aW9uIChub2RlLCBib2R5LCB0bXBWYXJTdWZmaXgpIHtcbiAgICAgICAgdmFyIGlpZmVSdW50aW1lSWQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IG9wdGlvbnMucnVudGltZVBhcmFtTmFtZSB9KTtcbiAgICAgICAgdmFyIGlpZmVPYmplY3RzSWQgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwib2JqZWN0c1wiIH0pO1xuICAgICAgICB2YXIgaWlmZU9iak1lbWJlciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBpaWZlUnVudGltZUlkLCBwcm9wZXJ0eTogaWlmZU9iamVjdHNJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgaWlmZUxpc3RJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJsaXN0XCIgfSk7XG4gICAgICAgIHZhciBpaWZlTGlzdE1lbWJlciA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBpaWZlT2JqTWVtYmVyLCBwcm9wZXJ0eTogaWlmZUxpc3RJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgaWlmZU5ld0V4cHIgPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiLCB7IGNhbGxlZTogaWlmZUxpc3RNZW1iZXIsIGFyZ3VtZW50czogW10gfSk7XG4gICAgICAgIHZhciBpaWZlTGlzdElkID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIl9fdG1wTGlzdFwiICsgdG1wVmFyU3VmZml4IH0pO1xuICAgICAgICB2YXIgaWlmZUxpc3REZWNsID0gdGhpcy5jcmVhdGVWYXJEZWNsRnJvbUlkKG5vZGUsIGlpZmVMaXN0SWQsIGlpZmVOZXdFeHByKTtcblxuICAgICAgICB2YXIgaWlmZVJldHVybkxpc3RJZCA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJfX3RtcExpc3RcIiArIHRtcFZhclN1ZmZpeCB9KTtcbiAgICAgICAgdmFyIGlpZmVSZXR1cm4gPSB0aGlzLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIsIHsgYXJndW1lbnQ6IGlpZmVSZXR1cm5MaXN0SWQgfSk7XG5cbiAgICAgICAgdmFyIGlpZmVCbG9jayA9IHRoaXMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiLCB7IGJvZHk6IFtpaWZlTGlzdERlY2wsIGJvZHksIGlpZmVSZXR1cm5dIH0pO1xuICAgICAgICB2YXIgZm5FeHByID0gdGhpcy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7IHBhcmFtczogW10sIGRlZmF1bHRzOiBbXSwgYm9keTogaWlmZUJsb2NrLCBnZW5lcmF0b3I6IGZhbHNlLCBleHByZXNzaW9uOiBmYWxzZSB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIsIHsgY2FsbGVlOiBmbkV4cHIsIGFyZ3VtZW50czogW10gfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuICAvLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG4gIGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG4gICAgaWYgKHRva1R5cGUgPT09IHR5cGUpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbiAgLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBmdW5jdGlvbiBleHBlY3QodHlwZSkge1xuICAgIGlmICh0b2tUeXBlID09PSB0eXBlKSBuZXh0KCk7XG4gICAgZWxzZSB1bmV4cGVjdGVkKCk7XG4gIH1cblxuICAvLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG4gIGZ1bmN0aW9uIHVuZXhwZWN0ZWQoKSB7XG4gICAgcmFpc2UodG9rU3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IGEgbm9kZSBpcyBhbiBsdmFsIC0gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4gIC8vIHRvLlxuXG4gIGZ1bmN0aW9uIGNoZWNrTFZhbChleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgZXhwci50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICAgIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZXhwci5uYW1lKSlcbiAgICAgIHJhaXNlKGV4cHIuc3RhcnQsIFwiQXNzaWduaW5nIHRvIFwiICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cblxuICAvLyBHZXQgYXJncyBmb3IgYSBuZXcgdHVwbGUgZXhwcmVzc2lvblxuXG4gIGZ1bmN0aW9uIGdldFR1cGxlQXJncyhleHByKSB7XG4gICAgaWYgKGV4cHIuY2FsbGVlICYmIGV4cHIuY2FsbGVlLm9iamVjdCAmJiBleHByLmNhbGxlZS5vYmplY3Qub2JqZWN0ICYmXG4gICAgICBleHByLmNhbGxlZS5vYmplY3Qub2JqZWN0Lm5hbWUgPT09IG9wdGlvbnMucnVudGltZVBhcmFtTmFtZSAmJlxuICAgICAgZXhwci5jYWxsZWUucHJvcGVydHkgJiYgZXhwci5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJ0dXBsZVwiKVxuICAgICAgcmV0dXJuIGV4cHIuYXJndW1lbnRzO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVW5wYWNrIGFuIGx2YWx1ZSB0dXBsZSBpbnRvIGluZGl2dWFsIHZhcmlhYmxlIGFzc2lnbm1lbnRzXG4gIC8vICdhcmcwLCBhcmcxID0gcmlnaHQnIGJlY29tZXM6XG4gIC8vIHZhciB0bXAgPSByaWdodFxuICAvLyBhcmcwID0gdG1wWzBdXG4gIC8vIGFyZzEgPSB0bXBbMV1cbiAgLy8gLi4uXG5cbiAgZnVuY3Rpb24gdW5wYWNrVHVwbGUodHVwbGVBcmdzLCByaWdodCkge1xuICAgIGlmICghdHVwbGVBcmdzIHx8IHR1cGxlQXJncy5sZW5ndGggPCAxKSB1bmV4cGVjdGVkKCk7XG5cbiAgICB2YXIgdmFyU3RtdHMgPSBbXTtcblxuICAgIC8vIHZhciB0bXAgPSByaWdodFxuXG4gICAgdmFyIHRtcElkID0gbmMuY3JlYXRlTm9kZVNwYW4ocmlnaHQsIHJpZ2h0LCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIl9fZmlsYmVydFRtcFwiICsgbmV3QXN0SWRDb3VudCsrIH0pO1xuICAgIHZhciB0bXBEZWNsID0gbmMuY3JlYXRlVmFyRGVjbEZyb21JZChyaWdodCwgdG1wSWQsIHJpZ2h0KTtcbiAgICB2YXJTdG10cy5wdXNoKHRtcERlY2wpO1xuXG4gICAgLy8gYXJnTiA9IHRtcFtOXVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0dXBsZUFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsdmFsID0gdHVwbGVBcmdzW2ldO1xuICAgICAgdmFyIHN1YlR1cGxlQXJncyA9IGdldFR1cGxlQXJncyhsdmFsKTtcbiAgICAgIGlmIChzdWJUdXBsZUFyZ3MpIHtcbiAgICAgICAgdmFyIHN1YkxpdCA9IG5jLmNyZWF0ZU5vZGVTcGFuKHJpZ2h0LCByaWdodCwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IGkgfSk7XG4gICAgICAgIHZhciBzdWJSaWdodCA9IG5jLmNyZWF0ZU5vZGVTcGFuKHJpZ2h0LCByaWdodCwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiB0bXBJZCwgcHJvcGVydHk6IHN1YkxpdCwgY29tcHV0ZWQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBzdWJTdG10cyA9IHVucGFja1R1cGxlKHN1YlR1cGxlQXJncywgc3ViUmlnaHQpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YlN0bXRzLmxlbmd0aDsgaisrKSB2YXJTdG10cy5wdXNoKHN1YlN0bXRzW2pdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrTFZhbChsdmFsKTtcbiAgICAgICAgdmFyIGluZGV4SWQgPSBuYy5jcmVhdGVOb2RlU3BhbihyaWdodCwgcmlnaHQsIFwiTGl0ZXJhbFwiLCB7IHZhbHVlOiBpIH0pO1xuICAgICAgICB2YXIgaW5pdCA9IG5jLmNyZWF0ZU5vZGVTcGFuKHJpZ2h0LCByaWdodCwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiB0bXBJZCwgcHJvcGVydHk6IGluZGV4SWQsIGNvbXB1dGVkOiB0cnVlIH0pO1xuICAgICAgICBpZiAobHZhbC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhc2NvcGUuZXhpc3RzKGx2YWwubmFtZSkpIHtcbiAgICAgICAgICBzY29wZS5hZGRWYXIobHZhbC5uYW1lKTtcbiAgICAgICAgICB2YXIgdmFyRGVjbCA9IG5jLmNyZWF0ZVZhckRlY2xGcm9tSWQobHZhbCwgbHZhbCwgaW5pdCk7XG4gICAgICAgICAgdmFyU3RtdHMucHVzaCh2YXJEZWNsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obHZhbCk7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gbHZhbDtcbiAgICAgICAgICBub2RlLm9wZXJhdG9yID0gXCI9XCI7XG4gICAgICAgICAgbm9kZS5yaWdodCA9IGluaXQ7XG4gICAgICAgICAgZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpO1xuICAgICAgICAgIHZhclN0bXRzLnB1c2gobmMuY3JlYXRlTm9kZUZyb20obm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHsgZXhwcmVzc2lvbjogbm9kZSB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFyU3RtdHM7XG4gIH1cblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgZnVuY3Rpb24gcGFyc2VUb3BMZXZlbChwcm9ncmFtKSB7XG4gICAgbGFzdFN0YXJ0ID0gbGFzdEVuZCA9IHRva1BvcztcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpIGxhc3RFbmRMb2MgPSBuZXcgUG9zaXRpb247XG4gICAgaW5GdW5jdGlvbiA9IHN0cmljdCA9IG51bGw7XG4gICAgYnJhY2tldE5lc3RpbmcgPSAwO1xuICAgIHJlYWRUb2tlbigpO1xuICAgIHZhciBub2RlID0gcHJvZ3JhbSB8fCBzdGFydE5vZGUoKTtcbiAgICBpZiAoIXByb2dyYW0pIG5vZGUuYm9keSA9IFtdO1xuICAgIHdoaWxlICh0b2tUeXBlICE9PSBfZW9mKSB7XG4gICAgICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICBpZiAoc3RtdCkgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGEgc2luZ2xlIHN0YXRlbWVudC5cbiAgLy9cbiAgLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbiAgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwuIFRoaXMgaXMgdG8gaGFuZGxlIGNhc2VzIGxpa2VcbiAgLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbyk7YCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbiAgLy8gZG9lcyBub3QgaGVscC5cblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICBpZiAodG9rVHlwZSA9PT0gX3NsYXNoIHx8IHRva1R5cGUgPT09IF9hc3NpZ24gJiYgdG9rVmFsID09IFwiLz1cIilcbiAgICAgIHJlYWRUb2tlbih0cnVlKTtcblxuICAgIHZhciBzdGFydHR5cGUgPSB0b2tUeXBlLCBub2RlID0gc3RhcnROb2RlKCk7XG5cbiAgICAvLyBNb3N0IHR5cGVzIG9mIHN0YXRlbWVudHMgYXJlIHJlY29nbml6ZWQgYnkgdGhlIGtleXdvcmQgdGhleVxuICAgIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAgIC8vIGNvbXBsZXhpdHkuXG5cbiAgICBzd2l0Y2ggKHN0YXJ0dHlwZSkge1xuXG4gICAgY2FzZSBfYnJlYWs6XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkJyZWFrU3RhdGVtZW50XCIpO1xuXG4gICAgY2FzZSBfY29udGludWU6XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xuXG4gICAgY2FzZSBfY2xhc3M6XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gcGFyc2VDbGFzcyhub2RlKTtcblxuICAgIGNhc2UgX2RlZjpcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUpO1xuXG4gICAgY2FzZSBfZm9yOlxuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHBhcnNlRm9yKG5vZGUpO1xuXG4gICAgY2FzZSBfZnJvbTogLy8gU2tpcHBpbmcgZnJvbSBhbmQgaW1wb3J0IHN0YXRlbWVudHMgZm9yIG5vd1xuICAgICAgc2tpcExpbmUoKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgY2FzZSBfaWY6IGNhc2UgX2VsaWY6XG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAodG9rVHlwZSA9PT0gX3BhcmVuTCkgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgIGVsc2Ugbm9kZS50ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlU3VpdGUoKTtcbiAgICAgIGlmICh0b2tUeXBlID09PSBfZWxpZikge1xuICAgICAgICBub2RlLmFsdGVybmF0ZSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlYXQoX2Vsc2UpKSB7XG4gICAgICAgIGV4cGVjdChfY29sb24pO1xuICAgICAgICBlYXQoX2NvbG9uKTtcbiAgICAgICAgbm9kZS5hbHRlcm5hdGUgPSBwYXJzZVN1aXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgfSBcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIik7XG5cbiAgICBjYXNlIF9pbXBvcnQ6IC8vIFNraXBwaW5nIGZyb20gYW5kIGltcG9ydCBzdGF0ZW1lbnRzIGZvciBub3dcbiAgICAgIHNraXBMaW5lKCk7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgIGNhc2UgX25ld2xpbmU6XG4gICAgICAvLyBUT0RPOiBwYXJzZVN0YXRlbWVudCgpIHNob3VsZCBwcm9iYWJseSBlYXQgaXQncyBvd24gbmV3bGluZVxuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIF9wYXNzOlxuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKTtcblxuICAgIGNhc2UgX3JldHVybjpcbiAgICAgIGlmICghaW5GdW5jdGlvbiAmJiAhb3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgICAgcmFpc2UodG9rU3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIGlmICh0b2tUeXBlID09PV9uZXdsaW5lIHx8IHRva1R5cGUgPT09IF9lb2YpIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgICAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTt9XG4gICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcblxuICAgIGNhc2UgX3RyeTogLy8gVE9ETywgYW5kIHJlbW92ZSBwYXJzZUJsb2NrXG4gICAgICBuZXh0KCk7XG4gICAgICBub2RlLmJsb2NrID0gcGFyc2VCbG9jaygpO1xuICAgICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICAgIGlmICh0b2tUeXBlID09PSBfY2F0Y2gpIHtcbiAgICAgICAgdmFyIGNsYXVzZSA9IHN0YXJ0Tm9kZSgpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICAgICAgY2xhdXNlLnBhcmFtID0gcGFyc2VJZGVudCgpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0QmFkSWRXb3JkKGNsYXVzZS5wYXJhbS5uYW1lKSlcbiAgICAgICAgICByYWlzZShjbGF1c2UucGFyYW0uc3RhcnQsIFwiQmluZGluZyBcIiArIGNsYXVzZS5wYXJhbS5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgICAgY2xhdXNlLmd1YXJkID0gbnVsbDtcbiAgICAgICAgY2xhdXNlLmJvZHkgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIG5vZGUuaGFuZGxlciA9IGZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgICAgfVxuICAgICAgbm9kZS5ndWFyZGVkSGFuZGxlcnMgPSBlbXB0eTtcbiAgICAgIG5vZGUuZmluYWxpemVyID0gZWF0KF9maW5hbGx5KSA/IHBhcnNlQmxvY2soKSA6IG51bGw7XG4gICAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICAgIHJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xuXG4gICAgY2FzZSBfd2hpbGU6XG4gICAgICBuZXh0KCk7XG4gICAgICBpZiAodG9rVHlwZSA9PT0gX3BhcmVuTCkgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICAgIGVsc2Ugbm9kZS50ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgIG5vZGUuYm9keSA9IHBhcnNlU3VpdGUoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG5cbiAgICBjYXNlIF93aXRoOiAvLyBUT0RPXG4gICAgICBpZiAoc3RyaWN0KSByYWlzZSh0b2tTdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICBuZXh0KCk7XG4gICAgICBub2RlLm9iamVjdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpO1xuXG4gICAgY2FzZSBfc2VtaTpcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG5cbiAgICAgIC8vIEFzc3VtZSBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQuIElmIGFuIGFzc2lnbiBoYXMgYmVlbiBcbiAgICAgIC8vIGNvbnZlcnRlZCB0byBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uLCBwYXNzIGl0IHVwIGFzIGlzLlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAodG9rVHlwZSAhPT0gX3NlbWkgJiYgdG9rVHlwZSAhPT0gX25ld2xpbmUgJiYgdG9rVHlwZSAhPT0gX2VvZikgdW5leHBlY3RlZCgpO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgfHwgZXhwci50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgaW5kZW50LWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHNcblxuICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgbm9kZS5ib2R5ID0gW107XG4gICAgd2hpbGUgKHRva1R5cGUgIT09IF9kZWRlbnQgJiYgdG9rVHlwZSAhPT0gX2VvZikge1xuICAgICAgdmFyIHN0bXQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgaWYgKHN0bXQpIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBpZiAodG9rVHlwZSA9PT0gX2RlZGVudCkgbmV4dCgpO1xuICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gIH1cblxuICAvLyBQYXJzZSAnc3VpdGUnIGZyb20gUHl0aG9uIGdyYW1tYXIgc3BlY1xuICAvLyBXaWxsIHJlcGxhY2UgcGFyc2VCbG9jayBldmVudHVhbGx5XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWl0ZSgpIHtcbiAgICAvLyBOT1RFOiBUaGlzIGlzIG5vdCBzdHJpY3RseSB2YWxpZCBQeXRob24gZm9yIHRoaXMgdG8gYmUgYW4gZW1wdHkgYmxvY2tcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuYm9keSA9IFtdO1xuICAgIGlmIChlYXQoX25ld2xpbmUpKSB7XG4gICAgICBpZiAodG9rVHlwZSA9PT0gX2luZGVudCkge1xuICAgICAgICBleHBlY3QoX2luZGVudCk7XG4gICAgICAgIHdoaWxlICghZWF0KF9kZWRlbnQpICYmICFlYXQoX2VvZikpIHtcbiAgICAgICAgICB2YXIgc3RtdCA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgaWYgKHN0bXQpIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tUeXBlICE9PSBfZW9mKSB7XG4gICAgICBub2RlLmJvZHkucHVzaChwYXJzZVN0YXRlbWVudCgpKTtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGZvci9pbiBsb29wXG5cbiAgZnVuY3Rpb24gcGFyc2VGb3Iobm9kZSkge1xuICAgIHZhciBpbml0ID0gcGFyc2VFeHByZXNzaW9uKGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgdHVwbGVBcmdzID0gZ2V0VHVwbGVBcmdzKGluaXQpO1xuICAgIGlmICghdHVwbGVBcmdzKSBjaGVja0xWYWwoaW5pdCk7XG4gICAgZXhwZWN0KF9pbik7XG4gICAgdmFyIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgZXhwZWN0KF9jb2xvbik7XG4gICAgdmFyIGJvZHkgPSBwYXJzZVN1aXRlKCk7XG4gICAgZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgIHJldHVybiBuYy5jcmVhdGVGb3Iobm9kZSwgaW5pdCwgdHVwbGVBcmdzLCByaWdodCwgYm9keSk7XG4gIH1cblxuICAvLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbiAgLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4gIC8vICdhdG9taWMnLCBub25kaXZpc2libGUgZXhwcmVzc2lvbiB0eXBlcyBhdCB0aGUgYm90dG9tLiBNb3N0IG9mXG4gIC8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuICAvLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuICAvLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbiAgLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZm9yYmlkIGNvbW1hXG4gIC8vIHNlcXVlbmNlcyAoaW4gYXJndW1lbnQgbGlzdHMsIGFycmF5IGxpdGVyYWxzLCBvciBvYmplY3QgbGl0ZXJhbHMpXG4gIC8vIG9yIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucykuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKG5vQ29tbWEsIG5vSW4pIHtcbiAgICByZXR1cm4gcGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIGNvbnN0cnVjdHMgbGlrZSBgc3dpdGNoYCBhbmQgYGlmYCB0aGF0IGluc2lzdCBvblxuICAvLyBwYXJlbnRoZXNlcyBhcm91bmQgdGhlaXIgZXhwcmVzc2lvbi5cblxuICBmdW5jdGlvbiBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIHtcbiAgICBleHBlY3QoX3BhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuICAvLyBBZGQgJ3RoaXMuJyB0byBhc3NpZ25tZW50cyBpbiBhIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAvLyBDb252ZXJ0IGlkZW50aWZpZXIgYXNzaWdubWVudCB0byB2YXJpYWJsZSBkZWNsYXJhdGlvbiBpZiB0aGVcbiAgLy8gaWRlbnRpZmllciBkb2Vzbid0IGV4aXN0IGluIHRoaXMgbmFtZXNwYWNlIHlldC5cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlQXNzaWduKG5vSW4pIHtcbiAgICB2YXIgbGVmdCA9IHBhcnNlTWF5YmVUdXBsZShub0luKTtcbiAgICBpZiAodG9rVHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIHR1cGxlQXJncyA9IGdldFR1cGxlQXJncyhsZWZ0KTtcbiAgICAgIGlmICh0dXBsZUFyZ3MpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYXJzZU1heWJlVHVwbGUobm9Jbik7XG4gICAgICAgIHZhciBibG9ja05vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuICAgICAgICBibG9ja05vZGUuYm9keSA9IHVucGFja1R1cGxlKHR1cGxlQXJncywgcmlnaHQpO1xuICAgICAgICByZXR1cm4gZmluaXNoTm9kZShibG9ja05vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5pc0NsYXNzKCkpIHtcbiAgICAgICAgdmFyIHRoaXNFeHByID0gbmMuY3JlYXRlTm9kZUZyb20obGVmdCwgXCJUaGlzRXhwcmVzc2lvblwiKTtcbiAgICAgICAgbGVmdCA9IG5jLmNyZWF0ZU5vZGVGcm9tKGxlZnQsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogdGhpc0V4cHIsIHByb3BlcnR5OiBsZWZ0IH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20obGVmdCk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdG9rVmFsO1xuICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5vZGUucmlnaHQgPSBwYXJzZU1heWJlVHVwbGUobm9Jbik7XG4gICAgICBjaGVja0xWYWwobGVmdCk7XG5cbiAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSAnKz0nIHx8IG5vZGUub3BlcmF0b3IgPT09ICcqPScpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZS5yaWdodCwgbm9kZS5yaWdodCwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICAgICAgcmlnaHQuY2FsbGVlID0gbmMuY3JlYXRlTm9kZU9wc0NhbGxlZShyaWdodCwgbm9kZS5vcGVyYXRvciA9PT0gJys9JyA/IFwiYWRkXCIgOiBcIm11bHRpcGx5XCIpO1xuICAgICAgICByaWdodC5hcmd1bWVudHMgPSBbbGVmdCwgbm9kZS5yaWdodF07XG4gICAgICAgIG5vZGUucmlnaHQgPSByaWdodDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9ICc9JztcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIXNjb3BlLmV4aXN0cyhsZWZ0Lm5hbWUpKSB7XG4gICAgICAgIGlmICghbm9kZS5vcGVyYXRvciB8fCBub2RlLm9wZXJhdG9yLmxlbmd0aCA+IDEpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgc2NvcGUuYWRkVmFyKGxlZnQubmFtZSk7XG4gICAgICAgIHJldHVybiBuYy5jcmVhdGVWYXJEZWNsRnJvbUlkKG5vZGUubGVmdCwgbm9kZS5sZWZ0LCBub2RlLnJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgLy8gUGFyc2UgYSB0dXBsZVxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVUdXBsZShub0luKSB7XG4gICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJPcHMobm9Jbik7XG4gICAgaWYgKHRva1R5cGUgPT09IF9jb21tYSkge1xuICAgICAgcmV0dXJuIHBhcnNlVHVwbGUobm9JbiwgZXhwcik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwck9wcyhub0luKSB7XG4gICAgcmV0dXJuIHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeShub0luKSwgLTEsIG5vSW4pO1xuICB9XG5cbiAgLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbiAgLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbiAgLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4gIC8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbiAgLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuICAvLyBFeHBvbmVudGlhdGlvbiBpcyBldmFsdWF0ZWQgcmlnaHQtdG8tbGVmdCwgc28gJ3ByZWMgPj0gbWluUHJlYydcbiAgLy8gRXhwb25lbnRpYXRpb24gb3BlcmF0b3IgJ3gqKnknIGlzIHJlcGxhY2VkIHdpdGggJ01hdGgucG93KHgsIHkpJ1xuICAvLyBGbG9vciBkaXZpc2lvbiBvcGVyYXRvciAneC8veScgaXMgcmVwbGFjZWQgd2l0aCAnTWF0aC5mbG9vcih4L3kpJ1xuICAvLyAnaW4nIGFuZCAnbm90IGluJyBpbXBsZW1lbnRlZCB2aWEgaW5kZXhPZigpXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByT3AobGVmdCwgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBub2RlLCBleHByTm9kZSwgcmlnaHQsIG9wID0gdG9rVHlwZSwgdmFsID0gdG9rVmFsO1xuICAgIHZhciBwcmVjID0gb3AgPT09IF9ub3QgPyBfaW4ucHJlYyA6IG9wLnByZWM7XG4gICAgaWYgKG9wID09PSBfZXhwb25lbnRpYXRpb24gJiYgcHJlYyA+PSBtaW5QcmVjKSB7XG4gICAgICBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KG5vSW4pLCBwcmVjLCBub0luKTtcbiAgICAgIGV4cHJOb2RlID0gbmMuY3JlYXRlTm9kZU1lbWJlckNhbGwobm9kZSwgXCJNYXRoXCIsIFwicG93XCIsIFtsZWZ0LCByaWdodF0pO1xuICAgICAgcmV0dXJuIHBhcnNlRXhwck9wKGV4cHJOb2RlLCBtaW5QcmVjLCBub0luKTtcbiAgICB9IGVsc2UgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgb3AgIT09IF9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuICAgICAgICBpZiAob3AgPT09IF9mbG9vckRpdikge1xuICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KG5vSW4pLCBwcmVjLCBub0luKTtcbiAgICAgICAgICBmaW5pc2hOb2RlKG5vZGUpO1xuICAgICAgICAgIHZhciBiaW5FeHByID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJCaW5hcnlFeHByZXNzaW9uXCIsIHsgbGVmdDogbGVmdCwgb3BlcmF0b3I6ICcvJywgcmlnaHQ6IHJpZ2h0IH0pO1xuICAgICAgICAgIGV4cHJOb2RlID0gbmMuY3JlYXRlTm9kZU1lbWJlckNhbGwobm9kZSwgXCJNYXRoXCIsIFwiZmxvb3JcIiwgW2JpbkV4cHJdKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcCA9PT0gX2luIHx8IG9wID09PSBfbm90KSB7XG4gICAgICAgICAgaWYgKG9wID09PSBfaW4gfHwgZWF0KF9pbikpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KG5vSW4pLCBwcmVjLCBub0luKTtcbiAgICAgICAgICAgIGZpbmlzaE5vZGUobm9kZSk7XG4gICAgICAgICAgICB2YXIgbm90TGl0ID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IG9wID09PSBfbm90IH0pO1xuICAgICAgICAgICAgZXhwck5vZGUgPSBuYy5jcmVhdGVOb2RlUnVudGltZUNhbGwobm9kZSwgJ29wcycsICdpbicsIFtsZWZ0LCByaWdodCwgbm90TGl0XSk7XG4gICAgICAgICAgfSBlbHNlIHJhaXNlKHRva1BvcywgXCJFeHBlY3RlZCAnbm90IGluJyBjb21wYXJpc29uIG9wZXJhdG9yXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wID09PSBfcGx1c01pbiAmJiB2YWwgPT09ICcrJyB8fCBvcCA9PT0gX211bHRpcGx5TW9kdWxvICYmIHZhbCA9PT0gJyonKSB7XG4gICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBbbGVmdF07XG4gICAgICAgICAgbm9kZS5hcmd1bWVudHMucHVzaChwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkobm9JbiksIHByZWMsIG5vSW4pKTtcbiAgICAgICAgICBmaW5pc2hOb2RlKG5vZGUsIFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgbm9kZS5jYWxsZWUgPSBuYy5jcmVhdGVOb2RlT3BzQ2FsbGVlKG5vZGUsIG9wID09PSBfcGx1c01pbiA/IFwiYWRkXCIgOiBcIm11bHRpcGx5XCIpO1xuICAgICAgICAgIGV4cHJOb2RlID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3AgPT09IF9pcykge1xuICAgICAgICAgICAgaWYgKGVhdChfbm90KSkgbm9kZS5vcGVyYXRvciA9IFwiIT09XCI7XG4gICAgICAgICAgICBlbHNlIG5vZGUub3BlcmF0b3IgPSBcIj09PVwiO1xuICAgICAgICAgIH0gZWxzZSBub2RlLm9wZXJhdG9yID0gb3AucmVwICE9IG51bGwgPyBvcC5yZXAgOiB2YWw7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICBub2RlLnJpZ2h0ID0gcGFyc2VFeHByT3AocGFyc2VNYXliZVVuYXJ5KG5vSW4pLCBwcmVjLCBub0luKTtcbiAgICAgICAgICBleHByTm9kZSA9IGZpbmlzaE5vZGUobm9kZSwgKG9wID09PSBfb3IgfHwgb3AgPT09IF9hbmQpID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJPcChleHByTm9kZSwgbWluUHJlYywgbm9Jbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgLy8gUGFyc2UgdW5hcnkgb3BlcmF0b3JzLlxuICAvLyAnLSsnIGFyZSBwcmVmaXhlcyBoZXJlLCB3aXRoIGRpZmZlcmVudCBwcmVjZWRlbmNlLlxuXG4gIGZ1bmN0aW9uIHBhcnNlTWF5YmVVbmFyeShub0luKSB7XG4gICAgaWYgKHRva1R5cGUucHJlZml4IHx8IHRva1R5cGUgPT09IF9wbHVzTWluKSB7XG4gICAgICB2YXIgcHJlYyA9IHRva1R5cGUgPT09IF9wbHVzTWluID8gX3Bvc05lZ05vdC5wcmVjIDogdG9rVHlwZS5wcmVjO1xuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0b2tUeXBlLnJlcCAhPSBudWxsID8gdG9rVHlwZS5yZXAgOiB0b2tWYWw7XG4gICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICB0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcbiAgICAgIG5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBwYXJzZUV4cHJPcChwYXJzZU1heWJlVW5hcnkobm9JbiksIHByZWMsIG5vSW4pO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMocGFyc2VFeHByQXRvbSgpKTtcbiAgfVxuXG4gIC8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG4gIGZ1bmN0aW9uIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBub0NhbGxzKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuICAgIGlmIChlYXQoX2RvdCkpIHtcbiAgICAgIHZhciBpZCA9IHBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAocHl0aG9uUnVudGltZS5pbXBvcnRzW2Jhc2UubmFtZV0gJiYgcHl0aG9uUnVudGltZS5pbXBvcnRzW2Jhc2UubmFtZV1baWQubmFtZV0pIHtcbiAgICAgICAgLy8gQ2FsbGluZyBhIFB5dGhvbiBpbXBvcnQgZnVuY3Rpb25cbiAgICAgICAgLy8gVE9ETzogVW5wYWNrIHBhcmFtZXRlcnMgaW50byBKYXZhU2NyaXB0LWZyaWVuZGx5IHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIHJ1bnRpbWVJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKGJhc2UsIGJhc2UsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IG9wdGlvbnMucnVudGltZVBhcmFtTmFtZSB9KTtcbiAgICAgICAgdmFyIGltcG9ydHNJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKGJhc2UsIGJhc2UsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwiaW1wb3J0c1wiIH0pO1xuICAgICAgICB2YXIgcnVudGltZU1lbWJlciA9IG5jLmNyZWF0ZU5vZGVTcGFuKGJhc2UsIGJhc2UsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogcnVudGltZUlkLCBwcm9wZXJ0eTogaW1wb3J0c0lkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgICAgIG5vZGUub2JqZWN0ID0gbmMuY3JlYXRlTm9kZVNwYW4oYmFzZSwgYmFzZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lTWVtYmVyLCBwcm9wZXJ0eTogYmFzZSwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIGlmIChiYXNlLm5hbWUgJiYgYmFzZS5uYW1lID09PSBzY29wZS5nZXRUaGlzUmVwbGFjZSgpKSB7XG4gICAgICAgIG5vZGUub2JqZWN0ID0gbmMuY3JlYXRlTm9kZVNwYW4oYmFzZSwgYmFzZSwgXCJUaGlzRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gaWQ7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcbiAgICB9IGVsc2UgaWYgKGVhdChfYnJhY2tldEwpKSB7XG4gICAgICB2YXIgZXhwciwgaXNTbGljZSA9IGZhbHNlO1xuICAgICAgaWYgKGVhdChfY29sb24pKSBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgIGVsc2UgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKCFpc1NsaWNlICYmIGVhdChfY29sb24pKSBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgIGlmIChpc1NsaWNlKSByZXR1cm4gcGFyc2VTbGljZShub2RlLCBiYXNlLCBleHByLCBub0NhbGxzKTtcbiAgICAgIHZhciBzdWJzY3JpcHRDYWxsID0gbmMuY3JlYXRlTm9kZVNwYW4oZXhwciwgZXhwciwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICAgIHN1YnNjcmlwdENhbGwuY2FsbGVlID0gbmMuY3JlYXRlTm9kZU9wc0NhbGxlZShleHByLCBcInN1YnNjcmlwdEluZGV4XCIpO1xuICAgICAgc3Vic2NyaXB0Q2FsbC5hcmd1bWVudHMgPSBbYmFzZSwgZXhwcl07XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gc3Vic2NyaXB0Q2FsbDtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgZXhwZWN0KF9icmFja2V0Uik7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIGVhdChfcGFyZW5MKSkge1xuICAgICAgaWYgKHNjb3BlLmlzVXNlckZ1bmN0aW9uKGJhc2UubmFtZSkpIHtcbiAgICAgICAgLy8gVW5wYWNrIHBhcmFtZXRlcnMgaW50byBKYXZhU2NyaXB0LWZyaWVuZGx5IHBhcmFtZXRlcnMsIGZ1cnRoZXIgcHJvY2Vzc2VkIGF0IHJ1bnRpbWVcbiAgICAgICAgdmFyIHBsID0gcGFyc2VQYXJhbXNMaXN0KCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgb3RoZXIgPSBbXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgcGwubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgaWYgKCBwbFtpXS5pc250Rm9ybWFsICkgb3RoZXIucHVzaChwbFtpXSk7XG4gICAgICAgICAgZWxzZSBhcmdzLnB1c2gocGxbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBvdGhlci5sZW5ndGggPiAwICkge1xuICAgICAgICAgIHZhciBjcmVhdGVQYXJhbXNDYWxsID0gbmMuY3JlYXRlTm9kZVJ1bnRpbWVDYWxsKG5vZGUsICd1dGlscycsICdjcmVhdGVQYXJhbXNPYmonLCBvdGhlcik7XG4gICAgICAgICAgYXJncy5wdXNoKGNyZWF0ZVBhcmFtc0NhbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgfSBlbHNlIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG5cblxuICAgICAgaWYgKCBiYXNlLm5hbWUgPT09ICdsZW4nICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgbm9kZS50eXBlID0gXCJNZW1iZXJFeHByZXNzaW9uXCIsXG4gICAgICAgIG5vZGUub2JqZWN0ID0gbm9kZS5hcmd1bWVudHNbMF07XG4gICAgICAgIG5vZGUucHJvcGVydHkgPSBuYy5jcmVhdGVOb2RlU3BhbihiYXNlLCBiYXNlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcImxlbmd0aFwifSksXG4gICAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVsZXRlIG5vZGUuYXJndW1lbnRzO1xuICAgICAgICBkZWxldGUgbm9kZS5jYWxsZWU7XG4gICAgICAgIGZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgICByZXR1cm4gbm9kZTsgXG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5pc05ld09iaihiYXNlLm5hbWUpKSBmaW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbiAgICAgIGVsc2UgZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuXG4gICAgICBpZiAocHl0aG9uUnVudGltZS5mdW5jdGlvbnNbYmFzZS5uYW1lXSkge1xuICAgICAgICAvLyBDYWxsaW5nIGEgUHl0aG9uIGJ1aWx0LWluIGZ1bmN0aW9uXG4gICAgICAgIC8vIFRPRE86IFVucGFjayBwYXJhbWV0ZXJzIGludG8gSmF2YVNjcmlwdC1mcmllbmRseSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChiYXNlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIHZhciBydW50aW1lSWQgPSBuYy5jcmVhdGVOb2RlU3BhbihiYXNlLCBiYXNlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBvcHRpb25zLnJ1bnRpbWVQYXJhbU5hbWUgfSk7XG4gICAgICAgIHZhciBmdW5jdGlvbnNJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKGJhc2UsIGJhc2UsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwiZnVuY3Rpb25zXCIgfSk7XG4gICAgICAgIHZhciBydW50aW1lTWVtYmVyID0gbmMuY3JlYXRlTm9kZVNwYW4oYmFzZSwgYmFzZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lSWQsIHByb3BlcnR5OiBmdW5jdGlvbnNJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgICBub2RlLmNhbGxlZSA9IG5jLmNyZWF0ZU5vZGVTcGFuKGJhc2UsIGJhc2UsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogcnVudGltZU1lbWJlciwgcHJvcGVydHk6IGJhc2UsIGNvbXB1dGVkOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKG5vZGUsIG5vQ2FsbHMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2xpY2Uobm9kZSwgYmFzZSwgc3RhcnQsIG5vQ2FsbHMpIHtcbiAgICB2YXIgZW5kLCBzdGVwO1xuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gbmMuY3JlYXRlTm9kZUZyb20obm9kZSwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IG51bGwgfSk7XG4gICAgaWYgKHRva1R5cGUgPT09IF9icmFja2V0UiB8fCBlYXQoX2NvbG9uKSkge1xuICAgICAgZW5kID0gbmMuY3JlYXRlTm9kZUZyb20obm9kZSwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IG51bGwgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgaWYgKHRva1R5cGUgIT09IF9icmFja2V0UikgZXhwZWN0KF9jb2xvbik7XG4gICAgfVxuICAgIGlmICh0b2tUeXBlID09PSBfYnJhY2tldFIpIHN0ZXAgPSBuYy5jcmVhdGVOb2RlRnJvbShub2RlLCBcIkxpdGVyYWxcIiwgeyB2YWx1ZTogbnVsbCB9KTtcbiAgICBlbHNlIHN0ZXAgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoX2JyYWNrZXRSKTtcblxuICAgIG5vZGUuYXJndW1lbnRzID0gW3N0YXJ0LCBlbmQsIHN0ZXBdO1xuICAgIHZhciBzbGljZUlkID0gbmMuY3JlYXRlTm9kZUZyb20oYmFzZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJfcHlTbGljZVwiIH0pO1xuICAgIHZhciBtZW1iZXJFeHByID0gbmMuY3JlYXRlTm9kZVNwYW4oYmFzZSwgYmFzZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBiYXNlLCBwcm9wZXJ0eTogc2xpY2VJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgIG5vZGUuY2FsbGVlID0gbWVtYmVyRXhwcjtcbiAgICByZXR1cm4gcGFyc2VTdWJzY3JpcHRzKGZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG4gIH1cblxuICAvLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiAtIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4gIC8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4gIC8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuICAvLyBvciBge31gLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwckF0b20oKSB7XG4gICAgc3dpdGNoICh0b2tUeXBlKSB7XG5cbiAgICBjYXNlIF9kaWN0OlxuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHBhcnNlRGljdChfcGFyZW5SKTtcblxuICAgIGNhc2UgX25hbWU6XG4gICAgICByZXR1cm4gcGFyc2VJZGVudCgpO1xuXG4gICAgY2FzZSBfbnVtOiBjYXNlIF9zdHJpbmc6IGNhc2UgX3JlZ2V4cDpcbiAgICAgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG4gICAgICBub2RlLnZhbHVlID0gdG9rVmFsO1xuICAgICAgbm9kZS5yYXcgPSBpbnB1dC5zbGljZSh0b2tTdGFydCwgdG9rRW5kKTtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgX25vbmU6IGNhc2UgX3RydWU6IGNhc2UgX2ZhbHNlOlxuICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0b2tUeXBlLmF0b21WYWx1ZTtcbiAgICAgIG5vZGUucmF3ID0gdG9rVHlwZS5rZXl3b3JkO1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpO1xuXG4gICAgY2FzZSBfcGFyZW5MOlxuICAgICAgdmFyIHRva1N0YXJ0TG9jMSA9IHRva1N0YXJ0TG9jLCB0b2tTdGFydDEgPSB0b2tTdGFydDtcbiAgICAgIG5leHQoKTtcbiAgICAgIGlmICh0b2tUeXBlID09PSBfcGFyZW5SKSB7XG4gICAgICAgIC8vIEVtcHR5IHR1cGxlXG4gICAgICAgIHZhciBub2RlID0gcGFyc2VUdXBsZShmYWxzZSk7XG4gICAgICAgIGVhdChfcGFyZW5SKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gcGFyc2VNYXliZVR1cGxlKGZhbHNlKTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICB2YWwubG9jLnN0YXJ0ID0gdG9rU3RhcnRMb2MxO1xuICAgICAgICB2YWwubG9jLmVuZCA9IHRva0VuZExvYztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgICAgdmFsLnJhbmdlID0gW3Rva1N0YXJ0MSwgdG9rRW5kXTtcbiAgICAgIGV4cGVjdChfcGFyZW5SKTtcbiAgICAgIHJldHVybiB2YWw7XG5cbiAgICBjYXNlIF9icmFja2V0TDpcbiAgICAgIHJldHVybiBwYXJzZUxpc3QoKTtcblxuICAgIGNhc2UgX2JyYWNlTDpcbiAgICAgIHJldHVybiBwYXJzZURpY3QoX2JyYWNlUik7XG5cbiAgICBjYXNlIF9pbmRlbnQ6XG4gICAgICByYWlzZSh0b2tTdGFydCwgXCJVbmV4cGVjdGVkIGluZGVudFwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgbGlzdFxuXG4gIC8vIEN1c3RvbSBsaXN0IG9iamVjdCBpcyB1c2VkIHRvIHNpbXVsYXRlIG5hdGl2ZSBQeXRob24gbGlzdFxuICAvLyBFLmcuIFB5dGhvbiAnW10nIGJlY29tZXMgSmF2YVNjcmlwdCAnbmV3IF9fcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTsnXG4gIC8vIElmIGxpc3QgY29tcHJlaGVuc2lvbiwgYnVpbGQgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAgLy8oZnVuY3Rpb24oKSB7XG4gIC8vICB2YXIgX2xpc3QgPSBbXTtcbiAgLy8gIC4uLlxuICAvLyAgX2xpc3QucHVzaChleHByKTtcbiAgLy8gIHJldHVybiBfbGlzdDtcbiAgLy99KCkpO1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGlzdCgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuYXJndW1lbnRzID0gW107XG4gICAgbmV4dCgpO1xuXG4gICAgaWYgKCFlYXQoX2JyYWNrZXRSKSkge1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJPcHMoZmFsc2UpO1xuICAgICAgaWYgKHRva1R5cGUgPT09IF9mb3IgfHwgdG9rVHlwZSA9PT0gX2lmKSB7XG5cbiAgICAgICAgLy8gTGlzdCBjb21wcmVoZW5zaW9uXG4gICAgICAgIHZhciB0bXBWYXJTdWZmaXggPSBuZXdBc3RJZENvdW50Kys7XG4gICAgICAgIGV4cHIgPSBuYy5jcmVhdGVMaXN0Q29tcFB1c2goZXhwciwgdG1wVmFyU3VmZml4KTtcbiAgICAgICAgdmFyIGJvZHkgPSBwYXJzZUNvbXBJdGVyKGV4cHIsIHRydWUpO1xuICAgICAgICBmaW5pc2hOb2RlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbmMuY3JlYXRlTGlzdENvbXBJaWZlKG5vZGUsIGJvZHksIHRtcFZhclN1ZmZpeCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoZWF0KF9jb21tYSkpIHtcbiAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBbZXhwcl0uY29uY2F0KHBhcnNlRXhwckxpc3QoX2JyYWNrZXRSLCB0cnVlLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGV4cGVjdChfYnJhY2tldFIpO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IFtleHByXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbiAgICB2YXIgcnVudGltZUlkID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogb3B0aW9ucy5ydW50aW1lUGFyYW1OYW1lIH0pO1xuICAgIHZhciBvYmplY3RzSWQgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcIm9iamVjdHNcIiB9KTtcbiAgICB2YXIgcnVudGltZU1lbWJlciA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogcnVudGltZUlkLCBwcm9wZXJ0eTogb2JqZWN0c0lkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgdmFyIGxpc3RJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwibGlzdFwiIH0pO1xuICAgIG5vZGUuY2FsbGVlID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lTWVtYmVyLCBwcm9wZXJ0eTogbGlzdElkLCBjb21wdXRlZDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBQYXJzZSBhIGNvbXBfaXRlciBmcm9tIFB5dGhvbiBsYW5ndWFnZSBncmFtbWFyXG4gIC8vIFVzZWQgdG8gYnVpbGQgbGlzdCBjb21wcmVoZW5zaW9uc1xuICAvLyAnZXhwcicgaXMgdGhlIGJvZHkgdG8gYmUgdXNlZCBhZnRlciB1bnJvbGxpbmcgdGhlIGlmcyBhbmQgZm9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcEl0ZXIoZXhwciwgZmlyc3QpIHtcbiAgICBpZiAoZmlyc3QgJiYgdG9rVHlwZSAhPT0gX2ZvcikgdW5leHBlY3RlZCgpO1xuICAgIGlmIChlYXQoX2JyYWNrZXRSKSkgcmV0dXJuIGV4cHI7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcbiAgICBpZiAoZWF0KF9mb3IpKSB7XG4gICAgICB2YXIgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbihmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YXIgdHVwbGVBcmdzID0gZ2V0VHVwbGVBcmdzKGluaXQpO1xuICAgICAgaWYgKCF0dXBsZUFyZ3MpIGNoZWNrTFZhbChpbml0KTtcbiAgICAgIGV4cGVjdChfaW4pO1xuICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB2YXIgYm9keSA9IHBhcnNlQ29tcEl0ZXIoZXhwciwgZmFsc2UpO1xuICAgICAgdmFyIGJsb2NrID0gbmMuY3JlYXRlTm9kZVNwYW4oYm9keSwgYm9keSwgXCJCbG9ja1N0YXRlbWVudFwiLCB7IGJvZHk6IFtib2R5XSB9KTtcbiAgICAgIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICAgIHJldHVybiBuYy5jcmVhdGVGb3Iobm9kZSwgaW5pdCwgdHVwbGVBcmdzLCByaWdodCwgYmxvY2spO1xuICAgIH0gZWxzZSBpZiAoZWF0KF9pZikpIHtcbiAgICAgIGlmICh0b2tUeXBlID09PSBfcGFyZW5MKSBub2RlLnRlc3QgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgICAgZWxzZSBub2RlLnRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIG5vZGUuY29uc2VxdWVudCA9IHBhcnNlQ29tcEl0ZXIoZXhwciwgZmFsc2UpO1xuICAgICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgICB9IGVsc2UgdW5leHBlY3RlZCgpO1xuICB9XG5cbiAgLy8gUGFyc2UgY2xhc3NcblxuICBmdW5jdGlvbiBwYXJzZUNsYXNzKGN0b3JOb2RlKSB7XG4gICAgLy8gQ29udGFpbmVyIGZvciBjbGFzcyBjb25zdHJ1Y3RvciBhbmQgcHJvdG90eXBlIGZ1bmN0aW9uc1xuICAgIHZhciBjb250YWluZXIgPSBzdGFydE5vZGVGcm9tKGN0b3JOb2RlKTtcbiAgICBjb250YWluZXIuYm9keSA9IFtdO1xuXG4gICAgLy8gUGFyc2UgY2xhc3Mgc2lnbmF0dXJlXG4gICAgY3Rvck5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG4gICAgY3Rvck5vZGUucGFyYW1zID0gW107XG4gICAgdmFyIGNsYXNzUGFyYW1zID0gW107XG4gICAgaWYgKGVhdChfcGFyZW5MKSkge1xuICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlICghZWF0KF9wYXJlblIpKSB7XG4gICAgICAgIGlmICghZmlyc3QpIGV4cGVjdChfY29tbWEpOyBlbHNlIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGNsYXNzUGFyYW1zLnB1c2gocGFyc2VJZGVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsYXNzUGFyYW1zLmxlbmd0aCA+IDEpIHJhaXNlKHRva1BvcywgXCJNdWx0aXBsZSBpbmhlcml0YW5jZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIGV4cGVjdChfY29sb24pO1xuXG4gICAgLy8gU3RhcnQgbmV3IG5hbWVzcGFjZSBmb3IgY2xhc3MgYm9keVxuICAgIHNjb3BlLnN0YXJ0Q2xhc3MoY3Rvck5vZGUuaWQubmFtZSk7XG5cbiAgICAvLyBTYXZlIGEgcmVmZXJlbmNlIGZvciBzb3VyY2UgcmFuZ2VzXG4gICAgdmFyIGNsYXNzQm9keVJlZk5vZGUgPSBmaW5pc2hOb2RlKHN0YXJ0Tm9kZSgpKTtcblxuICAgIC8vIFBhcnNlIGNsYXNzIGJvZHlcbiAgICB2YXIgY2xhc3NCbG9jayA9IHBhcnNlU3VpdGUoKTtcblxuICAgIC8vIEdlbmVyYXRlIGFkZGl0aW9uYWwgQVNUIHRvIGltcGxlbWVudCBjbGFzc1xuICAgIHZhciBjbGFzc1N0bXQgPSBuYy5jcmVhdGVDbGFzcyhjb250YWluZXIsIGN0b3JOb2RlLCBjbGFzc1BhcmFtcywgY2xhc3NCb2R5UmVmTm9kZSwgY2xhc3NCbG9jayk7XG5cbiAgICBzY29wZS5lbmQoKTtcblxuICAgIHJldHVybiBjbGFzc1N0bXQ7XG4gIH1cblxuICAvLyBQYXJzZSBkaWN0aW9uYXJ5XG4gIC8vIEN1c3RvbSBkaWN0IG9iamVjdCB1c2VkIHRvIHNpbXVsYXRlIG5hdGl2ZSBQeXRob24gZGljdFxuICAvLyBFLmcuIFwieydrMSc6J3YxJywgJ2syJzondjInfVwiIGJlY29tZXMgXCJuZXcgX19weXRob25SdW50aW1lLm9iamVjdHMuZGljdChbJ2sxJywgJ3YxJ10sIFsnazInLCAndjInXSk7XCJcblxuICBmdW5jdGlvbiBwYXJzZURpY3QodG9rQ2xvc2UpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIGtleSwgdmFsdWU7XG4gICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICBuZXh0KCk7XG4gICAgd2hpbGUgKCFlYXQodG9rQ2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgfSBlbHNlIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0b2tDbG9zZSA9PT0gX2JyYWNlUikge1xuICAgICAgICBrZXkgPSBwYXJzZVByb3BlcnR5TmFtZSgpO1xuICAgICAgICBleHBlY3QoX2NvbG9uKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUV4cHJPcHMoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0b2tDbG9zZSA9PT0gX3BhcmVuUikge1xuICAgICAgICB2YXIga2V5SWQgPSBwYXJzZUlkZW50KHRydWUpO1xuICAgICAgICBrZXkgPSBzdGFydE5vZGVGcm9tKGtleUlkKTtcbiAgICAgICAga2V5LnZhbHVlID0ga2V5SWQubmFtZTtcbiAgICAgICAgZmluaXNoTm9kZShrZXksIFwiTGl0ZXJhbFwiKTtcbiAgICAgICAgZXhwZWN0KF9lcSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VFeHByT3BzKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB1bmV4cGVjdGVkKCk7XG4gICAgICBub2RlLmFyZ3VtZW50cy5wdXNoKG5jLmNyZWF0ZU5vZGVTcGFuKGtleSwgdmFsdWUsIFwiQXJyYXlFeHByZXNzaW9uXCIsIHsgZWxlbWVudHM6IFtrZXksIHZhbHVlXSB9KSk7XG4gICAgfVxuICAgIGZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpO1xuXG4gICAgdmFyIHJ1bnRpbWVJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IG9wdGlvbnMucnVudGltZVBhcmFtTmFtZSB9KTtcbiAgICB2YXIgb2JqZWN0c0lkID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJvYmplY3RzXCIgfSk7XG4gICAgdmFyIHJ1bnRpbWVNZW1iZXIgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IHJ1bnRpbWVJZCwgcHJvcGVydHk6IG9iamVjdHNJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgIHZhciBsaXN0SWQgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBcImRpY3RcIiB9KTtcbiAgICBub2RlLmNhbGxlZSA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogcnVudGltZU1lbWJlciwgcHJvcGVydHk6IGxpc3RJZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb3BlcnR5TmFtZSgpIHtcbiAgICBpZiAodG9rVHlwZSA9PT0gX251bSB8fCB0b2tUeXBlID09PSBfc3RyaW5nKSByZXR1cm4gcGFyc2VFeHByQXRvbSgpO1xuICAgIHJldHVybiBwYXJzZUlkZW50KHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihub2RlKSB7XG4gICAgLy8gVE9ETzogVGhlIG5vZGUgY3JlYXRpb24gdXRpbGl0aWVzIHVzZWQgaGVyZSBhcmUgdGlnaHRseSBjb3VwbGVkIChlLmcuIHZhcmlhYmxlIG5hbWVzKVxuXG4gICAgdmFyIHN1ZmZpeCA9IG5ld0FzdElkQ291bnQrKztcbiAgICBub2RlLmlkID0gcGFyc2VJZGVudCgpO1xuICAgIG5vZGUucGFyYW1zID0gW107XG5cbiAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzXG5cbiAgICB2YXIgZm9ybWFscyA9IFtdOyAgICAgLy8gSW4gb3JkZXIsIG1heWJlIHdpdGggZGVmYXVsdCB2YWx1ZVxuICAgIHZhciBhcmdzSWQgPSBudWxsOyAgICAvLyAqYXJnc1xuICAgIHZhciBrd2FyZ3NJZCA9IG51bGw7ICAvLyAqKmt3YXJnc1xuICAgIHZhciBkZWZhdWx0c0ZvdW5kID0gZmFsc2U7XG4gICAgdmFyIGZpcnN0ID0gdHJ1ZTtcblxuICAgIHNjb3BlLnN0YXJ0Rm4obm9kZS5pZC5uYW1lKTtcblxuICAgIGV4cGVjdChfcGFyZW5MKTtcbiAgICB3aGlsZSAoIWVhdChfcGFyZW5SKSkge1xuICAgICAgaWYgKCFmaXJzdCkgZXhwZWN0KF9jb21tYSk7IGVsc2UgZmlyc3QgPSBmYWxzZTtcbiAgICAgIGlmICh0b2tWYWwgPT09ICcqJykge1xuICAgICAgICBpZiAoa3dhcmdzSWQpIHJhaXNlKHRva1BvcywgXCJpbnZhbGlkIHN5bnRheFwiKTtcbiAgICAgICAgbmV4dCgpOyBhcmdzSWQgPSBwYXJzZUlkZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKHRva1ZhbCA9PT0gJyoqJykge1xuICAgICAgICBuZXh0KCk7IGt3YXJnc0lkID0gcGFyc2VJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGt3YXJnc0lkKSByYWlzZSh0b2tQb3MsIFwiaW52YWxpZCBzeW50YXhcIik7XG4gICAgICAgIHZhciBwYXJhbUlkID0gcGFyc2VJZGVudCgpO1xuICAgICAgICBpZiAoZWF0KF9lcSkpIHtcbiAgICAgICAgICBmb3JtYWxzLnB1c2goeyBpZDogcGFyYW1JZCwgZXhwcjogcGFyc2VFeHByT3BzKGZhbHNlKSB9KTtcbiAgICAgICAgICBkZWZhdWx0c0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdHNGb3VuZCkgcmFpc2UodG9rUG9zLCBcIm5vbi1kZWZhdWx0IGFyZ3VtZW50IGZvbGxvd3MgZGVmYXVsdCBhcmd1bWVudFwiKTtcbiAgICAgICAgICBpZiAoYXJnc0lkKSByYWlzZSh0b2tQb3MsIFwibWlzc2luZyByZXF1aXJlZCBrZXl3b3JkLW9ubHkgYXJndW1lbnRcIik7XG4gICAgICAgICAgZm9ybWFscy5wdXNoKHsgaWQ6IHBhcmFtSWQsIGV4cHI6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuYWRkVmFyKHBhcmFtSWQubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV4cGVjdChfY29sb24pO1xuXG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgLy8gYGluRnVuY3Rpb25gIHVzZWQgdG8gdGhyb3cgc3ludGF4IGVycm9yIGZvciBzdHJheSBgcmV0dXJuYFxuICAgIHZhciBvbGRJbkZ1bmMgPSBpbkZ1bmN0aW9uID0gdHJ1ZTtcblxuICAgIC8vIElmIGNsYXNzIG1ldGhvZCwgcmVtb3ZlIGNsYXNzIGluc3RhbmNlIHZhciBmcm9tIHBhcmFtcyBhbmQgc2F2ZSBmb3IgJ3RoaXMnIHJlcGxhY2VtZW50XG4gICAgaWYgKHNjb3BlLmlzUGFyZW50Q2xhc3MoKSkge1xuICAgICAgdmFyIHNlbGZJZCA9IGZvcm1hbHMuc2hpZnQoKTtcbiAgICAgIHNjb3BlLnNldFRoaXNSZXBsYWNlKHNlbGZJZC5pZC5uYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IHBhcnNlU3VpdGUoKTtcbiAgICBub2RlLmJvZHkgPSBuYy5jcmVhdGVOb2RlU3Bhbihib2R5LCBib2R5LCBcIkJsb2NrU3RhdGVtZW50XCIsIHsgYm9keTogW10gfSk7XG5cbiAgICAvLyBBZGQgcnVudGltZSBwYXJhbWV0ZXIgcHJvY2Vzc2luZ1xuICAgIC8vIFRoZSBjYWxsZXIgbWF5IHBhc3MgYSBjb21wbGV4IHBhcmFtZXRlciBvYmplY3QgYXMgYSBzaW5nbGUgcGFyYW1ldGVyIGxpa2UgdGhpczpcbiAgICAvLyB7Zm9ybWFsczpbPGV4cHI+LCA8ZXhwcj4sIC4uLl0sIGtleXdvcmRzOns8aWQ+OjxleHByPiwgPGlkPjo8ZXhwcj4sIC4uLn19XG5cbiAgICB2YXIgciA9IG5vZGUuaWQ7XG4gICAgdmFyIF9faGFzUGFyYW1zID0gbmMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogJ19faGFzUGFyYW1zJyArIHN1ZmZpeCB9KTtcbiAgICB2YXIgX19wYXJhbXMgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiAnX19wYXJhbXMnICsgc3VmZml4IH0pO1xuICAgIHZhciBfX3JlYWxBcmdDb3VudCA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6ICdfX3JlYWxBcmdDb3VudCcgKyBzdWZmaXggfSk7XG5cbiAgICBpZiAoZm9ybWFscy5sZW5ndGggPiAwIHx8IGFyZ3NJZCB8fCBrd2FyZ3NJZCkge1xuICAgICAgdmFyIGFyZ3VtZW50c0xlbiA9IG5jLmNyZWF0ZU5vZGVTcGFuKHIsIHIsIFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7XG4gICAgICAgIG9wZXJhdG9yOiAnLScsXG4gICAgICAgIGxlZnQ6IG5jLmNyZWF0ZU5vZGVNZW1iSWRzKHIsICdhcmd1bWVudHMnLCAnbGVuZ3RoJyksXG4gICAgICAgIHJpZ2h0OiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkxpdGVyYWxcIiwgeyB2YWx1ZTogMSB9KVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBhcmd1bWVudHNOID0gbmMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgY29tcHV0ZWQ6IHRydWUsIG9iamVjdDogbmMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogJ2FyZ3VtZW50cycgfSksXG4gICAgICAgIHByb3BlcnR5OiBhcmd1bWVudHNMZW5cbiAgICAgIH0pO1xuXG4gICAgICAvLyB2YXIgX19oYXNQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLmZvcm1hbHMgJiYgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0ua2V5d29yZHM7XG4gICAgICB2YXIgc2V0SGFzUGFyYW1zID0gbmMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJMb2dpY2FsRXhwcmVzc2lvblwiLCB7XG4gICAgICAgIG9wZXJhdG9yOiAnJiYnLFxuICAgICAgICBsZWZ0OiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICBvcGVyYXRvcjogJyYmJyxcbiAgICAgICAgICBsZWZ0OiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6ICc+JyxcbiAgICAgICAgICAgIGxlZnQ6IG5jLmNyZWF0ZU5vZGVNZW1iSWRzKHIsICdhcmd1bWVudHMnLCAnbGVuZ3RoJyksXG4gICAgICAgICAgICByaWdodDogbmMuY3JlYXRlTm9kZVNwYW4ociwgciwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IDAgfSlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByaWdodDogYXJndW1lbnRzTlxuICAgICAgICB9KSxcbiAgICAgICAgcmlnaHQ6IG5jLmNyZWF0ZU5vZGVTcGFuKHIsIHIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLCBvYmplY3Q6IGFyZ3VtZW50c04sXG4gICAgICAgICAgcHJvcGVydHk6IG5jLmNyZWF0ZU5vZGVTcGFuKHIsIHIsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6ICdrZXl3b3JkcycgfSksXG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgbm9kZS5ib2R5LmJvZHkucHVzaChuYy5jcmVhdGVHZW5lcmF0ZWRWYXJEZWNsRnJvbUlkKHIsIF9faGFzUGFyYW1zLCBzZXRIYXNQYXJhbXMpKTtcblxuICAgICAgLy92YXIgX19wYXJhbXMgPSBfX2hhc1BhcmFtcyA/IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ua2V5d29yZHMgOiB7fTtcbiAgICAgIHZhciBzZXRQYXJhbXMgPSBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7XG4gICAgICAgIHRlc3Q6IF9faGFzUGFyYW1zLFxuICAgICAgICBjb25zZXF1ZW50OiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSwgb2JqZWN0OiBhcmd1bWVudHNOLFxuICAgICAgICAgIHByb3BlcnR5OiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiAna2V5d29yZHMnIH0pLFxuICAgICAgICB9KSxcbiAgICAgICAgYWx0ZXJuYXRlOiBuYy5jcmVhdGVOb2RlU3BhbihyLCByLCBcIk9iamVjdEV4cHJlc3Npb25cIiwgeyBwcm9wZXJ0aWVzOiBbXSB9KVxuICAgICAgfSk7XG4gICAgICBub2RlLmJvZHkuYm9keS5wdXNoKG5jLmNyZWF0ZUdlbmVyYXRlZFZhckRlY2xGcm9tSWQociwgX19wYXJhbXMsIHNldFBhcmFtcykpO1xuXG4gICAgICAvLyB2YXIgX19yZWFsQXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gX19wYXJhbXMwID8gMCA6IDE7XG4gICAgICB2YXIgc2V0UmVhbEFyZ0NvdW50ID0gKG5jLmNyZWF0ZUdlbmVyYXRlZFZhckRlY2xGcm9tSWQobm9kZS5pZCxcbiAgICAgICAgX19yZWFsQXJnQ291bnQsXG4gICAgICAgIG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiQmluYXJ5RXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgb3BlcmF0b3I6ICctJyxcbiAgICAgICAgICBsZWZ0OiBuYy5jcmVhdGVOb2RlTWVtYklkcyhub2RlLmlkLCAnYXJndW1lbnRzJywgJ2xlbmd0aCcpLFxuICAgICAgICAgIC8vcmlnaHQ6IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiTGl0ZXJhbFwiLCB7IHZhbHVlOiAwIH0pXG4gICAgICAgICAgcmlnaHQ6IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgIHRlc3Q6IF9faGFzUGFyYW1zLFxuICAgICAgICAgICAgY29uc2VxdWVudDogbmMuY3JlYXRlTm9kZVNwYW4obm9kZS5pZCwgbm9kZS5pZCwgXCJMaXRlcmFsXCIsIHsgdmFsdWU6IDEgfSksXG4gICAgICAgICAgICBhbHRlcm5hdGU6IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiTGl0ZXJhbFwiLCB7IHZhbHVlOiAwIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICkpO1xuXG4gICAgICBub2RlLmJvZHkuYm9keS5wdXNoKHNldFJlYWxBcmdDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXMgYXJlIG5vdCByZXBlYXRlZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWFscy5sZW5ndGg7ICsraSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaChmb3JtYWxzW2ldLmlkKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSBpZiAoZm9ybWFsc1tpXS5pZC5uYW1lID09PSBmb3JtYWxzW2pdLmlkLm5hbWUpXG4gICAgICAgIHJhaXNlKGZvcm1hbHNbaV0uaWQuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTtcbiAgICB9XG5cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgZm9ybWFscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZ05hbWUgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBmb3JtYWxzW2ldLmlkLm5hbWUgfSk7XG4gICAgICB2YXIgYXJnTmFtZVN0ciA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiTGl0ZXJhbFwiLCB7IHZhbHVlOiBmb3JtYWxzW2ldLmlkLm5hbWUgfSk7XG4gICAgICB2YXIgYXJnU2V0ID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZS5pZCwgbm9kZS5pZCwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7XG4gICAgICAgIG9wZXJhdG9yOiAnPScsXG4gICAgICAgIGxlZnQ6IGFyZ05hbWUsXG4gICAgICAgIHJpZ2h0OiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgdGVzdDogbmMuY3JlYXRlTm9kZVNwYW4obm9kZS5pZCwgbm9kZS5pZCwgXCJCaW5hcnlFeHByZXNzaW9uXCIsIHsgb3BlcmF0b3I6ICdpbicsIGxlZnQ6IGFyZ05hbWVTdHIsIHJpZ2h0OiBfX3BhcmFtcyB9KSxcbiAgICAgICAgICBjb25zZXF1ZW50OiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgeyBvYmplY3Q6IF9fcGFyYW1zLCBwcm9wZXJ0eTogYXJnTmFtZVN0ciwgY29tcHV0ZWQ6IHRydWUgfSksXG4gICAgICAgICAgYWx0ZXJuYXRlOiBmb3JtYWxzW2ldLmV4cHIgPyBmb3JtYWxzW2ldLmV4cHIgOiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiAndW5kZWZpbmVkJyB9KVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBhcmdDaGVjayA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiSWZTdGF0ZW1lbnRcIiwge1xuICAgICAgICB0ZXN0OiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICAgICAgICAgIG9wZXJhdG9yOiAnPCcsXG4gICAgICAgICAgbGVmdDogX19yZWFsQXJnQ291bnQsXG4gICAgICAgICAgcmlnaHQ6ICBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIkxpdGVyYWxcIiwgeyB2YWx1ZTogaSsxIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBjb25zZXF1ZW50OiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgeyBleHByZXNzaW9uOiBhcmdTZXQgfSlcbiAgICAgIH0pO1xuXG4gICAgICBub2RlLmJvZHkuYm9keS5wdXNoKGFyZ0NoZWNrKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0lkKSB7XG4gICAgICAvLyB2YXIgX19mb3JtYWxzSW5kZXggPSBuO1xuICAgICAgbm9kZS5ib2R5LmJvZHkucHVzaChuYy5jcmVhdGVHZW5lcmF0ZWRWYXJEZWNsRnJvbUlkKG5vZGUuaWQsXG4gICAgICAgIG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6ICdfX2Zvcm1hbHNJbmRleCcgKyBzdWZmaXggfSksXG4gICAgICAgIG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUuaWQsIG5vZGUuaWQsIFwiTGl0ZXJhbFwiLCB7IHZhbHVlOiBmb3JtYWxzLmxlbmd0aCB9KSkpO1xuXG4gICAgICAvLyB2YXIgPGFyZ3M+ID0gW107XG4gICAgICB2YXIgYXJnc0Fzc2lnbiA9IG5jLmNyZWF0ZUdlbmVyYXRlZFZhckRlY2xGcm9tSWQoYXJnc0lkLCBhcmdzSWQsIG5jLmNyZWF0ZU5vZGVTcGFuKGFyZ3NJZCwgYXJnc0lkLCBcIkFycmF5RXhwcmVzc2lvblwiLCB7IGVsZW1lbnRzOiBbXSB9KSk7XG4gICAgICBub2RlLmJvZHkuYm9keS5wdXNoKGFyZ3NBc3NpZ24pO1xuICAgICAgbm9kZS5ib2R5LmJvZHkucHVzaChuYy5jcmVhdGVOb2RlQXJnc1doaWxlQ29uc2VxdWVudChhcmdzSWQsIHN1ZmZpeCkpO1xuICAgICAgXG4gICAgfVxuXG4gICAgaWYgKGt3YXJnc0lkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZvcm1hbERlbGV0ZSA9IG5jLmNyZWF0ZU5vZGVTcGFuKGt3YXJnc0lkLCBrd2FyZ3NJZCwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtcbiAgICAgICAgICBleHByZXNzaW9uOiBuYy5jcmVhdGVOb2RlU3Bhbihrd2FyZ3NJZCwga3dhcmdzSWQsIFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcbiAgICAgICAgICAgIGFyZ3VtZW50OiBuYy5jcmVhdGVOb2RlU3Bhbihrd2FyZ3NJZCwga3dhcmdzSWQsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gICAgICAgICAgICAgIG9iamVjdDogX19wYXJhbXMsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLmlkLCBub2RlLmlkLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBmb3JtYWxzW2ldLmlkLm5hbWUgfSksXG4gICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuYm9keS5ib2R5LnB1c2goZm9ybWFsRGVsZXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gdmFyIDxrd2FyZ3M+ID0ge307XG4gICAgICB2YXIga3dhcmdzQXNzaWduID0gbmMuY3JlYXRlR2VuZXJhdGVkVmFyRGVjbEZyb21JZChrd2FyZ3NJZCwga3dhcmdzSWQsIF9fcGFyYW1zKTtcbiAgICAgIG5vZGUuYm9keS5ib2R5LnB1c2goa3dhcmdzQXNzaWduKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IG9yaWdpbmFsIGJvZHkgdG8gJ3JldHVybiAoZnVuY3Rpb24oKSB7PGJvZHk+fSkuY2FsbCh0aGlzKTsnO1xuICAgIC8vbm9kZS5ib2R5LmJvZHkucHVzaChuYy5jcmVhdGVOb2RlRm5Cb2R5SWlmZShib2R5KSk7XG5cbiAgICAvL0FwcGVuZCByZWFsIGJvZHkgdG8gbm9kZVxuICAgIG5vZGUuYm9keS5ib2R5LnB1c2guYXBwbHkobm9kZS5ib2R5LmJvZHksIGJvZHkuYm9keSk7XG5cbiAgICBpbkZ1bmN0aW9uID0gb2xkSW5GdW5jO1xuXG5cbiAgICAvLyBJZiBjbGFzcyBtZXRob2QsIHJlcGxhY2Ugd2l0aCBwcm90b3R5cGUgZnVuY3Rpb24gbGl0ZXJhbHNcbiAgICB2YXIgcmV0Tm9kZTtcbiAgICBpZiAoc2NvcGUuaXNQYXJlbnRDbGFzcygpKSB7XG4gICAgICBmaW5pc2hOb2RlKG5vZGUpO1xuICAgICAgdmFyIGNsYXNzSWQgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBzY29wZS5nZXRQYXJlbnRDbGFzc05hbWUoKSB9KTtcbiAgICAgIHZhciBwcm90b3R5cGVJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwicHJvdG90eXBlXCIgfSk7XG4gICAgICB2YXIgZnVuY3Rpb25JZCA9IG5vZGUuaWQ7XG4gICAgICB2YXIgcHJvdG90eXBlTWVtYmVyID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBjbGFzc0lkLCBwcm9wZXJ0eTogcHJvdG90eXBlSWQsIGNvbXB1dGVkOiBmYWxzZSB9KTtcbiAgICAgIHZhciBmdW5jdGlvbk1lbWJlciA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCB7IG9iamVjdDogcHJvdG90eXBlTWVtYmVyLCBwcm9wZXJ0eTogZnVuY3Rpb25JZCwgY29tcHV0ZWQ6IGZhbHNlIH0pO1xuICAgICAgdmFyIGZ1bmN0aW9uRXhwciA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIHsgYm9keTogbm9kZS5ib2R5LCBwYXJhbXM6IG5vZGUucGFyYW1zIH0pO1xuICAgICAgdmFyIGFzc2lnbkV4cHIgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIHsgbGVmdDogZnVuY3Rpb25NZW1iZXIsIG9wZXJhdG9yOiBcIj1cIiwgcmlnaHQ6IGZ1bmN0aW9uRXhwciB9KTtcbiAgICAgIHJldE5vZGUgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgeyBleHByZXNzaW9uOiBhc3NpZ25FeHByIH0pO1xuICAgIH0gZWxzZSByZXROb2RlID0gZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIik7XG5cbiAgICBzY29wZS5lbmQoKTtcblxuICAgIHJldHVybiByZXROb2RlO1xuICB9XG5cbiAgLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbiAgLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbiAgLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuICAvLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbiAgLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHkpIHtcbiAgICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCFlYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGV4cGVjdChfY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIG9wdGlvbnMuYWxsb3dUcmFpbGluZ0NvbW1hcyAmJiBlYXQoY2xvc2UpKSBicmVhaztcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0b2tUeXBlID09PSBfY29tbWEpIGVsdHMucHVzaChudWxsKTtcbiAgICAgIGVsc2UgZWx0cy5wdXNoKHBhcnNlRXhwck9wcyhmYWxzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGFyYW1zTGlzdCgpIHtcbiAgICAvLyBJbjogZXhwciwgZXhwciwgLi4uLCBpZD1leHByLCBpZD1leHByLCAuLi5cbiAgICAvLyBPdXQ6IGV4cHIsIGV4cHIsIC4uLiwge2lkOmV4cHIsIF9fa3dwOnRydWV9LCB7aWQ6ZXhwciwgX19rd3A6dHJ1ZX0sIC4uLlxuICAgIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIWVhdChfcGFyZW5SKSkge1xuICAgICAgaWYgKCFmaXJzdCkgZXhwZWN0KF9jb21tYSk7XG4gICAgICBlbHNlIGZpcnN0ID0gZmFsc2U7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlRXhwck9wcyhmYWxzZSk7XG4gICAgICBpZiAoZWF0KF9lcSkpIHtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFyc2VFeHByT3BzKGZhbHNlKTtcbiAgICAgICAgdmFyIGt3SWQgPSBuYy5jcmVhdGVOb2RlU3BhbihleHByLCByaWdodCwgXCJJZGVudGlmaWVyXCIsIHtuYW1lOlwiX19rd3BcIn0pO1xuICAgICAgICB2YXIga3dMaXQgPSBuYy5jcmVhdGVOb2RlU3BhbihleHByLCByaWdodCwgXCJMaXRlcmFsXCIsIHt2YWx1ZTp0cnVlfSk7XG4gICAgICAgIHZhciBsZWZ0ID0gbmMuY3JlYXRlTm9kZVNwYW4oZXhwciwgcmlnaHQsIFwiT2JqZWN0RXhwcmVzc2lvblwiLCB7IHByb3BlcnRpZXM6IFtdIH0pO1xuICAgICAgICBsZWZ0LmlzbnRGb3JtYWwgPSB0cnVlO1xuICAgICAgICBsZWZ0LnByb3BlcnRpZXMucHVzaCh7IHR5cGU6IFwiUHJvcGVydHlcIiwga2V5OiBleHByLCB2YWx1ZTogcmlnaHQsIGtpbmQ6IFwiaW5pdFwiIH0pO1xuICAgICAgICBsZWZ0LnByb3BlcnRpZXMucHVzaCh7IHR5cGU6IFwiUHJvcGVydHlcIiwga2V5OiBrd0lkLCB2YWx1ZToga3dMaXQsIGtpbmQ6IFwiaW5pdFwiIH0pO1xuICAgICAgICBleHByID0gbGVmdDtcbiAgICAgIH1cbiAgICAgIGVsdHMucHVzaChleHByKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cblxuICAvLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuICAvLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbiAgLy8gaWRlbnRpZmllcnMuXG5cbiAgLy8gVE9ETzogbGliZXJhbD9cblxuICBmdW5jdGlvbiBwYXJzZUlkZW50KGxpYmVyYWwpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuICAgIGlmIChsaWJlcmFsKSBsaWJlcmFsID0gZmFsc2U7XG4gICAgaWYgKHRva1R5cGUgPT09IF9uYW1lKSB7XG4gICAgICBpZiAoIWxpYmVyYWwgJiYgc3RyaWN0ICYmIGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpLmluZGV4T2YoXCJcXFxcXCIpID09IC0xKVxuICAgICAgICByYWlzZSh0b2tTdGFydCwgXCJUaGUga2V5d29yZCAnXCIgKyB0b2tWYWwgKyBcIicgaXMgcmVzZXJ2ZWRcIik7XG4gICAgICBub2RlLm5hbWUgPSB0b2tWYWw7XG4gICAgfSBlbHNlIGlmIChsaWJlcmFsICYmIHRva1R5cGUua2V5d29yZCkge1xuICAgICAgbm9kZS5uYW1lID0gdG9rVHlwZS5rZXl3b3JkO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRva1JlZ2V4cEFsbG93ZWQgPSBmYWxzZTtcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUdXBsZShub0luLCBleHByKSB7XG4gICAgdmFyIG5vZGUgPSBleHByID8gc3RhcnROb2RlRnJvbShleHByKSA6IHN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuYXJndW1lbnRzID0gZXhwciA/IFtleHByXSA6IFtdO1xuXG4gICAgLy8gVHVwbGUgd2l0aCBzaW5nbGUgZWxlbWVudCBoYXMgc3BlY2lhbCB0cmFpbGluZyBjb21tYTogdCA9ICdoaScsXG4gICAgLy8gTG9vayBhaGVhZCBhbmQgZWF0IGNvbW1hIGluIHRoaXMgc2NlbmFyaW9cbiAgICBpZiAodG9rVHlwZSA9PT0gX2NvbW1hKSB7XG4gICAgICB2YXIgb2xkUG9zID0gdG9rUG9zOyBza2lwU3BhY2UoKTtcbiAgICAgIHZhciBuZXdQb3MgPSB0b2tQb3M7IHRva1BvcyA9IG9sZFBvcztcbiAgICAgIGlmIChuZXdQb3MgPj0gaW5wdXRMZW4gfHwgaW5wdXRbbmV3UG9zXSA9PT0gJzsnIHx8IGlucHV0W25ld1Bvc10gPT09ICcpJyB8fCBuZXdsaW5lLnRlc3QoaW5wdXRbbmV3UG9zXSkpXG4gICAgICAgIGVhdChfY29tbWEpO1xuICAgIH1cblxuICAgIHdoaWxlIChlYXQoX2NvbW1hKSkge1xuICAgICAgbm9kZS5hcmd1bWVudHMucHVzaChwYXJzZUV4cHJPcHMobm9JbikpO1xuICAgIH1cbiAgICBmaW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcblxuICAgIHZhciBydW50aW1lSWQgPSBuYy5jcmVhdGVOb2RlU3Bhbihub2RlLCBub2RlLCBcIklkZW50aWZpZXJcIiwgeyBuYW1lOiBvcHRpb25zLnJ1bnRpbWVQYXJhbU5hbWUgfSk7XG4gICAgdmFyIG9iamVjdHNJZCA9IG5jLmNyZWF0ZU5vZGVTcGFuKG5vZGUsIG5vZGUsIFwiSWRlbnRpZmllclwiLCB7IG5hbWU6IFwib2JqZWN0c1wiIH0pO1xuICAgIHZhciBydW50aW1lTWVtYmVyID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lSWQsIHByb3BlcnR5OiBvYmplY3RzSWQsIGNvbXB1dGVkOiBmYWxzZSB9KTtcbiAgICB2YXIgbGlzdElkID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJJZGVudGlmaWVyXCIsIHsgbmFtZTogXCJ0dXBsZVwiIH0pO1xuICAgIG5vZGUuY2FsbGVlID0gbmMuY3JlYXRlTm9kZVNwYW4obm9kZSwgbm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHsgb2JqZWN0OiBydW50aW1lTWVtYmVyLCBwcm9wZXJ0eTogbGlzdElkLCBjb21wdXRlZDogZmFsc2UgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vICMjIFB5dGhvbiBydW50aW1lIGxpYnJhcnlcblxuICB2YXIgcHl0aG9uUnVudGltZSA9IGV4cG9ydHMucHl0aG9uUnVudGltZSA9IHtcblxuICAgIC8vIFNoaW0gSmF2YVNjcmlwdCBvYmplY3RzIHRoYXQgaW1wZXJzb25hdGUgUHl0aG9uIGVxdWl2YWxlbnRzXG5cbiAgICAvLyBUT0RPOiB1c2UgJ3R5cGUnIG9yIGlzU2VxdWVuY2UgaW5zdGVhZCBvZiAnaW5zdGFuY2VvZiBBcnJheScgdG8gaWQgdGhlc2VcblxuICAgIGludGVybmFsOiB7XG4gICAgICAvLyBPbmx5IHVzZWQgd2l0aGluIHJ1bnRpbWVcbiAgICAgIGlzU2VxOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAmJiAoYS5fdHlwZSA9PT0gXCJsaXN0XCIgfHwgYS5fdHlwZSA9PT0gXCJ0dXBsZVwiKTsgfSxcbiAgICAgIHNsaWNlOiBmdW5jdGlvbiAob2JqLCBzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwID09IG51bGwgfHwgc3RlcCA9PT0gMCkgc3RlcCA9IDE7IC8vIFRPRE86IHN0ZXAgPT09IDAgaXMgYSBydW50aW1lIGVycm9yXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHN0ZXAgPCAwKSBzdGFydCA9IG9iai5sZW5ndGggLSAxO1xuICAgICAgICAgIGVsc2Ugc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgKz0gb2JqLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHN0ZXAgPCAwKSBlbmQgPSAtMTtcbiAgICAgICAgICBlbHNlIGVuZCA9IG9iai5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5kIDwgMCkgZW5kICs9IG9iai5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpLCB0bXAsIGk7XG4gICAgICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgICAgIHRtcCA9IG9iai5zbGljZShlbmQgKyAxLCBzdGFydCArIDEpO1xuICAgICAgICAgIGZvciAoaSA9IHRtcC5sZW5ndGggLSAxOyBpID49IDA7IGkgKz0gc3RlcCkgcmV0LmFwcGVuZCh0bXBbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcCA9IG9iai5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICBpZiAoc3RlcCA9PT0gMSkgcmV0ID0gcHl0aG9uUnVudGltZS51dGlscy5jcmVhdGVMaXN0KHRtcCk7XG4gICAgICAgICAgZWxzZSBmb3IgKGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSArPSBzdGVwKSByZXQuYXBwZW5kKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBpc0pTQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHV0aWxzOiB7XG4gICAgICBjcmVhdGVEaWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmRpY3QoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzWzBdKSByZXRba10gPSBhcmd1bWVudHNbMF1ba107XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjcmVhdGVEaWN0IGV4cGVjdHMgYSBzaW5nbGUgSmF2YVNjcmlwdCBvYmplY3RcIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUGFyYW1zT2JqOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluOiBleHByLCBleHByLCAuLi4sIHtpZDpleHByLCBfX2t3cDp0cnVlfSwge2lkOmV4cHIsIF9fa3dwOnRydWV9LCAuLi5cbiAgICAgICAgLy8gT3V0OiB7Zm9ybWFsczpbZXhwciwgZXhwciwgLi4uXSwga2V5d29yZHM6e2lkOmV4cHIsIGlkOmV4cHIsIC4uLn19XG4gICAgICAgIHZhciBwYXJhbXMgPSB7IGZvcm1hbHM6IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpLCBrZXl3b3JkczogbmV3IFB5dGhvbkRpY3QoKSB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gJiYgYXJndW1lbnRzW2ldLl9fa3dwID09PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGFyZ3VtZW50c1tpXSlcbiAgICAgICAgICAgICAgaWYgKGsgIT09ICdfX2t3cCcpIHBhcmFtcy5rZXl3b3Jkc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBwYXJhbXMuZm9ybWFscy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH0sXG4gICAgICBjb252ZXJ0VG9MaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsaXN0LCBweXRob25SdW50aW1lLnV0aWxzLmxpc3RQcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH0sXG4gICAgICBjb252ZXJ0VG9EaWN0OiBmdW5jdGlvbiAoZGljdCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkaWN0LCBweXRob25SdW50aW1lLnV0aWxzLmRpY3RQcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gZGljdDtcbiAgICAgIH0sIFxuICAgICAgbGlzdFByb3BlcnR5RGVzY3JpcHRvcjoge1xuICAgICAgICAgIFwiX3R5cGVcIjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAnbGlzdCc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJfaXNQeXRob25cIjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYXBwZW5kXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICB0aGlzLnB1c2goeCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImNvcHlcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiY291bnRcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB4KSBjKys7XG4gICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVxdWFsc1wiOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHgubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5oYXNPd25Qcm9wZXJ0eShcImVxdWFsc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbaV0uZXF1YWxzKHhbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gIT09IHhbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZXh0ZW5kXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoTCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEwubGVuZ3RoOyBpKyspIHRoaXMucHVzaChMW2ldKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbmRleFwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbmRleE9mXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleCA/IGZyb21JbmRleCA6IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5oYXNPd25Qcm9wZXJ0eShcImVxdWFsc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5lcXVhbHMoeCkpIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiaW5zZXJ0XCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaSwgeCkge1xuICAgICAgICAgICAgICB0aGlzLnNwbGljZShpLCAwLCB4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwb3BcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIGlmICghaSlcbiAgICAgICAgICAgICAgICBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJfcHlTbGljZVwiOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHB5dGhvblJ1bnRpbWUuaW50ZXJuYWwuc2xpY2UodGhpcywgc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlXCI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICB0aGlzLnNwbGljZSh0aGlzLmluZGV4T2YoeCksIDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNvcnRcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHgsIHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgdmFyIGxpc3QyID0gdGhpcy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgdmFyIGFwcGx5X2tleSA9IGZ1bmN0aW9uKGEsIG51bWVyaWNhbCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0MyA9IGxpc3QyLm1hcCh4KTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3QgYSBkaWN0IHRoYXQgbWFwcyB0aGUgbGlzdGF5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1hcFxuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0ge31cbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gbGlzdDMpIG1hcHBpbmdbbGlzdDNbaV1dID0gbGlzdDJbaV07XG4gICAgICAgICAgICAgICAgaWYobnVtZXJpY2FsKVxuICAgICAgICAgICAgICAgICAgbGlzdDMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbGlzdDMuc29ydCgpXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGEpIGFbaV0gPSBtYXBwaW5nW2xpc3QzW2ldXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzW2ldICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodGhpc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB4ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5X2tleSh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdDIuc29ydCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIHRoaXMpIHRoaXNbal0gPSBsaXN0MltqXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmKHJldmVyc2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZih0eXBlb2YgeCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGFwcGx5X2tleSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0Mi5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gdGhpcykgdGhpc1tpXSA9IGxpc3QyW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJldmVyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidG9TdHJpbmdcIjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuam9pbignLCAnKSArICddJztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVMaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBhcmd1bWVudHNbMF0pIHJldC5wdXNoKGFyZ3VtZW50c1swXVtpXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBpIGluIGFyZ3VtZW50cykgcmV0LnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBkaWN0UHJvcGVydHlEZXNjcmlwdG9yOiB7XG4gICAgICAgIFwiX3R5cGVcIjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2RpY3QnO30sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJfaXNQeXRob25cIjoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMpIGl0ZW1zLmFwcGVuZChuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKGssIHRoaXNba10pKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVuZ3RoXCI6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5sZW5ndGg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSBkZWxldGUgdGhpc1tpXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGtleSwgZGVmKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIHRoaXMpIHJldHVybiB0aGlzW2tleV07XG4gICAgICAgICAgICBlbHNlIGlmIChkZWYgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3BcIjoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCBkZWYpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdGhpcykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmICE9PSB1bmRlZmluZWQpIHZhbHVlID0gZGVmO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gbmV3IEVycm9yKFwiS2V5RXJyb3JcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9LCBcInZhbHVlc1wiOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB2YWx1ZXMuYXBwZW5kKHRoaXNba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb3BzOiB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgcHl0aG9uUnVudGltZS5pbnRlcm5hbC5pc1NlcShhKSAmJiBweXRob25SdW50aW1lLmludGVybmFsLmlzU2VxKGIpKSB7XG4gICAgICAgICAgaWYgKGEuX3R5cGUgIT09IGIuX3R5cGUpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjYW4gb25seSBjb25jYXRlbmF0ZSBcIiArIGEuX3R5cGUgKyBcIiAobm90ICdcIiArIGIuX3R5cGUgKyBcIicpIHRvIFwiICsgYS5fdHlwZSk7XG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiAoYS5fdHlwZSA9PT0gJ2xpc3QnKSByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcbiAgICAgICAgICBlbHNlIGlmIChhLl90eXBlID09PSAndHVwbGUnKSByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKCk7XG4gICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSByZXQucHVzaChhW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykgcmV0LnB1c2goYltpXSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9LFxuICAgICAgaW46IGZ1bmN0aW9uIChhLCBiLCBuKSB7XG4gICAgICAgIHZhciByID0gYi5oYXNPd25Qcm9wZXJ0eSgnaW5kZXhPZicpID8gYi5pbmRleE9mKGEpID49IDAgOiBhIGluIGI7XG4gICAgICAgIHJldHVybiBuID8gIXIgOiByO1xuICAgICAgfSxcbiAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvLyBUT0RPOiBub24tc2VxdWVuY2Ugb3BlcmFuZCBtdXN0IGJlIGFuIGludGVnZXJcbiAgICAgICAgaWYgKCB0eXBlb2YgYSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgaWYgKHB5dGhvblJ1bnRpbWUuaW50ZXJuYWwuaXNTZXEoYSkgJiYgIWlzTmFOKHBhcnNlSW50KGIpKSkge1xuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIGlmIChhLl90eXBlID09PSAnbGlzdCcpIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuICAgICAgICAgICAgZWxzZSBpZiAoYS5fdHlwZSA9PT0gJ3R1cGxlJykgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy50dXBsZSgpO1xuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGI7IGkrKylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGEubGVuZ3RoOyBqKyspIHJldC5wdXNoKGFbal0pO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocHl0aG9uUnVudGltZS5pbnRlcm5hbC5pc1NlcShiKSAmJiAhaXNOYU4ocGFyc2VJbnQoYSkpKSB7XG4gICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgaWYgKGIuX3R5cGUgPT09ICdsaXN0JykgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG4gICAgICAgICAgICBlbHNlIGlmIChiLl90eXBlID09PSAndHVwbGUnKSByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKCk7XG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYTsgaSsrKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykgcmV0LnB1c2goYltqXSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhICogYjtcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRJbmRleDogZnVuY3Rpb24gKG8sIGkpIHtcbiAgICAgICAgaWYgKCBpID49IDAgKSByZXR1cm4gaTtcbiAgICAgICAgaWYgKCBweXRob25SdW50aW1lLmludGVybmFsLmlzU2VxKG8pICkgcmV0dXJuIG8ubGVuZ3RoICsgaTtcbiAgICAgICAgaWYgKCBweXRob25SdW50aW1lLmludGVybmFsLmlzSlNBcnJheShvKSApIHJldHVybiBvLmxlbmd0aCArIGk7XG4gICAgICAgIGlmICggdHlwZW9mIG8gPT09IFwic3RyaW5nXCIgKSByZXR1cm4gby5sZW5ndGggKyBpO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb2JqZWN0czoge1xuICAgICAgZGljdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JqID0gbmV3IFB5dGhvbkRpY3QoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kgKSBvYmpbYXJndW1lbnRzW2ldWzBdXSA9IGFyZ3VtZW50c1tpXVsxXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBsaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xuICAgICAgICBweXRob25SdW50aW1lLnV0aWxzLmNvbnZlcnRUb0xpc3QoYXJyKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICB0dXBsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIGFyci5wdXNoLmFwcGx5KGFyciwgYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJfdHlwZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAndHVwbGUnOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcIl9pc1B5dGhvblwiLFxuICAgICAgICB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcImNvdW50XCIsXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHgpIGMrKztcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnIsIFwiZXF1YWxzXCIsXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0geC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uaGFzT3duUHJvcGVydHkoXCJlcXVhbHNcIikpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpc1tpXS5lcXVhbHMoeFtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gIT09IHhbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyLCBcImluZGV4XCIsXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoeCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJpbmRleE9mXCIsXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHgsIGZyb21JbmRleCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleCA/IGZyb21JbmRleCA6IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uaGFzT3duUHJvcGVydHkoXCJlcXVhbHNcIikpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLmVxdWFscyh4KSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnIsIFwiX3B5U2xpY2VcIixcbiAgICAgICAge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgc3RlcCkgeyBcbiAgICAgICAgICAgIHJldHVybiBweXRob25SdW50aW1lLmludGVybmFsLnNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQsIHN0ZXApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJ0b1N0cmluZ1wiLFxuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzID0gJygnICsgdGhpcy5qb2luKCcsICcpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSBzICs9ICcsJztcbiAgICAgICAgICAgIHMgKz0gJyknO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUHl0aG9uIGJ1aWx0LWluIGZ1bmN0aW9uc1xuXG4gICAgZnVuY3Rpb25zOiB7XG4gICAgICBhYnM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgICAgfSxcbiAgICAgIGFsbDogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgaWYgKHB5dGhvblJ1bnRpbWUuZnVuY3Rpb25zLmJvb2woaXRlcmFibGVbaV0pICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGFueTogZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgaWYgKHB5dGhvblJ1bnRpbWUuZnVuY3Rpb25zLmJvb2woaXRlcmFibGVbaV0pID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGFzY2lpOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHMgPSBweXRob25SdW50aW1lLmZ1bmN0aW9ucy5yZXByKG9iaiksXG4gICAgICAgICAgICBhc2MgPSBcIlwiLFxuICAgICAgICAgICAgY29kZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29kZSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBpZiAoY29kZSA8PSAxMjcpIGFzYyArPSBzW2ldO1xuICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPD0gMHhGRikgYXNjICs9IFwiXFxcXHhcIiArIGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgIGVsc2UgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7IC8vIFVDUy0yIGZvciB0aGUgYXN0cmFsIGNoYXJzXG4gICAgICAgICAgICAvLyBpZiAoaSsxID49IHMubGVuZ3RoKSB0aHJvdyBcIkhpZ2ggc3Vycm9nYXRlIG5vdCBmb2xsb3dlZCBieSBsb3cgc3Vycm9nYXRlXCI7IC8vIElzIHRoaXMgbmVlZGVkP1xuICAgICAgICAgICAgY29kZSA9ICgoY29kZS0weEQ4MDApKjB4NDAwKSsocy5jaGFyQ29kZUF0KCsraSktMHhEQzAwKSsweDEwMDAwO1xuICAgICAgICAgICAgYXNjICs9IFwiXFxcXFVcIiArIChcIjAwMFwiK2NvZGUudG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDw9IDB4RkZGRikgYXNjICs9IFwiXFxcXHVcIiArIChcIjBcIitjb2RlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPD0gMHgxMEZGRkYpIGFzYyArPSBcIlxcXFxVXCIgKyAoXCIwMDBcIitjb2RlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuICAgICAgICAgIGVsc2U7IC8vIEludmFsaWQgdmFsdWUsIHNob3VsZCBwcm9iYWJseSB0aHJvdyBzb21ldGhpbmcuIEl0IHNob3VsZCBuZXZlciBnZXQgaGVyZSB0aG91Z2ggYXMgc3RyaW5ncyBzaG91bGRuJ3QgY29udGFpbiB0aGVtIGluIHRoZSBmaXJzdCBwbGFjZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc2M7XG4gICAgICB9LFxuICAgICAgYm9vbDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gISh4ID09PSB1bmRlZmluZWQgfHwgLy8gTm8gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgeCA9PT0gbnVsbCB8fCAvLyBOb25lXG4gICAgICAgICAgICAgICAgIHggPT09IGZhbHNlIHx8IC8vIEZhbHNlXG4gICAgICAgICAgICAgICAgIHggPT09IDAgfHwgLy8gWmVyb1xuICAgICAgICAgICAgICAgICB4Lmxlbmd0aCA9PT0gMCB8fCAvLyBFbXB0eSBTZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFbXB0eSBNYXBwaW5nLCBuZWVkcyBtb3JlIHN1cHBvcnQgZm9yIHB5dGhvbiBtYXBwaW5ncyBmaXJzdFxuICAgICAgICAgICAgICAgICAoeC5fX2Jvb2xfXyAhPT0gdW5kZWZpbmVkICYmIHguX19ib29sX18oKSA9PT0gZmFsc2UpIHx8IC8vIElmIGl0IGhhcyBib29sIGNvbnZlcnNpb24gZGVmaW5lZFxuICAgICAgICAgICAgICAgICAoeC5fX2xlbl9fICE9PSB1bmRlZmluZWQgJiYgKHguX19sZW5fXygpID09PSBmYWxzZSB8fCB4Ll9fbGVuX18oKSA9PT0gMCkpKTsgLy8gSWYgaXQgaGFzIGxlbmd0aCBjb252ZXJzaW9uIGRlZmluZWRcbiAgICAgIH0sXG4gICAgICBjaHI6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7IC8vIFRPRE86IEVycm9yIGNvZGUgZm9yIG5vdCAwIDw9IGkgPD0gMTExNDExMVxuICAgICAgfSxcbiAgICAgIGRpdm1vZDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gcHl0aG9uUnVudGltZS5vYmplY3RzLnR1cGxlKE1hdGguZmxvb3IoYS9iKSwgYSViKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhdGU6IGZ1bmN0aW9uKGl0ZXJhYmxlLCBzdGFydCkge1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgcmV0LnB1c2gobmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy50dXBsZShzdGFydCsrLCBpdGVyYWJsZVtpXSkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgIGZpbHRlcjogZnVuY3Rpb24oZm4sIGl0ZXJhYmxlKSB7XG4gICAgICAgIGZuID0gZm4gfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSBpZiAoZm4oaXRlcmFibGVbaV0pKSByZXQucHVzaChpdGVyYWJsZVtpXSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgZmxvYXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDAuMDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT0gXCJzdHJpbmdcIikgeyAvLyBUT0RPOiBGaXggdHlwZSBjaGVja1xuICAgICAgICAgIHggPSB4LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmICgoL15bKy1dP2luZihpbml0eSk/JC9pKS5leGVjKHgpICE9PSBudWxsKSByZXR1cm4gSW5maW5pdHkqKHhbMF09PT1cIi1cIj8tMToxKTtcbiAgICAgICAgICBlbHNlIGlmICgoL15uYW4kL2kpLmV4ZWMoeCkgIT09IG51bGwpIHJldHVybiBOYU47XG4gICAgICAgICAgZWxzZSByZXR1cm4gcGFyc2VGbG9hdCh4KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSBcIm51bWJlclwiKSB7IC8vIFRPRE86IEZpeCB0eXBlIGNoZWNrXG4gICAgICAgICAgcmV0dXJuIHg7IC8vIFRPRE86IEdldCBweXRob24gdHlwZXMgd29ya2luZyByaWdodCBzbyB3ZSBjYW4gcmV0dXJuIGFuIGFjdHVhbCBmbG9hdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4Ll9fZmxvYXRfXyAhPT0gdW5kZWZpbmVkKSByZXR1cm4geC5fX2Zsb2F0X18oKTtcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsOyAvLyBUT0RPOiBUaHJvdyBUeXBlRXJyb3I6IGZsb2F0KCkgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlciwgbm90ICc8dHlwZSBvZiB4PidcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhleDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygxNik7XG4gICAgICB9LFxuICAgICAgaW50OiBmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocyk7XG4gICAgICB9LFxuICAgICAgbGVuOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgbGlzdDogZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgcHl0aG9uUnVudGltZS5vYmplY3RzLmxpc3QoKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlIGluc3RhbmNlb2YgQXJyYXkpIGZvciAodmFyIGkgaW4gaXRlcmFibGUpIHJldC5wdXNoKGl0ZXJhYmxlW2ldKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQucHVzaChpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBtYXA6IGZ1bmN0aW9uKGZuLCBpdGVyYWJsZSkge1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFkZGl0aW9uYWwgaXRlcmFibGVzIHBhc3NlZFxuICAgICAgICB2YXIgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gaXRlcmFibGUpIHJldC5wdXNoKGZuKGl0ZXJhYmxlW2ldKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgbWF4OiBmdW5jdGlvbihhcmcxLCBhcmcyKSB7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3B0aW9uYWwga2V5d29yZC1vbmx5IGFyZ3VtZW50c1xuICAgICAgICAvLyBUT0RPOiBlbXB0eSBpdGVyYWJsZSByYWlzZXMgUHl0aG9uIFZhbHVlRXJyb3JcbiAgICAgICAgaWYgKCFhcmcyKSB7IC8vIGl0ZXJhYmxlXG4gICAgICAgICAgdmFyIG1heCA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBhcmcxKSBpZiAobWF4ID09PSBudWxsIHx8IGFyZzFbaV0gPiBtYXgpIG1heCA9IGFyZzFbaV07XG4gICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfSBlbHNlIHJldHVybiBhcmcxID49IGFyZzIgPyBhcmcxIDogYXJnMjtcbiAgICAgIH0sXG4gICAgICBtaW46IGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBvcHRpb25hbCBrZXl3b3JkLW9ubHkgYXJndW1lbnRzXG4gICAgICAgIC8vIFRPRE86IGVtcHR5IGl0ZXJhYmxlIHJhaXNlcyBQeXRob24gVmFsdWVFcnJvclxuICAgICAgICBpZiAoIWFyZzIpIHsgLy8gaXRlcmFibGVcbiAgICAgICAgICB2YXIgbWF4ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIGFyZzEpIGlmIChtYXggPT09IG51bGwgfHwgYXJnMVtpXSA8IG1heCkgbWF4ID0gYXJnMVtpXTtcbiAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9IGVsc2UgcmV0dXJuIGFyZzEgPD0gYXJnMiA/IGFyZzEgOiBhcmcyO1xuICAgICAgfSxcbiAgICAgIG9jdDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZyg4KTtcbiAgICAgIH0sXG4gICAgICBvcmQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTtcbiAgICAgIH0sXG4gICAgICBwb3c6IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICAgICAgcmV0dXJuIHogPyBNYXRoLnBvdyh4LCB5KSAlIHogOiBNYXRoLnBvdyh4LCB5KTtcbiAgICAgIH0sXG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHMgKz0gaSA9PT0gMCA/IGFyZ3VtZW50c1tpXSA6IFwiIFwiICsgYXJndW1lbnRzW2ldO1xuICAgICAgICBjb25zb2xlLmxvZyhzKTtcbiAgICAgIH0sXG4gICAgICByYW5nZTogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0ZXAgPT09IHVuZGVmaW5lZCkgc3RlcCA9IDE7XG4gICAgICAgIHZhciBsZW4gPSB+figoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApOyAvL35+IGlzIGEgZmFzdCBmbG9vclxuICAgICAgICB2YXIgciA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICB2YXIgZWxlbWVudCA9IDA7XG4gICAgICAgIGlmIChzdGFydCA8IHN0b3AgJiYgc3RlcCA+IDAgfHwgc3RhcnQgPiBzdG9wICYmIHN0ZXAgPCAwKSB7XG4gICAgICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgICAgICB3aGlsZSAoaSA8IHN0b3AgJiYgc3RlcCA+IDAgfHwgaSA+IHN0b3AgJiYgc3RlcCA8IDApIHtcbiAgICAgICAgICAgIHJbZWxlbWVudCsrXSA9IGk7XG4gICAgICAgICAgICBpICs9IHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB5dGhvblJ1bnRpbWUudXRpbHMuY29udmVydFRvTGlzdChyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LFxuICAgICAgcmVwcjogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHJldHVybiBcIidcIiArIG9iaiArIFwiJ1wiOyAvLyBUT0RPOiBQYXRjaCB1bnRpbCB0eXBlc3lzdGVtIGNvbWVzIHVwLlxuICAgICAgICBpZiAob2JqLl9fcmVwcl9fICE9PSB1bmRlZmluZWQpIHJldHVybiBvYmouX19yZXByX18oKTtcbiAgICAgICAgZWxzZSBpZiAob2JqLl9fY2xhc3NfXyAhPT0gdW5kZWZpbmVkICYmIG9iai5fX2NsYXNzX18ubW9kdWxlICE9PSB1bmRlZmluZWQgJiYgb2JqLl9fY2xhc3NfXy5fX25hbWVfXykge1xuICAgICAgICAgIHJldHVybiAnPCcrb2JqLl9fY2xhc3NfXy5fX21vZHVsZV9fKycuJytvYmouX19jbGFzc19fLl9fbmFtZV9fKycgb2JqZWN0Pic7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gb2JqLnRvU3RyaW5nKCk7IC8vIFJhaXNlIGEgcGxlYXNlIHJlcG9ydCB3YXJuaW5nIGhlcmUsIHdlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBpZWNlIG9mIGNvZGVcbiAgICAgIH0sXG4gICAgICByZXZlcnNlZDogZnVuY3Rpb24gKHNlcSkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IHB5dGhvblJ1bnRpbWUub2JqZWN0cy5saXN0KCk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc2VxKSByZXQucHVzaChzZXFbaV0pO1xuICAgICAgICByZXR1cm4gcmV0LnJldmVyc2UoKTtcbiAgICAgIH0sXG4gICAgICByb3VuZDogZnVuY3Rpb24gKG51bSwgbmRpZ2l0cykge1xuICAgICAgICBpZiAobmRpZ2l0cykge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDEwLCBuZGlnaXRzKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBzY2FsZSkgLyBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW0pO1xuICAgICAgfSxcbiAgICAgIHNvcnRlZDogZnVuY3Rpb24gKGl0ZXJhYmxlLCBrZXksIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMubGlzdCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIGl0ZXJhYmxlKSByZXQucHVzaChpdGVyYWJsZVtpXSk7XG4gICAgICAgIGlmKGtleSkgcmV0LnNvcnQoa2V5KTsgZWxzZSByZXQuc29ydCgpO1xuICAgICAgICBpZiAocmV2ZXJzZSkgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICBzdHI6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICAgIHN1bTogZnVuY3Rpb24gKGl0ZXJhYmxlLCBzdGFydCkge1xuICAgICAgICAvLyBUT0RPOiBzdGFydCBjYW4ndCBiZSBhIHN0cmluZ1xuICAgICAgICB2YXIgcmV0ID0gc3RhcnQgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgcmV0ICs9IGl0ZXJhYmxlW2ldO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgIHR1cGxlOiBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBweXRob25SdW50aW1lLm9iamVjdHMudHVwbGUoKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBpdGVyYWJsZSkgcmV0LnB1c2goaXRlcmFibGVbaV0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBQeXRob24gaW1wb3J0c1xuICAgIC8vIFRPRE86IGZyb20geCBpbXBvcnQgeSwgelxuXG4gICAgaW1wb3J0czoge1xuICAgICAgcmFuZG9tOiB7XG4gICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5yYW5kb20oKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBQeXRob25EaWN0KCkge1xuXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhQeXRob25EaWN0LnByb3RvdHlwZSwgcHl0aG9uUnVudGltZS51dGlscy5kaWN0UHJvcGVydHlEZXNjcmlwdG9yKTtcblxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/filbert/filbert.js\n");

/***/ })

}]);