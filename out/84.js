(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[84],{

/***/ "./node_modules/php-parser/dist/php-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/php-parser/dist/php-parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * \n *   Package: php-parser\n *   Parse PHP code from JS and returns its AST\n *   Build: 6af20f43d0d6855ac0e0 - 2020-4-24\n *   Copyright (C) 2020 Glayzzle (BSD-3-Clause)\n *   @authors https://github.com/glayzzle/php-parser/graphs/contributors\n *   @url http://glayzzle.com        \n *       \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 12);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"statement\";\n/**\n * Any statement.\n * @constructor Statement\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Statement(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"expression\";\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Expression\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Expression(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * A generic AST node\n * @constructor Node\n * @property {Location|null} loc\n * @property {Comment[]} leadingComments\n * @property {Comment[]?} trailingComments\n * @property {String} kind\n */\n\nvar Node = function Node(kind, docs, location) {\n  this.kind = kind;\n\n  if (docs) {\n    this.leadingComments = docs;\n  }\n\n  if (location) {\n    this.loc = location;\n  }\n};\n/**\n * Attach comments to current node\n * @param {*} docs\n */\n\n\nNode.prototype.setTrailingComments = function (docs) {\n  this.trailingComments = docs;\n};\n/**\n * Destroying an unused node\n */\n\n\nNode.prototype.destroy = function (node) {\n  if (!node) {\n    throw new Error(\"Node already initialized, you must swap with another node\");\n  }\n\n  if (this.leadingComments) {\n    if (node.leadingComments) {\n      node.leadingComments = Array.concat(this.leadingComments, node.leadingComments);\n    } else {\n      node.leadingComments = this.leadingComments;\n    }\n  }\n\n  if (this.trailingComments) {\n    if (node.trailingComments) {\n      node.trailingComments = Array.concat(this.trailingComments, node.trailingComments);\n    } else {\n      node.trailingComments = this.trailingComments;\n    }\n  }\n\n  return node;\n};\n/**\n * Includes current token position of the parser\n * @param {*} parser\n */\n\n\nNode.prototype.includeToken = function (parser) {\n  if (this.loc) {\n    if (this.loc.end) {\n      this.loc.end.line = parser.lexer.yylloc.last_line;\n      this.loc.end.column = parser.lexer.yylloc.last_column;\n      this.loc.end.offset = parser.lexer.offset;\n    }\n\n    if (parser.ast.withSource) {\n      this.loc.source = parser.lexer._input.substring(this.loc.start.offset, parser.lexer.offset);\n    }\n  }\n\n  return this;\n};\n/**\n * Helper for extending the Node class\n * @param {String} type\n * @param {Function} constructor\n * @return {Function}\n */\n\n\nNode[\"extends\"] = function (type, constructor) {\n  constructor.prototype = Object.create(this.prototype);\n  constructor[\"extends\"] = this[\"extends\"];\n  constructor.prototype.constructor = constructor;\n  constructor.kind = type;\n  return constructor;\n};\n\nmodule.exports = Node;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"literal\";\n/**\n * Defines an array structure\n * @constructor Literal\n * @extends {Expression}\n * @property {string} raw\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Literal(kind, value, raw, docs, location) {\n  Expression.apply(this, [kind || KIND, docs, location]);\n  this.value = value;\n\n  if (raw) {\n    this.raw = raw;\n  }\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"operation\";\n/**\n * Defines binary operations\n * @constructor Operation\n * @extends {Expression}\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Operation(kind, docs, location) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"declaration\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * A declaration statement (function, class, interface...)\n * @constructor Declaration\n * @extends {Statement}\n * @property {Identifier|string} name\n */\n\nvar Declaration = Statement[\"extends\"](KIND, function Declaration(kind, name, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.name = name;\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nDeclaration.prototype.parseFlags = function (flags) {\n  this.isAbstract = flags[2] === 1;\n  this.isFinal = flags[2] === 2;\n\n  if (this.kind !== \"class\") {\n    if (flags[0] === -1) {\n      this.visibility = IS_UNDEFINED;\n    } else if (flags[0] === null) {\n      this.visibility = null;\n    } else if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n\n    this.isStatic = flags[1] === 1;\n  }\n};\n\nmodule.exports = Declaration;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"reference\";\n/**\n * Defines a reference node\n * @constructor Reference\n * @extends {Node}\n */\n\nvar Reference = Node[\"extends\"](KIND, function Reference(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\nmodule.exports = Reference;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"block\";\n/**\n * A block statement, i.e., a sequence of statements surrounded by braces.\n * @constructor Block\n * @extends {Statement}\n * @property {Node[]} children\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Block(kind, children, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.children = children.filter(Boolean);\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"lookup\";\n/**\n * Lookup on an offset in the specified object\n * @constructor Lookup\n * @extends {Expression}\n * @property {Expression} what\n * @property {Expression} offset\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Lookup(kind, what, offset, docs, location) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n  this.what = what;\n  this.offset = offset;\n});\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n/**\n * Abstract documentation node (ComentLine or CommentBlock)\n * @constructor Comment\n * @extends {Node}\n * @property {String} value\n */\n\n\nmodule.exports = Node[\"extends\"](\"comment\", function Comment(kind, value, docs, location) {\n  Node.apply(this, [kind, docs, location]);\n  this.value = value;\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"constantstatement\";\n/**\n * Declares a constants into the current scope\n * @constructor ConstantStatement\n * @extends {Statement}\n * @property {Constant[]} constants\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function ConstantStatement(kind, constants, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.constants = constants;\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"function\";\n/**\n * Defines a classic function\n * @constructor Function\n * @extends {Declaration}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function _Function(name, args, byref, type, nullable, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.body = null;\n});\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2020 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar lexer = __webpack_require__(13);\n\nvar parser = __webpack_require__(23);\n\nvar tokens = __webpack_require__(39);\n\nvar AST = __webpack_require__(40);\n/**\n * @private\n */\n\n\nfunction combine(src, to) {\n  var keys = Object.keys(src);\n  var i = keys.length;\n\n  while (i--) {\n    var k = keys[i];\n    var val = src[k];\n\n    if (val === null) {\n      delete to[k];\n    } else if (typeof val === \"function\") {\n      to[k] = val.bind(to);\n    } else if (Array.isArray(val)) {\n      to[k] = Array.isArray(to[k]) ? to[k].concat(val) : val;\n    } else if (_typeof(val) === \"object\") {\n      to[k] = _typeof(to[k]) === \"object\" ? combine(val, to[k]) : val;\n    } else {\n      to[k] = val;\n    }\n  }\n\n  return to;\n}\n/**\n * Initialise a new parser instance with the specified options\n *\n * @class\n * @tutorial Engine\n * @example\n * var parser = require('php-parser');\n * var instance = new parser({\n *   parser: {\n *     extractDoc: true,\n *     suppressErrors: true,\n *     version: 704 // or '7.4'\n *   },\n *   ast: {\n *     withPositions: true\n *   },\n *   lexer: {\n *     short_tags: true,\n *     asp_tags: true\n *   }\n * });\n *\n * var evalAST = instance.parseEval('some php code');\n * var codeAST = instance.parseCode('<?php some php code', 'foo.php');\n * var tokens = instance.tokenGetAll('<?php some php code');\n *\n * @param {Object} options - List of options\n * @property {Lexer} lexer\n * @property {Parser} parser\n * @property {AST} ast\n * @property {Object} tokens\n */\n\n\nvar engine = function engine(options) {\n  if (typeof this === \"function\") {\n    return new this(options);\n  }\n\n  this.tokens = tokens;\n  this.lexer = new lexer(this);\n  this.ast = new AST();\n  this.parser = new parser(this.lexer, this.ast);\n\n  if (options && _typeof(options) === \"object\") {\n    // disable php7 from lexer if already disabled from parser\n    if (options.parser) {\n      if (!options.lexer) {\n        options.lexer = {};\n      }\n\n      if (options.parser.version) {\n        if (typeof options.parser.version === \"string\") {\n          var version = options.parser.version.split(\".\");\n          version = parseInt(version[0]) * 100 + parseInt(version[1]);\n\n          if (isNaN(version)) {\n            throw new Error(\"Bad version number : \" + options.parser.version);\n          } else {\n            options.parser.version = version;\n          }\n        } else if (typeof options.parser.version !== \"number\") {\n          throw new Error(\"Expecting a number for version\");\n        }\n\n        if (options.parser.version < 500 || options.parser.version > 704) {\n          throw new Error(\"Can only handle versions between 5.x to 7.x\");\n        }\n      }\n    }\n\n    combine(options, this); // same version flags based on parser options\n\n    this.lexer.version = this.parser.version;\n  }\n};\n/**\n * Check if the inpyt is a buffer or a string\n * @param  {Buffer|String} buffer Input value that can be either a buffer or a string\n * @return {String}   Returns the string from input\n */\n\n\nvar getStringBuffer = function getStringBuffer(buffer) {\n  return typeof buffer.write === \"function\" ? buffer.toString() : buffer;\n};\n/**\n * Creates a new instance (Helper)\n * @param {Object} options\n * @return {Engine}\n * @private\n */\n\n\nengine.create = function (options) {\n  return new engine(options);\n};\n/**\n * Evaluate the buffer\n * @private\n */\n\n\nengine.parseEval = function (buffer, options) {\n  var self = new engine(options);\n  return self.parseEval(buffer);\n};\n/**\n * Parse an evaluating mode string (no need to open php tags)\n * @param {String} buffer\n * @return {Program}\n */\n\n\nengine.prototype.parseEval = function (buffer) {\n  this.lexer.mode_eval = true;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, \"eval\");\n};\n/**\n * Static function that parse a php code with open/close tags\n * @private\n */\n\n\nengine.parseCode = function (buffer, filename, options) {\n  if (_typeof(filename) === \"object\" && !options) {\n    // retro-compatibility\n    options = filename;\n    filename = \"unknown\";\n  }\n\n  var self = new engine(options);\n  return self.parseCode(buffer, filename);\n};\n/**\n * Function that parse a php code with open/close tags\n *\n * Sample code :\n * ```php\n * <?php $x = 1;\n * ```\n *\n * Usage :\n * ```js\n * var parser = require('php-parser');\n * var phpParser = new parser({\n *   // some options\n * });\n * var ast = phpParser.parseCode('...php code...', 'foo.php');\n * ```\n * @param {String} buffer - The code to be parsed\n * @param {String} filename - Filename\n * @return {Program}\n */\n\n\nengine.prototype.parseCode = function (buffer, filename) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, filename);\n};\n/**\n * Split the buffer into tokens\n * @private\n */\n\n\nengine.tokenGetAll = function (buffer, options) {\n  var self = new engine(options);\n  return self.tokenGetAll(buffer);\n};\n/**\n * Extract tokens from the specified buffer.\n * > Note that the output tokens are *STRICLY* similar to PHP function `token_get_all`\n * @param {String} buffer\n * @return {String[]} - Each item can be a string or an array with following informations [token_name, text, line_number]\n */\n\n\nengine.prototype.tokenGetAll = function (buffer) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = true;\n  buffer = getStringBuffer(buffer);\n  var EOF = this.lexer.EOF;\n  var names = this.tokens.values;\n  this.lexer.setInput(buffer);\n  var token = this.lexer.lex() || EOF;\n  var result = [];\n\n  while (token != EOF) {\n    var entry = this.lexer.yytext;\n\n    if (names.hasOwnProperty(token)) {\n      entry = [names[token], entry, this.lexer.yylloc.first_line];\n    }\n\n    result.push(entry);\n    token = this.lexer.lex() || EOF;\n  }\n\n  return result;\n}; // exports the function\n\n\nmodule.exports = engine; // makes libraries public\n\nmodule.exports.tokens = tokens;\nmodule.exports.lexer = lexer;\nmodule.exports.AST = AST;\nmodule.exports.parser = parser;\nmodule.exports.combine = combine; // allow the default export in index.d.ts\n\nmodule.exports[\"default\"] = engine;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * This is the php lexer. It will tokenize the string for helping the\n * parser to build the AST from its grammar.\n *\n * @class\n * @property {Integer} EOF\n * @property {Boolean} all_tokens defines if all tokens must be retrieved (used by token_get_all only)\n * @property {Boolean} comment_tokens extracts comments tokens\n * @property {Boolean} mode_eval enables the evald mode (ignore opening tags)\n * @property {Boolean} asp_tags disables by default asp tags mode\n * @property {Boolean} short_tags enables by default short tags mode\n * @property {Object} keywords List of php keyword\n * @property {Object} castKeywords List of php keywords for type casting\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar lexer = function lexer(engine) {\n  this.engine = engine;\n  this.tok = this.engine.tokens.names;\n  this.EOF = 1;\n  this.debug = false;\n  this.all_tokens = true;\n  this.comment_tokens = false;\n  this.mode_eval = false;\n  this.asp_tags = false;\n  this.short_tags = false;\n  this.version = 704;\n  this.yyprevcol = 0;\n  this.keywords = {\n    __class__: this.tok.T_CLASS_C,\n    __trait__: this.tok.T_TRAIT_C,\n    __function__: this.tok.T_FUNC_C,\n    __method__: this.tok.T_METHOD_C,\n    __line__: this.tok.T_LINE,\n    __file__: this.tok.T_FILE,\n    __dir__: this.tok.T_DIR,\n    __namespace__: this.tok.T_NS_C,\n    exit: this.tok.T_EXIT,\n    die: this.tok.T_EXIT,\n    \"function\": this.tok.T_FUNCTION,\n    \"const\": this.tok.T_CONST,\n    \"return\": this.tok.T_RETURN,\n    \"try\": this.tok.T_TRY,\n    \"catch\": this.tok.T_CATCH,\n    \"finally\": this.tok.T_FINALLY,\n    \"throw\": this.tok.T_THROW,\n    \"if\": this.tok.T_IF,\n    elseif: this.tok.T_ELSEIF,\n    endif: this.tok.T_ENDIF,\n    \"else\": this.tok.T_ELSE,\n    \"while\": this.tok.T_WHILE,\n    endwhile: this.tok.T_ENDWHILE,\n    \"do\": this.tok.T_DO,\n    \"for\": this.tok.T_FOR,\n    endfor: this.tok.T_ENDFOR,\n    foreach: this.tok.T_FOREACH,\n    endforeach: this.tok.T_ENDFOREACH,\n    declare: this.tok.T_DECLARE,\n    enddeclare: this.tok.T_ENDDECLARE,\n    \"instanceof\": this.tok.T_INSTANCEOF,\n    as: this.tok.T_AS,\n    \"switch\": this.tok.T_SWITCH,\n    endswitch: this.tok.T_ENDSWITCH,\n    \"case\": this.tok.T_CASE,\n    \"default\": this.tok.T_DEFAULT,\n    \"break\": this.tok.T_BREAK,\n    \"continue\": this.tok.T_CONTINUE,\n    \"goto\": this.tok.T_GOTO,\n    echo: this.tok.T_ECHO,\n    print: this.tok.T_PRINT,\n    \"class\": this.tok.T_CLASS,\n    \"interface\": this.tok.T_INTERFACE,\n    trait: this.tok.T_TRAIT,\n    \"extends\": this.tok.T_EXTENDS,\n    \"implements\": this.tok.T_IMPLEMENTS,\n    \"new\": this.tok.T_NEW,\n    clone: this.tok.T_CLONE,\n    \"var\": this.tok.T_VAR,\n    eval: this.tok.T_EVAL,\n    include: this.tok.T_INCLUDE,\n    include_once: this.tok.T_INCLUDE_ONCE,\n    require: this.tok.T_REQUIRE,\n    require_once: this.tok.T_REQUIRE_ONCE,\n    namespace: this.tok.T_NAMESPACE,\n    use: this.tok.T_USE,\n    insteadof: this.tok.T_INSTEADOF,\n    global: this.tok.T_GLOBAL,\n    isset: this.tok.T_ISSET,\n    empty: this.tok.T_EMPTY,\n    __halt_compiler: this.tok.T_HALT_COMPILER,\n    \"static\": this.tok.T_STATIC,\n    \"abstract\": this.tok.T_ABSTRACT,\n    \"final\": this.tok.T_FINAL,\n    \"private\": this.tok.T_PRIVATE,\n    \"protected\": this.tok.T_PROTECTED,\n    \"public\": this.tok.T_PUBLIC,\n    unset: this.tok.T_UNSET,\n    list: this.tok.T_LIST,\n    array: this.tok.T_ARRAY,\n    callable: this.tok.T_CALLABLE,\n    or: this.tok.T_LOGICAL_OR,\n    and: this.tok.T_LOGICAL_AND,\n    xor: this.tok.T_LOGICAL_XOR\n  };\n  this.castKeywords = {\n    \"int\": this.tok.T_INT_CAST,\n    integer: this.tok.T_INT_CAST,\n    real: this.tok.T_DOUBLE_CAST,\n    \"double\": this.tok.T_DOUBLE_CAST,\n    \"float\": this.tok.T_DOUBLE_CAST,\n    string: this.tok.T_STRING_CAST,\n    binary: this.tok.T_STRING_CAST,\n    array: this.tok.T_ARRAY_CAST,\n    object: this.tok.T_OBJECT_CAST,\n    bool: this.tok.T_BOOL_CAST,\n    \"boolean\": this.tok.T_BOOL_CAST,\n    unset: this.tok.T_UNSET_CAST\n  };\n};\n/**\n * Initialize the lexer with the specified input\n */\n\n\nlexer.prototype.setInput = function (input) {\n  this._input = input;\n  this.size = input.length;\n  this.yylineno = 1;\n  this.offset = 0;\n  this.yyprevcol = 0;\n  this.yytext = \"\";\n  this.yylloc = {\n    first_offset: 0,\n    first_line: 1,\n    first_column: 0,\n    prev_offset: 0,\n    prev_line: 1,\n    prev_column: 0,\n    last_line: 1,\n    last_column: 0\n  };\n  this.tokens = [];\n\n  if (this.version > 703) {\n    this.keywords.fn = this.tok.T_FN;\n  } else {\n    delete this.keywords.fn;\n  }\n\n  this.done = this.offset >= this.size;\n\n  if (!this.all_tokens && this.mode_eval) {\n    this.conditionStack = [\"INITIAL\"];\n    this.begin(\"ST_IN_SCRIPTING\");\n  } else {\n    this.conditionStack = [];\n    this.begin(\"INITIAL\");\n  } // https://github.com/php/php-src/blob/999e32b65a8a4bb59e27e538fa68ffae4b99d863/Zend/zend_language_scanner.h#L59\n  // Used for heredoc and nowdoc\n\n\n  this.heredoc_label = {\n    label: \"\",\n    length: 0,\n    indentation: 0,\n    indentation_uses_spaces: false,\n    finished: false,\n\n    /**\n     * this used for parser to detemine the if current node segment is first encaps node.\n     * if ture, the indentation will remove from the begining. and if false, the prev node\n     * might be a variable '}' ,and the leading spaces should not be removed util meet the\n     * first \\n\n     */\n    first_encaps_node: false,\n    // for backward compatible\n    toString: function toString() {\n      this.label;\n    }\n  };\n  return this;\n};\n/**\n * consumes and returns one char from the input\n */\n\n\nlexer.prototype.input = function () {\n  var ch = this._input[this.offset];\n  if (!ch) return \"\";\n  this.yytext += ch;\n  this.offset++;\n\n  if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n    this.yytext += \"\\n\";\n    this.offset++;\n  }\n\n  if (ch === \"\\n\" || ch === \"\\r\") {\n    this.yylloc.last_line = ++this.yylineno;\n    this.yyprevcol = this.yylloc.last_column;\n    this.yylloc.last_column = 0;\n  } else {\n    this.yylloc.last_column++;\n  }\n\n  return ch;\n};\n/**\n * revert eating specified size\n */\n\n\nlexer.prototype.unput = function (size) {\n  if (size === 1) {\n    // 1 char unput (most cases)\n    this.offset--;\n\n    if (this._input[this.offset] === \"\\n\" && this._input[this.offset - 1] === \"\\r\") {\n      this.offset--;\n      size++;\n    }\n\n    if (this._input[this.offset] === \"\\r\" || this._input[this.offset] === \"\\n\") {\n      this.yylloc.last_line--;\n      this.yylineno--;\n      this.yylloc.last_column = this.yyprevcol;\n    } else {\n      this.yylloc.last_column--;\n    }\n\n    this.yytext = this.yytext.substring(0, this.yytext.length - size);\n  } else if (size > 0) {\n    this.offset -= size;\n\n    if (size < this.yytext.length) {\n      this.yytext = this.yytext.substring(0, this.yytext.length - size); // re-calculate position\n\n      this.yylloc.last_line = this.yylloc.first_line;\n      this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;\n\n      for (var i = 0; i < this.yytext.length; i++) {\n        var c = this.yytext[i];\n\n        if (c === \"\\r\") {\n          c = this.yytext[++i];\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n\n          if (c !== \"\\n\") {\n            if (c === \"\\r\") {\n              this.yylloc.last_line++;\n            } else {\n              this.yylloc.last_column++;\n            }\n          }\n        } else if (c === \"\\n\") {\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n        } else {\n          this.yylloc.last_column++;\n        }\n      }\n\n      this.yylineno = this.yylloc.last_line;\n    } else {\n      // reset full text\n      this.yytext = \"\";\n      this.yylloc.last_line = this.yylineno = this.yylloc.first_line;\n      this.yylloc.last_column = this.yylloc.first_column;\n    }\n  }\n\n  return this;\n}; // check if the text matches\n\n\nlexer.prototype.tryMatch = function (text) {\n  return text === this.ahead(text.length);\n}; // check if the text matches\n\n\nlexer.prototype.tryMatchCaseless = function (text) {\n  return text === this.ahead(text.length).toLowerCase();\n}; // look ahead\n\n\nlexer.prototype.ahead = function (size) {\n  var text = this._input.substring(this.offset, this.offset + size);\n\n  if (text[text.length - 1] === \"\\r\" && this._input[this.offset + size + 1] === \"\\n\") {\n    text += \"\\n\";\n  }\n\n  return text;\n}; // consume the specified size\n\n\nlexer.prototype.consume = function (size) {\n  for (var i = 0; i < size; i++) {\n    var ch = this._input[this.offset];\n    if (!ch) break;\n    this.yytext += ch;\n    this.offset++;\n\n    if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n      this.yytext += \"\\n\";\n      this.offset++;\n      i++;\n    }\n\n    if (ch === \"\\n\" || ch === \"\\r\") {\n      this.yylloc.last_line = ++this.yylineno;\n      this.yyprevcol = this.yylloc.last_column;\n      this.yylloc.last_column = 0;\n    } else {\n      this.yylloc.last_column++;\n    }\n  }\n\n  return this;\n};\n/**\n * Gets the current state\n */\n\n\nlexer.prototype.getState = function () {\n  return {\n    yytext: this.yytext,\n    offset: this.offset,\n    yylineno: this.yylineno,\n    yyprevcol: this.yyprevcol,\n    yylloc: {\n      first_offset: this.yylloc.first_offset,\n      first_line: this.yylloc.first_line,\n      first_column: this.yylloc.first_column,\n      last_line: this.yylloc.last_line,\n      last_column: this.yylloc.last_column\n    },\n    heredoc_label: this.heredoc_label\n  };\n};\n/**\n * Sets the current lexer state\n */\n\n\nlexer.prototype.setState = function (state) {\n  this.yytext = state.yytext;\n  this.offset = state.offset;\n  this.yylineno = state.yylineno;\n  this.yyprevcol = state.yyprevcol;\n  this.yylloc = state.yylloc;\n\n  if (state.heredoc_label) {\n    this.heredoc_label = state.heredoc_label;\n  }\n\n  return this;\n}; // prepend next token\n\n\nlexer.prototype.appendToken = function (value, ahead) {\n  this.tokens.push([value, ahead]);\n  return this;\n}; // return next match that has a token\n\n\nlexer.prototype.lex = function () {\n  this.yylloc.prev_offset = this.offset;\n  this.yylloc.prev_line = this.yylloc.last_line;\n  this.yylloc.prev_column = this.yylloc.last_column;\n  var token = this.next() || this.lex();\n\n  if (!this.all_tokens) {\n    while (token === this.tok.T_WHITESPACE || // ignore white space\n    !this.comment_tokens && (token === this.tok.T_COMMENT || // ignore single lines comments\n    token === this.tok.T_DOC_COMMENT) || // ignore doc comments\n    // ignore open tags\n    token === this.tok.T_OPEN_TAG) {\n      token = this.next() || this.lex();\n    }\n\n    if (token == this.tok.T_OPEN_TAG_WITH_ECHO) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1683\n      // open tag with echo statement\n      return this.tok.T_ECHO;\n    } else if (token === this.tok.T_CLOSE_TAG) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n      return \";\";\n      /* implicit ; */\n    }\n  }\n\n  if (!this.yylloc.prev_offset) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n  }\n  /*else if (this.yylloc.prev_offset === this.offset && this.offset !== this.size) {\n    throw new Error('Infinite loop @ ' + this.offset + ' / ' + this.size);\n  }*/\n\n\n  return token;\n}; // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n\n\nlexer.prototype.begin = function (condition) {\n  this.conditionStack.push(condition);\n  this.curCondition = condition;\n  this.stateCb = this[\"match\" + condition];\n\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + condition + '\"');\n  }\n\n  return this;\n}; // pop the previously active lexer condition state off the condition stack\n\n\nlexer.prototype.popState = function () {\n  var n = this.conditionStack.length - 1;\n  var condition = n > 0 ? this.conditionStack.pop() : this.conditionStack[0];\n  this.curCondition = this.conditionStack[this.conditionStack.length - 1];\n  this.stateCb = this[\"match\" + this.curCondition];\n\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + this.curCondition + '\"');\n  }\n\n  return condition;\n}; // return next match in input\n\n\nlexer.prototype.next = function () {\n  var token;\n\n  if (!this._input) {\n    this.done = true;\n  }\n\n  this.yylloc.first_offset = this.offset;\n  this.yylloc.first_line = this.yylloc.last_line;\n  this.yylloc.first_column = this.yylloc.last_column;\n  this.yytext = \"\";\n\n  if (this.done) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n    return this.EOF;\n  }\n\n  if (this.tokens.length > 0) {\n    token = this.tokens.shift();\n\n    if (_typeof(token[1]) === \"object\") {\n      this.setState(token[1]);\n    } else {\n      this.consume(token[1]);\n    }\n\n    token = token[0];\n  } else {\n    token = this.stateCb.apply(this, []);\n  }\n\n  if (this.offset >= this.size && this.tokens.length === 0) {\n    this.done = true;\n  }\n\n  if (this.debug) {\n    var tName = token;\n\n    if (typeof tName === \"number\") {\n      tName = this.engine.tokens.values[tName];\n    } else {\n      tName = '\"' + tName + '\"';\n    }\n\n    var e = new Error(tName + \"\\tfrom \" + this.yylloc.first_line + \",\" + this.yylloc.first_column + \"\\t - to \" + this.yylloc.last_line + \",\" + this.yylloc.last_column + '\\t\"' + this.yytext + '\"'); // eslint-disable-next-line no-console\n\n    console.error(e.stack);\n  }\n\n  return token;\n}; // extends the lexer with states\n\n\n[__webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20), __webpack_require__(21), __webpack_require__(22)].forEach(function (ext) {\n  for (var k in ext) {\n    lexer.prototype[k] = ext[k];\n  }\n});\nmodule.exports = lexer;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a single line comment\n   */\n  T_COMMENT: function T_COMMENT() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch === \"\\n\" || ch === \"\\r\") {\n        return this.tok.T_COMMENT;\n      } else if (ch === \"?\" && !this.aspTagMode && this._input[this.offset] === \">\") {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      } else if (ch === \"%\" && this.aspTagMode && this._input[this.offset] === \">\") {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      }\n    }\n\n    return this.tok.T_COMMENT;\n  },\n\n  /**\n   * Behaviour : https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1927\n   */\n  T_DOC_COMMENT: function T_DOC_COMMENT() {\n    var ch = this.input();\n    var token = this.tok.T_COMMENT;\n\n    if (ch === \"*\") {\n      // started with '/*' , check is next is '*'\n      ch = this.input();\n\n      if (this.is_WHITESPACE()) {\n        // check if next is WHITESPACE\n        token = this.tok.T_DOC_COMMENT;\n      }\n\n      if (ch === \"/\") {\n        return token;\n      } else {\n        this.unput(1); // reset\n      }\n    }\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch === \"*\" && this._input[this.offset] === \"/\") {\n        this.input();\n        break;\n      }\n    }\n\n    return token;\n  }\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  nextINITIAL: function nextINITIAL() {\n    if (this.conditionStack.length > 1 && this.conditionStack[this.conditionStack.length - 1] === \"INITIAL\") {\n      // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n      this.popState();\n    } else {\n      this.begin(\"ST_IN_SCRIPTING\");\n    }\n\n    return this;\n  },\n  matchINITIAL: function matchINITIAL() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch == \"<\") {\n        ch = this.ahead(1);\n\n        if (ch == \"?\") {\n          if (this.tryMatch(\"?=\")) {\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();\n            break;\n          } else if (this.tryMatchCaseless(\"?php\")) {\n            ch = this._input[this.offset + 4];\n\n            if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();\n              break;\n            }\n          }\n\n          if (this.short_tags) {\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        } else if (this.asp_tags && ch == \"%\") {\n          if (this.tryMatch(\"%=\")) {\n            this.aspTagMode = true;\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();\n            break;\n          } else {\n            this.aspTagMode = true;\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.yytext.length > 0) {\n      return this.tok.T_INLINE_HTML;\n    } else {\n      return false;\n    }\n  }\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/* istanbul ignore else  */\n\nvar MAX_LENGTH_OF_LONG = 10;\nvar long_min_digits = \"2147483648\";\n\nif (process.arch == \"x64\") {\n  MAX_LENGTH_OF_LONG = 19;\n  long_min_digits = \"9223372036854775808\";\n}\n\nmodule.exports = {\n  consume_NUM: function consume_NUM() {\n    var ch = this.yytext[0];\n    var hasPoint = ch === \".\";\n\n    if (ch === \"0\") {\n      ch = this.input(); // check if hexa\n\n      if (ch === \"x\" || ch === \"X\") {\n        ch = this.input();\n\n        if (ch !== \"_\" && this.is_HEX()) {\n          return this.consume_HNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        } // check binary notation\n\n      } else if (ch === \"b\" || ch === \"B\") {\n        ch = this.input();\n\n        if (ch !== \"_\" && ch === \"0\" || ch === \"1\") {\n          return this.consume_BNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        } // @fixme check octal notation ? not usefull\n\n      } else if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n      }\n    }\n\n    while (this.offset < this.size) {\n      var prev = ch;\n      ch = this.input();\n\n      if (ch === \"_\") {\n        if (prev === \"_\") {\n          // restriction : next to underscore / 1__1;\n          this.unput(2); // keep 1\n\n          break;\n        }\n\n        if (prev === \".\") {\n          // next to decimal point  \"1._0\"\n          this.unput(1); // keep 1.\n\n          break;\n        }\n\n        if (prev === \"e\" || prev === \"E\") {\n          // next to e \"1e_10\"\n          this.unput(2); // keep 1\n\n          break;\n        }\n      } else if (ch === \".\") {\n        if (hasPoint) {\n          // no multiple points \"1.0.5\"\n          this.unput(1); // keep 1.0\n\n          break;\n        }\n\n        if (prev === \"_\") {\n          // next to decimal point  \"1_.0\"\n          this.unput(2); // keep 1\n\n          break;\n        }\n\n        hasPoint = true;\n        continue;\n      } else if (ch === \"e\" || ch === \"E\") {\n        if (prev === \"_\") {\n          // next to e \"1_e10\"\n          this.unput(1);\n          break;\n        }\n\n        var undo = 2;\n        ch = this.input();\n\n        if (ch === \"+\" || ch === \"-\") {\n          // 1e-5\n          undo = 3;\n          ch = this.input();\n        }\n\n        if (this.is_NUM_START()) {\n          this.consume_LNUM();\n          return this.tok.T_DNUMBER;\n        }\n\n        this.unput(ch ? undo : undo - 1); // keep only 1\n\n        break;\n      }\n\n      if (!this.is_NUM()) {\n        // example : 10.0a\n        if (ch) this.unput(1); // keep 10.0\n\n        break;\n      }\n    }\n\n    if (hasPoint) {\n      return this.tok.T_DNUMBER;\n    } else if (this.yytext.length < MAX_LENGTH_OF_LONG - 1) {\n      return this.tok.T_LNUMBER;\n    } else {\n      if (this.yytext.length < MAX_LENGTH_OF_LONG || this.yytext.length == MAX_LENGTH_OF_LONG && this.yytext < long_min_digits) {\n        return this.tok.T_LNUMBER;\n      }\n\n      return this.tok.T_DNUMBER;\n    }\n  },\n  // read hexa\n  consume_HNUM: function consume_HNUM() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_HEX()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  },\n  // read a generic number\n  consume_LNUM: function consume_LNUM() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  },\n  // read binary\n  consume_BNUM: function consume_BNUM() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch !== \"0\" && ch !== \"1\" && ch !== \"_\") {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  matchST_LOOKING_FOR_PROPERTY: function matchST_LOOKING_FOR_PROPERTY() {\n    var ch = this.input();\n\n    if (ch === \"-\") {\n      ch = this.input();\n\n      if (ch === \">\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1296\n        return this.tok.T_OBJECT_OPERATOR;\n      }\n\n      if (ch) this.unput(1);\n    } else if (this.is_WHITESPACE()) {\n      return this.tok.T_WHITESPACE;\n    } else if (this.is_LABEL_START()) {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1300\n      this.consume_LABEL();\n      this.popState();\n      return this.tok.T_STRING;\n    } // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1306\n\n\n    this.popState();\n    if (ch) this.unput(1);\n    return false;\n  },\n  matchST_LOOKING_FOR_VARNAME: function matchST_LOOKING_FOR_VARNAME() {\n    var ch = this.input(); // SHIFT STATE\n\n    this.popState();\n    this.begin(\"ST_IN_SCRIPTING\");\n\n    if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      ch = this.input();\n\n      if (ch === \"[\" || ch === \"}\") {\n        this.unput(1);\n        return this.tok.T_STRING_VARNAME;\n      } else {\n        // any char (that's started with a label sequence)\n        this.unput(this.yytext.length);\n      }\n    } else {\n      // any char (thats not a label start sequence)\n      if (ch) this.unput(1);\n    } // stops looking for a varname and starts the scripting mode\n\n\n    return false;\n  },\n  matchST_VAR_OFFSET: function matchST_VAR_OFFSET() {\n    var ch = this.input();\n\n    if (this.is_NUM_START()) {\n      this.consume_NUM();\n      return this.tok.T_NUM_STRING;\n    } else if (ch === \"]\") {\n      this.popState();\n      return \"]\";\n    } else if (ch === \"$\") {\n      this.input();\n\n      if (this.is_LABEL_START()) {\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        throw new Error(\"Unexpected terminal\");\n      }\n    } else if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      return this.tok.T_STRING;\n    } else if (this.is_WHITESPACE() || ch === \"\\\\\" || ch === \"'\" || ch === \"#\") {\n      return this.tok.T_ENCAPSED_AND_WHITESPACE;\n    } else if (ch === \"[\" || ch === \"{\" || ch === \"}\" || ch === '\"' || ch === \"`\" || this.is_TOKEN()) {\n      return ch;\n    } else {\n      throw new Error(\"Unexpected terminal\");\n    }\n  }\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  matchST_IN_SCRIPTING: function matchST_IN_SCRIPTING() {\n    var ch = this.input();\n\n    switch (ch) {\n      case \" \":\n      case \"\\t\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\r\\n\":\n        return this.T_WHITESPACE();\n\n      case \"#\":\n        return this.T_COMMENT();\n\n      case \"/\":\n        if (this._input[this.offset] === \"/\") {\n          return this.T_COMMENT();\n        } else if (this._input[this.offset] === \"*\") {\n          this.input();\n          return this.T_DOC_COMMENT();\n        }\n\n        return this.consume_TOKEN();\n\n      case \"'\":\n        return this.T_CONSTANT_ENCAPSED_STRING();\n\n      case '\"':\n        return this.ST_DOUBLE_QUOTES();\n\n      case \"`\":\n        this.begin(\"ST_BACKQUOTE\");\n        return \"`\";\n\n      case \"?\":\n        if (!this.aspTagMode && this.tryMatch(\">\")) {\n          this.input();\n          var nextCH = this._input[this.offset];\n          if (nextCH === \"\\n\" || nextCH === \"\\r\") this.input();\n\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n\n          return this.tok.T_CLOSE_TAG;\n        }\n\n        return this.consume_TOKEN();\n\n      case \"%\":\n        if (this.aspTagMode && this._input[this.offset] === \">\") {\n          this.input(); // consume the '>'\n\n          ch = this._input[this.offset]; // read next\n\n          if (ch === \"\\n\" || ch === \"\\r\") {\n            this.input(); // consume the newline\n          }\n\n          this.aspTagMode = false;\n\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n\n          return this.tok.T_CLOSE_TAG;\n        }\n\n        return this.consume_TOKEN();\n\n      case \"{\":\n        this.begin(\"ST_IN_SCRIPTING\");\n        return \"{\";\n\n      case \"}\":\n        if (this.conditionStack.length > 2) {\n          // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n          this.popState();\n        }\n\n        return \"}\";\n\n      default:\n        if (ch === \".\") {\n          ch = this.input();\n\n          if (this.is_NUM_START()) {\n            return this.consume_NUM();\n          } else {\n            if (ch) this.unput(1);\n          }\n        }\n\n        if (this.is_NUM_START()) {\n          return this.consume_NUM();\n        } else if (this.is_LABEL_START()) {\n          return this.consume_LABEL().T_STRING();\n        } else if (this.is_TOKEN()) {\n          return this.consume_TOKEN();\n        }\n\n    }\n\n    throw new Error('Bad terminal sequence \"' + ch + '\" at line ' + this.yylineno + \" (offset \" + this.offset + \")\");\n  },\n  T_WHITESPACE: function T_WHITESPACE() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n        continue;\n      }\n\n      if (ch) this.unput(1);\n      break;\n    }\n\n    return this.tok.T_WHITESPACE;\n  }\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar newline = [\"\\n\", \"\\r\"];\nvar valid_after_heredoc = [\"\\n\", \"\\r\", \";\"];\nvar valid_after_heredoc_73 = valid_after_heredoc.concat([\"\\t\", \" \", \",\", \"]\", \")\", \"/\", \"=\", \"!\"]);\nmodule.exports = {\n  T_CONSTANT_ENCAPSED_STRING: function T_CONSTANT_ENCAPSED_STRING() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == \"'\") {\n        break;\n      }\n    }\n\n    return this.tok.T_CONSTANT_ENCAPSED_STRING;\n  },\n  // check if matching a HEREDOC state\n  is_HEREDOC: function is_HEREDOC() {\n    var revert = this.offset;\n\n    if (this._input[this.offset - 1] === \"<\" && this._input[this.offset] === \"<\" && this._input[this.offset + 1] === \"<\") {\n      this.offset += 3; // optional tabs / spaces\n\n      if (this.is_TABSPACE()) {\n        while (this.offset < this.size) {\n          this.offset++;\n\n          if (!this.is_TABSPACE()) {\n            break;\n          }\n        }\n      } // optional quotes\n\n\n      var tChar = this._input[this.offset - 1];\n\n      if (tChar === \"'\" || tChar === '\"') {\n        this.offset++;\n      } else {\n        tChar = null;\n      } // required label\n\n\n      if (this.is_LABEL_START()) {\n        var yyoffset = this.offset - 1;\n\n        while (this.offset < this.size) {\n          this.offset++;\n\n          if (!this.is_LABEL()) {\n            break;\n          }\n        }\n\n        var yylabel = this._input.substring(yyoffset, this.offset - 1);\n\n        if (!tChar || tChar === this._input[this.offset - 1]) {\n          // required ending quote\n          if (tChar) this.offset++; // require newline\n\n          if (newline.includes(this._input[this.offset - 1])) {\n            // go go go\n            this.heredoc_label.label = yylabel;\n            this.heredoc_label.length = yylabel.length;\n            this.heredoc_label.finished = false;\n            yyoffset = this.offset - revert;\n            this.offset = revert;\n            this.consume(yyoffset);\n\n            if (tChar === \"'\") {\n              this.begin(\"ST_NOWDOC\");\n            } else {\n              this.begin(\"ST_HEREDOC\");\n            } // prematch to get the indentation information from end of doc\n\n\n            this.prematch_ENDOFDOC();\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n      }\n    }\n\n    this.offset = revert;\n    return false;\n  },\n  ST_DOUBLE_QUOTES: function ST_DOUBLE_QUOTES() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == '\"') {\n        break;\n      } else if (ch == \"$\") {\n        ch = this.input();\n\n        if (ch == \"{\" || this.is_LABEL_START()) {\n          this.unput(2);\n          break;\n        }\n\n        if (ch) this.unput(1);\n      } else if (ch == \"{\") {\n        ch = this.input();\n\n        if (ch == \"$\") {\n          this.unput(2);\n          break;\n        }\n\n        if (ch) this.unput(1);\n      }\n    }\n\n    if (ch == '\"') {\n      return this.tok.T_CONSTANT_ENCAPSED_STRING;\n    } else {\n      var prefix = 1;\n\n      if (this.yytext[0] === \"b\" || this.yytext[0] === \"B\") {\n        prefix = 2;\n      }\n\n      if (this.yytext.length > 2) {\n        this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - prefix);\n      }\n\n      this.unput(this.yytext.length - prefix);\n      this.begin(\"ST_DOUBLE_QUOTES\");\n      return this.yytext;\n    }\n  },\n  // check if its a DOC end sequence\n  isDOC_MATCH: function isDOC_MATCH(offset, consumeLeadingSpaces) {\n    // @fixme : check if out of text limits\n    // consumeLeadingSpaces is false happen DOC prematch END HEREDOC stage.\n    // Ensure current state is really after a new line break, not after a such as ${variables}\n    var prev_ch = this._input[offset - 2];\n\n    if (!newline.includes(prev_ch)) {\n      return false;\n    } // skip leading spaces or tabs\n\n\n    var indentation_uses_spaces = false;\n    var indentation_uses_tabs = false; // reset heredoc_label structure\n\n    var indentation = 0;\n    var leading_ch = this._input[offset - 1];\n\n    if (this.version >= 703) {\n      while (leading_ch === \"\\t\" || leading_ch === \" \") {\n        if (leading_ch === \" \") {\n          indentation_uses_spaces = true;\n        } else if (leading_ch === \"\\t\") {\n          indentation_uses_tabs = true;\n        }\n\n        leading_ch = this._input[offset + indentation];\n        indentation++;\n      } // Move offset to skip leading whitespace\n\n\n      offset = offset + indentation; // return out if there was only whitespace on this line\n\n      if (newline.includes(this._input[offset - 1])) {\n        return false;\n      }\n    }\n\n    if (this._input.substring(offset - 1, offset - 1 + this.heredoc_label.length) === this.heredoc_label.label) {\n      var ch = this._input[offset - 1 + this.heredoc_label.length];\n\n      if ((this.version >= 703 ? valid_after_heredoc_73 : valid_after_heredoc).includes(ch)) {\n        if (consumeLeadingSpaces) {\n          this.consume(indentation); // https://wiki.php.net/rfc/flexible_heredoc_nowdoc_syntaxes\n\n          if (indentation_uses_spaces && indentation_uses_tabs) {\n            throw new Error(\"Parse error:  mixing spaces and tabs in ending marker at line \" + this.yylineno + \" (offset \" + this.offset + \")\");\n          }\n        } else {\n          // Called in prematch_ENDOFDOC\n          this.heredoc_label.indentation = indentation;\n          this.heredoc_label.indentation_uses_spaces = indentation_uses_spaces;\n          this.heredoc_label.first_encaps_node = true;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Prematch the end of HEREDOC/NOWDOC end tag to preset the\n   * context of this.heredoc_label\n   */\n  prematch_ENDOFDOC: function prematch_ENDOFDOC() {\n    // reset heredoc\n    this.heredoc_label.indentation_uses_spaces = false;\n    this.heredoc_label.indentation = 0;\n    this.heredoc_label.first_encaps_node = true;\n    var offset = this.offset + 1;\n\n    while (offset < this._input.length) {\n      // if match heredoc_label structrue will be set\n      if (this.isDOC_MATCH(offset, false)) {\n        return;\n      }\n\n      if (!newline.includes(this._input[offset - 1])) {\n        // skip one line\n        while (!newline.includes(this._input[offset++]) && offset < this._input.length) {// skip\n        }\n      }\n\n      offset++;\n    }\n  },\n  matchST_NOWDOC: function matchST_NOWDOC() {\n    /** edge case : empty now doc **/\n    if (this.isDOC_MATCH(this.offset, true)) {\n      // @fixme : never reached (may be caused by quotes)\n      this.consume(this.heredoc_label.length);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n\n\n    var ch = this._input[this.offset - 1];\n\n    while (this.offset < this.size) {\n      if (newline.includes(ch)) {\n        ch = this.input();\n\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else {\n        ch = this.input();\n      }\n    } // too bad ! reached end of document (will get a parse error)\n\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  matchST_HEREDOC: function matchST_HEREDOC() {\n    /** edge case : empty here doc **/\n    var ch = this.input();\n\n    if (this.isDOC_MATCH(this.offset, true)) {\n      this.consume(this.heredoc_label.length - 1);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        ch = this.input(); // ignore next\n\n        if (!newline.includes(ch)) {\n          ch = this.input();\n        }\n      }\n\n      if (newline.includes(ch)) {\n        ch = this.input();\n\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          // start of ${\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          } //console.log(this.yytext);\n\n        }\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n      } else {\n        ch = this.input();\n      }\n    } // too bad ! reached end of document (will get a parse error)\n\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  consume_VARIABLE: function consume_VARIABLE() {\n    this.consume_LABEL();\n    var ch = this.input();\n\n    if (ch == \"[\") {\n      this.unput(1);\n      this.begin(\"ST_VAR_OFFSET\");\n      return this.tok.T_VARIABLE;\n    } else if (ch === \"-\") {\n      if (this.input() === \">\") {\n        this.input();\n\n        if (this.is_LABEL_START()) {\n          this.begin(\"ST_LOOKING_FOR_PROPERTY\");\n        }\n\n        this.unput(3);\n        return this.tok.T_VARIABLE;\n      } else {\n        this.unput(2);\n      }\n    } else {\n      if (ch) this.unput(1);\n    }\n\n    return this.tok.T_VARIABLE;\n  },\n  // HANDLES BACKQUOTES\n  matchST_BACKQUOTE: function matchST_BACKQUOTE() {\n    var ch = this.input();\n\n    if (ch === \"$\") {\n      ch = this.input();\n\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        var tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === \"`\") {\n      this.popState();\n      return \"`\";\n    } // any char\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === \"`\") {\n        this.unput(1);\n        this.popState();\n        this.appendToken(\"`\", 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n\n        continue;\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n\n        continue;\n      }\n\n      ch = this.input();\n    }\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  matchST_DOUBLE_QUOTES: function matchST_DOUBLE_QUOTES() {\n    var ch = this.input();\n\n    if (ch === \"$\") {\n      ch = this.input();\n\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        var tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === '\"') {\n      this.popState();\n      return '\"';\n    } // any char\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === '\"') {\n        this.unput(1);\n        this.popState();\n        this.appendToken('\"', 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n\n        if (ch) this.unput(1);\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            // @fixme : yytext = '\"{$' (this.yytext.length > 3)\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n\n        if (ch) this.unput(1);\n      }\n\n      ch = this.input();\n    }\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  }\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  T_STRING: function T_STRING() {\n    var token = this.yytext.toLowerCase();\n    var id = this.keywords[token];\n\n    if (typeof id !== \"number\") {\n      if (token === \"yield\") {\n        if (this.version >= 700 && this.tryMatch(\" from\")) {\n          this.consume(5);\n          id = this.tok.T_YIELD_FROM;\n        } else {\n          id = this.tok.T_YIELD;\n        }\n      } else {\n        id = this.tok.T_STRING;\n\n        if (token === \"b\" || token === \"B\") {\n          var ch = this.input(1);\n\n          if (ch === '\"') {\n            return this.ST_DOUBLE_QUOTES();\n          } else if (ch === \"'\") {\n            return this.T_CONSTANT_ENCAPSED_STRING();\n          } else if (ch) {\n            this.unput(1);\n          }\n        }\n      }\n    }\n\n    return id;\n  },\n  // reads a custom token\n  consume_TOKEN: function consume_TOKEN() {\n    var ch = this._input[this.offset - 1];\n    var fn = this.tokenTerminals[ch];\n\n    if (fn) {\n      return fn.apply(this, []);\n    } else {\n      return this.yytext;\n    }\n  },\n  // list of special char tokens\n  tokenTerminals: {\n    $: function $() {\n      this.offset++;\n\n      if (this.is_LABEL_START()) {\n        this.offset--;\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        this.offset--;\n        return \"$\";\n      }\n    },\n    \"-\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \">\") {\n        this.begin(\"ST_LOOKING_FOR_PROPERTY\").input();\n        return this.tok.T_OBJECT_OPERATOR;\n      } else if (nchar === \"-\") {\n        this.input();\n        return this.tok.T_DEC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MINUS_EQUAL;\n      }\n\n      return \"-\";\n    },\n    \"\\\\\": function _() {\n      return this.tok.T_NS_SEPARATOR;\n    },\n    \"/\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_DIV_EQUAL;\n      }\n\n      return \"/\";\n    },\n    \":\": function _() {\n      if (this._input[this.offset] === \":\") {\n        this.input();\n        return this.tok.T_DOUBLE_COLON;\n      } else {\n        return \":\";\n      }\n    },\n    \"(\": function _() {\n      var initial = this.offset;\n      this.input();\n\n      if (this.is_TABSPACE()) {\n        this.consume_TABSPACE().input();\n      }\n\n      if (this.is_LABEL_START()) {\n        var yylen = this.yytext.length;\n        this.consume_LABEL();\n        var castToken = this.yytext.substring(yylen - 1).toLowerCase();\n        var castId = this.castKeywords[castToken];\n\n        if (typeof castId === \"number\") {\n          this.input();\n\n          if (this.is_TABSPACE()) {\n            this.consume_TABSPACE().input();\n          }\n\n          if (this._input[this.offset - 1] === \")\") {\n            return castId;\n          }\n        }\n      } // revert the check\n\n\n      this.unput(this.offset - initial);\n      return \"(\";\n    },\n    \"=\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \">\") {\n        this.input();\n        return this.tok.T_DOUBLE_ARROW;\n      } else if (nchar === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_EQUAL;\n        }\n      }\n\n      return \"=\";\n    },\n    \"+\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"+\") {\n        this.input();\n        return this.tok.T_INC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_PLUS_EQUAL;\n      }\n\n      return \"+\";\n    },\n    \"!\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_NOT_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_NOT_EQUAL;\n        }\n      }\n\n      return \"!\";\n    },\n    \"?\": function _() {\n      if (this.version >= 700 && this._input[this.offset] === \"?\") {\n        if (this.version >= 704 && this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_COALESCE_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_COALESCE;\n        }\n      }\n\n      return \"?\";\n    },\n    \"<\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"<\") {\n        nchar = this._input[this.offset + 1];\n\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SL_EQUAL;\n        } else if (nchar === \"<\") {\n          if (this.is_HEREDOC()) {\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n\n        this.input();\n        return this.tok.T_SL;\n      } else if (nchar === \"=\") {\n        this.input();\n\n        if (this.version >= 700 && this._input[this.offset] === \">\") {\n          this.input();\n          return this.tok.T_SPACESHIP;\n        } else {\n          return this.tok.T_IS_SMALLER_OR_EQUAL;\n        }\n      } else if (nchar === \">\") {\n        this.input();\n        return this.tok.T_IS_NOT_EQUAL;\n      }\n\n      return \"<\";\n    },\n    \">\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_IS_GREATER_OR_EQUAL;\n      } else if (nchar === \">\") {\n        nchar = this._input[this.offset + 1];\n\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SR_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_SR;\n        }\n      }\n\n      return \">\";\n    },\n    \"*\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MUL_EQUAL;\n      } else if (nchar === \"*\") {\n        this.input();\n\n        if (this._input[this.offset] === \"=\") {\n          this.input();\n          return this.tok.T_POW_EQUAL;\n        } else {\n          return this.tok.T_POW;\n        }\n      }\n\n      return \"*\";\n    },\n    \".\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_CONCAT_EQUAL;\n      } else if (nchar === \".\" && this._input[this.offset + 1] === \".\") {\n        this.consume(2);\n        return this.tok.T_ELLIPSIS;\n      }\n\n      return \".\";\n    },\n    \"%\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_MOD_EQUAL;\n      }\n\n      return \"%\";\n    },\n    \"&\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_AND_EQUAL;\n      } else if (nchar === \"&\") {\n        this.input();\n        return this.tok.T_BOOLEAN_AND;\n      }\n\n      return \"&\";\n    },\n    \"|\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_OR_EQUAL;\n      } else if (nchar === \"|\") {\n        this.input();\n        return this.tok.T_BOOLEAN_OR;\n      }\n\n      return \"|\";\n    },\n    \"^\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_XOR_EQUAL;\n      }\n\n      return \"^\";\n    }\n  }\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar tokens = \";:,.\\\\[]()|^&+-/*=%!~$<>?@\";\nmodule.exports = {\n  // check if the char can be a numeric\n  is_NUM: function is_NUM() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 47 && ch < 58 || ch === 95;\n  },\n  // check if the char can be a numeric\n  is_NUM_START: function is_NUM_START() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 47 && ch < 58;\n  },\n  // check if current char can be a label\n  is_LABEL: function is_LABEL() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 96 && ch < 123 || ch > 64 && ch < 91 || ch === 95 || ch > 47 && ch < 58 || ch > 126;\n  },\n  // check if current char can be a label\n  is_LABEL_START: function is_LABEL_START() {\n    var ch = this._input.charCodeAt(this.offset - 1); // A - Z\n\n\n    if (ch > 64 && ch < 91) return true; // a - z\n\n    if (ch > 96 && ch < 123) return true; // _ (95)\n\n    if (ch === 95) return true; // utf8 / extended\n\n    if (ch > 126) return true; // else\n\n    return false;\n  },\n  // reads each char of the label\n  consume_LABEL: function consume_LABEL() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_LABEL()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this;\n  },\n  // check if current char is a token char\n  is_TOKEN: function is_TOKEN() {\n    var ch = this._input[this.offset - 1];\n    return tokens.indexOf(ch) !== -1;\n  },\n  // check if current char is a whitespace\n  is_WHITESPACE: function is_WHITESPACE() {\n    var ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  },\n  // check if current char is a whitespace (without newlines)\n  is_TABSPACE: function is_TABSPACE() {\n    var ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\";\n  },\n  // consume all whitespaces (excluding newlines)\n  consume_TABSPACE: function consume_TABSPACE() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_TABSPACE()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this;\n  },\n  // check if current char can be a hexadecimal number\n  is_HEX: function is_HEX() {\n    var ch = this._input.charCodeAt(this.offset - 1); // 0 - 9\n\n\n    if (ch > 47 && ch < 58) return true; // A - F\n\n    if (ch > 64 && ch < 71) return true; // a - f\n\n    if (ch > 96 && ch < 103) return true; // _ (code 95)\n\n    if (ch === 95) return true; // else\n\n    return false;\n  }\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * @private\n */\n\nfunction isNumber(n) {\n  return n != \".\" && n != \",\" && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * The PHP Parser class that build the AST tree from the lexer\n *\n * @class\n * @tutorial Parser\n * @property {Lexer} lexer - current lexer instance\n * @property {AST} ast - the AST factory instance\n * @property {Integer|String} token - current token\n * @property {Boolean} extractDoc - should extract documentation as AST node\n * @property {Boolean} extractTokens - should extract each token\n * @property {Boolean} suppressErrors - should ignore parsing errors and continue\n * @property {Boolean} debug - should output debug informations\n */\n\n\nvar parser = function parser(lexer, ast) {\n  this.lexer = lexer;\n  this.ast = ast;\n  this.tok = lexer.tok;\n  this.EOF = lexer.EOF;\n  this.token = null;\n  this.prev = null;\n  this.debug = false;\n  this.version = 704;\n  this.extractDoc = false;\n  this.extractTokens = false;\n  this.suppressErrors = false;\n\n  var mapIt = function mapIt(item) {\n    return [item, null];\n  };\n\n  this.entries = {\n    // reserved_non_modifiers\n    IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(mapIt)),\n    VARIABLE: new Map([this.tok.T_VARIABLE, \"$\", \"&\", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(mapIt)),\n    SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, \"[\", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '\"', 'b\"', 'B\"', \"-\", this.tok.T_NS_SEPARATOR].map(mapIt)),\n    T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(mapIt)),\n    T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(mapIt)),\n    EOS: new Map([\";\", this.EOF, this.tok.T_INLINE_HTML].map(mapIt)),\n    EXPR: new Map([\"@\", \"-\", \"+\", \"!\", \"~\", \"(\", \"`\", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, // using VARIABLES :\n    this.tok.T_VARIABLE, \"$\", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, // using SCALAR :\n    this.tok.T_STRING, // @see variable.js line 45 > conflict with variable = shift/reduce :)\n    this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, \"[\", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '\"', 'b\"', 'B\"', \"-\", this.tok.T_NS_SEPARATOR].map(mapIt))\n  };\n};\n/**\n * helper : gets a token name\n */\n\n\nparser.prototype.getTokenName = function (token) {\n  if (!isNumber(token)) {\n    return \"'\" + token + \"'\";\n  } else {\n    if (token == this.EOF) return \"the end of file (EOF)\";\n    return this.lexer.engine.tokens.values[token];\n  }\n};\n/**\n * main entry point : converts a source code to AST\n */\n\n\nparser.prototype.parse = function (code, filename) {\n  this._errors = [];\n  this.filename = filename || \"eval\";\n  this.currentNamespace = [\"\"];\n\n  if (this.extractDoc) {\n    this._docs = [];\n  } else {\n    this._docs = null;\n  }\n\n  if (this.extractTokens) {\n    this._tokens = [];\n  } else {\n    this._tokens = null;\n  }\n\n  this._docIndex = 0;\n  this._lastNode = null;\n  this.lexer.setInput(code);\n  this.lexer.all_tokens = this.extractTokens;\n  this.lexer.comment_tokens = this.extractDoc;\n  this.length = this.lexer._input.length;\n  this.innerList = false;\n  this.innerListForm = false;\n  var program = this.node(\"program\");\n  var childs = [];\n  this.next();\n\n  while (this.token != this.EOF) {\n    childs.push(this.read_start());\n  } // append last comment\n\n\n  if (childs.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n    childs.push(this.node(\"noop\")());\n  } // #176 : register latest position\n\n\n  this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n  var result = program(childs, this._errors, this._docs, this._tokens);\n\n  if (this.debug) {\n    var errors = this.ast.checkNodes();\n\n    if (errors.length > 0) {\n      errors.forEach(function (error) {\n        if (error.position) {\n          // eslint-disable-next-line no-console\n          console.log(\"Node at line \" + error.position.line + \", column \" + error.position.column);\n        } // eslint-disable-next-line no-console\n\n\n        console.log(error.stack.join(\"\\n\"));\n      });\n      throw new Error(\"Some nodes are not closed\");\n    }\n  }\n\n  return result;\n};\n/**\n * Raise an error\n */\n\n\nparser.prototype.raiseError = function (message, msgExpect, expect, token) {\n  message += \" on line \" + this.lexer.yylloc.first_line;\n\n  if (!this.suppressErrors) {\n    var err = new SyntaxError(message, this.filename, this.lexer.yylloc.first_line);\n    err.lineNumber = this.lexer.yylloc.first_line;\n    err.fileName = this.filename;\n    err.columnNumber = this.lexer.yylloc.first_column;\n    throw err;\n  } // Error node :\n\n\n  var node = this.ast.prepare(\"error\", null, this)(message, token, this.lexer.yylloc.first_line, expect);\n\n  this._errors.push(node);\n\n  return node;\n};\n/**\n * handling errors\n */\n\n\nparser.prototype.error = function (expect) {\n  var msg = \"Parse Error : syntax error\";\n  var token = this.getTokenName(this.token);\n  var msgExpect = \"\";\n\n  if (this.token !== this.EOF) {\n    if (isNumber(this.token)) {\n      var symbol = this.text();\n\n      if (symbol.length > 10) {\n        symbol = symbol.substring(0, 7) + \"...\";\n      }\n\n      token = \"'\" + symbol + \"' (\" + token + \")\";\n    }\n\n    msg += \", unexpected \" + token;\n  }\n\n  if (expect && !Array.isArray(expect)) {\n    if (isNumber(expect) || expect.length === 1) {\n      msgExpect = \", expecting \" + this.getTokenName(expect);\n    }\n\n    msg += msgExpect;\n  }\n\n  return this.raiseError(msg, msgExpect, expect, token);\n};\n/**\n * Creates a new AST node\n */\n\n\nparser.prototype.node = function (name) {\n  if (this.extractDoc) {\n    var docs = null;\n\n    if (this._docIndex < this._docs.length) {\n      docs = this._docs.slice(this._docIndex);\n      this._docIndex = this._docs.length;\n\n      if (this.debug) {\n        // eslint-disable-next-line no-console\n        console.log(new Error(\"Append docs on \" + name)); // eslint-disable-next-line no-console\n\n        console.log(docs);\n      }\n    }\n\n    var node = this.ast.prepare(name, docs, this);\n    /**\n     * TOKENS :\n     * node1 commentA token commmentB node2 commentC token commentD node3 commentE token\n     *\n     * AST :\n     * structure:S1 [\n     *    left: node1 ( trail: commentA ),\n     *    right: structure:S2 [\n     *       node2 (lead: commentB, trail: commentC),\n     *       node3 (lead: commentD)\n     *    ],\n     *    trail: commentE\n     * ]\n     *\n     * Algorithm :\n     *\n     * Attach the last comments on parent of current node\n     * If a new node is started and the parent has a trailing comment\n     * the move it on previous node\n     *\n     * start S2\n     * start node1\n     * consume node1 & set commentA as trailingComment on S2\n     * start S2\n     * S1 has a trailingComment, attach it on node1\n     * ...\n     * NOTE : As the trailingComment Behavior depends on AST, it will be build on\n     * the AST layer - last child node will keep it's trailingComment nodes\n     */\n\n    node.postBuild = function (self) {\n      if (this._docIndex < this._docs.length) {\n        if (this._lastNode) {\n          var offset = this.prev[2];\n          var max = this._docIndex;\n\n          for (; max < this._docs.length; max++) {\n            if (this._docs[max].offset > offset) {\n              break;\n            }\n          }\n\n          if (max > this._docIndex) {\n            // inject trailing comment on child node\n            this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, max));\n\n            this._docIndex = max;\n          }\n        } else if (this.token === this.EOF) {\n          // end of content\n          self.setTrailingComments(this._docs.slice(this._docIndex));\n          this._docIndex = this._docs.length;\n        }\n      }\n\n      this._lastNode = self;\n    }.bind(this);\n\n    return node;\n  }\n\n  return this.ast.prepare(name, null, this);\n};\n/**\n * expects an end of statement or end of file\n * @return {boolean}\n */\n\n\nparser.prototype.expectEndOfStatement = function (node) {\n  if (this.token === \";\") {\n    // include only real ';' statements\n    // https://github.com/glayzzle/php-parser/issues/164\n    if (node && this.lexer.yytext === \";\") {\n      node.includeToken(this);\n    }\n  } else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {\n    this.error(\";\");\n    return false;\n  }\n\n  this.next();\n  return true;\n};\n/** outputs some debug information on current token **/\n\n\nvar ignoreStack = [\"parser.next\", \"parser.node\", \"parser.showlog\"];\n\nparser.prototype.showlog = function () {\n  var stack = new Error().stack.split(\"\\n\");\n  var line;\n\n  for (var offset = 2; offset < stack.length; offset++) {\n    line = stack[offset].trim();\n    var found = false;\n\n    for (var i = 0; i < ignoreStack.length; i++) {\n      if (line.substring(3, 3 + ignoreStack[i].length) === ignoreStack[i]) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      break;\n    }\n  } // eslint-disable-next-line no-console\n\n\n  console.log(\"Line \" + this.lexer.yylloc.first_line + \" : \" + this.getTokenName(this.token) + \">\" + this.lexer.yytext + \"<\" + \" @-->\" + line);\n  return this;\n};\n/**\n * Force the parser to check the current token.\n *\n * If the current token does not match to expected token,\n * the an error will be raised.\n *\n * If the suppressError mode is activated, then the error will\n * be added to the program error stack and this function will return `false`.\n *\n * @param {String|Number} token\n * @return {boolean}\n * @throws Error\n */\n\n\nparser.prototype.expect = function (token) {\n  if (Array.isArray(token)) {\n    if (token.indexOf(this.token) === -1) {\n      this.error(token);\n      return false;\n    }\n  } else if (this.token != token) {\n    this.error(token);\n    return false;\n  }\n\n  return true;\n};\n/**\n * Returns the current token contents\n * @return {String}\n */\n\n\nparser.prototype.text = function () {\n  return this.lexer.yytext;\n};\n/** consume the next token **/\n\n\nparser.prototype.next = function () {\n  // prepare the back command\n  if (this.token !== \";\" || this.lexer.yytext === \";\") {\n    // ignore '?>' from automated resolution\n    // https://github.com/glayzzle/php-parser/issues/168\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n  } // eating the token\n\n\n  this.lex(); // showing the debug\n\n  if (this.debug) {\n    this.showlog();\n  } // handling comments\n\n\n  if (this.extractDoc) {\n    while (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) {\n      // APPEND COMMENTS\n      if (this.token === this.tok.T_COMMENT) {\n        this._docs.push(this.read_comment());\n      } else {\n        this._docs.push(this.read_doc_comment());\n      }\n    }\n  }\n\n  return this;\n};\n/**\n * Eating a token\n */\n\n\nparser.prototype.lex = function () {\n  // append on token stack\n  if (this.extractTokens) {\n    do {\n      // the token\n      this.token = this.lexer.lex() || this.EOF;\n      if (this.token === this.EOF) return this;\n      var entry = this.lexer.yytext;\n\n      if (this.lexer.engine.tokens.values.hasOwnProperty(this.token)) {\n        entry = [this.lexer.engine.tokens.values[this.token], entry, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset];\n      } else {\n        entry = [null, entry, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset];\n      }\n\n      this._tokens.push(entry);\n\n      if (this.token === this.tok.T_CLOSE_TAG) {\n        // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n        this.token = \";\";\n        return this;\n      } else if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO) {\n        this.token = this.tok.T_ECHO;\n        return this;\n      }\n    } while (this.token === this.tok.T_WHITESPACE || // ignore white space\n    !this.extractDoc && (this.token === this.tok.T_COMMENT || // ignore single lines comments\n    this.token === this.tok.T_DOC_COMMENT) || // ignore doc comments\n    // ignore open tags\n    this.token === this.tok.T_OPEN_TAG);\n  } else {\n    this.token = this.lexer.lex() || this.EOF;\n  }\n\n  return this;\n};\n/**\n * Check if token is of specified type\n */\n\n\nparser.prototype.is = function (type) {\n  if (Array.isArray(type)) {\n    return type.indexOf(this.token) !== -1;\n  }\n\n  return this.entries[type].has(this.token);\n}; // extends the parser with syntax files\n\n\n[__webpack_require__(24), __webpack_require__(25), __webpack_require__(26), __webpack_require__(27), __webpack_require__(28), __webpack_require__(29), __webpack_require__(30), __webpack_require__(31), __webpack_require__(32), __webpack_require__(33), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38)].forEach(function (ext) {\n  for (var k in ext) {\n    if (parser.prototype.hasOwnProperty(k)) {\n      // @see https://github.com/glayzzle/php-parser/issues/234\n      throw new Error(\"Function \" + k + \" is already defined - collision\");\n    }\n\n    parser.prototype[k] = ext[k];\n  }\n});\nmodule.exports = parser;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Parse an array\n   * ```ebnf\n   * array ::= T_ARRAY '(' array_pair_list ')' |\n   *   '[' array_pair_list ']'\n   * ```\n   */\n  read_array: function read_array() {\n    var expect = null;\n    var shortForm = false;\n    var result = this.node(\"array\");\n\n    if (this.token === this.tok.T_ARRAY) {\n      this.next().expect(\"(\");\n      expect = \")\";\n    } else {\n      shortForm = true;\n      expect = \"]\";\n    }\n\n    var items = [];\n\n    if (this.next().token !== expect) {\n      items = this.read_array_pair_list(shortForm);\n    }\n\n    this.expect(expect);\n    this.next();\n    return result(shortForm, items);\n  },\n\n  /**\n   * Reads an array of items\n   * ```ebnf\n   * array_pair_list ::= array_pair (',' array_pair?)*\n   * ```\n   */\n  read_array_pair_list: function read_array_pair_list(shortForm) {\n    var self = this;\n    return this.read_list(function () {\n      return self.read_array_pair(shortForm);\n    }, \",\", true);\n  },\n\n  /**\n   * Reads an entry\n   * array_pair:\n   *  expr T_DOUBLE_ARROW expr\n   *  | expr\n   *  | expr T_DOUBLE_ARROW '&' variable\n   *  | '&' variable\n   *  | expr T_DOUBLE_ARROW T_LIST '(' array_pair_list ')'\n   *  | T_LIST '(' array_pair_list ')'\n   */\n  read_array_pair: function read_array_pair(shortForm) {\n    if (!shortForm && this.token === \")\" || shortForm && this.token === \"]\") {\n      return;\n    }\n\n    if (this.token === \",\") {\n      return this.node(\"noop\")();\n    }\n\n    var entry = this.node(\"entry\");\n    var key = null;\n    var value = null;\n    var byRef = false;\n    var unpack = false;\n\n    if (this.token === \"&\") {\n      this.next();\n      byRef = true;\n      value = this.read_variable(true, false);\n    } else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704) {\n      this.next();\n\n      if (this.token === \"&\") {\n        this.error();\n      }\n\n      unpack = true;\n      value = this.read_expr();\n    } else {\n      var expr = this.read_expr();\n\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        this.next();\n        key = expr;\n\n        if (this.token === \"&\") {\n          this.next();\n          byRef = true;\n          value = this.read_variable(true, false);\n        } else {\n          value = this.read_expr();\n        }\n      } else {\n        value = expr;\n      }\n    }\n\n    return entry(key, value, byRef, unpack);\n  }\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = {\n  /**\n   * reading a class\n   * ```ebnf\n   * class ::= class_scope? T_CLASS T_STRING (T_EXTENDS NAMESPACE_NAME)? (T_IMPLEMENTS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' CLASS_BODY '}'\n   * ```\n   */\n  read_class_declaration_statement: function read_class_declaration_statement() {\n    var result = this.node(\"class\");\n    var flag = this.read_class_modifiers(); // graceful mode : ignore token & go next\n\n    if (this.token !== this.tok.T_CLASS) {\n      this.error(this.tok.T_CLASS);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    var propExtends = this.read_extends_from();\n    var propImplements = this.read_implements_list();\n    this.expect(\"{\");\n    var body = this.next().read_class_body();\n    return result(propName, propExtends, propImplements, body, flag);\n  },\n  read_class_modifiers: function read_class_modifiers() {\n    return [0, 0, this.read_class_modifier()];\n  },\n  read_class_modifier: function read_class_modifier() {\n    var result = 0;\n\n    if (this.token === this.tok.T_ABSTRACT) {\n      this.next();\n      return 1;\n    } else if (this.token === this.tok.T_FINAL) {\n      this.next();\n      return 2;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a class body\n   * ```ebnf\n   *   class_body ::= (member_flags? (T_VAR | T_STRING | T_FUNCTION))*\n   * ```\n   */\n  read_class_body: function read_class_body() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      } // check T_USE trait\n\n\n      if (this.token === this.tok.T_USE) {\n        result = result.concat(this.read_trait_use_statement());\n        continue;\n      } // read member flags\n\n\n      var flags = this.read_member_flags(false); // check constant\n\n      if (this.token === this.tok.T_CONST) {\n        var constants = this.read_constant_list(flags);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n\n        result = result.concat(constants);\n        continue;\n      } // jump over T_VAR then land on T_VARIABLE\n\n\n      if (this.token === this.tok.T_VAR) {\n        this.next().expect(this.tok.T_VARIABLE);\n        flags[0] = null; // public (as null)\n\n        flags[1] = 0; // non static var\n      }\n\n      if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        result.push(this.read_function(false, flags));\n      } else if (this.token === this.tok.T_VARIABLE || // support https://wiki.php.net/rfc/typed_properties_v2\n      this.version >= 704 && (this.token === \"?\" || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_ARRAY || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE)) {\n        // reads a variable\n        var variables = this.read_variable_list(flags);\n        this.expect(\";\");\n        this.next();\n        result = result.concat(variables);\n      } else {\n        // raise an error\n        this.error([this.tok.T_CONST, this.tok.T_VARIABLE, this.tok.T_FUNCTION]); // ignore token\n\n        this.next();\n      }\n    }\n\n    this.expect(\"}\");\n    this.next();\n    return result;\n  },\n\n  /**\n   * Reads variable list\n   * ```ebnf\n   *  variable_list ::= (variable_declaration ',')* variable_declaration\n   * ```\n   */\n  read_variable_list: function read_variable_list(flags) {\n    var result = this.node(\"propertystatement\");\n    var properties = this.read_list(\n    /**\n     * Reads a variable declaration\n     *\n     * ```ebnf\n     *  variable_declaration ::= T_VARIABLE '=' scalar\n     * ```\n     */\n    function read_variable_declaration() {\n      var result = this.node(\"property\");\n\n      var _this$read_optional_t = this.read_optional_type(),\n          _this$read_optional_t2 = _slicedToArray(_this$read_optional_t, 2),\n          nullable = _this$read_optional_t2[0],\n          type = _this$read_optional_t2[1];\n\n      this.expect(this.tok.T_VARIABLE);\n      var propName = this.node(\"identifier\");\n      var name = this.text().substring(1); // ignore $\n\n      this.next();\n      propName = propName(name);\n\n      if (this.token === \";\" || this.token === \",\") {\n        return result(propName, null, nullable, type);\n      } else if (this.token === \"=\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L815\n        return result(propName, this.next().read_expr(), nullable, type);\n      } else {\n        this.expect([\",\", \";\", \"=\"]);\n        return result(propName, null, nullable, type);\n      }\n    }, \",\");\n    return result(null, properties, flags);\n  },\n\n  /**\n   * Reads constant list\n   * ```ebnf\n   *  constant_list ::= T_CONST (constant_declaration ',')* constant_declaration\n   * ```\n   */\n  read_constant_list: function read_constant_list(flags) {\n    if (this.expect(this.tok.T_CONST)) {\n      this.next();\n    }\n\n    var result = this.node(\"classconstant\");\n    var items = this.read_list(\n    /**\n     * Reads a constant declaration\n     *\n     * ```ebnf\n     *  constant_declaration ::= (T_STRING | IDENTIFIER) '=' expr\n     * ```\n     * @return {Constant} [:link:](AST.md#constant)\n     */\n    function read_constant_declaration() {\n      var result = this.node(\"constant\");\n      var constName = null;\n      var value = null;\n\n      if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n        constName = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        constName = constName(name);\n      } else {\n        this.expect(\"IDENTIFIER\");\n      }\n\n      if (this.expect(\"=\")) {\n        value = this.next().read_expr();\n      }\n\n      return result(constName, value);\n    }, \",\");\n    return result(null, items, flags);\n  },\n\n  /**\n   * Read member flags\n   * @return array\n   *  1st index : 0 => public, 1 => protected, 2 => private\n   *  2nd index : 0 => instance member, 1 => static member\n   *  3rd index : 0 => normal, 1 => abstract member, 2 => final member\n   */\n  read_member_flags: function read_member_flags(asInterface) {\n    var result = [-1, -1, -1];\n\n    if (this.is(\"T_MEMBER_FLAGS\")) {\n      var idx = 0,\n          val = 0;\n\n      do {\n        switch (this.token) {\n          case this.tok.T_PUBLIC:\n            idx = 0;\n            val = 0;\n            break;\n\n          case this.tok.T_PROTECTED:\n            idx = 0;\n            val = 1;\n            break;\n\n          case this.tok.T_PRIVATE:\n            idx = 0;\n            val = 2;\n            break;\n\n          case this.tok.T_STATIC:\n            idx = 1;\n            val = 1;\n            break;\n\n          case this.tok.T_ABSTRACT:\n            idx = 2;\n            val = 1;\n            break;\n\n          case this.tok.T_FINAL:\n            idx = 2;\n            val = 2;\n            break;\n        }\n\n        if (asInterface) {\n          if (idx == 0 && val == 2) {\n            // an interface can't be private\n            this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]);\n            val = -1;\n          } else if (idx == 2 && val == 1) {\n            // an interface cant be abstract\n            this.error();\n            val = -1;\n          }\n        }\n\n        if (result[idx] !== -1) {\n          // already defined flag\n          this.error();\n        } else if (val !== -1) {\n          result[idx] = val;\n        }\n      } while (this.next().is(\"T_MEMBER_FLAGS\"));\n    }\n\n    if (result[1] == -1) result[1] = 0;\n    if (result[2] == -1) result[2] = 0;\n    return result;\n  },\n\n  /**\n   * optional_type:\n   *\t  /- empty -/\t{ $$ = NULL; }\n   *   |\ttype_expr\t{ $$ = $1; }\n   * ;\n   *\n   * type_expr:\n   *\t\ttype\t\t{ $$ = $1; }\n   *\t|\t'?' type\t{ $$ = $2; $$->attr |= ZEND_TYPE_NULLABLE; }\n   *\t|\tunion_type\t{ $$ = $1; }\n   * ;\n   *\n   * type:\n   * \t\tT_ARRAY\t\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_ARRAY); }\n   * \t|\tT_CALLABLE\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_CALLABLE); }\n   * \t|\tname\t\t{ $$ = $1; }\n   * ;\n   *\n   * union_type:\n   * \t\ttype '|' type       { $$ = zend_ast_create_list(2, ZEND_AST_TYPE_UNION, $1, $3); }\n   * \t|\tunion_type '|' type { $$ = zend_ast_list_add($1, $3); }\n   * ;\n   */\n  read_optional_type: function read_optional_type() {\n    var nullable = false;\n\n    if (this.token === \"?\") {\n      nullable = true;\n      this.next();\n    }\n\n    var type = this.read_type();\n\n    if (nullable && !type) {\n      this.raiseError(\"Expecting a type definition combined with nullable operator\");\n    }\n\n    if (!nullable && !type) {\n      return [false, null];\n    }\n\n    if (this.token === \"|\") {\n      type = [type];\n\n      do {\n        this.next();\n        var variant = this.read_type();\n\n        if (!variant) {\n          this.raiseError(\"Expecting a type definition\");\n          break;\n        }\n\n        type.push(variant);\n      } while (this.token === \"|\");\n    }\n\n    return [nullable, type];\n  },\n\n  /**\n   * reading an interface\n   * ```ebnf\n   * interface ::= T_INTERFACE T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' INTERFACE_BODY '}'\n   * ```\n   */\n  read_interface_declaration_statement: function read_interface_declaration_statement() {\n    var result = this.node(\"interface\");\n\n    if (this.token !== this.tok.T_INTERFACE) {\n      this.error(this.tok.T_INTERFACE);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    var propExtends = this.read_interface_extends_list();\n    this.expect(\"{\");\n    var body = this.next().read_interface_body();\n    return result(propName, propExtends, body);\n  },\n\n  /**\n   * Reads an interface body\n   * ```ebnf\n   *   interface_body ::= (member_flags? (T_CONST | T_FUNCTION))*\n   * ```\n   */\n  read_interface_body: function read_interface_body() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      } // read member flags\n\n\n      var flags = this.read_member_flags(true); // check constant\n\n      if (this.token == this.tok.T_CONST) {\n        var constants = this.read_constant_list(flags);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n\n        result = result.concat(constants);\n      } else if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        var method = this.read_function_declaration(2, flags);\n        method.parseFlags(flags);\n        result.push(method);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n      } else {\n        // raise an error\n        this.error([this.tok.T_CONST, this.tok.T_FUNCTION]);\n        this.next();\n      }\n    }\n\n    if (this.expect(\"}\")) {\n      this.next();\n    }\n\n    return result;\n  },\n\n  /**\n   * reading a trait\n   * ```ebnf\n   * trait ::= T_TRAIT T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' FUNCTION* '}'\n   * ```\n   */\n  read_trait_declaration_statement: function read_trait_declaration_statement() {\n    var result = this.node(\"trait\"); // graceful mode : ignore token & go next\n\n    if (this.token !== this.tok.T_TRAIT) {\n      this.error(this.tok.T_TRAIT);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    this.expect(\"{\");\n    var body = this.next().read_class_body();\n    return result(propName, body);\n  },\n\n  /**\n   * reading a use statement\n   * ```ebnf\n   * trait_use_statement ::= namespace_name (',' namespace_name)* ('{' trait_use_alias '}')?\n   * ```\n   */\n  read_trait_use_statement: function read_trait_use_statement() {\n    // defines use statements\n    var node = this.node(\"traituse\");\n    this.expect(this.tok.T_USE) && this.next();\n    var traits = [this.read_namespace_name()];\n    var adaptations = null;\n\n    while (this.token === \",\") {\n      traits.push(this.next().read_namespace_name());\n    }\n\n    if (this.token === \"{\") {\n      adaptations = []; // defines alias statements\n\n      while (this.next().token !== this.EOF) {\n        if (this.token === \"}\") break;\n        adaptations.push(this.read_trait_use_alias());\n        this.expect(\";\");\n      }\n\n      if (this.expect(\"}\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    }\n\n    return node(traits, adaptations);\n  },\n\n  /**\n   * Reading trait alias\n   * ```ebnf\n   * trait_use_alias ::= namespace_name ( T_DOUBLE_COLON T_STRING )? (T_INSTEADOF namespace_name) | (T_AS member_flags? T_STRING)\n   * ```\n   * name list : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L303\n   * trait adaptation : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L742\n   */\n  read_trait_use_alias: function read_trait_use_alias() {\n    var node = this.node();\n    var trait = null;\n    var method;\n\n    if (this.is(\"IDENTIFIER\")) {\n      method = this.node(\"identifier\");\n      var methodName = this.text();\n      this.next();\n      method = method(methodName);\n    } else {\n      method = this.read_namespace_name();\n\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        this.next();\n\n        if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n          trait = method;\n          method = this.node(\"identifier\");\n\n          var _methodName = this.text();\n\n          this.next();\n          method = method(_methodName);\n        } else {\n          this.expect(this.tok.T_STRING);\n        }\n      } else {\n        // convert identifier as string\n        method = method.name;\n      }\n    } // handle trait precedence\n\n\n    if (this.token === this.tok.T_INSTEADOF) {\n      return node(\"traitprecedence\", trait, method, this.next().read_name_list());\n    } else if (this.token === this.tok.T_AS) {\n      // handle trait alias\n      var flags = null;\n      var alias = null;\n\n      if (this.next().is(\"T_MEMBER_FLAGS\")) {\n        flags = this.read_member_flags();\n      }\n\n      if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n        alias = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        alias = alias(name);\n      } else if (flags === false) {\n        // no visibility flags and no name => too bad\n        this.expect(this.tok.T_STRING);\n      }\n\n      return node(\"traitalias\", trait, method, alias, flags);\n    } // handle errors\n\n\n    this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]);\n    return node(\"traitalias\", trait, method, null, null);\n  }\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   *  Comments with // or # or / * ... * /\n   */\n  read_comment: function read_comment() {\n    var text = this.text();\n    var result = this.ast.prepare(text.substring(0, 2) === \"/*\" ? \"commentblock\" : \"commentline\", null, this);\n    var offset = this.lexer.yylloc.first_offset; // handle location on comment\n\n    var prev = this.prev;\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  },\n\n  /**\n   * Comments with / ** ... * /\n   */\n  read_doc_comment: function read_doc_comment() {\n    var result = this.ast.prepare(\"commentblock\", null, this);\n    var offset = this.lexer.yylloc.first_offset;\n    var text = this.text();\n    var prev = this.prev;\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  }\n};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  read_expr: function read_expr(expr) {\n    var result = this.node();\n\n    if (this.token === \"@\") {\n      if (!expr) {\n        expr = this.next().read_expr();\n      }\n\n      return result(\"silent\", expr);\n    }\n\n    if (!expr) {\n      expr = this.read_expr_item();\n    } // binary operations\n\n\n    if (this.token === \"|\") return result(\"bin\", \"|\", expr, this.next().read_expr());\n    if (this.token === \"&\") return result(\"bin\", \"&\", expr, this.next().read_expr());\n    if (this.token === \"^\") return result(\"bin\", \"^\", expr, this.next().read_expr());\n    if (this.token === \".\") return result(\"bin\", \".\", expr, this.next().read_expr());\n    if (this.token === \"+\") return result(\"bin\", \"+\", expr, this.next().read_expr());\n    if (this.token === \"-\") return result(\"bin\", \"-\", expr, this.next().read_expr());\n    if (this.token === \"*\") return result(\"bin\", \"*\", expr, this.next().read_expr());\n    if (this.token === \"/\") return result(\"bin\", \"/\", expr, this.next().read_expr());\n    if (this.token === \"%\") return result(\"bin\", \"%\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_POW) return result(\"bin\", \"**\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SL) return result(\"bin\", \"<<\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SR) return result(\"bin\", \">>\", expr, this.next().read_expr()); // more binary operations (formerly bool)\n\n    if (this.token === this.tok.T_BOOLEAN_OR) return result(\"bin\", \"||\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_OR) return result(\"bin\", \"or\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_BOOLEAN_AND) return result(\"bin\", \"&&\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_AND) return result(\"bin\", \"and\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_XOR) return result(\"bin\", \"xor\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_IDENTICAL) return result(\"bin\", \"===\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_IDENTICAL) return result(\"bin\", \"!==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_EQUAL) return result(\"bin\", \"==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_EQUAL) return result(\"bin\", \"!=\", expr, this.next().read_expr());\n    if (this.token === \"<\") return result(\"bin\", \"<\", expr, this.next().read_expr());\n    if (this.token === \">\") return result(\"bin\", \">\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL) return result(\"bin\", \"<=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_GREATER_OR_EQUAL) return result(\"bin\", \">=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SPACESHIP) return result(\"bin\", \"<=>\", expr, this.next().read_expr());\n\n    if (this.token === this.tok.T_INSTANCEOF) {\n      expr = result(\"bin\", \"instanceof\", expr, this.next().read_class_name_reference());\n\n      if (this.token !== \";\" && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {\n        expr = this.read_expr(expr);\n      }\n    } // extra operations :\n    // $username = $_GET['user'] ?? 'nobody';\n\n\n    if (this.token === this.tok.T_COALESCE) return result(\"bin\", \"??\", expr, this.next().read_expr()); // extra operations :\n    // $username = $_GET['user'] ? true : false;\n\n    if (this.token === \"?\") {\n      var trueArg = null;\n\n      if (this.next().token !== \":\") {\n        trueArg = this.read_expr();\n      }\n\n      this.expect(\":\") && this.next();\n      return result(\"retif\", expr, trueArg, this.read_expr());\n    } else {\n      // see #193\n      result.destroy(expr);\n    }\n\n    return expr;\n  },\n\n  /**\n   * Reads a cast expression\n   */\n  read_expr_cast: function read_expr_cast(type) {\n    return this.node(\"cast\")(type, this.text(), this.next().read_expr());\n  },\n\n  /**\n   * Read a isset variable\n   */\n  read_isset_variable: function read_isset_variable() {\n    return this.read_expr();\n  },\n\n  /**\n   * Reads isset variables\n   */\n  read_isset_variables: function read_isset_variables() {\n    return this.read_function_list(this.read_isset_variable, \",\");\n  },\n\n  /*\n   * Reads internal PHP functions\n   */\n  read_internal_functions_in_yacc: function read_internal_functions_in_yacc() {\n    var result = null;\n\n    switch (this.token) {\n      case this.tok.T_ISSET:\n        {\n          result = this.node(\"isset\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var variables = this.read_isset_variables();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(variables);\n        }\n        break;\n\n      case this.tok.T_EMPTY:\n        {\n          result = this.node(\"empty\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var expression = this.read_expr();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(expression);\n        }\n        break;\n\n      case this.tok.T_INCLUDE:\n        result = this.node(\"include\")(false, false, this.next().read_expr());\n        break;\n\n      case this.tok.T_INCLUDE_ONCE:\n        result = this.node(\"include\")(true, false, this.next().read_expr());\n        break;\n\n      case this.tok.T_EVAL:\n        {\n          result = this.node(\"eval\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var expr = this.read_expr();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(expr);\n        }\n        break;\n\n      case this.tok.T_REQUIRE:\n        result = this.node(\"include\")(false, true, this.next().read_expr());\n        break;\n\n      case this.tok.T_REQUIRE_ONCE:\n        result = this.node(\"include\")(true, true, this.next().read_expr());\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads optional expression\n   */\n  read_optional_expr: function read_optional_expr(stopToken) {\n    if (this.token !== stopToken) {\n      return this.read_expr();\n    }\n\n    return null;\n  },\n\n  /**\n   * Reads exit expression\n   */\n  read_exit_expr: function read_exit_expr() {\n    var expression = null;\n\n    if (this.token === \"(\") {\n      this.next();\n      expression = this.read_optional_expr(\")\");\n      this.expect(\")\") && this.next();\n    }\n\n    return expression;\n  },\n\n  /**\n   * ```ebnf\n   * Reads an expression\n   *  expr ::= @todo\n   * ```\n   */\n  read_expr_item: function read_expr_item() {\n    var result, expr;\n    if (this.token === \"+\") return this.node(\"unary\")(\"+\", this.next().read_expr());\n    if (this.token === \"-\") return this.node(\"unary\")(\"-\", this.next().read_expr());\n    if (this.token === \"!\") return this.node(\"unary\")(\"!\", this.next().read_expr());\n    if (this.token === \"~\") return this.node(\"unary\")(\"~\", this.next().read_expr());\n\n    if (this.token === \"(\") {\n      expr = this.next().read_expr();\n      expr.parenthesizedExpression = true;\n      this.expect(\")\") && this.next();\n      return this.handleDereferencable(expr);\n    }\n\n    if (this.token === \"`\") {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1048\n      return this.read_encapsed_string(\"`\");\n    }\n\n    if (this.token === this.tok.T_LIST) {\n      var assign = null;\n      var isInner = this.innerList;\n      result = this.node(\"list\");\n\n      if (!isInner) {\n        assign = this.node(\"assign\");\n      }\n\n      if (this.next().expect(\"(\")) {\n        this.next();\n      }\n\n      if (!this.innerList) this.innerList = true; // reads inner items\n\n      var assignList = this.read_array_pair_list(false);\n\n      if (this.expect(\")\")) {\n        this.next();\n      } // check if contains at least one assignment statement\n\n\n      var hasItem = false;\n\n      for (var i = 0; i < assignList.length; i++) {\n        if (assignList[i] !== null && assignList[i].kind !== \"noop\") {\n          hasItem = true;\n          break;\n        }\n      }\n\n      if (!hasItem) {\n        this.raiseError(\"Fatal Error :  Cannot use empty list on line \" + this.lexer.yylloc.first_line);\n      } // handles the node resolution\n\n\n      if (!isInner) {\n        this.innerList = false;\n\n        if (this.expect(\"=\")) {\n          return assign(result(assignList, false), this.next().read_expr(), \"=\");\n        } else {\n          // error fallback : list($a, $b);\n          return result(assignList, false);\n        }\n      } else {\n        return result(assignList, false);\n      }\n    }\n\n    if (this.token === this.tok.T_CLONE) return this.node(\"clone\")(this.next().read_expr());\n\n    switch (this.token) {\n      case this.tok.T_INC:\n        return this.node(\"pre\")(\"+\", this.next().read_variable(false, false));\n\n      case this.tok.T_DEC:\n        return this.node(\"pre\")(\"-\", this.next().read_variable(false, false));\n\n      case this.tok.T_NEW:\n        return this.read_new_expr();\n\n      case this.tok.T_ISSET:\n      case this.tok.T_EMPTY:\n      case this.tok.T_INCLUDE:\n      case this.tok.T_INCLUDE_ONCE:\n      case this.tok.T_EVAL:\n      case this.tok.T_REQUIRE:\n      case this.tok.T_REQUIRE_ONCE:\n        return this.read_internal_functions_in_yacc();\n\n      case this.tok.T_INT_CAST:\n        return this.read_expr_cast(\"int\");\n\n      case this.tok.T_DOUBLE_CAST:\n        return this.read_expr_cast(\"float\");\n\n      case this.tok.T_STRING_CAST:\n        return this.read_expr_cast(this.text().indexOf(\"binary\") !== -1 ? \"binary\" : \"string\");\n\n      case this.tok.T_ARRAY_CAST:\n        return this.read_expr_cast(\"array\");\n\n      case this.tok.T_OBJECT_CAST:\n        return this.read_expr_cast(\"object\");\n\n      case this.tok.T_BOOL_CAST:\n        return this.read_expr_cast(\"bool\");\n\n      case this.tok.T_UNSET_CAST:\n        return this.read_expr_cast(\"unset\");\n\n      case this.tok.T_EXIT:\n        {\n          var useDie = this.lexer.yytext.toLowerCase() === \"die\";\n          result = this.node(\"exit\");\n          this.next();\n          var expression = this.read_exit_expr();\n          return result(expression, useDie);\n        }\n\n      case this.tok.T_PRINT:\n        return this.node(\"print\")(this.next().read_expr());\n      // T_YIELD (expr (T_DOUBLE_ARROW expr)?)?\n\n      case this.tok.T_YIELD:\n        {\n          var value = null;\n          var key = null;\n          result = this.node(\"yield\");\n\n          if (this.next().is(\"EXPR\")) {\n            // reads the yield return value\n            value = this.read_expr();\n\n            if (this.token === this.tok.T_DOUBLE_ARROW) {\n              // reads the yield returned key\n              key = value;\n              value = this.next().read_expr();\n            }\n          }\n\n          return result(value, key);\n        }\n      // T_YIELD_FROM expr\n\n      case this.tok.T_YIELD_FROM:\n        result = this.node(\"yieldfrom\");\n        expr = this.next().read_expr();\n        return result(expr);\n\n      case this.tok.T_FN:\n      case this.tok.T_FUNCTION:\n        return this.read_inline_function();\n\n      case this.tok.T_STATIC:\n        {\n          var backup = [this.token, this.lexer.getState()];\n          this.next();\n\n          if (this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN) {\n            // handles static function\n            return this.read_inline_function([0, 1, 0]);\n          } else {\n            // rollback\n            this.lexer.tokens.push(backup);\n            this.next();\n          }\n        }\n    } // SCALAR | VARIABLE\n\n\n    if (this.is(\"VARIABLE\")) {\n      result = this.node();\n      expr = this.read_variable(false, false); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L877\n      // should accept only a variable\n\n      var isConst = expr.kind === \"identifier\" || expr.kind === \"staticlookup\" && expr.offset.kind === \"identifier\"; // VARIABLES SPECIFIC OPERATIONS\n\n      switch (this.token) {\n        case \"=\":\n          {\n            if (isConst) this.error(\"VARIABLE\");\n\n            if (this.next().token == \"&\") {\n              return this.read_assignref(result, expr);\n            }\n\n            return result(\"assign\", expr, this.read_expr(), \"=\");\n          }\n        // operations :\n\n        case this.tok.T_PLUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"+=\");\n\n        case this.tok.T_MINUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"-=\");\n\n        case this.tok.T_MUL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"*=\");\n\n        case this.tok.T_POW_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"**=\");\n\n        case this.tok.T_DIV_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"/=\");\n\n        case this.tok.T_CONCAT_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \".=\");\n\n        case this.tok.T_MOD_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"%=\");\n\n        case this.tok.T_AND_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"&=\");\n\n        case this.tok.T_OR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"|=\");\n\n        case this.tok.T_XOR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"^=\");\n\n        case this.tok.T_SL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"<<=\");\n\n        case this.tok.T_SR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \">>=\");\n\n        case this.tok.T_COALESCE_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"??=\");\n\n        case this.tok.T_INC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"+\", expr);\n\n        case this.tok.T_DEC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"-\", expr);\n\n        default:\n          // see #193\n          result.destroy(expr);\n      }\n    } else if (this.is(\"SCALAR\")) {\n      result = this.node();\n      expr = this.read_scalar();\n\n      if (expr.kind === \"array\" && expr.shortForm && this.token === \"=\") {\n        // list assign\n        var list = this.node(\"list\")(expr.items, true);\n        if (expr.loc) list.loc = expr.loc;\n        var right = this.next().read_expr();\n        return result(\"assign\", list, right, \"=\");\n      } else {\n        // see #189 - swap docs on nodes\n        result.destroy(expr);\n      } // classic array\n\n\n      return this.handleDereferencable(expr);\n    } else {\n      this.error(\"EXPR\");\n      this.next();\n    } // returns variable | scalar\n\n\n    return expr;\n  },\n\n  /**\n   * Reads assignment\n   * @param {*} left\n   */\n  read_assignref: function read_assignref(result, left) {\n    this.next();\n    var right;\n\n    if (this.token === this.tok.T_NEW) {\n      if (this.version >= 700) {\n        this.error();\n      }\n\n      right = this.read_new_expr();\n    } else {\n      right = this.read_variable(false, false);\n    }\n\n    return result(\"assignref\", left, right);\n  },\n\n  /**\n   *\n   * inline_function:\n   * \t\tfunction returns_ref backup_doc_comment '(' parameter_list ')' lexical_vars return_type\n   * \t\tbackup_fn_flags '{' inner_statement_list '}' backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_CLOSURE, $2 | $13, $1, $3,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0),\n   * \t\t\t\t  $5, $7, $11, $8); CG(extra_fn_flags) = $9; }\n   * \t|\tfn returns_ref '(' parameter_list ')' return_type backup_doc_comment T_DOUBLE_ARROW backup_fn_flags backup_lex_pos expr backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_ARROW_FUNC, $2 | $12, $1, $7,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0), $4, NULL,\n   * \t\t\t\t  zend_ast_create(ZEND_AST_RETURN, $11), $6);\n   * \t\t\t\t  ((zend_ast_decl *) $$)->lex_pos = $10;\n   * \t\t\t\t  CG(extra_fn_flags) = $9; }   *\n   */\n  read_inline_function: function read_inline_function(flags) {\n    if (this.token === this.tok.T_FUNCTION) {\n      return this.read_function(true, flags);\n    } // introduced in PHP 7.4\n\n\n    if (!this.version >= 704) {\n      this.raiseError(\"Arrow Functions are not allowed\");\n    } // as an arrowfunc\n\n\n    var node = this.node(\"arrowfunc\"); // eat T_FN\n\n    if (this.expect(this.tok.T_FN)) this.next(); // check the &\n\n    var isRef = this.is_reference(); // ...\n\n    if (this.expect(\"(\")) this.next();\n    var params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n    var nullable = false;\n    var returnType = null;\n\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n\n      returnType = this.read_type();\n    }\n\n    if (this.expect(this.tok.T_DOUBLE_ARROW)) this.next();\n    var body = this.read_expr();\n    return node(params, isRef, body, returnType, nullable, flags ? true : false);\n  },\n\n  /**\n   * ```ebnf\n   *    new_expr ::= T_NEW (namespace_name function_argument_list) | (T_CLASS ... class declaration)\n   * ```\n   * https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L850\n   */\n  read_new_expr: function read_new_expr() {\n    var result = this.node(\"new\");\n    this.expect(this.tok.T_NEW) && this.next();\n    var args = [];\n\n    if (this.token === this.tok.T_CLASS) {\n      var what = this.node(\"class\"); // Annonymous class declaration\n\n      if (this.next().token === \"(\") {\n        args = this.read_argument_list();\n      }\n\n      var propExtends = this.read_extends_from();\n      var propImplements = this.read_implements_list();\n      var body = null;\n\n      if (this.expect(\"{\")) {\n        body = this.next().read_class_body();\n      }\n\n      return result(what(null, propExtends, propImplements, body, [0, 0, 0]), args);\n    } // Already existing class\n\n\n    var name = this.read_new_class_name();\n\n    if (this.token === \"(\") {\n      args = this.read_argument_list();\n    }\n\n    return result(name, args);\n  },\n\n  /**\n   * Reads a class name\n   * ```ebnf\n   * read_new_class_name ::= namespace_name | variable\n   * ```\n   */\n  read_new_class_name: function read_new_class_name() {\n    if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {\n      var result = this.read_namespace_name(true);\n\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        result = this.read_static_getter(result);\n      }\n\n      return result;\n    } else if (this.is(\"VARIABLE\")) {\n      return this.read_variable(true, false);\n    } else {\n      this.expect([this.tok.T_STRING, \"VARIABLE\"]);\n    }\n  },\n  handleDereferencable: function handleDereferencable(expr) {\n    while (this.token !== this.EOF) {\n      if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON) {\n        expr = this.recursive_variable_chain_scan(expr, false, false, true);\n      } else if (this.token === this.tok.T_CURLY_OPEN || this.token === \"[\") {\n        expr = this.read_dereferencable(expr);\n      } else if (this.token === \"(\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1118\n        expr = this.node(\"call\")(expr, this.read_argument_list());\n      } else {\n        return expr;\n      }\n    }\n\n    return expr;\n  }\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * checks if current token is a reference keyword\n   */\n  is_reference: function is_reference() {\n    if (this.token == \"&\") {\n      this.next();\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * checks if current token is a variadic keyword\n   */\n  is_variadic: function is_variadic() {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * reading a function\n   * ```ebnf\n   * function ::= function_declaration code_block\n   * ```\n   */\n  read_function: function read_function(closure, flag) {\n    var result = this.read_function_declaration(closure ? 1 : flag ? 2 : 0, flag && flag[1] === 1);\n\n    if (flag && flag[2] == 1) {\n      // abstract function :\n      result.parseFlags(flag);\n\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\"{\")) {\n        result.body = this.read_code_block(false);\n\n        if (result.loc && result.body.loc) {\n          result.loc.end = result.body.loc.end;\n        }\n      }\n\n      if (!closure && flag) {\n        result.parseFlags(flag);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * reads a function declaration (without his body)\n   * ```ebnf\n   * function_declaration ::= T_FUNCTION '&'?  T_STRING '(' parameter_list ')'\n   * ```\n   */\n  read_function_declaration: function read_function_declaration(type, isStatic) {\n    var nodeName = \"function\";\n\n    if (type === 1) {\n      nodeName = \"closure\";\n    } else if (type === 2) {\n      nodeName = \"method\";\n    }\n\n    var result = this.node(nodeName);\n\n    if (this.expect(this.tok.T_FUNCTION)) {\n      this.next();\n    }\n\n    var isRef = this.is_reference();\n    var name = false,\n        use = [],\n        returnType = null,\n        nullable = false;\n\n    if (type !== 1) {\n      var nameNode = this.node(\"identifier\");\n\n      if (type === 2) {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING || this.is(\"IDENTIFIER\")) {\n            name = this.text();\n            this.next();\n          } else if (this.version < 704) {\n            this.error(\"IDENTIFIER\");\n          }\n        } else if (this.token === this.tok.T_STRING) {\n          name = this.text();\n          this.next();\n        } else {\n          this.error(\"IDENTIFIER\");\n        }\n      } else {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING) {\n            name = this.text();\n            this.next();\n          } else if (this.version >= 704) {\n            if (!this.expect(\"(\")) {\n              this.next();\n            }\n          } else {\n            this.error(this.tok.T_STRING);\n            this.next();\n          }\n        } else {\n          if (this.expect(this.tok.T_STRING)) {\n            name = this.text();\n          }\n\n          this.next();\n        }\n      }\n\n      name = nameNode(name);\n    }\n\n    if (this.expect(\"(\")) this.next();\n    var params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n\n    if (type === 1) {\n      use = this.read_lexical_vars();\n    }\n\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n\n      returnType = this.read_type();\n    }\n\n    if (type === 1) {\n      // closure\n      return result(params, isRef, use, returnType, nullable, isStatic);\n    }\n\n    return result(name, params, isRef, returnType, nullable);\n  },\n  read_lexical_vars: function read_lexical_vars() {\n    var result = [];\n\n    if (this.token === this.tok.T_USE) {\n      this.next();\n      this.expect(\"(\") && this.next();\n      result = this.read_lexical_var_list();\n      this.expect(\")\") && this.next();\n    }\n\n    return result;\n  },\n  read_lexical_var_list: function read_lexical_var_list() {\n    return this.read_list(this.read_lexical_var, \",\");\n  },\n\n  /**\n   * ```ebnf\n   * lexical_var ::= '&'? T_VARIABLE\n   * ```\n   */\n  read_lexical_var: function read_lexical_var() {\n    if (this.token === \"&\") {\n      return this.read_byref(this.read_lexical_var.bind(this));\n    }\n\n    var result = this.node(\"variable\");\n    this.expect(this.tok.T_VARIABLE);\n    var name = this.text().substring(1);\n    this.next();\n    return result(name, false);\n  },\n\n  /**\n   * reads a list of parameters\n   * ```ebnf\n   *  parameter_list ::= (parameter ',')* parameter?\n   * ```\n   */\n  read_parameter_list: function read_parameter_list() {\n    var result = [];\n\n    if (this.token != \")\") {\n      while (this.token != this.EOF) {\n        result.push(this.read_parameter());\n\n        if (this.token == \",\") {\n          this.next();\n        } else if (this.token == \")\") {\n          break;\n        } else {\n          this.error([\",\", \")\"]);\n          break;\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  parameter ::= type? '&'? T_ELLIPSIS? T_VARIABLE ('=' expr)?\n   * ```\n   * @see https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L640\n   */\n  read_parameter: function read_parameter() {\n    var node = this.node(\"parameter\");\n    var parameterName = null;\n    var value = null;\n    var type = null;\n    var nullable = false;\n\n    if (this.token === \"?\") {\n      this.next();\n      nullable = true;\n    }\n\n    type = this.read_type();\n\n    if (nullable && !type) {\n      this.raiseError(\"Expecting a type definition combined with nullable operator\");\n    }\n\n    var isRef = this.is_reference();\n    var isVariadic = this.is_variadic();\n\n    if (this.expect(this.tok.T_VARIABLE)) {\n      parameterName = this.node(\"identifier\");\n      var name = this.text().substring(1);\n      this.next();\n      parameterName = parameterName(name);\n    }\n\n    if (this.token == \"=\") {\n      value = this.next().read_expr();\n    }\n\n    return node(parameterName, type, value, isRef, isVariadic, nullable);\n  },\n\n  /**\n   * Reads a list of arguments\n   * ```ebnf\n   *  function_argument_list ::= '(' (argument_list (',' argument_list)*)? ')'\n   * ```\n   */\n  read_argument_list: function read_argument_list() {\n    var result = [];\n    this.expect(\"(\") && this.next();\n\n    if (this.token !== \")\") {\n      result = this.read_non_empty_argument_list();\n    }\n\n    this.expect(\")\") && this.next();\n    return result;\n  },\n\n  /**\n   * Reads non empty argument list\n   */\n  read_non_empty_argument_list: function read_non_empty_argument_list() {\n    var wasVariadic = false;\n    return this.read_function_list(function () {\n      var argument = this.read_argument();\n\n      if (argument) {\n        if (wasVariadic) {\n          this.raiseError(\"Unexpected argument after a variadic argument\");\n        }\n\n        if (argument.kind === \"variadic\") {\n          wasVariadic = true;\n        }\n      }\n\n      return argument;\n    }.bind(this), \",\");\n  },\n\n  /**\n   * ```ebnf\n   *    argument_list ::= T_ELLIPSIS? expr\n   * ```\n   */\n  read_argument: function read_argument() {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      return this.node(\"variadic\")(this.next().read_expr());\n    }\n\n    return this.read_expr();\n  },\n\n  /**\n   * read type hinting\n   * ```ebnf\n   *  type ::= T_ARRAY | T_CALLABLE | namespace_name\n   * ```\n   */\n  read_type: function read_type() {\n    var result = this.node();\n\n    if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {\n      var type = this.text();\n      this.next();\n      return result(\"typereference\", type.toLowerCase(), type);\n    } else if (this.token === this.tok.T_STRING) {\n      var _type = this.text();\n\n      var backup = [this.token, this.lexer.getState()];\n      this.next();\n\n      if (this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(_type.toLowerCase()) > -1) {\n        return result(\"typereference\", _type.toLowerCase(), _type);\n      } else {\n        // rollback a classic namespace\n        this.lexer.tokens.push(backup);\n        this.next(); // fix : destroy not consumed node (release comments)\n\n        result.destroy();\n        return this.read_namespace_name();\n      }\n    } else if (this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NS_SEPARATOR) {\n      // fix : destroy not consumed node (release comments)\n      result.destroy();\n      return this.read_namespace_name();\n    } // fix : destroy not consumed node (release comments)\n\n\n    result.destroy();\n    return null;\n  }\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads an IF statement\n   *\n   * ```ebnf\n   *  if ::= T_IF '(' expr ')' ':' ...\n   * ```\n   */\n  read_if: function read_if() {\n    var result = this.node(\"if\");\n    var test = this.next().read_if_expr();\n    var body = null;\n    var alternate = null;\n    var shortForm = false;\n\n    if (this.token === \":\") {\n      shortForm = true;\n      this.next();\n      body = this.node(\"block\");\n      var items = [];\n\n      while (this.token !== this.EOF && this.token !== this.tok.T_ENDIF) {\n        if (this.token === this.tok.T_ELSEIF) {\n          alternate = this.read_elseif_short();\n          break;\n        } else if (this.token === this.tok.T_ELSE) {\n          alternate = this.read_else_short();\n          break;\n        }\n\n        items.push(this.read_inner_statement());\n      }\n\n      body = body(null, items);\n      this.expect(this.tok.T_ENDIF) && this.next();\n      this.expectEndOfStatement();\n    } else {\n      body = this.read_statement();\n\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_if();\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.next().read_statement();\n      }\n    }\n\n    return result(test, body, alternate, shortForm);\n  },\n\n  /**\n   * reads an if expression : '(' expr ')'\n   */\n  read_if_expr: function read_if_expr() {\n    this.expect(\"(\") && this.next();\n    var result = this.read_expr();\n    this.expect(\")\") && this.next();\n    return result;\n  },\n\n  /**\n   * reads an elseif (expr): statements\n   */\n  read_elseif_short: function read_elseif_short() {\n    var alternate = null;\n    var result = this.node(\"if\");\n    var test = this.next().read_if_expr();\n    if (this.expect(\":\")) this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_elseif_short();\n        break;\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.read_else_short();\n        break;\n      }\n\n      items.push(this.read_inner_statement());\n    }\n\n    return result(test, body(null, items), alternate, true);\n  },\n\n  /**\n   *\n   */\n  read_else_short: function read_else_short() {\n    if (this.next().expect(\":\")) this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      items.push(this.read_inner_statement());\n    }\n\n    return body(null, items);\n  }\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a while statement\n   * ```ebnf\n   * while ::= T_WHILE (statement | ':' inner_statement_list T_ENDWHILE ';')\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L587\n   * @return {While}\n   */\n  read_while: function read_while() {\n    var result = this.node(\"while\");\n    this.expect(this.tok.T_WHILE) && this.next();\n    var test = null;\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    test = this.read_expr();\n    if (this.expect(\")\")) this.next();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDWHILE);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(test, body, shortForm);\n  },\n\n  /**\n   * Reads a do / while loop\n   * ```ebnf\n   * do ::= T_DO statement T_WHILE '(' expr ')' ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L423\n   * @return {Do}\n   */\n  read_do: function read_do() {\n    var result = this.node(\"do\");\n    this.expect(this.tok.T_DO) && this.next();\n    var test = null;\n    var body = null;\n    body = this.read_statement();\n\n    if (this.expect(this.tok.T_WHILE)) {\n      if (this.next().expect(\"(\")) this.next();\n      test = this.read_expr();\n      if (this.expect(\")\")) this.next();\n      if (this.expect(\";\")) this.next();\n    }\n\n    return result(test, body);\n  },\n\n  /**\n   * Read a for incremental loop\n   * ```ebnf\n   * for ::= T_FOR '(' for_exprs ';' for_exprs ';' for_exprs ')' for_statement\n   * for_statement ::= statement | ':' inner_statement_list T_ENDFOR ';'\n   * for_exprs ::= expr? (',' expr)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L425\n   * @return {For}\n   */\n  read_for: function read_for() {\n    var result = this.node(\"for\");\n    this.expect(this.tok.T_FOR) && this.next();\n    var init = [];\n    var test = [];\n    var increment = [];\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n\n    if (this.token !== \";\") {\n      init = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token !== \";\") {\n      test = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token !== \")\") {\n      increment = this.read_list(this.read_expr, \",\");\n      if (this.expect(\")\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOR);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(init, test, increment, body, shortForm);\n  },\n\n  /**\n   * Reads a foreach loop\n   * ```ebnf\n   * foreach ::= '(' expr T_AS foreach_variable (T_DOUBLE_ARROW foreach_variable)? ')' statement\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L438\n   * @return {Foreach}\n   */\n  read_foreach: function read_foreach() {\n    var result = this.node(\"foreach\");\n    this.expect(this.tok.T_FOREACH) && this.next();\n    var source = null;\n    var key = null;\n    var value = null;\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    source = this.read_expr();\n\n    if (this.expect(this.tok.T_AS)) {\n      this.next();\n      value = this.read_foreach_variable();\n\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        key = value;\n        value = this.next().read_foreach_variable();\n      }\n    } // grammatically correct but not supported by PHP\n\n\n    if (key && key.kind === \"list\") {\n      this.raiseError(\"Fatal Error : Cannot use list as key element\");\n    }\n\n    if (this.expect(\")\")) this.next();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOREACH);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(source, key, value, body, shortForm);\n  },\n\n  /**\n   * Reads a foreach variable statement\n   * ```ebnf\n   * foreach_variable =\n   *    variable |\n   *    '&' variable |\n   *    T_LIST '(' assignment_list ')' |\n   *    '[' assignment_list ']'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L544\n   * @return {Expression}\n   */\n  read_foreach_variable: function read_foreach_variable() {\n    if (this.token === this.tok.T_LIST || this.token === \"[\") {\n      var isShort = this.token === \"[\";\n      var result = this.node(\"list\");\n      this.next();\n      if (!isShort && this.expect(\"(\")) this.next();\n      var assignList = this.read_array_pair_list(isShort);\n      if (this.expect(isShort ? \"]\" : \")\")) this.next();\n      return result(assignList, isShort);\n    } else {\n      return this.read_variable(false, false);\n    }\n  }\n};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   * start ::= (namespace | top_statement)*\n   * ```\n   */\n  read_start: function read_start() {\n    if (this.token == this.tok.T_NAMESPACE) {\n      return this.read_namespace();\n    } else {\n      return this.read_top_statement();\n    }\n  }\n};\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a namespace declaration block\n   * ```ebnf\n   * namespace ::= T_NAMESPACE namespace_name? '{'\n   *    top_statements\n   * '}'\n   * | T_NAMESPACE namespace_name ';' top_statements\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.php\n   * @return {Namespace}\n   */\n  read_namespace: function read_namespace() {\n    var result = this.node(\"namespace\");\n    var body;\n    this.expect(this.tok.T_NAMESPACE) && this.next();\n    var name;\n\n    if (this.token == \"{\") {\n      name = {\n        name: [\"\"]\n      };\n    } else {\n      name = this.read_namespace_name();\n    }\n\n    this.currentNamespace = name;\n\n    if (this.token == \";\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(this.EOF);\n      return result(name.name, body, false);\n    } else if (this.token == \"{\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(\"}\") && this.next();\n\n      if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n        body.push(this.node(\"noop\")());\n      }\n\n      return result(name.name, body, true);\n    } else if (this.token === \"(\") {\n      // @fixme after merging #478\n      name.resolution = this.ast.reference.RELATIVE_NAME;\n      name.name = name.name.substring(1);\n      result.destroy();\n      return this.node(\"call\")(name, this.read_argument_list());\n    } else {\n      this.error([\"{\", \";\"]); // graceful mode :\n\n      this.currentNamespace = name;\n      body = this.read_top_statements();\n      this.expect(this.EOF);\n      return result(name, body, false);\n    }\n  },\n\n  /**\n   * Reads a namespace name\n   * ```ebnf\n   *  namespace_name ::= T_NS_SEPARATOR? (T_STRING T_NS_SEPARATOR)* T_STRING\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.rules.php\n   * @return {Reference}\n   */\n  read_namespace_name: function read_namespace_name(resolveReference) {\n    var result = this.node();\n    var relative = false;\n\n    if (this.token === this.tok.T_NAMESPACE) {\n      this.next().expect(this.tok.T_NS_SEPARATOR) && this.next();\n      relative = true;\n    }\n\n    var names = this.read_list(this.tok.T_STRING, this.tok.T_NS_SEPARATOR, true);\n\n    if (!relative && names.length === 1 && (resolveReference || this.token !== \"(\")) {\n      if (names[0].toLowerCase() === \"parent\") {\n        return result(\"parentreference\", names[0]);\n      } else if (names[0].toLowerCase() === \"self\") {\n        return result(\"selfreference\", names[0]);\n      }\n    }\n\n    return result(\"name\", names, relative);\n  },\n\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_statement ::= T_USE\n   *   use_type? use_declarations |\n   *   use_type use_statement '{' use_declarations '}' |\n   *   use_statement '{' use_declarations(=>typed) '}'\n   * ';'\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.importing.php\n   * @return {UseGroup}\n   */\n  read_use_statement: function read_use_statement() {\n    var result = this.node(\"usegroup\");\n    var items = [];\n    var name = null;\n    this.expect(this.tok.T_USE) && this.next();\n    var type = this.read_use_type();\n    items.push(this.read_use_declaration(false));\n\n    if (this.token === \",\") {\n      items = items.concat(this.next().read_use_declarations(false));\n    } else if (this.token === \"{\") {\n      name = items[0].name;\n      items = this.next().read_use_declarations(type === null);\n      this.expect(\"}\") && this.next();\n    }\n\n    result = result(name, type, items);\n    this.expect(\";\") && this.next();\n    return result;\n  },\n\n  /**\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1045\n   */\n  read_class_name_reference: function read_class_name_reference() {\n    // resolved as the same\n    return this.read_variable(true, false);\n  },\n\n  /**\n   * Reads a use declaration\n   * ```ebnf\n   * use_declaration ::= use_type? namespace_name use_alias\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem}\n   */\n  read_use_declaration: function read_use_declaration(typed) {\n    var result = this.node(\"useitem\");\n    var type = null;\n    if (typed) type = this.read_use_type();\n    var name = this.read_namespace_name();\n    var alias = this.read_use_alias();\n    return result(name.name, alias, type);\n  },\n\n  /**\n   * Reads a list of use declarations\n   * ```ebnf\n   * use_declarations ::= use_declaration (',' use_declaration)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem[]}\n   */\n  read_use_declarations: function read_use_declarations(typed) {\n    var result = [this.read_use_declaration(typed)];\n\n    while (this.token === \",\") {\n      this.next();\n\n      if (typed) {\n        if (this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING) {\n          break;\n        }\n      } else if (this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR) {\n        break;\n      }\n\n      result.push(this.read_use_declaration(typed));\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_alias ::= (T_AS T_STRING)?\n   * ```\n   * @return {String|null}\n   */\n  read_use_alias: function read_use_alias() {\n    var result = null;\n\n    if (this.token === this.tok.T_AS) {\n      if (this.next().expect(this.tok.T_STRING)) {\n        var aliasName = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        result = aliasName(name);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads the namespace type declaration\n   * ```ebnf\n   * use_type ::= (T_FUNCTION | T_CONST)?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L335\n   * @return {String|null} Possible values : function, const\n   */\n  read_use_type: function read_use_type() {\n    if (this.token === this.tok.T_FUNCTION) {\n      this.next();\n      return this.ast.useitem.TYPE_FUNCTION;\n    } else if (this.token === this.tok.T_CONST) {\n      this.next();\n      return this.ast.useitem.TYPE_CONST;\n    }\n\n    return null;\n  }\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar specialChar = {\n  \"\\\\\": \"\\\\\",\n  $: \"$\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\\t\",\n  f: String.fromCharCode(12),\n  v: String.fromCharCode(11),\n  e: String.fromCharCode(27)\n};\nmodule.exports = {\n  /**\n   * Unescape special chars\n   */\n  resolve_special_chars: function resolve_special_chars(text, doubleQuote) {\n    if (!doubleQuote) {\n      // single quote fix\n      return text.replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\'/g, \"'\");\n    }\n\n    return text.replace(/\\\\\"/, '\"').replace(/\\\\([\\\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function ($match, p1, p2) {\n      if (specialChar[p1]) {\n        return specialChar[p1];\n      } else if (\"x\" === p1[0] || \"X\" === p1[0]) {\n        return String.fromCodePoint(parseInt(p1.substr(1), 16));\n      } else if (\"u\" === p1[0]) {\n        return String.fromCodePoint(parseInt(p2, 16));\n      } else {\n        return String.fromCodePoint(parseInt(p1, 8));\n      }\n    });\n  },\n\n  /**\n   * Remove all leading spaces each line for heredoc text if there is a indentation\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  remove_heredoc_leading_whitespace_chars: function remove_heredoc_leading_whitespace_chars(text, indentation, indentation_uses_spaces, first_encaps_node) {\n    if (indentation === 0) {\n      return text;\n    }\n\n    this.check_heredoc_indentation_level(text, indentation, indentation_uses_spaces, first_encaps_node);\n    var matchedChar = indentation_uses_spaces ? \" \" : \"\\t\";\n    var removementRegExp = new RegExp(\"\\\\n\".concat(matchedChar, \"{\").concat(indentation, \"}\"), \"g\");\n    var removementFirstEncapsNodeRegExp = new RegExp(\"^\".concat(matchedChar, \"{\").concat(indentation, \"}\")); // Rough replace, need more check\n\n    if (first_encaps_node) {\n      // Remove text leading whitespace\n      text = text.replace(removementFirstEncapsNodeRegExp, \"\");\n    } // Remove leading whitespace after \\n\n\n\n    return text.replace(removementRegExp, \"\\n\");\n  },\n\n  /**\n   * Check indentation level of heredoc in text, if mismatch, raiseError\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  check_heredoc_indentation_level: function check_heredoc_indentation_level(text, indentation, indentation_uses_spaces, first_encaps_node) {\n    var textSize = text.length;\n    var offset = 0;\n    var leadingWhitespaceCharCount = 0;\n    /**\n     * @var inCoutingState {boolean} reset to true after a new line\n     */\n\n    var inCoutingState = true;\n    var chToCheck = indentation_uses_spaces ? \" \" : \"\\t\";\n    var inCheckState = false;\n\n    if (!first_encaps_node) {\n      // start from first \\n\n      offset = text.indexOf(\"\\n\"); // if no \\n, just return\n\n      if (offset === -1) {\n        return;\n      }\n\n      offset++;\n    }\n\n    while (offset < textSize) {\n      if (inCoutingState) {\n        if (text[offset] === chToCheck) {\n          leadingWhitespaceCharCount++;\n        } else {\n          inCheckState = true;\n        }\n      } else {\n        inCoutingState = false;\n      }\n\n      if (text[offset] !== \"\\n\" && inCheckState && leadingWhitespaceCharCount < indentation) {\n        this.raiseError(\"Invalid body indentation level (expecting an indentation at least \".concat(indentation, \")\"));\n      } else {\n        inCheckState = false;\n      }\n\n      if (text[offset] === \"\\n\") {\n        // Reset counting state\n        inCoutingState = true;\n        leadingWhitespaceCharCount = 0;\n      }\n\n      offset++;\n    }\n  },\n\n  /**\n   * Reads dereferencable scalar\n   */\n  read_dereferencable_scalar: function read_dereferencable_scalar() {\n    var result = null;\n\n    switch (this.token) {\n      case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        {\n          var value = this.node(\"string\");\n          var text = this.text();\n          var offset = 0;\n\n          if (text[0] === \"b\" || text[0] === \"B\") {\n            offset = 1;\n          }\n\n          var isDoubleQuote = text[offset] === '\"';\n          this.next();\n          var textValue = this.resolve_special_chars(text.substring(offset + 1, text.length - 1), isDoubleQuote);\n          value = value(isDoubleQuote, textValue, offset === 1, // unicode flag\n          text);\n\n          if (this.token === this.tok.T_DOUBLE_COLON) {\n            // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1151\n            result = this.read_static_getter(value);\n          } else {\n            // dirrect string\n            result = value;\n          }\n        }\n        break;\n\n      case this.tok.T_ARRAY:\n        // array parser\n        result = this.read_array();\n        break;\n\n      case \"[\":\n        // short array format\n        result = this.read_array();\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  scalar ::= T_MAGIC_CONST\n   *       | T_LNUMBER | T_DNUMBER\n   *       | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE? T_END_HEREDOC\n   *       | '\"' encaps_list '\"'\n   *       | T_START_HEREDOC encaps_list T_END_HEREDOC\n   *       | namespace_name (T_DOUBLE_COLON T_STRING)?\n   * ```\n   */\n  read_scalar: function read_scalar() {\n    if (this.is(\"T_MAGIC_CONST\")) {\n      return this.get_magic_constant();\n    } else {\n      var value, node;\n\n      switch (this.token) {\n        // NUMERIC\n        case this.tok.T_LNUMBER: // long\n\n        case this.tok.T_DNUMBER:\n          {\n            // double\n            var result = this.node(\"number\");\n            value = this.text();\n            this.next();\n            return result(value, null);\n          }\n\n        case this.tok.T_START_HEREDOC:\n          if (this.lexer.curCondition === \"ST_NOWDOC\") {\n            var start = this.lexer.yylloc.first_offset;\n            node = this.node(\"nowdoc\");\n            value = this.next().text(); // strip the last line return char\n\n            if (this.lexer.heredoc_label.indentation > 0) {\n              value = value.substring(0, value.length - this.lexer.heredoc_label.indentation);\n            }\n\n            var lastCh = value[value.length - 1];\n\n            if (lastCh === \"\\n\") {\n              if (value[value.length - 2] === \"\\r\") {\n                // windows style\n                value = value.substring(0, value.length - 2);\n              } else {\n                // linux style\n                value = value.substring(0, value.length - 1);\n              }\n            } else if (lastCh === \"\\r\") {\n              // mac style\n              value = value.substring(0, value.length - 1);\n            }\n\n            this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next();\n            this.expect(this.tok.T_END_HEREDOC) && this.next();\n\n            var raw = this.lexer._input.substring(start, this.lexer.yylloc.first_offset);\n\n            node = node(this.remove_heredoc_leading_whitespace_chars(value, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), raw, this.lexer.heredoc_label.label);\n            return node;\n          } else {\n            return this.read_encapsed_string(this.tok.T_END_HEREDOC);\n          }\n\n        case '\"':\n          return this.read_encapsed_string('\"');\n\n        case 'b\"':\n        case 'B\"':\n          {\n            return this.read_encapsed_string('\"', true);\n          }\n        // TEXTS\n\n        case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        case this.tok.T_ARRAY: // array parser\n\n        case \"[\":\n          // short array format\n          return this.read_dereferencable_scalar();\n\n        default:\n          {\n            var err = this.error(\"SCALAR\"); // graceful mode : ignore token & return error node\n\n            this.next();\n            return err;\n          }\n      }\n    }\n  },\n\n  /**\n   * Handles the dereferencing\n   */\n  read_dereferencable: function read_dereferencable(expr) {\n    var result, offset;\n    var node = this.node(\"offsetlookup\");\n\n    if (this.token === \"[\") {\n      offset = this.next().read_expr();\n      if (this.expect(\"]\")) this.next();\n      result = node(expr, offset);\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      offset = this.read_encapsed_string_item(false);\n      result = node(expr, offset);\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads and extracts an encapsed item\n   * ```ebnf\n   * encapsed_string_item ::= T_ENCAPSED_AND_WHITESPACE\n   *  | T_DOLLAR_OPEN_CURLY_BRACES expr '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}'\n   *  | T_CURLY_OPEN variable '}'\n   *  | variable\n   *  | variable '[' expr ']'\n   *  | variable T_OBJECT_OPERATOR T_STRING\n   * ```\n   * @return {String|Variable|Expr|Lookup}\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1219\n   */\n  read_encapsed_string_item: function read_encapsed_string_item(isDoubleQuote) {\n    var encapsedPart = this.node(\"encapsedpart\");\n    var syntax = null;\n    var curly = false;\n    var result = this.node(),\n        offset,\n        node,\n        name; // plain text\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1222\n\n    if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {\n      var text = this.text();\n      this.next(); // if this.lexer.heredoc_label.first_encaps_node -> remove first indents\n\n      result = result(\"string\", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(text, isDoubleQuote), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : text, false, text);\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      syntax = \"simple\";\n      curly = true; // dynamic variable name\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1239\n\n      name = null;\n\n      if (this.next().token === this.tok.T_STRING_VARNAME) {\n        name = this.node(\"variable\");\n        var varName = this.text();\n        this.next(); // check if lookup an offset\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1243\n\n        if (this.token === \"[\") {\n          name = name(varName, false);\n          node = this.node(\"offsetlookup\");\n          offset = this.next().read_expr();\n          this.expect(\"]\") && this.next();\n          result = node(name, offset);\n        } else {\n          result = name(varName, false);\n        }\n      } else {\n        result = result(\"variable\", this.read_expr(), false);\n      }\n\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_CURLY_OPEN) {\n      // expression\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1246\n      syntax = \"complex\";\n      result.destroy();\n      result = this.next().read_variable(false, false);\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_VARIABLE) {\n      syntax = \"simple\"; // plain variable\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1231\n\n      result.destroy();\n      result = this.read_simple_variable(); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1233\n\n      if (this.token === \"[\") {\n        node = this.node(\"offsetlookup\");\n        offset = this.next().read_encaps_var_offset();\n        this.expect(\"]\") && this.next();\n        result = node(result, offset);\n      } // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1236\n\n\n      if (this.token === this.tok.T_OBJECT_OPERATOR) {\n        node = this.node(\"propertylookup\");\n        this.next().expect(this.tok.T_STRING);\n        var what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        result = node(result, what(name));\n      } // error / fallback\n\n    } else {\n      this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);\n      var value = this.text();\n      this.next(); // consider it as string\n\n      result.destroy();\n      result = result(\"string\", false, value, false, value);\n    } // reset first_encaps_node to false after access any node\n\n\n    this.lexer.heredoc_label.first_encaps_node = false;\n    return encapsedPart(result, syntax, curly);\n  },\n\n  /**\n   * Reads an encapsed string\n   */\n  read_encapsed_string: function read_encapsed_string(expect) {\n    var isBinary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var labelStart = this.lexer.yylloc.first_offset;\n    var node = this.node(\"encapsed\");\n    this.next();\n    var start = this.lexer.yylloc.prev_offset - (isBinary ? 1 : 0);\n    var value = [];\n    var type = null;\n\n    if (expect === \"`\") {\n      type = this.ast.encapsed.TYPE_SHELL;\n    } else if (expect === '\"') {\n      type = this.ast.encapsed.TYPE_STRING;\n    } else {\n      type = this.ast.encapsed.TYPE_HEREDOC;\n    } // reading encapsed parts\n\n\n    while (this.token !== expect && this.token !== this.EOF) {\n      value.push(this.read_encapsed_string_item(true));\n    }\n\n    if (value.length > 0 && value[value.length - 1].kind === \"encapsedpart\" && value[value.length - 1].expression.kind === \"string\") {\n      var _node = value[value.length - 1].expression;\n      var lastCh = _node.value[_node.value.length - 1];\n\n      if (lastCh === \"\\n\") {\n        if (_node.value[_node.value.length - 2] === \"\\r\") {\n          // windows style\n          _node.value = _node.value.substring(0, _node.value.length - 2);\n        } else {\n          // linux style\n          _node.value = _node.value.substring(0, _node.value.length - 1);\n        }\n      } else if (lastCh === \"\\r\") {\n        // mac style\n        _node.value = _node.value.substring(0, _node.value.length - 1);\n      }\n    }\n\n    this.expect(expect) && this.next();\n\n    var raw = this.lexer._input.substring(type === \"heredoc\" ? labelStart : start - 1, this.lexer.yylloc.first_offset);\n\n    node = node(value, raw, type);\n\n    if (expect === this.tok.T_END_HEREDOC) {\n      node.label = this.lexer.heredoc_label.label;\n      this.lexer.heredoc_label.finished = true;\n    }\n\n    return node;\n  },\n\n  /**\n   * Constant token\n   */\n  get_magic_constant: function get_magic_constant() {\n    var result = this.node(\"magic\");\n    var name = this.text();\n    this.next();\n    return result(name.toUpperCase(), name);\n  }\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * reading a list of top statements (helper for top_statement*)\n   * ```ebnf\n   *  top_statements ::= top_statement*\n   * ```\n   */\n  read_top_statements: function read_top_statements() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      var statement = this.read_top_statement();\n\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * reading a top statement\n   * ```ebnf\n   *  top_statement ::=\n   *       namespace | function | class\n   *       | interface | trait\n   *       | use_statements | const_list\n   *       | statement\n   * ```\n   */\n  read_top_statement: function read_top_statement() {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n\n      case this.tok.T_USE:\n        return this.read_use_statement();\n\n      case this.tok.T_CONST:\n        {\n          var result = this.node(\"constantstatement\");\n          var items = this.next().read_const_list();\n          this.expectEndOfStatement();\n          return result(null, items);\n        }\n\n      case this.tok.T_NAMESPACE:\n        return this.read_namespace();\n\n      case this.tok.T_HALT_COMPILER:\n        {\n          var _result = this.node(\"halt\");\n\n          if (this.next().expect(\"(\")) this.next();\n          if (this.expect(\")\")) this.next();\n          this.expect(\";\");\n          this.lexer.done = true;\n          return _result(this.lexer._input.substring(this.lexer.offset));\n        }\n\n      default:\n        return this.read_statement();\n    }\n  },\n\n  /**\n   * reads a list of simple inner statements (helper for inner_statement*)\n   * ```ebnf\n   *  inner_statements ::= inner_statement*\n   * ```\n   */\n  read_inner_statements: function read_inner_statements() {\n    var result = [];\n\n    while (this.token != this.EOF && this.token !== \"}\") {\n      var statement = this.read_inner_statement();\n\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)* ';'\n   * ```\n   */\n  read_const_list: function read_const_list() {\n    return this.read_list(function () {\n      this.expect(this.tok.T_STRING);\n      var result = this.node(\"constant\");\n      var constName = this.node(\"identifier\");\n      var name = this.text();\n      this.next();\n      constName = constName(name);\n\n      if (this.expect(\"=\")) {\n        return result(constName, this.next().read_expr());\n      } else {\n        // fallback\n        return result(constName, null);\n      }\n    }, \",\", false);\n  },\n\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   declare_list ::= IDENTIFIER '=' expr (',' IDENTIFIER '=' expr)*\n   * ```\n   * @retrurn {Array}\n   */\n  read_declare_list: function read_declare_list() {\n    var result = [];\n\n    while (this.token != this.EOF && this.token !== \")\") {\n      this.expect(this.tok.T_STRING);\n      var directive = this.node(\"declaredirective\");\n      var key = this.node(\"identifier\");\n      var name = this.text();\n      this.next();\n      key = key(name);\n      var value = null;\n\n      if (this.expect(\"=\")) {\n        value = this.next().read_expr();\n      }\n\n      result.push(directive(key, value));\n      if (this.token !== \",\") break;\n      this.next();\n    }\n\n    return result;\n  },\n\n  /**\n   * reads a simple inner statement\n   * ```ebnf\n   *  inner_statement ::= '{' inner_statements '}' | token\n   * ```\n   */\n  read_inner_statement: function read_inner_statement() {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n\n      case this.tok.T_HALT_COMPILER:\n        {\n          this.raiseError(\"__HALT_COMPILER() can only be used from the outermost scope\"); // fallback : returns a node but does not stop the parsing\n\n          var node = this.node(\"halt\");\n          this.next().expect(\"(\") && this.next();\n          this.expect(\")\") && this.next();\n          node = node(this.lexer._input.substring(this.lexer.offset));\n          this.expect(\";\") && this.next();\n          return node;\n        }\n\n      default:\n        return this.read_statement();\n    }\n  },\n\n  /**\n   * Reads statements\n   */\n  read_statement: function read_statement() {\n    switch (this.token) {\n      case \"{\":\n        return this.read_code_block(false);\n\n      case this.tok.T_IF:\n        return this.read_if();\n\n      case this.tok.T_SWITCH:\n        return this.read_switch();\n\n      case this.tok.T_FOR:\n        return this.read_for();\n\n      case this.tok.T_FOREACH:\n        return this.read_foreach();\n\n      case this.tok.T_WHILE:\n        return this.read_while();\n\n      case this.tok.T_DO:\n        return this.read_do();\n\n      case this.tok.T_COMMENT:\n        return this.read_comment();\n\n      case this.tok.T_DOC_COMMENT:\n        return this.read_doc_comment();\n\n      case this.tok.T_RETURN:\n        {\n          var result = this.node(\"return\");\n          this.next();\n          var expr = this.read_optional_expr(\";\");\n          this.expectEndOfStatement();\n          return result(expr);\n        }\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L429\n\n      case this.tok.T_BREAK:\n      case this.tok.T_CONTINUE:\n        {\n          var _result2 = this.node(this.token === this.tok.T_CONTINUE ? \"continue\" : \"break\");\n\n          this.next();\n          var level = this.read_optional_expr(\";\");\n          this.expectEndOfStatement();\n          return _result2(level);\n        }\n\n      case this.tok.T_GLOBAL:\n        {\n          var _result3 = this.node(\"global\");\n\n          var items = this.next().read_list(this.read_simple_variable, \",\");\n          this.expectEndOfStatement();\n          return _result3(items);\n        }\n\n      case this.tok.T_STATIC:\n        {\n          var current = [this.token, this.lexer.getState()];\n\n          var _result4 = this.node();\n\n          if (this.next().token === this.tok.T_DOUBLE_COLON) {\n            // static keyword for a class\n            this.lexer.tokens.push(current);\n\n            var _expr = this.next().read_expr();\n\n            this.expectEndOfStatement(_expr);\n            return _result4(\"expressionstatement\", _expr);\n          }\n\n          if (this.token === this.tok.T_FUNCTION) {\n            return this.read_function(true, [0, 1, 0]);\n          }\n\n          var _items = this.read_variable_declarations();\n\n          this.expectEndOfStatement();\n          return _result4(\"static\", _items);\n        }\n\n      case this.tok.T_ECHO:\n        {\n          var _result5 = this.node(\"echo\");\n\n          var text = this.text();\n          var shortForm = text === \"<?=\" || text === \"<%=\";\n          var expressions = this.next().read_function_list(this.read_expr, \",\");\n          this.expectEndOfStatement();\n          return _result5(expressions, shortForm);\n        }\n\n      case this.tok.T_INLINE_HTML:\n        {\n          var value = this.text();\n          var prevChar = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null;\n          var fixFirstLine = prevChar === \"\\r\" || prevChar === \"\\n\"; // revert back the first stripped line\n\n          if (fixFirstLine) {\n            if (prevChar === \"\\n\" && this.lexer.yylloc.first_offset > 1 && this.lexer._input[this.lexer.yylloc.first_offset - 2] === \"\\r\") {\n              prevChar = \"\\r\\n\";\n            }\n          }\n\n          var _result6 = this.node(\"inline\");\n\n          this.next();\n          return _result6(value, fixFirstLine ? prevChar + value : value);\n        }\n\n      case this.tok.T_UNSET:\n        {\n          var _result7 = this.node(\"unset\");\n\n          this.next().expect(\"(\") && this.next();\n          var variables = this.read_function_list(this.read_variable, \",\");\n          this.expect(\")\") && this.next();\n          this.expect(\";\") && this.next();\n          return _result7(variables);\n        }\n\n      case this.tok.T_DECLARE:\n        {\n          var _result8 = this.node(\"declare\");\n\n          var body = [];\n          var mode;\n          this.next().expect(\"(\") && this.next();\n          var directives = this.read_declare_list();\n          this.expect(\")\") && this.next();\n\n          if (this.token === \":\") {\n            this.next();\n\n            while (this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE) {\n              // @todo : check declare_statement from php / not valid\n              body.push(this.read_top_statement());\n            }\n\n            if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n              body.push(this.node(\"noop\")());\n            }\n\n            this.expect(this.tok.T_ENDDECLARE) && this.next();\n            this.expectEndOfStatement();\n            mode = this.ast.declare.MODE_SHORT;\n          } else if (this.token === \"{\") {\n            this.next();\n\n            while (this.token != this.EOF && this.token !== \"}\") {\n              // @todo : check declare_statement from php / not valid\n              body.push(this.read_top_statement());\n            }\n\n            if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n              body.push(this.node(\"noop\")());\n            }\n\n            this.expect(\"}\") && this.next();\n            mode = this.ast.declare.MODE_BLOCK;\n          } else {\n            this.expect(\";\") && this.next();\n            mode = this.ast.declare.MODE_NONE;\n          }\n\n          return _result8(directives, body, mode);\n        }\n\n      case this.tok.T_TRY:\n        return this.read_try();\n\n      case this.tok.T_THROW:\n        {\n          var _result9 = this.node(\"throw\");\n\n          var _expr2 = this.next().read_expr();\n\n          this.expectEndOfStatement();\n          return _result9(_expr2);\n        }\n      // ignore this (extra ponctuation)\n\n      case \";\":\n        {\n          this.next();\n          return null;\n        }\n\n      case this.tok.T_STRING:\n        {\n          var _result10 = this.node();\n\n          var _current = [this.token, this.lexer.getState()];\n          var labelNameText = this.text();\n          var labelName = this.node(\"identifier\"); // AST : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L457\n\n          if (this.next().token === \":\") {\n            labelName = labelName(labelNameText);\n            this.next();\n            return _result10(\"label\", labelName);\n          } else {\n            labelName.destroy();\n          } // default fallback expr / T_STRING '::' (etc...)\n\n\n          _result10.destroy();\n\n          this.lexer.tokens.push(_current);\n          var statement = this.node(\"expressionstatement\");\n\n          var _expr3 = this.next().read_expr();\n\n          this.expectEndOfStatement(_expr3);\n          return statement(_expr3);\n        }\n\n      case this.tok.T_GOTO:\n        {\n          var _result11 = this.node(\"goto\");\n\n          var _labelName = null;\n\n          if (this.next().expect(this.tok.T_STRING)) {\n            _labelName = this.node(\"identifier\");\n            var name = this.text();\n            this.next();\n            _labelName = _labelName(name);\n            this.expectEndOfStatement();\n          }\n\n          return _result11(_labelName);\n        }\n\n      default:\n        {\n          // default fallback expr\n          var _statement = this.node(\"expressionstatement\");\n\n          var _expr4 = this.read_expr();\n\n          this.expectEndOfStatement(_expr4);\n          return _statement(_expr4);\n        }\n    }\n  },\n\n  /**\n   * ```ebnf\n   *  code_block ::= '{' (inner_statements | top_statements) '}'\n   * ```\n   */\n  read_code_block: function read_code_block(top) {\n    var result = this.node(\"block\");\n    this.expect(\"{\") && this.next();\n    var body = top ? this.read_top_statements() : this.read_inner_statements();\n\n    if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      body.push(this.node(\"noop\")());\n    }\n\n    this.expect(\"}\") && this.next();\n    return result(null, body);\n  }\n};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a switch statement\n   * ```ebnf\n   *  switch ::= T_SWITCH '(' expr ')' switch_case_list\n   * ```\n   * @return {Switch}\n   * @see http://php.net/manual/en/control-structures.switch.php\n   */\n  read_switch: function read_switch() {\n    var result = this.node(\"switch\");\n    this.expect(this.tok.T_SWITCH) && this.next();\n    this.expect(\"(\") && this.next();\n    var test = this.read_expr();\n    this.expect(\")\") && this.next();\n    var shortForm = this.token === \":\";\n    var body = this.read_switch_case_list();\n    return result(test, body, shortForm);\n  },\n\n  /**\n   * ```ebnf\n   *  switch_case_list ::= '{' ';'? case_list* '}' | ':' ';'? case_list* T_ENDSWITCH ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L566\n   */\n  read_switch_case_list: function read_switch_case_list() {\n    // DETECT SWITCH MODE\n    var expect = null;\n    var result = this.node(\"block\");\n    var items = [];\n\n    if (this.token === \"{\") {\n      expect = \"}\";\n    } else if (this.token === \":\") {\n      expect = this.tok.T_ENDSWITCH;\n    } else {\n      this.expect([\"{\", \":\"]);\n    }\n\n    this.next(); // OPTIONNAL ';'\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L570\n\n    if (this.token === \";\") {\n      this.next();\n    } // EXTRACTING CASES\n\n\n    while (this.token !== this.EOF && this.token !== expect) {\n      items.push(this.read_case_list(expect));\n    }\n\n    if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      items.push(this.node(\"noop\")());\n    } // CHECK END TOKEN\n\n\n    this.expect(expect) && this.next();\n\n    if (expect === this.tok.T_ENDSWITCH) {\n      this.expectEndOfStatement();\n    }\n\n    return result(null, items);\n  },\n\n  /**\n   * ```ebnf\n   *   case_list ::= ((T_CASE expr) | T_DEFAULT) (':' | ';') inner_statement*\n   * ```\n   */\n  read_case_list: function read_case_list(stopToken) {\n    var result = this.node(\"case\");\n    var test = null;\n\n    if (this.token === this.tok.T_CASE) {\n      test = this.next().read_expr();\n    } else if (this.token === this.tok.T_DEFAULT) {\n      // the default entry - no condition\n      this.next();\n    } else {\n      this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]);\n    } // case_separator\n\n\n    this.expect([\":\", \";\"]) && this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token !== this.EOF && this.token !== stopToken && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT) {\n      items.push(this.read_inner_statement());\n    }\n\n    return result(test, body(null, items));\n  }\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   *  try ::= T_TRY '{' inner_statement* '}'\n   *          (\n   *              T_CATCH '(' namespace_name variable ')' '{'  inner_statement* '}'\n   *          )*\n   *          (T_FINALLY '{' inner_statement* '}')?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L448\n   * @return {Try}\n   */\n  read_try: function read_try() {\n    this.expect(this.tok.T_TRY);\n    var result = this.node(\"try\");\n    var always = null;\n    var catches = [];\n    var body = this.next().read_statement(); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L455\n\n    while (this.token === this.tok.T_CATCH) {\n      var item = this.node(\"catch\");\n      this.next().expect(\"(\") && this.next();\n      var what = this.read_list(this.read_namespace_name, \"|\", false);\n      var variable = this.read_variable(true, false);\n      this.expect(\")\");\n      catches.push(item(this.next().read_statement(), what, variable));\n    }\n\n    if (this.token === this.tok.T_FINALLY) {\n      always = this.next().read_statement();\n    }\n\n    return result(body, catches, always);\n  }\n};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a short form of tokens\n   * @param {Number} token - The ending token\n   * @return {Block}\n   */\n  read_short_form: function read_short_form(token) {\n    var body = this.node(\"block\");\n    var items = [];\n    if (this.expect(\":\")) this.next();\n\n    while (this.token != this.EOF && this.token !== token) {\n      items.push(this.read_inner_statement());\n    }\n\n    if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      items.push(this.node(\"noop\")());\n    }\n\n    if (this.expect(token)) this.next();\n    this.expectEndOfStatement();\n    return body(null, items);\n  },\n\n  /**\n   * https://wiki.php.net/rfc/trailing-comma-function-calls\n   * @param {*} item\n   * @param {*} separator\n   */\n  read_function_list: function read_function_list(item, separator) {\n    var result = [];\n\n    do {\n      if (this.token == separator && this.version >= 703 && result.length > 0) {\n        result.push(this.node(\"noop\")());\n        break;\n      }\n\n      result.push(item.apply(this, []));\n\n      if (this.token != separator) {\n        break;\n      }\n\n      if (this.next().token == \")\" && this.version >= 703) {\n        break;\n      }\n    } while (this.token != this.EOF);\n\n    return result;\n  },\n\n  /**\n   * Helper : reads a list of tokens / sample : T_STRING ',' T_STRING ...\n   * ```ebnf\n   * list ::= separator? ( item separator )* item\n   * ```\n   */\n  read_list: function read_list(item, separator, preserveFirstSeparator) {\n    var result = [];\n\n    if (this.token == separator) {\n      if (preserveFirstSeparator) {\n        result.push(typeof item === \"function\" ? this.node(\"noop\")() : null);\n      }\n\n      this.next();\n    }\n\n    if (typeof item === \"function\") {\n      do {\n        var itemResult = item.apply(this, []);\n\n        if (itemResult) {\n          result.push(itemResult);\n        }\n\n        if (this.token != separator) {\n          break;\n        }\n      } while (this.next().token != this.EOF);\n    } else {\n      if (this.expect(item)) {\n        result.push(this.text());\n      } else {\n        return [];\n      }\n\n      while (this.next().token != this.EOF) {\n        if (this.token != separator) break; // trim current separator & check item\n\n        if (this.next().token != item) break;\n        result.push(this.text());\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of names separated by a comma\n   *\n   * ```ebnf\n   * name_list ::= namespace (',' namespace)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php class foo extends bar, baz { }\n   * ```\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L726\n   * @return {Reference[]}\n   */\n  read_name_list: function read_name_list() {\n    return this.read_list(this.read_namespace_name, \",\", false);\n  },\n\n  /**\n   * Reads the byref token and assign it to the specified node\n   * @param {*} cb\n   */\n  read_byref: function read_byref(cb) {\n    var byref = this.node(\"byref\");\n    this.next();\n    byref = byref(null);\n    var result = cb();\n\n    if (result) {\n      this.ast.swapLocations(result, byref, result, this);\n      result.byref = true;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of variables declarations\n   *\n   * ```ebnf\n   * variable_declaration ::= T_VARIABLE ('=' expr)?*\n   * variable_declarations ::= variable_declaration (',' variable_declaration)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php static $a = 'hello', $b = 'world';\n   * ```\n   * @return {StaticVariable[]} Returns an array composed by a list of variables, or\n   * assign values\n   */\n  read_variable_declarations: function read_variable_declarations() {\n    return this.read_list(function () {\n      var node = this.node(\"staticvariable\");\n      var variable = this.node(\"variable\"); // plain variable name\n\n      if (this.expect(this.tok.T_VARIABLE)) {\n        var name = this.text().substring(1);\n        this.next();\n        variable = variable(name, false);\n      } else {\n        variable = variable(\"#ERR\", false);\n      }\n\n      if (this.token === \"=\") {\n        return node(variable, this.next().read_expr());\n      } else {\n        return variable;\n      }\n    }, \",\");\n  },\n\n  /*\n   * Reads class extends\n   */\n  read_extends_from: function read_extends_from() {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_namespace_name();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads interface extends list\n   */\n  read_interface_extends_list: function read_interface_extends_list() {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads implements list\n   */\n  read_implements_list: function read_implements_list() {\n    if (this.token === this.tok.T_IMPLEMENTS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  }\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a variable\n   *\n   * ```ebnf\n   *   variable ::= &? ...complex @todo\n   * ```\n   *\n   * Some samples of parsed code :\n   * ```php\n   *  &$var                      // simple var\n   *  $var                      // simple var\n   *  classname::CONST_NAME     // dynamic class name with const retrieval\n   *  foo()                     // function call\n   *  $var->func()->property    // chained calls\n   * ```\n   */\n  read_variable: function read_variable(read_only, encapsed) {\n    var result; // check the byref flag\n\n    if (this.token === \"&\") {\n      return this.read_byref(this.read_variable.bind(this, read_only, encapsed));\n    } // reads the entry point\n\n\n    if (this.is([this.tok.T_VARIABLE, \"$\"])) {\n      result = this.read_reference_variable(encapsed);\n    } else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE])) {\n      result = this.node();\n      var name = this.read_namespace_name();\n\n      if (this.token != this.tok.T_DOUBLE_COLON && this.token != \"(\" && [\"parentreference\", \"selfreference\"].indexOf(name.kind) === -1) {\n        // @see parser.js line 130 : resolves a conflict with scalar\n        var literal = name.name.toLowerCase();\n\n        if (literal === \"true\") {\n          result = name.destroy(result(\"boolean\", true, name.name));\n        } else if (literal === \"false\") {\n          result = name.destroy(result(\"boolean\", false, name.name));\n        } else if (literal === \"null\") {\n          result = name.destroy(result(\"nullkeyword\", name.name));\n        } else {\n          result.destroy(name);\n          result = name;\n        }\n      } else {\n        // @fixme possible #193 bug\n        result.destroy(name);\n        result = name;\n      }\n    } else if (this.token === this.tok.T_STATIC) {\n      result = this.node(\"staticreference\");\n      var raw = this.text();\n      this.next();\n      result = result(raw);\n    } else {\n      this.expect(\"VARIABLE\");\n    } // static mode\n\n\n    if (this.token === this.tok.T_DOUBLE_COLON) {\n      result = this.read_static_getter(result, encapsed);\n    }\n\n    return this.recursive_variable_chain_scan(result, read_only, encapsed);\n  },\n  // resolves a static call\n  read_static_getter: function read_static_getter(what, encapsed) {\n    var result = this.node(\"staticlookup\");\n    var offset, name;\n\n    if (this.next().is([this.tok.T_VARIABLE, \"$\"])) {\n      offset = this.read_reference_variable(encapsed);\n    } else if (this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    } else if (this.token === \"{\") {\n      offset = this.node(\"literal\");\n      name = this.next().read_expr();\n      this.expect(\"}\") && this.next();\n      offset = offset(\"literal\", name, null);\n      this.expect(\"(\");\n    } else {\n      this.error([this.tok.T_VARIABLE, this.tok.T_STRING]); // graceful mode : set getter as error node and continue\n\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    }\n\n    return result(what, offset);\n  },\n  read_what: function read_what() {\n    var is_static_lookup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var what = null;\n    var name = null;\n\n    switch (this.next().token) {\n      case this.tok.T_STRING:\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n\n        if (is_static_lookup && this.token === this.tok.T_OBJECT_OPERATOR) {\n          this.error();\n        }\n\n        break;\n\n      case this.tok.T_VARIABLE:\n        what = this.node(\"variable\");\n        name = this.text().substring(1);\n        this.next();\n        what = what(name, false);\n        break;\n\n      case \"$\":\n        what = this.node();\n        this.next().expect([\"$\", \"{\", this.tok.T_VARIABLE]);\n\n        if (this.token === \"{\") {\n          // $obj->${$varname}\n          name = this.next().read_expr();\n          this.expect(\"}\") && this.next();\n          what = what(\"variable\", name, true);\n        } else {\n          // $obj->$$varname\n          name = this.read_expr();\n          what = what(\"variable\", name, false);\n        }\n\n        break;\n\n      case \"{\":\n        what = this.node(\"encapsedpart\");\n        name = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        what = what(name, \"complex\", false);\n        break;\n\n      default:\n        this.error([this.tok.T_STRING, this.tok.T_VARIABLE, \"$\", \"{\"]); // graceful mode : set what as error mode & continue\n\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n        break;\n    }\n\n    return what;\n  },\n  recursive_variable_chain_scan: function recursive_variable_chain_scan(result, read_only, encapsed) {\n    var node, offset;\n\n    recursive_scan_loop: while (this.token != this.EOF) {\n      switch (this.token) {\n        case \"(\":\n          if (read_only) {\n            // @fixme : add more informations & test\n            return result;\n          } else {\n            result = this.node(\"call\")(result, this.read_argument_list());\n          }\n\n          break;\n\n        case \"[\":\n        case \"{\":\n          {\n            var backet = this.token;\n            var isSquareBracket = backet === \"[\";\n            node = this.node(\"offsetlookup\");\n            this.next();\n            offset = false;\n\n            if (encapsed) {\n              offset = this.read_encaps_var_offset();\n              this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n            } else {\n              var isCallableVariable = isSquareBracket ? this.token !== \"]\" : this.token !== \"}\"; // callable_variable : https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1122\n\n              if (isCallableVariable) {\n                offset = this.read_expr();\n                this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n              } else {\n                this.next();\n              }\n            }\n\n            result = node(result, offset);\n            break;\n          }\n\n        case this.tok.T_DOUBLE_COLON:\n          // @see https://github.com/glayzzle/php-parser/issues/107#issuecomment-354104574\n          if (result.kind === \"staticlookup\" && result.offset.kind === \"identifier\") {\n            this.error();\n          }\n\n          node = this.node(\"staticlookup\");\n          result = node(result, this.read_what(true)); // fix 185\n          // static lookup dereferencables are limited to staticlookup over functions\n\n          /*if (dereferencable && this.token !== \"(\") {\n            this.error(\"(\");\n          }*/\n\n          break;\n\n        case this.tok.T_OBJECT_OPERATOR:\n          {\n            node = this.node(\"propertylookup\");\n            result = node(result, this.read_what());\n            break;\n          }\n\n        default:\n          break recursive_scan_loop;\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1231\n   */\n  read_encaps_var_offset: function read_encaps_var_offset() {\n    var offset = this.node();\n\n    if (this.token === this.tok.T_STRING) {\n      var text = this.text();\n      this.next();\n      offset = offset(\"identifier\", text);\n    } else if (this.token === this.tok.T_NUM_STRING) {\n      var num = this.text();\n      this.next();\n      offset = offset(\"number\", num, null);\n    } else if (this.token === \"-\") {\n      this.next();\n\n      var _num = -1 * this.text();\n\n      this.expect(this.tok.T_NUM_STRING) && this.next();\n      offset = offset(\"number\", _num, null);\n    } else if (this.token === this.tok.T_VARIABLE) {\n      var name = this.text().substring(1);\n      this.next();\n      offset = offset(\"variable\", name, false);\n    } else {\n      this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, \"-\", this.tok.T_VARIABLE]); // fallback : consider as identifier\n\n      var _text = this.text();\n\n      this.next();\n      offset = offset(\"identifier\", _text);\n    }\n\n    return offset;\n  },\n\n  /**\n   * ```ebnf\n   *  reference_variable ::=  simple_variable ('[' OFFSET ']')* | '{' EXPR '}'\n   * ```\n   * <code>\n   *  $foo[123];      // foo is an array ==> gets its entry\n   *  $foo{1};        // foo is a string ==> get the 2nd char offset\n   *  ${'foo'}[123];  // get the dynamic var $foo\n   *  $foo[123]{1};   // gets the 2nd char from the 123 array entry\n   * </code>\n   */\n  read_reference_variable: function read_reference_variable(encapsed) {\n    var result = this.read_simple_variable();\n    var offset;\n\n    while (this.token != this.EOF) {\n      var node = this.node();\n\n      if (this.token == \"{\" && !encapsed) {\n        // @fixme check coverage, not sure thats working\n        offset = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        result = node(\"offsetlookup\", result, offset);\n      } else {\n        node.destroy();\n        break;\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  simple_variable ::= T_VARIABLE | '$' '{' expr '}' | '$' simple_variable\n   * ```\n   */\n  read_simple_variable: function read_simple_variable() {\n    var result = this.node(\"variable\");\n    var name;\n\n    if (this.expect([this.tok.T_VARIABLE, \"$\"]) && this.token === this.tok.T_VARIABLE) {\n      // plain variable name\n      name = this.text().substring(1);\n      this.next();\n      result = result(name, false);\n    } else {\n      if (this.token === \"$\") this.next(); // dynamic variable name\n\n      switch (this.token) {\n        case \"{\":\n          {\n            var expr = this.next().read_expr();\n            this.expect(\"}\") && this.next();\n            result = result(expr, true);\n            break;\n          }\n\n        case \"$\":\n          // $$$var\n          result = result(this.read_simple_variable(), false);\n          break;\n\n        case this.tok.T_VARIABLE:\n          {\n            // $$var\n            name = this.text().substring(1);\n            var node = this.node(\"variable\");\n            this.next();\n            result = result(node(name, false), false);\n            break;\n          }\n\n        default:\n          this.error([\"{\", \"$\", this.tok.T_VARIABLE]); // graceful mode\n\n          name = this.text();\n          this.next();\n          result = result(name, false);\n      }\n    }\n\n    return result;\n  }\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * PHP AST Tokens\n * @type {Object}\n */\n\nmodule.exports = {\n  values: {\n    101: \"T_HALT_COMPILER\",\n    102: \"T_USE\",\n    103: \"T_ENCAPSED_AND_WHITESPACE\",\n    104: \"T_OBJECT_OPERATOR\",\n    105: \"T_STRING\",\n    106: \"T_DOLLAR_OPEN_CURLY_BRACES\",\n    107: \"T_STRING_VARNAME\",\n    108: \"T_CURLY_OPEN\",\n    109: \"T_NUM_STRING\",\n    110: \"T_ISSET\",\n    111: \"T_EMPTY\",\n    112: \"T_INCLUDE\",\n    113: \"T_INCLUDE_ONCE\",\n    114: \"T_EVAL\",\n    115: \"T_REQUIRE\",\n    116: \"T_REQUIRE_ONCE\",\n    117: \"T_NAMESPACE\",\n    118: \"T_NS_SEPARATOR\",\n    119: \"T_AS\",\n    120: \"T_IF\",\n    121: \"T_ENDIF\",\n    122: \"T_WHILE\",\n    123: \"T_DO\",\n    124: \"T_FOR\",\n    125: \"T_SWITCH\",\n    126: \"T_BREAK\",\n    127: \"T_CONTINUE\",\n    128: \"T_RETURN\",\n    129: \"T_GLOBAL\",\n    130: \"T_STATIC\",\n    131: \"T_ECHO\",\n    132: \"T_INLINE_HTML\",\n    133: \"T_UNSET\",\n    134: \"T_FOREACH\",\n    135: \"T_DECLARE\",\n    136: \"T_TRY\",\n    137: \"T_THROW\",\n    138: \"T_GOTO\",\n    139: \"T_FINALLY\",\n    140: \"T_CATCH\",\n    141: \"T_ENDDECLARE\",\n    142: \"T_LIST\",\n    143: \"T_CLONE\",\n    144: \"T_PLUS_EQUAL\",\n    145: \"T_MINUS_EQUAL\",\n    146: \"T_MUL_EQUAL\",\n    147: \"T_DIV_EQUAL\",\n    148: \"T_CONCAT_EQUAL\",\n    149: \"T_MOD_EQUAL\",\n    150: \"T_AND_EQUAL\",\n    151: \"T_OR_EQUAL\",\n    152: \"T_XOR_EQUAL\",\n    153: \"T_SL_EQUAL\",\n    154: \"T_SR_EQUAL\",\n    155: \"T_INC\",\n    156: \"T_DEC\",\n    157: \"T_BOOLEAN_OR\",\n    158: \"T_BOOLEAN_AND\",\n    159: \"T_LOGICAL_OR\",\n    160: \"T_LOGICAL_AND\",\n    161: \"T_LOGICAL_XOR\",\n    162: \"T_SL\",\n    163: \"T_SR\",\n    164: \"T_IS_IDENTICAL\",\n    165: \"T_IS_NOT_IDENTICAL\",\n    166: \"T_IS_EQUAL\",\n    167: \"T_IS_NOT_EQUAL\",\n    168: \"T_IS_SMALLER_OR_EQUAL\",\n    169: \"T_IS_GREATER_OR_EQUAL\",\n    170: \"T_INSTANCEOF\",\n    171: \"T_INT_CAST\",\n    172: \"T_DOUBLE_CAST\",\n    173: \"T_STRING_CAST\",\n    174: \"T_ARRAY_CAST\",\n    175: \"T_OBJECT_CAST\",\n    176: \"T_BOOL_CAST\",\n    177: \"T_UNSET_CAST\",\n    178: \"T_EXIT\",\n    179: \"T_PRINT\",\n    180: \"T_YIELD\",\n    181: \"T_YIELD_FROM\",\n    182: \"T_FUNCTION\",\n    183: \"T_DOUBLE_ARROW\",\n    184: \"T_DOUBLE_COLON\",\n    185: \"T_ARRAY\",\n    186: \"T_CALLABLE\",\n    187: \"T_CLASS\",\n    188: \"T_ABSTRACT\",\n    189: \"T_TRAIT\",\n    190: \"T_FINAL\",\n    191: \"T_EXTENDS\",\n    192: \"T_INTERFACE\",\n    193: \"T_IMPLEMENTS\",\n    194: \"T_VAR\",\n    195: \"T_PUBLIC\",\n    196: \"T_PROTECTED\",\n    197: \"T_PRIVATE\",\n    198: \"T_CONST\",\n    199: \"T_NEW\",\n    200: \"T_INSTEADOF\",\n    201: \"T_ELSEIF\",\n    202: \"T_ELSE\",\n    203: \"T_ENDSWITCH\",\n    204: \"T_CASE\",\n    205: \"T_DEFAULT\",\n    206: \"T_ENDFOR\",\n    207: \"T_ENDFOREACH\",\n    208: \"T_ENDWHILE\",\n    209: \"T_CONSTANT_ENCAPSED_STRING\",\n    210: \"T_LNUMBER\",\n    211: \"T_DNUMBER\",\n    212: \"T_LINE\",\n    213: \"T_FILE\",\n    214: \"T_DIR\",\n    215: \"T_TRAIT_C\",\n    216: \"T_METHOD_C\",\n    217: \"T_FUNC_C\",\n    218: \"T_NS_C\",\n    219: \"T_START_HEREDOC\",\n    220: \"T_END_HEREDOC\",\n    221: \"T_CLASS_C\",\n    222: \"T_VARIABLE\",\n    223: \"T_OPEN_TAG\",\n    224: \"T_OPEN_TAG_WITH_ECHO\",\n    225: \"T_CLOSE_TAG\",\n    226: \"T_WHITESPACE\",\n    227: \"T_COMMENT\",\n    228: \"T_DOC_COMMENT\",\n    229: \"T_ELLIPSIS\",\n    230: \"T_COALESCE\",\n    231: \"T_POW\",\n    232: \"T_POW_EQUAL\",\n    233: \"T_SPACESHIP\",\n    234: \"T_COALESCE_EQUAL\",\n    235: \"T_FN\"\n  },\n  names: {\n    T_HALT_COMPILER: 101,\n    T_USE: 102,\n    T_ENCAPSED_AND_WHITESPACE: 103,\n    T_OBJECT_OPERATOR: 104,\n    T_STRING: 105,\n    T_DOLLAR_OPEN_CURLY_BRACES: 106,\n    T_STRING_VARNAME: 107,\n    T_CURLY_OPEN: 108,\n    T_NUM_STRING: 109,\n    T_ISSET: 110,\n    T_EMPTY: 111,\n    T_INCLUDE: 112,\n    T_INCLUDE_ONCE: 113,\n    T_EVAL: 114,\n    T_REQUIRE: 115,\n    T_REQUIRE_ONCE: 116,\n    T_NAMESPACE: 117,\n    T_NS_SEPARATOR: 118,\n    T_AS: 119,\n    T_IF: 120,\n    T_ENDIF: 121,\n    T_WHILE: 122,\n    T_DO: 123,\n    T_FOR: 124,\n    T_SWITCH: 125,\n    T_BREAK: 126,\n    T_CONTINUE: 127,\n    T_RETURN: 128,\n    T_GLOBAL: 129,\n    T_STATIC: 130,\n    T_ECHO: 131,\n    T_INLINE_HTML: 132,\n    T_UNSET: 133,\n    T_FOREACH: 134,\n    T_DECLARE: 135,\n    T_TRY: 136,\n    T_THROW: 137,\n    T_GOTO: 138,\n    T_FINALLY: 139,\n    T_CATCH: 140,\n    T_ENDDECLARE: 141,\n    T_LIST: 142,\n    T_CLONE: 143,\n    T_PLUS_EQUAL: 144,\n    T_MINUS_EQUAL: 145,\n    T_MUL_EQUAL: 146,\n    T_DIV_EQUAL: 147,\n    T_CONCAT_EQUAL: 148,\n    T_MOD_EQUAL: 149,\n    T_AND_EQUAL: 150,\n    T_OR_EQUAL: 151,\n    T_XOR_EQUAL: 152,\n    T_SL_EQUAL: 153,\n    T_SR_EQUAL: 154,\n    T_INC: 155,\n    T_DEC: 156,\n    T_BOOLEAN_OR: 157,\n    T_BOOLEAN_AND: 158,\n    T_LOGICAL_OR: 159,\n    T_LOGICAL_AND: 160,\n    T_LOGICAL_XOR: 161,\n    T_SL: 162,\n    T_SR: 163,\n    T_IS_IDENTICAL: 164,\n    T_IS_NOT_IDENTICAL: 165,\n    T_IS_EQUAL: 166,\n    T_IS_NOT_EQUAL: 167,\n    T_IS_SMALLER_OR_EQUAL: 168,\n    T_IS_GREATER_OR_EQUAL: 169,\n    T_INSTANCEOF: 170,\n    T_INT_CAST: 171,\n    T_DOUBLE_CAST: 172,\n    T_STRING_CAST: 173,\n    T_ARRAY_CAST: 174,\n    T_OBJECT_CAST: 175,\n    T_BOOL_CAST: 176,\n    T_UNSET_CAST: 177,\n    T_EXIT: 178,\n    T_PRINT: 179,\n    T_YIELD: 180,\n    T_YIELD_FROM: 181,\n    T_FUNCTION: 182,\n    T_DOUBLE_ARROW: 183,\n    T_DOUBLE_COLON: 184,\n    T_ARRAY: 185,\n    T_CALLABLE: 186,\n    T_CLASS: 187,\n    T_ABSTRACT: 188,\n    T_TRAIT: 189,\n    T_FINAL: 190,\n    T_EXTENDS: 191,\n    T_INTERFACE: 192,\n    T_IMPLEMENTS: 193,\n    T_VAR: 194,\n    T_PUBLIC: 195,\n    T_PROTECTED: 196,\n    T_PRIVATE: 197,\n    T_CONST: 198,\n    T_NEW: 199,\n    T_INSTEADOF: 200,\n    T_ELSEIF: 201,\n    T_ELSE: 202,\n    T_ENDSWITCH: 203,\n    T_CASE: 204,\n    T_DEFAULT: 205,\n    T_ENDFOR: 206,\n    T_ENDFOREACH: 207,\n    T_ENDWHILE: 208,\n    T_CONSTANT_ENCAPSED_STRING: 209,\n    T_LNUMBER: 210,\n    T_DNUMBER: 211,\n    T_LINE: 212,\n    T_FILE: 213,\n    T_DIR: 214,\n    T_TRAIT_C: 215,\n    T_METHOD_C: 216,\n    T_FUNC_C: 217,\n    T_NS_C: 218,\n    T_START_HEREDOC: 219,\n    T_END_HEREDOC: 220,\n    T_CLASS_C: 221,\n    T_VARIABLE: 222,\n    T_OPEN_TAG: 223,\n    T_OPEN_TAG_WITH_ECHO: 224,\n    T_CLOSE_TAG: 225,\n    T_WHITESPACE: 226,\n    T_COMMENT: 227,\n    T_DOC_COMMENT: 228,\n    T_ELLIPSIS: 229,\n    T_COALESCE: 230,\n    T_POW: 231,\n    T_POW_EQUAL: 232,\n    T_SPACESHIP: 233,\n    T_COALESCE_EQUAL: 234,\n    T_FN: 235\n  }\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Location = __webpack_require__(41);\n\nvar Position = __webpack_require__(42);\n/**\n * ## Class hierarchy\n *\n * - [Location](#location)\n * - [Position](#position)\n * - [Node](#node)\n *   - [Noop](#noop)\n *   - [NullKeyword](#nullkeyword)\n *   - [StaticVariable](#staticvariable)\n *   - [EncapsedPart](#encapsedpart)\n *   - [Constant](#constant)\n *   - [Identifier](#identifier)\n *   - [Reference](#reference)\n *     - [TypeReference](#typereference)\n *     - [ParentReference](#parentreference)\n *     - [StaticReference](#staticreference)\n *     - [SelfReference](#selfreference)\n *     - [Name](#name)\n *   - [TraitUse](#traituse)\n *   - [TraitAlias](#traitalias)\n *   - [TraitPrecedence](#traitprecedence)\n *   - [Comment](#comment)\n *     - [CommentLine](#commentline)\n *     - [CommentBlock](#commentblock)\n *   - [Error](#error)\n *   - [Expression](#expression)\n *     - [Entry](#entry)\n *     - [ArrowFunc](#arrowfunc)\n *     - [Closure](#closure)\n *     - [ByRef](#byref)\n *     - [Silent](#silent)\n *     - [RetIf](#retif)\n *     - [New](#new)\n *     - [Include](#include)\n *     - [Call](#call)\n *     - [Eval](#eval)\n *     - [Exit](#exit)\n *     - [Clone](#clone)\n *     - [Assign](#assign)\n *     - [AssignRef](#assignref)\n *     - [Array](#array)\n *     - [List](#list)\n *     - [Variable](#variable)\n *     - [Variadic](#variadic)\n *     - [Yield](#yield)\n *     - [YieldFrom](#yieldfrom)\n *     - [Print](#print)\n *     - [Isset](#isset)\n *     - [Empty](#empty)\n *     - [Lookup](#lookup)\n *       - [PropertyLookup](#propertylookup)\n *       - [StaticLookup](#staticlookup)\n *       - [OffsetLookup](#offsetlookup)\n *     - [Operation](#operation)\n *       - [Pre](#pre)\n *       - [Post](#post)\n *       - [Bin](#bin)\n *       - [Unary](#unary)\n *       - [Cast](#cast)\n *     - [Literal](#literal)\n *       - [Boolean](#boolean)\n *       - [String](#string)\n *       - [Number](#number)\n *       - [Inline](#inline)\n *       - [Magic](#magic)\n *       - [Nowdoc](#nowdoc)\n *       - [Encapsed](#encapsed)\n *   - [Statement](#statement)\n *     - [ConstantStatement](#constantstatement)\n *       - [ClassConstant](#classconstant)\n *     - [Return](#return)\n *     - [Label](#label)\n *     - [Continue](#continue)\n *     - [Case](#case)\n *     - [Break](#break)\n *     - [Echo](#echo)\n *     - [Unset](#unset)\n *     - [Halt](#halt)\n *     - [Declare](#declare)\n *     - [Global](#global)\n *     - [Static](#static)\n *     - [If](#if)\n *     - [Do](#do)\n *     - [While](#while)\n *     - [For](#for)\n *     - [Foreach](#foreach)\n *     - [Switch](#switch)\n *     - [Goto](#goto)\n *     - [Try](#try)\n *     - [Catch](#catch)\n *     - [Throw](#throw)\n *     - [UseGroup](#usegroup)\n *     - [UseItem](#useitem)\n *     - [Block](#block)\n *       - [Program](#program)\n *       - [Namespace](#namespace)\n *     - [PropertyStatement](#propertystatement)\n *     - [Property](#property)\n *     - [Declaration](#declaration)\n *       - [Class](#class)\n *       - [Interface](#interface)\n *       - [Trait](#trait)\n *       - [Function](#function)\n *         - [Method](#method)\n *       - [Parameter](#parameter)\n * ---\n */\n\n/**\n * The AST builder class\n * @constructor AST\n * @tutorial AST\n * @property {Boolean} withPositions - Should locate any node (by default false)\n * @property {Boolean} withSource - Should extract the node original code (by default false)\n */\n\n\nvar AST = function AST(withPositions, withSource) {\n  this.withPositions = withPositions;\n  this.withSource = withSource;\n};\n/**\n * Create a position node from specified parser\n * including it's lexer current state\n * @param {Parser}\n * @return {Position}\n * @private\n */\n\n\nAST.prototype.position = function (parser) {\n  return new Position(parser.lexer.yylloc.first_line, parser.lexer.yylloc.first_column, parser.lexer.yylloc.first_offset);\n}; // operators in ascending order of precedence\n\n\nAST.precedence = {};\n[[\"or\"], [\"xor\"], [\"and\"], [\"=\"], [\"?\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"!=\", \"===\", \"!==\",\n/* '<>', */\n\"<=>\"], [\"<\", \"<=\", \">\", \">=\"], [\"<<\", \">>\"], [\"+\", \"-\", \".\"], [\"*\", \"/\", \"%\"], [\"!\"], [\"instanceof\"], [\"cast\", \"silent\"], [\"**\"] // TODO: [ (array)\n// TODO: clone, new\n].forEach(function (list, index) {\n  list.forEach(function (operator) {\n    AST.precedence[operator] = index + 1;\n  });\n});\n\nAST.prototype.isRightAssociative = function (operator) {\n  return operator === \"**\" || operator === \"??\";\n};\n/**\n * Change parent node informations after swapping childs\n */\n\n\nAST.prototype.swapLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    target.loc.start = first.loc.start;\n    target.loc.end = last.loc.end;\n\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);\n    }\n  }\n};\n/**\n * Includes locations from first & last into the target\n */\n\n\nAST.prototype.resolveLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    if (target.loc.start.offset > first.loc.start.offset) {\n      target.loc.start = first.loc.start;\n    }\n\n    if (target.loc.end.offset < last.loc.end.offset) {\n      target.loc.end = last.loc.end;\n    }\n\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);\n    }\n  }\n};\n/**\n * Check and fix precence, by default using right\n */\n\n\nAST.prototype.resolvePrecedence = function (result, parser) {\n  var buffer, lLevel, rLevel; // handling precendence\n\n  if (result.kind === \"call\") {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result, parser);\n  } else if (result.kind === \"propertylookup\" || result.kind === \"staticlookup\" || result.kind === \"offsetlookup\" && result.offset) {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result.offset, parser);\n  } else if (result.kind === \"bin\") {\n    if (result.right && !result.right.parenthesizedExpression) {\n      if (result.right.kind === \"bin\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[result.right.type];\n\n        if (lLevel && rLevel && rLevel <= lLevel && !this.isRightAssociative(result.type)) {\n          // https://github.com/glayzzle/php-parser/issues/79\n          // shift precedence\n          buffer = result.right;\n          result.right = result.right.left;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.left = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.left, buffer.right, parser);\n          result = buffer;\n        }\n      } else if (result.right.kind === \"retif\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[\"?\"];\n\n        if (lLevel && rLevel && rLevel <= lLevel) {\n          buffer = result.right;\n          result.right = result.right.test;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.test = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n          result = buffer;\n        }\n      }\n    }\n  } else if ((result.kind === \"silent\" || result.kind === \"cast\") && result.expr && !result.expr.parenthesizedExpression) {\n    // https://github.com/glayzzle/php-parser/issues/172\n    if (result.expr.kind === \"bin\") {\n      buffer = result.expr;\n      result.expr = result.expr.left;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.left = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.left, buffer.right, parser);\n      result = buffer;\n    } else if (result.expr.kind === \"retif\") {\n      buffer = result.expr;\n      result.expr = result.expr.test;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"unary\") {\n    // https://github.com/glayzzle/php-parser/issues/75\n    if (result.what && !result.what.parenthesizedExpression) {\n      // unary precedence is allways lower\n      if (result.what.kind === \"bin\") {\n        buffer = result.what;\n        result.what = result.what.left;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.left = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.left, buffer.right, parser);\n        result = buffer;\n      } else if (result.what.kind === \"retif\") {\n        buffer = result.what;\n        result.what = result.what.test;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.test = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"retif\") {\n    // https://github.com/glayzzle/php-parser/issues/77\n    if (result.falseExpr && result.falseExpr.kind === \"retif\" && !result.falseExpr.parenthesizedExpression) {\n      buffer = result.falseExpr;\n      result.falseExpr = buffer.test;\n      this.swapLocations(result, result.test, result.falseExpr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"assign\") {\n    // https://github.com/glayzzle/php-parser/issues/81\n    if (result.right && result.right.kind === \"bin\" && !result.right.parenthesizedExpression) {\n      lLevel = AST.precedence[\"=\"];\n      rLevel = AST.precedence[result.right.type]; // only shifts with and, xor, or\n\n      if (lLevel && rLevel && rLevel < lLevel) {\n        buffer = result.right;\n        result.right = result.right.left;\n        buffer.left = result;\n        this.swapLocations(buffer, buffer.left, result.right, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"expressionstatement\") {\n    this.swapLocations(result, result.expression, result, parser);\n  }\n\n  return result;\n};\n/**\n * Prepares an AST node\n * @param {String|null} kind - Defines the node type\n * (if null, the kind must be passed at the function call)\n * @param {Parser} parser - The parser instance (use for extracting locations)\n * @return {Function}\n */\n\n\nAST.prototype.prepare = function (kind, docs, parser) {\n  var start = null;\n\n  if (this.withPositions || this.withSource) {\n    start = this.position(parser);\n  }\n\n  var self = this; // returns the node\n\n  var result = function result() {\n    var location = null;\n    var args = Array.prototype.slice.call(arguments);\n    args.push(docs);\n\n    if (self.withPositions || self.withSource) {\n      var src = null;\n\n      if (self.withSource) {\n        src = parser.lexer._input.substring(start.offset, parser.prev[2]);\n      } // if with source, need location on swapLocations function\n\n\n      location = new Location(src, start, new Position(parser.prev[0], parser.prev[1], parser.prev[2])); // last argument is allways the location\n\n      args.push(location);\n    } // handle lazy kind definitions\n\n\n    if (!kind) {\n      kind = args.shift();\n    } // build the object\n\n\n    var node = self[kind];\n\n    if (typeof node !== \"function\") {\n      throw new Error('Undefined node \"' + kind + '\"');\n    }\n\n    var astNode = Object.create(node.prototype);\n    node.apply(astNode, args);\n    result.instance = astNode;\n\n    if (result.trailingComments) {\n      // buffer of trailingComments\n      astNode.trailingComments = result.trailingComments;\n    }\n\n    if (typeof result.postBuild === \"function\") {\n      result.postBuild(astNode);\n    }\n\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n\n    return self.resolvePrecedence(astNode, parser);\n  };\n\n  if (parser.debug) {\n    if (!AST.stack) {\n      AST.stack = {};\n      AST.stackUid = 1;\n    }\n\n    AST.stack[++AST.stackUid] = {\n      position: start,\n      stack: new Error().stack.split(\"\\n\").slice(3, 5)\n    };\n    result.stackUid = AST.stackUid;\n  }\n  /**\n   * Sets a list of trailing comments\n   * @param {*} docs\n   */\n\n\n  result.setTrailingComments = function (docs) {\n    if (result.instance) {\n      // already created\n      result.instance.setTrailingComments(docs);\n    } else {\n      result.trailingComments = docs;\n    }\n  };\n  /**\n   * Release a node without using it on the AST\n   */\n\n\n  result.destroy = function (target) {\n    if (docs) {\n      // release current docs stack\n      if (target) {\n        if (!target.leadingComments) {\n          target.leadingComments = docs;\n        } else {\n          target.leadingComments = docs.concat(target.leadingComments);\n        }\n      } else {\n        parser._docIndex = parser._docs.length - docs.length;\n      }\n    }\n\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n  };\n\n  return result;\n};\n\nAST.prototype.checkNodes = function () {\n  var errors = [];\n\n  for (var k in AST.stack) {\n    if (AST.stack.hasOwnProperty(k)) {\n      errors.push(AST.stack[k]);\n    }\n  }\n\n  AST.stack = {};\n  return errors;\n}; // Define all AST nodes\n\n\n[__webpack_require__(43), __webpack_require__(44), __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), __webpack_require__(7), __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(58), __webpack_require__(9), __webpack_require__(59), __webpack_require__(60), __webpack_require__(61), __webpack_require__(10), __webpack_require__(62), __webpack_require__(5), __webpack_require__(63), __webpack_require__(64), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71), __webpack_require__(72), __webpack_require__(73), __webpack_require__(1), __webpack_require__(74), __webpack_require__(75), __webpack_require__(76), __webpack_require__(11), __webpack_require__(77), __webpack_require__(78), __webpack_require__(79), __webpack_require__(80), __webpack_require__(81), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85), __webpack_require__(86), __webpack_require__(87), __webpack_require__(3), __webpack_require__(8), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(92), __webpack_require__(2), __webpack_require__(93), __webpack_require__(94), __webpack_require__(95), __webpack_require__(96), __webpack_require__(97), __webpack_require__(4), __webpack_require__(98), __webpack_require__(99), __webpack_require__(100), __webpack_require__(101), __webpack_require__(102), __webpack_require__(103), __webpack_require__(104), __webpack_require__(105), __webpack_require__(106), __webpack_require__(6), __webpack_require__(107), __webpack_require__(108), __webpack_require__(109), __webpack_require__(110), __webpack_require__(0), __webpack_require__(111), __webpack_require__(112), __webpack_require__(113), __webpack_require__(114), __webpack_require__(115), __webpack_require__(116), __webpack_require__(117), __webpack_require__(118), __webpack_require__(119), __webpack_require__(120), __webpack_require__(121), __webpack_require__(122), __webpack_require__(123), __webpack_require__(124), __webpack_require__(125), __webpack_require__(126), __webpack_require__(127), __webpack_require__(128), __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132)].forEach(function (ctor) {\n  AST.prototype[ctor.kind] = ctor;\n});\nmodule.exports = AST;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * Defines the location of the node (with it's source contents as string)\n * @constructor Location\n * @property {String|null} source\n * @property {Position} start\n * @property {Position} end\n */\n\nvar Location = function Location(source, start, end) {\n  this.source = source;\n  this.start = start;\n  this.end = end;\n};\n\nmodule.exports = Location;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * Each Position object consists of a line number (1-indexed) and a column number (0-indexed):\n * @constructor Position\n * @property {Number} line\n * @property {Number} column\n * @property {Number} offset\n */\n\nvar Position = function Position(line, column, offset) {\n  this.line = line;\n  this.column = column;\n  this.offset = offset;\n};\n\nmodule.exports = Position;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"array\";\n/**\n * Defines an array structure\n * @constructor Array\n * @example\n * // PHP code :\n * [1, 'foo' => 'bar', 3]\n *\n * // AST structure :\n * {\n *  \"kind\": \"array\",\n *  \"shortForm\": true\n *  \"items\": [\n *    {\"kind\": \"number\", \"value\": \"1\"},\n *    {\n *      \"kind\": \"entry\",\n *      \"key\": {\"kind\": \"string\", \"value\": \"foo\", \"isDoubleQuote\": false},\n *      \"value\": {\"kind\": \"string\", \"value\": \"bar\", \"isDoubleQuote\": false}\n *    },\n *    {\"kind\": \"number\", \"value\": \"3\"}\n *  ]\n * }\n * @extends {Expression}\n * @property {Entry|Expr|Variable} items List of array items\n * @property {boolean} shortForm Indicate if the short array syntax is used, ex `[]` instead `array()`\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Array(shortForm, items, docs, location) {\n  Expr.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"arrowfunc\";\n/**\n * Defines an arrow function (it's like a closure)\n * @constructor ArrowFunc\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {Expression} body\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {boolean} isStatic\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Closure(args, byref, body, type, nullable, isStatic, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.body = body;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n});\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"assign\";\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Assign(left, right, operator, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n  this.operator = operator;\n});\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"assignref\";\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function AssignRef(left, right, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n});\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"bin\";\n/**\n * Binary operations\n * @constructor Bin\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} left\n * @property {Expression} right\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Bin(type, left, right, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.left = left;\n  this.right = right;\n});\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"boolean\";\n/**\n * Defines a boolean value (true/false)\n * @constructor Boolean\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Boolean(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"break\";\n/**\n * A break statement\n * @constructor Break\n * @extends {Statement}\n * @property {Number|Null} level\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Break(level, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"byref\";\n/**\n * Passing by Reference - so the function can modify the variable\n * @constructor ByRef\n * @extends {Expression}\n * @property {expr} what\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function ByRef(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"call\";\n/**\n * Executes a call statement\n * @constructor Call\n * @extends {Expression}\n * @property {Identifier|Variable|??} what\n * @property {Arguments[]} arguments\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Call(what, args, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"case\";\n/**\n * A switch case statement\n * @constructor Case\n * @extends {Statement}\n * @property {Expression|null} test - if null, means that the default case\n * @property {Block|null} body\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Case(test, body, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"cast\";\n/**\n * Binary operations\n * @constructor Cast\n * @extends {Operation}\n * @property {String} type\n * @property {String} raw\n * @property {Expression} expr\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Cast(type, raw, expr, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.raw = raw;\n  this.expr = expr;\n});\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"catch\";\n/**\n * Defines a catch statement\n * @constructor Catch\n * @extends {Statement}\n * @property {Identifier[]} what\n * @property {Variable} variable\n * @property {Statement} body\n * @see http://php.net/manual/en/language.exceptions.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Catch(body, what, variable, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.what = what;\n  this.variable = variable;\n});\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"class\";\n/**\n * A class definition\n * @constructor Class\n * @extends {Declaration}\n * @property {Identifier|null} extends\n * @property {Identifier[]} implements\n * @property {Declaration[]} body\n * @property {boolean} isAnonymous\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Class(name, ext, impl, body, flags, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.isAnonymous = name ? false : true;\n  this[\"extends\"] = ext;\n  this[\"implements\"] = impl;\n  this.body = body;\n  this.parseFlags(flags);\n});\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar ConstantStatement = __webpack_require__(10);\n\nvar KIND = \"classconstant\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Defines a class/interface/trait constant\n * @constructor ClassConstant\n * @extends {ConstantStatement}\n * @property {string} visibility\n */\n\nvar ClassConstant = ConstantStatement[\"extends\"](KIND, function ClassConstant(kind, constants, flags, docs, location) {\n  ConstantStatement.apply(this, [kind || KIND, constants, docs, location]);\n  this.parseFlags(flags);\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nClassConstant.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n};\n\nmodule.exports = ClassConstant;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"clone\";\n/**\n * Defines a clone call\n * @constructor Clone\n * @extends {Expression}\n * @property {Expression} what\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Clone(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"closure\";\n/**\n * Defines a closure\n * @constructor Closure\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Variable[]} uses\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n * @property {boolean} isStatic\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Closure(args, byref, uses, type, nullable, isStatic, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.uses = uses;\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n  this.body = null;\n});\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Comment = __webpack_require__(9);\n\nvar KIND = \"commentblock\";\n/**\n * A comment block (multiline)\n * @constructor CommentBlock\n * @extends {Comment}\n */\n\nmodule.exports = Comment[\"extends\"](KIND, function CommentBlock(value, docs, location) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Comment = __webpack_require__(9);\n\nvar KIND = \"commentline\";\n/**\n * A single line comment\n * @constructor CommentLine\n * @extends {Comment}\n */\n\nmodule.exports = Comment[\"extends\"](KIND, function CommentLine(value, docs, location) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"constant\";\n/**\n * Defines a constant\n * @constructor Constant\n * @extends {Node}\n * @property {string} name\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Constant(name, value, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n});\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"continue\";\n/**\n * A continue statement\n * @constructor Continue\n * @extends {Statement}\n * @property {Number|Null} level\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Continue(level, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"declare\";\n/**\n * The declare construct is used to set execution directives for a block of code\n * @constructor Declare\n * @extends {Block}\n * @property {Array[]} directives\n * @property {String} mode\n * @see http://php.net/manual/en/control-structures.declare.php\n */\n\nvar Declare = Block[\"extends\"](KIND, function Declare(directives, body, mode, docs, location) {\n  Block.apply(this, [KIND, body, docs, location]);\n  this.directives = directives;\n  this.mode = mode;\n});\n/**\n * The node is declared as a short tag syntax :\n * ```php\n * <?php\n * declare(ticks=1):\n * // some statements\n * enddeclare;\n * ```\n * @constant {String} MODE_SHORT\n */\n\nDeclare.MODE_SHORT = \"short\";\n/**\n * The node is declared bracket enclosed code :\n * ```php\n * <?php\n * declare(ticks=1) {\n * // some statements\n * }\n * ```\n * @constant {String} MODE_BLOCK\n */\n\nDeclare.MODE_BLOCK = \"block\";\n/**\n * The node is declared as a simple statement. In order to make things simpler\n * children of the node are automatically collected until the next\n * declare statement.\n * ```php\n * <?php\n * declare(ticks=1);\n * // some statements\n * declare(ticks=2);\n * // some statements\n * ```\n * @constant {String} MODE_NONE\n */\n\nDeclare.MODE_NONE = \"none\";\nmodule.exports = Declare;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"declaredirective\";\n/**\n * Defines a constant\n * @constructor DeclareDirective\n * @extends {Node}\n * @property {Identifier} name\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Node[\"extends\"](KIND, function DeclareDirective(key, value, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n});\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"do\";\n/**\n * Defines a do/while statement\n * @constructor Do\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Do(test, body, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"echo\";\n/**\n * Defines system based call\n * @constructor Echo\n * @property {boolean} shortForm\n * @extends {Statement}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Echo(expressions, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.shortForm = shortForm;\n  this.expressions = expressions;\n});\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"empty\";\n/**\n * Defines an empty check call\n * @constructor Empty\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Empty(expression, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"encapsed\";\n/**\n * Defines an encapsed string (contains expressions)\n * @constructor Encapsed\n * @extends {Literal}\n * @property {String} type - Defines the type of encapsed string (shell, heredoc, string)\n * @property {String|Null} label - The heredoc label, defined only when the type is heredoc\n */\n\nvar Encapsed = Literal[\"extends\"](KIND, function Encapsed(value, raw, type, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.type = type;\n});\n/**\n * The node is a double quote string :\n * ```php\n * <?php\n * echo \"hello $world\";\n * ```\n * @constant {String} TYPE_STRING - `string`\n */\n\nEncapsed.TYPE_STRING = \"string\";\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo `ls -larth $path`;\n * ```\n * @constant {String} TYPE_SHELL - `shell`\n */\n\nEncapsed.TYPE_SHELL = \"shell\";\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo <<<STR\n *  Hello $world\n * STR\n * ;\n * ```\n * @constant {String} TYPE_HEREDOC - `heredoc`\n */\n\nEncapsed.TYPE_HEREDOC = \"heredoc\";\n/**\n * The node contains a list of constref / variables / expr :\n * ```php\n * <?php\n * echo $foo->bar_$baz;\n * ```\n * @constant {String} TYPE_OFFSET - `offset`\n */\n\nEncapsed.TYPE_OFFSET = \"offset\";\nmodule.exports = Encapsed;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"encapsedpart\";\n/**\n * Part of `Encapsed` node\n * @constructor EncapsedPart\n * @extends {Expression}\n * @property {Expression} expression\n * @property {String} syntax\n * @property {Boolean} curly\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function EncapsedPart(expression, syntax, curly, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.syntax = syntax;\n  this.curly = curly;\n});\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"entry\";\n/**\n * An array entry - see [Array](#array)\n * @constructor Entry\n * @extends {Expression}\n * @property {Node|null} key The entry key/offset\n * @property {Node} value The entry value\n * @property {Boolean} byRef By reference\n * @property {Boolean} unpack Argument unpacking\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Entry(key, value, byRef, unpack, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n  this.byRef = byRef;\n  this.unpack = unpack;\n});\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"error\";\n/**\n * Defines an error node (used only on silentMode)\n * @constructor Error\n * @extends {Node}\n * @property {string} message\n * @property {number} line\n * @property {number|string} token\n * @property {string|array} expected\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Error(message, token, line, expected, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.message = message;\n  this.token = token;\n  this.line = line;\n  this.expected = expected;\n});\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"eval\";\n/**\n * Defines an eval statement\n * @constructor Eval\n * @extends {Expression}\n * @property {Node} source\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Eval(source, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.source = source;\n});\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"exit\";\n/**\n * Defines an exit / die call\n * @constructor Exit\n * @extends {Expression}\n * @property {Node|null} expression\n * @property {Boolean} useDie\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Exit(expression, useDie, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.useDie = useDie;\n});\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"expressionstatement\";\n/**\n * Defines an expression based statement\n * @constructor ExpressionStatement\n * @extends {Statement}\n * @property {Expression} expression\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function ExpressionStatement(expr, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expression = expr;\n});\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"for\";\n/**\n * Defines a for iterator\n * @constructor For\n * @extends {Statement}\n * @property {Expression[]} init\n * @property {Expression[]} test\n * @property {Expression[]} increment\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.for.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function For(init, test, increment, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.init = init;\n  this.test = test;\n  this.increment = increment;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"foreach\";\n/**\n * Defines a foreach iterator\n * @constructor Foreach\n * @extends {Statement}\n * @property {Expression} source\n * @property {Expression|null} key\n * @property {Expression} value\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.foreach.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Foreach(source, key, value, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.source = source;\n  this.key = key;\n  this.value = value;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"global\";\n/**\n * Imports a variable from the global scope\n * @constructor Global\n * @extends {Statement}\n * @property {Variable[]} items\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Global(items, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.items = items;\n});\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"goto\";\n/**\n * Defines goto statement\n * @constructor Goto\n * @extends {Statement}\n * @property {String} label\n * @see {Label}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Goto(label, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.label = label;\n});\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"halt\";\n/**\n * Halts the compiler execution\n * @constructor Halt\n * @extends {Statement}\n * @property {String} after - String after the halt statement\n * @see http://php.net/manual/en/function.halt-compiler.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Halt(after, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.after = after;\n});\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"identifier\";\n/**\n * Defines an identifier node\n * @constructor Identifier\n * @extends {Node}\n * @property {string} name\n */\n\nvar Identifier = Node[\"extends\"](KIND, function Identifier(name, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\nmodule.exports = Identifier;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"if\";\n/**\n * Defines a if statement\n * @constructor If\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {Block|If|null} alternate\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function If(test, body, alternate, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.alternate = alternate;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"include\";\n/**\n * Defines system include call\n * @constructor Include\n * @extends {Expression}\n * @property {Node} target\n * @property {boolean} once\n * @property {boolean} require\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Include(once, require, target, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.once = once;\n  this.require = require;\n  this.target = target;\n});\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"inline\";\n/**\n * Defines inline html output (treated as echo output)\n * @constructor Inline\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Inline(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"interface\";\n/**\n * An interface definition\n * @constructor Interface\n * @extends {Declaration}\n * @property {Identifier[]} extends\n * @property {Declaration[]} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Interface(name, ext, body, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this[\"extends\"] = ext;\n  this.body = body;\n});\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"isset\";\n/**\n * Defines an isset call\n * @constructor Isset\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Isset(variables, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"label\";\n/**\n * A label statement (referenced by goto)\n * @constructor Label\n * @extends {Statement}\n * @property {String} name\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Label(name, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"list\";\n/**\n * Defines list assignment\n * @constructor List\n * @extends {Expression}\n * @property {boolean} shortForm\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function List(items, shortForm, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"magic\";\n/**\n * Defines magic constant\n * @constructor Magic\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Magic(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar _Function = __webpack_require__(11);\n\nvar KIND = \"method\";\n/**\n * Defines a class/interface/trait method\n * @constructor Method\n * @extends {_Function}\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n * @property {boolean} isStatic\n * @property {string} visibility\n */\n\nmodule.exports = _Function[\"extends\"](KIND, function Method() {\n  _Function.apply(this, arguments);\n\n  this.kind = KIND;\n});\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"name\";\n/**\n * Defines a class reference node\n * @constructor Name\n * @extends {Reference}\n * @property {string} name\n * @property {string} resolution\n */\n\nvar Name = Reference[\"extends\"](KIND, function Name(name, isRelative, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n\n  if (isRelative) {\n    this.resolution = Name.RELATIVE_NAME;\n  } else if (name.length === 1) {\n    this.resolution = Name.UNQUALIFIED_NAME;\n  } else if (!name[0]) {\n    this.resolution = Name.FULL_QUALIFIED_NAME;\n  } else {\n    this.resolution = Name.QUALIFIED_NAME;\n  }\n\n  this.name = name.join(\"\\\\\");\n});\n/**\n * This is an identifier without a namespace separator, such as Foo\n * @constant {String} UNQUALIFIED_NAME\n */\n\nName.UNQUALIFIED_NAME = \"uqn\";\n/**\n * This is an identifier with a namespace separator, such as Foo\\Bar\n * @constant {String} QUALIFIED_NAME\n */\n\nName.QUALIFIED_NAME = \"qn\";\n/**\n * This is an identifier with a namespace separator that begins with\n * a namespace separator, such as \\Foo\\Bar. The namespace \\Foo is also\n * a fully qualified name.\n * @constant {String} FULL_QUALIFIED_NAME\n */\n\nName.FULL_QUALIFIED_NAME = \"fqn\";\n/**\n * This is an identifier starting with namespace, such as namespace\\Foo\\Bar.\n * @constant {String} RELATIVE_NAME\n */\n\nName.RELATIVE_NAME = \"rn\";\nmodule.exports = Name;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"namespace\";\n/**\n * The main program node\n * @constructor Namespace\n * @extends {Block}\n * @property {String} name\n * @property {Boolean} withBrackets\n */\n\nmodule.exports = Block[\"extends\"](KIND, function Namespace(name, children, withBrackets, docs, location) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.name = name;\n  this.withBrackets = withBrackets || false;\n});\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"new\";\n/**\n * Creates a new instance of the specified class\n * @constructor New\n * @extends {Expression}\n * @property {Identifier|Variable|Class} what\n * @property {Arguments[]} arguments\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function New(what, args, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"noop\";\n/**\n * Ignore this node, it implies a no operation block, for example :\n * [$foo, $bar, /* here a noop node * /]\n * @constructor Noop\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Noop(docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n});\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"nowdoc\";\n/**\n * Defines a nowdoc string\n * @constructor NowDoc\n * @extends {Literal}\n * @property {String} label\n * @property {String} raw\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Nowdoc(value, raw, label, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.label = label;\n});\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"nullkeyword\";\n/**\n * Represents the null keyword\n * @constructor NullKeyword\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function NullKeyword(raw, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"number\";\n/**\n * Defines a numeric value\n * @constructor Number\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Number(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"offsetlookup\";\n/**\n * Lookup on an offset in an array\n * @constructor OffsetLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function OffsetLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"parameter\";\n/**\n * Defines a function parameter\n * @constructor Parameter\n * @extends {Declaration}\n * @property {Identifier|null} type\n * @property {Node|null} value\n * @property {boolean} byref\n * @property {boolean} variadic\n * @property {boolean} nullable\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Parameter(name, type, value, isRef, isVariadic, nullable, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.value = value;\n  this.type = type;\n  this.byref = isRef;\n  this.variadic = isVariadic;\n  this.nullable = nullable;\n});\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"parentreference\";\n/**\n * Defines a class reference node\n * @constructor ParentReference\n * @extends {Reference}\n */\n\nvar ParentReference = Reference[\"extends\"](KIND, function ParentReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = ParentReference;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"post\";\n/**\n * Defines a post operation `$i++` or `$i--`\n * @constructor Post\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Post(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"pre\";\n/**\n * Defines a pre operation `++$i` or `--$i`\n * @constructor Pre\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Pre(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"print\";\n/**\n * Outputs\n * @constructor Print\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Print(expression, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"program\";\n/**\n * The main program node\n * @constructor Program\n * @extends {Block}\n * @property {Error[]} errors\n * @property {Doc[]?} comments\n * @property {String[]?} tokens\n */\n\nmodule.exports = Block[\"extends\"](KIND, function Program(children, errors, comments, tokens, docs, location) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.errors = errors;\n\n  if (comments) {\n    this.comments = comments;\n  }\n\n  if (tokens) {\n    this.tokens = tokens;\n  }\n});\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"property\";\n/**\n * Defines a class property\n * @constructor Property\n * @extends {Statement}\n * @property {string} name\n * @property {Node|null} value\n * @property {boolean} nullable\n * @property {Identifier|Array<Identifier>|null} type\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Property(name, value, nullable, type, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n  this.nullable = nullable;\n  this.type = type;\n});\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"propertylookup\";\n/**\n * Lookup to an object property\n * @constructor PropertyLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function PropertyLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"propertystatement\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Declares a properties into the current scope\n * @constructor PropertyStatement\n * @extends {Statement}\n * @property {Property[]} properties\n */\n\nvar PropertyStatement = Statement[\"extends\"](KIND, function PropertyStatement(kind, properties, flags, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.properties = properties;\n  this.parseFlags(flags);\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nPropertyStatement.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n\n  this.isStatic = flags[1] === 1;\n};\n\nmodule.exports = PropertyStatement;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"retif\";\n/**\n * Defines a short if statement that returns a value\n * @constructor RetIf\n * @extends {Expression}\n * @property {Expression} test\n * @property {Expression} trueExpr\n * @property {Expression} falseExpr\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function RetIf(test, trueExpr, falseExpr, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.trueExpr = trueExpr;\n  this.falseExpr = falseExpr;\n});\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"return\";\n/**\n * A continue statement\n * @constructor Return\n * @extends {Statement}\n * @property {Expression|null} expr\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Return(expr, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"selfreference\";\n/**\n * Defines a class reference node\n * @constructor SelfReference\n * @extends {Reference}\n */\n\nvar SelfReference = Reference[\"extends\"](KIND, function SelfReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = SelfReference;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"silent\";\n/**\n * Avoids to show/log warnings & notices from the inner expression\n * @constructor Silent\n * @extends {Expression}\n * @property {Expression} expr\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Silent(expr, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"static\";\n/**\n * Declares a static variable into the current scope\n * @constructor Static\n * @extends {Statement}\n * @property {StaticVariable[]} variables\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Static(variables, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"staticvariable\";\n/**\n * Defines a constant\n * @constructor StaticVariable\n * @extends {Node}\n * @property {Variable} variable\n * @property {Node|string|number|boolean|null} defaultValue\n */\n\nmodule.exports = Node[\"extends\"](KIND, function StaticVariable(variable, defaultValue, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.variable = variable;\n  this.defaultValue = defaultValue;\n});\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"staticlookup\";\n/**\n * Lookup to a static property\n * @constructor StaticLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function StaticLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"staticreference\";\n/**\n * Defines a class reference node\n * @constructor StaticReference\n * @extends {Reference}\n */\n\nvar StaticReference = Reference[\"extends\"](KIND, function StaticReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = StaticReference;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"string\";\n/**\n * Defines a string (simple ou double quoted) - chars are already escaped\n * @constructor String\n * @extends {Literal}\n * @property {boolean} unicode\n * @property {boolean} isDoubleQuote\n * @see {Encapsed}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function String(isDoubleQuote, value, unicode, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.unicode = unicode;\n  this.isDoubleQuote = isDoubleQuote;\n});\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"switch\";\n/**\n * Defines a switch statement\n * @constructor Switch\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Switch(test, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"throw\";\n/**\n * Defines a throw statement\n * @constructor Throw\n * @extends {Statement}\n * @property {Expression} what\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Throw(what, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"trait\";\n/**\n * A trait definition\n * @constructor Trait\n * @extends {Declaration}\n * @property {Declaration[]} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Trait(name, body, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.body = body;\n});\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traitalias\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Defines a trait alias\n * @constructor TraitAlias\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier|null} as\n * @property {string|null} visibility\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitAlias(trait, method, as, flags, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.as = as;\n  this.visibility = IS_UNDEFINED;\n\n  if (flags) {\n    if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n  }\n});\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traitprecedence\";\n/**\n * Defines a trait alias\n * @constructor TraitPrecedence\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier[]} instead\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitPrecedence(trait, method, instead, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.instead = instead;\n});\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traituse\";\n/**\n * Defines a trait usage\n * @constructor TraitUse\n * @extends {Node}\n * @property {Identifier[]} traits\n * @property {Node[]|null} adaptations\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitUse(traits, adaptations, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.traits = traits;\n  this.adaptations = adaptations;\n});\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"try\";\n/**\n * Defines a try statement\n * @constructor Try\n * @extends {Statement}\n * @property {Block} body\n * @property {Catch[]} catches\n * @property {Block} allways\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Try(body, catches, always, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.catches = catches;\n  this.always = always;\n});\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"typereference\";\n/**\n * Defines a class reference node\n * @constructor TypeReference\n * @extends {Reference}\n * @property {string} name\n */\n\nvar TypeReference = Reference[\"extends\"](KIND, function TypeReference(name, raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.raw = raw;\n});\nTypeReference.types = [\"int\", \"float\", \"string\", \"bool\", \"object\", \"array\", \"callable\", \"iterable\", \"void\"];\nmodule.exports = TypeReference;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"unary\";\n/**\n * Unary operations\n * @constructor Unary\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Unary(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"unset\";\n/**\n * Deletes references to a list of variables\n * @constructor Unset\n * @extends {Statement}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Unset(variables, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"usegroup\";\n/**\n * Defines a use statement (with a list of use items)\n * @constructor UseGroup\n * @extends {Statement}\n * @property {String|null} name\n * @property {String|null} type - Possible value : function, const\n * @property {UseItem[]} item\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function UseGroup(name, type, items, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.type = type;\n  this.items = items;\n});\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"useitem\";\n/**\n * Defines a use statement (from namespace)\n * @constructor UseItem\n * @extends {Statement}\n * @property {String} name\n * @property {String|null} type - Possible value : function, const\n * @property {Identifier|null} alias\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\n\nvar UseItem = Statement[\"extends\"](KIND, function UseItem(name, alias, type, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.alias = alias;\n  this.type = type;\n});\n/**\n * Importing a constant\n * @constant {String} TYPE_CONST\n */\n\nUseItem.TYPE_CONST = \"const\";\n/**\n * Importing a function\n * @constant {String} TYPE_FUNC\n */\n\nUseItem.TYPE_FUNCTION = \"function\";\nmodule.exports = UseItem;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"variable\";\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Variable\n * @extends {Expression}\n * @example\n * // PHP code :\n * $foo\n * // AST output\n * {\n *  \"kind\": \"variable\",\n *  \"name\": \"foo\",\n *  \"curly\": false\n * }\n * @property {String|Node} name The variable name (can be a complex expression when the name is resolved dynamically)\n * @property {boolean} curly Indicate if the name is defined between curlies, ex `${foo}`\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Variable(name, curly, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.curly = curly || false;\n});\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"variadic\";\n/**\n * Introduce a list of items into the arguments of the call\n * @constructor variadic\n * @extends {Expression}\n * @property {Array|Expression} what\n * @see https://wiki.php.net/rfc/argument_unpacking\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function variadic(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"while\";\n/**\n * Defines a while statement\n * @constructor While\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function While(test, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"yield\";\n/**\n * Defines a yield generator statement\n * @constructor Yield\n * @extends {Expression}\n * @property {Expression|Null} value\n * @property {Expression|Null} key\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Yield(value, key, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n  this.key = key;\n});\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"yieldfrom\";\n/**\n * Defines a yield from generator statement\n * @constructor YieldFrom\n * @extends {Expression}\n * @property {Expression} value\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function YieldFrom(value, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n});\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGhwLXBhcnNlci9kaXN0L3BocC1wYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhwLXBhcnNlci9kaXN0L3BocC1wYXJzZXIuanM/YTE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFxuICogICBQYWNrYWdlOiBwaHAtcGFyc2VyXG4gKiAgIFBhcnNlIFBIUCBjb2RlIGZyb20gSlMgYW5kIHJldHVybnMgaXRzIEFTVFxuICogICBCdWlsZDogNmFmMjBmNDNkMGQ2ODU1YWMwZTAgLSAyMDIwLTQtMjRcbiAqICAgQ29weXJpZ2h0IChDKSAyMDIwIEdsYXl6emxlIChCU0QtMy1DbGF1c2UpXG4gKiAgIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqICAgQHVybCBodHRwOi8vZ2xheXp6bGUuY29tICAgICAgICBcbiAqICAgICAgIFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaHBQYXJzZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhwUGFyc2VyXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJzdGF0ZW1lbnRcIjtcbi8qKlxuICogQW55IHN0YXRlbWVudC5cbiAqIEBjb25zdHJ1Y3RvciBTdGF0ZW1lbnRcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGVtZW50KGtpbmQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJleHByZXNzaW9uXCI7XG4vKipcbiAqIEFueSBleHByZXNzaW9uIG5vZGUuIFNpbmNlIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhbiBhc3NpZ25tZW50IG1heVxuICogYmUgYW55IGV4cHJlc3Npb24gaW4gZ2VuZXJhbCwgYW4gZXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBhIHBhdHRlcm4uXG4gKiBAY29uc3RydWN0b3IgRXhwcmVzc2lvblxuICogQGV4dGVuZHMge05vZGV9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFeHByZXNzaW9uKGtpbmQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgQVNUIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBOb2RlXG4gKiBAcHJvcGVydHkge0xvY2F0aW9ufG51bGx9IGxvY1xuICogQHByb3BlcnR5IHtDb21tZW50W119IGxlYWRpbmdDb21tZW50c1xuICogQHByb3BlcnR5IHtDb21tZW50W10/fSB0cmFpbGluZ0NvbW1lbnRzXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2luZFxuICovXG5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShraW5kLCBkb2NzLCBsb2NhdGlvbikge1xuICB0aGlzLmtpbmQgPSBraW5kO1xuXG4gIGlmIChkb2NzKSB7XG4gICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBkb2NzO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5sb2MgPSBsb2NhdGlvbjtcbiAgfVxufTtcbi8qKlxuICogQXR0YWNoIGNvbW1lbnRzIHRvIGN1cnJlbnQgbm9kZVxuICogQHBhcmFtIHsqfSBkb2NzXG4gKi9cblxuXG5Ob2RlLnByb3RvdHlwZS5zZXRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKGRvY3MpIHtcbiAgdGhpcy50cmFpbGluZ0NvbW1lbnRzID0gZG9jcztcbn07XG4vKipcbiAqIERlc3Ryb3lpbmcgYW4gdW51c2VkIG5vZGVcbiAqL1xuXG5cbk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHlvdSBtdXN0IHN3YXAgd2l0aCBhbm90aGVyIG5vZGVcIik7XG4gIH1cblxuICBpZiAodGhpcy5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gQXJyYXkuY29uY2F0KHRoaXMubGVhZGluZ0NvbW1lbnRzLCBub2RlLmxlYWRpbmdDb21tZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gdGhpcy5sZWFkaW5nQ29tbWVudHM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudHJhaWxpbmdDb21tZW50cykge1xuICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IEFycmF5LmNvbmNhdCh0aGlzLnRyYWlsaW5nQ29tbWVudHMsIG5vZGUudHJhaWxpbmdDb21tZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRoaXMudHJhaWxpbmdDb21tZW50cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEluY2x1ZGVzIGN1cnJlbnQgdG9rZW4gcG9zaXRpb24gb2YgdGhlIHBhcnNlclxuICogQHBhcmFtIHsqfSBwYXJzZXJcbiAqL1xuXG5cbk5vZGUucHJvdG90eXBlLmluY2x1ZGVUb2tlbiA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgaWYgKHRoaXMubG9jKSB7XG4gICAgaWYgKHRoaXMubG9jLmVuZCkge1xuICAgICAgdGhpcy5sb2MuZW5kLmxpbmUgPSBwYXJzZXIubGV4ZXIueXlsbG9jLmxhc3RfbGluZTtcbiAgICAgIHRoaXMubG9jLmVuZC5jb2x1bW4gPSBwYXJzZXIubGV4ZXIueXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdGhpcy5sb2MuZW5kLm9mZnNldCA9IHBhcnNlci5sZXhlci5vZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hc3Qud2l0aFNvdXJjZSkge1xuICAgICAgdGhpcy5sb2Muc291cmNlID0gcGFyc2VyLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5sb2Muc3RhcnQub2Zmc2V0LCBwYXJzZXIubGV4ZXIub2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEhlbHBlciBmb3IgZXh0ZW5kaW5nIHRoZSBOb2RlIGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuTm9kZVtcImV4dGVuZHNcIl0gPSBmdW5jdGlvbiAodHlwZSwgY29uc3RydWN0b3IpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gIGNvbnN0cnVjdG9yW1wiZXh0ZW5kc1wiXSA9IHRoaXNbXCJleHRlbmRzXCJdO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgY29uc3RydWN0b3Iua2luZCA9IHR5cGU7XG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwibGl0ZXJhbFwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGFycmF5IHN0cnVjdHVyZVxuICogQGNvbnN0cnVjdG9yIExpdGVyYWxcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJhd1xuICogQHByb3BlcnR5IHtOb2RlfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTGl0ZXJhbChraW5kLCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBpZiAocmF3KSB7XG4gICAgdGhpcy5yYXcgPSByYXc7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJvcGVyYXRpb25cIjtcbi8qKlxuICogRGVmaW5lcyBiaW5hcnkgb3BlcmF0aW9uc1xuICogQGNvbnN0cnVjdG9yIE9wZXJhdGlvblxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBPcGVyYXRpb24oa2luZCwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwci5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZGVjbGFyYXRpb25cIjtcbnZhciBJU19VTkRFRklORUQgPSBcIlwiO1xudmFyIElTX1BVQkxJQyA9IFwicHVibGljXCI7XG52YXIgSVNfUFJPVEVDVEVEID0gXCJwcm90ZWN0ZWRcIjtcbnZhciBJU19QUklWQVRFID0gXCJwcml2YXRlXCI7XG4vKipcbiAqIEEgZGVjbGFyYXRpb24gc3RhdGVtZW50IChmdW5jdGlvbiwgY2xhc3MsIGludGVyZmFjZS4uLilcbiAqIEBjb25zdHJ1Y3RvciBEZWNsYXJhdGlvblxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxzdHJpbmd9IG5hbWVcbiAqL1xuXG52YXIgRGVjbGFyYXRpb24gPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIERlY2xhcmF0aW9uKGtpbmQsIG5hbWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufSk7XG4vKipcbiAqIEdlbmVyaWMgZmxhZ3MgcGFyc2VyXG4gKiBAcGFyYW0ge0ludGVnZXJbXX0gZmxhZ3NcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblxuRGVjbGFyYXRpb24ucHJvdG90eXBlLnBhcnNlRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgdGhpcy5pc0Fic3RyYWN0ID0gZmxhZ3NbMl0gPT09IDE7XG4gIHRoaXMuaXNGaW5hbCA9IGZsYWdzWzJdID09PSAyO1xuXG4gIGlmICh0aGlzLmtpbmQgIT09IFwiY2xhc3NcIikge1xuICAgIGlmIChmbGFnc1swXSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1VOREVGSU5FRDtcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSBudWxsKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZmxhZ3NbMF0gPT09IDApIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BVQkxJQztcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAxKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19QUk9URUNURUQ7XG4gICAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMikge1xuICAgICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJJVkFURTtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3RhdGljID0gZmxhZ3NbMV0gPT09IDE7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb247XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcInJlZmVyZW5jZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgcmVmZXJlbmNlIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBSZWZlcmVuY2VcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbnZhciBSZWZlcmVuY2UgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBSZWZlcmVuY2Uoa2luZCwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJibG9ja1wiO1xuLyoqXG4gKiBBIGJsb2NrIHN0YXRlbWVudCwgaS5lLiwgYSBzZXF1ZW5jZSBvZiBzdGF0ZW1lbnRzIHN1cnJvdW5kZWQgYnkgYnJhY2VzLlxuICogQGNvbnN0cnVjdG9yIEJsb2NrXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtOb2RlW119IGNoaWxkcmVuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEJsb2NrKGtpbmQsIGNoaWxkcmVuLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihCb29sZWFuKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJsb29rdXBcIjtcbi8qKlxuICogTG9va3VwIG9uIGFuIG9mZnNldCBpbiB0aGUgc3BlY2lmaWVkIG9iamVjdFxuICogQGNvbnN0cnVjdG9yIExvb2t1cFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHdoYXRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gb2Zmc2V0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBMb29rdXAoa2luZCwgd2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByLmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qKlxuICogQWJzdHJhY3QgZG9jdW1lbnRhdGlvbiBub2RlIChDb21lbnRMaW5lIG9yIENvbW1lbnRCbG9jaylcbiAqIEBjb25zdHJ1Y3RvciBDb21tZW50XG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2YWx1ZVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShcImNvbW1lbnRcIiwgZnVuY3Rpb24gQ29tbWVudChraW5kLCB2YWx1ZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBba2luZCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImNvbnN0YW50c3RhdGVtZW50XCI7XG4vKipcbiAqIERlY2xhcmVzIGEgY29uc3RhbnRzIGludG8gdGhlIGN1cnJlbnQgc2NvcGVcbiAqIEBjb25zdHJ1Y3RvciBDb25zdGFudFN0YXRlbWVudFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7Q29uc3RhbnRbXX0gY29uc3RhbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbnN0YW50U3RhdGVtZW50KGtpbmQsIGNvbnN0YW50cywgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRGVjbGFyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgS0lORCA9IFwiZnVuY3Rpb25cIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzaWMgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvblxuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtQYXJhbWV0ZXJbXX0gYXJndW1lbnRzXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnlyZWZcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbnVsbGFibGVcbiAqIEBwcm9wZXJ0eSB7QmxvY2t8bnVsbH0gYm9keVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIF9GdW5jdGlvbihuYW1lLCBhcmdzLCBieXJlZiwgdHlwZSwgbnVsbGFibGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBuYW1lLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gIHRoaXMuYnlyZWYgPSBieXJlZjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICB0aGlzLmJvZHkgPSBudWxsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAyMCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBsZXhlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciB0b2tlbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIEFTVCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY29tYmluZShzcmMsIHRvKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgIHZhciB2YWwgPSBzcmNba107XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgdG9ba107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRvW2tdID0gdmFsLmJpbmQodG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0b1trXSA9IEFycmF5LmlzQXJyYXkodG9ba10pID8gdG9ba10uY29uY2F0KHZhbCkgOiB2YWw7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHZhbCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRvW2tdID0gX3R5cGVvZih0b1trXSkgPT09IFwib2JqZWN0XCIgPyBjb21iaW5lKHZhbCwgdG9ba10pIDogdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1trXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAdHV0b3JpYWwgRW5naW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhcnNlciA9IHJlcXVpcmUoJ3BocC1wYXJzZXInKTtcbiAqIHZhciBpbnN0YW5jZSA9IG5ldyBwYXJzZXIoe1xuICogICBwYXJzZXI6IHtcbiAqICAgICBleHRyYWN0RG9jOiB0cnVlLFxuICogICAgIHN1cHByZXNzRXJyb3JzOiB0cnVlLFxuICogICAgIHZlcnNpb246IDcwNCAvLyBvciAnNy40J1xuICogICB9LFxuICogICBhc3Q6IHtcbiAqICAgICB3aXRoUG9zaXRpb25zOiB0cnVlXG4gKiAgIH0sXG4gKiAgIGxleGVyOiB7XG4gKiAgICAgc2hvcnRfdGFnczogdHJ1ZSxcbiAqICAgICBhc3BfdGFnczogdHJ1ZVxuICogICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgZXZhbEFTVCA9IGluc3RhbmNlLnBhcnNlRXZhbCgnc29tZSBwaHAgY29kZScpO1xuICogdmFyIGNvZGVBU1QgPSBpbnN0YW5jZS5wYXJzZUNvZGUoJzw/cGhwIHNvbWUgcGhwIGNvZGUnLCAnZm9vLnBocCcpO1xuICogdmFyIHRva2VucyA9IGluc3RhbmNlLnRva2VuR2V0QWxsKCc8P3BocCBzb21lIHBocCBjb2RlJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBMaXN0IG9mIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TGV4ZXJ9IGxleGVyXG4gKiBAcHJvcGVydHkge1BhcnNlcn0gcGFyc2VyXG4gKiBAcHJvcGVydHkge0FTVH0gYXN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gdG9rZW5zXG4gKi9cblxuXG52YXIgZW5naW5lID0gZnVuY3Rpb24gZW5naW5lKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB0aGlzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgdGhpcy5sZXhlciA9IG5ldyBsZXhlcih0aGlzKTtcbiAgdGhpcy5hc3QgPSBuZXcgQVNUKCk7XG4gIHRoaXMucGFyc2VyID0gbmV3IHBhcnNlcih0aGlzLmxleGVyLCB0aGlzLmFzdCk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgX3R5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgIC8vIGRpc2FibGUgcGhwNyBmcm9tIGxleGVyIGlmIGFscmVhZHkgZGlzYWJsZWQgZnJvbSBwYXJzZXJcbiAgICBpZiAob3B0aW9ucy5wYXJzZXIpIHtcbiAgICAgIGlmICghb3B0aW9ucy5sZXhlcikge1xuICAgICAgICBvcHRpb25zLmxleGVyID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlci52ZXJzaW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJzZXIudmVyc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gb3B0aW9ucy5wYXJzZXIudmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgICAgICAgdmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25bMF0pICogMTAwICsgcGFyc2VJbnQodmVyc2lvblsxXSk7XG5cbiAgICAgICAgICBpZiAoaXNOYU4odmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2ZXJzaW9uIG51bWJlciA6IFwiICsgb3B0aW9ucy5wYXJzZXIudmVyc2lvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyc2VyLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJzZXIudmVyc2lvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhIG51bWJlciBmb3IgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcnNlci52ZXJzaW9uIDwgNTAwIHx8IG9wdGlvbnMucGFyc2VyLnZlcnNpb24gPiA3MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBoYW5kbGUgdmVyc2lvbnMgYmV0d2VlbiA1LnggdG8gNy54XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tYmluZShvcHRpb25zLCB0aGlzKTsgLy8gc2FtZSB2ZXJzaW9uIGZsYWdzIGJhc2VkIG9uIHBhcnNlciBvcHRpb25zXG5cbiAgICB0aGlzLmxleGVyLnZlcnNpb24gPSB0aGlzLnBhcnNlci52ZXJzaW9uO1xuICB9XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5weXQgaXMgYSBidWZmZXIgb3IgYSBzdHJpbmdcbiAqIEBwYXJhbSAge0J1ZmZlcnxTdHJpbmd9IGJ1ZmZlciBJbnB1dCB2YWx1ZSB0aGF0IGNhbiBiZSBlaXRoZXIgYSBidWZmZXIgb3IgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gICBSZXR1cm5zIHRoZSBzdHJpbmcgZnJvbSBpbnB1dFxuICovXG5cblxudmFyIGdldFN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uIGdldFN0cmluZ0J1ZmZlcihidWZmZXIpIHtcbiAgcmV0dXJuIHR5cGVvZiBidWZmZXIud3JpdGUgPT09IFwiZnVuY3Rpb25cIiA/IGJ1ZmZlci50b1N0cmluZygpIDogYnVmZmVyO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSAoSGVscGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VuZ2luZX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5lbmdpbmUuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBlbmdpbmUob3B0aW9ucyk7XG59O1xuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgYnVmZmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZW5naW5lLnBhcnNlRXZhbCA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi5wYXJzZUV2YWwoYnVmZmVyKTtcbn07XG4vKipcbiAqIFBhcnNlIGFuIGV2YWx1YXRpbmcgbW9kZSBzdHJpbmcgKG5vIG5lZWQgdG8gb3BlbiBwaHAgdGFncylcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXJcbiAqIEByZXR1cm4ge1Byb2dyYW19XG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnBhcnNlRXZhbCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5sZXhlci5tb2RlX2V2YWwgPSB0cnVlO1xuICB0aGlzLmxleGVyLmFsbF90b2tlbnMgPSBmYWxzZTtcbiAgYnVmZmVyID0gZ2V0U3RyaW5nQnVmZmVyKGJ1ZmZlcik7XG4gIHJldHVybiB0aGlzLnBhcnNlci5wYXJzZShidWZmZXIsIFwiZXZhbFwiKTtcbn07XG4vKipcbiAqIFN0YXRpYyBmdW5jdGlvbiB0aGF0IHBhcnNlIGEgcGhwIGNvZGUgd2l0aCBvcGVuL2Nsb3NlIHRhZ3NcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5lbmdpbmUucGFyc2VDb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKF90eXBlb2YoZmlsZW5hbWUpID09PSBcIm9iamVjdFwiICYmICFvcHRpb25zKSB7XG4gICAgLy8gcmV0cm8tY29tcGF0aWJpbGl0eVxuICAgIG9wdGlvbnMgPSBmaWxlbmFtZTtcbiAgICBmaWxlbmFtZSA9IFwidW5rbm93blwiO1xuICB9XG5cbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi5wYXJzZUNvZGUoYnVmZmVyLCBmaWxlbmFtZSk7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHBhcnNlIGEgcGhwIGNvZGUgd2l0aCBvcGVuL2Nsb3NlIHRhZ3NcbiAqXG4gKiBTYW1wbGUgY29kZSA6XG4gKiBgYGBwaHBcbiAqIDw/cGhwICR4ID0gMTtcbiAqIGBgYFxuICpcbiAqIFVzYWdlIDpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyc2VyID0gcmVxdWlyZSgncGhwLXBhcnNlcicpO1xuICogdmFyIHBocFBhcnNlciA9IG5ldyBwYXJzZXIoe1xuICogICAvLyBzb21lIG9wdGlvbnNcbiAqIH0pO1xuICogdmFyIGFzdCA9IHBocFBhcnNlci5wYXJzZUNvZGUoJy4uLnBocCBjb2RlLi4uJywgJ2Zvby5waHAnKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAtIFRoZSBjb2RlIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWVcbiAqIEByZXR1cm4ge1Byb2dyYW19XG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnBhcnNlQ29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIGZpbGVuYW1lKSB7XG4gIHRoaXMubGV4ZXIubW9kZV9ldmFsID0gZmFsc2U7XG4gIHRoaXMubGV4ZXIuYWxsX3Rva2VucyA9IGZhbHNlO1xuICBidWZmZXIgPSBnZXRTdHJpbmdCdWZmZXIoYnVmZmVyKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlKGJ1ZmZlciwgZmlsZW5hbWUpO1xufTtcbi8qKlxuICogU3BsaXQgdGhlIGJ1ZmZlciBpbnRvIHRva2Vuc1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmVuZ2luZS50b2tlbkdldEFsbCA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi50b2tlbkdldEFsbChidWZmZXIpO1xufTtcbi8qKlxuICogRXh0cmFjdCB0b2tlbnMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqID4gTm90ZSB0aGF0IHRoZSBvdXRwdXQgdG9rZW5zIGFyZSAqU1RSSUNMWSogc2ltaWxhciB0byBQSFAgZnVuY3Rpb24gYHRva2VuX2dldF9hbGxgXG4gKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBFYWNoIGl0ZW0gY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IHdpdGggZm9sbG93aW5nIGluZm9ybWF0aW9ucyBbdG9rZW5fbmFtZSwgdGV4dCwgbGluZV9udW1iZXJdXG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnRva2VuR2V0QWxsID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLmxleGVyLm1vZGVfZXZhbCA9IGZhbHNlO1xuICB0aGlzLmxleGVyLmFsbF90b2tlbnMgPSB0cnVlO1xuICBidWZmZXIgPSBnZXRTdHJpbmdCdWZmZXIoYnVmZmVyKTtcbiAgdmFyIEVPRiA9IHRoaXMubGV4ZXIuRU9GO1xuICB2YXIgbmFtZXMgPSB0aGlzLnRva2Vucy52YWx1ZXM7XG4gIHRoaXMubGV4ZXIuc2V0SW5wdXQoYnVmZmVyKTtcbiAgdmFyIHRva2VuID0gdGhpcy5sZXhlci5sZXgoKSB8fCBFT0Y7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAodG9rZW4gIT0gRU9GKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5sZXhlci55eXRleHQ7XG5cbiAgICBpZiAobmFtZXMuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICBlbnRyeSA9IFtuYW1lc1t0b2tlbl0sIGVudHJ5LCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lXTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgdG9rZW4gPSB0aGlzLmxleGVyLmxleCgpIHx8IEVPRjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyBleHBvcnRzIHRoZSBmdW5jdGlvblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lOyAvLyBtYWtlcyBsaWJyYXJpZXMgcHVibGljXG5cbm1vZHVsZS5leHBvcnRzLnRva2VucyA9IHRva2Vucztcbm1vZHVsZS5leHBvcnRzLmxleGVyID0gbGV4ZXI7XG5tb2R1bGUuZXhwb3J0cy5BU1QgPSBBU1Q7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5tb2R1bGUuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTsgLy8gYWxsb3cgdGhlIGRlZmF1bHQgZXhwb3J0IGluIGluZGV4LmQudHNcblxubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZW5naW5lO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgcGhwIGxleGVyLiBJdCB3aWxsIHRva2VuaXplIHRoZSBzdHJpbmcgZm9yIGhlbHBpbmcgdGhlXG4gKiBwYXJzZXIgdG8gYnVpbGQgdGhlIEFTVCBmcm9tIGl0cyBncmFtbWFyLlxuICpcbiAqIEBjbGFzc1xuICogQHByb3BlcnR5IHtJbnRlZ2VyfSBFT0ZcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYWxsX3Rva2VucyBkZWZpbmVzIGlmIGFsbCB0b2tlbnMgbXVzdCBiZSByZXRyaWV2ZWQgKHVzZWQgYnkgdG9rZW5fZ2V0X2FsbCBvbmx5KVxuICogQHByb3BlcnR5IHtCb29sZWFufSBjb21tZW50X3Rva2VucyBleHRyYWN0cyBjb21tZW50cyB0b2tlbnNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW9kZV9ldmFsIGVuYWJsZXMgdGhlIGV2YWxkIG1vZGUgKGlnbm9yZSBvcGVuaW5nIHRhZ3MpXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGFzcF90YWdzIGRpc2FibGVzIGJ5IGRlZmF1bHQgYXNwIHRhZ3MgbW9kZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBzaG9ydF90YWdzIGVuYWJsZXMgYnkgZGVmYXVsdCBzaG9ydCB0YWdzIG1vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBrZXl3b3JkcyBMaXN0IG9mIHBocCBrZXl3b3JkXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FzdEtleXdvcmRzIExpc3Qgb2YgcGhwIGtleXdvcmRzIGZvciB0eXBlIGNhc3RpbmdcbiAqL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBsZXhlciA9IGZ1bmN0aW9uIGxleGVyKGVuZ2luZSkge1xuICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgdGhpcy50b2sgPSB0aGlzLmVuZ2luZS50b2tlbnMubmFtZXM7XG4gIHRoaXMuRU9GID0gMTtcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICB0aGlzLmFsbF90b2tlbnMgPSB0cnVlO1xuICB0aGlzLmNvbW1lbnRfdG9rZW5zID0gZmFsc2U7XG4gIHRoaXMubW9kZV9ldmFsID0gZmFsc2U7XG4gIHRoaXMuYXNwX3RhZ3MgPSBmYWxzZTtcbiAgdGhpcy5zaG9ydF90YWdzID0gZmFsc2U7XG4gIHRoaXMudmVyc2lvbiA9IDcwNDtcbiAgdGhpcy55eXByZXZjb2wgPSAwO1xuICB0aGlzLmtleXdvcmRzID0ge1xuICAgIF9fY2xhc3NfXzogdGhpcy50b2suVF9DTEFTU19DLFxuICAgIF9fdHJhaXRfXzogdGhpcy50b2suVF9UUkFJVF9DLFxuICAgIF9fZnVuY3Rpb25fXzogdGhpcy50b2suVF9GVU5DX0MsXG4gICAgX19tZXRob2RfXzogdGhpcy50b2suVF9NRVRIT0RfQyxcbiAgICBfX2xpbmVfXzogdGhpcy50b2suVF9MSU5FLFxuICAgIF9fZmlsZV9fOiB0aGlzLnRvay5UX0ZJTEUsXG4gICAgX19kaXJfXzogdGhpcy50b2suVF9ESVIsXG4gICAgX19uYW1lc3BhY2VfXzogdGhpcy50b2suVF9OU19DLFxuICAgIGV4aXQ6IHRoaXMudG9rLlRfRVhJVCxcbiAgICBkaWU6IHRoaXMudG9rLlRfRVhJVCxcbiAgICBcImZ1bmN0aW9uXCI6IHRoaXMudG9rLlRfRlVOQ1RJT04sXG4gICAgXCJjb25zdFwiOiB0aGlzLnRvay5UX0NPTlNULFxuICAgIFwicmV0dXJuXCI6IHRoaXMudG9rLlRfUkVUVVJOLFxuICAgIFwidHJ5XCI6IHRoaXMudG9rLlRfVFJZLFxuICAgIFwiY2F0Y2hcIjogdGhpcy50b2suVF9DQVRDSCxcbiAgICBcImZpbmFsbHlcIjogdGhpcy50b2suVF9GSU5BTExZLFxuICAgIFwidGhyb3dcIjogdGhpcy50b2suVF9USFJPVyxcbiAgICBcImlmXCI6IHRoaXMudG9rLlRfSUYsXG4gICAgZWxzZWlmOiB0aGlzLnRvay5UX0VMU0VJRixcbiAgICBlbmRpZjogdGhpcy50b2suVF9FTkRJRixcbiAgICBcImVsc2VcIjogdGhpcy50b2suVF9FTFNFLFxuICAgIFwid2hpbGVcIjogdGhpcy50b2suVF9XSElMRSxcbiAgICBlbmR3aGlsZTogdGhpcy50b2suVF9FTkRXSElMRSxcbiAgICBcImRvXCI6IHRoaXMudG9rLlRfRE8sXG4gICAgXCJmb3JcIjogdGhpcy50b2suVF9GT1IsXG4gICAgZW5kZm9yOiB0aGlzLnRvay5UX0VOREZPUixcbiAgICBmb3JlYWNoOiB0aGlzLnRvay5UX0ZPUkVBQ0gsXG4gICAgZW5kZm9yZWFjaDogdGhpcy50b2suVF9FTkRGT1JFQUNILFxuICAgIGRlY2xhcmU6IHRoaXMudG9rLlRfREVDTEFSRSxcbiAgICBlbmRkZWNsYXJlOiB0aGlzLnRvay5UX0VORERFQ0xBUkUsXG4gICAgXCJpbnN0YW5jZW9mXCI6IHRoaXMudG9rLlRfSU5TVEFOQ0VPRixcbiAgICBhczogdGhpcy50b2suVF9BUyxcbiAgICBcInN3aXRjaFwiOiB0aGlzLnRvay5UX1NXSVRDSCxcbiAgICBlbmRzd2l0Y2g6IHRoaXMudG9rLlRfRU5EU1dJVENILFxuICAgIFwiY2FzZVwiOiB0aGlzLnRvay5UX0NBU0UsXG4gICAgXCJkZWZhdWx0XCI6IHRoaXMudG9rLlRfREVGQVVMVCxcbiAgICBcImJyZWFrXCI6IHRoaXMudG9rLlRfQlJFQUssXG4gICAgXCJjb250aW51ZVwiOiB0aGlzLnRvay5UX0NPTlRJTlVFLFxuICAgIFwiZ290b1wiOiB0aGlzLnRvay5UX0dPVE8sXG4gICAgZWNobzogdGhpcy50b2suVF9FQ0hPLFxuICAgIHByaW50OiB0aGlzLnRvay5UX1BSSU5ULFxuICAgIFwiY2xhc3NcIjogdGhpcy50b2suVF9DTEFTUyxcbiAgICBcImludGVyZmFjZVwiOiB0aGlzLnRvay5UX0lOVEVSRkFDRSxcbiAgICB0cmFpdDogdGhpcy50b2suVF9UUkFJVCxcbiAgICBcImV4dGVuZHNcIjogdGhpcy50b2suVF9FWFRFTkRTLFxuICAgIFwiaW1wbGVtZW50c1wiOiB0aGlzLnRvay5UX0lNUExFTUVOVFMsXG4gICAgXCJuZXdcIjogdGhpcy50b2suVF9ORVcsXG4gICAgY2xvbmU6IHRoaXMudG9rLlRfQ0xPTkUsXG4gICAgXCJ2YXJcIjogdGhpcy50b2suVF9WQVIsXG4gICAgZXZhbDogdGhpcy50b2suVF9FVkFMLFxuICAgIGluY2x1ZGU6IHRoaXMudG9rLlRfSU5DTFVERSxcbiAgICBpbmNsdWRlX29uY2U6IHRoaXMudG9rLlRfSU5DTFVERV9PTkNFLFxuICAgIHJlcXVpcmU6IHRoaXMudG9rLlRfUkVRVUlSRSxcbiAgICByZXF1aXJlX29uY2U6IHRoaXMudG9rLlRfUkVRVUlSRV9PTkNFLFxuICAgIG5hbWVzcGFjZTogdGhpcy50b2suVF9OQU1FU1BBQ0UsXG4gICAgdXNlOiB0aGlzLnRvay5UX1VTRSxcbiAgICBpbnN0ZWFkb2Y6IHRoaXMudG9rLlRfSU5TVEVBRE9GLFxuICAgIGdsb2JhbDogdGhpcy50b2suVF9HTE9CQUwsXG4gICAgaXNzZXQ6IHRoaXMudG9rLlRfSVNTRVQsXG4gICAgZW1wdHk6IHRoaXMudG9rLlRfRU1QVFksXG4gICAgX19oYWx0X2NvbXBpbGVyOiB0aGlzLnRvay5UX0hBTFRfQ09NUElMRVIsXG4gICAgXCJzdGF0aWNcIjogdGhpcy50b2suVF9TVEFUSUMsXG4gICAgXCJhYnN0cmFjdFwiOiB0aGlzLnRvay5UX0FCU1RSQUNULFxuICAgIFwiZmluYWxcIjogdGhpcy50b2suVF9GSU5BTCxcbiAgICBcInByaXZhdGVcIjogdGhpcy50b2suVF9QUklWQVRFLFxuICAgIFwicHJvdGVjdGVkXCI6IHRoaXMudG9rLlRfUFJPVEVDVEVELFxuICAgIFwicHVibGljXCI6IHRoaXMudG9rLlRfUFVCTElDLFxuICAgIHVuc2V0OiB0aGlzLnRvay5UX1VOU0VULFxuICAgIGxpc3Q6IHRoaXMudG9rLlRfTElTVCxcbiAgICBhcnJheTogdGhpcy50b2suVF9BUlJBWSxcbiAgICBjYWxsYWJsZTogdGhpcy50b2suVF9DQUxMQUJMRSxcbiAgICBvcjogdGhpcy50b2suVF9MT0dJQ0FMX09SLFxuICAgIGFuZDogdGhpcy50b2suVF9MT0dJQ0FMX0FORCxcbiAgICB4b3I6IHRoaXMudG9rLlRfTE9HSUNBTF9YT1JcbiAgfTtcbiAgdGhpcy5jYXN0S2V5d29yZHMgPSB7XG4gICAgXCJpbnRcIjogdGhpcy50b2suVF9JTlRfQ0FTVCxcbiAgICBpbnRlZ2VyOiB0aGlzLnRvay5UX0lOVF9DQVNULFxuICAgIHJlYWw6IHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsXG4gICAgXCJkb3VibGVcIjogdGhpcy50b2suVF9ET1VCTEVfQ0FTVCxcbiAgICBcImZsb2F0XCI6IHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsXG4gICAgc3RyaW5nOiB0aGlzLnRvay5UX1NUUklOR19DQVNULFxuICAgIGJpbmFyeTogdGhpcy50b2suVF9TVFJJTkdfQ0FTVCxcbiAgICBhcnJheTogdGhpcy50b2suVF9BUlJBWV9DQVNULFxuICAgIG9iamVjdDogdGhpcy50b2suVF9PQkpFQ1RfQ0FTVCxcbiAgICBib29sOiB0aGlzLnRvay5UX0JPT0xfQ0FTVCxcbiAgICBcImJvb2xlYW5cIjogdGhpcy50b2suVF9CT09MX0NBU1QsXG4gICAgdW5zZXQ6IHRoaXMudG9rLlRfVU5TRVRfQ0FTVFxuICB9O1xufTtcbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGV4ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0XG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5zaXplID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnl5bGluZW5vID0gMTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLnl5cHJldmNvbCA9IDA7XG4gIHRoaXMueXl0ZXh0ID0gXCJcIjtcbiAgdGhpcy55eWxsb2MgPSB7XG4gICAgZmlyc3Rfb2Zmc2V0OiAwLFxuICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgZmlyc3RfY29sdW1uOiAwLFxuICAgIHByZXZfb2Zmc2V0OiAwLFxuICAgIHByZXZfbGluZTogMSxcbiAgICBwcmV2X2NvbHVtbjogMCxcbiAgICBsYXN0X2xpbmU6IDEsXG4gICAgbGFzdF9jb2x1bW46IDBcbiAgfTtcbiAgdGhpcy50b2tlbnMgPSBbXTtcblxuICBpZiAodGhpcy52ZXJzaW9uID4gNzAzKSB7XG4gICAgdGhpcy5rZXl3b3Jkcy5mbiA9IHRoaXMudG9rLlRfRk47XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMua2V5d29yZHMuZm47XG4gIH1cblxuICB0aGlzLmRvbmUgPSB0aGlzLm9mZnNldCA+PSB0aGlzLnNpemU7XG5cbiAgaWYgKCF0aGlzLmFsbF90b2tlbnMgJiYgdGhpcy5tb2RlX2V2YWwpIHtcbiAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gW1wiSU5JVElBTFwiXTtcbiAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbXTtcbiAgICB0aGlzLmJlZ2luKFwiSU5JVElBTFwiKTtcbiAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi85OTllMzJiNjVhOGE0YmI1OWUyN2U1MzhmYTY4ZmZhZTRiOTlkODYzL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmgjTDU5XG4gIC8vIFVzZWQgZm9yIGhlcmVkb2MgYW5kIG5vd2RvY1xuXG5cbiAgdGhpcy5oZXJlZG9jX2xhYmVsID0ge1xuICAgIGxhYmVsOiBcIlwiLFxuICAgIGxlbmd0aDogMCxcbiAgICBpbmRlbnRhdGlvbjogMCxcbiAgICBpbmRlbnRhdGlvbl91c2VzX3NwYWNlczogZmFsc2UsXG4gICAgZmluaXNoZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhpcyB1c2VkIGZvciBwYXJzZXIgdG8gZGV0ZW1pbmUgdGhlIGlmIGN1cnJlbnQgbm9kZSBzZWdtZW50IGlzIGZpcnN0IGVuY2FwcyBub2RlLlxuICAgICAqIGlmIHR1cmUsIHRoZSBpbmRlbnRhdGlvbiB3aWxsIHJlbW92ZSBmcm9tIHRoZSBiZWdpbmluZy4gYW5kIGlmIGZhbHNlLCB0aGUgcHJldiBub2RlXG4gICAgICogbWlnaHQgYmUgYSB2YXJpYWJsZSAnfScgLGFuZCB0aGUgbGVhZGluZyBzcGFjZXMgc2hvdWxkIG5vdCBiZSByZW1vdmVkIHV0aWwgbWVldCB0aGVcbiAgICAgKiBmaXJzdCBcXG5cbiAgICAgKi9cbiAgICBmaXJzdF9lbmNhcHNfbm9kZTogZmFsc2UsXG4gICAgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGlibGVcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB0aGlzLmxhYmVsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuICovXG5cblxubGV4ZXIucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG4gIGlmICghY2gpIHJldHVybiBcIlwiO1xuICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgdGhpcy5vZmZzZXQrKztcblxuICBpZiAoY2ggPT09IFwiXFxyXCIgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIlxcblwiKSB7XG4gICAgdGhpcy55eXRleHQgKz0gXCJcXG5cIjtcbiAgICB0aGlzLm9mZnNldCsrO1xuICB9XG5cbiAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gKyt0aGlzLnl5bGluZW5vO1xuICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gIH1cblxuICByZXR1cm4gY2g7XG59O1xuLyoqXG4gKiByZXZlcnQgZWF0aW5nIHNwZWNpZmllZCBzaXplXG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUudW5wdXQgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgIC8vIDEgY2hhciB1bnB1dCAobW9zdCBjYXNlcylcbiAgICB0aGlzLm9mZnNldC0tO1xuXG4gICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCJcXG5cIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdID09PSBcIlxcclwiKSB7XG4gICAgICB0aGlzLm9mZnNldC0tO1xuICAgICAgc2l6ZSsrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiXFxyXCIgfHwgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUtLTtcbiAgICAgIHRoaXMueXlsaW5lbm8tLTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eXByZXZjb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLS07XG4gICAgfVxuXG4gICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHJpbmcoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gc2l6ZSk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA+IDApIHtcbiAgICB0aGlzLm9mZnNldCAtPSBzaXplO1xuXG4gICAgaWYgKHNpemUgPCB0aGlzLnl5dGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyaW5nKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIHNpemUpOyAvLyByZS1jYWxjdWxhdGUgcG9zaXRpb25cblxuICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eXByZXZjb2wgPSB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55eXRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnl5dGV4dFtpXTtcblxuICAgICAgICBpZiAoYyA9PT0gXCJcXHJcIikge1xuICAgICAgICAgIGMgPSB0aGlzLnl5dGV4dFsrK2ldO1xuICAgICAgICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuXG4gICAgICAgICAgaWYgKGMgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgZnVsbCB0ZXh0XG4gICAgICB0aGlzLnl5dGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTsgLy8gY2hlY2sgaWYgdGhlIHRleHQgbWF0Y2hlc1xuXG5cbmxleGVyLnByb3RvdHlwZS50cnlNYXRjaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID09PSB0aGlzLmFoZWFkKHRleHQubGVuZ3RoKTtcbn07IC8vIGNoZWNrIGlmIHRoZSB0ZXh0IG1hdGNoZXNcblxuXG5sZXhlci5wcm90b3R5cGUudHJ5TWF0Y2hDYXNlbGVzcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID09PSB0aGlzLmFoZWFkKHRleHQubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xufTsgLy8gbG9vayBhaGVhZFxuXG5cbmxleGVyLnByb3RvdHlwZS5haGVhZCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHZhciB0ZXh0ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIHNpemUpO1xuXG4gIGlmICh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09IFwiXFxyXCIgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgKyBzaXplICsgMV0gPT09IFwiXFxuXCIpIHtcbiAgICB0ZXh0ICs9IFwiXFxuXCI7XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn07IC8vIGNvbnN1bWUgdGhlIHNwZWNpZmllZCBzaXplXG5cblxubGV4ZXIucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcbiAgICBpZiAoIWNoKSBicmVhaztcbiAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICB0aGlzLm9mZnNldCsrO1xuXG4gICAgaWYgKGNoID09PSBcIlxcclwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCJcXG5cIikge1xuICAgICAgdGhpcy55eXRleHQgKz0gXCJcXG5cIjtcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSArK3RoaXMueXlsaW5lbm87XG4gICAgICB0aGlzLnl5cHJldmNvbCA9IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5cblxubGV4ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICB5eXByZXZjb2w6IHRoaXMueXlwcmV2Y29sLFxuICAgIHl5bGxvYzoge1xuICAgICAgZmlyc3Rfb2Zmc2V0OiB0aGlzLnl5bGxvYy5maXJzdF9vZmZzZXQsXG4gICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICBsYXN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgIH0sXG4gICAgaGVyZWRvY19sYWJlbDogdGhpcy5oZXJlZG9jX2xhYmVsXG4gIH07XG59O1xuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxleGVyIHN0YXRlXG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdGhpcy55eXRleHQgPSBzdGF0ZS55eXRleHQ7XG4gIHRoaXMub2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICB0aGlzLnl5bGluZW5vID0gc3RhdGUueXlsaW5lbm87XG4gIHRoaXMueXlwcmV2Y29sID0gc3RhdGUueXlwcmV2Y29sO1xuICB0aGlzLnl5bGxvYyA9IHN0YXRlLnl5bGxvYztcblxuICBpZiAoc3RhdGUuaGVyZWRvY19sYWJlbCkge1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbCA9IHN0YXRlLmhlcmVkb2NfbGFiZWw7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07IC8vIHByZXBlbmQgbmV4dCB0b2tlblxuXG5cbmxleGVyLnByb3RvdHlwZS5hcHBlbmRUb2tlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgYWhlYWQpIHtcbiAgdGhpcy50b2tlbnMucHVzaChbdmFsdWUsIGFoZWFkXSk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxuXG5cbmxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMueXlsbG9jLnByZXZfb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIHRoaXMueXlsbG9jLnByZXZfbGluZSA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgdGhpcy55eWxsb2MucHJldl9jb2x1bW4gPSB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgdmFyIHRva2VuID0gdGhpcy5uZXh0KCkgfHwgdGhpcy5sZXgoKTtcblxuICBpZiAoIXRoaXMuYWxsX3Rva2Vucykge1xuICAgIHdoaWxlICh0b2tlbiA9PT0gdGhpcy50b2suVF9XSElURVNQQUNFIHx8IC8vIGlnbm9yZSB3aGl0ZSBzcGFjZVxuICAgICF0aGlzLmNvbW1lbnRfdG9rZW5zICYmICh0b2tlbiA9PT0gdGhpcy50b2suVF9DT01NRU5UIHx8IC8vIGlnbm9yZSBzaW5nbGUgbGluZXMgY29tbWVudHNcbiAgICB0b2tlbiA9PT0gdGhpcy50b2suVF9ET0NfQ09NTUVOVCkgfHwgLy8gaWdub3JlIGRvYyBjb21tZW50c1xuICAgIC8vIGlnbm9yZSBvcGVuIHRhZ3NcbiAgICB0b2tlbiA9PT0gdGhpcy50b2suVF9PUEVOX1RBRykge1xuICAgICAgdG9rZW4gPSB0aGlzLm5leHQoKSB8fCB0aGlzLmxleCgpO1xuICAgIH1cblxuICAgIGlmICh0b2tlbiA9PSB0aGlzLnRvay5UX09QRU5fVEFHX1dJVEhfRUNITykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvN2ZmMTg2NDM0ZTgyZWU3YmU3YzU5ZDBkYjlhOTc2NjQxY2Y3YjA5Yy9aZW5kL3plbmRfY29tcGlsZS5jI0wxNjgzXG4gICAgICAvLyBvcGVuIHRhZyB3aXRoIGVjaG8gc3RhdGVtZW50XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FQ0hPO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IHRoaXMudG9rLlRfQ0xPU0VfVEFHKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi83ZmYxODY0MzRlODJlZTdiZTdjNTlkMGRiOWE5NzY2NDFjZjdiMDljL1plbmQvemVuZF9jb21waWxlLmMjTDE2ODBcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICAgIC8qIGltcGxpY2l0IDsgKi9cbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMueXlsbG9jLnByZXZfb2Zmc2V0KSB7XG4gICAgdGhpcy55eWxsb2MucHJldl9vZmZzZXQgPSB0aGlzLnl5bGxvYy5maXJzdF9vZmZzZXQ7XG4gICAgdGhpcy55eWxsb2MucHJldl9saW5lID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X2NvbHVtbiA9IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbjtcbiAgfVxuICAvKmVsc2UgaWYgKHRoaXMueXlsbG9jLnByZXZfb2Zmc2V0ID09PSB0aGlzLm9mZnNldCAmJiB0aGlzLm9mZnNldCAhPT0gdGhpcy5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIEAgJyArIHRoaXMub2Zmc2V0ICsgJyAvICcgKyB0aGlzLnNpemUpO1xuICB9Ki9cblxuXG4gIHJldHVybiB0b2tlbjtcbn07IC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5cblxubGV4ZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgdGhpcy5jdXJDb25kaXRpb24gPSBjb25kaXRpb247XG4gIHRoaXMuc3RhdGVDYiA9IHRoaXNbXCJtYXRjaFwiICsgY29uZGl0aW9uXTtcblxuICBpZiAodHlwZW9mIHRoaXMuc3RhdGVDYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmRlZmluZWQgY29uZGl0aW9uIHN0YXRlIFwiJyArIGNvbmRpdGlvbiArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xuXG5cbmxleGVyLnByb3RvdHlwZS5wb3BTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBjb25kaXRpb24gPSBuID4gMCA/IHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCkgOiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICB0aGlzLmN1ckNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgdGhpcy5zdGF0ZUNiID0gdGhpc1tcIm1hdGNoXCIgKyB0aGlzLmN1ckNvbmRpdGlvbl07XG5cbiAgaWYgKHR5cGVvZiB0aGlzLnN0YXRlQ2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGNvbmRpdGlvbiBzdGF0ZSBcIicgKyB0aGlzLmN1ckNvbmRpdGlvbiArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmRpdGlvbjtcbn07IC8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5cblxubGV4ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbjtcblxuICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMueXlsbG9jLmZpcnN0X29mZnNldCA9IHRoaXMub2Zmc2V0O1xuICB0aGlzLnl5bGxvYy5maXJzdF9saW5lID0gdGhpcy55eWxsb2MubGFzdF9saW5lO1xuICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gPSB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgdGhpcy55eXRleHQgPSBcIlwiO1xuXG4gIGlmICh0aGlzLmRvbmUpIHtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X29mZnNldCA9IHRoaXMueXlsbG9jLmZpcnN0X29mZnNldDtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X2xpbmUgPSB0aGlzLnl5bGxvYy5maXJzdF9saW5lO1xuICAgIHRoaXMueXlsbG9jLnByZXZfY29sdW1uID0gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgIHJldHVybiB0aGlzLkVPRjtcbiAgfVxuXG4gIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgdG9rZW4gPSB0aGlzLnRva2Vucy5zaGlmdCgpO1xuXG4gICAgaWYgKF90eXBlb2YodG9rZW5bMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHRva2VuWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25zdW1lKHRva2VuWzFdKTtcbiAgICB9XG5cbiAgICB0b2tlbiA9IHRva2VuWzBdO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gdGhpcy5zdGF0ZUNiLmFwcGx5KHRoaXMsIFtdKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLnNpemUgJiYgdGhpcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgdmFyIHROYW1lID0gdG9rZW47XG5cbiAgICBpZiAodHlwZW9mIHROYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0TmFtZSA9IHRoaXMuZW5naW5lLnRva2Vucy52YWx1ZXNbdE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0TmFtZSA9ICdcIicgKyB0TmFtZSArICdcIic7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IodE5hbWUgKyBcIlxcdGZyb20gXCIgKyB0aGlzLnl5bGxvYy5maXJzdF9saW5lICsgXCIsXCIgKyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gKyBcIlxcdCAtIHRvIFwiICsgdGhpcy55eWxsb2MubGFzdF9saW5lICsgXCIsXCIgKyB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArICdcXHRcIicgKyB0aGlzLnl5dGV4dCArICdcIicpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07IC8vIGV4dGVuZHMgdGhlIGxleGVyIHdpdGggc3RhdGVzXG5cblxuW19fd2VicGFja19yZXF1aXJlX18oMTQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxNiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyMCksIF9fd2VicGFja19yZXF1aXJlX18oMjEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKV0uZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gIGZvciAodmFyIGsgaW4gZXh0KSB7XG4gICAgbGV4ZXIucHJvdG90eXBlW2tdID0gZXh0W2tdO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gbGV4ZXI7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGEgc2luZ2xlIGxpbmUgY29tbWVudFxuICAgKi9cbiAgVF9DT01NRU5UOiBmdW5jdGlvbiBUX0NPTU1FTlQoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT01NRU5UO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCI/XCIgJiYgIXRoaXMuYXNwVGFnTW9kZSAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPlwiKSB7XG4gICAgICAgIHRoaXMudW5wdXQoMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NPTU1FTlQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIiVcIiAmJiB0aGlzLmFzcFRhZ01vZGUgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLnVucHV0KDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT01NRU5UO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0NPTU1FTlQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJlaGF2aW91ciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2Vfc2Nhbm5lci5sI0wxOTI3XG4gICAqL1xuICBUX0RPQ19DT01NRU5UOiBmdW5jdGlvbiBUX0RPQ19DT01NRU5UKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLnRvay5UX0NPTU1FTlQ7XG5cbiAgICBpZiAoY2ggPT09IFwiKlwiKSB7XG4gICAgICAvLyBzdGFydGVkIHdpdGggJy8qJyAsIGNoZWNrIGlzIG5leHQgaXMgJyonXG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNfV0hJVEVTUEFDRSgpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG5leHQgaXMgV0hJVEVTUEFDRVxuICAgICAgICB0b2tlbiA9IHRoaXMudG9rLlRfRE9DX0NPTU1FTlQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTsgLy8gcmVzZXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT09IFwiKlwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCIvXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmV4dElOSVRJQUw6IGZ1bmN0aW9uIG5leHRJTklUSUFMKCkge1xuICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCA+IDEgJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOSVRJQUxcIikge1xuICAgICAgLy8gUmV0dXJuIHRvIEhFUkVET0MvU1RfRE9VQkxFX1FVT1RFUyBtb2RlXG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmVnaW4oXCJTVF9JTl9TQ1JJUFRJTkdcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1hdGNoSU5JVElBTDogZnVuY3Rpb24gbWF0Y2hJTklUSUFMKCkge1xuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmFoZWFkKDEpO1xuXG4gICAgICAgIGlmIChjaCA9PSBcIj9cIikge1xuICAgICAgICAgIGlmICh0aGlzLnRyeU1hdGNoKFwiPz1cIikpIHtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBR19XSVRIX0VDSE8sIDMpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJ5TWF0Y2hDYXNlbGVzcyhcIj9waHBcIikpIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgKyA0XTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXHRcIiB8fCBjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICB0aGlzLnVucHV0KDEpLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfT1BFTl9UQUcsIDYpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNob3J0X3RhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBRywgMikubmV4dElOSVRJQUwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFzcF90YWdzICYmIGNoID09IFwiJVwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJ5TWF0Y2goXCIlPVwiKSkge1xuICAgICAgICAgICAgdGhpcy5hc3BUYWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBR19XSVRIX0VDSE8sIDMpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3BUYWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBRywgMikubmV4dElOSVRJQUwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9JTkxJTkVfSFRNTDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXG52YXIgTUFYX0xFTkdUSF9PRl9MT05HID0gMTA7XG52YXIgbG9uZ19taW5fZGlnaXRzID0gXCIyMTQ3NDgzNjQ4XCI7XG5cbmlmIChwcm9jZXNzLmFyY2ggPT0gXCJ4NjRcIikge1xuICBNQVhfTEVOR1RIX09GX0xPTkcgPSAxOTtcbiAgbG9uZ19taW5fZGlnaXRzID0gXCI5MjIzMzcyMDM2ODU0Nzc1ODA4XCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdW1lX05VTTogZnVuY3Rpb24gY29uc3VtZV9OVU0oKSB7XG4gICAgdmFyIGNoID0gdGhpcy55eXRleHRbMF07XG4gICAgdmFyIGhhc1BvaW50ID0gY2ggPT09IFwiLlwiO1xuXG4gICAgaWYgKGNoID09PSBcIjBcIikge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7IC8vIGNoZWNrIGlmIGhleGFcblxuICAgICAgaWYgKGNoID09PSBcInhcIiB8fCBjaCA9PT0gXCJYXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoICE9PSBcIl9cIiAmJiB0aGlzLmlzX0hFWCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9ITlVNKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bnB1dChjaCA/IDIgOiAxKTtcbiAgICAgICAgfSAvLyBjaGVjayBiaW5hcnkgbm90YXRpb25cblxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJiXCIgfHwgY2ggPT09IFwiQlwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCAhPT0gXCJfXCIgJiYgY2ggPT09IFwiMFwiIHx8IGNoID09PSBcIjFcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfQk5VTSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5wdXQoY2ggPyAyIDogMSk7XG4gICAgICAgIH0gLy8gQGZpeG1lIGNoZWNrIG9jdGFsIG5vdGF0aW9uID8gbm90IHVzZWZ1bGxcblxuICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19OVU0oKSkge1xuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgcHJldiA9IGNoO1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCJfXCIpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IFwiX1wiKSB7XG4gICAgICAgICAgLy8gcmVzdHJpY3Rpb24gOiBuZXh0IHRvIHVuZGVyc2NvcmUgLyAxX18xO1xuICAgICAgICAgIHRoaXMudW5wdXQoMik7IC8vIGtlZXAgMVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldiA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGRlY2ltYWwgcG9pbnQgIFwiMS5fMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgxKTsgLy8ga2VlcCAxLlxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldiA9PT0gXCJlXCIgfHwgcHJldiA9PT0gXCJFXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGUgXCIxZV8xMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgyKTsgLy8ga2VlcCAxXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIuXCIpIHtcbiAgICAgICAgaWYgKGhhc1BvaW50KSB7XG4gICAgICAgICAgLy8gbm8gbXVsdGlwbGUgcG9pbnRzIFwiMS4wLjVcIlxuICAgICAgICAgIHRoaXMudW5wdXQoMSk7IC8vIGtlZXAgMS4wXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2ID09PSBcIl9cIikge1xuICAgICAgICAgIC8vIG5leHQgdG8gZGVjaW1hbCBwb2ludCAgXCIxXy4wXCJcbiAgICAgICAgICB0aGlzLnVucHV0KDIpOyAvLyBrZWVwIDFcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUG9pbnQgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiZVwiIHx8IGNoID09PSBcIkVcIikge1xuICAgICAgICBpZiAocHJldiA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGUgXCIxX2UxMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmRvID0gMjtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoID09PSBcIitcIiB8fCBjaCA9PT0gXCItXCIpIHtcbiAgICAgICAgICAvLyAxZS01XG4gICAgICAgICAgdW5kbyA9IDM7XG4gICAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc19OVU1fU1RBUlQoKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZV9MTlVNKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE5VTUJFUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5wdXQoY2ggPyB1bmRvIDogdW5kbyAtIDEpOyAvLyBrZWVwIG9ubHkgMVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNfTlVNKCkpIHtcbiAgICAgICAgLy8gZXhhbXBsZSA6IDEwLjBhXG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTsgLy8ga2VlcCAxMC4wXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9ETlVNQkVSO1xuICAgIH0gZWxzZSBpZiAodGhpcy55eXRleHQubGVuZ3RoIDwgTUFYX0xFTkdUSF9PRl9MT05HIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA8IE1BWF9MRU5HVEhfT0ZfTE9ORyB8fCB0aGlzLnl5dGV4dC5sZW5ndGggPT0gTUFYX0xFTkdUSF9PRl9MT05HICYmIHRoaXMueXl0ZXh0IDwgbG9uZ19taW5fZGlnaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0xOVU1CRVI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRvay5UX0ROVU1CRVI7XG4gICAgfVxuICB9LFxuICAvLyByZWFkIGhleGFcbiAgY29uc3VtZV9ITlVNOiBmdW5jdGlvbiBjb25zdW1lX0hOVU0oKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19IRVgoKSkge1xuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0xOVU1CRVI7XG4gIH0sXG4gIC8vIHJlYWQgYSBnZW5lcmljIG51bWJlclxuICBjb25zdW1lX0xOVU06IGZ1bmN0aW9uIGNvbnN1bWVfTE5VTSgpIHtcbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKCF0aGlzLmlzX05VTSgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgfSxcbiAgLy8gcmVhZCBiaW5hcnlcbiAgY29uc3VtZV9CTlVNOiBmdW5jdGlvbiBjb25zdW1lX0JOVU0oKSB7XG4gICAgdmFyIGNoO1xuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoICE9PSBcIjBcIiAmJiBjaCAhPT0gXCIxXCIgJiYgY2ggIT09IFwiX1wiKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgfVxufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hdGNoU1RfTE9PS0lOR19GT1JfUFJPUEVSVFk6IGZ1bmN0aW9uIG1hdGNoU1RfTE9PS0lOR19GT1JfUFJPUEVSVFkoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCI+XCIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEyOTZcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfT0JKRUNUX09QRVJBVE9SO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzX1dISVRFU1BBQ0UoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfV0hJVEVTUEFDRTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEzMDBcbiAgICAgIHRoaXMuY29uc3VtZV9MQUJFTCgpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1RSSU5HO1xuICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEzMDZcblxuXG4gICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIG1hdGNoU1RfTE9PS0lOR19GT1JfVkFSTkFNRTogZnVuY3Rpb24gbWF0Y2hTVF9MT09LSU5HX0ZPUl9WQVJOQU1FKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTsgLy8gU0hJRlQgU1RBVEVcblxuICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIltcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1RSSU5HX1ZBUk5BTUU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbnkgY2hhciAodGhhdCdzIHN0YXJ0ZWQgd2l0aCBhIGxhYmVsIHNlcXVlbmNlKVxuICAgICAgICB0aGlzLnVucHV0KHRoaXMueXl0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFueSBjaGFyICh0aGF0cyBub3QgYSBsYWJlbCBzdGFydCBzZXF1ZW5jZSlcbiAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICB9IC8vIHN0b3BzIGxvb2tpbmcgZm9yIGEgdmFybmFtZSBhbmQgc3RhcnRzIHRoZSBzY3JpcHRpbmcgbW9kZVxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIG1hdGNoU1RfVkFSX09GRlNFVDogZnVuY3Rpb24gbWF0Y2hTVF9WQVJfT0ZGU0VUKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgIGlmICh0aGlzLmlzX05VTV9TVEFSVCgpKSB7XG4gICAgICB0aGlzLmNvbnN1bWVfTlVNKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9OVU1fU1RSSU5HO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXVwiKSB7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gXCJdXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCIkXCIpIHtcbiAgICAgIHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfVkFSSUFCTEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRlcm1pbmFsXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUUklORztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNfV0hJVEVTUEFDRSgpIHx8IGNoID09PSBcIlxcXFxcIiB8fCBjaCA9PT0gXCInXCIgfHwgY2ggPT09IFwiI1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIltcIiB8fCBjaCA9PT0gXCJ7XCIgfHwgY2ggPT09IFwifVwiIHx8IGNoID09PSAnXCInIHx8IGNoID09PSBcImBcIiB8fCB0aGlzLmlzX1RPS0VOKCkpIHtcbiAgICAgIHJldHVybiBjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0ZXJtaW5hbFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2hTVF9JTl9TQ1JJUFRJTkc6IGZ1bmN0aW9uIG1hdGNoU1RfSU5fU0NSSVBUSU5HKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgXCIgXCI6XG4gICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICBjYXNlIFwiXFxyXFxuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLlRfV0hJVEVTUEFDRSgpO1xuXG4gICAgICBjYXNlIFwiI1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5UX0NPTU1FTlQoKTtcblxuICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5UX0NPTU1FTlQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLlRfRE9DX0NPTU1FTlQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfVE9LRU4oKTtcblxuICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkcoKTtcblxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gdGhpcy5TVF9ET1VCTEVfUVVPVEVTKCk7XG5cbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHRoaXMuYmVnaW4oXCJTVF9CQUNLUVVPVEVcIik7XG4gICAgICAgIHJldHVybiBcImBcIjtcblxuICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgaWYgKCF0aGlzLmFzcFRhZ01vZGUgJiYgdGhpcy50cnlNYXRjaChcIj5cIikpIHtcbiAgICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgICAgdmFyIG5leHRDSCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcbiAgICAgICAgICBpZiAobmV4dENIID09PSBcIlxcblwiIHx8IG5leHRDSCA9PT0gXCJcXHJcIikgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIklOSVRJQUxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfQ0xPU0VfVEFHO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9UT0tFTigpO1xuXG4gICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBpZiAodGhpcy5hc3BUYWdNb2RlICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCI+XCIpIHtcbiAgICAgICAgICB0aGlzLmlucHV0KCk7IC8vIGNvbnN1bWUgdGhlICc+J1xuXG4gICAgICAgICAgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07IC8vIHJlYWQgbmV4dFxuXG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0KCk7IC8vIGNvbnN1bWUgdGhlIG5ld2xpbmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFzcFRhZ01vZGUgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJJTklUSUFMXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NMT1NFX1RBRztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfVE9LRU4oKTtcblxuICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgdGhpcy5iZWdpbihcIlNUX0lOX1NDUklQVElOR1wiKTtcbiAgICAgICAgcmV0dXJuIFwie1wiO1xuXG4gICAgICBjYXNlIFwifVwiOlxuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRvIEhFUkVET0MvU1RfRE9VQkxFX1FVT1RFUyBtb2RlXG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwifVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2ggPT09IFwiLlwiKSB7XG4gICAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19OVU1fU1RBUlQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9OVU0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzX05VTV9TVEFSVCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9OVU0oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lX0xBQkVMKCkuVF9TVFJJTkcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX1RPS0VOKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lX1RPS0VOKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHRlcm1pbmFsIHNlcXVlbmNlIFwiJyArIGNoICsgJ1wiIGF0IGxpbmUgJyArIHRoaXMueXlsaW5lbm8gKyBcIiAob2Zmc2V0IFwiICsgdGhpcy5vZmZzZXQgKyBcIilcIik7XG4gIH0sXG4gIFRfV0hJVEVTUEFDRTogZnVuY3Rpb24gVF9XSElURVNQQUNFKCkge1xuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT09IFwiIFwiIHx8IGNoID09PSBcIlxcdFwiIHx8IGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9XSElURVNQQUNFO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIG5ld2xpbmUgPSBbXCJcXG5cIiwgXCJcXHJcIl07XG52YXIgdmFsaWRfYWZ0ZXJfaGVyZWRvYyA9IFtcIlxcblwiLCBcIlxcclwiLCBcIjtcIl07XG52YXIgdmFsaWRfYWZ0ZXJfaGVyZWRvY183MyA9IHZhbGlkX2FmdGVyX2hlcmVkb2MuY29uY2F0KFtcIlxcdFwiLCBcIiBcIiwgXCIsXCIsIFwiXVwiLCBcIilcIiwgXCIvXCIsIFwiPVwiLCBcIiFcIl0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HOiBmdW5jdGlvbiBUX0NPTlNUQU5UX0VOQ0FQU0VEX1NUUklORygpIHtcbiAgICB2YXIgY2g7XG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIidcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIG1hdGNoaW5nIGEgSEVSRURPQyBzdGF0ZVxuICBpc19IRVJFRE9DOiBmdW5jdGlvbiBpc19IRVJFRE9DKCkge1xuICAgIHZhciByZXZlcnQgPSB0aGlzLm9mZnNldDtcblxuICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdID09PSBcIjxcIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPFwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV0gPT09IFwiPFwiKSB7XG4gICAgICB0aGlzLm9mZnNldCArPSAzOyAvLyBvcHRpb25hbCB0YWJzIC8gc3BhY2VzXG5cbiAgICAgIGlmICh0aGlzLmlzX1RBQlNQQUNFKCkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcblxuICAgICAgICAgIGlmICghdGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3B0aW9uYWwgcXVvdGVzXG5cblxuICAgICAgdmFyIHRDaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcblxuICAgICAgaWYgKHRDaGFyID09PSBcIidcIiB8fCB0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdENoYXIgPSBudWxsO1xuICAgICAgfSAvLyByZXF1aXJlZCBsYWJlbFxuXG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSAxO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNfTEFCRUwoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHl5bGFiZWwgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoeXlvZmZzZXQsIHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgaWYgKCF0Q2hhciB8fCB0Q2hhciA9PT0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXSkge1xuICAgICAgICAgIC8vIHJlcXVpcmVkIGVuZGluZyBxdW90ZVxuICAgICAgICAgIGlmICh0Q2hhcikgdGhpcy5vZmZzZXQrKzsgLy8gcmVxdWlyZSBuZXdsaW5lXG5cbiAgICAgICAgICBpZiAobmV3bGluZS5pbmNsdWRlcyh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdKSkge1xuICAgICAgICAgICAgLy8gZ28gZ28gZ29cbiAgICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5sYWJlbCA9IHl5bGFiZWw7XG4gICAgICAgICAgICB0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoID0geXlsYWJlbC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmhlcmVkb2NfbGFiZWwuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSByZXZlcnQ7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHJldmVydDtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSh5eW9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmICh0Q2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIlNUX05PV0RPQ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJTVF9IRVJFRE9DXCIpO1xuICAgICAgICAgICAgfSAvLyBwcmVtYXRjaCB0byBnZXQgdGhlIGluZGVudGF0aW9uIGluZm9ybWF0aW9uIGZyb20gZW5kIG9mIGRvY1xuXG5cbiAgICAgICAgICAgIHRoaXMucHJlbWF0Y2hfRU5ET0ZET0MoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQgPSByZXZlcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBTVF9ET1VCTEVfUVVPVEVTOiBmdW5jdGlvbiBTVF9ET1VCTEVfUVVPVEVTKCkge1xuICAgIHZhciBjaDtcblxuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09ICdcIicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCA9PSBcIntcIiB8fCB0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSAxO1xuXG4gICAgICBpZiAodGhpcy55eXRleHRbMF0gPT09IFwiYlwiIHx8IHRoaXMueXl0ZXh0WzBdID09PSBcIkJcIikge1xuICAgICAgICBwcmVmaXggPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0UsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIHByZWZpeCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5wdXQodGhpcy55eXRleHQubGVuZ3RoIC0gcHJlZml4KTtcbiAgICAgIHRoaXMuYmVnaW4oXCJTVF9ET1VCTEVfUVVPVEVTXCIpO1xuICAgICAgcmV0dXJuIHRoaXMueXl0ZXh0O1xuICAgIH1cbiAgfSxcbiAgLy8gY2hlY2sgaWYgaXRzIGEgRE9DIGVuZCBzZXF1ZW5jZVxuICBpc0RPQ19NQVRDSDogZnVuY3Rpb24gaXNET0NfTUFUQ0gob2Zmc2V0LCBjb25zdW1lTGVhZGluZ1NwYWNlcykge1xuICAgIC8vIEBmaXhtZSA6IGNoZWNrIGlmIG91dCBvZiB0ZXh0IGxpbWl0c1xuICAgIC8vIGNvbnN1bWVMZWFkaW5nU3BhY2VzIGlzIGZhbHNlIGhhcHBlbiBET0MgcHJlbWF0Y2ggRU5EIEhFUkVET0Mgc3RhZ2UuXG4gICAgLy8gRW5zdXJlIGN1cnJlbnQgc3RhdGUgaXMgcmVhbGx5IGFmdGVyIGEgbmV3IGxpbmUgYnJlYWssIG5vdCBhZnRlciBhIHN1Y2ggYXMgJHt2YXJpYWJsZXN9XG4gICAgdmFyIHByZXZfY2ggPSB0aGlzLl9pbnB1dFtvZmZzZXQgLSAyXTtcblxuICAgIGlmICghbmV3bGluZS5pbmNsdWRlcyhwcmV2X2NoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gc2tpcCBsZWFkaW5nIHNwYWNlcyBvciB0YWJzXG5cblxuICAgIHZhciBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGZhbHNlO1xuICAgIHZhciBpbmRlbnRhdGlvbl91c2VzX3RhYnMgPSBmYWxzZTsgLy8gcmVzZXQgaGVyZWRvY19sYWJlbCBzdHJ1Y3R1cmVcblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gICAgdmFyIGxlYWRpbmdfY2ggPSB0aGlzLl9pbnB1dFtvZmZzZXQgLSAxXTtcblxuICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzAzKSB7XG4gICAgICB3aGlsZSAobGVhZGluZ19jaCA9PT0gXCJcXHRcIiB8fCBsZWFkaW5nX2NoID09PSBcIiBcIikge1xuICAgICAgICBpZiAobGVhZGluZ19jaCA9PT0gXCIgXCIpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGVhZGluZ19jaCA9PT0gXCJcXHRcIikge1xuICAgICAgICAgIGluZGVudGF0aW9uX3VzZXNfdGFicyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZWFkaW5nX2NoID0gdGhpcy5faW5wdXRbb2Zmc2V0ICsgaW5kZW50YXRpb25dO1xuICAgICAgICBpbmRlbnRhdGlvbisrO1xuICAgICAgfSAvLyBNb3ZlIG9mZnNldCB0byBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZVxuXG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGluZGVudGF0aW9uOyAvLyByZXR1cm4gb3V0IGlmIHRoZXJlIHdhcyBvbmx5IHdoaXRlc3BhY2Ugb24gdGhpcyBsaW5lXG5cbiAgICAgIGlmIChuZXdsaW5lLmluY2x1ZGVzKHRoaXMuX2lucHV0W29mZnNldCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnN1YnN0cmluZyhvZmZzZXQgLSAxLCBvZmZzZXQgLSAxICsgdGhpcy5oZXJlZG9jX2xhYmVsLmxlbmd0aCkgPT09IHRoaXMuaGVyZWRvY19sYWJlbC5sYWJlbCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbb2Zmc2V0IC0gMSArIHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGhdO1xuXG4gICAgICBpZiAoKHRoaXMudmVyc2lvbiA+PSA3MDMgPyB2YWxpZF9hZnRlcl9oZXJlZG9jXzczIDogdmFsaWRfYWZ0ZXJfaGVyZWRvYykuaW5jbHVkZXMoY2gpKSB7XG4gICAgICAgIGlmIChjb25zdW1lTGVhZGluZ1NwYWNlcykge1xuICAgICAgICAgIHRoaXMuY29uc3VtZShpbmRlbnRhdGlvbik7IC8vIGh0dHBzOi8vd2lraS5waHAubmV0L3JmYy9mbGV4aWJsZV9oZXJlZG9jX25vd2RvY19zeW50YXhlc1xuXG4gICAgICAgICAgaWYgKGluZGVudGF0aW9uX3VzZXNfc3BhY2VzICYmIGluZGVudGF0aW9uX3VzZXNfdGFicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgZXJyb3I6ICBtaXhpbmcgc3BhY2VzIGFuZCB0YWJzIGluIGVuZGluZyBtYXJrZXIgYXQgbGluZSBcIiArIHRoaXMueXlsaW5lbm8gKyBcIiAob2Zmc2V0IFwiICsgdGhpcy5vZmZzZXQgKyBcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGxlZCBpbiBwcmVtYXRjaF9FTkRPRkRPQ1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGluZGVudGF0aW9uX3VzZXNfc3BhY2VzO1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5maXJzdF9lbmNhcHNfbm9kZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZW1hdGNoIHRoZSBlbmQgb2YgSEVSRURPQy9OT1dET0MgZW5kIHRhZyB0byBwcmVzZXQgdGhlXG4gICAqIGNvbnRleHQgb2YgdGhpcy5oZXJlZG9jX2xhYmVsXG4gICAqL1xuICBwcmVtYXRjaF9FTkRPRkRPQzogZnVuY3Rpb24gcHJlbWF0Y2hfRU5ET0ZET0MoKSB7XG4gICAgLy8gcmVzZXQgaGVyZWRvY1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGZhbHNlO1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiA9IDA7XG4gICAgdGhpcy5oZXJlZG9jX2xhYmVsLmZpcnN0X2VuY2Fwc19ub2RlID0gdHJ1ZTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IHRoaXMuX2lucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gaWYgbWF0Y2ggaGVyZWRvY19sYWJlbCBzdHJ1Y3RydWUgd2lsbCBiZSBzZXRcbiAgICAgIGlmICh0aGlzLmlzRE9DX01BVENIKG9mZnNldCwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdsaW5lLmluY2x1ZGVzKHRoaXMuX2lucHV0W29mZnNldCAtIDFdKSkge1xuICAgICAgICAvLyBza2lwIG9uZSBsaW5lXG4gICAgICAgIHdoaWxlICghbmV3bGluZS5pbmNsdWRlcyh0aGlzLl9pbnB1dFtvZmZzZXQrK10pICYmIG9mZnNldCA8IHRoaXMuX2lucHV0Lmxlbmd0aCkgey8vIHNraXBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gIH0sXG4gIG1hdGNoU1RfTk9XRE9DOiBmdW5jdGlvbiBtYXRjaFNUX05PV0RPQygpIHtcbiAgICAvKiogZWRnZSBjYXNlIDogZW1wdHkgbm93IGRvYyAqKi9cbiAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgIC8vIEBmaXhtZSA6IG5ldmVyIHJlYWNoZWQgKG1heSBiZSBjYXVzZWQgYnkgcXVvdGVzKVxuICAgICAgdGhpcy5jb25zdW1lKHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGgpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5EX0hFUkVET0M7XG4gICAgfVxuICAgIC8qKiBTQ0FOTklORyBDT05URU5UUyAqKi9cblxuXG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcblxuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgaWYgKG5ld2xpbmUuaW5jbHVkZXMoY2gpKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRE9DX01BVENIKHRoaXMub2Zmc2V0LCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMudW5wdXQoMSkucG9wU3RhdGUoKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRU5EX0hFUkVET0MsIHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICAgIH1cbiAgICB9IC8vIHRvbyBiYWQgISByZWFjaGVkIGVuZCBvZiBkb2N1bWVudCAod2lsbCBnZXQgYSBwYXJzZSBlcnJvcilcblxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gIH0sXG4gIG1hdGNoU1RfSEVSRURPQzogZnVuY3Rpb24gbWF0Y2hTVF9IRVJFRE9DKCkge1xuICAgIC8qKiBlZGdlIGNhc2UgOiBlbXB0eSBoZXJlIGRvYyAqKi9cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSh0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoIC0gMSk7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FTkRfSEVSRURPQztcbiAgICB9XG4gICAgLyoqIFNDQU5OSU5HIENPTlRFTlRTICoqL1xuXG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7IC8vIGlnbm9yZSBuZXh0XG5cbiAgICAgICAgaWYgKCFuZXdsaW5lLmluY2x1ZGVzKGNoKSkge1xuICAgICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdsaW5lLmluY2x1ZGVzKGNoKSkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDEpLnBvcFN0YXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0VORF9IRVJFRE9DLCB0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIkXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICAgIC8vIHN0YXJ0IG9mICR7XG4gICAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1ZBUk5BTUVcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUywgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgJHZhci4uLlxuICAgICAgICAgIHZhciB5eW9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jb25zdW1lX1ZBUklBQkxFKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4obmV4dCwgdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpO1xuICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSAvL2NvbnNvbGUubG9nKHRoaXMueXl0ZXh0KTtcblxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICAgIH1cbiAgICB9IC8vIHRvbyBiYWQgISByZWFjaGVkIGVuZCBvZiBkb2N1bWVudCAod2lsbCBnZXQgYSBwYXJzZSBlcnJvcilcblxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gIH0sXG4gIGNvbnN1bWVfVkFSSUFCTEU6IGZ1bmN0aW9uIGNvbnN1bWVfVkFSSUFCTEUoKSB7XG4gICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICB0aGlzLnVucHV0KDEpO1xuICAgICAgdGhpcy5iZWdpbihcIlNUX1ZBUl9PRkZTRVRcIik7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgaWYgKHRoaXMuaW5wdXQoKSA9PT0gXCI+XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfUFJPUEVSVFlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVucHV0KDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgfSxcbiAgLy8gSEFORExFUyBCQUNLUVVPVEVTXG4gIG1hdGNoU1RfQkFDS1FVT1RFOiBmdW5jdGlvbiBtYXRjaFNUX0JBQ0tRVU9URSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMuY29uc3VtZV9WQVJJQUJMRSgpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIiRcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DVVJMWV9PUEVOO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiYFwiKSB7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gXCJgXCI7XG4gICAgfSAvLyBhbnkgY2hhclxuXG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJgXCIpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKFwiYFwiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIiRcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1ZBUk5BTUVcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUywgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgJHZhci4uLlxuICAgICAgICAgIHZhciB5eW9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jb25zdW1lX1ZBUklBQkxFKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4obmV4dCwgdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpO1xuICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICB9LFxuICBtYXRjaFNUX0RPVUJMRV9RVU9URVM6IGZ1bmN0aW9uIG1hdGNoU1RfRE9VQkxFX1FVT1RFUygpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMuY29uc3VtZV9WQVJJQUJMRSgpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIiRcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DVVJMWV9PUEVOO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgIHJldHVybiAnXCInO1xuICAgIH0gLy8gYW55IGNoYXJcblxuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKCdcIicsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTLCAyKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICAvLyBzdGFydCBvZiAkdmFyLi4uXG4gICAgICAgICAgdmFyIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmNvbnN1bWVfVkFSSUFCTEUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiB0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbihuZXh0LCB0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KHRoaXMub2Zmc2V0IC0geXlvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQGZpeG1lIDogeXl0ZXh0ID0gJ1wieyQnICh0aGlzLnl5dGV4dC5sZW5ndGggPiAzKVxuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfVxuXG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUX1NUUklORzogZnVuY3Rpb24gVF9TVFJJTkcoKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy55eXRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgaWQgPSB0aGlzLmtleXdvcmRzW3Rva2VuXTtcblxuICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzAwICYmIHRoaXMudHJ5TWF0Y2goXCIgZnJvbVwiKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSg1KTtcbiAgICAgICAgICBpZCA9IHRoaXMudG9rLlRfWUlFTERfRlJPTTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IHRoaXMudG9rLlRfWUlFTEQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gdGhpcy50b2suVF9TVFJJTkc7XG5cbiAgICAgICAgaWYgKHRva2VuID09PSBcImJcIiB8fCB0b2tlbiA9PT0gXCJCXCIpIHtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KDEpO1xuXG4gICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5TVF9ET1VCTEVfUVVPVEVTKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCkge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH0sXG4gIC8vIHJlYWRzIGEgY3VzdG9tIHRva2VuXG4gIGNvbnN1bWVfVE9LRU46IGZ1bmN0aW9uIGNvbnN1bWVfVE9LRU4oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcbiAgICB2YXIgZm4gPSB0aGlzLnRva2VuVGVybWluYWxzW2NoXTtcblxuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMueXl0ZXh0O1xuICAgIH1cbiAgfSxcbiAgLy8gbGlzdCBvZiBzcGVjaWFsIGNoYXIgdG9rZW5zXG4gIHRva2VuVGVybWluYWxzOiB7XG4gICAgJDogZnVuY3Rpb24gJCgpIHtcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQtLTtcbiAgICAgICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX1ZBUklBQkxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vZmZzZXQtLTtcbiAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCItXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1BST1BFUlRZXCIpLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX09CSkVDVF9PUEVSQVRPUjtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiLVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfREVDO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9NSU5VU19FUVVBTDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiLVwiO1xuICAgIH0sXG4gICAgXCJcXFxcXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9OU19TRVBBUkFUT1I7XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRElWX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIvXCI7XG4gICAgfSxcbiAgICBcIjpcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiOlwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiOlwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCIoXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IHRoaXMub2Zmc2V0O1xuICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAodGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZV9UQUJTUEFDRSgpLmlucHV0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHl5bGVuID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgICAgdmFyIGNhc3RUb2tlbiA9IHRoaXMueXl0ZXh0LnN1YnN0cmluZyh5eWxlbiAtIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjYXN0SWQgPSB0aGlzLmNhc3RLZXl3b3Jkc1tjYXN0VG9rZW5dO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FzdElkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNfVEFCU1BBQ0UoKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lX1RBQlNQQUNFKCkuaW5wdXQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXN0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHJldmVydCB0aGUgY2hlY2tcblxuXG4gICAgICB0aGlzLnVucHV0KHRoaXMub2Zmc2V0IC0gaW5pdGlhbCk7XG4gICAgICByZXR1cm4gXCIoXCI7XG4gICAgfSxcbiAgICBcIj1cIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPVUJMRV9BUlJPVztcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19JREVOVElDQUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0lTX0VRVUFMO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIj1cIjtcbiAgICB9LFxuICAgIFwiK1wiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiK1wiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfSU5DO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9QTFVTX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIrXCI7XG4gICAgfSxcbiAgICBcIiFcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19OT1RfSURFTlRJQ0FMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19OT1RfRVFVQUw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiIVwiO1xuICAgIH0sXG4gICAgXCI/XCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiP1wiKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzA0ICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKDIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NPQUxFU0NFX0VRVUFMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT0FMRVNDRTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI/XCI7XG4gICAgfSxcbiAgICBcIjxcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIjxcIikge1xuICAgICAgICBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV07XG5cbiAgICAgICAgaWYgKG5jaGFyID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9TTF9FUVVBTDtcbiAgICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc19IRVJFRE9DKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9TTDtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPlwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NQQUNFU0hJUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19TTUFMTEVSX09SX0VRVUFMO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0lTX05PVF9FUVVBTDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiPFwiO1xuICAgIH0sXG4gICAgXCI+XCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19HUkVBVEVSX09SX0VRVUFMO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdO1xuXG4gICAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1JfRVFVQUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NSO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIj5cIjtcbiAgICB9LFxuICAgIFwiKlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTVVMX0VRVUFMO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCIqXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1BPV19FUVVBTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9QT1c7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiKlwiO1xuICAgIH0sXG4gICAgXCIuXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT05DQVRfRVFVQUw7XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcIi5cIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIi5cIikge1xuICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VMTElQU0lTO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgfSxcbiAgICBcIiVcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTU9EX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIlXCI7XG4gICAgfSxcbiAgICBcIiZcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIj1cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0FORF9FUVVBTDtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiJlwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfQk9PTEVBTl9BTkQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIiZcIjtcbiAgICB9LFxuICAgIFwifFwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfT1JfRVFVQUw7XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcInxcIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0JPT0xFQU5fT1I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInxcIjtcbiAgICB9LFxuICAgIFwiXlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9YT1JfRVFVQUw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIl5cIjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgdG9rZW5zID0gXCI7OiwuXFxcXFtdKCl8XiYrLS8qPSUhfiQ8Pj9AXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gY2hlY2sgaWYgdGhlIGNoYXIgY2FuIGJlIGEgbnVtZXJpY1xuICBpc19OVU06IGZ1bmN0aW9uIGlzX05VTSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICByZXR1cm4gY2ggPiA0NyAmJiBjaCA8IDU4IHx8IGNoID09PSA5NTtcbiAgfSxcbiAgLy8gY2hlY2sgaWYgdGhlIGNoYXIgY2FuIGJlIGEgbnVtZXJpY1xuICBpc19OVU1fU1RBUlQ6IGZ1bmN0aW9uIGlzX05VTV9TVEFSVCgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICByZXR1cm4gY2ggPiA0NyAmJiBjaCA8IDU4O1xuICB9LFxuICAvLyBjaGVjayBpZiBjdXJyZW50IGNoYXIgY2FuIGJlIGEgbGFiZWxcbiAgaXNfTEFCRUw6IGZ1bmN0aW9uIGlzX0xBQkVMKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXQgLSAxKTtcblxuICAgIHJldHVybiBjaCA+IDk2ICYmIGNoIDwgMTIzIHx8IGNoID4gNjQgJiYgY2ggPCA5MSB8fCBjaCA9PT0gOTUgfHwgY2ggPiA0NyAmJiBjaCA8IDU4IHx8IGNoID4gMTI2O1xuICB9LFxuICAvLyBjaGVjayBpZiBjdXJyZW50IGNoYXIgY2FuIGJlIGEgbGFiZWxcbiAgaXNfTEFCRUxfU1RBUlQ6IGZ1bmN0aW9uIGlzX0xBQkVMX1NUQVJUKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXQgLSAxKTsgLy8gQSAtIFpcblxuXG4gICAgaWYgKGNoID4gNjQgJiYgY2ggPCA5MSkgcmV0dXJuIHRydWU7IC8vIGEgLSB6XG5cbiAgICBpZiAoY2ggPiA5NiAmJiBjaCA8IDEyMykgcmV0dXJuIHRydWU7IC8vIF8gKDk1KVxuXG4gICAgaWYgKGNoID09PSA5NSkgcmV0dXJuIHRydWU7IC8vIHV0ZjggLyBleHRlbmRlZFxuXG4gICAgaWYgKGNoID4gMTI2KSByZXR1cm4gdHJ1ZTsgLy8gZWxzZVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyByZWFkcyBlYWNoIGNoYXIgb2YgdGhlIGxhYmVsXG4gIGNvbnN1bWVfTEFCRUw6IGZ1bmN0aW9uIGNvbnN1bWVfTEFCRUwoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19MQUJFTCgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHRva2VuIGNoYXJcbiAgaXNfVE9LRU46IGZ1bmN0aW9uIGlzX1RPS0VOKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0IC0gMV07XG4gICAgcmV0dXJuIHRva2Vucy5pbmRleE9mKGNoKSAhPT0gLTE7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHdoaXRlc3BhY2VcbiAgaXNfV0hJVEVTUEFDRTogZnVuY3Rpb24gaXNfV0hJVEVTUEFDRSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdO1xuICAgIHJldHVybiBjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx0XCIgfHwgY2ggPT09IFwiXFxuXCIgfHwgY2ggPT09IFwiXFxyXCI7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHdoaXRlc3BhY2UgKHdpdGhvdXQgbmV3bGluZXMpXG4gIGlzX1RBQlNQQUNFOiBmdW5jdGlvbiBpc19UQUJTUEFDRSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdO1xuICAgIHJldHVybiBjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx0XCI7XG4gIH0sXG4gIC8vIGNvbnN1bWUgYWxsIHdoaXRlc3BhY2VzIChleGNsdWRpbmcgbmV3bGluZXMpXG4gIGNvbnN1bWVfVEFCU1BBQ0U6IGZ1bmN0aW9uIGNvbnN1bWVfVEFCU1BBQ0UoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBjYW4gYmUgYSBoZXhhZGVjaW1hbCBudW1iZXJcbiAgaXNfSEVYOiBmdW5jdGlvbiBpc19IRVgoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLm9mZnNldCAtIDEpOyAvLyAwIC0gOVxuXG5cbiAgICBpZiAoY2ggPiA0NyAmJiBjaCA8IDU4KSByZXR1cm4gdHJ1ZTsgLy8gQSAtIEZcblxuICAgIGlmIChjaCA+IDY0ICYmIGNoIDwgNzEpIHJldHVybiB0cnVlOyAvLyBhIC0gZlxuXG4gICAgaWYgKGNoID4gOTYgJiYgY2ggPCAxMDMpIHJldHVybiB0cnVlOyAvLyBfIChjb2RlIDk1KVxuXG4gICAgaWYgKGNoID09PSA5NSkgcmV0dXJuIHRydWU7IC8vIGVsc2VcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gbiAhPSBcIi5cIiAmJiBuICE9IFwiLFwiICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbi8qKlxuICogVGhlIFBIUCBQYXJzZXIgY2xhc3MgdGhhdCBidWlsZCB0aGUgQVNUIHRyZWUgZnJvbSB0aGUgbGV4ZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEB0dXRvcmlhbCBQYXJzZXJcbiAqIEBwcm9wZXJ0eSB7TGV4ZXJ9IGxleGVyIC0gY3VycmVudCBsZXhlciBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtBU1R9IGFzdCAtIHRoZSBBU1QgZmFjdG9yeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtJbnRlZ2VyfFN0cmluZ30gdG9rZW4gLSBjdXJyZW50IHRva2VuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4dHJhY3REb2MgLSBzaG91bGQgZXh0cmFjdCBkb2N1bWVudGF0aW9uIGFzIEFTVCBub2RlXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4dHJhY3RUb2tlbnMgLSBzaG91bGQgZXh0cmFjdCBlYWNoIHRva2VuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHN1cHByZXNzRXJyb3JzIC0gc2hvdWxkIGlnbm9yZSBwYXJzaW5nIGVycm9ycyBhbmQgY29udGludWVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVidWcgLSBzaG91bGQgb3V0cHV0IGRlYnVnIGluZm9ybWF0aW9uc1xuICovXG5cblxudmFyIHBhcnNlciA9IGZ1bmN0aW9uIHBhcnNlcihsZXhlciwgYXN0KSB7XG4gIHRoaXMubGV4ZXIgPSBsZXhlcjtcbiAgdGhpcy5hc3QgPSBhc3Q7XG4gIHRoaXMudG9rID0gbGV4ZXIudG9rO1xuICB0aGlzLkVPRiA9IGxleGVyLkVPRjtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMucHJldiA9IG51bGw7XG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgdGhpcy52ZXJzaW9uID0gNzA0O1xuICB0aGlzLmV4dHJhY3REb2MgPSBmYWxzZTtcbiAgdGhpcy5leHRyYWN0VG9rZW5zID0gZmFsc2U7XG4gIHRoaXMuc3VwcHJlc3NFcnJvcnMgPSBmYWxzZTtcblxuICB2YXIgbWFwSXQgPSBmdW5jdGlvbiBtYXBJdChpdGVtKSB7XG4gICAgcmV0dXJuIFtpdGVtLCBudWxsXTtcbiAgfTtcblxuICB0aGlzLmVudHJpZXMgPSB7XG4gICAgLy8gcmVzZXJ2ZWRfbm9uX21vZGlmaWVyc1xuICAgIElERU5USUZJRVI6IG5ldyBNYXAoW3RoaXMudG9rLlRfQUJTVFJBQ1QsIHRoaXMudG9rLlRfQVJSQVksIHRoaXMudG9rLlRfQVMsIHRoaXMudG9rLlRfQlJFQUssIHRoaXMudG9rLlRfQ0FMTEFCTEUsIHRoaXMudG9rLlRfQ0FTRSwgdGhpcy50b2suVF9DQVRDSCwgdGhpcy50b2suVF9DTEFTUywgdGhpcy50b2suVF9DTEFTU19DLCB0aGlzLnRvay5UX0NMT05FLCB0aGlzLnRvay5UX0NPTlNULCB0aGlzLnRvay5UX0NPTlRJTlVFLCB0aGlzLnRvay5UX0RFQ0xBUkUsIHRoaXMudG9rLlRfREVGQVVMVCwgdGhpcy50b2suVF9ESVIsIHRoaXMudG9rLlRfRE8sIHRoaXMudG9rLlRfRUNITywgdGhpcy50b2suVF9FTFNFLCB0aGlzLnRvay5UX0VMU0VJRiwgdGhpcy50b2suVF9FTVBUWSwgdGhpcy50b2suVF9FTkRERUNMQVJFLCB0aGlzLnRvay5UX0VOREZPUiwgdGhpcy50b2suVF9FTkRGT1JFQUNILCB0aGlzLnRvay5UX0VORElGLCB0aGlzLnRvay5UX0VORFNXSVRDSCwgdGhpcy50b2suVF9FTkRXSElMRSwgdGhpcy50b2suVF9FVkFMLCB0aGlzLnRvay5UX0VYSVQsIHRoaXMudG9rLlRfRVhURU5EUywgdGhpcy50b2suVF9GSUxFLCB0aGlzLnRvay5UX0ZJTkFMLCB0aGlzLnRvay5UX0ZJTkFMTFksIHRoaXMudG9rLlRfRk4sIHRoaXMudG9rLlRfRk9SLCB0aGlzLnRvay5UX0ZPUkVBQ0gsIHRoaXMudG9rLlRfRlVOQ19DLCB0aGlzLnRvay5UX0ZVTkNUSU9OLCB0aGlzLnRvay5UX0dMT0JBTCwgdGhpcy50b2suVF9HT1RPLCB0aGlzLnRvay5UX0lGLCB0aGlzLnRvay5UX0lNUExFTUVOVFMsIHRoaXMudG9rLlRfSU5DTFVERSwgdGhpcy50b2suVF9JTkNMVURFX09OQ0UsIHRoaXMudG9rLlRfSU5TVEFOQ0VPRiwgdGhpcy50b2suVF9JTlNURUFET0YsIHRoaXMudG9rLlRfSU5URVJGQUNFLCB0aGlzLnRvay5UX0lTU0VULCB0aGlzLnRvay5UX0xJTkUsIHRoaXMudG9rLlRfTElTVCwgdGhpcy50b2suVF9MT0dJQ0FMX0FORCwgdGhpcy50b2suVF9MT0dJQ0FMX09SLCB0aGlzLnRvay5UX0xPR0lDQUxfWE9SLCB0aGlzLnRvay5UX01FVEhPRF9DLCB0aGlzLnRvay5UX05BTUVTUEFDRSwgdGhpcy50b2suVF9ORVcsIHRoaXMudG9rLlRfTlNfQywgdGhpcy50b2suVF9QUklOVCwgdGhpcy50b2suVF9QUklWQVRFLCB0aGlzLnRvay5UX1BST1RFQ1RFRCwgdGhpcy50b2suVF9QVUJMSUMsIHRoaXMudG9rLlRfUkVRVUlSRSwgdGhpcy50b2suVF9SRVFVSVJFX09OQ0UsIHRoaXMudG9rLlRfUkVUVVJOLCB0aGlzLnRvay5UX1NUQVRJQywgdGhpcy50b2suVF9TV0lUQ0gsIHRoaXMudG9rLlRfVEhST1csIHRoaXMudG9rLlRfVFJBSVQsIHRoaXMudG9rLlRfVFJZLCB0aGlzLnRvay5UX1VOU0VULCB0aGlzLnRvay5UX1VTRSwgdGhpcy50b2suVF9WQVIsIHRoaXMudG9rLlRfV0hJTEUsIHRoaXMudG9rLlRfWUlFTERdLm1hcChtYXBJdCkpLFxuICAgIFZBUklBQkxFOiBuZXcgTWFwKFt0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIiwgXCImXCIsIHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SLCB0aGlzLnRvay5UX1NUUklORywgdGhpcy50b2suVF9OQU1FU1BBQ0UsIHRoaXMudG9rLlRfU1RBVElDXS5tYXAobWFwSXQpKSxcbiAgICBTQ0FMQVI6IG5ldyBNYXAoW3RoaXMudG9rLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HLCB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0MsIHRoaXMudG9rLlRfTE5VTUJFUiwgdGhpcy50b2suVF9ETlVNQkVSLCB0aGlzLnRvay5UX0FSUkFZLCBcIltcIiwgdGhpcy50b2suVF9DTEFTU19DLCB0aGlzLnRvay5UX1RSQUlUX0MsIHRoaXMudG9rLlRfRlVOQ19DLCB0aGlzLnRvay5UX01FVEhPRF9DLCB0aGlzLnRvay5UX0xJTkUsIHRoaXMudG9rLlRfRklMRSwgdGhpcy50b2suVF9ESVIsIHRoaXMudG9rLlRfTlNfQywgJ1wiJywgJ2JcIicsICdCXCInLCBcIi1cIiwgdGhpcy50b2suVF9OU19TRVBBUkFUT1JdLm1hcChtYXBJdCkpLFxuICAgIFRfTUFHSUNfQ09OU1Q6IG5ldyBNYXAoW3RoaXMudG9rLlRfQ0xBU1NfQywgdGhpcy50b2suVF9UUkFJVF9DLCB0aGlzLnRvay5UX0ZVTkNfQywgdGhpcy50b2suVF9NRVRIT0RfQywgdGhpcy50b2suVF9MSU5FLCB0aGlzLnRvay5UX0ZJTEUsIHRoaXMudG9rLlRfRElSLCB0aGlzLnRvay5UX05TX0NdLm1hcChtYXBJdCkpLFxuICAgIFRfTUVNQkVSX0ZMQUdTOiBuZXcgTWFwKFt0aGlzLnRvay5UX1BVQkxJQywgdGhpcy50b2suVF9QUklWQVRFLCB0aGlzLnRvay5UX1BST1RFQ1RFRCwgdGhpcy50b2suVF9TVEFUSUMsIHRoaXMudG9rLlRfQUJTVFJBQ1QsIHRoaXMudG9rLlRfRklOQUxdLm1hcChtYXBJdCkpLFxuICAgIEVPUzogbmV3IE1hcChbXCI7XCIsIHRoaXMuRU9GLCB0aGlzLnRvay5UX0lOTElORV9IVE1MXS5tYXAobWFwSXQpKSxcbiAgICBFWFBSOiBuZXcgTWFwKFtcIkBcIiwgXCItXCIsIFwiK1wiLCBcIiFcIiwgXCJ+XCIsIFwiKFwiLCBcImBcIiwgdGhpcy50b2suVF9MSVNULCB0aGlzLnRvay5UX0NMT05FLCB0aGlzLnRvay5UX0lOQywgdGhpcy50b2suVF9ERUMsIHRoaXMudG9rLlRfTkVXLCB0aGlzLnRvay5UX0lTU0VULCB0aGlzLnRvay5UX0VNUFRZLCB0aGlzLnRvay5UX0lOQ0xVREUsIHRoaXMudG9rLlRfSU5DTFVERV9PTkNFLCB0aGlzLnRvay5UX1JFUVVJUkUsIHRoaXMudG9rLlRfUkVRVUlSRV9PTkNFLCB0aGlzLnRvay5UX0VWQUwsIHRoaXMudG9rLlRfSU5UX0NBU1QsIHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsIHRoaXMudG9rLlRfU1RSSU5HX0NBU1QsIHRoaXMudG9rLlRfQVJSQVlfQ0FTVCwgdGhpcy50b2suVF9PQkpFQ1RfQ0FTVCwgdGhpcy50b2suVF9CT09MX0NBU1QsIHRoaXMudG9rLlRfVU5TRVRfQ0FTVCwgdGhpcy50b2suVF9FWElULCB0aGlzLnRvay5UX1BSSU5ULCB0aGlzLnRvay5UX1lJRUxELCB0aGlzLnRvay5UX1NUQVRJQywgdGhpcy50b2suVF9GVU5DVElPTiwgdGhpcy50b2suVF9GTiwgLy8gdXNpbmcgVkFSSUFCTEVTIDpcbiAgICB0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIiwgdGhpcy50b2suVF9OU19TRVBBUkFUT1IsIHRoaXMudG9rLlRfU1RSSU5HLCAvLyB1c2luZyBTQ0FMQVIgOlxuICAgIHRoaXMudG9rLlRfU1RSSU5HLCAvLyBAc2VlIHZhcmlhYmxlLmpzIGxpbmUgNDUgPiBjb25mbGljdCB3aXRoIHZhcmlhYmxlID0gc2hpZnQvcmVkdWNlIDopXG4gICAgdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkcsIHRoaXMudG9rLlRfU1RBUlRfSEVSRURPQywgdGhpcy50b2suVF9MTlVNQkVSLCB0aGlzLnRvay5UX0ROVU1CRVIsIHRoaXMudG9rLlRfQVJSQVksIFwiW1wiLCB0aGlzLnRvay5UX0NMQVNTX0MsIHRoaXMudG9rLlRfVFJBSVRfQywgdGhpcy50b2suVF9GVU5DX0MsIHRoaXMudG9rLlRfTUVUSE9EX0MsIHRoaXMudG9rLlRfTElORSwgdGhpcy50b2suVF9GSUxFLCB0aGlzLnRvay5UX0RJUiwgdGhpcy50b2suVF9OU19DLCAnXCInLCAnYlwiJywgJ0JcIicsIFwiLVwiLCB0aGlzLnRvay5UX05TX1NFUEFSQVRPUl0ubWFwKG1hcEl0KSlcbiAgfTtcbn07XG4vKipcbiAqIGhlbHBlciA6IGdldHMgYSB0b2tlbiBuYW1lXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLmdldFRva2VuTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICBpZiAoIWlzTnVtYmVyKHRva2VuKSkge1xuICAgIHJldHVybiBcIidcIiArIHRva2VuICsgXCInXCI7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRva2VuID09IHRoaXMuRU9GKSByZXR1cm4gXCJ0aGUgZW5kIG9mIGZpbGUgKEVPRilcIjtcbiAgICByZXR1cm4gdGhpcy5sZXhlci5lbmdpbmUudG9rZW5zLnZhbHVlc1t0b2tlbl07XG4gIH1cbn07XG4vKipcbiAqIG1haW4gZW50cnkgcG9pbnQgOiBjb252ZXJ0cyBhIHNvdXJjZSBjb2RlIHRvIEFTVFxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb2RlLCBmaWxlbmFtZSkge1xuICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lIHx8IFwiZXZhbFwiO1xuICB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPSBbXCJcIl07XG5cbiAgaWYgKHRoaXMuZXh0cmFjdERvYykge1xuICAgIHRoaXMuX2RvY3MgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kb2NzID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmV4dHJhY3RUb2tlbnMpIHtcbiAgICB0aGlzLl90b2tlbnMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90b2tlbnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5fZG9jSW5kZXggPSAwO1xuICB0aGlzLl9sYXN0Tm9kZSA9IG51bGw7XG4gIHRoaXMubGV4ZXIuc2V0SW5wdXQoY29kZSk7XG4gIHRoaXMubGV4ZXIuYWxsX3Rva2VucyA9IHRoaXMuZXh0cmFjdFRva2VucztcbiAgdGhpcy5sZXhlci5jb21tZW50X3Rva2VucyA9IHRoaXMuZXh0cmFjdERvYztcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmxleGVyLl9pbnB1dC5sZW5ndGg7XG4gIHRoaXMuaW5uZXJMaXN0ID0gZmFsc2U7XG4gIHRoaXMuaW5uZXJMaXN0Rm9ybSA9IGZhbHNlO1xuICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZShcInByb2dyYW1cIik7XG4gIHZhciBjaGlsZHMgPSBbXTtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YpIHtcbiAgICBjaGlsZHMucHVzaCh0aGlzLnJlYWRfc3RhcnQoKSk7XG4gIH0gLy8gYXBwZW5kIGxhc3QgY29tbWVudFxuXG5cbiAgaWYgKGNoaWxkcy5sZW5ndGggPT09IDAgJiYgdGhpcy5leHRyYWN0RG9jICYmIHRoaXMuX2RvY3MubGVuZ3RoID4gdGhpcy5fZG9jSW5kZXgpIHtcbiAgICBjaGlsZHMucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICB9IC8vICMxNzYgOiByZWdpc3RlciBsYXRlc3QgcG9zaXRpb25cblxuXG4gIHRoaXMucHJldiA9IFt0aGlzLmxleGVyLnl5bGxvYy5sYXN0X2xpbmUsIHRoaXMubGV4ZXIueXlsbG9jLmxhc3RfY29sdW1uLCB0aGlzLmxleGVyLm9mZnNldF07XG4gIHZhciByZXN1bHQgPSBwcm9ncmFtKGNoaWxkcywgdGhpcy5fZXJyb3JzLCB0aGlzLl9kb2NzLCB0aGlzLl90b2tlbnMpO1xuXG4gIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgdmFyIGVycm9ycyA9IHRoaXMuYXN0LmNoZWNrTm9kZXMoKTtcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5wb3NpdGlvbikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5sb2coXCJOb2RlIGF0IGxpbmUgXCIgKyBlcnJvci5wb3NpdGlvbi5saW5lICsgXCIsIGNvbHVtbiBcIiArIGVycm9yLnBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuXG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnN0YWNrLmpvaW4oXCJcXG5cIikpO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb21lIG5vZGVzIGFyZSBub3QgY2xvc2VkXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBSYWlzZSBhbiBlcnJvclxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5yYWlzZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG1zZ0V4cGVjdCwgZXhwZWN0LCB0b2tlbikge1xuICBtZXNzYWdlICs9IFwiIG9uIGxpbmUgXCIgKyB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lO1xuXG4gIGlmICghdGhpcy5zdXBwcmVzc0Vycm9ycykge1xuICAgIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSwgdGhpcy5maWxlbmFtZSwgdGhpcy5sZXhlci55eWxsb2MuZmlyc3RfbGluZSk7XG4gICAgZXJyLmxpbmVOdW1iZXIgPSB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lO1xuICAgIGVyci5maWxlTmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgZXJyLmNvbHVtbk51bWJlciA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2NvbHVtbjtcbiAgICB0aHJvdyBlcnI7XG4gIH0gLy8gRXJyb3Igbm9kZSA6XG5cblxuICB2YXIgbm9kZSA9IHRoaXMuYXN0LnByZXBhcmUoXCJlcnJvclwiLCBudWxsLCB0aGlzKShtZXNzYWdlLCB0b2tlbiwgdGhpcy5sZXhlci55eWxsb2MuZmlyc3RfbGluZSwgZXhwZWN0KTtcblxuICB0aGlzLl9lcnJvcnMucHVzaChub2RlKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIGhhbmRsaW5nIGVycm9yc1xuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChleHBlY3QpIHtcbiAgdmFyIG1zZyA9IFwiUGFyc2UgRXJyb3IgOiBzeW50YXggZXJyb3JcIjtcbiAgdmFyIHRva2VuID0gdGhpcy5nZXRUb2tlbk5hbWUodGhpcy50b2tlbik7XG4gIHZhciBtc2dFeHBlY3QgPSBcIlwiO1xuXG4gIGlmICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRikge1xuICAgIGlmIChpc051bWJlcih0aGlzLnRva2VuKSkge1xuICAgICAgdmFyIHN5bWJvbCA9IHRoaXMudGV4dCgpO1xuXG4gICAgICBpZiAoc3ltYm9sLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHN5bWJvbCA9IHN5bWJvbC5zdWJzdHJpbmcoMCwgNykgKyBcIi4uLlwiO1xuICAgICAgfVxuXG4gICAgICB0b2tlbiA9IFwiJ1wiICsgc3ltYm9sICsgXCInIChcIiArIHRva2VuICsgXCIpXCI7XG4gICAgfVxuXG4gICAgbXNnICs9IFwiLCB1bmV4cGVjdGVkIFwiICsgdG9rZW47XG4gIH1cblxuICBpZiAoZXhwZWN0ICYmICFBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICBpZiAoaXNOdW1iZXIoZXhwZWN0KSB8fCBleHBlY3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBtc2dFeHBlY3QgPSBcIiwgZXhwZWN0aW5nIFwiICsgdGhpcy5nZXRUb2tlbk5hbWUoZXhwZWN0KTtcbiAgICB9XG5cbiAgICBtc2cgKz0gbXNnRXhwZWN0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucmFpc2VFcnJvcihtc2csIG1zZ0V4cGVjdCwgZXhwZWN0LCB0b2tlbik7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFTVCBub2RlXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAodGhpcy5leHRyYWN0RG9jKSB7XG4gICAgdmFyIGRvY3MgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2RvY0luZGV4IDwgdGhpcy5fZG9jcy5sZW5ndGgpIHtcbiAgICAgIGRvY3MgPSB0aGlzLl9kb2NzLnNsaWNlKHRoaXMuX2RvY0luZGV4KTtcbiAgICAgIHRoaXMuX2RvY0luZGV4ID0gdGhpcy5fZG9jcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKG5ldyBFcnJvcihcIkFwcGVuZCBkb2NzIG9uIFwiICsgbmFtZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGRvY3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gdGhpcy5hc3QucHJlcGFyZShuYW1lLCBkb2NzLCB0aGlzKTtcbiAgICAvKipcbiAgICAgKiBUT0tFTlMgOlxuICAgICAqIG5vZGUxIGNvbW1lbnRBIHRva2VuIGNvbW1tZW50QiBub2RlMiBjb21tZW50QyB0b2tlbiBjb21tZW50RCBub2RlMyBjb21tZW50RSB0b2tlblxuICAgICAqXG4gICAgICogQVNUIDpcbiAgICAgKiBzdHJ1Y3R1cmU6UzEgW1xuICAgICAqICAgIGxlZnQ6IG5vZGUxICggdHJhaWw6IGNvbW1lbnRBICksXG4gICAgICogICAgcmlnaHQ6IHN0cnVjdHVyZTpTMiBbXG4gICAgICogICAgICAgbm9kZTIgKGxlYWQ6IGNvbW1lbnRCLCB0cmFpbDogY29tbWVudEMpLFxuICAgICAqICAgICAgIG5vZGUzIChsZWFkOiBjb21tZW50RClcbiAgICAgKiAgICBdLFxuICAgICAqICAgIHRyYWlsOiBjb21tZW50RVxuICAgICAqIF1cbiAgICAgKlxuICAgICAqIEFsZ29yaXRobSA6XG4gICAgICpcbiAgICAgKiBBdHRhY2ggdGhlIGxhc3QgY29tbWVudHMgb24gcGFyZW50IG9mIGN1cnJlbnQgbm9kZVxuICAgICAqIElmIGEgbmV3IG5vZGUgaXMgc3RhcnRlZCBhbmQgdGhlIHBhcmVudCBoYXMgYSB0cmFpbGluZyBjb21tZW50XG4gICAgICogdGhlIG1vdmUgaXQgb24gcHJldmlvdXMgbm9kZVxuICAgICAqXG4gICAgICogc3RhcnQgUzJcbiAgICAgKiBzdGFydCBub2RlMVxuICAgICAqIGNvbnN1bWUgbm9kZTEgJiBzZXQgY29tbWVudEEgYXMgdHJhaWxpbmdDb21tZW50IG9uIFMyXG4gICAgICogc3RhcnQgUzJcbiAgICAgKiBTMSBoYXMgYSB0cmFpbGluZ0NvbW1lbnQsIGF0dGFjaCBpdCBvbiBub2RlMVxuICAgICAqIC4uLlxuICAgICAqIE5PVEUgOiBBcyB0aGUgdHJhaWxpbmdDb21tZW50IEJlaGF2aW9yIGRlcGVuZHMgb24gQVNULCBpdCB3aWxsIGJlIGJ1aWxkIG9uXG4gICAgICogdGhlIEFTVCBsYXllciAtIGxhc3QgY2hpbGQgbm9kZSB3aWxsIGtlZXAgaXQncyB0cmFpbGluZ0NvbW1lbnQgbm9kZXNcbiAgICAgKi9cblxuICAgIG5vZGUucG9zdEJ1aWxkID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgIGlmICh0aGlzLl9kb2NJbmRleCA8IHRoaXMuX2RvY3MubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0Tm9kZSkge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnByZXZbMl07XG4gICAgICAgICAgdmFyIG1heCA9IHRoaXMuX2RvY0luZGV4O1xuXG4gICAgICAgICAgZm9yICg7IG1heCA8IHRoaXMuX2RvY3MubGVuZ3RoOyBtYXgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RvY3NbbWF4XS5vZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1heCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICAgICAgICAvLyBpbmplY3QgdHJhaWxpbmcgY29tbWVudCBvbiBjaGlsZCBub2RlXG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZS5zZXRUcmFpbGluZ0NvbW1lbnRzKHRoaXMuX2RvY3Muc2xpY2UodGhpcy5fZG9jSW5kZXgsIG1heCkpO1xuXG4gICAgICAgICAgICB0aGlzLl9kb2NJbmRleCA9IG1heDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy5FT0YpIHtcbiAgICAgICAgICAvLyBlbmQgb2YgY29udGVudFxuICAgICAgICAgIHNlbGYuc2V0VHJhaWxpbmdDb21tZW50cyh0aGlzLl9kb2NzLnNsaWNlKHRoaXMuX2RvY0luZGV4KSk7XG4gICAgICAgICAgdGhpcy5fZG9jSW5kZXggPSB0aGlzLl9kb2NzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXN0Tm9kZSA9IHNlbGY7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hc3QucHJlcGFyZShuYW1lLCBudWxsLCB0aGlzKTtcbn07XG4vKipcbiAqIGV4cGVjdHMgYW4gZW5kIG9mIHN0YXRlbWVudCBvciBlbmQgb2YgZmlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbnBhcnNlci5wcm90b3R5cGUuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy50b2tlbiA9PT0gXCI7XCIpIHtcbiAgICAvLyBpbmNsdWRlIG9ubHkgcmVhbCAnOycgc3RhdGVtZW50c1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2lzc3Vlcy8xNjRcbiAgICBpZiAobm9kZSAmJiB0aGlzLmxleGVyLnl5dGV4dCA9PT0gXCI7XCIpIHtcbiAgICAgIG5vZGUuaW5jbHVkZVRva2VuKHRoaXMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0lOTElORV9IVE1MICYmIHRoaXMudG9rZW4gIT09IHRoaXMuRU9GKSB7XG4gICAgdGhpcy5lcnJvcihcIjtcIik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufTtcbi8qKiBvdXRwdXRzIHNvbWUgZGVidWcgaW5mb3JtYXRpb24gb24gY3VycmVudCB0b2tlbiAqKi9cblxuXG52YXIgaWdub3JlU3RhY2sgPSBbXCJwYXJzZXIubmV4dFwiLCBcInBhcnNlci5ub2RlXCIsIFwicGFyc2VyLnNob3dsb2dcIl07XG5cbnBhcnNlci5wcm90b3R5cGUuc2hvd2xvZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gIHZhciBsaW5lO1xuXG4gIGZvciAodmFyIG9mZnNldCA9IDI7IG9mZnNldCA8IHN0YWNrLmxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBsaW5lID0gc3RhY2tbb2Zmc2V0XS50cmltKCk7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlnbm9yZVN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGluZS5zdWJzdHJpbmcoMywgMyArIGlnbm9yZVN0YWNrW2ldLmxlbmd0aCkgPT09IGlnbm9yZVN0YWNrW2ldKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cblxuICBjb25zb2xlLmxvZyhcIkxpbmUgXCIgKyB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lICsgXCIgOiBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHRoaXMudG9rZW4pICsgXCI+XCIgKyB0aGlzLmxleGVyLnl5dGV4dCArIFwiPFwiICsgXCIgQC0tPlwiICsgbGluZSk7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogRm9yY2UgdGhlIHBhcnNlciB0byBjaGVjayB0aGUgY3VycmVudCB0b2tlbi5cbiAqXG4gKiBJZiB0aGUgY3VycmVudCB0b2tlbiBkb2VzIG5vdCBtYXRjaCB0byBleHBlY3RlZCB0b2tlbixcbiAqIHRoZSBhbiBlcnJvciB3aWxsIGJlIHJhaXNlZC5cbiAqXG4gKiBJZiB0aGUgc3VwcHJlc3NFcnJvciBtb2RlIGlzIGFjdGl2YXRlZCwgdGhlbiB0aGUgZXJyb3Igd2lsbFxuICogYmUgYWRkZWQgdG8gdGhlIHByb2dyYW0gZXJyb3Igc3RhY2sgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHRva2VuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHRocm93cyBFcnJvclxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5leHBlY3QgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgaWYgKHRva2VuLmluZGV4T2YodGhpcy50b2tlbikgPT09IC0xKSB7XG4gICAgICB0aGlzLmVycm9yKHRva2VuKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy50b2tlbiAhPSB0b2tlbikge1xuICAgIHRoaXMuZXJyb3IodG9rZW4pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBjb250ZW50c1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZXhlci55eXRleHQ7XG59O1xuLyoqIGNvbnN1bWUgdGhlIG5leHQgdG9rZW4gKiovXG5cblxucGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBwcmVwYXJlIHRoZSBiYWNrIGNvbW1hbmRcbiAgaWYgKHRoaXMudG9rZW4gIT09IFwiO1wiIHx8IHRoaXMubGV4ZXIueXl0ZXh0ID09PSBcIjtcIikge1xuICAgIC8vIGlnbm9yZSAnPz4nIGZyb20gYXV0b21hdGVkIHJlc29sdXRpb25cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvMTY4XG4gICAgdGhpcy5wcmV2ID0gW3RoaXMubGV4ZXIueXlsbG9jLmxhc3RfbGluZSwgdGhpcy5sZXhlci55eWxsb2MubGFzdF9jb2x1bW4sIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgfSAvLyBlYXRpbmcgdGhlIHRva2VuXG5cblxuICB0aGlzLmxleCgpOyAvLyBzaG93aW5nIHRoZSBkZWJ1Z1xuXG4gIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgdGhpcy5zaG93bG9nKCk7XG4gIH0gLy8gaGFuZGxpbmcgY29tbWVudHNcblxuXG4gIGlmICh0aGlzLmV4dHJhY3REb2MpIHtcbiAgICB3aGlsZSAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT01NRU5UIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9DX0NPTU1FTlQpIHtcbiAgICAgIC8vIEFQUEVORCBDT01NRU5UU1xuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09NTUVOVCkge1xuICAgICAgICB0aGlzLl9kb2NzLnB1c2godGhpcy5yZWFkX2NvbW1lbnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kb2NzLnB1c2godGhpcy5yZWFkX2RvY19jb21tZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogRWF0aW5nIGEgdG9rZW5cbiAqL1xuXG5cbnBhcnNlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24gKCkge1xuICAvLyBhcHBlbmQgb24gdG9rZW4gc3RhY2tcbiAgaWYgKHRoaXMuZXh0cmFjdFRva2Vucykge1xuICAgIGRvIHtcbiAgICAgIC8vIHRoZSB0b2tlblxuICAgICAgdGhpcy50b2tlbiA9IHRoaXMubGV4ZXIubGV4KCkgfHwgdGhpcy5FT0Y7XG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy5FT0YpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZXhlci55eXRleHQ7XG5cbiAgICAgIGlmICh0aGlzLmxleGVyLmVuZ2luZS50b2tlbnMudmFsdWVzLmhhc093blByb3BlcnR5KHRoaXMudG9rZW4pKSB7XG4gICAgICAgIGVudHJ5ID0gW3RoaXMubGV4ZXIuZW5naW5lLnRva2Vucy52YWx1ZXNbdGhpcy50b2tlbl0sIGVudHJ5LCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lLCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQsIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5ID0gW251bGwsIGVudHJ5LCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lLCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQsIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9rZW5zLnB1c2goZW50cnkpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DTE9TRV9UQUcpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvN2ZmMTg2NDM0ZTgyZWU3YmU3YzU5ZDBkYjlhOTc2NjQxY2Y3YjA5Yy9aZW5kL3plbmRfY29tcGlsZS5jI0wxNjgwXG4gICAgICAgIHRoaXMudG9rZW4gPSBcIjtcIjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfT1BFTl9UQUdfV0lUSF9FQ0hPKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0aGlzLnRvay5UX0VDSE87XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfV0hJVEVTUEFDRSB8fCAvLyBpZ25vcmUgd2hpdGUgc3BhY2VcbiAgICAhdGhpcy5leHRyYWN0RG9jICYmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NPTU1FTlQgfHwgLy8gaWdub3JlIHNpbmdsZSBsaW5lcyBjb21tZW50c1xuICAgIHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9DX0NPTU1FTlQpIHx8IC8vIGlnbm9yZSBkb2MgY29tbWVudHNcbiAgICAvLyBpZ25vcmUgb3BlbiB0YWdzXG4gICAgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9PUEVOX1RBRyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbiA9IHRoaXMubGV4ZXIubGV4KCkgfHwgdGhpcy5FT0Y7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIENoZWNrIGlmIHRva2VuIGlzIG9mIHNwZWNpZmllZCB0eXBlXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLmlzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICByZXR1cm4gdHlwZS5pbmRleE9mKHRoaXMudG9rZW4pICE9PSAtMTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVudHJpZXNbdHlwZV0uaGFzKHRoaXMudG9rZW4pO1xufTsgLy8gZXh0ZW5kcyB0aGUgcGFyc2VyIHdpdGggc3ludGF4IGZpbGVzXG5cblxuW19fd2VicGFja19yZXF1aXJlX18oMjQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNiksIF9fd2VicGFja19yZXF1aXJlX18oMjcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSksIF9fd2VicGFja19yZXF1aXJlX18oMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMiksIF9fd2VicGFja19yZXF1aXJlX18oMzMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNSksIF9fd2VicGFja19yZXF1aXJlX18oMzYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzOCldLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICBmb3IgKHZhciBrIGluIGV4dCkge1xuICAgIGlmIChwYXJzZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2lzc3Vlcy8yMzRcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIFwiICsgayArIFwiIGlzIGFscmVhZHkgZGVmaW5lZCAtIGNvbGxpc2lvblwiKTtcbiAgICB9XG5cbiAgICBwYXJzZXIucHJvdG90eXBlW2tdID0gZXh0W2tdO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBQYXJzZSBhbiBhcnJheVxuICAgKiBgYGBlYm5mXG4gICAqIGFycmF5IDo6PSBUX0FSUkFZICcoJyBhcnJheV9wYWlyX2xpc3QgJyknIHxcbiAgICogICAnWycgYXJyYXlfcGFpcl9saXN0ICddJ1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfYXJyYXk6IGZ1bmN0aW9uIHJlYWRfYXJyYXkoKSB7XG4gICAgdmFyIGV4cGVjdCA9IG51bGw7XG4gICAgdmFyIHNob3J0Rm9ybSA9IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJhcnJheVwiKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FSUkFZKSB7XG4gICAgICB0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpO1xuICAgICAgZXhwZWN0ID0gXCIpXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3J0Rm9ybSA9IHRydWU7XG4gICAgICBleHBlY3QgPSBcIl1cIjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiAhPT0gZXhwZWN0KSB7XG4gICAgICBpdGVtcyA9IHRoaXMucmVhZF9hcnJheV9wYWlyX2xpc3Qoc2hvcnRGb3JtKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdChleHBlY3QpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQoc2hvcnRGb3JtLCBpdGVtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuIGFycmF5IG9mIGl0ZW1zXG4gICAqIGBgYGVibmZcbiAgICogYXJyYXlfcGFpcl9saXN0IDo6PSBhcnJheV9wYWlyICgnLCcgYXJyYXlfcGFpcj8pKlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfYXJyYXlfcGFpcl9saXN0OiBmdW5jdGlvbiByZWFkX2FycmF5X3BhaXJfbGlzdChzaG9ydEZvcm0pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMucmVhZF9saXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlYWRfYXJyYXlfcGFpcihzaG9ydEZvcm0pO1xuICAgIH0sIFwiLFwiLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYW4gZW50cnlcbiAgICogYXJyYXlfcGFpcjpcbiAgICogIGV4cHIgVF9ET1VCTEVfQVJST1cgZXhwclxuICAgKiAgfCBleHByXG4gICAqICB8IGV4cHIgVF9ET1VCTEVfQVJST1cgJyYnIHZhcmlhYmxlXG4gICAqICB8ICcmJyB2YXJpYWJsZVxuICAgKiAgfCBleHByIFRfRE9VQkxFX0FSUk9XIFRfTElTVCAnKCcgYXJyYXlfcGFpcl9saXN0ICcpJ1xuICAgKiAgfCBUX0xJU1QgJygnIGFycmF5X3BhaXJfbGlzdCAnKSdcbiAgICovXG4gIHJlYWRfYXJyYXlfcGFpcjogZnVuY3Rpb24gcmVhZF9hcnJheV9wYWlyKHNob3J0Rm9ybSkge1xuICAgIGlmICghc2hvcnRGb3JtICYmIHRoaXMudG9rZW4gPT09IFwiKVwiIHx8IHNob3J0Rm9ybSAmJiB0aGlzLnRva2VuID09PSBcIl1cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIixcIikge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShcIm5vb3BcIikoKTtcbiAgICB9XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLm5vZGUoXCJlbnRyeVwiKTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHZhciBieVJlZiA9IGZhbHNlO1xuICAgIHZhciB1bnBhY2sgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBieVJlZiA9IHRydWU7XG4gICAgICB2YWx1ZSA9IHRoaXMucmVhZF92YXJpYWJsZSh0cnVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMTElQU0lTICYmIHRoaXMudmVyc2lvbiA+PSA3MDQpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCImXCIpIHtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB1bnBhY2sgPSB0cnVlO1xuICAgICAgdmFsdWUgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwciA9IHRoaXMucmVhZF9leHByKCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPVUJMRV9BUlJPVykge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAga2V5ID0gZXhwcjtcblxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCImXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBieVJlZiA9IHRydWU7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRfdmFyaWFibGUodHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBleHByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRyeShrZXksIHZhbHVlLCBieVJlZiwgdW5wYWNrKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogcmVhZGluZyBhIGNsYXNzXG4gICAqIGBgYGVibmZcbiAgICogY2xhc3MgOjo9IGNsYXNzX3Njb3BlPyBUX0NMQVNTIFRfU1RSSU5HIChUX0VYVEVORFMgTkFNRVNQQUNFX05BTUUpPyAoVF9JTVBMRU1FTlRTIChOQU1FU1BBQ0VfTkFNRSAnLCcpKiBOQU1FU1BBQ0VfTkFNRSk/ICd7JyBDTEFTU19CT0RZICd9J1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY2xhc3NfZGVjbGFyYXRpb25fc3RhdGVtZW50OiBmdW5jdGlvbiByZWFkX2NsYXNzX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiY2xhc3NcIik7XG4gICAgdmFyIGZsYWcgPSB0aGlzLnJlYWRfY2xhc3NfbW9kaWZpZXJzKCk7IC8vIGdyYWNlZnVsIG1vZGUgOiBpZ25vcmUgdG9rZW4gJiBnbyBuZXh0XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9DTEFTUykge1xuICAgICAgdGhpcy5lcnJvcih0aGlzLnRvay5UX0NMQVNTKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKTtcbiAgICB2YXIgcHJvcE5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcHJvcE5hbWUgPSBwcm9wTmFtZShuYW1lKTtcbiAgICB2YXIgcHJvcEV4dGVuZHMgPSB0aGlzLnJlYWRfZXh0ZW5kc19mcm9tKCk7XG4gICAgdmFyIHByb3BJbXBsZW1lbnRzID0gdGhpcy5yZWFkX2ltcGxlbWVudHNfbGlzdCgpO1xuICAgIHRoaXMuZXhwZWN0KFwie1wiKTtcbiAgICB2YXIgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfY2xhc3NfYm9keSgpO1xuICAgIHJldHVybiByZXN1bHQocHJvcE5hbWUsIHByb3BFeHRlbmRzLCBwcm9wSW1wbGVtZW50cywgYm9keSwgZmxhZyk7XG4gIH0sXG4gIHJlYWRfY2xhc3NfbW9kaWZpZXJzOiBmdW5jdGlvbiByZWFkX2NsYXNzX21vZGlmaWVycygpIHtcbiAgICByZXR1cm4gWzAsIDAsIHRoaXMucmVhZF9jbGFzc19tb2RpZmllcigpXTtcbiAgfSxcbiAgcmVhZF9jbGFzc19tb2RpZmllcjogZnVuY3Rpb24gcmVhZF9jbGFzc19tb2RpZmllcigpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FCU1RSQUNUKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GSU5BTCkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGNsYXNzIGJvZHlcbiAgICogYGBgZWJuZlxuICAgKiAgIGNsYXNzX2JvZHkgOjo9IChtZW1iZXJfZmxhZ3M/IChUX1ZBUiB8IFRfU1RSSU5HIHwgVF9GVU5DVElPTikpKlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY2xhc3NfYm9keTogZnVuY3Rpb24gcmVhZF9jbGFzc19ib2R5KCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBcIn1cIikge1xuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09NTUVOVCkge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfY29tbWVudCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPQ19DT01NRU5UKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmVhZF9kb2NfY29tbWVudCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNoZWNrIFRfVVNFIHRyYWl0XG5cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfVVNFKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5yZWFkX3RyYWl0X3VzZV9zdGF0ZW1lbnQoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyByZWFkIG1lbWJlciBmbGFnc1xuXG5cbiAgICAgIHZhciBmbGFncyA9IHRoaXMucmVhZF9tZW1iZXJfZmxhZ3MoZmFsc2UpOyAvLyBjaGVjayBjb25zdGFudFxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT05TVCkge1xuICAgICAgICB2YXIgY29uc3RhbnRzID0gdGhpcy5yZWFkX2NvbnN0YW50X2xpc3QoZmxhZ3MpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29uc3RhbnRzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGp1bXAgb3ZlciBUX1ZBUiB0aGVuIGxhbmQgb24gVF9WQVJJQUJMRVxuXG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1ZBUikge1xuICAgICAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9WQVJJQUJMRSk7XG4gICAgICAgIGZsYWdzWzBdID0gbnVsbDsgLy8gcHVibGljIChhcyBudWxsKVxuXG4gICAgICAgIGZsYWdzWzFdID0gMDsgLy8gbm9uIHN0YXRpYyB2YXJcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04pIHtcbiAgICAgICAgLy8gcmVhZHMgYSBmdW5jdGlvblxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfZnVuY3Rpb24oZmFsc2UsIGZsYWdzKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfVkFSSUFCTEUgfHwgLy8gc3VwcG9ydCBodHRwczovL3dpa2kucGhwLm5ldC9yZmMvdHlwZWRfcHJvcGVydGllc192MlxuICAgICAgdGhpcy52ZXJzaW9uID49IDcwNCAmJiAodGhpcy50b2tlbiA9PT0gXCI/XCIgfHwgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DQUxMQUJMRSB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FSUkFZIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTkFNRVNQQUNFKSkge1xuICAgICAgICAvLyByZWFkcyBhIHZhcmlhYmxlXG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSB0aGlzLnJlYWRfdmFyaWFibGVfbGlzdChmbGFncyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodmFyaWFibGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJhaXNlIGFuIGVycm9yXG4gICAgICAgIHRoaXMuZXJyb3IoW3RoaXMudG9rLlRfQ09OU1QsIHRoaXMudG9rLlRfVkFSSUFCTEUsIHRoaXMudG9rLlRfRlVOQ1RJT05dKTsgLy8gaWdub3JlIHRva2VuXG5cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIHZhcmlhYmxlIGxpc3RcbiAgICogYGBgZWJuZlxuICAgKiAgdmFyaWFibGVfbGlzdCA6Oj0gKHZhcmlhYmxlX2RlY2xhcmF0aW9uICcsJykqIHZhcmlhYmxlX2RlY2xhcmF0aW9uXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF92YXJpYWJsZV9saXN0OiBmdW5jdGlvbiByZWFkX3ZhcmlhYmxlX2xpc3QoZmxhZ3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwicHJvcGVydHlzdGF0ZW1lbnRcIik7XG4gICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnJlYWRfbGlzdChcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uXG4gICAgICpcbiAgICAgKiBgYGBlYm5mXG4gICAgICogIHZhcmlhYmxlX2RlY2xhcmF0aW9uIDo6PSBUX1ZBUklBQkxFICc9JyBzY2FsYXJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkX3ZhcmlhYmxlX2RlY2xhcmF0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInByb3BlcnR5XCIpO1xuXG4gICAgICB2YXIgX3RoaXMkcmVhZF9vcHRpb25hbF90ID0gdGhpcy5yZWFkX29wdGlvbmFsX3R5cGUoKSxcbiAgICAgICAgICBfdGhpcyRyZWFkX29wdGlvbmFsX3QyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcmVhZF9vcHRpb25hbF90LCAyKSxcbiAgICAgICAgICBudWxsYWJsZSA9IF90aGlzJHJlYWRfb3B0aW9uYWxfdDJbMF0sXG4gICAgICAgICAgdHlwZSA9IF90aGlzJHJlYWRfb3B0aW9uYWxfdDJbMV07XG5cbiAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfVkFSSUFCTEUpO1xuICAgICAgdmFyIHByb3BOYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCkuc3Vic3RyaW5nKDEpOyAvLyBpZ25vcmUgJFxuXG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUobmFtZSk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIjtcIiB8fCB0aGlzLnRva2VuID09PSBcIixcIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0KHByb3BOYW1lLCBudWxsLCBudWxsYWJsZSwgdHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IFwiPVwiKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDgxNVxuICAgICAgICByZXR1cm4gcmVzdWx0KHByb3BOYW1lLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgbnVsbGFibGUsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoW1wiLFwiLCBcIjtcIiwgXCI9XCJdKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChwcm9wTmFtZSwgbnVsbCwgbnVsbGFibGUsIHR5cGUpO1xuICAgICAgfVxuICAgIH0sIFwiLFwiKTtcbiAgICByZXR1cm4gcmVzdWx0KG51bGwsIHByb3BlcnRpZXMsIGZsYWdzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgY29uc3RhbnQgbGlzdFxuICAgKiBgYGBlYm5mXG4gICAqICBjb25zdGFudF9saXN0IDo6PSBUX0NPTlNUIChjb25zdGFudF9kZWNsYXJhdGlvbiAnLCcpKiBjb25zdGFudF9kZWNsYXJhdGlvblxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY29uc3RhbnRfbGlzdDogZnVuY3Rpb24gcmVhZF9jb25zdGFudF9saXN0KGZsYWdzKSB7XG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfQ09OU1QpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiY2xhc3Njb25zdGFudFwiKTtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLnJlYWRfbGlzdChcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGNvbnN0YW50IGRlY2xhcmF0aW9uXG4gICAgICpcbiAgICAgKiBgYGBlYm5mXG4gICAgICogIGNvbnN0YW50X2RlY2xhcmF0aW9uIDo6PSAoVF9TVFJJTkcgfCBJREVOVElGSUVSKSAnPScgZXhwclxuICAgICAqIGBgYFxuICAgICAqIEByZXR1cm4ge0NvbnN0YW50fSBbOmxpbms6XShBU1QubWQjY29uc3RhbnQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZF9jb25zdGFudF9kZWNsYXJhdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJjb25zdGFudFwiKTtcbiAgICAgIHZhciBjb25zdE5hbWUgPSBudWxsO1xuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudmVyc2lvbiA+PSA3MDAgJiYgdGhpcy5pcyhcIklERU5USUZJRVJcIikpIHtcbiAgICAgICAgY29uc3ROYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGNvbnN0TmFtZSA9IGNvbnN0TmFtZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiSURFTlRJRklFUlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiPVwiKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0KGNvbnN0TmFtZSwgdmFsdWUpO1xuICAgIH0sIFwiLFwiKTtcbiAgICByZXR1cm4gcmVzdWx0KG51bGwsIGl0ZW1zLCBmbGFncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWQgbWVtYmVyIGZsYWdzXG4gICAqIEByZXR1cm4gYXJyYXlcbiAgICogIDFzdCBpbmRleCA6IDAgPT4gcHVibGljLCAxID0+IHByb3RlY3RlZCwgMiA9PiBwcml2YXRlXG4gICAqICAybmQgaW5kZXggOiAwID0+IGluc3RhbmNlIG1lbWJlciwgMSA9PiBzdGF0aWMgbWVtYmVyXG4gICAqICAzcmQgaW5kZXggOiAwID0+IG5vcm1hbCwgMSA9PiBhYnN0cmFjdCBtZW1iZXIsIDIgPT4gZmluYWwgbWVtYmVyXG4gICAqL1xuICByZWFkX21lbWJlcl9mbGFnczogZnVuY3Rpb24gcmVhZF9tZW1iZXJfZmxhZ3MoYXNJbnRlcmZhY2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gWy0xLCAtMSwgLTFdO1xuXG4gICAgaWYgKHRoaXMuaXMoXCJUX01FTUJFUl9GTEFHU1wiKSkge1xuICAgICAgdmFyIGlkeCA9IDAsXG4gICAgICAgICAgdmFsID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgICAgICBjYXNlIHRoaXMudG9rLlRfUFVCTElDOlxuICAgICAgICAgICAgaWR4ID0gMDtcbiAgICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgdGhpcy50b2suVF9QUk9URUNURUQ6XG4gICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSB0aGlzLnRvay5UX1BSSVZBVEU6XG4gICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgdmFsID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSB0aGlzLnRvay5UX1NUQVRJQzpcbiAgICAgICAgICAgIGlkeCA9IDE7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHRoaXMudG9rLlRfQUJTVFJBQ1Q6XG4gICAgICAgICAgICBpZHggPSAyO1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSB0aGlzLnRvay5UX0ZJTkFMOlxuICAgICAgICAgICAgaWR4ID0gMjtcbiAgICAgICAgICAgIHZhbCA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc0ludGVyZmFjZSkge1xuICAgICAgICAgIGlmIChpZHggPT0gMCAmJiB2YWwgPT0gMikge1xuICAgICAgICAgICAgLy8gYW4gaW50ZXJmYWNlIGNhbid0IGJlIHByaXZhdGVcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KFt0aGlzLnRvay5UX1BVQkxJQywgdGhpcy50b2suVF9QUk9URUNURURdKTtcbiAgICAgICAgICAgIHZhbCA9IC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaWR4ID09IDIgJiYgdmFsID09IDEpIHtcbiAgICAgICAgICAgIC8vIGFuIGludGVyZmFjZSBjYW50IGJlIGFic3RyYWN0XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICB2YWwgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0W2lkeF0gIT09IC0xKSB7XG4gICAgICAgICAgLy8gYWxyZWFkeSBkZWZpbmVkIGZsYWdcbiAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsICE9PSAtMSkge1xuICAgICAgICAgIHJlc3VsdFtpZHhdID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0aGlzLm5leHQoKS5pcyhcIlRfTUVNQkVSX0ZMQUdTXCIpKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0WzFdID09IC0xKSByZXN1bHRbMV0gPSAwO1xuICAgIGlmIChyZXN1bHRbMl0gPT0gLTEpIHJlc3VsdFsyXSA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogb3B0aW9uYWxfdHlwZTpcbiAgICpcdCAgLy0gZW1wdHkgLS9cdHsgJCQgPSBOVUxMOyB9XG4gICAqICAgfFx0dHlwZV9leHByXHR7ICQkID0gJDE7IH1cbiAgICogO1xuICAgKlxuICAgKiB0eXBlX2V4cHI6XG4gICAqXHRcdHR5cGVcdFx0eyAkJCA9ICQxOyB9XG4gICAqXHR8XHQnPycgdHlwZVx0eyAkJCA9ICQyOyAkJC0+YXR0ciB8PSBaRU5EX1RZUEVfTlVMTEFCTEU7IH1cbiAgICpcdHxcdHVuaW9uX3R5cGVcdHsgJCQgPSAkMTsgfVxuICAgKiA7XG4gICAqXG4gICAqIHR5cGU6XG4gICAqIFx0XHRUX0FSUkFZXHRcdHsgJCQgPSB6ZW5kX2FzdF9jcmVhdGVfZXgoWkVORF9BU1RfVFlQRSwgSVNfQVJSQVkpOyB9XG4gICAqIFx0fFx0VF9DQUxMQUJMRVx0eyAkJCA9IHplbmRfYXN0X2NyZWF0ZV9leChaRU5EX0FTVF9UWVBFLCBJU19DQUxMQUJMRSk7IH1cbiAgICogXHR8XHRuYW1lXHRcdHsgJCQgPSAkMTsgfVxuICAgKiA7XG4gICAqXG4gICAqIHVuaW9uX3R5cGU6XG4gICAqIFx0XHR0eXBlICd8JyB0eXBlICAgICAgIHsgJCQgPSB6ZW5kX2FzdF9jcmVhdGVfbGlzdCgyLCBaRU5EX0FTVF9UWVBFX1VOSU9OLCAkMSwgJDMpOyB9XG4gICAqIFx0fFx0dW5pb25fdHlwZSAnfCcgdHlwZSB7ICQkID0gemVuZF9hc3RfbGlzdF9hZGQoJDEsICQzKTsgfVxuICAgKiA7XG4gICAqL1xuICByZWFkX29wdGlvbmFsX3R5cGU6IGZ1bmN0aW9uIHJlYWRfb3B0aW9uYWxfdHlwZSgpIHtcbiAgICB2YXIgbnVsbGFibGUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIj9cIikge1xuICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnJlYWRfdHlwZSgpO1xuXG4gICAgaWYgKG51bGxhYmxlICYmICF0eXBlKSB7XG4gICAgICB0aGlzLnJhaXNlRXJyb3IoXCJFeHBlY3RpbmcgYSB0eXBlIGRlZmluaXRpb24gY29tYmluZWQgd2l0aCBudWxsYWJsZSBvcGVyYXRvclwiKTtcbiAgICB9XG5cbiAgICBpZiAoIW51bGxhYmxlICYmICF0eXBlKSB7XG4gICAgICByZXR1cm4gW2ZhbHNlLCBudWxsXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJ8XCIpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhciB2YXJpYW50ID0gdGhpcy5yZWFkX3R5cGUoKTtcblxuICAgICAgICBpZiAoIXZhcmlhbnQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoXCJFeHBlY3RpbmcgYSB0eXBlIGRlZmluaXRpb25cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlLnB1c2godmFyaWFudCk7XG4gICAgICB9IHdoaWxlICh0aGlzLnRva2VuID09PSBcInxcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtudWxsYWJsZSwgdHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRpbmcgYW4gaW50ZXJmYWNlXG4gICAqIGBgYGVibmZcbiAgICogaW50ZXJmYWNlIDo6PSBUX0lOVEVSRkFDRSBUX1NUUklORyAoVF9FWFRFTkRTIChOQU1FU1BBQ0VfTkFNRSAnLCcpKiBOQU1FU1BBQ0VfTkFNRSk/ICd7JyBJTlRFUkZBQ0VfQk9EWSAnfSdcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2ludGVyZmFjZV9kZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZ1bmN0aW9uIHJlYWRfaW50ZXJmYWNlX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiaW50ZXJmYWNlXCIpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfSU5URVJGQUNFKSB7XG4gICAgICB0aGlzLmVycm9yKHRoaXMudG9rLlRfSU5URVJGQUNFKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKTtcbiAgICB2YXIgcHJvcE5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcHJvcE5hbWUgPSBwcm9wTmFtZShuYW1lKTtcbiAgICB2YXIgcHJvcEV4dGVuZHMgPSB0aGlzLnJlYWRfaW50ZXJmYWNlX2V4dGVuZHNfbGlzdCgpO1xuICAgIHRoaXMuZXhwZWN0KFwie1wiKTtcbiAgICB2YXIgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfaW50ZXJmYWNlX2JvZHkoKTtcbiAgICByZXR1cm4gcmVzdWx0KHByb3BOYW1lLCBwcm9wRXh0ZW5kcywgYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuIGludGVyZmFjZSBib2R5XG4gICAqIGBgYGVibmZcbiAgICogICBpbnRlcmZhY2VfYm9keSA6Oj0gKG1lbWJlcl9mbGFncz8gKFRfQ09OU1QgfCBUX0ZVTkNUSU9OKSkqXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9pbnRlcmZhY2VfYm9keTogZnVuY3Rpb24gcmVhZF9pbnRlcmZhY2VfYm9keSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gXCJ9XCIpIHtcbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NPTU1FTlQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yZWFkX2NvbW1lbnQoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET0NfQ09NTUVOVCkge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfZG9jX2NvbW1lbnQoKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyByZWFkIG1lbWJlciBmbGFnc1xuXG5cbiAgICAgIHZhciBmbGFncyA9IHRoaXMucmVhZF9tZW1iZXJfZmxhZ3ModHJ1ZSk7IC8vIGNoZWNrIGNvbnN0YW50XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09IHRoaXMudG9rLlRfQ09OU1QpIHtcbiAgICAgICAgdmFyIGNvbnN0YW50cyA9IHRoaXMucmVhZF9jb25zdGFudF9saXN0KGZsYWdzKTtcblxuICAgICAgICBpZiAodGhpcy5leHBlY3QoXCI7XCIpKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGNvbnN0YW50cyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04pIHtcbiAgICAgICAgLy8gcmVhZHMgYSBmdW5jdGlvblxuICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5yZWFkX2Z1bmN0aW9uX2RlY2xhcmF0aW9uKDIsIGZsYWdzKTtcbiAgICAgICAgbWV0aG9kLnBhcnNlRmxhZ3MoZmxhZ3MpO1xuICAgICAgICByZXN1bHQucHVzaChtZXRob2QpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmFpc2UgYW4gZXJyb3JcbiAgICAgICAgdGhpcy5lcnJvcihbdGhpcy50b2suVF9DT05TVCwgdGhpcy50b2suVF9GVU5DVElPTl0pO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3QoXCJ9XCIpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkaW5nIGEgdHJhaXRcbiAgICogYGBgZWJuZlxuICAgKiB0cmFpdCA6Oj0gVF9UUkFJVCBUX1NUUklORyAoVF9FWFRFTkRTIChOQU1FU1BBQ0VfTkFNRSAnLCcpKiBOQU1FU1BBQ0VfTkFNRSk/ICd7JyBGVU5DVElPTiogJ30nXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF90cmFpdF9kZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZ1bmN0aW9uIHJlYWRfdHJhaXRfZGVjbGFyYXRpb25fc3RhdGVtZW50KCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJ0cmFpdFwiKTsgLy8gZ3JhY2VmdWwgbW9kZSA6IGlnbm9yZSB0b2tlbiAmIGdvIG5leHRcblxuICAgIGlmICh0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX1RSQUlUKSB7XG4gICAgICB0aGlzLmVycm9yKHRoaXMudG9rLlRfVFJBSVQpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgIHZhciBwcm9wTmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lKG5hbWUpO1xuICAgIHRoaXMuZXhwZWN0KFwie1wiKTtcbiAgICB2YXIgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfY2xhc3NfYm9keSgpO1xuICAgIHJldHVybiByZXN1bHQocHJvcE5hbWUsIGJvZHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkaW5nIGEgdXNlIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqIHRyYWl0X3VzZV9zdGF0ZW1lbnQgOjo9IG5hbWVzcGFjZV9uYW1lICgnLCcgbmFtZXNwYWNlX25hbWUpKiAoJ3snIHRyYWl0X3VzZV9hbGlhcyAnfScpP1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfdHJhaXRfdXNlX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF90cmFpdF91c2Vfc3RhdGVtZW50KCkge1xuICAgIC8vIGRlZmluZXMgdXNlIHN0YXRlbWVudHNcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcInRyYWl0dXNlXCIpO1xuICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfVVNFKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgdHJhaXRzID0gW3RoaXMucmVhZF9uYW1lc3BhY2VfbmFtZSgpXTtcbiAgICB2YXIgYWRhcHRhdGlvbnMgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gPT09IFwiLFwiKSB7XG4gICAgICB0cmFpdHMucHVzaCh0aGlzLm5leHQoKS5yZWFkX25hbWVzcGFjZV9uYW1lKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIntcIikge1xuICAgICAgYWRhcHRhdGlvbnMgPSBbXTsgLy8gZGVmaW5lcyBhbGlhcyBzdGF0ZW1lbnRzXG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50b2tlbiAhPT0gdGhpcy5FT0YpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IFwifVwiKSBicmVhaztcbiAgICAgICAgYWRhcHRhdGlvbnMucHVzaCh0aGlzLnJlYWRfdHJhaXRfdXNlX2FsaWFzKCkpO1xuICAgICAgICB0aGlzLmV4cGVjdChcIjtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIn1cIikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUodHJhaXRzLCBhZGFwdGF0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRpbmcgdHJhaXQgYWxpYXNcbiAgICogYGBgZWJuZlxuICAgKiB0cmFpdF91c2VfYWxpYXMgOjo9IG5hbWVzcGFjZV9uYW1lICggVF9ET1VCTEVfQ09MT04gVF9TVFJJTkcgKT8gKFRfSU5TVEVBRE9GIG5hbWVzcGFjZV9uYW1lKSB8IChUX0FTIG1lbWJlcl9mbGFncz8gVF9TVFJJTkcpXG4gICAqIGBgYFxuICAgKiBuYW1lIGxpc3QgOiBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wzMDNcbiAgICogdHJhaXQgYWRhcHRhdGlvbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDc0MlxuICAgKi9cbiAgcmVhZF90cmFpdF91c2VfYWxpYXM6IGZ1bmN0aW9uIHJlYWRfdHJhaXRfdXNlX2FsaWFzKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgdmFyIHRyYWl0ID0gbnVsbDtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgaWYgKHRoaXMuaXMoXCJJREVOVElGSUVSXCIpKSB7XG4gICAgICBtZXRob2QgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbWV0aG9kID0gbWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSB0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORyB8fCB0aGlzLnZlcnNpb24gPj0gNzAwICYmIHRoaXMuaXMoXCJJREVOVElGSUVSXCIpKSB7XG4gICAgICAgICAgdHJhaXQgPSBtZXRob2Q7XG4gICAgICAgICAgbWV0aG9kID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcblxuICAgICAgICAgIHZhciBfbWV0aG9kTmFtZSA9IHRoaXMudGV4dCgpO1xuXG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbWV0aG9kID0gbWV0aG9kKF9tZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlcnQgaWRlbnRpZmllciBhcyBzdHJpbmdcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kLm5hbWU7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgdHJhaXQgcHJlY2VkZW5jZVxuXG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9JTlNURUFET0YpIHtcbiAgICAgIHJldHVybiBub2RlKFwidHJhaXRwcmVjZWRlbmNlXCIsIHRyYWl0LCBtZXRob2QsIHRoaXMubmV4dCgpLnJlYWRfbmFtZV9saXN0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9BUykge1xuICAgICAgLy8gaGFuZGxlIHRyYWl0IGFsaWFzXG4gICAgICB2YXIgZmxhZ3MgPSBudWxsO1xuICAgICAgdmFyIGFsaWFzID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMubmV4dCgpLmlzKFwiVF9NRU1CRVJfRkxBR1NcIikpIHtcbiAgICAgICAgZmxhZ3MgPSB0aGlzLnJlYWRfbWVtYmVyX2ZsYWdzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORyB8fCB0aGlzLnZlcnNpb24gPj0gNzAwICYmIHRoaXMuaXMoXCJJREVOVElGSUVSXCIpKSB7XG4gICAgICAgIGFsaWFzID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGFsaWFzID0gYWxpYXMobmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWdzID09PSBmYWxzZSkge1xuICAgICAgICAvLyBubyB2aXNpYmlsaXR5IGZsYWdzIGFuZCBubyBuYW1lID0+IHRvbyBiYWRcbiAgICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZShcInRyYWl0YWxpYXNcIiwgdHJhaXQsIG1ldGhvZCwgYWxpYXMsIGZsYWdzKTtcbiAgICB9IC8vIGhhbmRsZSBlcnJvcnNcblxuXG4gICAgdGhpcy5leHBlY3QoW3RoaXMudG9rLlRfQVMsIHRoaXMudG9rLlRfSU5TVEVBRE9GXSk7XG4gICAgcmV0dXJuIG5vZGUoXCJ0cmFpdGFsaWFzXCIsIHRyYWl0LCBtZXRob2QsIG51bGwsIG51bGwpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiAgQ29tbWVudHMgd2l0aCAvLyBvciAjIG9yIC8gKiAuLi4gKiAvXG4gICAqL1xuICByZWFkX2NvbW1lbnQ6IGZ1bmN0aW9uIHJlYWRfY29tbWVudCgpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmFzdC5wcmVwYXJlKHRleHQuc3Vic3RyaW5nKDAsIDIpID09PSBcIi8qXCIgPyBcImNvbW1lbnRibG9ja1wiIDogXCJjb21tZW50bGluZVwiLCBudWxsLCB0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0OyAvLyBoYW5kbGUgbG9jYXRpb24gb24gY29tbWVudFxuXG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXY7XG4gICAgdGhpcy5wcmV2ID0gW3RoaXMubGV4ZXIueXlsbG9jLmxhc3RfbGluZSwgdGhpcy5sZXhlci55eWxsb2MubGFzdF9jb2x1bW4sIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgICB0aGlzLmxleCgpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCh0ZXh0KTtcbiAgICByZXN1bHQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ29tbWVudHMgd2l0aCAvICoqIC4uLiAqIC9cbiAgICovXG4gIHJlYWRfZG9jX2NvbW1lbnQ6IGZ1bmN0aW9uIHJlYWRfZG9jX2NvbW1lbnQoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuYXN0LnByZXBhcmUoXCJjb21tZW50YmxvY2tcIiwgbnVsbCwgdGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldDtcbiAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2O1xuICAgIHRoaXMucHJldiA9IFt0aGlzLmxleGVyLnl5bGxvYy5sYXN0X2xpbmUsIHRoaXMubGV4ZXIueXlsbG9jLmxhc3RfY29sdW1uLCB0aGlzLmxleGVyLm9mZnNldF07XG4gICAgdGhpcy5sZXgoKTtcbiAgICByZXN1bHQgPSByZXN1bHQodGV4dCk7XG4gICAgcmVzdWx0Lm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVhZF9leHByOiBmdW5jdGlvbiByZWFkX2V4cHIoZXhwcikge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIkBcIikge1xuICAgICAgaWYgKCFleHByKSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdChcInNpbGVudFwiLCBleHByKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgIGV4cHIgPSB0aGlzLnJlYWRfZXhwcl9pdGVtKCk7XG4gICAgfSAvLyBiaW5hcnkgb3BlcmF0aW9uc1xuXG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJ8XCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJ8XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCImXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCImXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJeXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJeXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIuXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIuXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIrXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIrXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCItXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCItXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIqXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIqXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIvXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIvXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIlXCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIlXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9QT1cpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIqKlwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU0wpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI8PFwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1IpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI+PlwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7IC8vIG1vcmUgYmluYXJ5IG9wZXJhdGlvbnMgKGZvcm1lcmx5IGJvb2wpXG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9CT09MRUFOX09SKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwifHxcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0xPR0lDQUxfT1IpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJvclwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQk9PTEVBTl9BTkQpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCImJlwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTE9HSUNBTF9BTkQpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJhbmRcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0xPR0lDQUxfWE9SKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwieG9yXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9JU19JREVOVElDQUwpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI9PT1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX05PVF9JREVOVElDQUwpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCIhPT1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX0VRVUFMKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwiPT1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX05PVF9FUVVBTCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIiE9XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI8XCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI8XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI+XCIpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI+XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9JU19TTUFMTEVSX09SX0VRVUFMKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwiPD1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX0dSRUFURVJfT1JfRVFVQUwpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI+PVwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1BBQ0VTSElQKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwiPD0+XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lOU1RBTkNFT0YpIHtcbiAgICAgIGV4cHIgPSByZXN1bHQoXCJiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfY2xhc3NfbmFtZV9yZWZlcmVuY2UoKSk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuICE9PSBcIjtcIiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0lOTElORV9IVE1MICYmIHRoaXMudG9rZW4gIT09IHRoaXMuRU9GKSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLnJlYWRfZXhwcihleHByKTtcbiAgICAgIH1cbiAgICB9IC8vIGV4dHJhIG9wZXJhdGlvbnMgOlxuICAgIC8vICR1c2VybmFtZSA9ICRfR0VUWyd1c2VyJ10gPz8gJ25vYm9keSc7XG5cblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NPQUxFU0NFKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwiPz9cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpOyAvLyBleHRyYSBvcGVyYXRpb25zIDpcbiAgICAvLyAkdXNlcm5hbWUgPSAkX0dFVFsndXNlciddID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiP1wiKSB7XG4gICAgICB2YXIgdHJ1ZUFyZyA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiAhPT0gXCI6XCIpIHtcbiAgICAgICAgdHJ1ZUFyZyA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0KFwiOlwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiByZXN1bHQoXCJyZXRpZlwiLCBleHByLCB0cnVlQXJnLCB0aGlzLnJlYWRfZXhwcigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2VlICMxOTNcbiAgICAgIHJlc3VsdC5kZXN0cm95KGV4cHIpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGNhc3QgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZF9leHByX2Nhc3Q6IGZ1bmN0aW9uIHJlYWRfZXhwcl9jYXN0KHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlKFwiY2FzdFwiKSh0eXBlLCB0aGlzLnRleHQoKSwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgaXNzZXQgdmFyaWFibGVcbiAgICovXG4gIHJlYWRfaXNzZXRfdmFyaWFibGU6IGZ1bmN0aW9uIHJlYWRfaXNzZXRfdmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZF9leHByKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGlzc2V0IHZhcmlhYmxlc1xuICAgKi9cbiAgcmVhZF9pc3NldF92YXJpYWJsZXM6IGZ1bmN0aW9uIHJlYWRfaXNzZXRfdmFyaWFibGVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRfZnVuY3Rpb25fbGlzdCh0aGlzLnJlYWRfaXNzZXRfdmFyaWFibGUsIFwiLFwiKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZWFkcyBpbnRlcm5hbCBQSFAgZnVuY3Rpb25zXG4gICAqL1xuICByZWFkX2ludGVybmFsX2Z1bmN0aW9uc19pbl95YWNjOiBmdW5jdGlvbiByZWFkX2ludGVybmFsX2Z1bmN0aW9uc19pbl95YWNjKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0aGlzLnRva2VuKSB7XG4gICAgICBjYXNlIHRoaXMudG9rLlRfSVNTRVQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJpc3NldFwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFyaWFibGVzID0gdGhpcy5yZWFkX2lzc2V0X3ZhcmlhYmxlcygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KHZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9FTVBUWTpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImVtcHR5XCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5yZWFkX2V4cHIoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0lOQ0xVREU6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImluY2x1ZGVcIikoZmFsc2UsIGZhbHNlLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5DTFVERV9PTkNFOlxuICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJpbmNsdWRlXCIpKHRydWUsIGZhbHNlLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRVZBTDpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImV2YWxcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkuZXhwZWN0KFwiKFwiKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnJlYWRfZXhwcigpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KGV4cHIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfUkVRVUlSRTpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwiaW5jbHVkZVwiKShmYWxzZSwgdHJ1ZSwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1JFUVVJUkVfT05DRTpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwiaW5jbHVkZVwiKSh0cnVlLCB0cnVlLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIG9wdGlvbmFsIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRfb3B0aW9uYWxfZXhwcjogZnVuY3Rpb24gcmVhZF9vcHRpb25hbF9leHByKHN0b3BUb2tlbikge1xuICAgIGlmICh0aGlzLnRva2VuICE9PSBzdG9wVG9rZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfZXhwcigpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBleGl0IGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRfZXhpdF9leHByOiBmdW5jdGlvbiByZWFkX2V4aXRfZXhwcigpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucmVhZF9vcHRpb25hbF9leHByKFwiKVwiKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiBSZWFkcyBhbiBleHByZXNzaW9uXG4gICAqICBleHByIDo6PSBAdG9kb1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfZXhwcl9pdGVtOiBmdW5jdGlvbiByZWFkX2V4cHJfaXRlbSgpIHtcbiAgICB2YXIgcmVzdWx0LCBleHByO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIitcIikgcmV0dXJuIHRoaXMubm9kZShcInVuYXJ5XCIpKFwiK1wiLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiLVwiKSByZXR1cm4gdGhpcy5ub2RlKFwidW5hcnlcIikoXCItXCIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIhXCIpIHJldHVybiB0aGlzLm5vZGUoXCJ1bmFyeVwiKShcIiFcIiwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIn5cIikgcmV0dXJuIHRoaXMubm9kZShcInVuYXJ5XCIpKFwiflwiLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgIGV4cHIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgIGV4cHIucGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgdGhpcy5leHBlY3QoXCIpXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVyZWZlcmVuY2FibGUoZXhwcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiYFwiKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMDQ4XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX2VuY2Fwc2VkX3N0cmluZyhcImBcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTElTVCkge1xuICAgICAgdmFyIGFzc2lnbiA9IG51bGw7XG4gICAgICB2YXIgaXNJbm5lciA9IHRoaXMuaW5uZXJMaXN0O1xuICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwibGlzdFwiKTtcblxuICAgICAgaWYgKCFpc0lubmVyKSB7XG4gICAgICAgIGFzc2lnbiA9IHRoaXMubm9kZShcImFzc2lnblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pbm5lckxpc3QpIHRoaXMuaW5uZXJMaXN0ID0gdHJ1ZTsgLy8gcmVhZHMgaW5uZXIgaXRlbXNcblxuICAgICAgdmFyIGFzc2lnbkxpc3QgPSB0aGlzLnJlYWRfYXJyYXlfcGFpcl9saXN0KGZhbHNlKTtcblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gLy8gY2hlY2sgaWYgY29udGFpbnMgYXQgbGVhc3Qgb25lIGFzc2lnbm1lbnQgc3RhdGVtZW50XG5cblxuICAgICAgdmFyIGhhc0l0ZW0gPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3NpZ25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhc3NpZ25MaXN0W2ldICE9PSBudWxsICYmIGFzc2lnbkxpc3RbaV0ua2luZCAhPT0gXCJub29wXCIpIHtcbiAgICAgICAgICBoYXNJdGVtID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhc0l0ZW0pIHtcbiAgICAgICAgdGhpcy5yYWlzZUVycm9yKFwiRmF0YWwgRXJyb3IgOiAgQ2Fubm90IHVzZSBlbXB0eSBsaXN0IG9uIGxpbmUgXCIgKyB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lKTtcbiAgICAgIH0gLy8gaGFuZGxlcyB0aGUgbm9kZSByZXNvbHV0aW9uXG5cblxuICAgICAgaWYgKCFpc0lubmVyKSB7XG4gICAgICAgIHRoaXMuaW5uZXJMaXN0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiPVwiKSkge1xuICAgICAgICAgIHJldHVybiBhc3NpZ24ocmVzdWx0KGFzc2lnbkxpc3QsIGZhbHNlKSwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiPVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlcnJvciBmYWxsYmFjayA6IGxpc3QoJGEsICRiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KGFzc2lnbkxpc3QsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChhc3NpZ25MaXN0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ0xPTkUpIHJldHVybiB0aGlzLm5vZGUoXCJjbG9uZVwiKSh0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTkM6XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoXCJwcmVcIikoXCIrXCIsIHRoaXMubmV4dCgpLnJlYWRfdmFyaWFibGUoZmFsc2UsIGZhbHNlKSk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9ERUM6XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoXCJwcmVcIikoXCItXCIsIHRoaXMubmV4dCgpLnJlYWRfdmFyaWFibGUoZmFsc2UsIGZhbHNlKSk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9ORVc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfbmV3X2V4cHIoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0lTU0VUOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0VNUFRZOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0lOQ0xVREU6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5DTFVERV9PTkNFOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0VWQUw6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfUkVRVUlSRTpcbiAgICAgIGNhc2UgdGhpcy50b2suVF9SRVFVSVJFX09OQ0U6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfaW50ZXJuYWxfZnVuY3Rpb25zX2luX3lhY2MoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0lOVF9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcImludFwiKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0RPVUJMRV9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcImZsb2F0XCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfU1RSSU5HX0NBU1Q6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZXhwcl9jYXN0KHRoaXMudGV4dCgpLmluZGV4T2YoXCJiaW5hcnlcIikgIT09IC0xID8gXCJiaW5hcnlcIiA6IFwic3RyaW5nXCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQVJSQVlfQ0FTVDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9leHByX2Nhc3QoXCJhcnJheVwiKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX09CSkVDVF9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcIm9iamVjdFwiKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0JPT0xfQ0FTVDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9leHByX2Nhc3QoXCJib29sXCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVU5TRVRfQ0FTVDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9leHByX2Nhc3QoXCJ1bnNldFwiKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0VYSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdXNlRGllID0gdGhpcy5sZXhlci55eXRleHQudG9Mb3dlckNhc2UoKSA9PT0gXCJkaWVcIjtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJleGl0XCIpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5yZWFkX2V4aXRfZXhwcigpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoZXhwcmVzc2lvbiwgdXNlRGllKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfUFJJTlQ6XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUoXCJwcmludFwiKSh0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgICAvLyBUX1lJRUxEIChleHByIChUX0RPVUJMRV9BUlJPVyBleHByKT8pP1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfWUlFTEQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcInlpZWxkXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLmlzKFwiRVhQUlwiKSkge1xuICAgICAgICAgICAgLy8gcmVhZHMgdGhlIHlpZWxkIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRfZXhwcigpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET1VCTEVfQVJST1cpIHtcbiAgICAgICAgICAgICAgLy8gcmVhZHMgdGhlIHlpZWxkIHJldHVybmVkIGtleVxuICAgICAgICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0KHZhbHVlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAvLyBUX1lJRUxEX0ZST00gZXhwclxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfWUlFTERfRlJPTTpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwieWllbGRmcm9tXCIpO1xuICAgICAgICBleHByID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQoZXhwcik7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9GTjpcbiAgICAgIGNhc2UgdGhpcy50b2suVF9GVU5DVElPTjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9pbmxpbmVfZnVuY3Rpb24oKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1NUQVRJQzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBiYWNrdXAgPSBbdGhpcy50b2tlbiwgdGhpcy5sZXhlci5nZXRTdGF0ZSgpXTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0ZVTkNUSU9OIHx8IHRoaXMudmVyc2lvbiA+PSA3MDQgJiYgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GTikge1xuICAgICAgICAgICAgLy8gaGFuZGxlcyBzdGF0aWMgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRfaW5saW5lX2Z1bmN0aW9uKFswLCAxLCAwXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJvbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmxleGVyLnRva2Vucy5wdXNoKGJhY2t1cCk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IC8vIFNDQUxBUiB8IFZBUklBQkxFXG5cblxuICAgIGlmICh0aGlzLmlzKFwiVkFSSUFCTEVcIikpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubm9kZSgpO1xuICAgICAgZXhwciA9IHRoaXMucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w4NzdcbiAgICAgIC8vIHNob3VsZCBhY2NlcHQgb25seSBhIHZhcmlhYmxlXG5cbiAgICAgIHZhciBpc0NvbnN0ID0gZXhwci5raW5kID09PSBcImlkZW50aWZpZXJcIiB8fCBleHByLmtpbmQgPT09IFwic3RhdGljbG9va3VwXCIgJiYgZXhwci5vZmZzZXQua2luZCA9PT0gXCJpZGVudGlmaWVyXCI7IC8vIFZBUklBQkxFUyBTUEVDSUZJQyBPUEVSQVRJT05TXG5cbiAgICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PSBcIiZcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2Fzc2lnbnJlZihyZXN1bHQsIGV4cHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMucmVhZF9leHByKCksIFwiPVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIG9wZXJhdGlvbnMgOlxuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9QTFVTX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCIrPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfTUlOVVNfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIi09XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9NVUxfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIio9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9QT1dfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIioqPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfRElWX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCIvPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfQ09OQ0FUX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCIuPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfTU9EX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCIlPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfQU5EX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCImPVwiKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfT1JfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcInw9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9YT1JfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIl49XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9TTF9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiPDw9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9TUl9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiPj49XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9DT0FMRVNDRV9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiPz89XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9JTkM6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwicG9zdFwiLCBcIitcIiwgZXhwcik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX0RFQzpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJwb3N0XCIsIFwiLVwiLCBleHByKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHNlZSAjMTkzXG4gICAgICAgICAgcmVzdWx0LmRlc3Ryb3koZXhwcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzKFwiU0NBTEFSXCIpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLm5vZGUoKTtcbiAgICAgIGV4cHIgPSB0aGlzLnJlYWRfc2NhbGFyKCk7XG5cbiAgICAgIGlmIChleHByLmtpbmQgPT09IFwiYXJyYXlcIiAmJiBleHByLnNob3J0Rm9ybSAmJiB0aGlzLnRva2VuID09PSBcIj1cIikge1xuICAgICAgICAvLyBsaXN0IGFzc2lnblxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubm9kZShcImxpc3RcIikoZXhwci5pdGVtcywgdHJ1ZSk7XG4gICAgICAgIGlmIChleHByLmxvYykgbGlzdC5sb2MgPSBleHByLmxvYztcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgbGlzdCwgcmlnaHQsIFwiPVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNlZSAjMTg5IC0gc3dhcCBkb2NzIG9uIG5vZGVzXG4gICAgICAgIHJlc3VsdC5kZXN0cm95KGV4cHIpO1xuICAgICAgfSAvLyBjbGFzc2ljIGFycmF5XG5cblxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRGVyZWZlcmVuY2FibGUoZXhwcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXJyb3IoXCJFWFBSXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSAvLyByZXR1cm5zIHZhcmlhYmxlIHwgc2NhbGFyXG5cblxuICAgIHJldHVybiBleHByO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhc3NpZ25tZW50XG4gICAqIEBwYXJhbSB7Kn0gbGVmdFxuICAgKi9cbiAgcmVhZF9hc3NpZ25yZWY6IGZ1bmN0aW9uIHJlYWRfYXNzaWducmVmKHJlc3VsdCwgbGVmdCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciByaWdodDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05FVykge1xuICAgICAgaWYgKHRoaXMudmVyc2lvbiA+PSA3MDApIHtcbiAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgfVxuXG4gICAgICByaWdodCA9IHRoaXMucmVhZF9uZXdfZXhwcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IHRoaXMucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25yZWZcIiwgbGVmdCwgcmlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBpbmxpbmVfZnVuY3Rpb246XG4gICAqIFx0XHRmdW5jdGlvbiByZXR1cm5zX3JlZiBiYWNrdXBfZG9jX2NvbW1lbnQgJygnIHBhcmFtZXRlcl9saXN0ICcpJyBsZXhpY2FsX3ZhcnMgcmV0dXJuX3R5cGVcbiAgICogXHRcdGJhY2t1cF9mbl9mbGFncyAneycgaW5uZXJfc3RhdGVtZW50X2xpc3QgJ30nIGJhY2t1cF9mbl9mbGFnc1xuICAgKiBcdFx0XHR7ICQkID0gemVuZF9hc3RfY3JlYXRlX2RlY2woWkVORF9BU1RfQ0xPU1VSRSwgJDIgfCAkMTMsICQxLCAkMyxcbiAgICogXHRcdFx0XHQgIHplbmRfc3RyaW5nX2luaXQoXCJ7Y2xvc3VyZX1cIiwgc2l6ZW9mKFwie2Nsb3N1cmV9XCIpIC0gMSwgMCksXG4gICAqIFx0XHRcdFx0ICAkNSwgJDcsICQxMSwgJDgpOyBDRyhleHRyYV9mbl9mbGFncykgPSAkOTsgfVxuICAgKiBcdHxcdGZuIHJldHVybnNfcmVmICcoJyBwYXJhbWV0ZXJfbGlzdCAnKScgcmV0dXJuX3R5cGUgYmFja3VwX2RvY19jb21tZW50IFRfRE9VQkxFX0FSUk9XIGJhY2t1cF9mbl9mbGFncyBiYWNrdXBfbGV4X3BvcyBleHByIGJhY2t1cF9mbl9mbGFnc1xuICAgKiBcdFx0XHR7ICQkID0gemVuZF9hc3RfY3JlYXRlX2RlY2woWkVORF9BU1RfQVJST1dfRlVOQywgJDIgfCAkMTIsICQxLCAkNyxcbiAgICogXHRcdFx0XHQgIHplbmRfc3RyaW5nX2luaXQoXCJ7Y2xvc3VyZX1cIiwgc2l6ZW9mKFwie2Nsb3N1cmV9XCIpIC0gMSwgMCksICQ0LCBOVUxMLFxuICAgKiBcdFx0XHRcdCAgemVuZF9hc3RfY3JlYXRlKFpFTkRfQVNUX1JFVFVSTiwgJDExKSwgJDYpO1xuICAgKiBcdFx0XHRcdCAgKCh6ZW5kX2FzdF9kZWNsICopICQkKS0+bGV4X3BvcyA9ICQxMDtcbiAgICogXHRcdFx0XHQgIENHKGV4dHJhX2ZuX2ZsYWdzKSA9ICQ5OyB9ICAgKlxuICAgKi9cbiAgcmVhZF9pbmxpbmVfZnVuY3Rpb246IGZ1bmN0aW9uIHJlYWRfaW5saW5lX2Z1bmN0aW9uKGZsYWdzKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfZnVuY3Rpb24odHJ1ZSwgZmxhZ3MpO1xuICAgIH0gLy8gaW50cm9kdWNlZCBpbiBQSFAgNy40XG5cblxuICAgIGlmICghdGhpcy52ZXJzaW9uID49IDcwNCkge1xuICAgICAgdGhpcy5yYWlzZUVycm9yKFwiQXJyb3cgRnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICB9IC8vIGFzIGFuIGFycm93ZnVuY1xuXG5cbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcImFycm93ZnVuY1wiKTsgLy8gZWF0IFRfRk5cblxuICAgIGlmICh0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0ZOKSkgdGhpcy5uZXh0KCk7IC8vIGNoZWNrIHRoZSAmXG5cbiAgICB2YXIgaXNSZWYgPSB0aGlzLmlzX3JlZmVyZW5jZSgpOyAvLyAuLi5cblxuICAgIGlmICh0aGlzLmV4cGVjdChcIihcIikpIHRoaXMubmV4dCgpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLnJlYWRfcGFyYW1ldGVyX2xpc3QoKTtcbiAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB0aGlzLm5leHQoKTtcbiAgICB2YXIgbnVsbGFibGUgPSBmYWxzZTtcbiAgICB2YXIgcmV0dXJuVHlwZSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PT0gXCI/XCIpIHtcbiAgICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuVHlwZSA9IHRoaXMucmVhZF90eXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRE9VQkxFX0FSUk9XKSkgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGJvZHkgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgIHJldHVybiBub2RlKHBhcmFtcywgaXNSZWYsIGJvZHksIHJldHVyblR5cGUsIG51bGxhYmxlLCBmbGFncyA/IHRydWUgOiBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogICAgbmV3X2V4cHIgOjo9IFRfTkVXIChuYW1lc3BhY2VfbmFtZSBmdW5jdGlvbl9hcmd1bWVudF9saXN0KSB8IChUX0NMQVNTIC4uLiBjbGFzcyBkZWNsYXJhdGlvbilcbiAgICogYGBgXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDg1MFxuICAgKi9cbiAgcmVhZF9uZXdfZXhwcjogZnVuY3Rpb24gcmVhZF9uZXdfZXhwcigpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwibmV3XCIpO1xuICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfTkVXKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ0xBU1MpIHtcbiAgICAgIHZhciB3aGF0ID0gdGhpcy5ub2RlKFwiY2xhc3NcIik7IC8vIEFubm9ueW1vdXMgY2xhc3MgZGVjbGFyYXRpb25cblxuICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09PSBcIihcIikge1xuICAgICAgICBhcmdzID0gdGhpcy5yZWFkX2FyZ3VtZW50X2xpc3QoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BFeHRlbmRzID0gdGhpcy5yZWFkX2V4dGVuZHNfZnJvbSgpO1xuICAgICAgdmFyIHByb3BJbXBsZW1lbnRzID0gdGhpcy5yZWFkX2ltcGxlbWVudHNfbGlzdCgpO1xuICAgICAgdmFyIGJvZHkgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5leHBlY3QoXCJ7XCIpKSB7XG4gICAgICAgIGJvZHkgPSB0aGlzLm5leHQoKS5yZWFkX2NsYXNzX2JvZHkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCh3aGF0KG51bGwsIHByb3BFeHRlbmRzLCBwcm9wSW1wbGVtZW50cywgYm9keSwgWzAsIDAsIDBdKSwgYXJncyk7XG4gICAgfSAvLyBBbHJlYWR5IGV4aXN0aW5nIGNsYXNzXG5cblxuICAgIHZhciBuYW1lID0gdGhpcy5yZWFkX25ld19jbGFzc19uYW1lKCk7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgIGFyZ3MgPSB0aGlzLnJlYWRfYXJndW1lbnRfbGlzdCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQobmFtZSwgYXJncyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgY2xhc3MgbmFtZVxuICAgKiBgYGBlYm5mXG4gICAqIHJlYWRfbmV3X2NsYXNzX25hbWUgOjo9IG5hbWVzcGFjZV9uYW1lIHwgdmFyaWFibGVcbiAgICogYGBgXG4gICAqL1xuICByZWFkX25ld19jbGFzc19uYW1lOiBmdW5jdGlvbiByZWFkX25ld19jbGFzc19uYW1lKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05TX1NFUEFSQVRPUiB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORyB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05BTUVTUEFDRSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVhZF9uYW1lc3BhY2VfbmFtZSh0cnVlKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9zdGF0aWNfZ2V0dGVyKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzKFwiVkFSSUFCTEVcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfdmFyaWFibGUodHJ1ZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdChbdGhpcy50b2suVF9TVFJJTkcsIFwiVkFSSUFCTEVcIl0pO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlRGVyZWZlcmVuY2FibGU6IGZ1bmN0aW9uIGhhbmRsZURlcmVmZXJlbmNhYmxlKGV4cHIpIHtcbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gdGhpcy5FT0YpIHtcbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX09CSkVDVF9PUEVSQVRPUiB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPVUJMRV9DT0xPTikge1xuICAgICAgICBleHByID0gdGhpcy5yZWN1cnNpdmVfdmFyaWFibGVfY2hhaW5fc2NhbihleHByLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NVUkxZX09QRU4gfHwgdGhpcy50b2tlbiA9PT0gXCJbXCIpIHtcbiAgICAgICAgZXhwciA9IHRoaXMucmVhZF9kZXJlZmVyZW5jYWJsZShleHByKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTExOFxuICAgICAgICBleHByID0gdGhpcy5ub2RlKFwiY2FsbFwiKShleHByLCB0aGlzLnJlYWRfYXJndW1lbnRfbGlzdCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBjaGVja3MgaWYgY3VycmVudCB0b2tlbiBpcyBhIHJlZmVyZW5jZSBrZXl3b3JkXG4gICAqL1xuICBpc19yZWZlcmVuY2U6IGZ1bmN0aW9uIGlzX3JlZmVyZW5jZSgpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PSBcIiZcIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrcyBpZiBjdXJyZW50IHRva2VuIGlzIGEgdmFyaWFkaWMga2V5d29yZFxuICAgKi9cbiAgaXNfdmFyaWFkaWM6IGZ1bmN0aW9uIGlzX3ZhcmlhZGljKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMTElQU0lTKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZGluZyBhIGZ1bmN0aW9uXG4gICAqIGBgYGVibmZcbiAgICogZnVuY3Rpb24gOjo9IGZ1bmN0aW9uX2RlY2xhcmF0aW9uIGNvZGVfYmxvY2tcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2Z1bmN0aW9uOiBmdW5jdGlvbiByZWFkX2Z1bmN0aW9uKGNsb3N1cmUsIGZsYWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWFkX2Z1bmN0aW9uX2RlY2xhcmF0aW9uKGNsb3N1cmUgPyAxIDogZmxhZyA/IDIgOiAwLCBmbGFnICYmIGZsYWdbMV0gPT09IDEpO1xuXG4gICAgaWYgKGZsYWcgJiYgZmxhZ1syXSA9PSAxKSB7XG4gICAgICAvLyBhYnN0cmFjdCBmdW5jdGlvbiA6XG4gICAgICByZXN1bHQucGFyc2VGbGFncyhmbGFnKTtcblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiO1wiKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwie1wiKSkge1xuICAgICAgICByZXN1bHQuYm9keSA9IHRoaXMucmVhZF9jb2RlX2Jsb2NrKGZhbHNlKTtcblxuICAgICAgICBpZiAocmVzdWx0LmxvYyAmJiByZXN1bHQuYm9keS5sb2MpIHtcbiAgICAgICAgICByZXN1bHQubG9jLmVuZCA9IHJlc3VsdC5ib2R5LmxvYy5lbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFjbG9zdXJlICYmIGZsYWcpIHtcbiAgICAgICAgcmVzdWx0LnBhcnNlRmxhZ3MoZmxhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZHMgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiAod2l0aG91dCBoaXMgYm9keSlcbiAgICogYGBgZWJuZlxuICAgKiBmdW5jdGlvbl9kZWNsYXJhdGlvbiA6Oj0gVF9GVU5DVElPTiAnJic/ICBUX1NUUklORyAnKCcgcGFyYW1ldGVyX2xpc3QgJyknXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9mdW5jdGlvbl9kZWNsYXJhdGlvbjogZnVuY3Rpb24gcmVhZF9mdW5jdGlvbl9kZWNsYXJhdGlvbih0eXBlLCBpc1N0YXRpYykge1xuICAgIHZhciBub2RlTmFtZSA9IFwiZnVuY3Rpb25cIjtcblxuICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICBub2RlTmFtZSA9IFwiY2xvc3VyZVwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuICAgICAgbm9kZU5hbWUgPSBcIm1ldGhvZFwiO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUobm9kZU5hbWUpO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRlVOQ1RJT04pKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZWYgPSB0aGlzLmlzX3JlZmVyZW5jZSgpO1xuICAgIHZhciBuYW1lID0gZmFsc2UsXG4gICAgICAgIHVzZSA9IFtdLFxuICAgICAgICByZXR1cm5UeXBlID0gbnVsbCxcbiAgICAgICAgbnVsbGFibGUgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlICE9PSAxKSB7XG4gICAgICB2YXIgbmFtZU5vZGUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gMikge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCkge1xuICAgICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORyB8fCB0aGlzLmlzKFwiSURFTlRJRklFUlwiKSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPCA3MDQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJJREVOVElGSUVSXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORykge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yKFwiSURFTlRJRklFUlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA+PSA3MDApIHtcbiAgICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TVFJJTkcpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52ZXJzaW9uID49IDcwNCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cGVjdChcIihcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy50b2suVF9TVFJJTkcpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORykpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuYW1lID0gbmFtZU5vZGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiKFwiKSkgdGhpcy5uZXh0KCk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucmVhZF9wYXJhbWV0ZXJfbGlzdCgpO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgIHVzZSA9IHRoaXMucmVhZF9sZXhpY2FsX3ZhcnMoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PT0gXCI/XCIpIHtcbiAgICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuVHlwZSA9IHRoaXMucmVhZF90eXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGNsb3N1cmVcbiAgICAgIHJldHVybiByZXN1bHQocGFyYW1zLCBpc1JlZiwgdXNlLCByZXR1cm5UeXBlLCBudWxsYWJsZSwgaXNTdGF0aWMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQobmFtZSwgcGFyYW1zLCBpc1JlZiwgcmV0dXJuVHlwZSwgbnVsbGFibGUpO1xuICB9LFxuICByZWFkX2xleGljYWxfdmFyczogZnVuY3Rpb24gcmVhZF9sZXhpY2FsX3ZhcnMoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfVVNFKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwiKFwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9sZXhpY2FsX3Zhcl9saXN0KCk7XG4gICAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgcmVhZF9sZXhpY2FsX3Zhcl9saXN0OiBmdW5jdGlvbiByZWFkX2xleGljYWxfdmFyX2xpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZF9saXN0KHRoaXMucmVhZF9sZXhpY2FsX3ZhciwgXCIsXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqIGxleGljYWxfdmFyIDo6PSAnJic/IFRfVkFSSUFCTEVcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2xleGljYWxfdmFyOiBmdW5jdGlvbiByZWFkX2xleGljYWxfdmFyKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF9ieXJlZih0aGlzLnJlYWRfbGV4aWNhbF92YXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInZhcmlhYmxlXCIpO1xuICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfVkFSSUFCTEUpO1xuICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCkuc3Vic3RyaW5nKDEpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQobmFtZSwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkcyBhIGxpc3Qgb2YgcGFyYW1ldGVyc1xuICAgKiBgYGBlYm5mXG4gICAqICBwYXJhbWV0ZXJfbGlzdCA6Oj0gKHBhcmFtZXRlciAnLCcpKiBwYXJhbWV0ZXI/XG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9wYXJhbWV0ZXJfbGlzdDogZnVuY3Rpb24gcmVhZF9wYXJhbWV0ZXJfbGlzdCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPSBcIilcIikge1xuICAgICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yZWFkX3BhcmFtZXRlcigpKTtcblxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PSBcIixcIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT0gXCIpXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yKFtcIixcIiwgXCIpXCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHBhcmFtZXRlciA6Oj0gdHlwZT8gJyYnPyBUX0VMTElQU0lTPyBUX1ZBUklBQkxFICgnPScgZXhwcik/XG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iLzQ5MzUyNDQ1NGQ2NmFkZGU4NGUwMGQyNDlkNjA3ZWNkNTQwZGU5OWYvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w2NDBcbiAgICovXG4gIHJlYWRfcGFyYW1ldGVyOiBmdW5jdGlvbiByZWFkX3BhcmFtZXRlcigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcInBhcmFtZXRlclwiKTtcbiAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IG51bGw7XG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgdmFyIG51bGxhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI/XCIpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSB0aGlzLnJlYWRfdHlwZSgpO1xuXG4gICAgaWYgKG51bGxhYmxlICYmICF0eXBlKSB7XG4gICAgICB0aGlzLnJhaXNlRXJyb3IoXCJFeHBlY3RpbmcgYSB0eXBlIGRlZmluaXRpb24gY29tYmluZWQgd2l0aCBudWxsYWJsZSBvcGVyYXRvclwiKTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZWYgPSB0aGlzLmlzX3JlZmVyZW5jZSgpO1xuICAgIHZhciBpc1ZhcmlhZGljID0gdGhpcy5pc192YXJpYWRpYygpO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfVkFSSUFCTEUpKSB7XG4gICAgICBwYXJhbWV0ZXJOYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCkuc3Vic3RyaW5nKDEpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PSBcIj1cIikge1xuICAgICAgdmFsdWUgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZShwYXJhbWV0ZXJOYW1lLCB0eXBlLCB2YWx1ZSwgaXNSZWYsIGlzVmFyaWFkaWMsIG51bGxhYmxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBsaXN0IG9mIGFyZ3VtZW50c1xuICAgKiBgYGBlYm5mXG4gICAqICBmdW5jdGlvbl9hcmd1bWVudF9saXN0IDo6PSAnKCcgKGFyZ3VtZW50X2xpc3QgKCcsJyBhcmd1bWVudF9saXN0KSopPyAnKSdcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2FyZ3VtZW50X2xpc3Q6IGZ1bmN0aW9uIHJlYWRfYXJndW1lbnRfbGlzdCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdGhpcy5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gIT09IFwiKVwiKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnJlYWRfbm9uX2VtcHR5X2FyZ3VtZW50X2xpc3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgbm9uIGVtcHR5IGFyZ3VtZW50IGxpc3RcbiAgICovXG4gIHJlYWRfbm9uX2VtcHR5X2FyZ3VtZW50X2xpc3Q6IGZ1bmN0aW9uIHJlYWRfbm9uX2VtcHR5X2FyZ3VtZW50X2xpc3QoKSB7XG4gICAgdmFyIHdhc1ZhcmlhZGljID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbl9saXN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucmVhZF9hcmd1bWVudCgpO1xuXG4gICAgICBpZiAoYXJndW1lbnQpIHtcbiAgICAgICAgaWYgKHdhc1ZhcmlhZGljKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudCBhZnRlciBhIHZhcmlhZGljIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50LmtpbmQgPT09IFwidmFyaWFkaWNcIikge1xuICAgICAgICAgIHdhc1ZhcmlhZGljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgfS5iaW5kKHRoaXMpLCBcIixcIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogICAgYXJndW1lbnRfbGlzdCA6Oj0gVF9FTExJUFNJUz8gZXhwclxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfYXJndW1lbnQ6IGZ1bmN0aW9uIHJlYWRfYXJndW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRUxMSVBTSVMpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUoXCJ2YXJpYWRpY1wiKSh0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVhZF9leHByKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWQgdHlwZSBoaW50aW5nXG4gICAqIGBgYGVibmZcbiAgICogIHR5cGUgOjo9IFRfQVJSQVkgfCBUX0NBTExBQkxFIHwgbmFtZXNwYWNlX25hbWVcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3R5cGU6IGZ1bmN0aW9uIHJlYWRfdHlwZSgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKCk7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9BUlJBWSB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NBTExBQkxFKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0KFwidHlwZXJlZmVyZW5jZVwiLCB0eXBlLnRvTG93ZXJDYXNlKCksIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TVFJJTkcpIHtcbiAgICAgIHZhciBfdHlwZSA9IHRoaXMudGV4dCgpO1xuXG4gICAgICB2YXIgYmFja3VwID0gW3RoaXMudG9rZW4sIHRoaXMubGV4ZXIuZ2V0U3RhdGUoKV07XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SICYmIHRoaXMuYXN0LnR5cGVyZWZlcmVuY2UudHlwZXMuaW5kZXhPZihfdHlwZS50b0xvd2VyQ2FzZSgpKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoXCJ0eXBlcmVmZXJlbmNlXCIsIF90eXBlLnRvTG93ZXJDYXNlKCksIF90eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJvbGxiYWNrIGEgY2xhc3NpYyBuYW1lc3BhY2VcbiAgICAgICAgdGhpcy5sZXhlci50b2tlbnMucHVzaChiYWNrdXApO1xuICAgICAgICB0aGlzLm5leHQoKTsgLy8gZml4IDogZGVzdHJveSBub3QgY29uc3VtZWQgbm9kZSAocmVsZWFzZSBjb21tZW50cylcblxuICAgICAgICByZXN1bHQuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05BTUVTUEFDRSB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05TX1NFUEFSQVRPUikge1xuICAgICAgLy8gZml4IDogZGVzdHJveSBub3QgY29uc3VtZWQgbm9kZSAocmVsZWFzZSBjb21tZW50cylcbiAgICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG4gICAgfSAvLyBmaXggOiBkZXN0cm95IG5vdCBjb25zdW1lZCBub2RlIChyZWxlYXNlIGNvbW1lbnRzKVxuXG5cbiAgICByZXN1bHQuZGVzdHJveSgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWFkcyBhbiBJRiBzdGF0ZW1lbnRcbiAgICpcbiAgICogYGBgZWJuZlxuICAgKiAgaWYgOjo9IFRfSUYgJygnIGV4cHIgJyknICc6JyAuLi5cbiAgICogYGBgXG4gICAqL1xuICByZWFkX2lmOiBmdW5jdGlvbiByZWFkX2lmKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJpZlwiKTtcbiAgICB2YXIgdGVzdCA9IHRoaXMubmV4dCgpLnJlYWRfaWZfZXhwcigpO1xuICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB2YXIgc2hvcnRGb3JtID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIHNob3J0Rm9ybSA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGJvZHkgPSB0aGlzLm5vZGUoXCJibG9ja1wiKTtcbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9FTkRJRikge1xuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTFNFSUYpIHtcbiAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnJlYWRfZWxzZWlmX3Nob3J0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTFNFKSB7XG4gICAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5yZWFkX2Vsc2Vfc2hvcnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy5yZWFkX2lubmVyX3N0YXRlbWVudCgpKTtcbiAgICAgIH1cblxuICAgICAgYm9keSA9IGJvZHkobnVsbCwgaXRlbXMpO1xuICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9FTkRJRikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSB0aGlzLnJlYWRfc3RhdGVtZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0VJRikge1xuICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnJlYWRfaWYoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTFNFKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRoaXMubmV4dCgpLnJlYWRfc3RhdGVtZW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCh0ZXN0LCBib2R5LCBhbHRlcm5hdGUsIHNob3J0Rm9ybSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRzIGFuIGlmIGV4cHJlc3Npb24gOiAnKCcgZXhwciAnKSdcbiAgICovXG4gIHJlYWRfaWZfZXhwcjogZnVuY3Rpb24gcmVhZF9pZl9leHByKCkge1xuICAgIHRoaXMuZXhwZWN0KFwiKFwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZHMgYW4gZWxzZWlmIChleHByKTogc3RhdGVtZW50c1xuICAgKi9cbiAgcmVhZF9lbHNlaWZfc2hvcnQ6IGZ1bmN0aW9uIHJlYWRfZWxzZWlmX3Nob3J0KCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBudWxsO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJpZlwiKTtcbiAgICB2YXIgdGVzdCA9IHRoaXMubmV4dCgpLnJlYWRfaWZfZXhwcigpO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIjpcIikpIHRoaXMubmV4dCgpO1xuICAgIHZhciBib2R5ID0gdGhpcy5ub2RlKFwiYmxvY2tcIik7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0VORElGKSB7XG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTFNFSUYpIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5yZWFkX2Vsc2VpZl9zaG9ydCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTFNFKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucmVhZF9lbHNlX3Nob3J0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHRoaXMucmVhZF9pbm5lcl9zdGF0ZW1lbnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCh0ZXN0LCBib2R5KG51bGwsIGl0ZW1zKSwgYWx0ZXJuYXRlLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICovXG4gIHJlYWRfZWxzZV9zaG9ydDogZnVuY3Rpb24gcmVhZF9lbHNlX3Nob3J0KCkge1xuICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QoXCI6XCIpKSB0aGlzLm5leHQoKTtcbiAgICB2YXIgYm9keSA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9FTkRJRikge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLnJlYWRfaW5uZXJfc3RhdGVtZW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBib2R5KG51bGwsIGl0ZW1zKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVhZHMgYSB3aGlsZSBzdGF0ZW1lbnRcbiAgICogYGBgZWJuZlxuICAgKiB3aGlsZSA6Oj0gVF9XSElMRSAoc3RhdGVtZW50IHwgJzonIGlubmVyX3N0YXRlbWVudF9saXN0IFRfRU5EV0hJTEUgJzsnKVxuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w1ODdcbiAgICogQHJldHVybiB7V2hpbGV9XG4gICAqL1xuICByZWFkX3doaWxlOiBmdW5jdGlvbiByZWFkX3doaWxlKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJ3aGlsZVwiKTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1dISUxFKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgdGVzdCA9IG51bGw7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIHZhciBzaG9ydEZvcm0gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICB0ZXN0ID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjpcIikge1xuICAgICAgc2hvcnRGb3JtID0gdHJ1ZTtcbiAgICAgIGJvZHkgPSB0aGlzLnJlYWRfc2hvcnRfZm9ybSh0aGlzLnRvay5UX0VORFdISUxFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KHRlc3QsIGJvZHksIHNob3J0Rm9ybSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgZG8gLyB3aGlsZSBsb29wXG4gICAqIGBgYGVibmZcbiAgICogZG8gOjo9IFRfRE8gc3RhdGVtZW50IFRfV0hJTEUgJygnIGV4cHIgJyknICc7J1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w0MjNcbiAgICogQHJldHVybiB7RG99XG4gICAqL1xuICByZWFkX2RvOiBmdW5jdGlvbiByZWFkX2RvKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJkb1wiKTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0RPKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgdGVzdCA9IG51bGw7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIGJvZHkgPSB0aGlzLnJlYWRfc3RhdGVtZW50KCk7XG5cbiAgICBpZiAodGhpcy5leHBlY3QodGhpcy50b2suVF9XSElMRSkpIHtcbiAgICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgIHRlc3QgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCI7XCIpKSB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KHRlc3QsIGJvZHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgZm9yIGluY3JlbWVudGFsIGxvb3BcbiAgICogYGBgZWJuZlxuICAgKiBmb3IgOjo9IFRfRk9SICcoJyBmb3JfZXhwcnMgJzsnIGZvcl9leHBycyAnOycgZm9yX2V4cHJzICcpJyBmb3Jfc3RhdGVtZW50XG4gICAqIGZvcl9zdGF0ZW1lbnQgOjo9IHN0YXRlbWVudCB8ICc6JyBpbm5lcl9zdGF0ZW1lbnRfbGlzdCBUX0VOREZPUiAnOydcbiAgICogZm9yX2V4cHJzIDo6PSBleHByPyAoJywnIGV4cHIpKlxuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w0MjVcbiAgICogQHJldHVybiB7Rm9yfVxuICAgKi9cbiAgcmVhZF9mb3I6IGZ1bmN0aW9uIHJlYWRfZm9yKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJmb3JcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9GT1IpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciBpbml0ID0gW107XG4gICAgdmFyIHRlc3QgPSBbXTtcbiAgICB2YXIgaW5jcmVtZW50ID0gW107XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIHZhciBzaG9ydEZvcm0gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLnRva2VuICE9PSBcIjtcIikge1xuICAgICAgaW5pdCA9IHRoaXMucmVhZF9saXN0KHRoaXMucmVhZF9leHByLCBcIixcIik7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCI7XCIpKSB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gIT09IFwiO1wiKSB7XG4gICAgICB0ZXN0ID0gdGhpcy5yZWFkX2xpc3QodGhpcy5yZWFkX2V4cHIsIFwiLFwiKTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPT0gXCIpXCIpIHtcbiAgICAgIGluY3JlbWVudCA9IHRoaXMucmVhZF9saXN0KHRoaXMucmVhZF9leHByLCBcIixcIik7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICBzaG9ydEZvcm0gPSB0cnVlO1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zaG9ydF9mb3JtKHRoaXMudG9rLlRfRU5ERk9SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KGluaXQsIHRlc3QsIGluY3JlbWVudCwgYm9keSwgc2hvcnRGb3JtKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBmb3JlYWNoIGxvb3BcbiAgICogYGBgZWJuZlxuICAgKiBmb3JlYWNoIDo6PSAnKCcgZXhwciBUX0FTIGZvcmVhY2hfdmFyaWFibGUgKFRfRE9VQkxFX0FSUk9XIGZvcmVhY2hfdmFyaWFibGUpPyAnKScgc3RhdGVtZW50XG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQzOFxuICAgKiBAcmV0dXJuIHtGb3JlYWNofVxuICAgKi9cbiAgcmVhZF9mb3JlYWNoOiBmdW5jdGlvbiByZWFkX2ZvcmVhY2goKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImZvcmVhY2hcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9GT1JFQUNIKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICB2YXIgc2hvcnRGb3JtID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiKFwiKSkgdGhpcy5uZXh0KCk7XG4gICAgc291cmNlID0gdGhpcy5yZWFkX2V4cHIoKTtcblxuICAgIGlmICh0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0FTKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YWx1ZSA9IHRoaXMucmVhZF9mb3JlYWNoX3ZhcmlhYmxlKCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPVUJMRV9BUlJPVykge1xuICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5leHQoKS5yZWFkX2ZvcmVhY2hfdmFyaWFibGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIGdyYW1tYXRpY2FsbHkgY29ycmVjdCBidXQgbm90IHN1cHBvcnRlZCBieSBQSFBcblxuXG4gICAgaWYgKGtleSAmJiBrZXkua2luZCA9PT0gXCJsaXN0XCIpIHtcbiAgICAgIHRoaXMucmFpc2VFcnJvcihcIkZhdGFsIEVycm9yIDogQ2Fubm90IHVzZSBsaXN0IGFzIGtleSBlbGVtZW50XCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICBzaG9ydEZvcm0gPSB0cnVlO1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zaG9ydF9mb3JtKHRoaXMudG9rLlRfRU5ERk9SRUFDSCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSB0aGlzLnJlYWRfc3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChzb3VyY2UsIGtleSwgdmFsdWUsIGJvZHksIHNob3J0Rm9ybSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgZm9yZWFjaCB2YXJpYWJsZSBzdGF0ZW1lbnRcbiAgICogYGBgZWJuZlxuICAgKiBmb3JlYWNoX3ZhcmlhYmxlID1cbiAgICogICAgdmFyaWFibGUgfFxuICAgKiAgICAnJicgdmFyaWFibGUgfFxuICAgKiAgICBUX0xJU1QgJygnIGFzc2lnbm1lbnRfbGlzdCAnKScgfFxuICAgKiAgICAnWycgYXNzaWdubWVudF9saXN0ICddJ1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w1NDRcbiAgICogQHJldHVybiB7RXhwcmVzc2lvbn1cbiAgICovXG4gIHJlYWRfZm9yZWFjaF92YXJpYWJsZTogZnVuY3Rpb24gcmVhZF9mb3JlYWNoX3ZhcmlhYmxlKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0xJU1QgfHwgdGhpcy50b2tlbiA9PT0gXCJbXCIpIHtcbiAgICAgIHZhciBpc1Nob3J0ID0gdGhpcy50b2tlbiA9PT0gXCJbXCI7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwibGlzdFwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKCFpc1Nob3J0ICYmIHRoaXMuZXhwZWN0KFwiKFwiKSkgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgYXNzaWduTGlzdCA9IHRoaXMucmVhZF9hcnJheV9wYWlyX2xpc3QoaXNTaG9ydCk7XG4gICAgICBpZiAodGhpcy5leHBlY3QoaXNTaG9ydCA/IFwiXVwiIDogXCIpXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiByZXN1bHQoYXNzaWduTGlzdCwgaXNTaG9ydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfdmFyaWFibGUoZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogc3RhcnQgOjo9IChuYW1lc3BhY2UgfCB0b3Bfc3RhdGVtZW50KSpcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3N0YXJ0OiBmdW5jdGlvbiByZWFkX3N0YXJ0KCkge1xuICAgIGlmICh0aGlzLnRva2VuID09IHRoaXMudG9rLlRfTkFNRVNQQUNFKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX25hbWVzcGFjZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX3RvcF9zdGF0ZW1lbnQoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGEgbmFtZXNwYWNlIGRlY2xhcmF0aW9uIGJsb2NrXG4gICAqIGBgYGVibmZcbiAgICogbmFtZXNwYWNlIDo6PSBUX05BTUVTUEFDRSBuYW1lc3BhY2VfbmFtZT8gJ3snXG4gICAqICAgIHRvcF9zdGF0ZW1lbnRzXG4gICAqICd9J1xuICAgKiB8IFRfTkFNRVNQQUNFIG5hbWVzcGFjZV9uYW1lICc7JyB0b3Bfc3RhdGVtZW50c1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vbGFuZ3VhZ2UubmFtZXNwYWNlcy5waHBcbiAgICogQHJldHVybiB7TmFtZXNwYWNlfVxuICAgKi9cbiAgcmVhZF9uYW1lc3BhY2U6IGZ1bmN0aW9uIHJlYWRfbmFtZXNwYWNlKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJuYW1lc3BhY2VcIik7XG4gICAgdmFyIGJvZHk7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9OQU1FU1BBQ0UpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT0gXCJ7XCIpIHtcbiAgICAgIG5hbWUgPSB7XG4gICAgICAgIG5hbWU6IFtcIlwiXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IHRoaXMucmVhZF9uYW1lc3BhY2VfbmFtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudE5hbWVzcGFjZSA9IG5hbWU7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PSBcIjtcIikge1xuICAgICAgdGhpcy5jdXJyZW50TmFtZXNwYWNlID0gbmFtZTtcbiAgICAgIGJvZHkgPSB0aGlzLm5leHQoKS5yZWFkX3RvcF9zdGF0ZW1lbnRzKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLkVPRik7XG4gICAgICByZXR1cm4gcmVzdWx0KG5hbWUubmFtZSwgYm9keSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PSBcIntcIikge1xuICAgICAgdGhpcy5jdXJyZW50TmFtZXNwYWNlID0gbmFtZTtcbiAgICAgIGJvZHkgPSB0aGlzLm5leHQoKS5yZWFkX3RvcF9zdGF0ZW1lbnRzKCk7XG4gICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMCAmJiB0aGlzLmV4dHJhY3REb2MgJiYgdGhpcy5fZG9jcy5sZW5ndGggPiB0aGlzLl9kb2NJbmRleCkge1xuICAgICAgICBib2R5LnB1c2godGhpcy5ub2RlKFwibm9vcFwiKSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdChuYW1lLm5hbWUsIGJvZHksIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgIC8vIEBmaXhtZSBhZnRlciBtZXJnaW5nICM0NzhcbiAgICAgIG5hbWUucmVzb2x1dGlvbiA9IHRoaXMuYXN0LnJlZmVyZW5jZS5SRUxBVElWRV9OQU1FO1xuICAgICAgbmFtZS5uYW1lID0gbmFtZS5uYW1lLnN1YnN0cmluZygxKTtcbiAgICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKFwiY2FsbFwiKShuYW1lLCB0aGlzLnJlYWRfYXJndW1lbnRfbGlzdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcihbXCJ7XCIsIFwiO1wiXSk7IC8vIGdyYWNlZnVsIG1vZGUgOlxuXG4gICAgICB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPSBuYW1lO1xuICAgICAgYm9keSA9IHRoaXMucmVhZF90b3Bfc3RhdGVtZW50cygpO1xuICAgICAgdGhpcy5leHBlY3QodGhpcy5FT0YpO1xuICAgICAgcmV0dXJuIHJlc3VsdChuYW1lLCBib2R5LCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIG5hbWVzcGFjZSBuYW1lXG4gICAqIGBgYGVibmZcbiAgICogIG5hbWVzcGFjZV9uYW1lIDo6PSBUX05TX1NFUEFSQVRPUj8gKFRfU1RSSU5HIFRfTlNfU0VQQVJBVE9SKSogVF9TVFJJTkdcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2xhbmd1YWdlLm5hbWVzcGFjZXMucnVsZXMucGhwXG4gICAqIEByZXR1cm4ge1JlZmVyZW5jZX1cbiAgICovXG4gIHJlYWRfbmFtZXNwYWNlX25hbWU6IGZ1bmN0aW9uIHJlYWRfbmFtZXNwYWNlX25hbWUocmVzb2x2ZVJlZmVyZW5jZSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoKTtcbiAgICB2YXIgcmVsYXRpdmUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX05BTUVTUEFDRSkge1xuICAgICAgdGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgIHJlbGF0aXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSB0aGlzLnJlYWRfbGlzdCh0aGlzLnRvay5UX1NUUklORywgdGhpcy50b2suVF9OU19TRVBBUkFUT1IsIHRydWUpO1xuXG4gICAgaWYgKCFyZWxhdGl2ZSAmJiBuYW1lcy5sZW5ndGggPT09IDEgJiYgKHJlc29sdmVSZWZlcmVuY2UgfHwgdGhpcy50b2tlbiAhPT0gXCIoXCIpKSB7XG4gICAgICBpZiAobmFtZXNbMF0udG9Mb3dlckNhc2UoKSA9PT0gXCJwYXJlbnRcIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0KFwicGFyZW50cmVmZXJlbmNlXCIsIG5hbWVzWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZXNbMF0udG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxmXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChcInNlbGZyZWZlcmVuY2VcIiwgbmFtZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQoXCJuYW1lXCIsIG5hbWVzLCByZWxhdGl2ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgdXNlIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqIHVzZV9zdGF0ZW1lbnQgOjo9IFRfVVNFXG4gICAqICAgdXNlX3R5cGU/IHVzZV9kZWNsYXJhdGlvbnMgfFxuICAgKiAgIHVzZV90eXBlIHVzZV9zdGF0ZW1lbnQgJ3snIHVzZV9kZWNsYXJhdGlvbnMgJ30nIHxcbiAgICogICB1c2Vfc3RhdGVtZW50ICd7JyB1c2VfZGVjbGFyYXRpb25zKD0+dHlwZWQpICd9J1xuICAgKiAnOydcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2xhbmd1YWdlLm5hbWVzcGFjZXMuaW1wb3J0aW5nLnBocFxuICAgKiBAcmV0dXJuIHtVc2VHcm91cH1cbiAgICovXG4gIHJlYWRfdXNlX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF91c2Vfc3RhdGVtZW50KCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJ1c2Vncm91cFwiKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9VU0UpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciB0eXBlID0gdGhpcy5yZWFkX3VzZV90eXBlKCk7XG4gICAgaXRlbXMucHVzaCh0aGlzLnJlYWRfdXNlX2RlY2xhcmF0aW9uKGZhbHNlKSk7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIsXCIpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KHRoaXMubmV4dCgpLnJlYWRfdXNlX2RlY2xhcmF0aW9ucyhmYWxzZSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICAgIG5hbWUgPSBpdGVtc1swXS5uYW1lO1xuICAgICAgaXRlbXMgPSB0aGlzLm5leHQoKS5yZWFkX3VzZV9kZWNsYXJhdGlvbnModHlwZSA9PT0gbnVsbCk7XG4gICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0KG5hbWUsIHR5cGUsIGl0ZW1zKTtcbiAgICB0aGlzLmV4cGVjdChcIjtcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMDQ1XG4gICAqL1xuICByZWFkX2NsYXNzX25hbWVfcmVmZXJlbmNlOiBmdW5jdGlvbiByZWFkX2NsYXNzX25hbWVfcmVmZXJlbmNlKCkge1xuICAgIC8vIHJlc29sdmVkIGFzIHRoZSBzYW1lXG4gICAgcmV0dXJuIHRoaXMucmVhZF92YXJpYWJsZSh0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgdXNlIGRlY2xhcmF0aW9uXG4gICAqIGBgYGVibmZcbiAgICogdXNlX2RlY2xhcmF0aW9uIDo6PSB1c2VfdHlwZT8gbmFtZXNwYWNlX25hbWUgdXNlX2FsaWFzXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDM4MFxuICAgKiBAcmV0dXJuIHtVc2VJdGVtfVxuICAgKi9cbiAgcmVhZF91c2VfZGVjbGFyYXRpb246IGZ1bmN0aW9uIHJlYWRfdXNlX2RlY2xhcmF0aW9uKHR5cGVkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInVzZWl0ZW1cIik7XG4gICAgdmFyIHR5cGUgPSBudWxsO1xuICAgIGlmICh0eXBlZCkgdHlwZSA9IHRoaXMucmVhZF91c2VfdHlwZSgpO1xuICAgIHZhciBuYW1lID0gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5yZWFkX3VzZV9hbGlhcygpO1xuICAgIHJldHVybiByZXN1bHQobmFtZS5uYW1lLCBhbGlhcywgdHlwZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiB1c2UgZGVjbGFyYXRpb25zXG4gICAqIGBgYGVibmZcbiAgICogdXNlX2RlY2xhcmF0aW9ucyA6Oj0gdXNlX2RlY2xhcmF0aW9uICgnLCcgdXNlX2RlY2xhcmF0aW9uKSpcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMzgwXG4gICAqIEByZXR1cm4ge1VzZUl0ZW1bXX1cbiAgICovXG4gIHJlYWRfdXNlX2RlY2xhcmF0aW9uczogZnVuY3Rpb24gcmVhZF91c2VfZGVjbGFyYXRpb25zKHR5cGVkKSB7XG4gICAgdmFyIHJlc3VsdCA9IFt0aGlzLnJlYWRfdXNlX2RlY2xhcmF0aW9uKHR5cGVkKV07XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiA9PT0gXCIsXCIpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodHlwZWQpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfRlVOQ1RJT04gJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9DT05TVCAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX1NUUklORykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfU1RSSU5HICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfdXNlX2RlY2xhcmF0aW9uKHR5cGVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSB1c2Ugc3RhdGVtZW50XG4gICAqIGBgYGVibmZcbiAgICogdXNlX2FsaWFzIDo6PSAoVF9BUyBUX1NUUklORyk/XG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAgICovXG4gIHJlYWRfdXNlX2FsaWFzOiBmdW5jdGlvbiByZWFkX3VzZV9hbGlhcygpIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FTKSB7XG4gICAgICBpZiAodGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKSkge1xuICAgICAgICB2YXIgYWxpYXNOYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IGFsaWFzTmFtZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgbmFtZXNwYWNlIHR5cGUgZGVjbGFyYXRpb25cbiAgICogYGBgZWJuZlxuICAgKiB1c2VfdHlwZSA6Oj0gKFRfRlVOQ1RJT04gfCBUX0NPTlNUKT9cbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMzM1XG4gICAqIEByZXR1cm4ge1N0cmluZ3xudWxsfSBQb3NzaWJsZSB2YWx1ZXMgOiBmdW5jdGlvbiwgY29uc3RcbiAgICovXG4gIHJlYWRfdXNlX3R5cGU6IGZ1bmN0aW9uIHJlYWRfdXNlX3R5cGUoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04pIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuYXN0LnVzZWl0ZW0uVFlQRV9GVU5DVElPTjtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09OU1QpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuYXN0LnVzZWl0ZW0uVFlQRV9DT05TVDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBzcGVjaWFsQ2hhciA9IHtcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxuICAkOiBcIiRcIixcbiAgbjogXCJcXG5cIixcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcXHRcIixcbiAgZjogU3RyaW5nLmZyb21DaGFyQ29kZSgxMiksXG4gIHY6IFN0cmluZy5mcm9tQ2hhckNvZGUoMTEpLFxuICBlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDI3KVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVW5lc2NhcGUgc3BlY2lhbCBjaGFyc1xuICAgKi9cbiAgcmVzb2x2ZV9zcGVjaWFsX2NoYXJzOiBmdW5jdGlvbiByZXNvbHZlX3NwZWNpYWxfY2hhcnModGV4dCwgZG91YmxlUXVvdGUpIHtcbiAgICBpZiAoIWRvdWJsZVF1b3RlKSB7XG4gICAgICAvLyBzaW5nbGUgcXVvdGUgZml4XG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIikucmVwbGFjZSgvXFxcXCcvZywgXCInXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcXFxcIi8sICdcIicpLnJlcGxhY2UoL1xcXFwoW1xcXFwkbnJ0ZnZlXXxbeFhdWzAtOWEtZkEtRl17MSwyfXxbMC03XXsxLDN9fHV7KFswLTlhLWZBLUZdKyl9KS9nLCBmdW5jdGlvbiAoJG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgIGlmIChzcGVjaWFsQ2hhcltwMV0pIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpYWxDaGFyW3AxXTtcbiAgICAgIH0gZWxzZSBpZiAoXCJ4XCIgPT09IHAxWzBdIHx8IFwiWFwiID09PSBwMVswXSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQocDEuc3Vic3RyKDEpLCAxNikpO1xuICAgICAgfSBlbHNlIGlmIChcInVcIiA9PT0gcDFbMF0pIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHAyLCAxNikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHAxLCA4KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgbGVhZGluZyBzcGFjZXMgZWFjaCBsaW5lIGZvciBoZXJlZG9jIHRleHQgaWYgdGhlcmUgaXMgYSBpbmRlbnRhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBpbmRlbnRhdGlvbl91c2VzX3NwYWNlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0X2VuY2Fwc19ub2RlIGlmIGl0IGlzIGJlaGluZCBhIHZhcmlhYmxlLCB0aGUgZmlyc3QgTiBzcGFjZXMgc2hvdWxkIG5vdCBiZSByZW1vdmVkXG4gICAqL1xuICByZW1vdmVfaGVyZWRvY19sZWFkaW5nX3doaXRlc3BhY2VfY2hhcnM6IGZ1bmN0aW9uIHJlbW92ZV9oZXJlZG9jX2xlYWRpbmdfd2hpdGVzcGFjZV9jaGFycyh0ZXh0LCBpbmRlbnRhdGlvbiwgaW5kZW50YXRpb25fdXNlc19zcGFjZXMsIGZpcnN0X2VuY2Fwc19ub2RlKSB7XG4gICAgaWYgKGluZGVudGF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrX2hlcmVkb2NfaW5kZW50YXRpb25fbGV2ZWwodGV4dCwgaW5kZW50YXRpb24sIGluZGVudGF0aW9uX3VzZXNfc3BhY2VzLCBmaXJzdF9lbmNhcHNfbm9kZSk7XG4gICAgdmFyIG1hdGNoZWRDaGFyID0gaW5kZW50YXRpb25fdXNlc19zcGFjZXMgPyBcIiBcIiA6IFwiXFx0XCI7XG4gICAgdmFyIHJlbW92ZW1lbnRSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXFxcXG5cIi5jb25jYXQobWF0Y2hlZENoYXIsIFwie1wiKS5jb25jYXQoaW5kZW50YXRpb24sIFwifVwiKSwgXCJnXCIpO1xuICAgIHZhciByZW1vdmVtZW50Rmlyc3RFbmNhcHNOb2RlUmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQobWF0Y2hlZENoYXIsIFwie1wiKS5jb25jYXQoaW5kZW50YXRpb24sIFwifVwiKSk7IC8vIFJvdWdoIHJlcGxhY2UsIG5lZWQgbW9yZSBjaGVja1xuXG4gICAgaWYgKGZpcnN0X2VuY2Fwc19ub2RlKSB7XG4gICAgICAvLyBSZW1vdmUgdGV4dCBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVtb3ZlbWVudEZpcnN0RW5jYXBzTm9kZVJlZ0V4cCwgXCJcIik7XG4gICAgfSAvLyBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGFmdGVyIFxcblxuXG5cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlbW92ZW1lbnRSZWdFeHAsIFwiXFxuXCIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpbmRlbnRhdGlvbiBsZXZlbCBvZiBoZXJlZG9jIGluIHRleHQsIGlmIG1pc21hdGNoLCByYWlzZUVycm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZGVudGF0aW9uX3VzZXNfc3BhY2VzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RfZW5jYXBzX25vZGUgaWYgaXQgaXMgYmVoaW5kIGEgdmFyaWFibGUsIHRoZSBmaXJzdCBOIHNwYWNlcyBzaG91bGQgbm90IGJlIHJlbW92ZWRcbiAgICovXG4gIGNoZWNrX2hlcmVkb2NfaW5kZW50YXRpb25fbGV2ZWw6IGZ1bmN0aW9uIGNoZWNrX2hlcmVkb2NfaW5kZW50YXRpb25fbGV2ZWwodGV4dCwgaW5kZW50YXRpb24sIGluZGVudGF0aW9uX3VzZXNfc3BhY2VzLCBmaXJzdF9lbmNhcHNfbm9kZSkge1xuICAgIHZhciB0ZXh0U2l6ZSA9IHRleHQubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBsZWFkaW5nV2hpdGVzcGFjZUNoYXJDb3VudCA9IDA7XG4gICAgLyoqXG4gICAgICogQHZhciBpbkNvdXRpbmdTdGF0ZSB7Ym9vbGVhbn0gcmVzZXQgdG8gdHJ1ZSBhZnRlciBhIG5ldyBsaW5lXG4gICAgICovXG5cbiAgICB2YXIgaW5Db3V0aW5nU3RhdGUgPSB0cnVlO1xuICAgIHZhciBjaFRvQ2hlY2sgPSBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA/IFwiIFwiIDogXCJcXHRcIjtcbiAgICB2YXIgaW5DaGVja1N0YXRlID0gZmFsc2U7XG5cbiAgICBpZiAoIWZpcnN0X2VuY2Fwc19ub2RlKSB7XG4gICAgICAvLyBzdGFydCBmcm9tIGZpcnN0IFxcblxuICAgICAgb2Zmc2V0ID0gdGV4dC5pbmRleE9mKFwiXFxuXCIpOyAvLyBpZiBubyBcXG4sIGp1c3QgcmV0dXJuXG5cbiAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IHRleHRTaXplKSB7XG4gICAgICBpZiAoaW5Db3V0aW5nU3RhdGUpIHtcbiAgICAgICAgaWYgKHRleHRbb2Zmc2V0XSA9PT0gY2hUb0NoZWNrKSB7XG4gICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VDaGFyQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbkNoZWNrU3RhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbkNvdXRpbmdTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFtvZmZzZXRdICE9PSBcIlxcblwiICYmIGluQ2hlY2tTdGF0ZSAmJiBsZWFkaW5nV2hpdGVzcGFjZUNoYXJDb3VudCA8IGluZGVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2VFcnJvcihcIkludmFsaWQgYm9keSBpbmRlbnRhdGlvbiBsZXZlbCAoZXhwZWN0aW5nIGFuIGluZGVudGF0aW9uIGF0IGxlYXN0IFwiLmNvbmNhdChpbmRlbnRhdGlvbiwgXCIpXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluQ2hlY2tTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFtvZmZzZXRdID09PSBcIlxcblwiKSB7XG4gICAgICAgIC8vIFJlc2V0IGNvdW50aW5nIHN0YXRlXG4gICAgICAgIGluQ291dGluZ1N0YXRlID0gdHJ1ZTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VDaGFyQ291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGRlcmVmZXJlbmNhYmxlIHNjYWxhclxuICAgKi9cbiAgcmVhZF9kZXJlZmVyZW5jYWJsZV9zY2FsYXI6IGZ1bmN0aW9uIHJlYWRfZGVyZWZlcmVuY2FibGVfc2NhbGFyKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0aGlzLnRva2VuKSB7XG4gICAgICBjYXNlIHRoaXMudG9rLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5ub2RlKFwic3RyaW5nXCIpO1xuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICBpZiAodGV4dFswXSA9PT0gXCJiXCIgfHwgdGV4dFswXSA9PT0gXCJCXCIpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzRG91YmxlUXVvdGUgPSB0ZXh0W29mZnNldF0gPT09ICdcIic7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHRoaXMucmVzb2x2ZV9zcGVjaWFsX2NoYXJzKHRleHQuc3Vic3RyaW5nKG9mZnNldCArIDEsIHRleHQubGVuZ3RoIC0gMSksIGlzRG91YmxlUXVvdGUpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUoaXNEb3VibGVRdW90ZSwgdGV4dFZhbHVlLCBvZmZzZXQgPT09IDEsIC8vIHVuaWNvZGUgZmxhZ1xuICAgICAgICAgIHRleHQpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMTUxXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlYWRfc3RhdGljX2dldHRlcih2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpcnJlY3Qgc3RyaW5nXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9BUlJBWTpcbiAgICAgICAgLy8gYXJyYXkgcGFyc2VyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9hcnJheSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgLy8gc2hvcnQgYXJyYXkgZm9ybWF0XG4gICAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9hcnJheSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICBzY2FsYXIgOjo9IFRfTUFHSUNfQ09OU1RcbiAgICogICAgICAgfCBUX0xOVU1CRVIgfCBUX0ROVU1CRVJcbiAgICogICAgICAgfCBUX1NUQVJUX0hFUkVET0MgVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRT8gVF9FTkRfSEVSRURPQ1xuICAgKiAgICAgICB8ICdcIicgZW5jYXBzX2xpc3QgJ1wiJ1xuICAgKiAgICAgICB8IFRfU1RBUlRfSEVSRURPQyBlbmNhcHNfbGlzdCBUX0VORF9IRVJFRE9DXG4gICAqICAgICAgIHwgbmFtZXNwYWNlX25hbWUgKFRfRE9VQkxFX0NPTE9OIFRfU1RSSU5HKT9cbiAgICogYGBgXG4gICAqL1xuICByZWFkX3NjYWxhcjogZnVuY3Rpb24gcmVhZF9zY2FsYXIoKSB7XG4gICAgaWYgKHRoaXMuaXMoXCJUX01BR0lDX0NPTlNUXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRfbWFnaWNfY29uc3RhbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlLCBub2RlO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgICAgLy8gTlVNRVJJQ1xuICAgICAgICBjYXNlIHRoaXMudG9rLlRfTE5VTUJFUjogLy8gbG9uZ1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9ETlVNQkVSOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcIm51bWJlclwiKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQodmFsdWUsIG51bGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfU1RBUlRfSEVSRURPQzpcbiAgICAgICAgICBpZiAodGhpcy5sZXhlci5jdXJDb25kaXRpb24gPT09IFwiU1RfTk9XRE9DXCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldDtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUoXCJub3dkb2NcIik7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnRleHQoKTsgLy8gc3RyaXAgdGhlIGxhc3QgbGluZSByZXR1cm4gY2hhclxuXG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmluZGVudGF0aW9uID4gMCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFzdENoID0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChsYXN0Q2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDJdID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgICAgLy8gd2luZG93cyBzdHlsZVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGxpbnV4IHN0eWxlXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENoID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgIC8vIG1hYyBzdHlsZVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRSkgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0VORF9IRVJFRE9DKSAmJiB0aGlzLm5leHQoKTtcblxuICAgICAgICAgICAgdmFyIHJhdyA9IHRoaXMubGV4ZXIuX2lucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0KTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUodGhpcy5yZW1vdmVfaGVyZWRvY19sZWFkaW5nX3doaXRlc3BhY2VfY2hhcnModmFsdWUsIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiwgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmluZGVudGF0aW9uX3VzZXNfc3BhY2VzLCB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuZmlyc3RfZW5jYXBzX25vZGUpLCByYXcsIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5sYWJlbCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9lbmNhcHNlZF9zdHJpbmcodGhpcy50b2suVF9FTkRfSEVSRURPQyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2VuY2Fwc2VkX3N0cmluZygnXCInKTtcblxuICAgICAgICBjYXNlICdiXCInOlxuICAgICAgICBjYXNlICdCXCInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRfZW5jYXBzZWRfc3RyaW5nKCdcIicsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gVEVYVFNcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HOlxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfQVJSQVk6IC8vIGFycmF5IHBhcnNlclxuXG4gICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgLy8gc2hvcnQgYXJyYXkgZm9ybWF0XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9kZXJlZmVyZW5jYWJsZV9zY2FsYXIoKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSB0aGlzLmVycm9yKFwiU0NBTEFSXCIpOyAvLyBncmFjZWZ1bCBtb2RlIDogaWdub3JlIHRva2VuICYgcmV0dXJuIGVycm9yIG5vZGVcblxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGRlcmVmZXJlbmNpbmdcbiAgICovXG4gIHJlYWRfZGVyZWZlcmVuY2FibGU6IGZ1bmN0aW9uIHJlYWRfZGVyZWZlcmVuY2FibGUoZXhwcikge1xuICAgIHZhciByZXN1bHQsIG9mZnNldDtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcIm9mZnNldGxvb2t1cFwiKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIltcIikge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCJdXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgIHJlc3VsdCA9IG5vZGUoZXhwciwgb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLnJlYWRfZW5jYXBzZWRfc3RyaW5nX2l0ZW0oZmFsc2UpO1xuICAgICAgcmVzdWx0ID0gbm9kZShleHByLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuZCBleHRyYWN0cyBhbiBlbmNhcHNlZCBpdGVtXG4gICAqIGBgYGVibmZcbiAgICogZW5jYXBzZWRfc3RyaW5nX2l0ZW0gOjo9IFRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0VcbiAgICogIHwgVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVMgZXhwciAnfSdcbiAgICogIHwgVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVMgVF9TVFJJTkdfVkFSTkFNRSAnfSdcbiAgICogIHwgVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVMgVF9TVFJJTkdfVkFSTkFNRSAnWycgZXhwciAnXScgJ30nXG4gICAqICB8IFRfQ1VSTFlfT1BFTiB2YXJpYWJsZSAnfSdcbiAgICogIHwgdmFyaWFibGVcbiAgICogIHwgdmFyaWFibGUgJ1snIGV4cHIgJ10nXG4gICAqICB8IHZhcmlhYmxlIFRfT0JKRUNUX09QRVJBVE9SIFRfU1RSSU5HXG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTdHJpbmd8VmFyaWFibGV8RXhwcnxMb29rdXB9XG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTIxOVxuICAgKi9cbiAgcmVhZF9lbmNhcHNlZF9zdHJpbmdfaXRlbTogZnVuY3Rpb24gcmVhZF9lbmNhcHNlZF9zdHJpbmdfaXRlbShpc0RvdWJsZVF1b3RlKSB7XG4gICAgdmFyIGVuY2Fwc2VkUGFydCA9IHRoaXMubm9kZShcImVuY2Fwc2VkcGFydFwiKTtcbiAgICB2YXIgc3ludGF4ID0gbnVsbDtcbiAgICB2YXIgY3VybHkgPSBmYWxzZTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKCksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbmFtZTsgLy8gcGxhaW4gdGV4dFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyMjJcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7IC8vIGlmIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5maXJzdF9lbmNhcHNfbm9kZSAtPiByZW1vdmUgZmlyc3QgaW5kZW50c1xuXG4gICAgICByZXN1bHQgPSByZXN1bHQoXCJzdHJpbmdcIiwgZmFsc2UsIHRoaXMudmVyc2lvbiA+PSA3MDMgJiYgIXRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5maW5pc2hlZCA/IHRoaXMucmVtb3ZlX2hlcmVkb2NfbGVhZGluZ193aGl0ZXNwYWNlX2NoYXJzKHRoaXMucmVzb2x2ZV9zcGVjaWFsX2NoYXJzKHRleHQsIGlzRG91YmxlUXVvdGUpLCB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuaW5kZW50YXRpb24sIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbl91c2VzX3NwYWNlcywgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmZpcnN0X2VuY2Fwc19ub2RlKSA6IHRleHQsIGZhbHNlLCB0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTKSB7XG4gICAgICBzeW50YXggPSBcInNpbXBsZVwiO1xuICAgICAgY3VybHkgPSB0cnVlOyAvLyBkeW5hbWljIHZhcmlhYmxlIG5hbWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyMzlcblxuICAgICAgbmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PT0gdGhpcy50b2suVF9TVFJJTkdfVkFSTkFNRSkge1xuICAgICAgICBuYW1lID0gdGhpcy5ub2RlKFwidmFyaWFibGVcIik7XG4gICAgICAgIHZhciB2YXJOYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpOyAvLyBjaGVjayBpZiBsb29rdXAgYW4gb2Zmc2V0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyNDNcblxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZSh2YXJOYW1lLCBmYWxzZSk7XG4gICAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcIm9mZnNldGxvb2t1cFwiKTtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIl1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmVzdWx0ID0gbm9kZShuYW1lLCBvZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG5hbWUodmFyTmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQoXCJ2YXJpYWJsZVwiLCB0aGlzLnJlYWRfZXhwcigpLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ1VSTFlfT1BFTikge1xuICAgICAgLy8gZXhwcmVzc2lvblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTI0NlxuICAgICAgc3ludGF4ID0gXCJjb21wbGV4XCI7XG4gICAgICByZXN1bHQuZGVzdHJveSgpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0KCkucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9WQVJJQUJMRSkge1xuICAgICAgc3ludGF4ID0gXCJzaW1wbGVcIjsgLy8gcGxhaW4gdmFyaWFibGVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyMzFcblxuICAgICAgcmVzdWx0LmRlc3Ryb3koKTtcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9zaW1wbGVfdmFyaWFibGUoKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTIzM1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJbXCIpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcIm9mZnNldGxvb2t1cFwiKTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5uZXh0KCkucmVhZF9lbmNhcHNfdmFyX29mZnNldCgpO1xuICAgICAgICB0aGlzLmV4cGVjdChcIl1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IG5vZGUocmVzdWx0LCBvZmZzZXQpO1xuICAgICAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMjM2XG5cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfT0JKRUNUX09QRVJBVE9SKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLm5vZGUoXCJwcm9wZXJ0eWxvb2t1cFwiKTtcbiAgICAgICAgdGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKTtcbiAgICAgICAgdmFyIHdoYXQgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXN1bHQgPSBub2RlKHJlc3VsdCwgd2hhdChuYW1lKSk7XG4gICAgICB9IC8vIGVycm9yIC8gZmFsbGJhY2tcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFKTtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7IC8vIGNvbnNpZGVyIGl0IGFzIHN0cmluZ1xuXG4gICAgICByZXN1bHQuZGVzdHJveSgpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0KFwic3RyaW5nXCIsIGZhbHNlLCB2YWx1ZSwgZmFsc2UsIHZhbHVlKTtcbiAgICB9IC8vIHJlc2V0IGZpcnN0X2VuY2Fwc19ub2RlIHRvIGZhbHNlIGFmdGVyIGFjY2VzcyBhbnkgbm9kZVxuXG5cbiAgICB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuZmlyc3RfZW5jYXBzX25vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gZW5jYXBzZWRQYXJ0KHJlc3VsdCwgc3ludGF4LCBjdXJseSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGFuIGVuY2Fwc2VkIHN0cmluZ1xuICAgKi9cbiAgcmVhZF9lbmNhcHNlZF9zdHJpbmc6IGZ1bmN0aW9uIHJlYWRfZW5jYXBzZWRfc3RyaW5nKGV4cGVjdCkge1xuICAgIHZhciBpc0JpbmFyeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGxhYmVsU3RhcnQgPSB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQ7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoXCJlbmNhcHNlZFwiKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmxleGVyLnl5bGxvYy5wcmV2X29mZnNldCAtIChpc0JpbmFyeSA/IDEgOiAwKTtcbiAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICB2YXIgdHlwZSA9IG51bGw7XG5cbiAgICBpZiAoZXhwZWN0ID09PSBcImBcIikge1xuICAgICAgdHlwZSA9IHRoaXMuYXN0LmVuY2Fwc2VkLlRZUEVfU0hFTEw7XG4gICAgfSBlbHNlIGlmIChleHBlY3QgPT09ICdcIicpIHtcbiAgICAgIHR5cGUgPSB0aGlzLmFzdC5lbmNhcHNlZC5UWVBFX1NUUklORztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHRoaXMuYXN0LmVuY2Fwc2VkLlRZUEVfSEVSRURPQztcbiAgICB9IC8vIHJlYWRpbmcgZW5jYXBzZWQgcGFydHNcblxuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT09IGV4cGVjdCAmJiB0aGlzLnRva2VuICE9PSB0aGlzLkVPRikge1xuICAgICAgdmFsdWUucHVzaCh0aGlzLnJlYWRfZW5jYXBzZWRfc3RyaW5nX2l0ZW0odHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdLmtpbmQgPT09IFwiZW5jYXBzZWRwYXJ0XCIgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0uZXhwcmVzc2lvbi5raW5kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgX25vZGUgPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXS5leHByZXNzaW9uO1xuICAgICAgdmFyIGxhc3RDaCA9IF9ub2RlLnZhbHVlW19ub2RlLnZhbHVlLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAobGFzdENoID09PSBcIlxcblwiKSB7XG4gICAgICAgIGlmIChfbm9kZS52YWx1ZVtfbm9kZS52YWx1ZS5sZW5ndGggLSAyXSA9PT0gXCJcXHJcIikge1xuICAgICAgICAgIC8vIHdpbmRvd3Mgc3R5bGVcbiAgICAgICAgICBfbm9kZS52YWx1ZSA9IF9ub2RlLnZhbHVlLnN1YnN0cmluZygwLCBfbm9kZS52YWx1ZS5sZW5ndGggLSAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsaW51eCBzdHlsZVxuICAgICAgICAgIF9ub2RlLnZhbHVlID0gX25vZGUudmFsdWUuc3Vic3RyaW5nKDAsIF9ub2RlLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxhc3RDaCA9PT0gXCJcXHJcIikge1xuICAgICAgICAvLyBtYWMgc3R5bGVcbiAgICAgICAgX25vZGUudmFsdWUgPSBfbm9kZS52YWx1ZS5zdWJzdHJpbmcoMCwgX25vZGUudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoZXhwZWN0KSAmJiB0aGlzLm5leHQoKTtcblxuICAgIHZhciByYXcgPSB0aGlzLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodHlwZSA9PT0gXCJoZXJlZG9jXCIgPyBsYWJlbFN0YXJ0IDogc3RhcnQgLSAxLCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQpO1xuXG4gICAgbm9kZSA9IG5vZGUodmFsdWUsIHJhdywgdHlwZSk7XG5cbiAgICBpZiAoZXhwZWN0ID09PSB0aGlzLnRvay5UX0VORF9IRVJFRE9DKSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmxhYmVsO1xuICAgICAgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RhbnQgdG9rZW5cbiAgICovXG4gIGdldF9tYWdpY19jb25zdGFudDogZnVuY3Rpb24gZ2V0X21hZ2ljX2NvbnN0YW50KCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJtYWdpY1wiKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQobmFtZS50b1VwcGVyQ2FzZSgpLCBuYW1lKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogcmVhZGluZyBhIGxpc3Qgb2YgdG9wIHN0YXRlbWVudHMgKGhlbHBlciBmb3IgdG9wX3N0YXRlbWVudCopXG4gICAqIGBgYGVibmZcbiAgICogIHRvcF9zdGF0ZW1lbnRzIDo6PSB0b3Bfc3RhdGVtZW50KlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfdG9wX3N0YXRlbWVudHM6IGZ1bmN0aW9uIHJlYWRfdG9wX3N0YXRlbWVudHMoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT09IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IFwifVwiKSB7XG4gICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5yZWFkX3RvcF9zdGF0ZW1lbnQoKTtcblxuICAgICAgaWYgKHN0YXRlbWVudCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChzdGF0ZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkaW5nIGEgdG9wIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqICB0b3Bfc3RhdGVtZW50IDo6PVxuICAgKiAgICAgICBuYW1lc3BhY2UgfCBmdW5jdGlvbiB8IGNsYXNzXG4gICAqICAgICAgIHwgaW50ZXJmYWNlIHwgdHJhaXRcbiAgICogICAgICAgfCB1c2Vfc3RhdGVtZW50cyB8IGNvbnN0X2xpc3RcbiAgICogICAgICAgfCBzdGF0ZW1lbnRcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3RvcF9zdGF0ZW1lbnQ6IGZ1bmN0aW9uIHJlYWRfdG9wX3N0YXRlbWVudCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9GVU5DVElPTjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbihmYWxzZSwgZmFsc2UpO1xuICAgICAgLy8gb3B0aW9uYWwgZmxhZ3NcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0FCU1RSQUNUOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZJTkFMOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0NMQVNTOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2NsYXNzX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5URVJGQUNFOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2ludGVyZmFjZV9kZWNsYXJhdGlvbl9zdGF0ZW1lbnQoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1RSQUlUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3RyYWl0X2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVVNFOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3VzZV9zdGF0ZW1lbnQoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0NPTlNUOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImNvbnN0YW50c3RhdGVtZW50XCIpO1xuICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMubmV4dCgpLnJlYWRfY29uc3RfbGlzdCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KG51bGwsIGl0ZW1zKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfTkFNRVNQQUNFOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX25hbWVzcGFjZSgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSEFMVF9DT01QSUxFUjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0ID0gdGhpcy5ub2RlKFwiaGFsdFwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIjtcIik7XG4gICAgICAgICAgdGhpcy5sZXhlci5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdCh0aGlzLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5sZXhlci5vZmZzZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3N0YXRlbWVudCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogcmVhZHMgYSBsaXN0IG9mIHNpbXBsZSBpbm5lciBzdGF0ZW1lbnRzIChoZWxwZXIgZm9yIGlubmVyX3N0YXRlbWVudCopXG4gICAqIGBgYGVibmZcbiAgICogIGlubmVyX3N0YXRlbWVudHMgOjo9IGlubmVyX3N0YXRlbWVudCpcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2lubmVyX3N0YXRlbWVudHM6IGZ1bmN0aW9uIHJlYWRfaW5uZXJfc3RhdGVtZW50cygpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBcIn1cIikge1xuICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMucmVhZF9pbm5lcl9zdGF0ZW1lbnQoKTtcblxuICAgICAgaWYgKHN0YXRlbWVudCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChzdGF0ZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgY29uc3RhbnRzIGRlY2xhcmF0aW9uXG4gICAqIGBgYGVibmZcbiAgICogICBjb25zdF9saXN0IDo6PSBUX0NPTlNUIFRfU1RSSU5HICc9JyBleHByICgnLCcgVF9TVFJJTkcgJz0nIGV4cHIpKiAnOydcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2NvbnN0X2xpc3Q6IGZ1bmN0aW9uIHJlYWRfY29uc3RfbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2xpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNvbnN0TmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdE5hbWUgPSBjb25zdE5hbWUobmFtZSk7XG5cbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIj1cIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChjb25zdE5hbWUsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrXG4gICAgICAgIHJldHVybiByZXN1bHQoY29uc3ROYW1lLCBudWxsKTtcbiAgICAgIH1cbiAgICB9LCBcIixcIiwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgY29uc3RhbnRzIGRlY2xhcmF0aW9uXG4gICAqIGBgYGVibmZcbiAgICogICBkZWNsYXJlX2xpc3QgOjo9IElERU5USUZJRVIgJz0nIGV4cHIgKCcsJyBJREVOVElGSUVSICc9JyBleHByKSpcbiAgICogYGBgXG4gICAqIEByZXRydXJuIHtBcnJheX1cbiAgICovXG4gIHJlYWRfZGVjbGFyZV9saXN0OiBmdW5jdGlvbiByZWFkX2RlY2xhcmVfbGlzdCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBcIilcIikge1xuICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgICAgdmFyIGRpcmVjdGl2ZSA9IHRoaXMubm9kZShcImRlY2xhcmVkaXJlY3RpdmVcIik7XG4gICAgICB2YXIga2V5ID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGtleSA9IGtleShuYW1lKTtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIj1cIikpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goZGlyZWN0aXZlKGtleSwgdmFsdWUpKTtcbiAgICAgIGlmICh0aGlzLnRva2VuICE9PSBcIixcIikgYnJlYWs7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkcyBhIHNpbXBsZSBpbm5lciBzdGF0ZW1lbnRcbiAgICogYGBgZWJuZlxuICAgKiAgaW5uZXJfc3RhdGVtZW50IDo6PSAneycgaW5uZXJfc3RhdGVtZW50cyAnfScgfCB0b2tlblxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfaW5uZXJfc3RhdGVtZW50OiBmdW5jdGlvbiByZWFkX2lubmVyX3N0YXRlbWVudCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9GVU5DVElPTjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbihmYWxzZSwgZmFsc2UpO1xuICAgICAgLy8gb3B0aW9uYWwgZmxhZ3NcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0FCU1RSQUNUOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZJTkFMOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0NMQVNTOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2NsYXNzX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5URVJGQUNFOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2ludGVyZmFjZV9kZWNsYXJhdGlvbl9zdGF0ZW1lbnQoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1RSQUlUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3RyYWl0X2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSEFMVF9DT01QSUxFUjpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMucmFpc2VFcnJvcihcIl9fSEFMVF9DT01QSUxFUigpIGNhbiBvbmx5IGJlIHVzZWQgZnJvbSB0aGUgb3V0ZXJtb3N0IHNjb3BlXCIpOyAvLyBmYWxsYmFjayA6IHJldHVybnMgYSBub2RlIGJ1dCBkb2VzIG5vdCBzdG9wIHRoZSBwYXJzaW5nXG5cbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcImhhbHRcIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCkuZXhwZWN0KFwiKFwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUodGhpcy5sZXhlci5faW5wdXQuc3Vic3RyaW5nKHRoaXMubGV4ZXIub2Zmc2V0KSk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoXCI7XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfc3RhdGVtZW50KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBzdGF0ZW1lbnRzXG4gICAqL1xuICByZWFkX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF9zdGF0ZW1lbnQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnRva2VuKSB7XG4gICAgICBjYXNlIFwie1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2NvZGVfYmxvY2soZmFsc2UpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSUY6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfaWYoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1NXSVRDSDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9zd2l0Y2goKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZPUjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9mb3IoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZPUkVBQ0g6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZm9yZWFjaCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfV0hJTEU6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfd2hpbGUoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0RPOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2RvKCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9DT01NRU5UOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2NvbW1lbnQoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0RPQ19DT01NRU5UOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2RvY19jb21tZW50KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9SRVRVUk46XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwicmV0dXJuXCIpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHZhciBleHByID0gdGhpcy5yZWFkX29wdGlvbmFsX2V4cHIoXCI7XCIpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KGV4cHIpO1xuICAgICAgICB9XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w0MjlcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0JSRUFLOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0NPTlRJTlVFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQyID0gdGhpcy5ub2RlKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09OVElOVUUgPyBcImNvbnRpbnVlXCIgOiBcImJyZWFrXCIpO1xuXG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIGxldmVsID0gdGhpcy5yZWFkX29wdGlvbmFsX2V4cHIoXCI7XCIpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDIobGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9HTE9CQUw6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDMgPSB0aGlzLm5vZGUoXCJnbG9iYWxcIik7XG5cbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLm5leHQoKS5yZWFkX2xpc3QodGhpcy5yZWFkX3NpbXBsZV92YXJpYWJsZSwgXCIsXCIpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDMoaXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9TVEFUSUM6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IFt0aGlzLnRva2VuLCB0aGlzLmxleGVyLmdldFN0YXRlKCldO1xuXG4gICAgICAgICAgdmFyIF9yZXN1bHQ0ID0gdGhpcy5ub2RlKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICAgICAgICAvLyBzdGF0aWMga2V5d29yZCBmb3IgYSBjbGFzc1xuICAgICAgICAgICAgdGhpcy5sZXhlci50b2tlbnMucHVzaChjdXJyZW50KTtcblxuICAgICAgICAgICAgdmFyIF9leHByID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoX2V4cHIpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQ0KFwiZXhwcmVzc2lvbnN0YXRlbWVudFwiLCBfZXhwcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRfZnVuY3Rpb24odHJ1ZSwgWzAsIDEsIDBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2l0ZW1zID0gdGhpcy5yZWFkX3ZhcmlhYmxlX2RlY2xhcmF0aW9ucygpO1xuXG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0NChcInN0YXRpY1wiLCBfaXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9FQ0hPOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ1ID0gdGhpcy5ub2RlKFwiZWNob1wiKTtcblxuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgdmFyIHNob3J0Rm9ybSA9IHRleHQgPT09IFwiPD89XCIgfHwgdGV4dCA9PT0gXCI8JT1cIjtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLm5leHQoKS5yZWFkX2Z1bmN0aW9uX2xpc3QodGhpcy5yZWFkX2V4cHIsIFwiLFwiKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ1KGV4cHJlc3Npb25zLCBzaG9ydEZvcm0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTkxJTkVfSFRNTDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgIHZhciBwcmV2Q2hhciA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCA+IDAgPyB0aGlzLmxleGVyLl9pbnB1dFt0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgICAgICAgdmFyIGZpeEZpcnN0TGluZSA9IHByZXZDaGFyID09PSBcIlxcclwiIHx8IHByZXZDaGFyID09PSBcIlxcblwiOyAvLyByZXZlcnQgYmFjayB0aGUgZmlyc3Qgc3RyaXBwZWQgbGluZVxuXG4gICAgICAgICAgaWYgKGZpeEZpcnN0TGluZSkge1xuICAgICAgICAgICAgaWYgKHByZXZDaGFyID09PSBcIlxcblwiICYmIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCA+IDEgJiYgdGhpcy5sZXhlci5faW5wdXRbdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0IC0gMl0gPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgICAgcHJldkNoYXIgPSBcIlxcclxcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfcmVzdWx0NiA9IHRoaXMubm9kZShcImlubGluZVwiKTtcblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0Nih2YWx1ZSwgZml4Rmlyc3RMaW5lID8gcHJldkNoYXIgKyB2YWx1ZSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVU5TRVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDcgPSB0aGlzLm5vZGUoXCJ1bnNldFwiKTtcblxuICAgICAgICAgIHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHRoaXMucmVhZF9mdW5jdGlvbl9saXN0KHRoaXMucmVhZF92YXJpYWJsZSwgXCIsXCIpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIjtcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ3KHZhcmlhYmxlcyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0RFQ0xBUkU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDggPSB0aGlzLm5vZGUoXCJkZWNsYXJlXCIpO1xuXG4gICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICB2YXIgbW9kZTtcbiAgICAgICAgICB0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5yZWFkX2RlY2xhcmVfbGlzdCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIjpcIikge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfRU5EREVDTEFSRSkge1xuICAgICAgICAgICAgICAvLyBAdG9kbyA6IGNoZWNrIGRlY2xhcmVfc3RhdGVtZW50IGZyb20gcGhwIC8gbm90IHZhbGlkXG4gICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnJlYWRfdG9wX3N0YXRlbWVudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAwICYmIHRoaXMuZXh0cmFjdERvYyAmJiB0aGlzLl9kb2NzLmxlbmd0aCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0VORERFQ0xBUkUpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgICAgbW9kZSA9IHRoaXMuYXN0LmRlY2xhcmUuTU9ERV9TSE9SVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgLy8gQHRvZG8gOiBjaGVjayBkZWNsYXJlX3N0YXRlbWVudCBmcm9tIHBocCAvIG5vdCB2YWxpZFxuICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5yZWFkX3RvcF9zdGF0ZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMCAmJiB0aGlzLmV4dHJhY3REb2MgJiYgdGhpcy5fZG9jcy5sZW5ndGggPiB0aGlzLl9kb2NJbmRleCkge1xuICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5ub2RlKFwibm9vcFwiKSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgbW9kZSA9IHRoaXMuYXN0LmRlY2xhcmUuTU9ERV9CTE9DSztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoXCI7XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgbW9kZSA9IHRoaXMuYXN0LmRlY2xhcmUuTU9ERV9OT05FO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfcmVzdWx0OChkaXJlY3RpdmVzLCBib2R5LCBtb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVFJZOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3RyeSgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVEhST1c6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDkgPSB0aGlzLm5vZGUoXCJ0aHJvd1wiKTtcblxuICAgICAgICAgIHZhciBfZXhwcjIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcblxuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDkoX2V4cHIyKTtcbiAgICAgICAgfVxuICAgICAgLy8gaWdub3JlIHRoaXMgKGV4dHJhIHBvbmN0dWF0aW9uKVxuXG4gICAgICBjYXNlIFwiO1wiOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1NUUklORzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0MTAgPSB0aGlzLm5vZGUoKTtcblxuICAgICAgICAgIHZhciBfY3VycmVudCA9IFt0aGlzLnRva2VuLCB0aGlzLmxleGVyLmdldFN0YXRlKCldO1xuICAgICAgICAgIHZhciBsYWJlbE5hbWVUZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgdmFyIGxhYmVsTmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7IC8vIEFTVCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQ1N1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09PSBcIjpcIikge1xuICAgICAgICAgICAgbGFiZWxOYW1lID0gbGFiZWxOYW1lKGxhYmVsTmFtZVRleHQpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDEwKFwibGFiZWxcIiwgbGFiZWxOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFiZWxOYW1lLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IC8vIGRlZmF1bHQgZmFsbGJhY2sgZXhwciAvIFRfU1RSSU5HICc6OicgKGV0Yy4uLilcblxuXG4gICAgICAgICAgX3Jlc3VsdDEwLmRlc3Ryb3koKTtcblxuICAgICAgICAgIHRoaXMubGV4ZXIudG9rZW5zLnB1c2goX2N1cnJlbnQpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLm5vZGUoXCJleHByZXNzaW9uc3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgdmFyIF9leHByMyA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuXG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudChfZXhwcjMpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnQoX2V4cHIzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfR09UTzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0MTEgPSB0aGlzLm5vZGUoXCJnb3RvXCIpO1xuXG4gICAgICAgICAgdmFyIF9sYWJlbE5hbWUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORykpIHtcbiAgICAgICAgICAgIF9sYWJlbE5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgX2xhYmVsTmFtZSA9IF9sYWJlbE5hbWUobmFtZSk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQxMShfbGFiZWxOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZGVmYXVsdCBmYWxsYmFjayBleHByXG4gICAgICAgICAgdmFyIF9zdGF0ZW1lbnQgPSB0aGlzLm5vZGUoXCJleHByZXNzaW9uc3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgdmFyIF9leHByNCA9IHRoaXMucmVhZF9leHByKCk7XG5cbiAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KF9leHByNCk7XG4gICAgICAgICAgcmV0dXJuIF9zdGF0ZW1lbnQoX2V4cHI0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiAgY29kZV9ibG9jayA6Oj0gJ3snIChpbm5lcl9zdGF0ZW1lbnRzIHwgdG9wX3N0YXRlbWVudHMpICd9J1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY29kZV9ibG9jazogZnVuY3Rpb24gcmVhZF9jb2RlX2Jsb2NrKHRvcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJibG9ja1wiKTtcbiAgICB0aGlzLmV4cGVjdChcIntcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGJvZHkgPSB0b3AgPyB0aGlzLnJlYWRfdG9wX3N0YXRlbWVudHMoKSA6IHRoaXMucmVhZF9pbm5lcl9zdGF0ZW1lbnRzKCk7XG5cbiAgICBpZiAoYm9keS5sZW5ndGggPT09IDAgJiYgdGhpcy5leHRyYWN0RG9jICYmIHRoaXMuX2RvY3MubGVuZ3RoID4gdGhpcy5fZG9jSW5kZXgpIHtcbiAgICAgIGJvZHkucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gcmVzdWx0KG51bGwsIGJvZHkpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWFkcyBhIHN3aXRjaCBzdGF0ZW1lbnRcbiAgICogYGBgZWJuZlxuICAgKiAgc3dpdGNoIDo6PSBUX1NXSVRDSCAnKCcgZXhwciAnKScgc3dpdGNoX2Nhc2VfbGlzdFxuICAgKiBgYGBcbiAgICogQHJldHVybiB7U3dpdGNofVxuICAgKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9jb250cm9sLXN0cnVjdHVyZXMuc3dpdGNoLnBocFxuICAgKi9cbiAgcmVhZF9zd2l0Y2g6IGZ1bmN0aW9uIHJlYWRfc3dpdGNoKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJzd2l0Y2hcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9TV0lUQ0gpICYmIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0KFwiKFwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgdGVzdCA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgdGhpcy5leHBlY3QoXCIpXCIpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciBzaG9ydEZvcm0gPSB0aGlzLnRva2VuID09PSBcIjpcIjtcbiAgICB2YXIgYm9keSA9IHRoaXMucmVhZF9zd2l0Y2hfY2FzZV9saXN0KCk7XG4gICAgcmV0dXJuIHJlc3VsdCh0ZXN0LCBib2R5LCBzaG9ydEZvcm0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICBzd2l0Y2hfY2FzZV9saXN0IDo6PSAneycgJzsnPyBjYXNlX2xpc3QqICd9JyB8ICc6JyAnOyc/IGNhc2VfbGlzdCogVF9FTkRTV0lUQ0ggJzsnXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDU2NlxuICAgKi9cbiAgcmVhZF9zd2l0Y2hfY2FzZV9saXN0OiBmdW5jdGlvbiByZWFkX3N3aXRjaF9jYXNlX2xpc3QoKSB7XG4gICAgLy8gREVURUNUIFNXSVRDSCBNT0RFXG4gICAgdmFyIGV4cGVjdCA9IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwie1wiKSB7XG4gICAgICBleHBlY3QgPSBcIn1cIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICBleHBlY3QgPSB0aGlzLnRvay5UX0VORFNXSVRDSDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoW1wie1wiLCBcIjpcIl0pO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpOyAvLyBPUFRJT05OQUwgJzsnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNTcwXG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gLy8gRVhUUkFDVElORyBDQVNFU1xuXG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gZXhwZWN0KSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMucmVhZF9jYXNlX2xpc3QoZXhwZWN0KSk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmV4dHJhY3REb2MgJiYgdGhpcy5fZG9jcy5sZW5ndGggPiB0aGlzLl9kb2NJbmRleCkge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgIH0gLy8gQ0hFQ0sgRU5EIFRPS0VOXG5cblxuICAgIHRoaXMuZXhwZWN0KGV4cGVjdCkgJiYgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoZXhwZWN0ID09PSB0aGlzLnRvay5UX0VORFNXSVRDSCkge1xuICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQobnVsbCwgaXRlbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICAgY2FzZV9saXN0IDo6PSAoKFRfQ0FTRSBleHByKSB8IFRfREVGQVVMVCkgKCc6JyB8ICc7JykgaW5uZXJfc3RhdGVtZW50KlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY2FzZV9saXN0OiBmdW5jdGlvbiByZWFkX2Nhc2VfbGlzdChzdG9wVG9rZW4pIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiY2FzZVwiKTtcbiAgICB2YXIgdGVzdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DQVNFKSB7XG4gICAgICB0ZXN0ID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RFRkFVTFQpIHtcbiAgICAgIC8vIHRoZSBkZWZhdWx0IGVudHJ5IC0gbm8gY29uZGl0aW9uXG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoW3RoaXMudG9rLlRfQ0FTRSwgdGhpcy50b2suVF9ERUZBVUxUXSk7XG4gICAgfSAvLyBjYXNlX3NlcGFyYXRvclxuXG5cbiAgICB0aGlzLmV4cGVjdChbXCI6XCIsIFwiO1wiXSkgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGJvZHkgPSB0aGlzLm5vZGUoXCJibG9ja1wiKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBzdG9wVG9rZW4gJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9DQVNFICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfREVGQVVMVCkge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLnJlYWRfaW5uZXJfc3RhdGVtZW50KCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQodGVzdCwgYm9keShudWxsLCBpdGVtcykpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICB0cnkgOjo9IFRfVFJZICd7JyBpbm5lcl9zdGF0ZW1lbnQqICd9J1xuICAgKiAgICAgICAgICAoXG4gICAqICAgICAgICAgICAgICBUX0NBVENIICcoJyBuYW1lc3BhY2VfbmFtZSB2YXJpYWJsZSAnKScgJ3snICBpbm5lcl9zdGF0ZW1lbnQqICd9J1xuICAgKiAgICAgICAgICApKlxuICAgKiAgICAgICAgICAoVF9GSU5BTExZICd7JyBpbm5lcl9zdGF0ZW1lbnQqICd9Jyk/XG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQ0OFxuICAgKiBAcmV0dXJuIHtUcnl9XG4gICAqL1xuICByZWFkX3RyeTogZnVuY3Rpb24gcmVhZF90cnkoKSB7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9UUlkpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJ0cnlcIik7XG4gICAgdmFyIGFsd2F5cyA9IG51bGw7XG4gICAgdmFyIGNhdGNoZXMgPSBbXTtcbiAgICB2YXIgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfc3RhdGVtZW50KCk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQ1NVxuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ0FUQ0gpIHtcbiAgICAgIHZhciBpdGVtID0gdGhpcy5ub2RlKFwiY2F0Y2hcIik7XG4gICAgICB0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgdmFyIHdoYXQgPSB0aGlzLnJlYWRfbGlzdCh0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUsIFwifFwiLCBmYWxzZSk7XG4gICAgICB2YXIgdmFyaWFibGUgPSB0aGlzLnJlYWRfdmFyaWFibGUodHJ1ZSwgZmFsc2UpO1xuICAgICAgdGhpcy5leHBlY3QoXCIpXCIpO1xuICAgICAgY2F0Y2hlcy5wdXNoKGl0ZW0odGhpcy5uZXh0KCkucmVhZF9zdGF0ZW1lbnQoKSwgd2hhdCwgdmFyaWFibGUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GSU5BTExZKSB7XG4gICAgICBhbHdheXMgPSB0aGlzLm5leHQoKS5yZWFkX3N0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQoYm9keSwgY2F0Y2hlcywgYWx3YXlzKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVhZHMgYSBzaG9ydCBmb3JtIG9mIHRva2Vuc1xuICAgKiBAcGFyYW0ge051bWJlcn0gdG9rZW4gLSBUaGUgZW5kaW5nIHRva2VuXG4gICAqIEByZXR1cm4ge0Jsb2NrfVxuICAgKi9cbiAgcmVhZF9zaG9ydF9mb3JtOiBmdW5jdGlvbiByZWFkX3Nob3J0X2Zvcm0odG9rZW4pIHtcbiAgICB2YXIgYm9keSA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIjpcIikpIHRoaXMubmV4dCgpO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gdG9rZW4pIHtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy5yZWFkX2lubmVyX3N0YXRlbWVudCgpKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHRoaXMuZXh0cmFjdERvYyAmJiB0aGlzLl9kb2NzLmxlbmd0aCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMubm9kZShcIm5vb3BcIikoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRva2VuKSkgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgIHJldHVybiBib2R5KG51bGwsIGl0ZW1zKTtcbiAgfSxcblxuICAvKipcbiAgICogaHR0cHM6Ly93aWtpLnBocC5uZXQvcmZjL3RyYWlsaW5nLWNvbW1hLWZ1bmN0aW9uLWNhbGxzXG4gICAqIEBwYXJhbSB7Kn0gaXRlbVxuICAgKiBAcGFyYW0geyp9IHNlcGFyYXRvclxuICAgKi9cbiAgcmVhZF9mdW5jdGlvbl9saXN0OiBmdW5jdGlvbiByZWFkX2Z1bmN0aW9uX2xpc3QoaXRlbSwgc2VwYXJhdG9yKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRoaXMudG9rZW4gPT0gc2VwYXJhdG9yICYmIHRoaXMudmVyc2lvbiA+PSA3MDMgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5ub2RlKFwibm9vcFwiKSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0uYXBwbHkodGhpcywgW10pKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gIT0gc2VwYXJhdG9yKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uZXh0KCkudG9rZW4gPT0gXCIpXCIgJiYgdGhpcy52ZXJzaW9uID49IDcwMykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciA6IHJlYWRzIGEgbGlzdCBvZiB0b2tlbnMgLyBzYW1wbGUgOiBUX1NUUklORyAnLCcgVF9TVFJJTkcgLi4uXG4gICAqIGBgYGVibmZcbiAgICogbGlzdCA6Oj0gc2VwYXJhdG9yPyAoIGl0ZW0gc2VwYXJhdG9yICkqIGl0ZW1cbiAgICogYGBgXG4gICAqL1xuICByZWFkX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfbGlzdChpdGVtLCBzZXBhcmF0b3IsIHByZXNlcnZlRmlyc3RTZXBhcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PSBzZXBhcmF0b3IpIHtcbiAgICAgIGlmIChwcmVzZXJ2ZUZpcnN0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLm5vZGUoXCJub29wXCIpKCkgOiBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGl0ZW1SZXN1bHQgPSBpdGVtLmFwcGx5KHRoaXMsIFtdKTtcblxuICAgICAgICBpZiAoaXRlbVJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW1SZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9rZW4gIT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRoaXMubmV4dCgpLnRva2VuICE9IHRoaXMuRU9GKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXhwZWN0KGl0ZW0pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudGV4dCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnRva2VuICE9IHRoaXMuRU9GKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuICE9IHNlcGFyYXRvcikgYnJlYWs7IC8vIHRyaW0gY3VycmVudCBzZXBhcmF0b3IgJiBjaGVjayBpdGVtXG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuICE9IGl0ZW0pIGJyZWFrO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnRleHQoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBsaXN0IG9mIG5hbWVzIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAqXG4gICAqIGBgYGVibmZcbiAgICogbmFtZV9saXN0IDo6PSBuYW1lc3BhY2UgKCcsJyBuYW1lc3BhY2UpKlxuICAgKiBgYGBcbiAgICpcbiAgICogU2FtcGxlIGNvZGUgOlxuICAgKiBgYGBwaHBcbiAgICogPD9waHAgY2xhc3MgZm9vIGV4dGVuZHMgYmFyLCBiYXogeyB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDcyNlxuICAgKiBAcmV0dXJuIHtSZWZlcmVuY2VbXX1cbiAgICovXG4gIHJlYWRfbmFtZV9saXN0OiBmdW5jdGlvbiByZWFkX25hbWVfbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2xpc3QodGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lLCBcIixcIiwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgYnlyZWYgdG9rZW4gYW5kIGFzc2lnbiBpdCB0byB0aGUgc3BlY2lmaWVkIG5vZGVcbiAgICogQHBhcmFtIHsqfSBjYlxuICAgKi9cbiAgcmVhZF9ieXJlZjogZnVuY3Rpb24gcmVhZF9ieXJlZihjYikge1xuICAgIHZhciBieXJlZiA9IHRoaXMubm9kZShcImJ5cmVmXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGJ5cmVmID0gYnlyZWYobnVsbCk7XG4gICAgdmFyIHJlc3VsdCA9IGNiKCk7XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmFzdC5zd2FwTG9jYXRpb25zKHJlc3VsdCwgYnlyZWYsIHJlc3VsdCwgdGhpcyk7XG4gICAgICByZXN1bHQuYnlyZWYgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiB2YXJpYWJsZXMgZGVjbGFyYXRpb25zXG4gICAqXG4gICAqIGBgYGVibmZcbiAgICogdmFyaWFibGVfZGVjbGFyYXRpb24gOjo9IFRfVkFSSUFCTEUgKCc9JyBleHByKT8qXG4gICAqIHZhcmlhYmxlX2RlY2xhcmF0aW9ucyA6Oj0gdmFyaWFibGVfZGVjbGFyYXRpb24gKCcsJyB2YXJpYWJsZV9kZWNsYXJhdGlvbikqXG4gICAqIGBgYFxuICAgKlxuICAgKiBTYW1wbGUgY29kZSA6XG4gICAqIGBgYHBocFxuICAgKiA8P3BocCBzdGF0aWMgJGEgPSAnaGVsbG8nLCAkYiA9ICd3b3JsZCc7XG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTdGF0aWNWYXJpYWJsZVtdfSBSZXR1cm5zIGFuIGFycmF5IGNvbXBvc2VkIGJ5IGEgbGlzdCBvZiB2YXJpYWJsZXMsIG9yXG4gICAqIGFzc2lnbiB2YWx1ZXNcbiAgICovXG4gIHJlYWRfdmFyaWFibGVfZGVjbGFyYXRpb25zOiBmdW5jdGlvbiByZWFkX3ZhcmlhYmxlX2RlY2xhcmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2xpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoXCJzdGF0aWN2YXJpYWJsZVwiKTtcbiAgICAgIHZhciB2YXJpYWJsZSA9IHRoaXMubm9kZShcInZhcmlhYmxlXCIpOyAvLyBwbGFpbiB2YXJpYWJsZSBuYW1lXG5cbiAgICAgIGlmICh0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1ZBUklBQkxFKSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpLnN1YnN0cmluZygxKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUobmFtZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZShcIiNFUlJcIiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI9XCIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUodmFyaWFibGUsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICAgIH1cbiAgICB9LCBcIixcIik7XG4gIH0sXG5cbiAgLypcbiAgICogUmVhZHMgY2xhc3MgZXh0ZW5kc1xuICAgKi9cbiAgcmVhZF9leHRlbmRzX2Zyb206IGZ1bmN0aW9uIHJlYWRfZXh0ZW5kc19mcm9tKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VYVEVORFMpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQoKS5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLypcbiAgICogUmVhZHMgaW50ZXJmYWNlIGV4dGVuZHMgbGlzdFxuICAgKi9cbiAgcmVhZF9pbnRlcmZhY2VfZXh0ZW5kc19saXN0OiBmdW5jdGlvbiByZWFkX2ludGVyZmFjZV9leHRlbmRzX2xpc3QoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRVhURU5EUykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCgpLnJlYWRfbmFtZV9saXN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLypcbiAgICogUmVhZHMgaW1wbGVtZW50cyBsaXN0XG4gICAqL1xuICByZWFkX2ltcGxlbWVudHNfbGlzdDogZnVuY3Rpb24gcmVhZF9pbXBsZW1lbnRzX2xpc3QoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSU1QTEVNRU5UUykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCgpLnJlYWRfbmFtZV9saXN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGEgdmFyaWFibGVcbiAgICpcbiAgICogYGBgZWJuZlxuICAgKiAgIHZhcmlhYmxlIDo6PSAmPyAuLi5jb21wbGV4IEB0b2RvXG4gICAqIGBgYFxuICAgKlxuICAgKiBTb21lIHNhbXBsZXMgb2YgcGFyc2VkIGNvZGUgOlxuICAgKiBgYGBwaHBcbiAgICogICYkdmFyICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbXBsZSB2YXJcbiAgICogICR2YXIgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGxlIHZhclxuICAgKiAgY2xhc3NuYW1lOjpDT05TVF9OQU1FICAgICAvLyBkeW5hbWljIGNsYXNzIG5hbWUgd2l0aCBjb25zdCByZXRyaWV2YWxcbiAgICogIGZvbygpICAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gY2FsbFxuICAgKiAgJHZhci0+ZnVuYygpLT5wcm9wZXJ0eSAgICAvLyBjaGFpbmVkIGNhbGxzXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF92YXJpYWJsZTogZnVuY3Rpb24gcmVhZF92YXJpYWJsZShyZWFkX29ubHksIGVuY2Fwc2VkKSB7XG4gICAgdmFyIHJlc3VsdDsgLy8gY2hlY2sgdGhlIGJ5cmVmIGZsYWdcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF9ieXJlZih0aGlzLnJlYWRfdmFyaWFibGUuYmluZCh0aGlzLCByZWFkX29ubHksIGVuY2Fwc2VkKSk7XG4gICAgfSAvLyByZWFkcyB0aGUgZW50cnkgcG9pbnRcblxuXG4gICAgaWYgKHRoaXMuaXMoW3RoaXMudG9rLlRfVkFSSUFCTEUsIFwiJFwiXSkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9yZWZlcmVuY2VfdmFyaWFibGUoZW5jYXBzZWQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pcyhbdGhpcy50b2suVF9OU19TRVBBUkFUT1IsIHRoaXMudG9rLlRfU1RSSU5HLCB0aGlzLnRvay5UX05BTUVTUEFDRV0pKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLm5vZGUoKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuICE9IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OICYmIHRoaXMudG9rZW4gIT0gXCIoXCIgJiYgW1wicGFyZW50cmVmZXJlbmNlXCIsIFwic2VsZnJlZmVyZW5jZVwiXS5pbmRleE9mKG5hbWUua2luZCkgPT09IC0xKSB7XG4gICAgICAgIC8vIEBzZWUgcGFyc2VyLmpzIGxpbmUgMTMwIDogcmVzb2x2ZXMgYSBjb25mbGljdCB3aXRoIHNjYWxhclxuICAgICAgICB2YXIgbGl0ZXJhbCA9IG5hbWUubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChsaXRlcmFsID09PSBcInRydWVcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5hbWUuZGVzdHJveShyZXN1bHQoXCJib29sZWFuXCIsIHRydWUsIG5hbWUubmFtZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpdGVyYWwgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5hbWUuZGVzdHJveShyZXN1bHQoXCJib29sZWFuXCIsIGZhbHNlLCBuYW1lLm5hbWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaXRlcmFsID09PSBcIm51bGxcIikge1xuICAgICAgICAgIHJlc3VsdCA9IG5hbWUuZGVzdHJveShyZXN1bHQoXCJudWxsa2V5d29yZFwiLCBuYW1lLm5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuZGVzdHJveShuYW1lKTtcbiAgICAgICAgICByZXN1bHQgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBAZml4bWUgcG9zc2libGUgIzE5MyBidWdcbiAgICAgICAgcmVzdWx0LmRlc3Ryb3kobmFtZSk7XG4gICAgICAgIHJlc3VsdCA9IG5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUQVRJQykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwic3RhdGljcmVmZXJlbmNlXCIpO1xuICAgICAgdmFyIHJhdyA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXN1bHQgPSByZXN1bHQocmF3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoXCJWQVJJQUJMRVwiKTtcbiAgICB9IC8vIHN0YXRpYyBtb2RlXG5cblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPVUJMRV9DT0xPTikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX3N0YXRpY19nZXR0ZXIocmVzdWx0LCBlbmNhcHNlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlX3ZhcmlhYmxlX2NoYWluX3NjYW4ocmVzdWx0LCByZWFkX29ubHksIGVuY2Fwc2VkKTtcbiAgfSxcbiAgLy8gcmVzb2x2ZXMgYSBzdGF0aWMgY2FsbFxuICByZWFkX3N0YXRpY19nZXR0ZXI6IGZ1bmN0aW9uIHJlYWRfc3RhdGljX2dldHRlcih3aGF0LCBlbmNhcHNlZCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJzdGF0aWNsb29rdXBcIik7XG4gICAgdmFyIG9mZnNldCwgbmFtZTtcblxuICAgIGlmICh0aGlzLm5leHQoKS5pcyhbdGhpcy50b2suVF9WQVJJQUJMRSwgXCIkXCJdKSkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkX3JlZmVyZW5jZV92YXJpYWJsZShlbmNhcHNlZCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORyB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NMQVNTIHx8IHRoaXMudmVyc2lvbiA+PSA3MDAgJiYgdGhpcy5pcyhcIklERU5USUZJRVJcIikpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldChuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IFwie1wiKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLm5vZGUoXCJsaXRlcmFsXCIpO1xuICAgICAgbmFtZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KFwibGl0ZXJhbFwiLCBuYW1lLCBudWxsKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwiKFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcihbdGhpcy50b2suVF9WQVJJQUJMRSwgdGhpcy50b2suVF9TVFJJTkddKTsgLy8gZ3JhY2VmdWwgbW9kZSA6IHNldCBnZXR0ZXIgYXMgZXJyb3Igbm9kZSBhbmQgY29udGludWVcblxuICAgICAgb2Zmc2V0ID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQod2hhdCwgb2Zmc2V0KTtcbiAgfSxcbiAgcmVhZF93aGF0OiBmdW5jdGlvbiByZWFkX3doYXQoKSB7XG4gICAgdmFyIGlzX3N0YXRpY19sb29rdXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciB3aGF0ID0gbnVsbDtcbiAgICB2YXIgbmFtZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRoaXMubmV4dCgpLnRva2VuKSB7XG4gICAgICBjYXNlIHRoaXMudG9rLlRfU1RSSU5HOlxuICAgICAgICB3aGF0ID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgd2hhdCA9IHdoYXQobmFtZSk7XG5cbiAgICAgICAgaWYgKGlzX3N0YXRpY19sb29rdXAgJiYgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9PQkpFQ1RfT1BFUkFUT1IpIHtcbiAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1ZBUklBQkxFOlxuICAgICAgICB3aGF0ID0gdGhpcy5ub2RlKFwidmFyaWFibGVcIik7XG4gICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB3aGF0ID0gd2hhdChuYW1lLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiJFwiOlxuICAgICAgICB3aGF0ID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpLmV4cGVjdChbXCIkXCIsIFwie1wiLCB0aGlzLnRvay5UX1ZBUklBQkxFXSk7XG5cbiAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IFwie1wiKSB7XG4gICAgICAgICAgLy8gJG9iai0+JHskdmFybmFtZX1cbiAgICAgICAgICBuYW1lID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHdoYXQgPSB3aGF0KFwidmFyaWFibGVcIiwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJG9iai0+JCR2YXJuYW1lXG4gICAgICAgICAgbmFtZSA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgICAgICAgd2hhdCA9IHdoYXQoXCJ2YXJpYWJsZVwiLCBuYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgd2hhdCA9IHRoaXMubm9kZShcImVuY2Fwc2VkcGFydFwiKTtcbiAgICAgICAgbmFtZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgIHdoYXQgPSB3aGF0KG5hbWUsIFwiY29tcGxleFwiLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmVycm9yKFt0aGlzLnRvay5UX1NUUklORywgdGhpcy50b2suVF9WQVJJQUJMRSwgXCIkXCIsIFwie1wiXSk7IC8vIGdyYWNlZnVsIG1vZGUgOiBzZXQgd2hhdCBhcyBlcnJvciBtb2RlICYgY29udGludWVcblxuICAgICAgICB3aGF0ID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgd2hhdCA9IHdoYXQobmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB3aGF0O1xuICB9LFxuICByZWN1cnNpdmVfdmFyaWFibGVfY2hhaW5fc2NhbjogZnVuY3Rpb24gcmVjdXJzaXZlX3ZhcmlhYmxlX2NoYWluX3NjYW4ocmVzdWx0LCByZWFkX29ubHksIGVuY2Fwc2VkKSB7XG4gICAgdmFyIG5vZGUsIG9mZnNldDtcblxuICAgIHJlY3Vyc2l2ZV9zY2FuX2xvb3A6IHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICBpZiAocmVhZF9vbmx5KSB7XG4gICAgICAgICAgICAvLyBAZml4bWUgOiBhZGQgbW9yZSBpbmZvcm1hdGlvbnMgJiB0ZXN0XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJjYWxsXCIpKHJlc3VsdCwgdGhpcy5yZWFkX2FyZ3VtZW50X2xpc3QoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYmFja2V0ID0gdGhpcy50b2tlbjtcbiAgICAgICAgICAgIHZhciBpc1NxdWFyZUJyYWNrZXQgPSBiYWNrZXQgPT09IFwiW1wiO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcIm9mZnNldGxvb2t1cFwiKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChlbmNhcHNlZCkge1xuICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRfZW5jYXBzX3Zhcl9vZmZzZXQoKTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3QoaXNTcXVhcmVCcmFja2V0ID8gXCJdXCIgOiBcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaXNDYWxsYWJsZVZhcmlhYmxlID0gaXNTcXVhcmVCcmFja2V0ID8gdGhpcy50b2tlbiAhPT0gXCJdXCIgOiB0aGlzLnRva2VuICE9PSBcIn1cIjsgLy8gY2FsbGFibGVfdmFyaWFibGUgOiBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi80OTM1MjQ0NTRkNjZhZGRlODRlMDBkMjQ5ZDYwN2VjZDU0MGRlOTlmL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTEyMlxuXG4gICAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KGlzU3F1YXJlQnJhY2tldCA/IFwiXVwiIDogXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUocmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9ET1VCTEVfQ09MT046XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvMTA3I2lzc3VlY29tbWVudC0zNTQxMDQ1NzRcbiAgICAgICAgICBpZiAocmVzdWx0LmtpbmQgPT09IFwic3RhdGljbG9va3VwXCIgJiYgcmVzdWx0Lm9mZnNldC5raW5kID09PSBcImlkZW50aWZpZXJcIikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUoXCJzdGF0aWNsb29rdXBcIik7XG4gICAgICAgICAgcmVzdWx0ID0gbm9kZShyZXN1bHQsIHRoaXMucmVhZF93aGF0KHRydWUpKTsgLy8gZml4IDE4NVxuICAgICAgICAgIC8vIHN0YXRpYyBsb29rdXAgZGVyZWZlcmVuY2FibGVzIGFyZSBsaW1pdGVkIHRvIHN0YXRpY2xvb2t1cCBvdmVyIGZ1bmN0aW9uc1xuXG4gICAgICAgICAgLyppZiAoZGVyZWZlcmVuY2FibGUgJiYgdGhpcy50b2tlbiAhPT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCIoXCIpO1xuICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX09CSkVDVF9PUEVSQVRPUjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ub2RlKFwicHJvcGVydHlsb29rdXBcIik7XG4gICAgICAgICAgICByZXN1bHQgPSBub2RlKHJlc3VsdCwgdGhpcy5yZWFkX3doYXQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhayByZWN1cnNpdmVfc2Nhbl9sb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iLzQ5MzUyNDQ1NGQ2NmFkZGU4NGUwMGQyNDlkNjA3ZWNkNTQwZGU5OWYvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMjMxXG4gICAqL1xuICByZWFkX2VuY2Fwc192YXJfb2Zmc2V0OiBmdW5jdGlvbiByZWFkX2VuY2Fwc192YXJfb2Zmc2V0KCkge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm5vZGUoKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORykge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KFwiaWRlbnRpZmllclwiLCB0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTlVNX1NUUklORykge1xuICAgICAgdmFyIG51bSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQoXCJudW1iZXJcIiwgbnVtLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IFwiLVwiKSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIF9udW0gPSAtMSAqIHRoaXMudGV4dCgpO1xuXG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX05VTV9TVFJJTkcpICYmIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KFwibnVtYmVyXCIsIF9udW0sIG51bGwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9WQVJJQUJMRSkge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldChcInZhcmlhYmxlXCIsIG5hbWUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoW3RoaXMudG9rLlRfU1RSSU5HLCB0aGlzLnRvay5UX05VTV9TVFJJTkcsIFwiLVwiLCB0aGlzLnRvay5UX1ZBUklBQkxFXSk7IC8vIGZhbGxiYWNrIDogY29uc2lkZXIgYXMgaWRlbnRpZmllclxuXG4gICAgICB2YXIgX3RleHQgPSB0aGlzLnRleHQoKTtcblxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQoXCJpZGVudGlmaWVyXCIsIF90ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICByZWZlcmVuY2VfdmFyaWFibGUgOjo9ICBzaW1wbGVfdmFyaWFibGUgKCdbJyBPRkZTRVQgJ10nKSogfCAneycgRVhQUiAnfSdcbiAgICogYGBgXG4gICAqIDxjb2RlPlxuICAgKiAgJGZvb1sxMjNdOyAgICAgIC8vIGZvbyBpcyBhbiBhcnJheSA9PT4gZ2V0cyBpdHMgZW50cnlcbiAgICogICRmb297MX07ICAgICAgICAvLyBmb28gaXMgYSBzdHJpbmcgPT0+IGdldCB0aGUgMm5kIGNoYXIgb2Zmc2V0XG4gICAqICAkeydmb28nfVsxMjNdOyAgLy8gZ2V0IHRoZSBkeW5hbWljIHZhciAkZm9vXG4gICAqICAkZm9vWzEyM117MX07ICAgLy8gZ2V0cyB0aGUgMm5kIGNoYXIgZnJvbSB0aGUgMTIzIGFycmF5IGVudHJ5XG4gICAqIDwvY29kZT5cbiAgICovXG4gIHJlYWRfcmVmZXJlbmNlX3ZhcmlhYmxlOiBmdW5jdGlvbiByZWFkX3JlZmVyZW5jZV92YXJpYWJsZShlbmNhcHNlZCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlYWRfc2ltcGxlX3ZhcmlhYmxlKCk7XG4gICAgdmFyIG9mZnNldDtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PSBcIntcIiAmJiAhZW5jYXBzZWQpIHtcbiAgICAgICAgLy8gQGZpeG1lIGNoZWNrIGNvdmVyYWdlLCBub3Qgc3VyZSB0aGF0cyB3b3JraW5nXG4gICAgICAgIG9mZnNldCA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IG5vZGUoXCJvZmZzZXRsb29rdXBcIiwgcmVzdWx0LCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5kZXN0cm95KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHNpbXBsZV92YXJpYWJsZSA6Oj0gVF9WQVJJQUJMRSB8ICckJyAneycgZXhwciAnfScgfCAnJCcgc2ltcGxlX3ZhcmlhYmxlXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9zaW1wbGVfdmFyaWFibGU6IGZ1bmN0aW9uIHJlYWRfc2ltcGxlX3ZhcmlhYmxlKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJ2YXJpYWJsZVwiKTtcbiAgICB2YXIgbmFtZTtcblxuICAgIGlmICh0aGlzLmV4cGVjdChbdGhpcy50b2suVF9WQVJJQUJMRSwgXCIkXCJdKSAmJiB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1ZBUklBQkxFKSB7XG4gICAgICAvLyBwbGFpbiB2YXJpYWJsZSBuYW1lXG4gICAgICBuYW1lID0gdGhpcy50ZXh0KCkuc3Vic3RyaW5nKDEpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXN1bHQgPSByZXN1bHQobmFtZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCIkXCIpIHRoaXMubmV4dCgpOyAvLyBkeW5hbWljIHZhcmlhYmxlIG5hbWVcblxuICAgICAgc3dpdGNoICh0aGlzLnRva2VuKSB7XG4gICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdChleHByLCB0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgIC8vICQkJHZhclxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCh0aGlzLnJlYWRfc2ltcGxlX3ZhcmlhYmxlKCksIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfVkFSSUFCTEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gJCR2YXJcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcInZhcmlhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQobm9kZShuYW1lLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMuZXJyb3IoW1wie1wiLCBcIiRcIiwgdGhpcy50b2suVF9WQVJJQUJMRV0pOyAvLyBncmFjZWZ1bCBtb2RlXG5cbiAgICAgICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KG5hbWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qKlxuICogUEhQIEFTVCBUb2tlbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbHVlczoge1xuICAgIDEwMTogXCJUX0hBTFRfQ09NUElMRVJcIixcbiAgICAxMDI6IFwiVF9VU0VcIixcbiAgICAxMDM6IFwiVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRVwiLFxuICAgIDEwNDogXCJUX09CSkVDVF9PUEVSQVRPUlwiLFxuICAgIDEwNTogXCJUX1NUUklOR1wiLFxuICAgIDEwNjogXCJUX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFU1wiLFxuICAgIDEwNzogXCJUX1NUUklOR19WQVJOQU1FXCIsXG4gICAgMTA4OiBcIlRfQ1VSTFlfT1BFTlwiLFxuICAgIDEwOTogXCJUX05VTV9TVFJJTkdcIixcbiAgICAxMTA6IFwiVF9JU1NFVFwiLFxuICAgIDExMTogXCJUX0VNUFRZXCIsXG4gICAgMTEyOiBcIlRfSU5DTFVERVwiLFxuICAgIDExMzogXCJUX0lOQ0xVREVfT05DRVwiLFxuICAgIDExNDogXCJUX0VWQUxcIixcbiAgICAxMTU6IFwiVF9SRVFVSVJFXCIsXG4gICAgMTE2OiBcIlRfUkVRVUlSRV9PTkNFXCIsXG4gICAgMTE3OiBcIlRfTkFNRVNQQUNFXCIsXG4gICAgMTE4OiBcIlRfTlNfU0VQQVJBVE9SXCIsXG4gICAgMTE5OiBcIlRfQVNcIixcbiAgICAxMjA6IFwiVF9JRlwiLFxuICAgIDEyMTogXCJUX0VORElGXCIsXG4gICAgMTIyOiBcIlRfV0hJTEVcIixcbiAgICAxMjM6IFwiVF9ET1wiLFxuICAgIDEyNDogXCJUX0ZPUlwiLFxuICAgIDEyNTogXCJUX1NXSVRDSFwiLFxuICAgIDEyNjogXCJUX0JSRUFLXCIsXG4gICAgMTI3OiBcIlRfQ09OVElOVUVcIixcbiAgICAxMjg6IFwiVF9SRVRVUk5cIixcbiAgICAxMjk6IFwiVF9HTE9CQUxcIixcbiAgICAxMzA6IFwiVF9TVEFUSUNcIixcbiAgICAxMzE6IFwiVF9FQ0hPXCIsXG4gICAgMTMyOiBcIlRfSU5MSU5FX0hUTUxcIixcbiAgICAxMzM6IFwiVF9VTlNFVFwiLFxuICAgIDEzNDogXCJUX0ZPUkVBQ0hcIixcbiAgICAxMzU6IFwiVF9ERUNMQVJFXCIsXG4gICAgMTM2OiBcIlRfVFJZXCIsXG4gICAgMTM3OiBcIlRfVEhST1dcIixcbiAgICAxMzg6IFwiVF9HT1RPXCIsXG4gICAgMTM5OiBcIlRfRklOQUxMWVwiLFxuICAgIDE0MDogXCJUX0NBVENIXCIsXG4gICAgMTQxOiBcIlRfRU5EREVDTEFSRVwiLFxuICAgIDE0MjogXCJUX0xJU1RcIixcbiAgICAxNDM6IFwiVF9DTE9ORVwiLFxuICAgIDE0NDogXCJUX1BMVVNfRVFVQUxcIixcbiAgICAxNDU6IFwiVF9NSU5VU19FUVVBTFwiLFxuICAgIDE0NjogXCJUX01VTF9FUVVBTFwiLFxuICAgIDE0NzogXCJUX0RJVl9FUVVBTFwiLFxuICAgIDE0ODogXCJUX0NPTkNBVF9FUVVBTFwiLFxuICAgIDE0OTogXCJUX01PRF9FUVVBTFwiLFxuICAgIDE1MDogXCJUX0FORF9FUVVBTFwiLFxuICAgIDE1MTogXCJUX09SX0VRVUFMXCIsXG4gICAgMTUyOiBcIlRfWE9SX0VRVUFMXCIsXG4gICAgMTUzOiBcIlRfU0xfRVFVQUxcIixcbiAgICAxNTQ6IFwiVF9TUl9FUVVBTFwiLFxuICAgIDE1NTogXCJUX0lOQ1wiLFxuICAgIDE1NjogXCJUX0RFQ1wiLFxuICAgIDE1NzogXCJUX0JPT0xFQU5fT1JcIixcbiAgICAxNTg6IFwiVF9CT09MRUFOX0FORFwiLFxuICAgIDE1OTogXCJUX0xPR0lDQUxfT1JcIixcbiAgICAxNjA6IFwiVF9MT0dJQ0FMX0FORFwiLFxuICAgIDE2MTogXCJUX0xPR0lDQUxfWE9SXCIsXG4gICAgMTYyOiBcIlRfU0xcIixcbiAgICAxNjM6IFwiVF9TUlwiLFxuICAgIDE2NDogXCJUX0lTX0lERU5USUNBTFwiLFxuICAgIDE2NTogXCJUX0lTX05PVF9JREVOVElDQUxcIixcbiAgICAxNjY6IFwiVF9JU19FUVVBTFwiLFxuICAgIDE2NzogXCJUX0lTX05PVF9FUVVBTFwiLFxuICAgIDE2ODogXCJUX0lTX1NNQUxMRVJfT1JfRVFVQUxcIixcbiAgICAxNjk6IFwiVF9JU19HUkVBVEVSX09SX0VRVUFMXCIsXG4gICAgMTcwOiBcIlRfSU5TVEFOQ0VPRlwiLFxuICAgIDE3MTogXCJUX0lOVF9DQVNUXCIsXG4gICAgMTcyOiBcIlRfRE9VQkxFX0NBU1RcIixcbiAgICAxNzM6IFwiVF9TVFJJTkdfQ0FTVFwiLFxuICAgIDE3NDogXCJUX0FSUkFZX0NBU1RcIixcbiAgICAxNzU6IFwiVF9PQkpFQ1RfQ0FTVFwiLFxuICAgIDE3NjogXCJUX0JPT0xfQ0FTVFwiLFxuICAgIDE3NzogXCJUX1VOU0VUX0NBU1RcIixcbiAgICAxNzg6IFwiVF9FWElUXCIsXG4gICAgMTc5OiBcIlRfUFJJTlRcIixcbiAgICAxODA6IFwiVF9ZSUVMRFwiLFxuICAgIDE4MTogXCJUX1lJRUxEX0ZST01cIixcbiAgICAxODI6IFwiVF9GVU5DVElPTlwiLFxuICAgIDE4MzogXCJUX0RPVUJMRV9BUlJPV1wiLFxuICAgIDE4NDogXCJUX0RPVUJMRV9DT0xPTlwiLFxuICAgIDE4NTogXCJUX0FSUkFZXCIsXG4gICAgMTg2OiBcIlRfQ0FMTEFCTEVcIixcbiAgICAxODc6IFwiVF9DTEFTU1wiLFxuICAgIDE4ODogXCJUX0FCU1RSQUNUXCIsXG4gICAgMTg5OiBcIlRfVFJBSVRcIixcbiAgICAxOTA6IFwiVF9GSU5BTFwiLFxuICAgIDE5MTogXCJUX0VYVEVORFNcIixcbiAgICAxOTI6IFwiVF9JTlRFUkZBQ0VcIixcbiAgICAxOTM6IFwiVF9JTVBMRU1FTlRTXCIsXG4gICAgMTk0OiBcIlRfVkFSXCIsXG4gICAgMTk1OiBcIlRfUFVCTElDXCIsXG4gICAgMTk2OiBcIlRfUFJPVEVDVEVEXCIsXG4gICAgMTk3OiBcIlRfUFJJVkFURVwiLFxuICAgIDE5ODogXCJUX0NPTlNUXCIsXG4gICAgMTk5OiBcIlRfTkVXXCIsXG4gICAgMjAwOiBcIlRfSU5TVEVBRE9GXCIsXG4gICAgMjAxOiBcIlRfRUxTRUlGXCIsXG4gICAgMjAyOiBcIlRfRUxTRVwiLFxuICAgIDIwMzogXCJUX0VORFNXSVRDSFwiLFxuICAgIDIwNDogXCJUX0NBU0VcIixcbiAgICAyMDU6IFwiVF9ERUZBVUxUXCIsXG4gICAgMjA2OiBcIlRfRU5ERk9SXCIsXG4gICAgMjA3OiBcIlRfRU5ERk9SRUFDSFwiLFxuICAgIDIwODogXCJUX0VORFdISUxFXCIsXG4gICAgMjA5OiBcIlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HXCIsXG4gICAgMjEwOiBcIlRfTE5VTUJFUlwiLFxuICAgIDIxMTogXCJUX0ROVU1CRVJcIixcbiAgICAyMTI6IFwiVF9MSU5FXCIsXG4gICAgMjEzOiBcIlRfRklMRVwiLFxuICAgIDIxNDogXCJUX0RJUlwiLFxuICAgIDIxNTogXCJUX1RSQUlUX0NcIixcbiAgICAyMTY6IFwiVF9NRVRIT0RfQ1wiLFxuICAgIDIxNzogXCJUX0ZVTkNfQ1wiLFxuICAgIDIxODogXCJUX05TX0NcIixcbiAgICAyMTk6IFwiVF9TVEFSVF9IRVJFRE9DXCIsXG4gICAgMjIwOiBcIlRfRU5EX0hFUkVET0NcIixcbiAgICAyMjE6IFwiVF9DTEFTU19DXCIsXG4gICAgMjIyOiBcIlRfVkFSSUFCTEVcIixcbiAgICAyMjM6IFwiVF9PUEVOX1RBR1wiLFxuICAgIDIyNDogXCJUX09QRU5fVEFHX1dJVEhfRUNIT1wiLFxuICAgIDIyNTogXCJUX0NMT1NFX1RBR1wiLFxuICAgIDIyNjogXCJUX1dISVRFU1BBQ0VcIixcbiAgICAyMjc6IFwiVF9DT01NRU5UXCIsXG4gICAgMjI4OiBcIlRfRE9DX0NPTU1FTlRcIixcbiAgICAyMjk6IFwiVF9FTExJUFNJU1wiLFxuICAgIDIzMDogXCJUX0NPQUxFU0NFXCIsXG4gICAgMjMxOiBcIlRfUE9XXCIsXG4gICAgMjMyOiBcIlRfUE9XX0VRVUFMXCIsXG4gICAgMjMzOiBcIlRfU1BBQ0VTSElQXCIsXG4gICAgMjM0OiBcIlRfQ09BTEVTQ0VfRVFVQUxcIixcbiAgICAyMzU6IFwiVF9GTlwiXG4gIH0sXG4gIG5hbWVzOiB7XG4gICAgVF9IQUxUX0NPTVBJTEVSOiAxMDEsXG4gICAgVF9VU0U6IDEwMixcbiAgICBUX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFOiAxMDMsXG4gICAgVF9PQkpFQ1RfT1BFUkFUT1I6IDEwNCxcbiAgICBUX1NUUklORzogMTA1LFxuICAgIFRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTOiAxMDYsXG4gICAgVF9TVFJJTkdfVkFSTkFNRTogMTA3LFxuICAgIFRfQ1VSTFlfT1BFTjogMTA4LFxuICAgIFRfTlVNX1NUUklORzogMTA5LFxuICAgIFRfSVNTRVQ6IDExMCxcbiAgICBUX0VNUFRZOiAxMTEsXG4gICAgVF9JTkNMVURFOiAxMTIsXG4gICAgVF9JTkNMVURFX09OQ0U6IDExMyxcbiAgICBUX0VWQUw6IDExNCxcbiAgICBUX1JFUVVJUkU6IDExNSxcbiAgICBUX1JFUVVJUkVfT05DRTogMTE2LFxuICAgIFRfTkFNRVNQQUNFOiAxMTcsXG4gICAgVF9OU19TRVBBUkFUT1I6IDExOCxcbiAgICBUX0FTOiAxMTksXG4gICAgVF9JRjogMTIwLFxuICAgIFRfRU5ESUY6IDEyMSxcbiAgICBUX1dISUxFOiAxMjIsXG4gICAgVF9ETzogMTIzLFxuICAgIFRfRk9SOiAxMjQsXG4gICAgVF9TV0lUQ0g6IDEyNSxcbiAgICBUX0JSRUFLOiAxMjYsXG4gICAgVF9DT05USU5VRTogMTI3LFxuICAgIFRfUkVUVVJOOiAxMjgsXG4gICAgVF9HTE9CQUw6IDEyOSxcbiAgICBUX1NUQVRJQzogMTMwLFxuICAgIFRfRUNITzogMTMxLFxuICAgIFRfSU5MSU5FX0hUTUw6IDEzMixcbiAgICBUX1VOU0VUOiAxMzMsXG4gICAgVF9GT1JFQUNIOiAxMzQsXG4gICAgVF9ERUNMQVJFOiAxMzUsXG4gICAgVF9UUlk6IDEzNixcbiAgICBUX1RIUk9XOiAxMzcsXG4gICAgVF9HT1RPOiAxMzgsXG4gICAgVF9GSU5BTExZOiAxMzksXG4gICAgVF9DQVRDSDogMTQwLFxuICAgIFRfRU5EREVDTEFSRTogMTQxLFxuICAgIFRfTElTVDogMTQyLFxuICAgIFRfQ0xPTkU6IDE0MyxcbiAgICBUX1BMVVNfRVFVQUw6IDE0NCxcbiAgICBUX01JTlVTX0VRVUFMOiAxNDUsXG4gICAgVF9NVUxfRVFVQUw6IDE0NixcbiAgICBUX0RJVl9FUVVBTDogMTQ3LFxuICAgIFRfQ09OQ0FUX0VRVUFMOiAxNDgsXG4gICAgVF9NT0RfRVFVQUw6IDE0OSxcbiAgICBUX0FORF9FUVVBTDogMTUwLFxuICAgIFRfT1JfRVFVQUw6IDE1MSxcbiAgICBUX1hPUl9FUVVBTDogMTUyLFxuICAgIFRfU0xfRVFVQUw6IDE1MyxcbiAgICBUX1NSX0VRVUFMOiAxNTQsXG4gICAgVF9JTkM6IDE1NSxcbiAgICBUX0RFQzogMTU2LFxuICAgIFRfQk9PTEVBTl9PUjogMTU3LFxuICAgIFRfQk9PTEVBTl9BTkQ6IDE1OCxcbiAgICBUX0xPR0lDQUxfT1I6IDE1OSxcbiAgICBUX0xPR0lDQUxfQU5EOiAxNjAsXG4gICAgVF9MT0dJQ0FMX1hPUjogMTYxLFxuICAgIFRfU0w6IDE2MixcbiAgICBUX1NSOiAxNjMsXG4gICAgVF9JU19JREVOVElDQUw6IDE2NCxcbiAgICBUX0lTX05PVF9JREVOVElDQUw6IDE2NSxcbiAgICBUX0lTX0VRVUFMOiAxNjYsXG4gICAgVF9JU19OT1RfRVFVQUw6IDE2NyxcbiAgICBUX0lTX1NNQUxMRVJfT1JfRVFVQUw6IDE2OCxcbiAgICBUX0lTX0dSRUFURVJfT1JfRVFVQUw6IDE2OSxcbiAgICBUX0lOU1RBTkNFT0Y6IDE3MCxcbiAgICBUX0lOVF9DQVNUOiAxNzEsXG4gICAgVF9ET1VCTEVfQ0FTVDogMTcyLFxuICAgIFRfU1RSSU5HX0NBU1Q6IDE3MyxcbiAgICBUX0FSUkFZX0NBU1Q6IDE3NCxcbiAgICBUX09CSkVDVF9DQVNUOiAxNzUsXG4gICAgVF9CT09MX0NBU1Q6IDE3NixcbiAgICBUX1VOU0VUX0NBU1Q6IDE3NyxcbiAgICBUX0VYSVQ6IDE3OCxcbiAgICBUX1BSSU5UOiAxNzksXG4gICAgVF9ZSUVMRDogMTgwLFxuICAgIFRfWUlFTERfRlJPTTogMTgxLFxuICAgIFRfRlVOQ1RJT046IDE4MixcbiAgICBUX0RPVUJMRV9BUlJPVzogMTgzLFxuICAgIFRfRE9VQkxFX0NPTE9OOiAxODQsXG4gICAgVF9BUlJBWTogMTg1LFxuICAgIFRfQ0FMTEFCTEU6IDE4NixcbiAgICBUX0NMQVNTOiAxODcsXG4gICAgVF9BQlNUUkFDVDogMTg4LFxuICAgIFRfVFJBSVQ6IDE4OSxcbiAgICBUX0ZJTkFMOiAxOTAsXG4gICAgVF9FWFRFTkRTOiAxOTEsXG4gICAgVF9JTlRFUkZBQ0U6IDE5MixcbiAgICBUX0lNUExFTUVOVFM6IDE5MyxcbiAgICBUX1ZBUjogMTk0LFxuICAgIFRfUFVCTElDOiAxOTUsXG4gICAgVF9QUk9URUNURUQ6IDE5NixcbiAgICBUX1BSSVZBVEU6IDE5NyxcbiAgICBUX0NPTlNUOiAxOTgsXG4gICAgVF9ORVc6IDE5OSxcbiAgICBUX0lOU1RFQURPRjogMjAwLFxuICAgIFRfRUxTRUlGOiAyMDEsXG4gICAgVF9FTFNFOiAyMDIsXG4gICAgVF9FTkRTV0lUQ0g6IDIwMyxcbiAgICBUX0NBU0U6IDIwNCxcbiAgICBUX0RFRkFVTFQ6IDIwNSxcbiAgICBUX0VOREZPUjogMjA2LFxuICAgIFRfRU5ERk9SRUFDSDogMjA3LFxuICAgIFRfRU5EV0hJTEU6IDIwOCxcbiAgICBUX0NPTlNUQU5UX0VOQ0FQU0VEX1NUUklORzogMjA5LFxuICAgIFRfTE5VTUJFUjogMjEwLFxuICAgIFRfRE5VTUJFUjogMjExLFxuICAgIFRfTElORTogMjEyLFxuICAgIFRfRklMRTogMjEzLFxuICAgIFRfRElSOiAyMTQsXG4gICAgVF9UUkFJVF9DOiAyMTUsXG4gICAgVF9NRVRIT0RfQzogMjE2LFxuICAgIFRfRlVOQ19DOiAyMTcsXG4gICAgVF9OU19DOiAyMTgsXG4gICAgVF9TVEFSVF9IRVJFRE9DOiAyMTksXG4gICAgVF9FTkRfSEVSRURPQzogMjIwLFxuICAgIFRfQ0xBU1NfQzogMjIxLFxuICAgIFRfVkFSSUFCTEU6IDIyMixcbiAgICBUX09QRU5fVEFHOiAyMjMsXG4gICAgVF9PUEVOX1RBR19XSVRIX0VDSE86IDIyNCxcbiAgICBUX0NMT1NFX1RBRzogMjI1LFxuICAgIFRfV0hJVEVTUEFDRTogMjI2LFxuICAgIFRfQ09NTUVOVDogMjI3LFxuICAgIFRfRE9DX0NPTU1FTlQ6IDIyOCxcbiAgICBUX0VMTElQU0lTOiAyMjksXG4gICAgVF9DT0FMRVNDRTogMjMwLFxuICAgIFRfUE9XOiAyMzEsXG4gICAgVF9QT1dfRVFVQUw6IDIzMixcbiAgICBUX1NQQUNFU0hJUDogMjMzLFxuICAgIFRfQ09BTEVTQ0VfRVFVQUw6IDIzNCxcbiAgICBUX0ZOOiAyMzVcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMb2NhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgUG9zaXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbi8qKlxuICogIyMgQ2xhc3MgaGllcmFyY2h5XG4gKlxuICogLSBbTG9jYXRpb25dKCNsb2NhdGlvbilcbiAqIC0gW1Bvc2l0aW9uXSgjcG9zaXRpb24pXG4gKiAtIFtOb2RlXSgjbm9kZSlcbiAqICAgLSBbTm9vcF0oI25vb3ApXG4gKiAgIC0gW051bGxLZXl3b3JkXSgjbnVsbGtleXdvcmQpXG4gKiAgIC0gW1N0YXRpY1ZhcmlhYmxlXSgjc3RhdGljdmFyaWFibGUpXG4gKiAgIC0gW0VuY2Fwc2VkUGFydF0oI2VuY2Fwc2VkcGFydClcbiAqICAgLSBbQ29uc3RhbnRdKCNjb25zdGFudClcbiAqICAgLSBbSWRlbnRpZmllcl0oI2lkZW50aWZpZXIpXG4gKiAgIC0gW1JlZmVyZW5jZV0oI3JlZmVyZW5jZSlcbiAqICAgICAtIFtUeXBlUmVmZXJlbmNlXSgjdHlwZXJlZmVyZW5jZSlcbiAqICAgICAtIFtQYXJlbnRSZWZlcmVuY2VdKCNwYXJlbnRyZWZlcmVuY2UpXG4gKiAgICAgLSBbU3RhdGljUmVmZXJlbmNlXSgjc3RhdGljcmVmZXJlbmNlKVxuICogICAgIC0gW1NlbGZSZWZlcmVuY2VdKCNzZWxmcmVmZXJlbmNlKVxuICogICAgIC0gW05hbWVdKCNuYW1lKVxuICogICAtIFtUcmFpdFVzZV0oI3RyYWl0dXNlKVxuICogICAtIFtUcmFpdEFsaWFzXSgjdHJhaXRhbGlhcylcbiAqICAgLSBbVHJhaXRQcmVjZWRlbmNlXSgjdHJhaXRwcmVjZWRlbmNlKVxuICogICAtIFtDb21tZW50XSgjY29tbWVudClcbiAqICAgICAtIFtDb21tZW50TGluZV0oI2NvbW1lbnRsaW5lKVxuICogICAgIC0gW0NvbW1lbnRCbG9ja10oI2NvbW1lbnRibG9jaylcbiAqICAgLSBbRXJyb3JdKCNlcnJvcilcbiAqICAgLSBbRXhwcmVzc2lvbl0oI2V4cHJlc3Npb24pXG4gKiAgICAgLSBbRW50cnldKCNlbnRyeSlcbiAqICAgICAtIFtBcnJvd0Z1bmNdKCNhcnJvd2Z1bmMpXG4gKiAgICAgLSBbQ2xvc3VyZV0oI2Nsb3N1cmUpXG4gKiAgICAgLSBbQnlSZWZdKCNieXJlZilcbiAqICAgICAtIFtTaWxlbnRdKCNzaWxlbnQpXG4gKiAgICAgLSBbUmV0SWZdKCNyZXRpZilcbiAqICAgICAtIFtOZXddKCNuZXcpXG4gKiAgICAgLSBbSW5jbHVkZV0oI2luY2x1ZGUpXG4gKiAgICAgLSBbQ2FsbF0oI2NhbGwpXG4gKiAgICAgLSBbRXZhbF0oI2V2YWwpXG4gKiAgICAgLSBbRXhpdF0oI2V4aXQpXG4gKiAgICAgLSBbQ2xvbmVdKCNjbG9uZSlcbiAqICAgICAtIFtBc3NpZ25dKCNhc3NpZ24pXG4gKiAgICAgLSBbQXNzaWduUmVmXSgjYXNzaWducmVmKVxuICogICAgIC0gW0FycmF5XSgjYXJyYXkpXG4gKiAgICAgLSBbTGlzdF0oI2xpc3QpXG4gKiAgICAgLSBbVmFyaWFibGVdKCN2YXJpYWJsZSlcbiAqICAgICAtIFtWYXJpYWRpY10oI3ZhcmlhZGljKVxuICogICAgIC0gW1lpZWxkXSgjeWllbGQpXG4gKiAgICAgLSBbWWllbGRGcm9tXSgjeWllbGRmcm9tKVxuICogICAgIC0gW1ByaW50XSgjcHJpbnQpXG4gKiAgICAgLSBbSXNzZXRdKCNpc3NldClcbiAqICAgICAtIFtFbXB0eV0oI2VtcHR5KVxuICogICAgIC0gW0xvb2t1cF0oI2xvb2t1cClcbiAqICAgICAgIC0gW1Byb3BlcnR5TG9va3VwXSgjcHJvcGVydHlsb29rdXApXG4gKiAgICAgICAtIFtTdGF0aWNMb29rdXBdKCNzdGF0aWNsb29rdXApXG4gKiAgICAgICAtIFtPZmZzZXRMb29rdXBdKCNvZmZzZXRsb29rdXApXG4gKiAgICAgLSBbT3BlcmF0aW9uXSgjb3BlcmF0aW9uKVxuICogICAgICAgLSBbUHJlXSgjcHJlKVxuICogICAgICAgLSBbUG9zdF0oI3Bvc3QpXG4gKiAgICAgICAtIFtCaW5dKCNiaW4pXG4gKiAgICAgICAtIFtVbmFyeV0oI3VuYXJ5KVxuICogICAgICAgLSBbQ2FzdF0oI2Nhc3QpXG4gKiAgICAgLSBbTGl0ZXJhbF0oI2xpdGVyYWwpXG4gKiAgICAgICAtIFtCb29sZWFuXSgjYm9vbGVhbilcbiAqICAgICAgIC0gW1N0cmluZ10oI3N0cmluZylcbiAqICAgICAgIC0gW051bWJlcl0oI251bWJlcilcbiAqICAgICAgIC0gW0lubGluZV0oI2lubGluZSlcbiAqICAgICAgIC0gW01hZ2ljXSgjbWFnaWMpXG4gKiAgICAgICAtIFtOb3dkb2NdKCNub3dkb2MpXG4gKiAgICAgICAtIFtFbmNhcHNlZF0oI2VuY2Fwc2VkKVxuICogICAtIFtTdGF0ZW1lbnRdKCNzdGF0ZW1lbnQpXG4gKiAgICAgLSBbQ29uc3RhbnRTdGF0ZW1lbnRdKCNjb25zdGFudHN0YXRlbWVudClcbiAqICAgICAgIC0gW0NsYXNzQ29uc3RhbnRdKCNjbGFzc2NvbnN0YW50KVxuICogICAgIC0gW1JldHVybl0oI3JldHVybilcbiAqICAgICAtIFtMYWJlbF0oI2xhYmVsKVxuICogICAgIC0gW0NvbnRpbnVlXSgjY29udGludWUpXG4gKiAgICAgLSBbQ2FzZV0oI2Nhc2UpXG4gKiAgICAgLSBbQnJlYWtdKCNicmVhaylcbiAqICAgICAtIFtFY2hvXSgjZWNobylcbiAqICAgICAtIFtVbnNldF0oI3Vuc2V0KVxuICogICAgIC0gW0hhbHRdKCNoYWx0KVxuICogICAgIC0gW0RlY2xhcmVdKCNkZWNsYXJlKVxuICogICAgIC0gW0dsb2JhbF0oI2dsb2JhbClcbiAqICAgICAtIFtTdGF0aWNdKCNzdGF0aWMpXG4gKiAgICAgLSBbSWZdKCNpZilcbiAqICAgICAtIFtEb10oI2RvKVxuICogICAgIC0gW1doaWxlXSgjd2hpbGUpXG4gKiAgICAgLSBbRm9yXSgjZm9yKVxuICogICAgIC0gW0ZvcmVhY2hdKCNmb3JlYWNoKVxuICogICAgIC0gW1N3aXRjaF0oI3N3aXRjaClcbiAqICAgICAtIFtHb3RvXSgjZ290bylcbiAqICAgICAtIFtUcnldKCN0cnkpXG4gKiAgICAgLSBbQ2F0Y2hdKCNjYXRjaClcbiAqICAgICAtIFtUaHJvd10oI3Rocm93KVxuICogICAgIC0gW1VzZUdyb3VwXSgjdXNlZ3JvdXApXG4gKiAgICAgLSBbVXNlSXRlbV0oI3VzZWl0ZW0pXG4gKiAgICAgLSBbQmxvY2tdKCNibG9jaylcbiAqICAgICAgIC0gW1Byb2dyYW1dKCNwcm9ncmFtKVxuICogICAgICAgLSBbTmFtZXNwYWNlXSgjbmFtZXNwYWNlKVxuICogICAgIC0gW1Byb3BlcnR5U3RhdGVtZW50XSgjcHJvcGVydHlzdGF0ZW1lbnQpXG4gKiAgICAgLSBbUHJvcGVydHldKCNwcm9wZXJ0eSlcbiAqICAgICAtIFtEZWNsYXJhdGlvbl0oI2RlY2xhcmF0aW9uKVxuICogICAgICAgLSBbQ2xhc3NdKCNjbGFzcylcbiAqICAgICAgIC0gW0ludGVyZmFjZV0oI2ludGVyZmFjZSlcbiAqICAgICAgIC0gW1RyYWl0XSgjdHJhaXQpXG4gKiAgICAgICAtIFtGdW5jdGlvbl0oI2Z1bmN0aW9uKVxuICogICAgICAgICAtIFtNZXRob2RdKCNtZXRob2QpXG4gKiAgICAgICAtIFtQYXJhbWV0ZXJdKCNwYXJhbWV0ZXIpXG4gKiAtLS1cbiAqL1xuXG4vKipcbiAqIFRoZSBBU1QgYnVpbGRlciBjbGFzc1xuICogQGNvbnN0cnVjdG9yIEFTVFxuICogQHR1dG9yaWFsIEFTVFxuICogQHByb3BlcnR5IHtCb29sZWFufSB3aXRoUG9zaXRpb25zIC0gU2hvdWxkIGxvY2F0ZSBhbnkgbm9kZSAoYnkgZGVmYXVsdCBmYWxzZSlcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gd2l0aFNvdXJjZSAtIFNob3VsZCBleHRyYWN0IHRoZSBub2RlIG9yaWdpbmFsIGNvZGUgKGJ5IGRlZmF1bHQgZmFsc2UpXG4gKi9cblxuXG52YXIgQVNUID0gZnVuY3Rpb24gQVNUKHdpdGhQb3NpdGlvbnMsIHdpdGhTb3VyY2UpIHtcbiAgdGhpcy53aXRoUG9zaXRpb25zID0gd2l0aFBvc2l0aW9ucztcbiAgdGhpcy53aXRoU291cmNlID0gd2l0aFNvdXJjZTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIHBvc2l0aW9uIG5vZGUgZnJvbSBzcGVjaWZpZWQgcGFyc2VyXG4gKiBpbmNsdWRpbmcgaXQncyBsZXhlciBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge1BhcnNlcn1cbiAqIEByZXR1cm4ge1Bvc2l0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuXG5cbkFTVC5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24ocGFyc2VyLmxleGVyLnl5bGxvYy5maXJzdF9saW5lLCBwYXJzZXIubGV4ZXIueXlsbG9jLmZpcnN0X2NvbHVtbiwgcGFyc2VyLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQpO1xufTsgLy8gb3BlcmF0b3JzIGluIGFzY2VuZGluZyBvcmRlciBvZiBwcmVjZWRlbmNlXG5cblxuQVNULnByZWNlZGVuY2UgPSB7fTtcbltbXCJvclwiXSwgW1wieG9yXCJdLCBbXCJhbmRcIl0sIFtcIj1cIl0sIFtcIj9cIl0sIFtcIj8/XCJdLCBbXCJ8fFwiXSwgW1wiJiZcIl0sIFtcInxcIl0sIFtcIl5cIl0sIFtcIiZcIl0sIFtcIj09XCIsIFwiIT1cIiwgXCI9PT1cIiwgXCIhPT1cIixcbi8qICc8PicsICovXG5cIjw9PlwiXSwgW1wiPFwiLCBcIjw9XCIsIFwiPlwiLCBcIj49XCJdLCBbXCI8PFwiLCBcIj4+XCJdLCBbXCIrXCIsIFwiLVwiLCBcIi5cIl0sIFtcIipcIiwgXCIvXCIsIFwiJVwiXSwgW1wiIVwiXSwgW1wiaW5zdGFuY2VvZlwiXSwgW1wiY2FzdFwiLCBcInNpbGVudFwiXSwgW1wiKipcIl0gLy8gVE9ETzogWyAoYXJyYXkpXG4vLyBUT0RPOiBjbG9uZSwgbmV3XG5dLmZvckVhY2goZnVuY3Rpb24gKGxpc3QsIGluZGV4KSB7XG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICBBU1QucHJlY2VkZW5jZVtvcGVyYXRvcl0gPSBpbmRleCArIDE7XG4gIH0pO1xufSk7XG5cbkFTVC5wcm90b3R5cGUuaXNSaWdodEFzc29jaWF0aXZlID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIqKlwiIHx8IG9wZXJhdG9yID09PSBcIj8/XCI7XG59O1xuLyoqXG4gKiBDaGFuZ2UgcGFyZW50IG5vZGUgaW5mb3JtYXRpb25zIGFmdGVyIHN3YXBwaW5nIGNoaWxkc1xuICovXG5cblxuQVNULnByb3RvdHlwZS5zd2FwTG9jYXRpb25zID0gZnVuY3Rpb24gKHRhcmdldCwgZmlyc3QsIGxhc3QsIHBhcnNlcikge1xuICBpZiAodGhpcy53aXRoUG9zaXRpb25zKSB7XG4gICAgdGFyZ2V0LmxvYy5zdGFydCA9IGZpcnN0LmxvYy5zdGFydDtcbiAgICB0YXJnZXQubG9jLmVuZCA9IGxhc3QubG9jLmVuZDtcblxuICAgIGlmICh0aGlzLndpdGhTb3VyY2UpIHtcbiAgICAgIHRhcmdldC5sb2Muc291cmNlID0gcGFyc2VyLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGFyZ2V0LmxvYy5zdGFydC5vZmZzZXQsIHRhcmdldC5sb2MuZW5kLm9mZnNldCk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBJbmNsdWRlcyBsb2NhdGlvbnMgZnJvbSBmaXJzdCAmIGxhc3QgaW50byB0aGUgdGFyZ2V0XG4gKi9cblxuXG5BU1QucHJvdG90eXBlLnJlc29sdmVMb2NhdGlvbnMgPSBmdW5jdGlvbiAodGFyZ2V0LCBmaXJzdCwgbGFzdCwgcGFyc2VyKSB7XG4gIGlmICh0aGlzLndpdGhQb3NpdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0LmxvYy5zdGFydC5vZmZzZXQgPiBmaXJzdC5sb2Muc3RhcnQub2Zmc2V0KSB7XG4gICAgICB0YXJnZXQubG9jLnN0YXJ0ID0gZmlyc3QubG9jLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQubG9jLmVuZC5vZmZzZXQgPCBsYXN0LmxvYy5lbmQub2Zmc2V0KSB7XG4gICAgICB0YXJnZXQubG9jLmVuZCA9IGxhc3QubG9jLmVuZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53aXRoU291cmNlKSB7XG4gICAgICB0YXJnZXQubG9jLnNvdXJjZSA9IHBhcnNlci5sZXhlci5faW5wdXQuc3Vic3RyaW5nKHRhcmdldC5sb2Muc3RhcnQub2Zmc2V0LCB0YXJnZXQubG9jLmVuZC5vZmZzZXQpO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQ2hlY2sgYW5kIGZpeCBwcmVjZW5jZSwgYnkgZGVmYXVsdCB1c2luZyByaWdodFxuICovXG5cblxuQVNULnByb3RvdHlwZS5yZXNvbHZlUHJlY2VkZW5jZSA9IGZ1bmN0aW9uIChyZXN1bHQsIHBhcnNlcikge1xuICB2YXIgYnVmZmVyLCBsTGV2ZWwsIHJMZXZlbDsgLy8gaGFuZGxpbmcgcHJlY2VuZGVuY2VcblxuICBpZiAocmVzdWx0LmtpbmQgPT09IFwiY2FsbFwiKSB7XG4gICAgLy8gaW5jbHVkaW5nIHdoYXQgYXJndW1lbnQgaW50byBsb2NhdGlvblxuICAgIHRoaXMucmVzb2x2ZUxvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC53aGF0LCByZXN1bHQsIHBhcnNlcik7XG4gIH0gZWxzZSBpZiAocmVzdWx0LmtpbmQgPT09IFwicHJvcGVydHlsb29rdXBcIiB8fCByZXN1bHQua2luZCA9PT0gXCJzdGF0aWNsb29rdXBcIiB8fCByZXN1bHQua2luZCA9PT0gXCJvZmZzZXRsb29rdXBcIiAmJiByZXN1bHQub2Zmc2V0KSB7XG4gICAgLy8gaW5jbHVkaW5nIHdoYXQgYXJndW1lbnQgaW50byBsb2NhdGlvblxuICAgIHRoaXMucmVzb2x2ZUxvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC53aGF0LCByZXN1bHQub2Zmc2V0LCBwYXJzZXIpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5raW5kID09PSBcImJpblwiKSB7XG4gICAgaWYgKHJlc3VsdC5yaWdodCAmJiAhcmVzdWx0LnJpZ2h0LnBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKSB7XG4gICAgICBpZiAocmVzdWx0LnJpZ2h0LmtpbmQgPT09IFwiYmluXCIpIHtcbiAgICAgICAgbExldmVsID0gQVNULnByZWNlZGVuY2VbcmVzdWx0LnR5cGVdO1xuICAgICAgICByTGV2ZWwgPSBBU1QucHJlY2VkZW5jZVtyZXN1bHQucmlnaHQudHlwZV07XG5cbiAgICAgICAgaWYgKGxMZXZlbCAmJiByTGV2ZWwgJiYgckxldmVsIDw9IGxMZXZlbCAmJiAhdGhpcy5pc1JpZ2h0QXNzb2NpYXRpdmUocmVzdWx0LnR5cGUpKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzc5XG4gICAgICAgICAgLy8gc2hpZnQgcHJlY2VkZW5jZVxuICAgICAgICAgIGJ1ZmZlciA9IHJlc3VsdC5yaWdodDtcbiAgICAgICAgICByZXN1bHQucmlnaHQgPSByZXN1bHQucmlnaHQubGVmdDtcbiAgICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMocmVzdWx0LCByZXN1bHQubGVmdCwgcmVzdWx0LnJpZ2h0LCBwYXJzZXIpO1xuICAgICAgICAgIGJ1ZmZlci5sZWZ0ID0gdGhpcy5yZXNvbHZlUHJlY2VkZW5jZShyZXN1bHQsIHBhcnNlcik7XG4gICAgICAgICAgdGhpcy5zd2FwTG9jYXRpb25zKGJ1ZmZlciwgYnVmZmVyLmxlZnQsIGJ1ZmZlci5yaWdodCwgcGFyc2VyKTtcbiAgICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnJpZ2h0LmtpbmQgPT09IFwicmV0aWZcIikge1xuICAgICAgICBsTGV2ZWwgPSBBU1QucHJlY2VkZW5jZVtyZXN1bHQudHlwZV07XG4gICAgICAgIHJMZXZlbCA9IEFTVC5wcmVjZWRlbmNlW1wiP1wiXTtcblxuICAgICAgICBpZiAobExldmVsICYmIHJMZXZlbCAmJiByTGV2ZWwgPD0gbExldmVsKSB7XG4gICAgICAgICAgYnVmZmVyID0gcmVzdWx0LnJpZ2h0O1xuICAgICAgICAgIHJlc3VsdC5yaWdodCA9IHJlc3VsdC5yaWdodC50ZXN0O1xuICAgICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC5sZWZ0LCByZXN1bHQucmlnaHQsIHBhcnNlcik7XG4gICAgICAgICAgYnVmZmVyLnRlc3QgPSB0aGlzLnJlc29sdmVQcmVjZWRlbmNlKHJlc3VsdCwgcGFyc2VyKTtcbiAgICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIudGVzdCwgYnVmZmVyLmZhbHNlRXhwciwgcGFyc2VyKTtcbiAgICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoKHJlc3VsdC5raW5kID09PSBcInNpbGVudFwiIHx8IHJlc3VsdC5raW5kID09PSBcImNhc3RcIikgJiYgcmVzdWx0LmV4cHIgJiYgIXJlc3VsdC5leHByLnBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzE3MlxuICAgIGlmIChyZXN1bHQuZXhwci5raW5kID09PSBcImJpblwiKSB7XG4gICAgICBidWZmZXIgPSByZXN1bHQuZXhwcjtcbiAgICAgIHJlc3VsdC5leHByID0gcmVzdWx0LmV4cHIubGVmdDtcbiAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdCwgcmVzdWx0LmV4cHIsIHBhcnNlcik7XG4gICAgICBidWZmZXIubGVmdCA9IHRoaXMucmVzb2x2ZVByZWNlZGVuY2UocmVzdWx0LCBwYXJzZXIpO1xuICAgICAgdGhpcy5zd2FwTG9jYXRpb25zKGJ1ZmZlciwgYnVmZmVyLmxlZnQsIGJ1ZmZlci5yaWdodCwgcGFyc2VyKTtcbiAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5leHByLmtpbmQgPT09IFwicmV0aWZcIikge1xuICAgICAgYnVmZmVyID0gcmVzdWx0LmV4cHI7XG4gICAgICByZXN1bHQuZXhwciA9IHJlc3VsdC5leHByLnRlc3Q7XG4gICAgICB0aGlzLnN3YXBMb2NhdGlvbnMocmVzdWx0LCByZXN1bHQsIHJlc3VsdC5leHByLCBwYXJzZXIpO1xuICAgICAgYnVmZmVyLnRlc3QgPSB0aGlzLnJlc29sdmVQcmVjZWRlbmNlKHJlc3VsdCwgcGFyc2VyKTtcbiAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci50ZXN0LCBidWZmZXIuZmFsc2VFeHByLCBwYXJzZXIpO1xuICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZXN1bHQua2luZCA9PT0gXCJ1bmFyeVwiKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzc1XG4gICAgaWYgKHJlc3VsdC53aGF0ICYmICFyZXN1bHQud2hhdC5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbikge1xuICAgICAgLy8gdW5hcnkgcHJlY2VkZW5jZSBpcyBhbGx3YXlzIGxvd2VyXG4gICAgICBpZiAocmVzdWx0LndoYXQua2luZCA9PT0gXCJiaW5cIikge1xuICAgICAgICBidWZmZXIgPSByZXN1bHQud2hhdDtcbiAgICAgICAgcmVzdWx0LndoYXQgPSByZXN1bHQud2hhdC5sZWZ0O1xuICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMocmVzdWx0LCByZXN1bHQsIHJlc3VsdC53aGF0LCBwYXJzZXIpO1xuICAgICAgICBidWZmZXIubGVmdCA9IHRoaXMucmVzb2x2ZVByZWNlZGVuY2UocmVzdWx0LCBwYXJzZXIpO1xuICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIubGVmdCwgYnVmZmVyLnJpZ2h0LCBwYXJzZXIpO1xuICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdC53aGF0LmtpbmQgPT09IFwicmV0aWZcIikge1xuICAgICAgICBidWZmZXIgPSByZXN1bHQud2hhdDtcbiAgICAgICAgcmVzdWx0LndoYXQgPSByZXN1bHQud2hhdC50ZXN0O1xuICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMocmVzdWx0LCByZXN1bHQsIHJlc3VsdC53aGF0LCBwYXJzZXIpO1xuICAgICAgICBidWZmZXIudGVzdCA9IHRoaXMucmVzb2x2ZVByZWNlZGVuY2UocmVzdWx0LCBwYXJzZXIpO1xuICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIudGVzdCwgYnVmZmVyLmZhbHNlRXhwciwgcGFyc2VyKTtcbiAgICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyZXN1bHQua2luZCA9PT0gXCJyZXRpZlwiKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzc3XG4gICAgaWYgKHJlc3VsdC5mYWxzZUV4cHIgJiYgcmVzdWx0LmZhbHNlRXhwci5raW5kID09PSBcInJldGlmXCIgJiYgIXJlc3VsdC5mYWxzZUV4cHIucGFyZW50aGVzaXplZEV4cHJlc3Npb24pIHtcbiAgICAgIGJ1ZmZlciA9IHJlc3VsdC5mYWxzZUV4cHI7XG4gICAgICByZXN1bHQuZmFsc2VFeHByID0gYnVmZmVyLnRlc3Q7XG4gICAgICB0aGlzLnN3YXBMb2NhdGlvbnMocmVzdWx0LCByZXN1bHQudGVzdCwgcmVzdWx0LmZhbHNlRXhwciwgcGFyc2VyKTtcbiAgICAgIGJ1ZmZlci50ZXN0ID0gdGhpcy5yZXNvbHZlUHJlY2VkZW5jZShyZXN1bHQsIHBhcnNlcik7XG4gICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIudGVzdCwgYnVmZmVyLmZhbHNlRXhwciwgcGFyc2VyKTtcbiAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzdWx0LmtpbmQgPT09IFwiYXNzaWduXCIpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvODFcbiAgICBpZiAocmVzdWx0LnJpZ2h0ICYmIHJlc3VsdC5yaWdodC5raW5kID09PSBcImJpblwiICYmICFyZXN1bHQucmlnaHQucGFyZW50aGVzaXplZEV4cHJlc3Npb24pIHtcbiAgICAgIGxMZXZlbCA9IEFTVC5wcmVjZWRlbmNlW1wiPVwiXTtcbiAgICAgIHJMZXZlbCA9IEFTVC5wcmVjZWRlbmNlW3Jlc3VsdC5yaWdodC50eXBlXTsgLy8gb25seSBzaGlmdHMgd2l0aCBhbmQsIHhvciwgb3JcblxuICAgICAgaWYgKGxMZXZlbCAmJiByTGV2ZWwgJiYgckxldmVsIDwgbExldmVsKSB7XG4gICAgICAgIGJ1ZmZlciA9IHJlc3VsdC5yaWdodDtcbiAgICAgICAgcmVzdWx0LnJpZ2h0ID0gcmVzdWx0LnJpZ2h0LmxlZnQ7XG4gICAgICAgIGJ1ZmZlci5sZWZ0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIubGVmdCwgcmVzdWx0LnJpZ2h0LCBwYXJzZXIpO1xuICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlc3VsdC5raW5kID09PSBcImV4cHJlc3Npb25zdGF0ZW1lbnRcIikge1xuICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC5leHByZXNzaW9uLCByZXN1bHQsIHBhcnNlcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogUHJlcGFyZXMgYW4gQVNUIG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IGtpbmQgLSBEZWZpbmVzIHRoZSBub2RlIHR5cGVcbiAqIChpZiBudWxsLCB0aGUga2luZCBtdXN0IGJlIHBhc3NlZCBhdCB0aGUgZnVuY3Rpb24gY2FsbClcbiAqIEBwYXJhbSB7UGFyc2VyfSBwYXJzZXIgLSBUaGUgcGFyc2VyIGluc3RhbmNlICh1c2UgZm9yIGV4dHJhY3RpbmcgbG9jYXRpb25zKVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuXG5BU1QucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbiAoa2luZCwgZG9jcywgcGFyc2VyKSB7XG4gIHZhciBzdGFydCA9IG51bGw7XG5cbiAgaWYgKHRoaXMud2l0aFBvc2l0aW9ucyB8fCB0aGlzLndpdGhTb3VyY2UpIHtcbiAgICBzdGFydCA9IHRoaXMucG9zaXRpb24ocGFyc2VyKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpczsgLy8gcmV0dXJucyB0aGUgbm9kZVxuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbiByZXN1bHQoKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbnVsbDtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgYXJncy5wdXNoKGRvY3MpO1xuXG4gICAgaWYgKHNlbGYud2l0aFBvc2l0aW9ucyB8fCBzZWxmLndpdGhTb3VyY2UpIHtcbiAgICAgIHZhciBzcmMgPSBudWxsO1xuXG4gICAgICBpZiAoc2VsZi53aXRoU291cmNlKSB7XG4gICAgICAgIHNyYyA9IHBhcnNlci5sZXhlci5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCwgcGFyc2VyLnByZXZbMl0pO1xuICAgICAgfSAvLyBpZiB3aXRoIHNvdXJjZSwgbmVlZCBsb2NhdGlvbiBvbiBzd2FwTG9jYXRpb25zIGZ1bmN0aW9uXG5cblxuICAgICAgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24oc3JjLCBzdGFydCwgbmV3IFBvc2l0aW9uKHBhcnNlci5wcmV2WzBdLCBwYXJzZXIucHJldlsxXSwgcGFyc2VyLnByZXZbMl0pKTsgLy8gbGFzdCBhcmd1bWVudCBpcyBhbGx3YXlzIHRoZSBsb2NhdGlvblxuXG4gICAgICBhcmdzLnB1c2gobG9jYXRpb24pO1xuICAgIH0gLy8gaGFuZGxlIGxhenkga2luZCBkZWZpbml0aW9uc1xuXG5cbiAgICBpZiAoIWtpbmQpIHtcbiAgICAgIGtpbmQgPSBhcmdzLnNoaWZ0KCk7XG4gICAgfSAvLyBidWlsZCB0aGUgb2JqZWN0XG5cblxuICAgIHZhciBub2RlID0gc2VsZltraW5kXTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZGVmaW5lZCBub2RlIFwiJyArIGtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICB2YXIgYXN0Tm9kZSA9IE9iamVjdC5jcmVhdGUobm9kZS5wcm90b3R5cGUpO1xuICAgIG5vZGUuYXBwbHkoYXN0Tm9kZSwgYXJncyk7XG4gICAgcmVzdWx0Lmluc3RhbmNlID0gYXN0Tm9kZTtcblxuICAgIGlmIChyZXN1bHQudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgLy8gYnVmZmVyIG9mIHRyYWlsaW5nQ29tbWVudHNcbiAgICAgIGFzdE5vZGUudHJhaWxpbmdDb21tZW50cyA9IHJlc3VsdC50cmFpbGluZ0NvbW1lbnRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzdWx0LnBvc3RCdWlsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXN1bHQucG9zdEJ1aWxkKGFzdE5vZGUpO1xuICAgIH1cblxuICAgIGlmIChwYXJzZXIuZGVidWcpIHtcbiAgICAgIGRlbGV0ZSBBU1Quc3RhY2tbcmVzdWx0LnN0YWNrVWlkXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5yZXNvbHZlUHJlY2VkZW5jZShhc3ROb2RlLCBwYXJzZXIpO1xuICB9O1xuXG4gIGlmIChwYXJzZXIuZGVidWcpIHtcbiAgICBpZiAoIUFTVC5zdGFjaykge1xuICAgICAgQVNULnN0YWNrID0ge307XG4gICAgICBBU1Quc3RhY2tVaWQgPSAxO1xuICAgIH1cblxuICAgIEFTVC5zdGFja1srK0FTVC5zdGFja1VpZF0gPSB7XG4gICAgICBwb3NpdGlvbjogc3RhcnQsXG4gICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMywgNSlcbiAgICB9O1xuICAgIHJlc3VsdC5zdGFja1VpZCA9IEFTVC5zdGFja1VpZDtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIGxpc3Qgb2YgdHJhaWxpbmcgY29tbWVudHNcbiAgICogQHBhcmFtIHsqfSBkb2NzXG4gICAqL1xuXG5cbiAgcmVzdWx0LnNldFRyYWlsaW5nQ29tbWVudHMgPSBmdW5jdGlvbiAoZG9jcykge1xuICAgIGlmIChyZXN1bHQuaW5zdGFuY2UpIHtcbiAgICAgIC8vIGFscmVhZHkgY3JlYXRlZFxuICAgICAgcmVzdWx0Lmluc3RhbmNlLnNldFRyYWlsaW5nQ29tbWVudHMoZG9jcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC50cmFpbGluZ0NvbW1lbnRzID0gZG9jcztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBSZWxlYXNlIGEgbm9kZSB3aXRob3V0IHVzaW5nIGl0IG9uIHRoZSBBU1RcbiAgICovXG5cblxuICByZXN1bHQuZGVzdHJveSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBpZiAoZG9jcykge1xuICAgICAgLy8gcmVsZWFzZSBjdXJyZW50IGRvY3Mgc3RhY2tcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cyA9IGRvY3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cyA9IGRvY3MuY29uY2F0KHRhcmdldC5sZWFkaW5nQ29tbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZXIuX2RvY0luZGV4ID0gcGFyc2VyLl9kb2NzLmxlbmd0aCAtIGRvY3MubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuZGVidWcpIHtcbiAgICAgIGRlbGV0ZSBBU1Quc3RhY2tbcmVzdWx0LnN0YWNrVWlkXTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkFTVC5wcm90b3R5cGUuY2hlY2tOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGsgaW4gQVNULnN0YWNrKSB7XG4gICAgaWYgKEFTVC5zdGFjay5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgZXJyb3JzLnB1c2goQVNULnN0YWNrW2tdKTtcbiAgICB9XG4gIH1cblxuICBBU1Quc3RhY2sgPSB7fTtcbiAgcmV0dXJuIGVycm9ycztcbn07IC8vIERlZmluZSBhbGwgQVNUIG5vZGVzXG5cblxuW19fd2VicGFja19yZXF1aXJlX18oNDMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NSksIF9fd2VicGFja19yZXF1aXJlX18oNDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0OCksIF9fd2VicGFja19yZXF1aXJlX18oNDkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1MSksIF9fd2VicGFja19yZXF1aXJlX18oNTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksIF9fd2VicGFja19yZXF1aXJlX18oNTUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1NyksIF9fd2VicGFja19yZXF1aXJlX18oNTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MCksIF9fd2VicGFja19yZXF1aXJlX18oNjEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MiksIF9fd2VicGFja19yZXF1aXJlX18oNSksIF9fd2VicGFja19yZXF1aXJlX18oNjMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2NSksIF9fd2VicGFja19yZXF1aXJlX18oNjYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2OCksIF9fd2VicGFja19yZXF1aXJlX18oNjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3MSksIF9fd2VicGFja19yZXF1aXJlX18oNzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3NCksIF9fd2VicGFja19yZXF1aXJlX18oNzUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMSksIF9fd2VicGFja19yZXF1aXJlX18oNzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3OSksIF9fd2VicGFja19yZXF1aXJlX18oODApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4MiksIF9fd2VicGFja19yZXF1aXJlX18oODMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4NSksIF9fd2VicGFja19yZXF1aXJlX18oODYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4OCksIF9fd2VicGFja19yZXF1aXJlX18oODkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5MSksIF9fd2VicGFja19yZXF1aXJlX18oOTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5NCksIF9fd2VicGFja19yZXF1aXJlX18oOTUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5NyksIF9fd2VicGFja19yZXF1aXJlX18oNCksIF9fd2VicGFja19yZXF1aXJlX18oOTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSksIF9fd2VicGFja19yZXF1aXJlX18oMTAyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCksIF9fd2VicGFja19yZXF1aXJlX18oMTA1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyksIF9fd2VicGFja19yZXF1aXJlX18oMTA4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCksIF9fd2VicGFja19yZXF1aXJlX18oMCksIF9fd2VicGFja19yZXF1aXJlX18oMTExKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMyksIF9fd2VicGFja19yZXF1aXJlX18oMTE0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNiksIF9fd2VicGFja19yZXF1aXJlX18oMTE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSksIF9fd2VicGFja19yZXF1aXJlX18oMTIwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMiksIF9fd2VicGFja19yZXF1aXJlX18oMTIzKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSksIF9fd2VicGFja19yZXF1aXJlX18oMTI2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOCksIF9fd2VicGFja19yZXF1aXJlX18oMTI5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMSksIF9fd2VicGFja19yZXF1aXJlX18oMTMyKV0uZm9yRWFjaChmdW5jdGlvbiAoY3Rvcikge1xuICBBU1QucHJvdG90eXBlW2N0b3Iua2luZF0gPSBjdG9yO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFTVDtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBub2RlICh3aXRoIGl0J3Mgc291cmNlIGNvbnRlbnRzIGFzIHN0cmluZylcbiAqIEBjb25zdHJ1Y3RvciBMb2NhdGlvblxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gc291cmNlXG4gKiBAcHJvcGVydHkge1Bvc2l0aW9ufSBzdGFydFxuICogQHByb3BlcnR5IHtQb3NpdGlvbn0gZW5kXG4gKi9cblxudmFyIExvY2F0aW9uID0gZnVuY3Rpb24gTG9jYXRpb24oc291cmNlLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuZW5kID0gZW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhdGlvbjtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG4vKipcbiAqIEVhY2ggUG9zaXRpb24gb2JqZWN0IGNvbnNpc3RzIG9mIGEgbGluZSBudW1iZXIgKDEtaW5kZXhlZCkgYW5kIGEgY29sdW1uIG51bWJlciAoMC1pbmRleGVkKTpcbiAqIEBjb25zdHJ1Y3RvciBQb3NpdGlvblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGxpbmVcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2x1bW5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvZmZzZXRcbiAqL1xuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2x1bW4sIG9mZnNldCkge1xuICB0aGlzLmxpbmUgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiYXJyYXlcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBhcnJheSBzdHJ1Y3R1cmVcbiAqIEBjb25zdHJ1Y3RvciBBcnJheVxuICogQGV4YW1wbGVcbiAqIC8vIFBIUCBjb2RlIDpcbiAqIFsxLCAnZm9vJyA9PiAnYmFyJywgM11cbiAqXG4gKiAvLyBBU1Qgc3RydWN0dXJlIDpcbiAqIHtcbiAqICBcImtpbmRcIjogXCJhcnJheVwiLFxuICogIFwic2hvcnRGb3JtXCI6IHRydWVcbiAqICBcIml0ZW1zXCI6IFtcbiAqICAgIHtcImtpbmRcIjogXCJudW1iZXJcIiwgXCJ2YWx1ZVwiOiBcIjFcIn0sXG4gKiAgICB7XG4gKiAgICAgIFwia2luZFwiOiBcImVudHJ5XCIsXG4gKiAgICAgIFwia2V5XCI6IHtcImtpbmRcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcImZvb1wiLCBcImlzRG91YmxlUXVvdGVcIjogZmFsc2V9LFxuICogICAgICBcInZhbHVlXCI6IHtcImtpbmRcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcImJhclwiLCBcImlzRG91YmxlUXVvdGVcIjogZmFsc2V9XG4gKiAgICB9LFxuICogICAge1wia2luZFwiOiBcIm51bWJlclwiLCBcInZhbHVlXCI6IFwiM1wifVxuICogIF1cbiAqIH1cbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtFbnRyeXxFeHByfFZhcmlhYmxlfSBpdGVtcyBMaXN0IG9mIGFycmF5IGl0ZW1zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3J0Rm9ybSBJbmRpY2F0ZSBpZiB0aGUgc2hvcnQgYXJyYXkgc3ludGF4IGlzIHVzZWQsIGV4IGBbXWAgaW5zdGVhZCBgYXJyYXkoKWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEFycmF5KHNob3J0Rm9ybSwgaXRlbXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHIuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImFycm93ZnVuY1wiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGFycm93IGZ1bmN0aW9uIChpdCdzIGxpa2UgYSBjbG9zdXJlKVxuICogQGNvbnN0cnVjdG9yIEFycm93RnVuY1xuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge1BhcmFtZXRlcltdfSBhcmd1bWVudHNcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gdHlwZVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSBib2R5XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ5cmVmXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG51bGxhYmxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3RhdGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDbG9zdXJlKGFyZ3MsIGJ5cmVmLCBib2R5LCB0eXBlLCBudWxsYWJsZSwgaXNTdGF0aWMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgdGhpcy5ieXJlZiA9IGJ5cmVmO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLm51bGxhYmxlID0gbnVsbGFibGU7XG4gIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYyB8fCBmYWxzZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiYXNzaWduXCI7XG4vKipcbiAqIEFzc2lnbnMgYSB2YWx1ZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldFxuICogQGNvbnN0cnVjdG9yIEFzc2lnblxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGxlZnRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gcmlnaHRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcGVyYXRvclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQXNzaWduKGxlZnQsIHJpZ2h0LCBvcGVyYXRvciwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImFzc2lnbnJlZlwiO1xuLyoqXG4gKiBBc3NpZ25zIGEgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXRcbiAqIEBjb25zdHJ1Y3RvciBBc3NpZ25cbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSBsZWZ0XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHJpZ2h0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gb3BlcmF0b3JcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEFzc2lnblJlZihsZWZ0LCByaWdodCwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgT3BlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEtJTkQgPSBcImJpblwiO1xuLyoqXG4gKiBCaW5hcnkgb3BlcmF0aW9uc1xuICogQGNvbnN0cnVjdG9yIEJpblxuICogQGV4dGVuZHMge09wZXJhdGlvbn1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGxlZnRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gcmlnaHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQmluKHR5cGUsIGxlZnQsIHJpZ2h0LCBkb2NzLCBsb2NhdGlvbikge1xuICBPcGVyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMubGVmdCA9IGxlZnQ7XG4gIHRoaXMucmlnaHQgPSByaWdodDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwiYm9vbGVhblwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgYm9vbGVhbiB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAqIEBjb25zdHJ1Y3RvciBCb29sZWFuXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpdGVyYWxbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEJvb2xlYW4odmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgTGl0ZXJhbC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJicmVha1wiO1xuLyoqXG4gKiBBIGJyZWFrIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIEJyZWFrXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtOdW1iZXJ8TnVsbH0gbGV2ZWxcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQnJlYWsobGV2ZWwsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJieXJlZlwiO1xuLyoqXG4gKiBQYXNzaW5nIGJ5IFJlZmVyZW5jZSAtIHNvIHRoZSBmdW5jdGlvbiBjYW4gbW9kaWZ5IHRoZSB2YXJpYWJsZVxuICogQGNvbnN0cnVjdG9yIEJ5UmVmXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7ZXhwcn0gd2hhdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQnlSZWYod2hhdCwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiY2FsbFwiO1xuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGwgc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgQ2FsbFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8VmFyaWFibGV8Pz99IHdoYXRcbiAqIEBwcm9wZXJ0eSB7QXJndW1lbnRzW119IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ2FsbCh3aGF0LCBhcmdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLndoYXQgPSB3aGF0O1xuICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiY2FzZVwiO1xuLyoqXG4gKiBBIHN3aXRjaCBjYXNlIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIENhc2VcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb258bnVsbH0gdGVzdCAtIGlmIG51bGwsIG1lYW5zIHRoYXQgdGhlIGRlZmF1bHQgY2FzZVxuICogQHByb3BlcnR5IHtCbG9ja3xudWxsfSBib2R5XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENhc2UodGVzdCwgYm9keSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgT3BlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEtJTkQgPSBcImNhc3RcIjtcbi8qKlxuICogQmluYXJ5IG9wZXJhdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBDYXN0XG4gKiBAZXh0ZW5kcyB7T3BlcmF0aW9ufVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByYXdcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gZXhwclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDYXN0KHR5cGUsIHJhdywgZXhwciwgZG9jcywgbG9jYXRpb24pIHtcbiAgT3BlcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnJhdyA9IHJhdztcbiAgdGhpcy5leHByID0gZXhwcjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJjYXRjaFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY2F0Y2ggc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgQ2F0Y2hcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJbXX0gd2hhdFxuICogQHByb3BlcnR5IHtWYXJpYWJsZX0gdmFyaWFibGVcbiAqIEBwcm9wZXJ0eSB7U3RhdGVtZW50fSBib2R5XG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5leGNlcHRpb25zLnBocFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDYXRjaChib2R5LCB3aGF0LCB2YXJpYWJsZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLndoYXQgPSB3aGF0O1xuICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBEZWNsYXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBLSU5EID0gXCJjbGFzc1wiO1xuLyoqXG4gKiBBIGNsYXNzIGRlZmluaXRpb25cbiAqIEBjb25zdHJ1Y3RvciBDbGFzc1xuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfG51bGx9IGV4dGVuZHNcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcltdfSBpbXBsZW1lbnRzXG4gKiBAcHJvcGVydHkge0RlY2xhcmF0aW9uW119IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNBbm9ueW1vdXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNBYnN0cmFjdFxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0ZpbmFsXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ2xhc3MobmFtZSwgZXh0LCBpbXBsLCBib2R5LCBmbGFncywgZG9jcywgbG9jYXRpb24pIHtcbiAgRGVjbGFyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIG5hbWUsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuaXNBbm9ueW1vdXMgPSBuYW1lID8gZmFsc2UgOiB0cnVlO1xuICB0aGlzW1wiZXh0ZW5kc1wiXSA9IGV4dDtcbiAgdGhpc1tcImltcGxlbWVudHNcIl0gPSBpbXBsO1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLnBhcnNlRmxhZ3MoZmxhZ3MpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgQ29uc3RhbnRTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIEtJTkQgPSBcImNsYXNzY29uc3RhbnRcIjtcbnZhciBJU19VTkRFRklORUQgPSBcIlwiO1xudmFyIElTX1BVQkxJQyA9IFwicHVibGljXCI7XG52YXIgSVNfUFJPVEVDVEVEID0gXCJwcm90ZWN0ZWRcIjtcbnZhciBJU19QUklWQVRFID0gXCJwcml2YXRlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcy9pbnRlcmZhY2UvdHJhaXQgY29uc3RhbnRcbiAqIEBjb25zdHJ1Y3RvciBDbGFzc0NvbnN0YW50XG4gKiBAZXh0ZW5kcyB7Q29uc3RhbnRTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmlzaWJpbGl0eVxuICovXG5cbnZhciBDbGFzc0NvbnN0YW50ID0gQ29uc3RhbnRTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENsYXNzQ29uc3RhbnQoa2luZCwgY29uc3RhbnRzLCBmbGFncywgZG9jcywgbG9jYXRpb24pIHtcbiAgQ29uc3RhbnRTdGF0ZW1lbnQuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgY29uc3RhbnRzLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnBhcnNlRmxhZ3MoZmxhZ3MpO1xufSk7XG4vKipcbiAqIEdlbmVyaWMgZmxhZ3MgcGFyc2VyXG4gKiBAcGFyYW0ge0ludGVnZXJbXX0gZmxhZ3NcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblxuQ2xhc3NDb25zdGFudC5wcm90b3R5cGUucGFyc2VGbGFncyA9IGZ1bmN0aW9uIChmbGFncykge1xuICBpZiAoZmxhZ3NbMF0gPT09IC0xKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfVU5ERUZJTkVEO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSBudWxsKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMCkge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BVQkxJQztcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMSkge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BST1RFQ1RFRDtcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMikge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BSSVZBVEU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NDb25zdGFudDtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImNsb25lXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbG9uZSBjYWxsXG4gKiBAY29uc3RydWN0b3IgQ2xvbmVcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB3aGF0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDbG9uZSh3aGF0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLndoYXQgPSB3aGF0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJjbG9zdXJlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbG9zdXJlXG4gKiBAY29uc3RydWN0b3IgQ2xvc3VyZVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge1BhcmFtZXRlcltdfSBhcmd1bWVudHNcbiAqIEBwcm9wZXJ0eSB7VmFyaWFibGVbXX0gdXNlc1xuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSB0eXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ5cmVmXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG51bGxhYmxlXG4gKiBAcHJvcGVydHkge0Jsb2NrfG51bGx9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdGF0aWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENsb3N1cmUoYXJncywgYnlyZWYsIHVzZXMsIHR5cGUsIG51bGxhYmxlLCBpc1N0YXRpYywgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy51c2VzID0gdXNlcztcbiAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICB0aGlzLmJ5cmVmID0gYnlyZWY7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljIHx8IGZhbHNlO1xuICB0aGlzLmJvZHkgPSBudWxsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgQ29tbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBLSU5EID0gXCJjb21tZW50YmxvY2tcIjtcbi8qKlxuICogQSBjb21tZW50IGJsb2NrIChtdWx0aWxpbmUpXG4gKiBAY29uc3RydWN0b3IgQ29tbWVudEJsb2NrXG4gKiBAZXh0ZW5kcyB7Q29tbWVudH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbW1lbnRCbG9jayh2YWx1ZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgQ29tbWVudC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIGRvY3MsIGxvY2F0aW9uXSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBDb21tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIEtJTkQgPSBcImNvbW1lbnRsaW5lXCI7XG4vKipcbiAqIEEgc2luZ2xlIGxpbmUgY29tbWVudFxuICogQGNvbnN0cnVjdG9yIENvbW1lbnRMaW5lXG4gKiBAZXh0ZW5kcyB7Q29tbWVudH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbW1lbnRMaW5lKHZhbHVlLCBkb2NzLCBsb2NhdGlvbikge1xuICBDb21tZW50LmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwiY29uc3RhbnRcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNvbnN0YW50XG4gKiBAY29uc3RydWN0b3IgQ29uc3RhbnRcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Tm9kZXxzdHJpbmd8bnVtYmVyfGJvb2xlYW58bnVsbH0gdmFsdWVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbnN0YW50KG5hbWUsIHZhbHVlLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiY29udGludWVcIjtcbi8qKlxuICogQSBjb250aW51ZSBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBDb250aW51ZVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfE51bGx9IGxldmVsXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbnRpbnVlKGxldmVsLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubGV2ZWwgPSBsZXZlbDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEJsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIEtJTkQgPSBcImRlY2xhcmVcIjtcbi8qKlxuICogVGhlIGRlY2xhcmUgY29uc3RydWN0IGlzIHVzZWQgdG8gc2V0IGV4ZWN1dGlvbiBkaXJlY3RpdmVzIGZvciBhIGJsb2NrIG9mIGNvZGVcbiAqIEBjb25zdHJ1Y3RvciBEZWNsYXJlXG4gKiBAZXh0ZW5kcyB7QmxvY2t9XG4gKiBAcHJvcGVydHkge0FycmF5W119IGRpcmVjdGl2ZXNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtb2RlXG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9jb250cm9sLXN0cnVjdHVyZXMuZGVjbGFyZS5waHBcbiAqL1xuXG52YXIgRGVjbGFyZSA9IEJsb2NrW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBEZWNsYXJlKGRpcmVjdGl2ZXMsIGJvZHksIG1vZGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEJsb2NrLmFwcGx5KHRoaXMsIFtLSU5ELCBib2R5LCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xufSk7XG4vKipcbiAqIFRoZSBub2RlIGlzIGRlY2xhcmVkIGFzIGEgc2hvcnQgdGFnIHN5bnRheCA6XG4gKiBgYGBwaHBcbiAqIDw/cGhwXG4gKiBkZWNsYXJlKHRpY2tzPTEpOlxuICogLy8gc29tZSBzdGF0ZW1lbnRzXG4gKiBlbmRkZWNsYXJlO1xuICogYGBgXG4gKiBAY29uc3RhbnQge1N0cmluZ30gTU9ERV9TSE9SVFxuICovXG5cbkRlY2xhcmUuTU9ERV9TSE9SVCA9IFwic2hvcnRcIjtcbi8qKlxuICogVGhlIG5vZGUgaXMgZGVjbGFyZWQgYnJhY2tldCBlbmNsb3NlZCBjb2RlIDpcbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGRlY2xhcmUodGlja3M9MSkge1xuICogLy8gc29tZSBzdGF0ZW1lbnRzXG4gKiB9XG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBNT0RFX0JMT0NLXG4gKi9cblxuRGVjbGFyZS5NT0RFX0JMT0NLID0gXCJibG9ja1wiO1xuLyoqXG4gKiBUaGUgbm9kZSBpcyBkZWNsYXJlZCBhcyBhIHNpbXBsZSBzdGF0ZW1lbnQuIEluIG9yZGVyIHRvIG1ha2UgdGhpbmdzIHNpbXBsZXJcbiAqIGNoaWxkcmVuIG9mIHRoZSBub2RlIGFyZSBhdXRvbWF0aWNhbGx5IGNvbGxlY3RlZCB1bnRpbCB0aGUgbmV4dFxuICogZGVjbGFyZSBzdGF0ZW1lbnQuXG4gKiBgYGBwaHBcbiAqIDw/cGhwXG4gKiBkZWNsYXJlKHRpY2tzPTEpO1xuICogLy8gc29tZSBzdGF0ZW1lbnRzXG4gKiBkZWNsYXJlKHRpY2tzPTIpO1xuICogLy8gc29tZSBzdGF0ZW1lbnRzXG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBNT0RFX05PTkVcbiAqL1xuXG5EZWNsYXJlLk1PREVfTk9ORSA9IFwibm9uZVwiO1xubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJlO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwiZGVjbGFyZWRpcmVjdGl2ZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY29uc3RhbnRcbiAqIEBjb25zdHJ1Y3RvciBEZWNsYXJlRGlyZWN0aXZlXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gbmFtZVxuICogQHByb3BlcnR5IHtOb2RlfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRGVjbGFyZURpcmVjdGl2ZShrZXksIHZhbHVlLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImRvXCI7XG4vKipcbiAqIERlZmluZXMgYSBkby93aGlsZSBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBEb1xuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdGVzdFxuICogQHByb3BlcnR5IHtTdGF0ZW1lbnR9IGJvZHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRG8odGVzdCwgYm9keSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImVjaG9cIjtcbi8qKlxuICogRGVmaW5lcyBzeXN0ZW0gYmFzZWQgY2FsbFxuICogQGNvbnN0cnVjdG9yIEVjaG9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFY2hvKGV4cHJlc3Npb25zLCBzaG9ydEZvcm0sIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG4gIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiZW1wdHlcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBlbXB0eSBjaGVjayBjYWxsXG4gKiBAY29uc3RydWN0b3IgRW1wdHlcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRW1wdHkoZXhwcmVzc2lvbiwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwiZW5jYXBzZWRcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBlbmNhcHNlZCBzdHJpbmcgKGNvbnRhaW5zIGV4cHJlc3Npb25zKVxuICogQGNvbnN0cnVjdG9yIEVuY2Fwc2VkXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIC0gRGVmaW5lcyB0aGUgdHlwZSBvZiBlbmNhcHNlZCBzdHJpbmcgKHNoZWxsLCBoZXJlZG9jLCBzdHJpbmcpXG4gKiBAcHJvcGVydHkge1N0cmluZ3xOdWxsfSBsYWJlbCAtIFRoZSBoZXJlZG9jIGxhYmVsLCBkZWZpbmVkIG9ubHkgd2hlbiB0aGUgdHlwZSBpcyBoZXJlZG9jXG4gKi9cblxudmFyIEVuY2Fwc2VkID0gTGl0ZXJhbFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRW5jYXBzZWQodmFsdWUsIHJhdywgdHlwZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgTGl0ZXJhbC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn0pO1xuLyoqXG4gKiBUaGUgbm9kZSBpcyBhIGRvdWJsZSBxdW90ZSBzdHJpbmcgOlxuICogYGBgcGhwXG4gKiA8P3BocFxuICogZWNobyBcImhlbGxvICR3b3JsZFwiO1xuICogYGBgXG4gKiBAY29uc3RhbnQge1N0cmluZ30gVFlQRV9TVFJJTkcgLSBgc3RyaW5nYFxuICovXG5cbkVuY2Fwc2VkLlRZUEVfU1RSSU5HID0gXCJzdHJpbmdcIjtcbi8qKlxuICogVGhlIG5vZGUgaXMgYSBzaGVsbCBleGVjdXRlIHN0cmluZyA6XG4gKiBgYGBwaHBcbiAqIDw/cGhwXG4gKiBlY2hvIGBscyAtbGFydGggJHBhdGhgO1xuICogYGBgXG4gKiBAY29uc3RhbnQge1N0cmluZ30gVFlQRV9TSEVMTCAtIGBzaGVsbGBcbiAqL1xuXG5FbmNhcHNlZC5UWVBFX1NIRUxMID0gXCJzaGVsbFwiO1xuLyoqXG4gKiBUaGUgbm9kZSBpcyBhIHNoZWxsIGV4ZWN1dGUgc3RyaW5nIDpcbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGVjaG8gPDw8U1RSXG4gKiAgSGVsbG8gJHdvcmxkXG4gKiBTVFJcbiAqIDtcbiAqIGBgYFxuICogQGNvbnN0YW50IHtTdHJpbmd9IFRZUEVfSEVSRURPQyAtIGBoZXJlZG9jYFxuICovXG5cbkVuY2Fwc2VkLlRZUEVfSEVSRURPQyA9IFwiaGVyZWRvY1wiO1xuLyoqXG4gKiBUaGUgbm9kZSBjb250YWlucyBhIGxpc3Qgb2YgY29uc3RyZWYgLyB2YXJpYWJsZXMgLyBleHByIDpcbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGVjaG8gJGZvby0+YmFyXyRiYXo7XG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBUWVBFX09GRlNFVCAtIGBvZmZzZXRgXG4gKi9cblxuRW5jYXBzZWQuVFlQRV9PRkZTRVQgPSBcIm9mZnNldFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFbmNhcHNlZDtcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImVuY2Fwc2VkcGFydFwiO1xuLyoqXG4gKiBQYXJ0IG9mIGBFbmNhcHNlZGAgbm9kZVxuICogQGNvbnN0cnVjdG9yIEVuY2Fwc2VkUGFydFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGV4cHJlc3Npb25cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW50YXhcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY3VybHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEVuY2Fwc2VkUGFydChleHByZXNzaW9uLCBzeW50YXgsIGN1cmx5LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB0aGlzLnN5bnRheCA9IHN5bnRheDtcbiAgdGhpcy5jdXJseSA9IGN1cmx5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJlbnRyeVwiO1xuLyoqXG4gKiBBbiBhcnJheSBlbnRyeSAtIHNlZSBbQXJyYXldKCNhcnJheSlcbiAqIEBjb25zdHJ1Y3RvciBFbnRyeVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge05vZGV8bnVsbH0ga2V5IFRoZSBlbnRyeSBrZXkvb2Zmc2V0XG4gKiBAcHJvcGVydHkge05vZGV9IHZhbHVlIFRoZSBlbnRyeSB2YWx1ZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBieVJlZiBCeSByZWZlcmVuY2VcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdW5wYWNrIEFyZ3VtZW50IHVucGFja2luZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRW50cnkoa2V5LCB2YWx1ZSwgYnlSZWYsIHVucGFjaywgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5ieVJlZiA9IGJ5UmVmO1xuICB0aGlzLnVucGFjayA9IHVucGFjaztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwiZXJyb3JcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBlcnJvciBub2RlICh1c2VkIG9ubHkgb24gc2lsZW50TW9kZSlcbiAqIEBjb25zdHJ1Y3RvciBFcnJvclxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHN0cmluZ30gdG9rZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGFycmF5fSBleHBlY3RlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRXJyb3IobWVzc2FnZSwgdG9rZW4sIGxpbmUsIGV4cGVjdGVkLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiZXZhbFwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGV2YWwgc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgRXZhbFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge05vZGV9IHNvdXJjZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRXZhbChzb3VyY2UsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJleGl0XCI7XG4vKipcbiAqIERlZmluZXMgYW4gZXhpdCAvIGRpZSBjYWxsXG4gKiBAY29uc3RydWN0b3IgRXhpdFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge05vZGV8bnVsbH0gZXhwcmVzc2lvblxuICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VEaWVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEV4aXQoZXhwcmVzc2lvbiwgdXNlRGllLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB0aGlzLnVzZURpZSA9IHVzZURpZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJleHByZXNzaW9uc3RhdGVtZW50XCI7XG4vKipcbiAqIERlZmluZXMgYW4gZXhwcmVzc2lvbiBiYXNlZCBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBFeHByZXNzaW9uU3RhdGVtZW50XG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSBleHByZXNzaW9uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwciwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImZvclwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgZm9yIGl0ZXJhdG9yXG4gKiBAY29uc3RydWN0b3IgRm9yXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9uW119IGluaXRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbltdfSB0ZXN0XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb25bXX0gaW5jcmVtZW50XG4gKiBAcHJvcGVydHkge1N0YXRlbWVudH0gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG9ydEZvcm1cbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2NvbnRyb2wtc3RydWN0dXJlcy5mb3IucGhwXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEZvcihpbml0LCB0ZXN0LCBpbmNyZW1lbnQsIGJvZHksIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmluaXQgPSBpbml0O1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudDtcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG4gIHRoaXMuYm9keSA9IGJvZHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZm9yZWFjaFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgZm9yZWFjaCBpdGVyYXRvclxuICogQGNvbnN0cnVjdG9yIEZvcmVhY2hcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHNvdXJjZVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufG51bGx9IGtleVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB2YWx1ZVxuICogQHByb3BlcnR5IHtTdGF0ZW1lbnR9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9jb250cm9sLXN0cnVjdHVyZXMuZm9yZWFjaC5waHBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRm9yZWFjaChzb3VyY2UsIGtleSwgdmFsdWUsIGJvZHksIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG4gIHRoaXMuYm9keSA9IGJvZHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZ2xvYmFsXCI7XG4vKipcbiAqIEltcG9ydHMgYSB2YXJpYWJsZSBmcm9tIHRoZSBnbG9iYWwgc2NvcGVcbiAqIEBjb25zdHJ1Y3RvciBHbG9iYWxcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge1ZhcmlhYmxlW119IGl0ZW1zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEdsb2JhbChpdGVtcywgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLml0ZW1zID0gaXRlbXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZ290b1wiO1xuLyoqXG4gKiBEZWZpbmVzIGdvdG8gc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgR290b1xuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYWJlbFxuICogQHNlZSB7TGFiZWx9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEdvdG8obGFiZWwsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImhhbHRcIjtcbi8qKlxuICogSGFsdHMgdGhlIGNvbXBpbGVyIGV4ZWN1dGlvblxuICogQGNvbnN0cnVjdG9yIEhhbHRcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gYWZ0ZXIgLSBTdHJpbmcgYWZ0ZXIgdGhlIGhhbHQgc3RhdGVtZW50XG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9mdW5jdGlvbi5oYWx0LWNvbXBpbGVyLnBocFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBIYWx0KGFmdGVyLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuYWZ0ZXIgPSBhZnRlcjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwiaWRlbnRpZmllclwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGlkZW50aWZpZXIgbm9kZVxuICogQGNvbnN0cnVjdG9yIElkZW50aWZpZXJcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqL1xuXG52YXIgSWRlbnRpZmllciA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIElkZW50aWZpZXIobmFtZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBJZGVudGlmaWVyO1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJpZlwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgaWYgc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgSWZcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHRlc3RcbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7QmxvY2t8SWZ8bnVsbH0gYWx0ZXJuYXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3J0Rm9ybVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBJZih0ZXN0LCBib2R5LCBhbHRlcm5hdGUsIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG59KTtcblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImluY2x1ZGVcIjtcbi8qKlxuICogRGVmaW5lcyBzeXN0ZW0gaW5jbHVkZSBjYWxsXG4gKiBAY29uc3RydWN0b3IgSW5jbHVkZVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge05vZGV9IHRhcmdldFxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJlcXVpcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEluY2x1ZGUob25jZSwgcmVxdWlyZSwgdGFyZ2V0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm9uY2UgPSBvbmNlO1xuICB0aGlzLnJlcXVpcmUgPSByZXF1aXJlO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwiaW5saW5lXCI7XG4vKipcbiAqIERlZmluZXMgaW5saW5lIGh0bWwgb3V0cHV0ICh0cmVhdGVkIGFzIGVjaG8gb3V0cHV0KVxuICogQGNvbnN0cnVjdG9yIElubGluZVxuICogQGV4dGVuZHMge0xpdGVyYWx9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBJbmxpbmUodmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgTGl0ZXJhbC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDg0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIERlY2xhcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIEtJTkQgPSBcImludGVyZmFjZVwiO1xuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZGVmaW5pdGlvblxuICogQGNvbnN0cnVjdG9yIEludGVyZmFjZVxuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyW119IGV4dGVuZHNcbiAqIEBwcm9wZXJ0eSB7RGVjbGFyYXRpb25bXX0gYm9keVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEludGVyZmFjZShuYW1lLCBleHQsIGJvZHksIGRvY3MsIGxvY2F0aW9uKSB7XG4gIERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBuYW1lLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzW1wiZXh0ZW5kc1wiXSA9IGV4dDtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiaXNzZXRcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBpc3NldCBjYWxsXG4gKiBAY29uc3RydWN0b3IgSXNzZXRcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gSXNzZXQodmFyaWFibGVzLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJsYWJlbFwiO1xuLyoqXG4gKiBBIGxhYmVsIHN0YXRlbWVudCAocmVmZXJlbmNlZCBieSBnb3RvKVxuICogQGNvbnN0cnVjdG9yIExhYmVsXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTGFiZWwobmFtZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJsaXN0XCI7XG4vKipcbiAqIERlZmluZXMgbGlzdCBhc3NpZ25tZW50XG4gKiBAY29uc3RydWN0b3IgTGlzdFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3J0Rm9ybVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTGlzdChpdGVtcywgc2hvcnRGb3JtLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gIHRoaXMuc2hvcnRGb3JtID0gc2hvcnRGb3JtO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBLSU5EID0gXCJtYWdpY1wiO1xuLyoqXG4gKiBEZWZpbmVzIG1hZ2ljIGNvbnN0YW50XG4gKiBAY29uc3RydWN0b3IgTWFnaWNcbiAqIEBleHRlbmRzIHtMaXRlcmFsfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGl0ZXJhbFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTWFnaWModmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgTGl0ZXJhbC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIF9GdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgS0lORCA9IFwibWV0aG9kXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcy9pbnRlcmZhY2UvdHJhaXQgbWV0aG9kXG4gKiBAY29uc3RydWN0b3IgTWV0aG9kXG4gKiBAZXh0ZW5kcyB7X0Z1bmN0aW9ufVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0Fic3RyYWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRmluYWxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdGF0aWNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aXNpYmlsaXR5XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBfRnVuY3Rpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE1ldGhvZCgpIHtcbiAgX0Z1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy5raW5kID0gS0lORDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFJlZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBLSU5EID0gXCJuYW1lXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcyByZWZlcmVuY2Ugbm9kZVxuICogQGNvbnN0cnVjdG9yIE5hbWVcbiAqIEBleHRlbmRzIHtSZWZlcmVuY2V9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlc29sdXRpb25cbiAqL1xuXG52YXIgTmFtZSA9IFJlZmVyZW5jZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTmFtZShuYW1lLCBpc1JlbGF0aXZlLCBkb2NzLCBsb2NhdGlvbikge1xuICBSZWZlcmVuY2UuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG5cbiAgaWYgKGlzUmVsYXRpdmUpIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBOYW1lLlJFTEFUSVZFX05BTUU7XG4gIH0gZWxzZSBpZiAobmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBOYW1lLlVOUVVBTElGSUVEX05BTUU7XG4gIH0gZWxzZSBpZiAoIW5hbWVbMF0pIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBOYW1lLkZVTExfUVVBTElGSUVEX05BTUU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZXNvbHV0aW9uID0gTmFtZS5RVUFMSUZJRURfTkFNRTtcbiAgfVxuXG4gIHRoaXMubmFtZSA9IG5hbWUuam9pbihcIlxcXFxcIik7XG59KTtcbi8qKlxuICogVGhpcyBpcyBhbiBpZGVudGlmaWVyIHdpdGhvdXQgYSBuYW1lc3BhY2Ugc2VwYXJhdG9yLCBzdWNoIGFzIEZvb1xuICogQGNvbnN0YW50IHtTdHJpbmd9IFVOUVVBTElGSUVEX05BTUVcbiAqL1xuXG5OYW1lLlVOUVVBTElGSUVEX05BTUUgPSBcInVxblwiO1xuLyoqXG4gKiBUaGlzIGlzIGFuIGlkZW50aWZpZXIgd2l0aCBhIG5hbWVzcGFjZSBzZXBhcmF0b3IsIHN1Y2ggYXMgRm9vXFxCYXJcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBRVUFMSUZJRURfTkFNRVxuICovXG5cbk5hbWUuUVVBTElGSUVEX05BTUUgPSBcInFuXCI7XG4vKipcbiAqIFRoaXMgaXMgYW4gaWRlbnRpZmllciB3aXRoIGEgbmFtZXNwYWNlIHNlcGFyYXRvciB0aGF0IGJlZ2lucyB3aXRoXG4gKiBhIG5hbWVzcGFjZSBzZXBhcmF0b3IsIHN1Y2ggYXMgXFxGb29cXEJhci4gVGhlIG5hbWVzcGFjZSBcXEZvbyBpcyBhbHNvXG4gKiBhIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICogQGNvbnN0YW50IHtTdHJpbmd9IEZVTExfUVVBTElGSUVEX05BTUVcbiAqL1xuXG5OYW1lLkZVTExfUVVBTElGSUVEX05BTUUgPSBcImZxblwiO1xuLyoqXG4gKiBUaGlzIGlzIGFuIGlkZW50aWZpZXIgc3RhcnRpbmcgd2l0aCBuYW1lc3BhY2UsIHN1Y2ggYXMgbmFtZXNwYWNlXFxGb29cXEJhci5cbiAqIEBjb25zdGFudCB7U3RyaW5nfSBSRUxBVElWRV9OQU1FXG4gKi9cblxuTmFtZS5SRUxBVElWRV9OQU1FID0gXCJyblwiO1xubW9kdWxlLmV4cG9ydHMgPSBOYW1lO1xuXG4vKioqLyB9KSxcbi8qIDkxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEJsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIEtJTkQgPSBcIm5hbWVzcGFjZVwiO1xuLyoqXG4gKiBUaGUgbWFpbiBwcm9ncmFtIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBOYW1lc3BhY2VcbiAqIEBleHRlbmRzIHtCbG9ja31cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHdpdGhCcmFja2V0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2tbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE5hbWVzcGFjZShuYW1lLCBjaGlsZHJlbiwgd2l0aEJyYWNrZXRzLCBkb2NzLCBsb2NhdGlvbikge1xuICBCbG9jay5hcHBseSh0aGlzLCBbS0lORCwgY2hpbGRyZW4sIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMud2l0aEJyYWNrZXRzID0gd2l0aEJyYWNrZXRzIHx8IGZhbHNlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJuZXdcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzXG4gKiBAY29uc3RydWN0b3IgTmV3XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxWYXJpYWJsZXxDbGFzc30gd2hhdFxuICogQHByb3BlcnR5IHtBcmd1bWVudHNbXX0gYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBOZXcod2hhdCwgYXJncywgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbiAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJub29wXCI7XG4vKipcbiAqIElnbm9yZSB0aGlzIG5vZGUsIGl0IGltcGxpZXMgYSBubyBvcGVyYXRpb24gYmxvY2ssIGZvciBleGFtcGxlIDpcbiAqIFskZm9vLCAkYmFyLCAvKiBoZXJlIGEgbm9vcCBub2RlICogL11cbiAqIEBjb25zdHJ1Y3RvciBOb29wXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE5vb3AoZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwibm93ZG9jXCI7XG4vKipcbiAqIERlZmluZXMgYSBub3dkb2Mgc3RyaW5nXG4gKiBAY29uc3RydWN0b3IgTm93RG9jXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYWJlbFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJhd1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGl0ZXJhbFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTm93ZG9jKHZhbHVlLCByYXcsIGxhYmVsLCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmxhYmVsID0gbGFiZWw7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcIm51bGxrZXl3b3JkXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG51bGwga2V5d29yZFxuICogQGNvbnN0cnVjdG9yIE51bGxLZXl3b3JkXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE51bGxLZXl3b3JkKHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5yYXcgPSByYXc7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMaXRlcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEtJTkQgPSBcIm51bWJlclwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgbnVtZXJpYyB2YWx1ZVxuICogQGNvbnN0cnVjdG9yIE51bWJlclxuICogQGV4dGVuZHMge0xpdGVyYWx9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBOdW1iZXIodmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgTGl0ZXJhbC5hcHBseSh0aGlzLCBbS0lORCwgdmFsdWUsIHJhdywgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExvb2t1cCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBLSU5EID0gXCJvZmZzZXRsb29rdXBcIjtcbi8qKlxuICogTG9va3VwIG9uIGFuIG9mZnNldCBpbiBhbiBhcnJheVxuICogQGNvbnN0cnVjdG9yIE9mZnNldExvb2t1cFxuICogQGV4dGVuZHMge0xvb2t1cH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvb2t1cFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gT2Zmc2V0TG9va3VwKHdoYXQsIG9mZnNldCwgZG9jcywgbG9jYXRpb24pIHtcbiAgTG9va3VwLmFwcGx5KHRoaXMsIFtLSU5ELCB3aGF0LCBvZmZzZXQsIGRvY3MsIGxvY2F0aW9uXSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBEZWNsYXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBLSU5EID0gXCJwYXJhbWV0ZXJcIjtcbi8qKlxuICogRGVmaW5lcyBhIGZ1bmN0aW9uIHBhcmFtZXRlclxuICogQGNvbnN0cnVjdG9yIFBhcmFtZXRlclxuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfG51bGx9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7Tm9kZXxudWxsfSB2YWx1ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBieXJlZlxuICogQHByb3BlcnR5IHtib29sZWFufSB2YXJpYWRpY1xuICogQHByb3BlcnR5IHtib29sZWFufSBudWxsYWJsZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFBhcmFtZXRlcihuYW1lLCB0eXBlLCB2YWx1ZSwgaXNSZWYsIGlzVmFyaWFkaWMsIG51bGxhYmxlLCBkb2NzLCBsb2NhdGlvbikge1xuICBEZWNsYXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgbmFtZSwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmJ5cmVmID0gaXNSZWY7XG4gIHRoaXMudmFyaWFkaWMgPSBpc1ZhcmlhZGljO1xuICB0aGlzLm51bGxhYmxlID0gbnVsbGFibGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBSZWZlcmVuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgS0lORCA9IFwicGFyZW50cmVmZXJlbmNlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcyByZWZlcmVuY2Ugbm9kZVxuICogQGNvbnN0cnVjdG9yIFBhcmVudFJlZmVyZW5jZVxuICogQGV4dGVuZHMge1JlZmVyZW5jZX1cbiAqL1xuXG52YXIgUGFyZW50UmVmZXJlbmNlID0gUmVmZXJlbmNlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQYXJlbnRSZWZlcmVuY2UocmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBSZWZlcmVuY2UuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMucmF3ID0gcmF3O1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFBhcmVudFJlZmVyZW5jZTtcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgT3BlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEtJTkQgPSBcInBvc3RcIjtcbi8qKlxuICogRGVmaW5lcyBhIHBvc3Qgb3BlcmF0aW9uIGAkaSsrYCBvciBgJGktLWBcbiAqIEBjb25zdHJ1Y3RvciBQb3N0XG4gKiBAZXh0ZW5kcyB7T3BlcmF0aW9ufVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7VmFyaWFibGV9IHdoYXRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUG9zdCh0eXBlLCB3aGF0LCBkb2NzLCBsb2NhdGlvbikge1xuICBPcGVyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgT3BlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEtJTkQgPSBcInByZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgcHJlIG9wZXJhdGlvbiBgKyskaWAgb3IgYC0tJGlgXG4gKiBAY29uc3RydWN0b3IgUHJlXG4gKiBAZXh0ZW5kcyB7T3BlcmF0aW9ufVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7VmFyaWFibGV9IHdoYXRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUHJlKHR5cGUsIHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE9wZXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcInByaW50XCI7XG4vKipcbiAqIE91dHB1dHNcbiAqIEBjb25zdHJ1Y3RvciBQcmludFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQcmludChleHByZXNzaW9uLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEJsb2NrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIEtJTkQgPSBcInByb2dyYW1cIjtcbi8qKlxuICogVGhlIG1haW4gcHJvZ3JhbSBub2RlXG4gKiBAY29uc3RydWN0b3IgUHJvZ3JhbVxuICogQGV4dGVuZHMge0Jsb2NrfVxuICogQHByb3BlcnR5IHtFcnJvcltdfSBlcnJvcnNcbiAqIEBwcm9wZXJ0eSB7RG9jW10/fSBjb21tZW50c1xuICogQHByb3BlcnR5IHtTdHJpbmdbXT99IHRva2Vuc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmxvY2tbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFByb2dyYW0oY2hpbGRyZW4sIGVycm9ycywgY29tbWVudHMsIHRva2VucywgZG9jcywgbG9jYXRpb24pIHtcbiAgQmxvY2suYXBwbHkodGhpcywgW0tJTkQsIGNoaWxkcmVuLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmVycm9ycyA9IGVycm9ycztcblxuICBpZiAoY29tbWVudHMpIHtcbiAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHM7XG4gIH1cblxuICBpZiAodG9rZW5zKSB7XG4gICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwicHJvcGVydHlcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHByb3BlcnR5XG4gKiBAY29uc3RydWN0b3IgUHJvcGVydHlcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtOb2RlfG51bGx9IHZhbHVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG51bGxhYmxlXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8QXJyYXk8SWRlbnRpZmllcj58bnVsbH0gdHlwZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgbnVsbGFibGUsIHR5cGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLm51bGxhYmxlID0gbnVsbGFibGU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTG9va3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEtJTkQgPSBcInByb3BlcnR5bG9va3VwXCI7XG4vKipcbiAqIExvb2t1cCB0byBhbiBvYmplY3QgcHJvcGVydHlcbiAqIEBjb25zdHJ1Y3RvciBQcm9wZXJ0eUxvb2t1cFxuICogQGV4dGVuZHMge0xvb2t1cH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvb2t1cFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUHJvcGVydHlMb29rdXAod2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbikge1xuICBMb29rdXAuYXBwbHkodGhpcywgW0tJTkQsIHdoYXQsIG9mZnNldCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwicHJvcGVydHlzdGF0ZW1lbnRcIjtcbnZhciBJU19VTkRFRklORUQgPSBcIlwiO1xudmFyIElTX1BVQkxJQyA9IFwicHVibGljXCI7XG52YXIgSVNfUFJPVEVDVEVEID0gXCJwcm90ZWN0ZWRcIjtcbnZhciBJU19QUklWQVRFID0gXCJwcml2YXRlXCI7XG4vKipcbiAqIERlY2xhcmVzIGEgcHJvcGVydGllcyBpbnRvIHRoZSBjdXJyZW50IHNjb3BlXG4gKiBAY29uc3RydWN0b3IgUHJvcGVydHlTdGF0ZW1lbnRcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge1Byb3BlcnR5W119IHByb3BlcnRpZXNcbiAqL1xuXG52YXIgUHJvcGVydHlTdGF0ZW1lbnQgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFByb3BlcnR5U3RhdGVtZW50KGtpbmQsIHByb3BlcnRpZXMsIGZsYWdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gIHRoaXMucGFyc2VGbGFncyhmbGFncyk7XG59KTtcbi8qKlxuICogR2VuZXJpYyBmbGFncyBwYXJzZXJcbiAqIEBwYXJhbSB7SW50ZWdlcltdfSBmbGFnc1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuXG5Qcm9wZXJ0eVN0YXRlbWVudC5wcm90b3R5cGUucGFyc2VGbGFncyA9IGZ1bmN0aW9uIChmbGFncykge1xuICBpZiAoZmxhZ3NbMF0gPT09IC0xKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfVU5ERUZJTkVEO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSBudWxsKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMCkge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BVQkxJQztcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMSkge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BST1RFQ1RFRDtcbiAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMikge1xuICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BSSVZBVEU7XG4gIH1cblxuICB0aGlzLmlzU3RhdGljID0gZmxhZ3NbMV0gPT09IDE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5U3RhdGVtZW50O1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcInJldGlmXCI7XG4vKipcbiAqIERlZmluZXMgYSBzaG9ydCBpZiBzdGF0ZW1lbnQgdGhhdCByZXR1cm5zIGEgdmFsdWVcbiAqIEBjb25zdHJ1Y3RvciBSZXRJZlxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHRlc3RcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdHJ1ZUV4cHJcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gZmFsc2VFeHByXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBSZXRJZih0ZXN0LCB0cnVlRXhwciwgZmFsc2VFeHByLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLnRydWVFeHByID0gdHJ1ZUV4cHI7XG4gIHRoaXMuZmFsc2VFeHByID0gZmFsc2VFeHByO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJyZXR1cm5cIjtcbi8qKlxuICogQSBjb250aW51ZSBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBSZXR1cm5cbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb258bnVsbH0gZXhwclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBSZXR1cm4oZXhwciwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHIgPSBleHByO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFJlZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBLSU5EID0gXCJzZWxmcmVmZXJlbmNlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcyByZWZlcmVuY2Ugbm9kZVxuICogQGNvbnN0cnVjdG9yIFNlbGZSZWZlcmVuY2VcbiAqIEBleHRlbmRzIHtSZWZlcmVuY2V9XG4gKi9cblxudmFyIFNlbGZSZWZlcmVuY2UgPSBSZWZlcmVuY2VbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFNlbGZSZWZlcmVuY2UocmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBSZWZlcmVuY2UuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMucmF3ID0gcmF3O1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNlbGZSZWZlcmVuY2U7XG5cbi8qKiovIH0pLFxuLyogMTEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwic2lsZW50XCI7XG4vKipcbiAqIEF2b2lkcyB0byBzaG93L2xvZyB3YXJuaW5ncyAmIG5vdGljZXMgZnJvbSB0aGUgaW5uZXIgZXhwcmVzc2lvblxuICogQGNvbnN0cnVjdG9yIFNpbGVudFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGV4cHJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFNpbGVudChleHByLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHIgPSBleHByO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJzdGF0aWNcIjtcbi8qKlxuICogRGVjbGFyZXMgYSBzdGF0aWMgdmFyaWFibGUgaW50byB0aGUgY3VycmVudCBzY29wZVxuICogQGNvbnN0cnVjdG9yIFN0YXRpY1xuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7U3RhdGljVmFyaWFibGVbXX0gdmFyaWFibGVzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN0YXRpYyh2YXJpYWJsZXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJzdGF0aWN2YXJpYWJsZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY29uc3RhbnRcbiAqIEBjb25zdHJ1Y3RvciBTdGF0aWNWYXJpYWJsZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge1ZhcmlhYmxlfSB2YXJpYWJsZVxuICogQHByb3BlcnR5IHtOb2RlfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSBkZWZhdWx0VmFsdWVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN0YXRpY1ZhcmlhYmxlKHZhcmlhYmxlLCBkZWZhdWx0VmFsdWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbiAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTG9va3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEtJTkQgPSBcInN0YXRpY2xvb2t1cFwiO1xuLyoqXG4gKiBMb29rdXAgdG8gYSBzdGF0aWMgcHJvcGVydHlcbiAqIEBjb25zdHJ1Y3RvciBTdGF0aWNMb29rdXBcbiAqIEBleHRlbmRzIHtMb29rdXB9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMb29rdXBbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN0YXRpY0xvb2t1cCh3aGF0LCBvZmZzZXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIExvb2t1cC5hcHBseSh0aGlzLCBbS0lORCwgd2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFJlZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBLSU5EID0gXCJzdGF0aWNyZWZlcmVuY2VcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHJlZmVyZW5jZSBub2RlXG4gKiBAY29uc3RydWN0b3IgU3RhdGljUmVmZXJlbmNlXG4gKiBAZXh0ZW5kcyB7UmVmZXJlbmNlfVxuICovXG5cbnZhciBTdGF0aWNSZWZlcmVuY2UgPSBSZWZlcmVuY2VbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN0YXRpY1JlZmVyZW5jZShyYXcsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFJlZmVyZW5jZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5yYXcgPSByYXc7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gU3RhdGljUmVmZXJlbmNlO1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMaXRlcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEtJTkQgPSBcInN0cmluZ1wiO1xuLyoqXG4gKiBEZWZpbmVzIGEgc3RyaW5nIChzaW1wbGUgb3UgZG91YmxlIHF1b3RlZCkgLSBjaGFycyBhcmUgYWxyZWFkeSBlc2NhcGVkXG4gKiBAY29uc3RydWN0b3IgU3RyaW5nXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5pY29kZVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0RvdWJsZVF1b3RlXG4gKiBAc2VlIHtFbmNhcHNlZH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpdGVyYWxbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN0cmluZyhpc0RvdWJsZVF1b3RlLCB2YWx1ZSwgdW5pY29kZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnVuaWNvZGUgPSB1bmljb2RlO1xuICB0aGlzLmlzRG91YmxlUXVvdGUgPSBpc0RvdWJsZVF1b3RlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJzd2l0Y2hcIjtcbi8qKlxuICogRGVmaW5lcyBhIHN3aXRjaCBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBTd2l0Y2hcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHRlc3RcbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFN3aXRjaCh0ZXN0LCBib2R5LCBzaG9ydEZvcm0sIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInRocm93XCI7XG4vKipcbiAqIERlZmluZXMgYSB0aHJvdyBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBUaHJvd1xuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gd2hhdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBUaHJvdyh3aGF0LCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRGVjbGFyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgS0lORCA9IFwidHJhaXRcIjtcbi8qKlxuICogQSB0cmFpdCBkZWZpbml0aW9uXG4gKiBAY29uc3RydWN0b3IgVHJhaXRcbiAqIEBleHRlbmRzIHtEZWNsYXJhdGlvbn1cbiAqIEBwcm9wZXJ0eSB7RGVjbGFyYXRpb25bXX0gYm9keVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRyYWl0KG5hbWUsIGJvZHksIGRvY3MsIGxvY2F0aW9uKSB7XG4gIERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBuYW1lLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmJvZHkgPSBib2R5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwidHJhaXRhbGlhc1wiO1xudmFyIElTX1VOREVGSU5FRCA9IFwiXCI7XG52YXIgSVNfUFVCTElDID0gXCJwdWJsaWNcIjtcbnZhciBJU19QUk9URUNURUQgPSBcInByb3RlY3RlZFwiO1xudmFyIElTX1BSSVZBVEUgPSBcInByaXZhdGVcIjtcbi8qKlxuICogRGVmaW5lcyBhIHRyYWl0IGFsaWFzXG4gKiBAY29uc3RydWN0b3IgVHJhaXRBbGlhc1xuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8bnVsbH0gdHJhaXRcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gbWV0aG9kXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8bnVsbH0gYXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IHZpc2liaWxpdHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRyYWl0QWxpYXModHJhaXQsIG1ldGhvZCwgYXMsIGZsYWdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRyYWl0ID0gdHJhaXQ7XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLmFzID0gYXM7XG4gIHRoaXMudmlzaWJpbGl0eSA9IElTX1VOREVGSU5FRDtcblxuICBpZiAoZmxhZ3MpIHtcbiAgICBpZiAoZmxhZ3NbMF0gPT09IDApIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BVQkxJQztcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAxKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19QUk9URUNURUQ7XG4gICAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMikge1xuICAgICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJJVkFURTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcInRyYWl0cHJlY2VkZW5jZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdHJhaXQgYWxpYXNcbiAqIEBjb25zdHJ1Y3RvciBUcmFpdFByZWNlZGVuY2VcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfG51bGx9IHRyYWl0XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ9IG1ldGhvZFxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyW119IGluc3RlYWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRyYWl0UHJlY2VkZW5jZSh0cmFpdCwgbWV0aG9kLCBpbnN0ZWFkLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRyYWl0ID0gdHJhaXQ7XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLmluc3RlYWQgPSBpbnN0ZWFkO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwidHJhaXR1c2VcIjtcbi8qKlxuICogRGVmaW5lcyBhIHRyYWl0IHVzYWdlXG4gKiBAY29uc3RydWN0b3IgVHJhaXRVc2VcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyW119IHRyYWl0c1xuICogQHByb3BlcnR5IHtOb2RlW118bnVsbH0gYWRhcHRhdGlvbnNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRyYWl0VXNlKHRyYWl0cywgYWRhcHRhdGlvbnMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHJhaXRzID0gdHJhaXRzO1xuICB0aGlzLmFkYXB0YXRpb25zID0gYWRhcHRhdGlvbnM7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInRyeVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdHJ5IHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFRyeVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7QmxvY2t9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Q2F0Y2hbXX0gY2F0Y2hlc1xuICogQHByb3BlcnR5IHtCbG9ja30gYWxsd2F5c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBUcnkoYm9keSwgY2F0Y2hlcywgYWx3YXlzLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuY2F0Y2hlcyA9IGNhdGNoZXM7XG4gIHRoaXMuYWx3YXlzID0gYWx3YXlzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFJlZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBLSU5EID0gXCJ0eXBlcmVmZXJlbmNlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjbGFzcyByZWZlcmVuY2Ugbm9kZVxuICogQGNvbnN0cnVjdG9yIFR5cGVSZWZlcmVuY2VcbiAqIEBleHRlbmRzIHtSZWZlcmVuY2V9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICovXG5cbnZhciBUeXBlUmVmZXJlbmNlID0gUmVmZXJlbmNlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBUeXBlUmVmZXJlbmNlKG5hbWUsIHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgUmVmZXJlbmNlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnJhdyA9IHJhdztcbn0pO1xuVHlwZVJlZmVyZW5jZS50eXBlcyA9IFtcImludFwiLCBcImZsb2F0XCIsIFwic3RyaW5nXCIsIFwiYm9vbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiY2FsbGFibGVcIiwgXCJpdGVyYWJsZVwiLCBcInZvaWRcIl07XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVSZWZlcmVuY2U7XG5cbi8qKiovIH0pLFxuLyogMTI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE9wZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBLSU5EID0gXCJ1bmFyeVwiO1xuLyoqXG4gKiBVbmFyeSBvcGVyYXRpb25zXG4gKiBAY29uc3RydWN0b3IgVW5hcnlcbiAqIEBleHRlbmRzIHtPcGVyYXRpb259XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB3aGF0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFVuYXJ5KHR5cGUsIHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE9wZXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwidW5zZXRcIjtcbi8qKlxuICogRGVsZXRlcyByZWZlcmVuY2VzIHRvIGEgbGlzdCBvZiB2YXJpYWJsZXNcbiAqIEBjb25zdHJ1Y3RvciBVbnNldFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVW5zZXQodmFyaWFibGVzLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJ1c2Vncm91cFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdXNlIHN0YXRlbWVudCAod2l0aCBhIGxpc3Qgb2YgdXNlIGl0ZW1zKVxuICogQGNvbnN0cnVjdG9yIFVzZUdyb3VwXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gbmFtZVxuICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gdHlwZSAtIFBvc3NpYmxlIHZhbHVlIDogZnVuY3Rpb24sIGNvbnN0XG4gKiBAcHJvcGVydHkge1VzZUl0ZW1bXX0gaXRlbVxuICogQHNlZSB7TmFtZXNwYWNlfVxuICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vbGFuZ3VhZ2UubmFtZXNwYWNlcy5pbXBvcnRpbmcucGhwXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFVzZUdyb3VwKG5hbWUsIHR5cGUsIGl0ZW1zLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwidXNlaXRlbVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdXNlIHN0YXRlbWVudCAoZnJvbSBuYW1lc3BhY2UpXG4gKiBAY29uc3RydWN0b3IgVXNlSXRlbVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSB0eXBlIC0gUG9zc2libGUgdmFsdWUgOiBmdW5jdGlvbiwgY29uc3RcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxudWxsfSBhbGlhc1xuICogQHNlZSB7TmFtZXNwYWNlfVxuICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vbGFuZ3VhZ2UubmFtZXNwYWNlcy5pbXBvcnRpbmcucGhwXG4gKi9cblxudmFyIFVzZUl0ZW0gPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFVzZUl0ZW0obmFtZSwgYWxpYXMsIHR5cGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufSk7XG4vKipcbiAqIEltcG9ydGluZyBhIGNvbnN0YW50XG4gKiBAY29uc3RhbnQge1N0cmluZ30gVFlQRV9DT05TVFxuICovXG5cblVzZUl0ZW0uVFlQRV9DT05TVCA9IFwiY29uc3RcIjtcbi8qKlxuICogSW1wb3J0aW5nIGEgZnVuY3Rpb25cbiAqIEBjb25zdGFudCB7U3RyaW5nfSBUWVBFX0ZVTkNcbiAqL1xuXG5Vc2VJdGVtLlRZUEVfRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCI7XG5tb2R1bGUuZXhwb3J0cyA9IFVzZUl0ZW07XG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwidmFyaWFibGVcIjtcbi8qKlxuICogQW55IGV4cHJlc3Npb24gbm9kZS4gU2luY2UgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIGFuIGFzc2lnbm1lbnQgbWF5XG4gKiBiZSBhbnkgZXhwcmVzc2lvbiBpbiBnZW5lcmFsLCBhbiBleHByZXNzaW9uIGNhbiBhbHNvIGJlIGEgcGF0dGVybi5cbiAqIEBjb25zdHJ1Y3RvciBWYXJpYWJsZVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAZXhhbXBsZVxuICogLy8gUEhQIGNvZGUgOlxuICogJGZvb1xuICogLy8gQVNUIG91dHB1dFxuICoge1xuICogIFwia2luZFwiOiBcInZhcmlhYmxlXCIsXG4gKiAgXCJuYW1lXCI6IFwiZm9vXCIsXG4gKiAgXCJjdXJseVwiOiBmYWxzZVxuICogfVxuICogQHByb3BlcnR5IHtTdHJpbmd8Tm9kZX0gbmFtZSBUaGUgdmFyaWFibGUgbmFtZSAoY2FuIGJlIGEgY29tcGxleCBleHByZXNzaW9uIHdoZW4gdGhlIG5hbWUgaXMgcmVzb2x2ZWQgZHluYW1pY2FsbHkpXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGN1cmx5IEluZGljYXRlIGlmIHRoZSBuYW1lIGlzIGRlZmluZWQgYmV0d2VlbiBjdXJsaWVzLCBleCBgJHtmb299YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVmFyaWFibGUobmFtZSwgY3VybHksIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuY3VybHkgPSBjdXJseSB8fCBmYWxzZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcInZhcmlhZGljXCI7XG4vKipcbiAqIEludHJvZHVjZSBhIGxpc3Qgb2YgaXRlbXMgaW50byB0aGUgYXJndW1lbnRzIG9mIHRoZSBjYWxsXG4gKiBAY29uc3RydWN0b3IgdmFyaWFkaWNcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtBcnJheXxFeHByZXNzaW9ufSB3aGF0XG4gKiBAc2VlIGh0dHBzOi8vd2lraS5waHAubmV0L3JmYy9hcmd1bWVudF91bnBhY2tpbmdcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIHZhcmlhZGljKHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcIndoaWxlXCI7XG4vKipcbiAqIERlZmluZXMgYSB3aGlsZSBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBXaGlsZVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdGVzdFxuICogQHByb3BlcnR5IHtTdGF0ZW1lbnR9IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFdoaWxlKHRlc3QsIGJvZHksIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcInlpZWxkXCI7XG4vKipcbiAqIERlZmluZXMgYSB5aWVsZCBnZW5lcmF0b3Igc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgWWllbGRcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufE51bGx9IHZhbHVlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb258TnVsbH0ga2V5XG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5nZW5lcmF0b3JzLnN5bnRheC5waHBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFlpZWxkKHZhbHVlLCBrZXksIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5rZXkgPSBrZXk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJ5aWVsZGZyb21cIjtcbi8qKlxuICogRGVmaW5lcyBhIHlpZWxkIGZyb20gZ2VuZXJhdG9yIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFlpZWxkRnJvbVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHZhbHVlXG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5nZW5lcmF0b3JzLnN5bnRheC5waHBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFlpZWxkRnJvbSh2YWx1ZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufSk7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/php-parser/dist/php-parser.js\n");

/***/ })

}]);