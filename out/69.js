(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[69],{

/***/ "./node_modules/@angular/compiler/fesm5/compiler.js":
/*!**********************************************************!*\
  !*** ./node_modules/@angular/compiler/fesm5/compiler.js ***!
  \**********************************************************/
/*! exports provided: AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, AotCompiler, AotSummaryResolver, ArrayType, AssertNotNull, AstMemoryEfficientTransformer, AstPath, AstTransformer, AttrAst, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BoundDirectivePropertyAst, BoundElementProperty, BoundElementPropertyAst, BoundEventAst, BoundTextAst, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CONTENT_ATTR, CUSTOM_ELEMENTS_SCHEMA, CastExpr, Chain, ClassField, ClassMethod, ClassStmt, CommaExpr, Comment, CommentStmt, CompileDirectiveMetadata, CompileMetadataResolver, CompileNgModuleMetadata, CompilePipeMetadata, CompileReflector, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileSummaryKind, CompileTemplateMetadata, CompiledStylesheet, CompilerConfig, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, DirectiveAst, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, EOF, ERROR_COMPONENT_TYPE, Element, ElementAst, ElementSchemaRegistry, EmbeddedTemplateAst, EmitterVisitorContext, EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, Extractor, FunctionCall, FunctionExpr, GeneratedFile, HOST_ATTR, HtmlParser, HtmlTagDefinition, I18NHtmlParser, Identifiers, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation, InterpolationConfig, InvokeFunctionExpr, InvokeMethodExpr, IvyParser, JSDocCommentStmt, JitCompiler, JitEvaluator, JitSummaryResolver, KeyedRead, KeyedWrite, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, MapType, MessageBundle, MethodCall, NAMED_ENTITIES, NGSP_UNICODE, NONE_TYPE, NO_ERRORS_SCHEMA, NgContentAst, NgModuleCompiler, NgModuleResolver, NodeWithI18n, NonNullAssert, NotExpr, NullTemplateVisitor, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, ParserError, PipeResolver, PrefixNot, PropertyRead, PropertyWrite, ProviderAst, ProviderAstType, ProviderMeta, Quote, R3BoundTarget, R3FactoryTarget, R3Identifiers, R3ResolvedDependencyType, R3TargetBinder, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveTemplateAstVisitor, RecursiveVisitor, ReferenceAst, ResolvedStaticSymbol, ResourceLoader, ReturnStatement, STRING_TYPE, SafeMethodCall, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, Serializer, SplitInterpolation, Statement, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StmtModifier, StyleCompiler, StylesCompileDependency, SummaryResolver, TagContentType, TemplateBindingParseResult, TemplateParseError, TemplateParseResult, TemplateParser, Text, TextAst, ThrowStmt, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable, Token, TokenType, TransitiveCompileNgModuleMetadata, TreeError, TryCatchStmt, Type, TypeScriptEmitter, TypeofExpr, UrlResolver, VERSION, VariableAst, VariableBinding, Version, ViewCompiler, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ParseAST, analyzeAndValidateNgModules, analyzeFile, analyzeFileForInjectables, analyzeNgModules, collectExternalReferences, compileComponentFromMetadata, compileDirectiveFromMetadata, compileFactoryFunction, compileInjectable, compileInjector, compileNgModule, compilePipeFromMetadata, componentFactoryName, computeMsgId, core, createAotCompiler, createAotUrlResolver, createElementCssSelector, createLoweredSymbol, createOfflineCompileUrlResolver, createUrlResolverWithoutPackagePrefix, debugOutputAstAsTypeScript, findNode, flatten, formattedError, getHtmlTagDefinition, getNsPrefix, getParseErrors, getUrlScheme, hostViewClassName, identifierModuleUrl, identifierName, isEmptyExpression, isFormattedError, isIdentifier, isLoweredSymbol, isNgContainer, isNgContent, isNgTemplate, isQuote, isSyntaxError, literalMap, makeBindingParser, mergeAnalyzedFiles, mergeNsAndName, ngModuleJitUrl, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, removeSummaryDuplicates, rendererTypeName, sanitizeIdentifier, sharedStylesheetJitUrl, splitClasses, splitNsName, syntaxError, templateJitUrl, templateSourceUrl, templateVisitAll, toTypeScript, tokenName, tokenReference, typeSourceSpan, unescapeIdentifier, unwrapResolvedMetadata, verifyHostBindings, viewClassName, visitAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AST\", function() { return AST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASTWithName\", function() { return ASTWithName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASTWithSource\", function() { return ASTWithSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbsoluteSourceSpan\", function() { return AbsoluteSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AotCompiler\", function() { return AotCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AotSummaryResolver\", function() { return AotSummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayType\", function() { return ArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssertNotNull\", function() { return AssertNotNull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstMemoryEfficientTransformer\", function() { return AstMemoryEfficientTransformer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstPath\", function() { return AstPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstTransformer\", function() { return AstTransformer$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AttrAst\", function() { return AttrAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Attribute\", function() { return Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Binary\", function() { return Binary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperator\", function() { return BinaryOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperatorExpr\", function() { return BinaryOperatorExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BindingPipe\", function() { return BindingPipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundDirectivePropertyAst\", function() { return BoundDirectivePropertyAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundElementProperty\", function() { return BoundElementProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundElementPropertyAst\", function() { return BoundElementPropertyAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundEventAst\", function() { return BoundEventAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundTextAst\", function() { return BoundTextAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinMethod\", function() { return BuiltinMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinType\", function() { return BuiltinType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinTypeName\", function() { return BuiltinTypeName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinVar\", function() { return BuiltinVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTENT_ATTR\", function() { return CONTENT_ATTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CUSTOM_ELEMENTS_SCHEMA\", function() { return CUSTOM_ELEMENTS_SCHEMA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CastExpr\", function() { return CastExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chain\", function() { return Chain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassField\", function() { return ClassField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassMethod\", function() { return ClassMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassStmt\", function() { return ClassStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommaExpr\", function() { return CommaExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Comment\", function() { return Comment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommentStmt\", function() { return CommentStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileDirectiveMetadata\", function() { return CompileDirectiveMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileMetadataResolver\", function() { return CompileMetadataResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileNgModuleMetadata\", function() { return CompileNgModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompilePipeMetadata\", function() { return CompilePipeMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileReflector\", function() { return CompileReflector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileShallowModuleMetadata\", function() { return CompileShallowModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileStylesheetMetadata\", function() { return CompileStylesheetMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileSummaryKind\", function() { return CompileSummaryKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompileTemplateMetadata\", function() { return CompileTemplateMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompiledStylesheet\", function() { return CompiledStylesheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompilerConfig\", function() { return CompilerConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Conditional\", function() { return Conditional; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConditionalExpr\", function() { return ConditionalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstantPool\", function() { return ConstantPool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CssSelector\", function() { return CssSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_INTERPOLATION_CONFIG\", function() { return DEFAULT_INTERPOLATION_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DYNAMIC_TYPE\", function() { return DYNAMIC_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareFunctionStmt\", function() { return DeclareFunctionStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareVarStmt\", function() { return DeclareVarStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveAst\", function() { return DirectiveAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveNormalizer\", function() { return DirectiveNormalizer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DirectiveResolver\", function() { return DirectiveResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomElementSchemaRegistry\", function() { return DomElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOF\", function() { return EOF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ERROR_COMPONENT_TYPE\", function() { return ERROR_COMPONENT_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementAst\", function() { return ElementAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementSchemaRegistry\", function() { return ElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmbeddedTemplateAst\", function() { return EmbeddedTemplateAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmitterVisitorContext\", function() { return EmitterVisitorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyExpr\", function() { return EmptyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expansion\", function() { return Expansion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpansionCase\", function() { return ExpansionCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expression\", function() { return Expression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionBinding\", function() { return ExpressionBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionStatement\", function() { return ExpressionStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionType\", function() { return ExpressionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalExpr\", function() { return ExternalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalReference\", function() { return ExternalReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Extractor\", function() { return Extractor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionCall\", function() { return FunctionCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionExpr\", function() { return FunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneratedFile\", function() { return GeneratedFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HOST_ATTR\", function() { return HOST_ATTR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlParser\", function() { return HtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlTagDefinition\", function() { return HtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I18NHtmlParser\", function() { return I18NHtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Identifiers\", function() { return Identifiers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IfStmt\", function() { return IfStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImplicitReceiver\", function() { return ImplicitReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstantiateExpr\", function() { return InstantiateExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolation\", function() { return Interpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolationConfig\", function() { return InterpolationConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvokeFunctionExpr\", function() { return InvokeFunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvokeMethodExpr\", function() { return InvokeMethodExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IvyParser\", function() { return IvyParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSDocCommentStmt\", function() { return JSDocCommentStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitCompiler\", function() { return JitCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitEvaluator\", function() { return JitEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitSummaryResolver\", function() { return JitSummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedRead\", function() { return KeyedRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedWrite\", function() { return KeyedWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArray\", function() { return LiteralArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArrayExpr\", function() { return LiteralArrayExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralExpr\", function() { return LiteralExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMap\", function() { return LiteralMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMapExpr\", function() { return LiteralMapExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralPrimitive\", function() { return LiteralPrimitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapType\", function() { return MapType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageBundle\", function() { return MessageBundle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MethodCall\", function() { return MethodCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAMED_ENTITIES\", function() { return NAMED_ENTITIES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NGSP_UNICODE\", function() { return NGSP_UNICODE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NONE_TYPE\", function() { return NONE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NO_ERRORS_SCHEMA\", function() { return NO_ERRORS_SCHEMA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgContentAst\", function() { return NgContentAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgModuleCompiler\", function() { return NgModuleCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NgModuleResolver\", function() { return NgModuleResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeWithI18n\", function() { return NodeWithI18n; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NonNullAssert\", function() { return NonNullAssert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotExpr\", function() { return NotExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NullTemplateVisitor\", function() { return NullTemplateVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseError\", function() { return ParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseErrorLevel\", function() { return ParseErrorLevel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseLocation\", function() { return ParseLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceFile\", function() { return ParseSourceFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceSpan\", function() { return ParseSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSpan\", function() { return ParseSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseTreeResult\", function() { return ParseTreeResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedEvent\", function() { return ParsedEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedProperty\", function() { return ParsedProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedPropertyType\", function() { return ParsedPropertyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedVariable\", function() { return ParsedVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserError\", function() { return ParserError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PipeResolver\", function() { return PipeResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixNot\", function() { return PrefixNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyRead\", function() { return PropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyWrite\", function() { return PropertyWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderAst\", function() { return ProviderAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderAstType\", function() { return ProviderAstType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProviderMeta\", function() { return ProviderMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quote\", function() { return Quote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3BoundTarget\", function() { return R3BoundTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3FactoryTarget\", function() { return R3FactoryTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3Identifiers\", function() { return Identifiers$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3ResolvedDependencyType\", function() { return R3ResolvedDependencyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3TargetBinder\", function() { return R3TargetBinder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadKeyExpr\", function() { return ReadKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadPropExpr\", function() { return ReadPropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadVarExpr\", function() { return ReadVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveAstVisitor\", function() { return RecursiveAstVisitor$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveTemplateAstVisitor\", function() { return RecursiveTemplateAstVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveVisitor\", function() { return RecursiveVisitor$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReferenceAst\", function() { return ReferenceAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResolvedStaticSymbol\", function() { return ResolvedStaticSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceLoader\", function() { return ResourceLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReturnStatement\", function() { return ReturnStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRING_TYPE\", function() { return STRING_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafeMethodCall\", function() { return SafeMethodCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafePropertyRead\", function() { return SafePropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorContext\", function() { return SelectorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorListContext\", function() { return SelectorListContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorMatcher\", function() { return SelectorMatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return Serializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplitInterpolation\", function() { return SplitInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Statement\", function() { return Statement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticReflector\", function() { return StaticReflector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbol\", function() { return StaticSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbolCache\", function() { return StaticSymbolCache; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticSymbolResolver\", function() { return StaticSymbolResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StmtModifier\", function() { return StmtModifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyleCompiler\", function() { return StyleCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StylesCompileDependency\", function() { return StylesCompileDependency; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SummaryResolver\", function() { return SummaryResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TagContentType\", function() { return TagContentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateBindingParseResult\", function() { return TemplateBindingParseResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParseError\", function() { return TemplateParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParseResult\", function() { return TemplateParseResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateParser\", function() { return TemplateParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return Text$3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextAst\", function() { return TextAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThrowStmt\", function() { return ThrowStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundAttribute\", function() { return BoundAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundEvent\", function() { return BoundEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundText\", function() { return BoundText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstContent\", function() { return Content; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstElement\", function() { return Element; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstRecursiveVisitor\", function() { return RecursiveVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstReference\", function() { return Reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTemplate\", function() { return Template; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstText\", function() { return Text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTextAttribute\", function() { return TextAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstVariable\", function() { return Variable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenType\", function() { return TokenType$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransitiveCompileNgModuleMetadata\", function() { return TransitiveCompileNgModuleMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeError\", function() { return TreeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TryCatchStmt\", function() { return TryCatchStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeScriptEmitter\", function() { return TypeScriptEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeofExpr\", function() { return TypeofExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UrlResolver\", function() { return UrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableAst\", function() { return VariableAst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableBinding\", function() { return VariableBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Version\", function() { return Version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewCompiler\", function() { return ViewCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrappedNodeExpr\", function() { return WrappedNodeExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteKeyExpr\", function() { return WriteKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WritePropExpr\", function() { return WritePropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteVarExpr\", function() { return WriteVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff\", function() { return Xliff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff2\", function() { return Xliff2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xmb\", function() { return Xmb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XmlParser\", function() { return XmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xtb\", function() { return Xtb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ParseAST\", function() { return _ParseAST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeAndValidateNgModules\", function() { return analyzeAndValidateNgModules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeFile\", function() { return analyzeFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeFileForInjectables\", function() { return analyzeFileForInjectables; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"analyzeNgModules\", function() { return analyzeNgModules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"collectExternalReferences\", function() { return collectExternalReferences; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileComponentFromMetadata\", function() { return compileComponentFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDirectiveFromMetadata\", function() { return compileDirectiveFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileFactoryFunction\", function() { return compileFactoryFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjectable\", function() { return compileInjectable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjector\", function() { return compileInjector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileNgModule\", function() { return compileNgModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compilePipeFromMetadata\", function() { return compilePipeFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"componentFactoryName\", function() { return componentFactoryName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeMsgId\", function() { return computeMsgId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAotCompiler\", function() { return createAotCompiler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAotUrlResolver\", function() { return createAotUrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElementCssSelector\", function() { return createElementCssSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLoweredSymbol\", function() { return createLoweredSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createOfflineCompileUrlResolver\", function() { return createOfflineCompileUrlResolver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createUrlResolverWithoutPackagePrefix\", function() { return createUrlResolverWithoutPackagePrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debugOutputAstAsTypeScript\", function() { return debugOutputAstAsTypeScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findNode\", function() { return findNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flatten\", function() { return flatten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formattedError\", function() { return formattedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHtmlTagDefinition\", function() { return getHtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNsPrefix\", function() { return getNsPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParseErrors\", function() { return getParseErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUrlScheme\", function() { return getUrlScheme; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hostViewClassName\", function() { return hostViewClassName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifierModuleUrl\", function() { return identifierModuleUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifierName\", function() { return identifierName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmptyExpression\", function() { return isEmptyExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFormattedError\", function() { return isFormattedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifier\", function() { return isIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isLoweredSymbol\", function() { return isLoweredSymbol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContainer\", function() { return isNgContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContent\", function() { return isNgContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgTemplate\", function() { return isNgTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isQuote\", function() { return isQuote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSyntaxError\", function() { return isSyntaxError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"literalMap\", function() { return literalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeBindingParser\", function() { return makeBindingParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeAnalyzedFiles\", function() { return mergeAnalyzedFiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeNsAndName\", function() { return mergeNsAndName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ngModuleJitUrl\", function() { return ngModuleJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseHostBindings\", function() { return parseHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTemplate\", function() { return parseTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preserveWhitespacesDefault\", function() { return preserveWhitespacesDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"publishFacade\", function() { return publishFacade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r3JitTypeSourceSpan\", function() { return r3JitTypeSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeSummaryDuplicates\", function() { return removeSummaryDuplicates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rendererTypeName\", function() { return rendererTypeName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitizeIdentifier\", function() { return sanitizeIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sharedStylesheetJitUrl\", function() { return sharedStylesheetJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitClasses\", function() { return splitClasses; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitNsName\", function() { return splitNsName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"syntaxError\", function() { return syntaxError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateJitUrl\", function() { return templateJitUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateSourceUrl\", function() { return templateSourceUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"templateVisitAll\", function() { return templateVisitAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toTypeScript\", function() { return toTypeScript; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenName\", function() { return tokenName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokenReference\", function() { return tokenReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"typeSourceSpan\", function() { return typeSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unescapeIdentifier\", function() { return unescapeIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrapResolvedMetadata\", function() { return unwrapResolvedMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"verifyHostBindings\", function() { return verifyHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"viewClassName\", function() { return viewClassName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visitAll\", function() { return visitAll$1; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * @license Angular v9.1.12\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagContentType;\n(function (TagContentType) {\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n// `<ng-container>` tags work the same regardless the namespace\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n// `<ng-content>` tags work the same regardless the namespace\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n// `<ng-template>` tags work the same regardless the namespace\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nvar NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = /** @class */ (function () {\n    function HtmlTagDefinition(_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\nvar _DEFAULT_TAG_DEFINITION;\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n    if (!TAG_DEFINITIONS) {\n        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n        TAG_DEFINITIONS = {\n            'base': new HtmlTagDefinition({ isVoid: true }),\n            'meta': new HtmlTagDefinition({ isVoid: true }),\n            'area': new HtmlTagDefinition({ isVoid: true }),\n            'embed': new HtmlTagDefinition({ isVoid: true }),\n            'link': new HtmlTagDefinition({ isVoid: true }),\n            'img': new HtmlTagDefinition({ isVoid: true }),\n            'input': new HtmlTagDefinition({ isVoid: true }),\n            'param': new HtmlTagDefinition({ isVoid: true }),\n            'hr': new HtmlTagDefinition({ isVoid: true }),\n            'br': new HtmlTagDefinition({ isVoid: true }),\n            'source': new HtmlTagDefinition({ isVoid: true }),\n            'track': new HtmlTagDefinition({ isVoid: true }),\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\n            'p': new HtmlTagDefinition({\n                closedByChildren: [\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\n                    'p', 'pre', 'section', 'table', 'ul'\n                ],\n                closedByParent: true\n            }),\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'col': new HtmlTagDefinition({ isVoid: true }),\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n            'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n        };\n    }\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = /** @class */ (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        /**\n         * The selectors are encoded in pairs where:\n         * - even locations are attribute names\n         * - odd locations are attribute values.\n         *\n         * Example:\n         * Selector: `[key1=value1][key2]` would parse to:\n         * ```\n         * ['key1', 'value1', 'key2', '']\n         * ```\n         */\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    CssSelector.parse = function (selector) {\n        var results = [];\n        var _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var cssSelector = new CssSelector();\n        var match;\n        var current = cssSelector;\n        var inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1 /* NOT */]) {\n                if (inNot) {\n                    throw new Error('Nesting :not in a selector is not allowed');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            var tag = match[2 /* TAG */];\n            if (tag) {\n                var prefix = match[3 /* PREFIX */];\n                if (prefix === '#') {\n                    // #hash\n                    current.addAttribute('id', tag.substr(1));\n                }\n                else if (prefix === '.') {\n                    // Class\n                    current.addClassName(tag.substr(1));\n                }\n                else {\n                    // Element\n                    current.setElement(tag);\n                }\n            }\n            var attribute = match[4 /* ATTRIBUTE */];\n            if (attribute) {\n                current.addAttribute(attribute, match[6 /* ATTRIBUTE_VALUE */]);\n            }\n            if (match[7 /* NOT_END */]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8 /* SEPARATOR */]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    CssSelector.prototype.hasElementSelector = function () {\n        return !!this.element;\n    };\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /** Gets a template string for an element that matches the selector. */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var tagName = this.element || 'div';\n        var classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var attrs = '';\n        for (var i = 0; i < this.attrs.length; i += 2) {\n            var attrName = this.attrs[i];\n            var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    CssSelector.prototype.getAttrs = function () {\n        var result = [];\n        if (this.classNames.length > 0) {\n            result.push('class', this.classNames.join(' '));\n        }\n        return result.concat(this.attrs);\n    };\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    CssSelector.prototype.addClassName = function (name) {\n        this.classNames.push(name.toLowerCase());\n    };\n    CssSelector.prototype.toString = function () {\n        var res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var i = 0; i < this.attrs.length; i += 2) {\n                var name_1 = this.attrs[i];\n                var value = this.attrs[i + 1];\n                res += \"[\" + name_1 + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = /** @class */ (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var matcher = this;\n        var element = cssSelector.element;\n        var classNames = cssSelector.classNames;\n        var attrs = cssSelector.attrs;\n        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var i = 0; i < classNames.length; i++) {\n                var isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var i = 0; i < attrs.length; i += 2) {\n                var isTerminal = i === attrs.length - 2;\n                var name_2 = attrs[i];\n                var value = attrs[i + 1];\n                if (isTerminal) {\n                    var terminalMap = matcher._attrValueMap;\n                    var terminalValuesMap = terminalMap.get(name_2);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name_2, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var partialMap = matcher._attrValuePartialMap;\n                    var partialValuesMap = partialMap.get(name_2);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name_2, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var result = false;\n        var element = cssSelector.element;\n        var classNames = cssSelector.classNames;\n        var attrs = cssSelector.attrs;\n        for (var i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var i = 0; i < classNames.length; i++) {\n                var className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var i = 0; i < attrs.length; i += 2) {\n                var name_3 = attrs[i];\n                var value = attrs[i + 1];\n                var terminalValuesMap = this._attrValueMap.get(name_3);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var partialValuesMap = this._attrValuePartialMap.get(name_3);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /** @internal */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var selectables = map.get(name) || [];\n        var starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var selectable;\n        var result = false;\n        for (var i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /** @internal */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = /** @class */ (function () {\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\n// Store context to pass back selector and context when a selector is matched\nvar SelectorContext = /** @class */ (function () {\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar createInject = makeMetadataFactory('Inject', function (token) { return ({ token: token }); });\nvar createInjectionToken = makeMetadataFactory('InjectionToken', function (desc) { return ({ _desc: desc, prov: undefined }); });\nvar createAttribute = makeMetadataFactory('Attribute', function (attributeName) { return ({ attributeName: attributeName }); });\nvar createContentChildren = makeMetadataFactory('ContentChildren', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: false, isViewQuery: false, descendants: false }, data));\n});\nvar createContentChild = makeMetadataFactory('ContentChild', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: true, isViewQuery: false, descendants: true }, data));\n});\nvar createViewChildren = makeMetadataFactory('ViewChildren', function (selector, data) {\n    if (data === void 0) { data = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: false, isViewQuery: true, descendants: true }, data));\n});\nvar createViewChild = makeMetadataFactory('ViewChild', function (selector, data) {\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ selector: selector, first: true, isViewQuery: true, descendants: true }, data));\n});\nvar createDirective = makeMetadataFactory('Directive', function (dir) {\n    if (dir === void 0) { dir = {}; }\n    return dir;\n});\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nvar createComponent = makeMetadataFactory('Component', function (c) {\n    if (c === void 0) { c = {}; }\n    return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ changeDetection: ChangeDetectionStrategy.Default }, c));\n});\nvar createPipe = makeMetadataFactory('Pipe', function (p) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ pure: true }, p)); });\nvar createInput = makeMetadataFactory('Input', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });\nvar createOutput = makeMetadataFactory('Output', function (bindingPropertyName) { return ({ bindingPropertyName: bindingPropertyName }); });\nvar createHostBinding = makeMetadataFactory('HostBinding', function (hostPropertyName) { return ({ hostPropertyName: hostPropertyName }); });\nvar createHostListener = makeMetadataFactory('HostListener', function (eventName, args) { return ({ eventName: eventName, args: args }); });\nvar createNgModule = makeMetadataFactory('NgModule', function (ngModule) { return ngModule; });\nvar createInjectable = makeMetadataFactory('Injectable', function (injectable) {\n    if (injectable === void 0) { injectable = {}; }\n    return injectable;\n});\nvar CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nvar NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nvar createOptional = makeMetadataFactory('Optional');\nvar createSelf = makeMetadataFactory('Self');\nvar createSkipSelf = makeMetadataFactory('SkipSelf');\nvar createHost = makeMetadataFactory('Host');\nvar Type = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction makeMetadataFactory(name, props) {\n    // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\n    // that works with the static_reflector.ts in the ViewEngine compiler.\n    // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\n    // new'ed.\n    function factory() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var values = props ? props.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args)) : {};\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ ngMetadataName: name }, values);\n    }\n    factory.isTypeOf = function (obj) { return obj && obj.ngMetadataName === name; };\n    factory.ngMetadataName = name;\n    return factory;\n}\nfunction parserSelectorToSimpleSelector(selector) {\n    var classes = selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([8 /* CLASS */], selector.classNames) :\n        [];\n    var elementName = selector.element && selector.element !== '*' ? selector.element : '';\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([elementName], selector.attrs, classes);\n}\nfunction parserSelectorToNegativeSelector(selector) {\n    var classes = selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([8 /* CLASS */], selector.classNames) :\n        [];\n    if (selector.element) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n            1 /* NOT */ | 4 /* ELEMENT */, selector.element\n        ], selector.attrs, classes);\n    }\n    else if (selector.attrs.length) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([1 /* NOT */ | 2 /* ATTRIBUTE */], selector.attrs, classes);\n    }\n    else {\n        return selector.classNames && selector.classNames.length ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([1 /* NOT */ | 8 /* CLASS */], selector.classNames) :\n            [];\n    }\n}\nfunction parserSelectorToR3Selector(selector) {\n    var positive = parserSelectorToSimpleSelector(selector);\n    var negative = selector.notSelectors && selector.notSelectors.length ?\n        selector.notSelectors.map(function (notSelector) { return parserSelectorToNegativeSelector(notSelector); }) :\n        [];\n    return positive.concat.apply(positive, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(negative));\n}\nfunction parseSelectorToR3Selector(selector) {\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createInject: createInject,\n    createInjectionToken: createInjectionToken,\n    createAttribute: createAttribute,\n    createContentChildren: createContentChildren,\n    createContentChild: createContentChild,\n    createViewChildren: createViewChildren,\n    createViewChild: createViewChild,\n    createDirective: createDirective,\n    get ViewEncapsulation () { return ViewEncapsulation; },\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\n    createComponent: createComponent,\n    createPipe: createPipe,\n    createInput: createInput,\n    createOutput: createOutput,\n    createHostBinding: createHostBinding,\n    createHostListener: createHostListener,\n    createNgModule: createNgModule,\n    createInjectable: createInjectable,\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    createOptional: createOptional,\n    createSelf: createSelf,\n    createSkipSelf: createSkipSelf,\n    createHost: createHost,\n    Type: Type,\n    get SecurityContext () { return SecurityContext; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n//// Types\nvar TypeModifier;\n(function (TypeModifier) {\n    TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nvar Type$1 = /** @class */ (function () {\n    function Type(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    Type.prototype.hasModifier = function (modifier) {\n        return this.modifiers.indexOf(modifier) !== -1;\n    };\n    return Type;\n}());\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nvar BuiltinType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BuiltinType, _super);\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltinType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpressionType, _super);\n    function ExpressionType(value, modifiers, typeParams) {\n        if (modifiers === void 0) { modifiers = null; }\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ArrayType, _super);\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MapType, _super);\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType || null;\n        return _this;\n    }\n    MapType.prototype.visitType = function (visitor, context) {\n        return visitor.visitMapType(this, context);\n    };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n///// Expressions\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\nfunction areAllEquivalent(base, other) {\n    var len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (var i = 0; i < len; i++) {\n        if (!base[i].isEquivalent(other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nvar Expression = /** @class */ (function () {\n    function Expression(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.bitwiseAnd = function (rhs, sourceSpan, parens) {\n        if (parens === void 0) { parens = true; }\n        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    };\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    Expression.prototype.toStmt = function () {\n        return new ExpressionStatement(this, null);\n    };\n    return Expression;\n}());\nvar BuiltinVar;\n(function (BuiltinVar) {\n    BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n    BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n    BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n    BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n})(BuiltinVar || (BuiltinVar = {}));\nvar ReadVarExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadVarExpr, _super);\n    function ReadVarExpr(name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    ReadVarExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    };\n    ReadVarExpr.prototype.isConstant = function () {\n        return false;\n    };\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    ReadVarExpr.prototype.set = function (value) {\n        if (!this.name) {\n            throw new Error(\"Built in variable \" + this.builtin + \" can not be assigned to.\");\n        }\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar TypeofExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TypeofExpr, _super);\n    function TypeofExpr(expr, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    TypeofExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitTypeofExpr(this, context);\n    };\n    TypeofExpr.prototype.isEquivalent = function (e) {\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    };\n    TypeofExpr.prototype.isConstant = function () {\n        return this.expr.isConstant();\n    };\n    return TypeofExpr;\n}(Expression));\nvar WrappedNodeExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WrappedNodeExpr, _super);\n    function WrappedNodeExpr(node, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.node = node;\n        return _this;\n    }\n    WrappedNodeExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WrappedNodeExpr && this.node === e.node;\n    };\n    WrappedNodeExpr.prototype.isConstant = function () {\n        return false;\n    };\n    WrappedNodeExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWrappedNodeExpr(this, context);\n    };\n    return WrappedNodeExpr;\n}(Expression));\nvar WriteVarExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WriteVarExpr, _super);\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    WriteVarExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    };\n    WriteVarExpr.prototype.isConstant = function () {\n        return false;\n    };\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    WriteVarExpr.prototype.toConstDecl = function () {\n        return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);\n    };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WriteKeyExpr, _super);\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    WriteKeyExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    };\n    WriteKeyExpr.prototype.isConstant = function () {\n        return false;\n    };\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(WritePropExpr, _super);\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    WritePropExpr.prototype.isEquivalent = function (e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    };\n    WritePropExpr.prototype.isConstant = function () {\n        return false;\n    };\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod;\n(function (BuiltinMethod) {\n    BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n    BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n    BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n})(BuiltinMethod || (BuiltinMethod = {}));\nvar InvokeMethodExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InvokeMethodExpr, _super);\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    InvokeMethodExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    };\n    InvokeMethodExpr.prototype.isConstant = function () {\n        return false;\n    };\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InvokeFunctionExpr, _super);\n    function InvokeFunctionExpr(fn, args, type, sourceSpan, pure) {\n        if (pure === void 0) { pure = false; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        _this.pure = pure;\n        return _this;\n    }\n    InvokeFunctionExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    };\n    InvokeFunctionExpr.prototype.isConstant = function () {\n        return false;\n    };\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(InstantiateExpr, _super);\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    InstantiateExpr.prototype.isEquivalent = function (e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    };\n    InstantiateExpr.prototype.isConstant = function () {\n        return false;\n    };\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralExpr, _super);\n    function LiteralExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    LiteralExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    };\n    LiteralExpr.prototype.isConstant = function () {\n        return true;\n    };\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar LocalizedString = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LocalizedString, _super);\n    function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n        var _this = _super.call(this, STRING_TYPE, sourceSpan) || this;\n        _this.metaBlock = metaBlock;\n        _this.messageParts = messageParts;\n        _this.placeHolderNames = placeHolderNames;\n        _this.expressions = expressions;\n        return _this;\n    }\n    LocalizedString.prototype.isEquivalent = function (e) {\n        // return e instanceof LocalizedString && this.message === e.message;\n        return false;\n    };\n    LocalizedString.prototype.isConstant = function () {\n        return false;\n    };\n    LocalizedString.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLocalizedString(this, context);\n    };\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n    LocalizedString.prototype.serializeI18nHead = function () {\n        var MEANING_SEPARATOR = '|';\n        var ID_SEPARATOR = '@@';\n        var LEGACY_ID_INDICATOR = '';\n        var metaBlock = this.metaBlock.description || '';\n        if (this.metaBlock.meaning) {\n            metaBlock = \"\" + this.metaBlock.meaning + MEANING_SEPARATOR + metaBlock;\n        }\n        if (this.metaBlock.customId) {\n            metaBlock = \"\" + metaBlock + ID_SEPARATOR + this.metaBlock.customId;\n        }\n        if (this.metaBlock.legacyIds) {\n            this.metaBlock.legacyIds.forEach(function (legacyId) {\n                metaBlock = \"\" + metaBlock + LEGACY_ID_INDICATOR + legacyId;\n            });\n        }\n        return createCookedRawString(metaBlock, this.messageParts[0]);\n    };\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * @param placeholderName The placeholder name to serialize\n     * @param messagePart The following message string after this placeholder\n     */\n    LocalizedString.prototype.serializeI18nTemplatePart = function (partIndex) {\n        var placeholderName = this.placeHolderNames[partIndex - 1];\n        var messagePart = this.messageParts[partIndex];\n        return createCookedRawString(placeholderName, messagePart);\n    };\n    return LocalizedString;\n}(Expression));\nvar escapeSlashes = function (str) { return str.replace(/\\\\/g, '\\\\\\\\'); };\nvar escapeStartingColon = function (str) { return str.replace(/^:/, '\\\\:'); };\nvar escapeColons = function (str) { return str.replace(/:/g, '\\\\:'); };\nvar escapeForMessagePart = function (str) {\n    return str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n};\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(metaBlock, messagePart) {\n    if (metaBlock === '') {\n        return {\n            cooked: messagePart,\n            raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))\n        };\n    }\n    else {\n        return {\n            cooked: \":\" + metaBlock + \":\" + messagePart,\n            raw: escapeForMessagePart(\":\" + escapeColons(escapeSlashes(metaBlock)) + \":\" + escapeSlashes(messagePart))\n        };\n    }\n}\nvar ExternalExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExternalExpr, _super);\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    ExternalExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    };\n    ExternalExpr.prototype.isConstant = function () {\n        return false;\n    };\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ExternalReference = /** @class */ (function () {\n    function ExternalReference(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n    return ExternalReference;\n}());\nvar ConditionalExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ConditionalExpr, _super);\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    ConditionalExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    };\n    ConditionalExpr.prototype.isConstant = function () {\n        return false;\n    };\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(NotExpr, _super);\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    NotExpr.prototype.isEquivalent = function (e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    };\n    NotExpr.prototype.isConstant = function () {\n        return false;\n    };\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar AssertNotNull = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AssertNotNull, _super);\n    function AssertNotNull(condition, sourceSpan) {\n        var _this = _super.call(this, condition.type, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    AssertNotNull.prototype.isEquivalent = function (e) {\n        return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    };\n    AssertNotNull.prototype.isConstant = function () {\n        return false;\n    };\n    AssertNotNull.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitAssertNotNullExpr(this, context);\n    };\n    return AssertNotNull;\n}(Expression));\nvar CastExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CastExpr, _super);\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    CastExpr.prototype.isEquivalent = function (e) {\n        return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    };\n    CastExpr.prototype.isConstant = function () {\n        return false;\n    };\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = /** @class */ (function () {\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    FnParam.prototype.isEquivalent = function (param) {\n        return this.name === param.name;\n    };\n    return FnParam;\n}());\nvar FunctionExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FunctionExpr, _super);\n    function FunctionExpr(params, statements, type, sourceSpan, name) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        _this.name = name;\n        return _this;\n    }\n    FunctionExpr.prototype.isEquivalent = function (e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    };\n    FunctionExpr.prototype.isConstant = function () {\n        return false;\n    };\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BinaryOperatorExpr, _super);\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan, parens) {\n        if (parens === void 0) { parens = true; }\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.parens = parens;\n        _this.lhs = lhs;\n        return _this;\n    }\n    BinaryOperatorExpr.prototype.isEquivalent = function (e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    };\n    BinaryOperatorExpr.prototype.isConstant = function () {\n        return false;\n    };\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadPropExpr, _super);\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    ReadPropExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    };\n    ReadPropExpr.prototype.isConstant = function () {\n        return false;\n    };\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReadKeyExpr, _super);\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    ReadKeyExpr.prototype.isEquivalent = function (e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    };\n    ReadKeyExpr.prototype.isConstant = function () {\n        return false;\n    };\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralArrayExpr, _super);\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    LiteralArrayExpr.prototype.isConstant = function () {\n        return this.entries.every(function (e) { return e.isConstant(); });\n    };\n    LiteralArrayExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    };\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = /** @class */ (function () {\n    function LiteralMapEntry(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    LiteralMapEntry.prototype.isEquivalent = function (e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    };\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralMapExpr, _super);\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    LiteralMapExpr.prototype.isEquivalent = function (e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    };\n    LiteralMapExpr.prototype.isConstant = function () {\n        return this.entries.every(function (e) { return e.value.isConstant(); });\n    };\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CommaExpr, _super);\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    CommaExpr.prototype.isEquivalent = function (e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    };\n    CommaExpr.prototype.isConstant = function () {\n        return false;\n    };\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n//// Statements\nvar StmtModifier;\n(function (StmtModifier) {\n    StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nvar Statement = /** @class */ (function () {\n    function Statement(modifiers, sourceSpan) {\n        this.modifiers = modifiers || [];\n        this.sourceSpan = sourceSpan || null;\n    }\n    Statement.prototype.hasModifier = function (modifier) {\n        return this.modifiers.indexOf(modifier) !== -1;\n    };\n    return Statement;\n}());\nvar DeclareVarStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DeclareVarStmt, _super);\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || (value && value.type) || null;\n        return _this;\n    }\n    DeclareVarStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    };\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DeclareFunctionStmt, _super);\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type || null;\n        return _this;\n    }\n    DeclareFunctionStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    };\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpressionStatement, _super);\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    ExpressionStatement.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    };\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReturnStatement, _super);\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    ReturnStatement.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    };\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = /** @class */ (function () {\n    function AbstractClassPart(type, modifiers) {\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n        this.type = type || null;\n    }\n    AbstractClassPart.prototype.hasModifier = function (modifier) {\n        return this.modifiers.indexOf(modifier) !== -1;\n    };\n    return AbstractClassPart;\n}());\nvar ClassField = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassField, _super);\n    function ClassField(name, type, modifiers, initializer) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.initializer = initializer;\n        return _this;\n    }\n    ClassField.prototype.isEquivalent = function (f) {\n        return this.name === f.name;\n    };\n    return ClassField;\n}(AbstractClassPart));\nvar ClassMethod = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassMethod, _super);\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    ClassMethod.prototype.isEquivalent = function (m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassGetter, _super);\n    function ClassGetter(name, body, type, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    ClassGetter.prototype.isEquivalent = function (m) {\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\n    };\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ClassStmt, _super);\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    ClassStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof ClassStmt && this.name === stmt.name &&\n            nullSafeIsEquivalent(this.parent, stmt.parent) &&\n            areAllEquivalent(this.fields, stmt.fields) &&\n            areAllEquivalent(this.getters, stmt.getters) &&\n            this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\n            areAllEquivalent(this.methods, stmt.methods);\n    };\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(IfStmt, _super);\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    IfStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    };\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar CommentStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CommentStmt, _super);\n    function CommentStmt(comment, multiline, sourceSpan) {\n        if (multiline === void 0) { multiline = false; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.comment = comment;\n        _this.multiline = multiline;\n        return _this;\n    }\n    CommentStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof CommentStmt;\n    };\n    CommentStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitCommentStmt(this, context);\n    };\n    return CommentStmt;\n}(Statement));\nvar JSDocCommentStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(JSDocCommentStmt, _super);\n    function JSDocCommentStmt(tags, sourceSpan) {\n        if (tags === void 0) { tags = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.tags = tags;\n        return _this;\n    }\n    JSDocCommentStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();\n    };\n    JSDocCommentStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitJSDocCommentStmt(this, context);\n    };\n    JSDocCommentStmt.prototype.toString = function () {\n        return serializeTags(this.tags);\n    };\n    return JSDocCommentStmt;\n}(Statement));\nvar TryCatchStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TryCatchStmt, _super);\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    TryCatchStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n            areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    };\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ThrowStmt, _super);\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    ThrowStmt.prototype.isEquivalent = function (stmt) {\n        return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    };\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer = /** @class */ (function () {\n    function AstTransformer() {\n    }\n    AstTransformer.prototype.transformExpr = function (expr, context) {\n        return expr;\n    };\n    AstTransformer.prototype.transformStmt = function (stmt, context) {\n        return stmt;\n    };\n    AstTransformer.prototype.visitReadVarExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitWrappedNodeExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitTypeofExpr = function (expr, context) {\n        return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitLocalizedString = function (ast, context) {\n        return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    AstTransformer.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitAssertNotNullExpr = function (ast, context) {\n        return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var mapType = new MapType(ast.valueType, null);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    AstTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {\n        var value = stmt.value && stmt.value.visitExpression(this, context);\n        return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var parent = stmt.parent.visitExpression(this, context);\n        var getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    AstTransformer.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    AstTransformer.prototype.visitJSDocCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    AstTransformer.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer;\n}());\nvar RecursiveAstVisitor = /** @class */ (function () {\n    function RecursiveAstVisitor() {\n    }\n    RecursiveAstVisitor.prototype.visitType = function (ast, context) {\n        return ast;\n    };\n    RecursiveAstVisitor.prototype.visitExpression = function (ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    };\n    RecursiveAstVisitor.prototype.visitBuiltinType = function (type, context) {\n        return this.visitType(type, context);\n    };\n    RecursiveAstVisitor.prototype.visitExpressionType = function (type, context) {\n        var _this = this;\n        type.value.visitExpression(this, context);\n        if (type.typeParams !== null) {\n            type.typeParams.forEach(function (param) { return _this.visitType(param, context); });\n        }\n        return this.visitType(type, context);\n    };\n    RecursiveAstVisitor.prototype.visitArrayType = function (type, context) {\n        return this.visitType(type, context);\n    };\n    RecursiveAstVisitor.prototype.visitMapType = function (type, context) {\n        return this.visitType(type, context);\n    };\n    RecursiveAstVisitor.prototype.visitWrappedNodeExpr = function (ast, context) {\n        return ast;\n    };\n    RecursiveAstVisitor.prototype.visitTypeofExpr = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWriteVarExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWriteKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitWritePropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralExpr = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLocalizedString = function (ast, context) {\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitExternalExpr = function (ast, context) {\n        var _this = this;\n        if (ast.typeParams) {\n            ast.typeParams.forEach(function (type) { return type.visitType(_this, context); });\n        }\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitAssertNotNullExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    };\n    RecursiveAstVisitor.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    RecursiveAstVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {\n        if (stmt.value) {\n            stmt.value.visitExpression(this, context);\n        }\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        stmt.parent.visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitCommentStmt = function (stmt, context) {\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitJSDocCommentStmt = function (stmt, context) {\n        return stmt;\n    };\n    RecursiveAstVisitor.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor;\n}());\nfunction findReadVarNames(stmts) {\n    var visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        if (ast.name) {\n            this.varNames.add(ast.name);\n        }\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor));\nfunction collectExternalReferences(stmts) {\n    var visitor = new _FindExternalReferencesVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.externalReferences;\n}\nvar _FindExternalReferencesVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_FindExternalReferencesVisitor, _super);\n    function _FindExternalReferencesVisitor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.externalReferences = [];\n        return _this;\n    }\n    _FindExternalReferencesVisitor.prototype.visitExternalExpr = function (e, context) {\n        this.externalReferences.push(e.value);\n        return _super.prototype.visitExternalExpr.call(this, e, context);\n    };\n    return _FindExternalReferencesVisitor;\n}(RecursiveAstVisitor));\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_ApplySourceSpanTransformer, _super);\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var e_1, _a;\n        var clone = Object.create(obj.constructor.prototype);\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var prop = _c.value;\n                clone[prop] = obj[prop];\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return clone;\n    };\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer));\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction typeofExpr(expr) {\n    return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type) {\n    if (type === void 0) { type = null; }\n    return new LiteralMapExpr(values.map(function (e) { return new LiteralMapEntry(e.key, e.value, e.quoted); }), type, null);\n}\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\nfunction assertNotNull(expr, sourceSpan) {\n    return new AssertNotNull(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction ifStmt(condition, thenClause, elseClause) {\n    return new IfStmt(condition, thenClause, elseClause);\n}\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag) {\n    var out = '';\n    if (tag.tagName) {\n        out += \" @\" + tag.tagName;\n    }\n    if (tag.text) {\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n        }\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n    return out;\n}\nfunction serializeTags(tags) {\n    var e_2, _a;\n    if (tags.length === 0)\n        return '';\n    var out = '*\\n';\n    try {\n        for (var tags_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {\n            var tag = tags_1_1.value;\n            out += ' *';\n            // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n            out += tagToString(tag).replace(/\\n/g, '\\n * ');\n            out += '\\n';\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    out += ' ';\n    return out;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n    var characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(value, context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(value, context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\nfunction isDefined(val) {\n    return val !== null && val !== undefined;\n}\nfunction noUndefined(val) {\n    return val === undefined ? null : val;\n}\nvar ValueTransformer = /** @class */ (function () {\n    function ValueTransformer() {\n    }\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var result = {};\n        Object.keys(map).forEach(function (key) {\n            result[key] = visitValue(map[key], _this, context);\n        });\n        return result;\n    };\n    ValueTransformer.prototype.visitPrimitive = function (value, context) {\n        return value;\n    };\n    ValueTransformer.prototype.visitOther = function (value, context) {\n        return value;\n    };\n    return ValueTransformer;\n}());\nvar SyncAsync = {\n    assertSync: function (value) {\n        if (isPromise(value)) {\n            throw new Error(\"Illegal state: value cannot be a promise\");\n        }\n        return value;\n    },\n    then: function (value, cb) {\n        return isPromise(value) ? value.then(cb) : cb(value);\n    },\n    all: function (syncAsyncValues) {\n        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n    }\n};\nfunction error(msg) {\n    throw new Error(\"Internal Error: \" + msg);\n}\nfunction syntaxError(msg, parseErrors) {\n    var error = Error(msg);\n    error[ERROR_SYNTAX_ERROR] = true;\n    if (parseErrors)\n        error[ERROR_PARSE_ERRORS] = parseErrors;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nvar ERROR_PARSE_ERRORS = 'ngParseErrors';\nfunction isSyntaxError(error) {\n    return error[ERROR_SYNTAX_ERROR];\n}\nfunction getParseErrors(error) {\n    return error[ERROR_PARSE_ERRORS] || [];\n}\n// Escape characters that have a special meaning in Regular Expressions\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\nfunction utf8Encode(str) {\n    var encoded = '';\n    for (var index = 0; index < str.length; index++) {\n        var codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return \"\" + token.overriddenName;\n    }\n    if (token.name) {\n        return \"\" + token.name;\n    }\n    if (!token.toString) {\n        return 'object';\n    }\n    // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n    var res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    var newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n */\nfunction resolveForwardRef(type) {\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n        return type();\n    }\n    else {\n        return type;\n    }\n}\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\nvar Version = /** @class */ (function () {\n    function Version(full) {\n        this.full = full;\n        var splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n    return Version;\n}());\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nvar _global = __global || __window || __self;\nfunction newArray(size, value) {\n    var list = [];\n    for (var i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nfunction partitionArray(arr, conditionFn) {\n    var truthy = [];\n    var falsy = [];\n    arr.forEach(function (item) {\n        (conditionFn(item) ? truthy : falsy).push(item);\n    });\n    return [truthy, falsy];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CONSTANT_PREFIX = '_c';\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nvar UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nvar KEY_CONTEXT = {};\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nvar FixupExpression = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FixupExpression, _super);\n    function FixupExpression(resolved) {\n        var _this = _super.call(this, resolved.type) || this;\n        _this.resolved = resolved;\n        _this.original = resolved;\n        return _this;\n    }\n    FixupExpression.prototype.visitExpression = function (visitor, context) {\n        if (context === KEY_CONTEXT) {\n            // When producing a key we want to traverse the constant not the\n            // variable used to refer to it.\n            return this.original.visitExpression(visitor, context);\n        }\n        else {\n            return this.resolved.visitExpression(visitor, context);\n        }\n    };\n    FixupExpression.prototype.isEquivalent = function (e) {\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    };\n    FixupExpression.prototype.isConstant = function () {\n        return true;\n    };\n    FixupExpression.prototype.fixup = function (expression) {\n        this.resolved = expression;\n        this.shared = true;\n    };\n    return FixupExpression;\n}(Expression));\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nvar ConstantPool = /** @class */ (function () {\n    function ConstantPool() {\n        this.statements = [];\n        this.literals = new Map();\n        this.literalFactories = new Map();\n        this.injectorDefinitions = new Map();\n        this.directiveDefinitions = new Map();\n        this.componentDefinitions = new Map();\n        this.pipeDefinitions = new Map();\n        this.nextNameIndex = 0;\n    }\n    ConstantPool.prototype.getConstLiteral = function (literal, forceShared) {\n        if (literal instanceof LiteralExpr || literal instanceof FixupExpression) {\n            // Do no put simple literals into the constant pool or try to produce a constant for a\n            // reference to a constant.\n            return literal;\n        }\n        var key = this.keyOf(literal);\n        var fixup = this.literals.get(key);\n        var newValue = false;\n        if (!fixup) {\n            fixup = new FixupExpression(literal);\n            this.literals.set(key, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            // Replace the expression with a variable\n            var name_1 = this.freshName();\n            this.statements.push(variable(name_1).set(literal).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n            fixup.fixup(variable(name_1));\n        }\n        return fixup;\n    };\n    ConstantPool.prototype.getDefinition = function (type, kind, ctx, forceShared) {\n        if (forceShared === void 0) { forceShared = false; }\n        var definitions = this.definitionsOf(kind);\n        var fixup = definitions.get(type);\n        var newValue = false;\n        if (!fixup) {\n            var property = this.propertyNameOf(kind);\n            fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n            definitions.set(type, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            var name_2 = this.freshName();\n            this.statements.push(variable(name_2).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n            fixup.fixup(variable(name_2));\n        }\n        return fixup;\n    };\n    ConstantPool.prototype.getLiteralFactory = function (literal) {\n        // Create a pure function that builds an array of a mix of constant and variable expressions\n        if (literal instanceof LiteralArrayExpr) {\n            var argumentsForKey = literal.entries.map(function (e) { return e.isConstant() ? e : UNKNOWN_VALUE_KEY; });\n            var key = this.keyOf(literalArr(argumentsForKey));\n            return this._getLiteralFactory(key, literal.entries, function (entries) { return literalArr(entries); });\n        }\n        else {\n            var expressionForKey = literalMap(literal.entries.map(function (e) { return ({\n                key: e.key,\n                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                quoted: e.quoted\n            }); }));\n            var key = this.keyOf(expressionForKey);\n            return this._getLiteralFactory(key, literal.entries.map(function (e) { return e.value; }), function (entries) { return literalMap(entries.map(function (value, index) { return ({\n                key: literal.entries[index].key,\n                value: value,\n                quoted: literal.entries[index].quoted\n            }); })); });\n        }\n    };\n    ConstantPool.prototype._getLiteralFactory = function (key, values, resultMap) {\n        var _this = this;\n        var literalFactory = this.literalFactories.get(key);\n        var literalFactoryArguments = values.filter((function (e) { return !e.isConstant(); }));\n        if (!literalFactory) {\n            var resultExpressions = values.map(function (e, index) { return e.isConstant() ? _this.getConstLiteral(e, true) : variable(\"a\" + index); });\n            var parameters = resultExpressions.filter(isVariable).map(function (e) { return new FnParam(e.name, DYNAMIC_TYPE); });\n            var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n            var name_3 = this.freshName();\n            this.statements.push(variable(name_3).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [\n                StmtModifier.Final\n            ]));\n            literalFactory = variable(name_3);\n            this.literalFactories.set(key, literalFactory);\n        }\n        return { literalFactory: literalFactory, literalFactoryArguments: literalFactoryArguments };\n    };\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n    ConstantPool.prototype.uniqueName = function (prefix) {\n        return \"\" + prefix + this.nextNameIndex++;\n    };\n    ConstantPool.prototype.definitionsOf = function (kind) {\n        switch (kind) {\n            case 2 /* Component */:\n                return this.componentDefinitions;\n            case 1 /* Directive */:\n                return this.directiveDefinitions;\n            case 0 /* Injector */:\n                return this.injectorDefinitions;\n            case 3 /* Pipe */:\n                return this.pipeDefinitions;\n        }\n        error(\"Unknown definition kind \" + kind);\n        return this.componentDefinitions;\n    };\n    ConstantPool.prototype.propertyNameOf = function (kind) {\n        switch (kind) {\n            case 2 /* Component */:\n                return 'cmp';\n            case 1 /* Directive */:\n                return 'dir';\n            case 0 /* Injector */:\n                return 'inj';\n            case 3 /* Pipe */:\n                return 'pipe';\n        }\n        error(\"Unknown definition kind \" + kind);\n        return '<unknown>';\n    };\n    ConstantPool.prototype.freshName = function () {\n        return this.uniqueName(CONSTANT_PREFIX);\n    };\n    ConstantPool.prototype.keyOf = function (expression) {\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    };\n    return ConstantPool;\n}());\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nvar KeyVisitor = /** @class */ (function () {\n    function KeyVisitor() {\n        this.visitWrappedNodeExpr = invalid;\n        this.visitWriteVarExpr = invalid;\n        this.visitWriteKeyExpr = invalid;\n        this.visitWritePropExpr = invalid;\n        this.visitInvokeMethodExpr = invalid;\n        this.visitInvokeFunctionExpr = invalid;\n        this.visitInstantiateExpr = invalid;\n        this.visitConditionalExpr = invalid;\n        this.visitNotExpr = invalid;\n        this.visitAssertNotNullExpr = invalid;\n        this.visitCastExpr = invalid;\n        this.visitFunctionExpr = invalid;\n        this.visitBinaryOperatorExpr = invalid;\n        this.visitReadPropExpr = invalid;\n        this.visitReadKeyExpr = invalid;\n        this.visitCommaExpr = invalid;\n        this.visitLocalizedString = invalid;\n    }\n    KeyVisitor.prototype.visitLiteralExpr = function (ast) {\n        return \"\" + (typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value);\n    };\n    KeyVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n        var _this = this;\n        return \"[\" + ast.entries.map(function (entry) { return entry.visitExpression(_this, context); }).join(',') + \"]\";\n    };\n    KeyVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var mapKey = function (entry) {\n            var quote = entry.quoted ? '\"' : '';\n            return \"\" + quote + entry.key + quote;\n        };\n        var mapEntry = function (entry) {\n            return mapKey(entry) + \":\" + entry.value.visitExpression(_this, context);\n        };\n        return \"{\" + ast.entries.map(mapEntry).join(',');\n    };\n    KeyVisitor.prototype.visitExternalExpr = function (ast) {\n        return ast.value.moduleName ? \"EX:\" + ast.value.moduleName + \":\" + ast.value.name :\n            \"EX:\" + ast.value.runtime.name;\n    };\n    KeyVisitor.prototype.visitReadVarExpr = function (node) {\n        return \"VAR:\" + node.name;\n    };\n    KeyVisitor.prototype.visitTypeofExpr = function (node, context) {\n        return \"TYPEOF:\" + node.expr.visitExpression(this, context);\n    };\n    return KeyVisitor;\n}());\nfunction invalid(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n}\nfunction isVariable(e) {\n    return e instanceof ReadVarExpr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = '@angular/core';\nvar Identifiers = /** @class */ (function () {\n    function Identifiers() {\n    }\n    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n        name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n        moduleName: CORE,\n    };\n    Identifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };\n    Identifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };\n    Identifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };\n    Identifiers.ChangeDetectorRef = {\n        name: 'ChangeDetectorRef',\n        moduleName: CORE,\n    };\n    Identifiers.QueryList = { name: 'QueryList', moduleName: CORE };\n    Identifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };\n    Identifiers.Renderer2 = { name: 'Renderer2', moduleName: CORE };\n    Identifiers.CodegenComponentFactoryResolver = {\n        name: 'CodegenComponentFactoryResolver',\n        moduleName: CORE,\n    };\n    Identifiers.ComponentFactoryResolver = {\n        name: 'ComponentFactoryResolver',\n        moduleName: CORE,\n    };\n    Identifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };\n    Identifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };\n    Identifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };\n    Identifiers.createModuleFactory = {\n        name: 'cmf',\n        moduleName: CORE,\n    };\n    Identifiers.moduleDef = {\n        name: 'mod',\n        moduleName: CORE,\n    };\n    Identifiers.moduleProviderDef = {\n        name: 'mpd',\n        moduleName: CORE,\n    };\n    Identifiers.RegisterModuleFactoryFn = {\n        name: 'registerModuleFactory',\n        moduleName: CORE,\n    };\n    Identifiers.inject = { name: 'inject', moduleName: CORE };\n    Identifiers.directiveInject = { name: 'directiveInject', moduleName: CORE };\n    Identifiers.INJECTOR = { name: 'INJECTOR', moduleName: CORE };\n    Identifiers.Injector = { name: 'Injector', moduleName: CORE };\n    Identifiers.defineInjectable = { name: 'defineInjectable', moduleName: CORE };\n    Identifiers.InjectableDef = { name: 'InjectableDef', moduleName: CORE };\n    Identifiers.ViewEncapsulation = {\n        name: 'ViewEncapsulation',\n        moduleName: CORE,\n    };\n    Identifiers.ChangeDetectionStrategy = {\n        name: 'ChangeDetectionStrategy',\n        moduleName: CORE,\n    };\n    Identifiers.SecurityContext = {\n        name: 'SecurityContext',\n        moduleName: CORE,\n    };\n    Identifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };\n    Identifiers.TRANSLATIONS_FORMAT = {\n        name: 'TRANSLATIONS_FORMAT',\n        moduleName: CORE,\n    };\n    Identifiers.inlineInterpolate = {\n        name: 'inlineInterpolate',\n        moduleName: CORE,\n    };\n    Identifiers.interpolate = { name: 'interpolate', moduleName: CORE };\n    Identifiers.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE };\n    Identifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE };\n    Identifiers.Renderer = { name: 'Renderer', moduleName: CORE };\n    Identifiers.viewDef = { name: 'vid', moduleName: CORE };\n    Identifiers.elementDef = { name: 'eld', moduleName: CORE };\n    Identifiers.anchorDef = { name: 'and', moduleName: CORE };\n    Identifiers.textDef = { name: 'ted', moduleName: CORE };\n    Identifiers.directiveDef = { name: 'did', moduleName: CORE };\n    Identifiers.providerDef = { name: 'prd', moduleName: CORE };\n    Identifiers.queryDef = { name: 'qud', moduleName: CORE };\n    Identifiers.pureArrayDef = { name: 'pad', moduleName: CORE };\n    Identifiers.pureObjectDef = { name: 'pod', moduleName: CORE };\n    Identifiers.purePipeDef = { name: 'ppd', moduleName: CORE };\n    Identifiers.pipeDef = { name: 'pid', moduleName: CORE };\n    Identifiers.nodeValue = { name: 'nov', moduleName: CORE };\n    Identifiers.ngContentDef = { name: 'ncd', moduleName: CORE };\n    Identifiers.unwrapValue = { name: 'unv', moduleName: CORE };\n    Identifiers.createRendererType2 = { name: 'crt', moduleName: CORE };\n    // type only\n    Identifiers.RendererType2 = {\n        name: 'RendererType2',\n        moduleName: CORE,\n    };\n    // type only\n    Identifiers.ViewDefinition = {\n        name: 'ViewDefinition',\n        moduleName: CORE,\n    };\n    Identifiers.createComponentFactory = { name: 'ccf', moduleName: CORE };\n    Identifiers.setClassMetadata = { name: 'setClassMetadata', moduleName: CORE };\n    return Identifiers;\n}());\nfunction createTokenForReference(reference) {\n    return { identifier: { reference: reference } };\n}\nfunction createTokenForExternalReference(reflector, reference) {\n    return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = /** @class */ (function () {\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = /** @class */ (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nfunction sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\nfunction identifierModuleUrl(compileIdentifier) {\n    var ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    // Runtime type\n    return \"./\" + stringify(ref);\n}\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind;\n(function (CompileSummaryKind) {\n    CompileSummaryKind[CompileSummaryKind[\"Pipe\"] = 0] = \"Pipe\";\n    CompileSummaryKind[CompileSummaryKind[\"Directive\"] = 1] = \"Directive\";\n    CompileSummaryKind[CompileSummaryKind[\"NgModule\"] = 2] = \"NgModule\";\n    CompileSummaryKind[CompileSummaryKind[\"Injectable\"] = 3] = \"Injectable\";\n})(CompileSummaryKind || (CompileSummaryKind = {}));\nfunction tokenName(token) {\n    return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = /** @class */ (function () {\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = /** @class */ (function () {\n    function CompileTemplateMetadata(_a) {\n        var encapsulation = _a.encapsulation, template = _a.template, templateUrl = _a.templateUrl, htmlAst = _a.htmlAst, styles = _a.styles, styleUrls = _a.styleUrls, externalStylesheets = _a.externalStylesheets, animations = _a.animations, ngContentSelectors = _a.ngContentSelectors, interpolation = _a.interpolation, isInline = _a.isInline, preserveWhitespaces = _a.preserveWhitespaces;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.htmlAst = htmlAst;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n        this.preserveWhitespaces = preserveWhitespaces;\n    }\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n            styles: this.styles,\n            animations: this.animations\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = /** @class */ (function () {\n    function CompileDirectiveMetadata(_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, hostListeners = _a.hostListeners, hostProperties = _a.hostProperties, hostAttributes = _a.hostAttributes, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, guards = _a.guards, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.guards = guards;\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    CompileDirectiveMetadata.create = function (_a) {\n        var isHost = _a.isHost, type = _a.type, isComponent = _a.isComponent, selector = _a.selector, exportAs = _a.exportAs, changeDetection = _a.changeDetection, inputs = _a.inputs, outputs = _a.outputs, host = _a.host, providers = _a.providers, viewProviders = _a.viewProviders, queries = _a.queries, guards = _a.guards, viewQueries = _a.viewQueries, entryComponents = _a.entryComponents, template = _a.template, componentViewType = _a.componentViewType, rendererType = _a.rendererType, componentFactory = _a.componentFactory;\n        var hostListeners = {};\n        var hostProperties = {};\n        var hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var value = host[key];\n                var matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent,\n            selector: selector,\n            exportAs: exportAs,\n            changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            guards: guards,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            guards: this.guards,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\nvar CompilePipeMetadata = /** @class */ (function () {\n    function CompilePipeMetadata(_a) {\n        var type = _a.type, name = _a.name, pure = _a.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\nvar CompileShallowModuleMetadata = /** @class */ (function () {\n    function CompileShallowModuleMetadata() {\n    }\n    return CompileShallowModuleMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = /** @class */ (function () {\n    function CompileNgModuleMetadata(_a) {\n        var type = _a.type, providers = _a.providers, declaredDirectives = _a.declaredDirectives, exportedDirectives = _a.exportedDirectives, declaredPipes = _a.declaredPipes, exportedPipes = _a.exportedPipes, entryComponents = _a.entryComponents, bootstrapComponents = _a.bootstrapComponents, importedModules = _a.importedModules, exportedModules = _a.exportedModules, schemas = _a.schemas, transitiveModule = _a.transitiveModule, id = _a.id;\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n    }\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        var module = this.transitiveModule;\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: module.entryComponents,\n            providers: module.providers,\n            modules: module.modules,\n            exportedDirectives: module.exportedDirectives,\n            exportedPipes: module.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = /** @class */ (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = /** @class */ (function () {\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n    }, []);\n}\nfunction jitSourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = templateMeta.templateUrl;\n    }\n    return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\nfunction sharedStylesheetJitUrl(meta, id) {\n    var pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n    var baseName = pathParts[pathParts.length - 1];\n    return jitSourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\nfunction ngModuleJitUrl(moduleMeta) {\n    return jitSourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return jitSourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE$1 = '@angular/core';\nvar Identifiers$1 = /** @class */ (function () {\n    function Identifiers() {\n    }\n    /* Methods */\n    Identifiers.NEW_METHOD = 'factory';\n    Identifiers.TRANSFORM_METHOD = 'transform';\n    Identifiers.PATCH_DEPS = 'patchedDeps';\n    /* Instructions */\n    Identifiers.namespaceHTML = { name: 'namespaceHTML', moduleName: CORE$1 };\n    Identifiers.namespaceMathML = { name: 'namespaceMathML', moduleName: CORE$1 };\n    Identifiers.namespaceSVG = { name: 'namespaceSVG', moduleName: CORE$1 };\n    Identifiers.element = { name: 'element', moduleName: CORE$1 };\n    Identifiers.elementStart = { name: 'elementStart', moduleName: CORE$1 };\n    Identifiers.elementEnd = { name: 'elementEnd', moduleName: CORE$1 };\n    Identifiers.select = { name: 'select', moduleName: CORE$1 };\n    Identifiers.advance = { name: 'advance', moduleName: CORE$1 };\n    Identifiers.updateSyntheticHostBinding = { name: 'updateSyntheticHostBinding', moduleName: CORE$1 };\n    Identifiers.componentHostSyntheticListener = { name: 'componentHostSyntheticListener', moduleName: CORE$1 };\n    Identifiers.attribute = { name: 'attribute', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate1 = { name: 'attributeInterpolate1', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate2 = { name: 'attributeInterpolate2', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate3 = { name: 'attributeInterpolate3', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate4 = { name: 'attributeInterpolate4', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate5 = { name: 'attributeInterpolate5', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate6 = { name: 'attributeInterpolate6', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate7 = { name: 'attributeInterpolate7', moduleName: CORE$1 };\n    Identifiers.attributeInterpolate8 = { name: 'attributeInterpolate8', moduleName: CORE$1 };\n    Identifiers.attributeInterpolateV = { name: 'attributeInterpolateV', moduleName: CORE$1 };\n    Identifiers.classProp = { name: 'classProp', moduleName: CORE$1 };\n    Identifiers.elementContainerStart = { name: 'elementContainerStart', moduleName: CORE$1 };\n    Identifiers.elementContainerEnd = { name: 'elementContainerEnd', moduleName: CORE$1 };\n    Identifiers.elementContainer = { name: 'elementContainer', moduleName: CORE$1 };\n    Identifiers.styleMap = { name: 'styleMap', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate1 = { name: 'styleMapInterpolate1', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate2 = { name: 'styleMapInterpolate2', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate3 = { name: 'styleMapInterpolate3', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate4 = { name: 'styleMapInterpolate4', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate5 = { name: 'styleMapInterpolate5', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate6 = { name: 'styleMapInterpolate6', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate7 = { name: 'styleMapInterpolate7', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolate8 = { name: 'styleMapInterpolate8', moduleName: CORE$1 };\n    Identifiers.styleMapInterpolateV = { name: 'styleMapInterpolateV', moduleName: CORE$1 };\n    Identifiers.classMap = { name: 'classMap', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate1 = { name: 'classMapInterpolate1', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate2 = { name: 'classMapInterpolate2', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate3 = { name: 'classMapInterpolate3', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate4 = { name: 'classMapInterpolate4', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate5 = { name: 'classMapInterpolate5', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate6 = { name: 'classMapInterpolate6', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate7 = { name: 'classMapInterpolate7', moduleName: CORE$1 };\n    Identifiers.classMapInterpolate8 = { name: 'classMapInterpolate8', moduleName: CORE$1 };\n    Identifiers.classMapInterpolateV = { name: 'classMapInterpolateV', moduleName: CORE$1 };\n    Identifiers.styleProp = { name: 'styleProp', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate1 = { name: 'stylePropInterpolate1', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate2 = { name: 'stylePropInterpolate2', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate3 = { name: 'stylePropInterpolate3', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate4 = { name: 'stylePropInterpolate4', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate5 = { name: 'stylePropInterpolate5', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate6 = { name: 'stylePropInterpolate6', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate7 = { name: 'stylePropInterpolate7', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolate8 = { name: 'stylePropInterpolate8', moduleName: CORE$1 };\n    Identifiers.stylePropInterpolateV = { name: 'stylePropInterpolateV', moduleName: CORE$1 };\n    Identifiers.nextContext = { name: 'nextContext', moduleName: CORE$1 };\n    Identifiers.templateCreate = { name: 'template', moduleName: CORE$1 };\n    Identifiers.text = { name: 'text', moduleName: CORE$1 };\n    Identifiers.enableBindings = { name: 'enableBindings', moduleName: CORE$1 };\n    Identifiers.disableBindings = { name: 'disableBindings', moduleName: CORE$1 };\n    Identifiers.getCurrentView = { name: 'getCurrentView', moduleName: CORE$1 };\n    Identifiers.textInterpolate = { name: 'textInterpolate', moduleName: CORE$1 };\n    Identifiers.textInterpolate1 = { name: 'textInterpolate1', moduleName: CORE$1 };\n    Identifiers.textInterpolate2 = { name: 'textInterpolate2', moduleName: CORE$1 };\n    Identifiers.textInterpolate3 = { name: 'textInterpolate3', moduleName: CORE$1 };\n    Identifiers.textInterpolate4 = { name: 'textInterpolate4', moduleName: CORE$1 };\n    Identifiers.textInterpolate5 = { name: 'textInterpolate5', moduleName: CORE$1 };\n    Identifiers.textInterpolate6 = { name: 'textInterpolate6', moduleName: CORE$1 };\n    Identifiers.textInterpolate7 = { name: 'textInterpolate7', moduleName: CORE$1 };\n    Identifiers.textInterpolate8 = { name: 'textInterpolate8', moduleName: CORE$1 };\n    Identifiers.textInterpolateV = { name: 'textInterpolateV', moduleName: CORE$1 };\n    Identifiers.restoreView = { name: 'restoreView', moduleName: CORE$1 };\n    Identifiers.pureFunction0 = { name: 'pureFunction0', moduleName: CORE$1 };\n    Identifiers.pureFunction1 = { name: 'pureFunction1', moduleName: CORE$1 };\n    Identifiers.pureFunction2 = { name: 'pureFunction2', moduleName: CORE$1 };\n    Identifiers.pureFunction3 = { name: 'pureFunction3', moduleName: CORE$1 };\n    Identifiers.pureFunction4 = { name: 'pureFunction4', moduleName: CORE$1 };\n    Identifiers.pureFunction5 = { name: 'pureFunction5', moduleName: CORE$1 };\n    Identifiers.pureFunction6 = { name: 'pureFunction6', moduleName: CORE$1 };\n    Identifiers.pureFunction7 = { name: 'pureFunction7', moduleName: CORE$1 };\n    Identifiers.pureFunction8 = { name: 'pureFunction8', moduleName: CORE$1 };\n    Identifiers.pureFunctionV = { name: 'pureFunctionV', moduleName: CORE$1 };\n    Identifiers.pipeBind1 = { name: 'pipeBind1', moduleName: CORE$1 };\n    Identifiers.pipeBind2 = { name: 'pipeBind2', moduleName: CORE$1 };\n    Identifiers.pipeBind3 = { name: 'pipeBind3', moduleName: CORE$1 };\n    Identifiers.pipeBind4 = { name: 'pipeBind4', moduleName: CORE$1 };\n    Identifiers.pipeBindV = { name: 'pipeBindV', moduleName: CORE$1 };\n    Identifiers.hostProperty = { name: 'hostProperty', moduleName: CORE$1 };\n    Identifiers.property = { name: 'property', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate = { name: 'propertyInterpolate', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate1 = { name: 'propertyInterpolate1', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate2 = { name: 'propertyInterpolate2', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate3 = { name: 'propertyInterpolate3', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate4 = { name: 'propertyInterpolate4', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate5 = { name: 'propertyInterpolate5', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate6 = { name: 'propertyInterpolate6', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate7 = { name: 'propertyInterpolate7', moduleName: CORE$1 };\n    Identifiers.propertyInterpolate8 = { name: 'propertyInterpolate8', moduleName: CORE$1 };\n    Identifiers.propertyInterpolateV = { name: 'propertyInterpolateV', moduleName: CORE$1 };\n    Identifiers.i18n = { name: 'i18n', moduleName: CORE$1 };\n    Identifiers.i18nAttributes = { name: 'i18nAttributes', moduleName: CORE$1 };\n    Identifiers.i18nExp = { name: 'i18nExp', moduleName: CORE$1 };\n    Identifiers.i18nStart = { name: 'i18nStart', moduleName: CORE$1 };\n    Identifiers.i18nEnd = { name: 'i18nEnd', moduleName: CORE$1 };\n    Identifiers.i18nApply = { name: 'i18nApply', moduleName: CORE$1 };\n    Identifiers.i18nPostprocess = { name: 'i18nPostprocess', moduleName: CORE$1 };\n    Identifiers.pipe = { name: 'pipe', moduleName: CORE$1 };\n    Identifiers.projection = { name: 'projection', moduleName: CORE$1 };\n    Identifiers.projectionDef = { name: 'projectionDef', moduleName: CORE$1 };\n    Identifiers.reference = { name: 'reference', moduleName: CORE$1 };\n    Identifiers.inject = { name: 'inject', moduleName: CORE$1 };\n    Identifiers.injectAttribute = { name: 'injectAttribute', moduleName: CORE$1 };\n    Identifiers.injectPipeChangeDetectorRef = { name: 'injectPipeChangeDetectorRef', moduleName: CORE$1 };\n    Identifiers.directiveInject = { name: 'directiveInject', moduleName: CORE$1 };\n    Identifiers.invalidFactory = { name: 'invalidFactory', moduleName: CORE$1 };\n    Identifiers.invalidFactoryDep = { name: 'invalidFactoryDep', moduleName: CORE$1 };\n    Identifiers.templateRefExtractor = { name: 'templateRefExtractor', moduleName: CORE$1 };\n    Identifiers.resolveWindow = { name: 'resolveWindow', moduleName: CORE$1 };\n    Identifiers.resolveDocument = { name: 'resolveDocument', moduleName: CORE$1 };\n    Identifiers.resolveBody = { name: 'resolveBody', moduleName: CORE$1 };\n    Identifiers.defineComponent = { name: 'defineComponent', moduleName: CORE$1 };\n    Identifiers.setComponentScope = { name: 'setComponentScope', moduleName: CORE$1 };\n    Identifiers.ComponentDefWithMeta = {\n        name: 'ComponentDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.FactoryDef = {\n        name: 'FactoryDef',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineDirective = {\n        name: 'defineDirective',\n        moduleName: CORE$1,\n    };\n    Identifiers.DirectiveDefWithMeta = {\n        name: 'DirectiveDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.InjectorDef = {\n        name: 'InjectorDef',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineInjector = {\n        name: 'defineInjector',\n        moduleName: CORE$1,\n    };\n    Identifiers.NgModuleDefWithMeta = {\n        name: 'NgModuleDefWithMeta',\n        moduleName: CORE$1,\n    };\n    Identifiers.ModuleWithProviders = {\n        name: 'ModuleWithProviders',\n        moduleName: CORE$1,\n    };\n    Identifiers.defineNgModule = { name: 'defineNgModule', moduleName: CORE$1 };\n    Identifiers.setNgModuleScope = { name: 'setNgModuleScope', moduleName: CORE$1 };\n    Identifiers.PipeDefWithMeta = { name: 'PipeDefWithMeta', moduleName: CORE$1 };\n    Identifiers.definePipe = { name: 'definePipe', moduleName: CORE$1 };\n    Identifiers.queryRefresh = { name: 'queryRefresh', moduleName: CORE$1 };\n    Identifiers.viewQuery = { name: 'viewQuery', moduleName: CORE$1 };\n    Identifiers.staticViewQuery = { name: 'staticViewQuery', moduleName: CORE$1 };\n    Identifiers.staticContentQuery = { name: 'staticContentQuery', moduleName: CORE$1 };\n    Identifiers.loadQuery = { name: 'loadQuery', moduleName: CORE$1 };\n    Identifiers.contentQuery = { name: 'contentQuery', moduleName: CORE$1 };\n    Identifiers.NgOnChangesFeature = { name: 'NgOnChangesFeature', moduleName: CORE$1 };\n    Identifiers.InheritDefinitionFeature = { name: 'InheritDefinitionFeature', moduleName: CORE$1 };\n    Identifiers.CopyDefinitionFeature = { name: 'CopyDefinitionFeature', moduleName: CORE$1 };\n    Identifiers.ProvidersFeature = { name: 'ProvidersFeature', moduleName: CORE$1 };\n    Identifiers.listener = { name: 'listener', moduleName: CORE$1 };\n    Identifiers.getFactoryOf = {\n        name: 'getFactoryOf',\n        moduleName: CORE$1,\n    };\n    Identifiers.getInheritedFactory = {\n        name: 'getInheritedFactory',\n        moduleName: CORE$1,\n    };\n    // sanitization-related functions\n    Identifiers.sanitizeHtml = { name: 'sanitizeHtml', moduleName: CORE$1 };\n    Identifiers.sanitizeStyle = { name: 'sanitizeStyle', moduleName: CORE$1 };\n    Identifiers.defaultStyleSanitizer = { name: 'defaultStyleSanitizer', moduleName: CORE$1 };\n    Identifiers.sanitizeResourceUrl = { name: 'sanitizeResourceUrl', moduleName: CORE$1 };\n    Identifiers.sanitizeScript = { name: 'sanitizeScript', moduleName: CORE$1 };\n    Identifiers.sanitizeUrl = { name: 'sanitizeUrl', moduleName: CORE$1 };\n    Identifiers.sanitizeUrlOrResourceUrl = { name: 'sanitizeUrlOrResourceUrl', moduleName: CORE$1 };\n    return Identifiers;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n */\nfunction mapToMapExpression(map) {\n    var result = Object.keys(map).map(function (key) { return ({\n        key: key,\n        // The assertion here is because really TypeScript doesn't allow us to express that if the\n        // key is present, it will have a value, but this is true in reality.\n        value: map[key],\n        quoted: false,\n    }); });\n    return literalMap(result);\n}\n/**\n * Convert metadata into an `Expression` in the given `OutputContext`.\n *\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n */\nfunction convertMetaToOutput(meta, ctx) {\n    if (Array.isArray(meta)) {\n        return literalArr(meta.map(function (entry) { return convertMetaToOutput(entry, ctx); }));\n    }\n    if (meta instanceof StaticSymbol) {\n        return ctx.importExpr(meta);\n    }\n    if (meta == null) {\n        return literal(meta);\n    }\n    throw new Error(\"Internal error: Unsupported or unknown metadata: \" + meta);\n}\nfunction typeWithParameters(type, numParams) {\n    var params = null;\n    if (numParams > 0) {\n        params = [];\n        for (var i = 0; i < numParams; i++) {\n            params.push(DYNAMIC_TYPE);\n        }\n    }\n    return expressionType(type, null, params);\n}\nvar ANIMATE_SYMBOL_PREFIX = '@';\nfunction prepareSyntheticPropertyName(name) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name;\n}\nfunction prepareSyntheticListenerName(name, phase) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name + \".\" + phase;\n}\nfunction isSyntheticPropertyOrListener(name) {\n    return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n}\nfunction getSyntheticPropertyName(name) {\n    // this will strip out listener phase values...\n    // @foo.start => @foo\n    var i = name.indexOf('.');\n    name = i > 0 ? name.substring(0, i) : name;\n    if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n        name = ANIMATE_SYMBOL_PREFIX + name;\n    }\n    return name;\n}\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n    return \"animation_\" + name + \"_\" + phase;\n}\nfunction jitOnlyGuardedExpression(expr) {\n    var ngJitMode = new ExternalExpr({ name: 'ngJitMode', moduleName: null });\n    var jitFlagNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(ngJitMode), literal('undefined'));\n    var jitFlagUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, jitFlagNotDefined, ngJitMode, /* type */ undefined, \n    /* sourceSpan */ undefined, true);\n    return new BinaryOperatorExpr(BinaryOperator.And, jitFlagUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n    var wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $BSPACE = 8;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $7 = 55;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $b = 98;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $PIPE = 124;\nvar $TILDA = 126;\nvar $AT = 64;\nvar $BT = 96;\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n    return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n    return $0 <= code && code <= $7;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = /** @class */ (function () {\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    ParseLocation.prototype.moveBy = function (delta) {\n        var source = this.file.content;\n        var len = source.length;\n        var offset = this.offset;\n        var line = this.line;\n        var col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var content = this.file.content;\n        var startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var endOffset = startOffset;\n            var ctxChars = 0;\n            var ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = /** @class */ (function () {\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = /** @class */ (function () {\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nvar ParseError = /** @class */ (function () {\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    ParseError.prototype.contextualMessage = function () {\n        var ctx = this.span.start.getContext(100, 3);\n        return ctx ? this.msg + \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" :\n            this.msg;\n    };\n    ParseError.prototype.toString = function () {\n        var details = this.span.details ? \", \" + this.span.details : '';\n        return this.contextualMessage() + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\nfunction typeSourceSpan(kind, type) {\n    var moduleUrl = identifierModuleUrl(type);\n    var sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    var sourceFileName = \"in \" + kind + \" \" + typeName + \" in \" + sourceUrl;\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = /** @class */ (function () {\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Text.prototype.visit = function (visitor) {\n        return visitor.visitText(this);\n    };\n    return Text;\n}());\nvar BoundText = /** @class */ (function () {\n    function BoundText(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    BoundText.prototype.visit = function (visitor) {\n        return visitor.visitBoundText(this);\n    };\n    return BoundText;\n}());\nvar TextAttribute = /** @class */ (function () {\n    function TextAttribute(name, value, sourceSpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    TextAttribute.prototype.visit = function (visitor) {\n        return visitor.visitTextAttribute(this);\n    };\n    return TextAttribute;\n}());\nvar BoundAttribute = /** @class */ (function () {\n    function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, valueSpan, i18n) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    BoundAttribute.fromBoundElementProperty = function (prop, i18n) {\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.valueSpan, i18n);\n    };\n    BoundAttribute.prototype.visit = function (visitor) {\n        return visitor.visitBoundAttribute(this);\n    };\n    return BoundAttribute;\n}());\nvar BoundEvent = /** @class */ (function () {\n    function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.type = type;\n        this.handler = handler;\n        this.target = target;\n        this.phase = phase;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n    }\n    BoundEvent.fromParsedEvent = function (event) {\n        var target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\n        var phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);\n    };\n    BoundEvent.prototype.visit = function (visitor) {\n        return visitor.visitBoundEvent(this);\n    };\n    return BoundEvent;\n}());\nvar Element = /** @class */ (function () {\n    function Element(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.name = name;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.children = children;\n        this.references = references;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n        // If the element is empty then the source span should include any closing tag\n        if (children.length === 0 && startSourceSpan && endSourceSpan) {\n            this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);\n        }\n    }\n    Element.prototype.visit = function (visitor) {\n        return visitor.visitElement(this);\n    };\n    return Element;\n}());\nvar Template = /** @class */ (function () {\n    function Template(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.templateAttrs = templateAttrs;\n        this.children = children;\n        this.references = references;\n        this.variables = variables;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    Template.prototype.visit = function (visitor) {\n        return visitor.visitTemplate(this);\n    };\n    return Template;\n}());\nvar Content = /** @class */ (function () {\n    function Content(selector, attributes, sourceSpan, i18n) {\n        this.selector = selector;\n        this.attributes = attributes;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    Content.prototype.visit = function (visitor) {\n        return visitor.visitContent(this);\n    };\n    return Content;\n}());\nvar Variable = /** @class */ (function () {\n    function Variable(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    Variable.prototype.visit = function (visitor) {\n        return visitor.visitVariable(this);\n    };\n    return Variable;\n}());\nvar Reference = /** @class */ (function () {\n    function Reference(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    Reference.prototype.visit = function (visitor) {\n        return visitor.visitReference(this);\n    };\n    return Reference;\n}());\nvar Icu = /** @class */ (function () {\n    function Icu(vars, placeholders, sourceSpan, i18n) {\n        this.vars = vars;\n        this.placeholders = placeholders;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    Icu.prototype.visit = function (visitor) {\n        return visitor.visitIcu(this);\n    };\n    return Icu;\n}());\nvar NullVisitor = /** @class */ (function () {\n    function NullVisitor() {\n    }\n    NullVisitor.prototype.visitElement = function (element) { };\n    NullVisitor.prototype.visitTemplate = function (template) { };\n    NullVisitor.prototype.visitContent = function (content) { };\n    NullVisitor.prototype.visitVariable = function (variable) { };\n    NullVisitor.prototype.visitReference = function (reference) { };\n    NullVisitor.prototype.visitTextAttribute = function (attribute) { };\n    NullVisitor.prototype.visitBoundAttribute = function (attribute) { };\n    NullVisitor.prototype.visitBoundEvent = function (attribute) { };\n    NullVisitor.prototype.visitText = function (text) { };\n    NullVisitor.prototype.visitBoundText = function (text) { };\n    NullVisitor.prototype.visitIcu = function (icu) { };\n    return NullVisitor;\n}());\nvar RecursiveVisitor = /** @class */ (function () {\n    function RecursiveVisitor() {\n    }\n    RecursiveVisitor.prototype.visitElement = function (element) {\n        visitAll(this, element.attributes);\n        visitAll(this, element.children);\n        visitAll(this, element.references);\n    };\n    RecursiveVisitor.prototype.visitTemplate = function (template) {\n        visitAll(this, template.attributes);\n        visitAll(this, template.children);\n        visitAll(this, template.references);\n        visitAll(this, template.variables);\n    };\n    RecursiveVisitor.prototype.visitContent = function (content) { };\n    RecursiveVisitor.prototype.visitVariable = function (variable) { };\n    RecursiveVisitor.prototype.visitReference = function (reference) { };\n    RecursiveVisitor.prototype.visitTextAttribute = function (attribute) { };\n    RecursiveVisitor.prototype.visitBoundAttribute = function (attribute) { };\n    RecursiveVisitor.prototype.visitBoundEvent = function (attribute) { };\n    RecursiveVisitor.prototype.visitText = function (text) { };\n    RecursiveVisitor.prototype.visitBoundText = function (text) { };\n    RecursiveVisitor.prototype.visitIcu = function (icu) { };\n    return RecursiveVisitor;\n}());\nvar TransformVisitor = /** @class */ (function () {\n    function TransformVisitor() {\n    }\n    TransformVisitor.prototype.visitElement = function (element) {\n        var newAttributes = transformAll(this, element.attributes);\n        var newInputs = transformAll(this, element.inputs);\n        var newOutputs = transformAll(this, element.outputs);\n        var newChildren = transformAll(this, element.children);\n        var newReferences = transformAll(this, element.references);\n        if (newAttributes != element.attributes || newInputs != element.inputs ||\n            newOutputs != element.outputs || newChildren != element.children ||\n            newReferences != element.references) {\n            return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n        }\n        return element;\n    };\n    TransformVisitor.prototype.visitTemplate = function (template) {\n        var newAttributes = transformAll(this, template.attributes);\n        var newInputs = transformAll(this, template.inputs);\n        var newOutputs = transformAll(this, template.outputs);\n        var newTemplateAttrs = transformAll(this, template.templateAttrs);\n        var newChildren = transformAll(this, template.children);\n        var newReferences = transformAll(this, template.references);\n        var newVariables = transformAll(this, template.variables);\n        if (newAttributes != template.attributes || newInputs != template.inputs ||\n            newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n            newChildren != template.children || newReferences != template.references ||\n            newVariables != template.variables) {\n            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n        }\n        return template;\n    };\n    TransformVisitor.prototype.visitContent = function (content) {\n        return content;\n    };\n    TransformVisitor.prototype.visitVariable = function (variable) {\n        return variable;\n    };\n    TransformVisitor.prototype.visitReference = function (reference) {\n        return reference;\n    };\n    TransformVisitor.prototype.visitTextAttribute = function (attribute) {\n        return attribute;\n    };\n    TransformVisitor.prototype.visitBoundAttribute = function (attribute) {\n        return attribute;\n    };\n    TransformVisitor.prototype.visitBoundEvent = function (attribute) {\n        return attribute;\n    };\n    TransformVisitor.prototype.visitText = function (text) {\n        return text;\n    };\n    TransformVisitor.prototype.visitBoundText = function (text) {\n        return text;\n    };\n    TransformVisitor.prototype.visitIcu = function (icu) {\n        return icu;\n    };\n    return TransformVisitor;\n}());\nfunction visitAll(visitor, nodes) {\n    var e_1, _a, e_2, _b;\n    var result = [];\n    if (visitor.visit) {\n        try {\n            for (var nodes_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n                var node = nodes_1_1.value;\n                var newNode = visitor.visit(node) || node.visit(visitor);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    else {\n        try {\n            for (var nodes_2 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_2_1 = nodes_2.next(); !nodes_2_1.done; nodes_2_1 = nodes_2.next()) {\n                var node = nodes_2_1.value;\n                var newNode = node.visit(visitor);\n                if (newNode) {\n                    result.push(newNode);\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (nodes_2_1 && !nodes_2_1.done && (_b = nodes_2.return)) _b.call(nodes_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    return result;\n}\nfunction transformAll(visitor, nodes) {\n    var e_3, _a;\n    var result = [];\n    var changed = false;\n    try {\n        for (var nodes_3 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(nodes), nodes_3_1 = nodes_3.next(); !nodes_3_1.done; nodes_3_1 = nodes_3.next()) {\n            var node = nodes_3_1.value;\n            var newNode = node.visit(visitor);\n            if (newNode) {\n                result.push(newNode);\n            }\n            changed = changed || newNode != node;\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (nodes_3_1 && !nodes_3_1.done && (_a = nodes_3.return)) _a.call(nodes_3);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return changed ? result : nodes;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = /** @class */ (function () {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param customId\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.customId = customId;\n        this.id = this.customId;\n        /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n        this.legacyIds = [];\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n    return Message;\n}());\nvar Text$1 = /** @class */ (function () {\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Text.prototype.visit = function (visitor, context) {\n        return visitor.visitText(this, context);\n    };\n    return Text;\n}());\n// TODO(vicb): do we really need this node (vs an array) ?\nvar Container = /** @class */ (function () {\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    Container.prototype.visit = function (visitor, context) {\n        return visitor.visitContainer(this, context);\n    };\n    return Container;\n}());\nvar Icu$1 = /** @class */ (function () {\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    Icu.prototype.visit = function (visitor, context) {\n        return visitor.visitIcu(this, context);\n    };\n    return Icu;\n}());\nvar TagPlaceholder = /** @class */ (function () {\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    TagPlaceholder.prototype.visit = function (visitor, context) {\n        return visitor.visitTagPlaceholder(this, context);\n    };\n    return TagPlaceholder;\n}());\nvar Placeholder = /** @class */ (function () {\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    Placeholder.prototype.visit = function (visitor, context) {\n        return visitor.visitPlaceholder(this, context);\n    };\n    return Placeholder;\n}());\nvar IcuPlaceholder = /** @class */ (function () {\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    IcuPlaceholder.prototype.visit = function (visitor, context) {\n        return visitor.visitIcuPlaceholder(this, context);\n    };\n    return IcuPlaceholder;\n}());\n// Clone the AST\nvar CloneVisitor = /** @class */ (function () {\n    function CloneVisitor() {\n    }\n    CloneVisitor.prototype.visitText = function (text, context) {\n        return new Text$1(text.value, text.sourceSpan);\n    };\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\n// Visit all the nodes recursively\nvar RecurseVisitor = /** @class */ (function () {\n    function RecurseVisitor() {\n    }\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) {\n            icu.cases[k].visit(_this);\n        });\n    };\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    return RecurseVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nfunction digest(message) {\n    return message.id || computeDigest(message);\n}\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nfunction computeDigest(message) {\n    return sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nfunction decimalDigest(message) {\n    return message.id || computeDecimalDigest(message);\n}\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nfunction computeDecimalDigest(message) {\n    var visitor = new _SerializerIgnoreIcuExpVisitor();\n    var parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nvar _SerializerVisitor = /** @class */ (function () {\n    function _SerializerVisitor() {\n    }\n    _SerializerVisitor.prototype.visitText = function (text, context) {\n        return text.value;\n    };\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nvar _SerializerIgnoreIcuExpVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nfunction sha1(str) {\n    var utf8 = utf8Encode(str);\n    var words32 = stringToWords32(utf8, Endian.Big);\n    var len = utf8.length * 8;\n    var w = newArray(80);\n    var a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var i = 0; i < words32.length; i += 16) {\n        var h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n        for (var j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var fkVal = fk(j, b, c, d);\n            var f = fkVal[0];\n            var k = fkVal[1];\n            var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            e = d;\n            d = c;\n            c = rol32(b, 30);\n            b = a;\n            a = temp;\n        }\n        a = add32(a, h0);\n        b = add32(b, h1);\n        c = add32(c, h2);\n        d = add32(d, h3);\n        e = add32(e, h4);\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nfunction fingerprint(str) {\n    var utf8 = utf8Encode(str);\n    var hi = hash32(utf8, 0);\n    var lo = hash32(utf8, 102072);\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\nfunction computeMsgId(msg, meaning) {\n    if (meaning === void 0) { meaning = ''; }\n    var msgFingerprint = fingerprint(msg);\n    if (meaning) {\n        var meaningFingerprint = fingerprint(meaning);\n        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n    }\n    var hi = msgFingerprint[0];\n    var lo = msgFingerprint[1];\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\nfunction hash32(str, c) {\n    var a = 0x9e3779b9, b = 0x9e3779b9;\n    var i;\n    var len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        var res = mix(a, b, c);\n        a = res[0], b = res[1], c = res[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix(a, b, c)[2];\n}\n// clang-format off\nfunction mix(a, b, c) {\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n// clang-format on\n// Utils\nvar Endian;\n(function (Endian) {\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n    var low = (a & 0xffff) + (b & 0xffff);\n    var high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\nfunction add64(a, b) {\n    var ah = a[0], al = a[1];\n    var bh = b[0], bl = b[1];\n    var result = add32to64(al, bl);\n    var carry = result[0];\n    var l = result[1];\n    var h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\nfunction sub32(a, b) {\n    var low = (a & 0xffff) - (b & 0xffff);\n    var high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n// Rotate a 32b number left `count` position\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n// Rotate a 64b number left `count` position\nfunction rol64(num, count) {\n    var hi = num[0], lo = num[1];\n    var h = (hi << count) | (lo >>> (32 - count));\n    var l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\nfunction stringToWords32(str, endian) {\n    var size = (str.length + 3) >>> 2;\n    var words32 = [];\n    for (var i = 0; i < size; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\nfunction wordAt(str, index, endian) {\n    var word = 0;\n    if (endian === Endian.Big) {\n        for (var i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\nfunction word32ToByteString(word) {\n    var str = '';\n    for (var i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\nfunction byteStringToHexString(str) {\n    var hex = '';\n    for (var i = 0; i < str.length; i++) {\n        var b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str) {\n    var decimal = '';\n    var toThePower = '1';\n    for (var i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x, y) {\n    var sum = '';\n    var len = Math.max(x.length, y.length);\n    for (var i = 0, carry = 0; i < len || carry; i++) {\n        var tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\nfunction numberTimesBigInt(num, b) {\n    var product = '';\n    var bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Serializer = /** @class */ (function () {\n    function Serializer() {\n    }\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    Serializer.prototype.createNameMapper = function (message) {\n        return null;\n    };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SimplePlaceholderMapper, _super);\n    // create a mapping from the message\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) {\n        return null;\n    };\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    // XMB placeholders could only contains A-Z, 0-9 and _\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor = /** @class */ (function () {\n    function _Visitor() {\n    }\n    _Visitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        var strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    _Visitor.prototype.visitText = function (text) {\n        return text.value;\n    };\n    _Visitor.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    _Visitor.prototype._serializeAttributes = function (attrs) {\n        var strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    _Visitor.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor;\n}());\nvar _visitor = new _Visitor();\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = /** @class */ (function () {\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    Declaration.prototype.visit = function (visitor) {\n        return visitor.visitDeclaration(this);\n    };\n    return Declaration;\n}());\nvar Doctype = /** @class */ (function () {\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    Doctype.prototype.visit = function (visitor) {\n        return visitor.visitDoctype(this);\n    };\n    return Doctype;\n}());\nvar Tag = /** @class */ (function () {\n    function Tag(name, unescapedAttrs, children) {\n        var _this = this;\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    Tag.prototype.visit = function (visitor) {\n        return visitor.visitTag(this);\n    };\n    return Tag;\n}());\nvar Text$2 = /** @class */ (function () {\n    function Text(unescapedValue) {\n        this.value = escapeXml(unescapedValue);\n    }\n    Text.prototype.visit = function (visitor) {\n        return visitor.visitText(this);\n    };\n    return Text;\n}());\nvar CR = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(CR, _super);\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nfunction escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG = 'ph';\nvar _EXAMPLE_TAG = 'ex';\nvar _SOURCE_TAG = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xmb.prototype.write = function (messages, locale) {\n        var exampleVisitor = new ExampleVisitor();\n        var visitor = new _Visitor$1();\n        var rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            var sourceTags = [];\n            message.sources.forEach(function (source) {\n                sourceTags.push(new Tag(_SOURCE_TAG, {}, [new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(sourceTags, visitor.serialize(message.nodes))));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    Xmb.prototype.digest = function (message) {\n        return digest$1(message);\n    };\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$1 = /** @class */ (function () {\n    function _Visitor() {\n    }\n    _Visitor.prototype.visitText = function (text, context) {\n        return [new Text$2(text.value)];\n    };\n    _Visitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _Visitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _Visitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var startTagAsText = new Text$2(\"<\" + ph.tag + \">\");\n        var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        var startTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.startName }, [startEx, startTagAsText]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var closeTagAsText = new Text$2(\"</\" + ph.tag + \">\");\n        var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        var closeTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.closeName }, [closeEx, closeTagAsText]);\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([startTagPh], this.serialize(ph.children), [closeTagPh]);\n    };\n    _Visitor.prototype.visitPlaceholder = function (ph, context) {\n        var interpolationAsText = new Text$2(\"{{\" + ph.value + \"}}\");\n        // Example tag needs to be not-empty for TC.\n        var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, interpolationAsText])\n        ];\n    };\n    _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var icuExpression = ph.value.expression;\n        var icuType = ph.value.type;\n        var icuCases = Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ');\n        var icuAsText = new Text$2(\"{\" + icuExpression + \", \" + icuType + \", \" + icuCases + \"}\");\n        var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, icuAsText])\n        ];\n    };\n    _Visitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _Visitor;\n}());\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\n// TC requires at least one non-empty example on placeholders\nvar ExampleVisitor = /** @class */ (function () {\n    function ExampleVisitor() {\n    }\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG) {\n            if (!tag.children || tag.children.length == 0) {\n                var exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    ExampleVisitor.prototype.visitText = function (text) { };\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nvar CLOSURE_TRANSLATION_PREFIX = 'MSG_';\n/* Prefix for non-`goog.getMsg` i18n-related vars */\nvar TRANSLATION_PREFIX = 'I18N_';\n/** Name of the i18n attributes **/\nvar I18N_ATTR = 'i18n';\nvar I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\nvar I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\nvar I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\nvar I18N_PLACEHOLDER_SYMBOL = '';\nfunction isI18nAttribute(name) {\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction isI18nRootNode(meta) {\n    return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;\n}\nfunction hasI18nMeta(node) {\n    return !!node.i18n;\n}\nfunction hasI18nAttrs(element) {\n    return element.attrs.some(function (attr) { return isI18nAttribute(attr.name); });\n}\nfunction icuFromI18nMessage(message) {\n    return message.nodes[0];\n}\nfunction wrapI18nPlaceholder(content, contextId) {\n    if (contextId === void 0) { contextId = 0; }\n    var blockId = contextId > 0 ? \":\" + contextId : '';\n    return \"\" + I18N_PLACEHOLDER_SYMBOL + content + blockId + I18N_PLACEHOLDER_SYMBOL;\n}\nfunction assembleI18nBoundString(strings, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) { bindingStartIndex = 0; }\n    if (contextId === void 0) { contextId = 0; }\n    if (!strings.length)\n        return '';\n    var acc = '';\n    var lastIdx = strings.length - 1;\n    for (var i = 0; i < lastIdx; i++) {\n        acc += \"\" + strings[i] + wrapI18nPlaceholder(bindingStartIndex + i, contextId);\n    }\n    acc += strings[lastIdx];\n    return acc;\n}\nfunction getSeqNumberGenerator(startsAt) {\n    if (startsAt === void 0) { startsAt = 0; }\n    var current = startsAt;\n    return function () { return current++; };\n}\nfunction placeholdersToParams(placeholders) {\n    var params = {};\n    placeholders.forEach(function (values, key) {\n        params[key] = literal(values.length > 1 ? \"[\" + values.join('|') + \"]\" : values[0]);\n    });\n    return params;\n}\nfunction updatePlaceholderMap(map, name) {\n    var values = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        values[_i - 2] = arguments[_i];\n    }\n    var current = map.get(name) || [];\n    current.push.apply(current, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(values));\n    map.set(name, current);\n}\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex, contextId) {\n    if (bindingStartIndex === void 0) { bindingStartIndex = 0; }\n    if (contextId === void 0) { contextId = 0; }\n    var startIdx = bindingStartIndex;\n    var placeholders = new Map();\n    var node = meta instanceof Message ? meta.nodes.find(function (node) { return node instanceof Container; }) : meta;\n    if (node) {\n        node\n            .children\n            .filter(function (child) { return child instanceof Placeholder; })\n            .forEach(function (child, idx) {\n            var content = wrapI18nPlaceholder(startIdx + idx, contextId);\n            updatePlaceholderMap(placeholders, child.name, content);\n        });\n    }\n    return placeholders;\n}\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nfunction i18nFormatPlaceholderNames(params, useCamelCase) {\n    if (params === void 0) { params = {}; }\n    var _params = {};\n    if (params && Object.keys(params).length) {\n        Object.keys(params).forEach(function (key) { return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]; });\n    }\n    return _params;\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nfunction formatI18nPlaceholderName(name, useCamelCase) {\n    if (useCamelCase === void 0) { useCamelCase = true; }\n    var publicName = toPublicName(name);\n    if (!useCamelCase) {\n        return publicName;\n    }\n    var chunks = publicName.split('_');\n    if (chunks.length === 1) {\n        // if no \"_\" found - just lowercase the value\n        return name.toLowerCase();\n    }\n    var postfix;\n    // eject last element if it's a number\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n        postfix = chunks.pop();\n    }\n    var raw = chunks.shift().toLowerCase();\n    if (chunks.length) {\n        raw += chunks.map(function (c) { return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase(); }).join('');\n    }\n    return postfix ? raw + \"_\" + postfix : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nfunction getTranslationConstPrefix(extra) {\n    return (\"\" + CLOSURE_TRANSLATION_PREFIX + extra).toUpperCase();\n}\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nfunction declareI18nVariable(variable) {\n    return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, null, variable.sourceSpan);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nvar UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\nvar TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\nvar CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\nvar RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\nvar REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\nvar IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\nvar NON_BINDABLE_ATTR = 'ngNonBindable';\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nfunction temporaryAllocator(statements, name) {\n    var temp = null;\n    return function () {\n        if (!temp) {\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n            temp = variable(name);\n        }\n        return temp;\n    };\n}\nfunction unsupported(feature) {\n    if (this) {\n        throw new Error(\"Builder \" + this.constructor.name + \" doesn't support \" + feature + \" yet\");\n    }\n    throw new Error(\"Feature \" + feature + \" is not supported yet\");\n}\nfunction invalid$1(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n}\nfunction asLiteral(value) {\n    if (Array.isArray(value)) {\n        return literalArr(value.map(asLiteral));\n    }\n    return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n        return mapToExpression(keys, keepDeclared);\n    }\n    return null;\n}\nfunction mapToExpression(map, keepDeclared) {\n    return literalMap(Object.getOwnPropertyNames(map).map(function (key) {\n        var _a, _b;\n        // canonical syntax: `dirProp: publicProp`\n        // if there is no `:`, use dirProp = elProp\n        var value = map[key];\n        var declaredName;\n        var publicName;\n        var minifiedName;\n        if (Array.isArray(value)) {\n            _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(value, 2), publicName = _a[0], declaredName = _a[1];\n        }\n        else {\n            _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitAtColon(key, [key, value]), 2), declaredName = _b[0], publicName = _b[1];\n        }\n        minifiedName = declaredName;\n        return {\n            key: minifiedName,\n            // put quotes around keys that contain potentially unsafe characters\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n            value: (keepDeclared && publicName !== declaredName) ?\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n                asLiteral(publicName)\n        };\n    }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\nfunction trimTrailingNulls(parameters) {\n    while (isNull(parameters[parameters.length - 1])) {\n        parameters.pop();\n    }\n    return parameters;\n}\nfunction getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n        var predicate_1 = [];\n        query.predicate.forEach(function (selector) {\n            // Each item in predicates array may contain strings with comma-separated refs\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n            // as separate array entities\n            var selectors = selector.split(',').map(function (token) { return literal(token.trim()); });\n            predicate_1.push.apply(predicate_1, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(selectors));\n        });\n        return constantPool.getConstLiteral(literalArr(predicate_1), true);\n    }\n    else {\n        return query.predicate;\n    }\n}\nfunction noop() { }\nvar DefinitionMap = /** @class */ (function () {\n    function DefinitionMap() {\n        this.values = [];\n    }\n    DefinitionMap.prototype.set = function (key, value) {\n        if (value) {\n            this.values.push({ key: key, value: value, quoted: false });\n        }\n    };\n    DefinitionMap.prototype.toLiteralMap = function () {\n        return literalMap(this.values);\n    };\n    return DefinitionMap;\n}());\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n    var attributesMap = {};\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n        elOrTpl.templateAttrs.forEach(function (a) { return attributesMap[a.name] = ''; });\n    }\n    else {\n        elOrTpl.attributes.forEach(function (a) {\n            if (!isI18nAttribute(a.name)) {\n                attributesMap[a.name] = a.value;\n            }\n        });\n        elOrTpl.inputs.forEach(function (i) {\n            attributesMap[i.name] = '';\n        });\n        elOrTpl.outputs.forEach(function (o) {\n            attributesMap[o.name] = '';\n        });\n    }\n    return attributesMap;\n}\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nfunction chainedInstruction(reference, calls, span) {\n    var expression = importExpr(reference, null, span);\n    if (calls.length > 0) {\n        for (var i = 0; i < calls.length; i++) {\n            expression = expression.callFn(calls[i], span);\n        }\n    }\n    else {\n        // Add a blank invocation, in case the `calls` array is empty.\n        expression = expression.callFn([], span);\n    }\n    return expression;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nfunction getInterpolationArgsLength(interpolation) {\n    var expressions = interpolation.expressions, strings = interpolation.strings;\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n        // `textInterpolate`.\n        return 1;\n    }\n    else {\n        return expressions.length + strings.length;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Factory\"] = 2] = \"Factory\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nvar R3FactoryTarget;\n(function (R3FactoryTarget) {\n    R3FactoryTarget[R3FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    R3FactoryTarget[R3FactoryTarget[\"Component\"] = 1] = \"Component\";\n    R3FactoryTarget[R3FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    R3FactoryTarget[R3FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    R3FactoryTarget[R3FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(R3FactoryTarget || (R3FactoryTarget = {}));\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nvar R3ResolvedDependencyType;\n(function (R3ResolvedDependencyType) {\n    /**\n     * A normal token dependency.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Token\"] = 0] = \"Token\";\n    /**\n     * The dependency is for an attribute.\n     *\n     * The token expression is a string representing the attribute name.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Attribute\"] = 1] = \"Attribute\";\n    /**\n     * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"ChangeDetectorRef\"] = 2] = \"ChangeDetectorRef\";\n    /**\n     * An invalid dependency (no token could be determined). An error should be thrown at runtime.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Invalid\"] = 3] = \"Invalid\";\n})(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nfunction compileFactoryFunction(meta) {\n    var t = variable('t');\n    var statements = [];\n    var ctorDepsType = NONE_TYPE;\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n    var typeForCtor = !isDelegatedMetadata(meta) ?\n        new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :\n        t;\n    var ctorExpr = null;\n    if (meta.deps !== null) {\n        // There is a constructor (either explicitly or implicitly defined).\n        if (meta.deps !== 'invalid') {\n            ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));\n            ctorDepsType = createCtorDepsType(meta.deps);\n        }\n    }\n    else {\n        var baseFactory = variable(\"\\u0275\" + meta.name + \"_BaseFactory\");\n        var getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);\n        var baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.internalType]))\n            .toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);\n        statements.push(baseFactoryStmt);\n        // There is no constructor, use the base class' factory to construct typeForCtor.\n        ctorExpr = baseFactory.callFn([typeForCtor]);\n    }\n    var ctorExprFinal = ctorExpr;\n    var body = [];\n    var retExpr = null;\n    function makeConditionalFactory(nonCtorExpr) {\n        var r = variable('r');\n        body.push(r.set(NULL_EXPR).toDeclStmt());\n        var ctorStmt = null;\n        if (ctorExprFinal !== null) {\n            ctorStmt = r.set(ctorExprFinal).toStmt();\n        }\n        else {\n            ctorStmt = importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();\n        }\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n        return r;\n    }\n    if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {\n        var delegateFactory = variable(\"\\u0275\" + meta.name + \"_BaseFactory\");\n        var getFactoryOf = importExpr(Identifiers$1.getFactoryOf);\n        if (meta.delegate.isEquivalent(meta.internalType)) {\n            throw new Error(\"Illegal state: compiling factory that delegates to itself\");\n        }\n        var delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [\n            StmtModifier.Exported, StmtModifier.Final\n        ]);\n        statements.push(delegateFactoryStmt);\n        retExpr = makeConditionalFactory(delegateFactory.callFn([]));\n    }\n    else if (isDelegatedMetadata(meta)) {\n        // This type is created with a delegated factory. If a type parameter is not specified, call\n        // the factory instead.\n        var delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe);\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n        var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\n            InstantiateExpr :\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\n        retExpr = makeConditionalFactory(factoryExpr);\n    }\n    else if (isExpressionFactoryMetadata(meta)) {\n        // TODO(alxhub): decide whether to lower the value here or in the caller\n        retExpr = makeConditionalFactory(meta.expression);\n    }\n    else {\n        retExpr = ctorExpr;\n    }\n    if (retExpr !== null) {\n        body.push(new ReturnStatement(retExpr));\n    }\n    else {\n        body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());\n    }\n    return {\n        factory: fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, meta.name + \"_Factory\"),\n        statements: statements,\n        type: expressionType(importExpr(Identifiers$1.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]))\n    };\n}\nfunction injectDependencies(deps, injectFn, isPipe) {\n    return deps.map(function (dep, index) { return compileInjectDependency(dep, injectFn, isPipe, index); });\n}\nfunction compileInjectDependency(dep, injectFn, isPipe, index) {\n    // Interpret the dependency according to its resolved type.\n    switch (dep.resolved) {\n        case R3ResolvedDependencyType.Token:\n        case R3ResolvedDependencyType.ChangeDetectorRef:\n            // Build up the injection flags according to the metadata.\n            var flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |\n                (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |\n                (dep.optional ? 8 /* Optional */ : 0);\n            // If this dependency is optional or otherwise has non-default flags, then additional\n            // parameters describing how to inject the dependency must be passed to the inject function\n            // that's being used.\n            var flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;\n            // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n            if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n                return importExpr(Identifiers$1.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n            }\n            // Build up the arguments to the injectFn call.\n            var injectArgs = [dep.token];\n            if (flagsParam) {\n                injectArgs.push(flagsParam);\n            }\n            return importExpr(injectFn).callFn(injectArgs);\n        case R3ResolvedDependencyType.Attribute:\n            // In the case of attributes, the attribute name in question is given as the token.\n            return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);\n        case R3ResolvedDependencyType.Invalid:\n            return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);\n        default:\n            return unsupported(\"Unknown R3ResolvedDependencyType: \" + R3ResolvedDependencyType[dep.resolved]);\n    }\n}\nfunction createCtorDepsType(deps) {\n    var hasTypes = false;\n    var attributeTypes = deps.map(function (dep) {\n        var type = createCtorDepType(dep);\n        if (type !== null) {\n            hasTypes = true;\n            return type;\n        }\n        else {\n            return literal(null);\n        }\n    });\n    if (hasTypes) {\n        return expressionType(literalArr(attributeTypes));\n    }\n    else {\n        return NONE_TYPE;\n    }\n}\nfunction createCtorDepType(dep) {\n    var entries = [];\n    if (dep.resolved === R3ResolvedDependencyType.Attribute) {\n        if (dep.attribute !== null) {\n            entries.push({ key: 'attribute', value: dep.attribute, quoted: false });\n        }\n    }\n    if (dep.optional) {\n        entries.push({ key: 'optional', value: literal(true), quoted: false });\n    }\n    if (dep.host) {\n        entries.push({ key: 'host', value: literal(true), quoted: false });\n    }\n    if (dep.self) {\n        entries.push({ key: 'self', value: literal(true), quoted: false });\n    }\n    if (dep.skipSelf) {\n        entries.push({ key: 'skipSelf', value: literal(true), quoted: false });\n    }\n    return entries.length > 0 ? literalMap(entries) : null;\n}\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nfunction dependenciesFromGlobalMetadata(type, outputCtx, reflector) {\n    var e_1, _a;\n    // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n    // be compared with the token to statically determine whether the token has significance to\n    // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n    var injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n    // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n    var deps = [];\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(type.diDeps), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var dependency = _c.value;\n            if (dependency.token) {\n                var tokenRef = tokenReference(dependency.token);\n                var resolved = dependency.isAttribute ?\n                    R3ResolvedDependencyType.Attribute :\n                    R3ResolvedDependencyType.Token;\n                // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n                // however, it can be a string, in the case of older Angular code or @Attribute injection.\n                var token = tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : literal(tokenRef);\n                // Construct the dependency.\n                deps.push({\n                    token: token,\n                    attribute: null,\n                    resolved: resolved,\n                    host: !!dependency.isHost,\n                    optional: !!dependency.isOptional,\n                    self: !!dependency.isSelf,\n                    skipSelf: !!dependency.isSkipSelf,\n                });\n            }\n            else {\n                unsupported('dependency without a token');\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return deps;\n}\nfunction isDelegatedMetadata(meta) {\n    return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjectable(meta) {\n    var result = null;\n    var factoryMeta = {\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: [],\n        injectFn: Identifiers.inject,\n        target: R3FactoryTarget.Injectable,\n    };\n    if (meta.useClass !== undefined) {\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n        // used to instantiate the class with dependencies injected, or deps are not specified and\n        // the factory of the class is used to instantiate it.\n        //\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\n        // deps are specified, in which case 'useClass' is effectively ignored.\n        var useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);\n        var deps = undefined;\n        if (meta.userDeps !== undefined) {\n            deps = meta.userDeps;\n        }\n        if (deps !== undefined) {\n            // factory: () => new meta.useClass(...deps)\n            result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta), { delegate: meta.useClass, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));\n        }\n        else if (useClassOnSelf) {\n            result = compileFactoryFunction(factoryMeta);\n        }\n        else {\n            result = delegateToFactory(meta.type.value, meta.useClass);\n        }\n    }\n    else if (meta.useFactory !== undefined) {\n        if (meta.userDeps !== undefined) {\n            result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.userDeps || [], delegateType: R3FactoryDelegateType.Function }));\n        }\n        else {\n            result = {\n                statements: [],\n                factory: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n            };\n        }\n    }\n    else if (meta.useValue !== undefined) {\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n        // client code because meta.useValue is an Expression which will be defined even if the actual\n        // value is undefined.\n        result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta), { expression: meta.useValue }));\n    }\n    else if (meta.useExisting !== undefined) {\n        // useExisting is an `inject` call on the existing token.\n        result = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting]) }));\n    }\n    else {\n        result = delegateToFactory(meta.type.value, meta.internalType);\n    }\n    var token = meta.internalType;\n    var injectableProps = { token: token, factory: result.factory };\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn.value !== null) {\n        injectableProps.providedIn = meta.providedIn;\n    }\n    var expression = importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(injectableProps)]);\n    var type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n    return {\n        expression: expression,\n        type: type,\n        statements: result.statements,\n    };\n}\nfunction delegateToFactory(type, internalType) {\n    return {\n        statements: [],\n        // If types are the same, we can generate `factory: type.fac`\n        // If types are different, we have to generate a wrapper function to ensure\n        // the internal type has been resolved (`factory: function(t) { return type.fac(t); }`)\n        factory: type.node === internalType.node ?\n            internalType.prop('fac') :\n            fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(internalType.callMethod('fac', [variable('t')]))])\n    };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar UNUSABLE_INTERPOLATION_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (value != null) {\n        var start_1 = value[0];\n        var end_1 = value[1];\n        // Check for unusable interpolation symbols\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = /** @class */ (function () {\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = /** @class */ (function () {\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    // The content is `null` when the content is expected to be loaded using the URL\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        /**\n         * @internal strip this from published d.ts files due to\n         * https://github.com/microsoft/TypeScript/issues/36216\n         */\n        get: function () {\n            return this.lines.slice(-1)[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var sourcesIndex = new Map();\n        var sources = [];\n        var sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var mappings = '';\n        var lastCol0 = 0;\n        var lastSourceIndex = 0;\n        var lastSourceLine0 = 0;\n        var lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the sources list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\nfunction toBase64String(value) {\n    var b64 = '';\n    value = utf8Encode(value);\n    for (var i = 0; i < value.length;) {\n        var i1 = value.charCodeAt(i++);\n        var i2 = value.charCodeAt(i++);\n        var i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var out = '';\n    do {\n        var digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\nvar _EmittedLine = /** @class */ (function () {\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = /** @class */ (function () {\n    function EmitterVisitorContext(_indent) {\n        this._indent = _indent;\n        this._classes = [];\n        this._preambleLineCount = 0;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    EmitterVisitorContext.createRoot = function () {\n        return new EmitterVisitorContext(0);\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        /**\n         * @internal strip this from published d.ts files due to\n         * https://github.com/microsoft/TypeScript/issues/36216\n         */\n        get: function () {\n            return this._lines[this._lines.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from || null, lastPart, true);\n    };\n    EmitterVisitorContext.prototype.lineIsEmpty = function () {\n        return this._currentLine.parts.length === 0;\n    };\n    EmitterVisitorContext.prototype.lineLength = function () {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    };\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    };\n    EmitterVisitorContext.prototype.pushClass = function (clazz) {\n        this._classes.push(clazz);\n    };\n    EmitterVisitorContext.prototype.popClass = function () {\n        return this._classes.pop();\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var map = new SourceMapGenerator(genFilePath);\n        var firstOffsetMapped = false;\n        var mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var spans = line.srcSpans;\n            var parts = line.parts;\n            var col0 = line.indent * _INDENT_WITH.length;\n            var spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var span = spans[spanIdx];\n                var source = span.start.file;\n                var sourceLine = span.start.line;\n                var sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    EmitterVisitorContext.prototype.setPreambleLineCount = function (count) {\n        return this._preambleLineCount = count;\n    };\n    EmitterVisitorContext.prototype.spanOf = function (line, column) {\n        var emittedLine = this._lines[line - this._preambleLineCount];\n        if (emittedLine) {\n            var columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                var part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        /**\n         * @internal strip this from published d.ts files due to\n         * https://github.com/microsoft/TypeScript/issues/36216\n         */\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\nvar AbstractEmitterVisitor = /** @class */ (function () {\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        if (stmt.multiline) {\n            ctx.println(stmt, \"/* \" + stmt.comment + \" */\");\n        }\n        else {\n            stmt.comment.split('\\n').forEach(function (line) {\n                ctx.println(stmt, \"// \" + line);\n            });\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitJSDocCommentStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"/*\" + stmt.toString() + \"*/\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    };\n    AbstractEmitterVisitor.prototype.visitTypeofExpr = function (expr, ctx) {\n        ctx.print(expr, 'typeof ');\n        expr.expr.visitExpression(this, ctx);\n    };\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$1.name;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$1.name;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLocalizedString = function (ast, ctx) {\n        var head = ast.serializeI18nHead();\n        ctx.print(ast, '$localize `' + head.raw);\n        for (var i = 1; i < ast.messageParts.length; i++) {\n            ctx.print(ast, '${');\n            ast.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(ast, \"}\" + ast.serializeI18nTemplatePart(i).raw);\n        }\n        ctx.print(ast, '`');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.BitwiseAnd:\n                opStr = '&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        if (ast.parens)\n            ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, \")\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        ctx.print(ast, \"[\");\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        ctx.print(ast, \"{\");\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \":\");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator) {\n        var _this = this;\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator);\n    };\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator) {\n        var incrementedIndent = false;\n        for (var i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    };\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\nfunction _createIndent(count) {\n    var res = '';\n    for (var i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AbstractJsEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    AbstractJsEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    };\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name);\n        if (stmt.value) {\n            ctx.print(stmt, ' = ');\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.currentClass.parent.visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function\" + (ast.name ? ' ' + ast.name : '') + \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ])].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype.visitLocalizedString = function (ast, ctx) {\n        var _this = this;\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // $localize `...`\n        // ```\n        // which is effectively like:\n        // ```\n        // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        //\n        // The `$localize` function expects a \"template object\", which is an array of \"cooked\" strings\n        // plus a `raw` property that contains an array of \"raw\" strings.\n        //\n        // In some environments a helper function called `__makeTemplateObject(cooked, raw)` might be\n        // available, in which case we use that. Otherwise we must create our own helper function\n        // inline.\n        //\n        // In the inline function, if `Object.defineProperty` is available we use that to attach the\n        // `raw` array.\n        ctx.print(ast, '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})(');\n        var parts = [ast.serializeI18nHead()];\n        for (var i = 1; i < ast.messageParts.length; i++) {\n            parts.push(ast.serializeI18nTemplatePart(i));\n        }\n        ctx.print(ast, \"[\" + parts.map(function (part) { return escapeIdentifier(part.cooked, false); }).join(', ') + \"], \");\n        ctx.print(ast, \"[\" + parts.map(function (part) { return escapeIdentifier(part.raw, false); }).join(', ') + \"])\");\n        ast.expressions.forEach(function (expression) {\n            ctx.print(ast, ', ');\n            expression.visitExpression(_this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    };\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nvar JitEvaluator = /** @class */ (function () {\n    function JitEvaluator() {\n    }\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param reflector A helper used when converting the statements to executable code.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    JitEvaluator.prototype.evaluateStatements = function (sourceUrl, statements, reflector, createSourceMaps) {\n        var converter = new JitEmitterVisitor(reflector);\n        var ctx = EmitterVisitorContext.createRoot();\n        // Ensure generated code is in strict mode\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n            statements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n                literal('use strict').toStmt()\n            ], statements);\n        }\n        converter.visitAllStatements(statements, ctx);\n        converter.createReturnStmt(ctx);\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    };\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n    JitEvaluator.prototype.evaluateCode = function (sourceUrl, ctx, vars, createSourceMap) {\n        var fnBody = \"\\\"use strict\\\";\" + ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl;\n        var fnArgNames = [];\n        var fnArgValues = [];\n        for (var argName in vars) {\n            fnArgValues.push(vars[argName]);\n            fnArgNames.push(argName);\n        }\n        if (createSourceMap) {\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n            // E.g. ```\n            // function anonymous(a,b,c\n            // /**/) { ... }```\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\n            var emptyFn = new (Function.bind.apply(Function, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], fnArgNames.concat('return null;'))))().toString();\n            var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n            fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment();\n        }\n        var fn = new (Function.bind.apply(Function, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], fnArgNames.concat(fnBody))))();\n        return this.executeFunction(fn, fnArgValues);\n    };\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n    JitEvaluator.prototype.executeFunction = function (fn, args) {\n        return fn.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args));\n    };\n    return JitEvaluator;\n}());\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nvar JitEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(JitEmitterVisitor, _super);\n    function JitEmitterVisitor(reflector) {\n        var _this = _super.call(this) || this;\n        _this.reflector = reflector;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        _this._evalExportedVars = [];\n        return _this;\n    }\n    JitEmitterVisitor.prototype.createReturnStmt = function (ctx) {\n        var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) { return new LiteralMapEntry(resultVar, variable(resultVar), false); })));\n        stmt.visitStatement(this, ctx);\n    };\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var result = {};\n        for (var i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n        return null;\n    };\n    JitEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        this._emitReferenceToExternal(ast, ast.node, ctx);\n        return null;\n    };\n    JitEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareVarStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareFunctionStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return _super.prototype.visitDeclareClassStmt.call(this, stmt, ctx);\n    };\n    JitEmitterVisitor.prototype._emitReferenceToExternal = function (ast, value, ctx) {\n        var id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var name_1 = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(\"jit_\" + name_1 + \"_\" + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\nfunction isUseStrictStatement(statement) {\n    return statement.isEquivalent(literal('use strict').toStmt());\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nvar R3JitReflector = /** @class */ (function () {\n    function R3JitReflector(context) {\n        this.context = context;\n    }\n    R3JitReflector.prototype.resolveExternalReference = function (ref) {\n        // This reflector only handles @angular/core imports.\n        if (ref.moduleName !== '@angular/core') {\n            throw new Error(\"Cannot resolve external reference to \" + ref.moduleName + \", only references to @angular/core are supported.\");\n        }\n        if (!this.context.hasOwnProperty(ref.name)) {\n            throw new Error(\"No value provided for @angular/core symbol '\" + ref.name + \"'.\");\n        }\n        return this.context[ref.name];\n    };\n    R3JitReflector.prototype.parameters = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.annotations = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.shallowAnnotations = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.tryAnnotations = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.propMetadata = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.guards = function (typeOrFunc) {\n        throw new Error('Not implemented.');\n    };\n    R3JitReflector.prototype.componentModuleUrl = function (type, cmpMetadata) {\n        throw new Error('Not implemented.');\n    };\n    return R3JitReflector;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mapEntry(key, value) {\n    return { key: key, value: value, quoted: false };\n}\nfunction mapLiteral(obj, quoted) {\n    if (quoted === void 0) { quoted = false; }\n    return literalMap(Object.keys(obj).map(function (key) { return ({\n        key: key,\n        quoted: quoted,\n        value: obj[key],\n    }); }));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nfunction compileNgModule(meta) {\n    var internalType = meta.internalType, moduleType = meta.type, bootstrap = meta.bootstrap, declarations = meta.declarations, imports = meta.imports, exports = meta.exports, schemas = meta.schemas, containsForwardDecls = meta.containsForwardDecls, emitInline = meta.emitInline, id = meta.id;\n    var additionalStatements = [];\n    var definitionMap = { type: internalType };\n    // Only generate the keys in the metadata if the arrays have values.\n    if (bootstrap.length) {\n        definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n    }\n    // If requested to emit scope information inline, pass the declarations, imports and exports to\n    // the `defineNgModule` call. The JIT compilation uses this.\n    if (emitInline) {\n        if (declarations.length) {\n            definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n        }\n        if (imports.length) {\n            definitionMap.imports = refsToArray(imports, containsForwardDecls);\n        }\n        if (exports.length) {\n            definitionMap.exports = refsToArray(exports, containsForwardDecls);\n        }\n    }\n    // If not emitting inline, the scope information is not passed into `defineNgModule` as it would\n    // prevent tree-shaking of the declarations, imports and exports references.\n    else {\n        var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n        if (setNgModuleScopeCall !== null) {\n            additionalStatements.push(setNgModuleScopeCall);\n        }\n    }\n    if (schemas && schemas.length) {\n        definitionMap.schemas = literalArr(schemas.map(function (ref) { return ref.value; }));\n    }\n    if (id) {\n        definitionMap.id = id;\n    }\n    var expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression(definitionMap)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [\n        new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n        tupleTypeOf(exports)\n    ]));\n    return { expression: expression, type: type, additionalStatements: additionalStatements };\n}\n/**\n * Generates a function call to `setNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta) {\n    var moduleType = meta.adjacentType, declarations = meta.declarations, imports = meta.imports, exports = meta.exports, containsForwardDecls = meta.containsForwardDecls;\n    var scopeMap = {};\n    if (declarations.length) {\n        scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n    if (imports.length) {\n        scopeMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n    if (exports.length) {\n        scopeMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n    if (Object.keys(scopeMap).length === 0) {\n        return null;\n    }\n    // setNgModuleScope(...)\n    var fnCall = new InvokeFunctionExpr(\n    /* fn */ importExpr(Identifiers$1.setNgModuleScope), \n    /* args */ [moduleType, mapToMapExpression(scopeMap)]);\n    // (ngJitMode guard) && setNgModuleScope(...)\n    var guardedCall = jitOnlyGuardedExpression(fnCall);\n    // function() { (ngJitMode guard) && setNgModuleScope(...); }\n    var iife = new FunctionExpr(\n    /* params */ [], \n    /* statements */ [guardedCall.toStmt()]);\n    // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n    var iifeCall = new InvokeFunctionExpr(\n    /* fn */ iife, \n    /* args */ []);\n    return iifeCall.toStmt();\n}\nfunction compileInjector(meta) {\n    var result = compileFactoryFunction({\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: 0,\n        deps: meta.deps,\n        injectFn: Identifiers$1.inject,\n        target: R3FactoryTarget.NgModule,\n    });\n    var definitionMap = {\n        factory: result.factory,\n    };\n    if (meta.providers !== null) {\n        definitionMap.providers = meta.providers;\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.imports = literalArr(meta.imports);\n    }\n    var expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression(definitionMap)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type.type)]));\n    return { expression: expression, type: type, statements: result.statements };\n}\n// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\nfunction compileNgModuleFromRender2(ctx, ngModule, injectableCompiler) {\n    var className = identifierName(ngModule.type);\n    var rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n    var rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n    var injectorDefArg = mapLiteral({\n        'factory': injectableCompiler.factoryFor({ type: ngModule.type, symbol: ngModule.type.reference }, ctx),\n        'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n        'imports': convertMetaToOutput(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(rawImports, rawExports), ctx),\n    });\n    var injectorDef = importExpr(Identifiers$1.defineInjector).callFn([injectorDefArg]);\n    ctx.statements.push(new ClassStmt(\n    /* name */ className, \n    /* parent */ null, \n    /* fields */ [new ClassField(\n        /* name */ 'inj', \n        /* type */ INFERRED_TYPE, \n        /* modifiers */ [StmtModifier.Static], \n        /* initializer */ injectorDef)], \n    /* getters */ [], \n    /* constructorMethod */ new ClassMethod(null, [], []), \n    /* methods */ []));\n}\nfunction accessExportScope(module) {\n    var selectorScope = new ReadPropExpr(module, 'mod');\n    return new ReadPropExpr(selectorScope, 'exported');\n}\nfunction tupleTypeOf(exp) {\n    var types = exp.map(function (ref) { return typeofExpr(ref.type); });\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n    var values = literalArr(refs.map(function (ref) { return ref.value; }));\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compilePipeFromMetadata(metadata) {\n    var definitionMapValues = [];\n    // e.g. `name: 'myPipe'`\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\n    // e.g. `type: MyPipe`\n    definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });\n    // e.g. `pure: true`\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\n    var expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);\n    var type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [\n        typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\n    ]));\n    return { expression: expression, type: type };\n}\n/**\n * Write a pipe definition to the output context.\n */\nfunction compilePipeFromRender2(outputCtx, pipe, reflector) {\n    var name = identifierName(pipe.type);\n    if (!name) {\n        return error(\"Cannot resolve the name of \" + pipe.type);\n    }\n    var type = outputCtx.importExpr(pipe.type.reference);\n    var metadata = {\n        name: name,\n        type: wrapReference(type),\n        internalType: type,\n        pipeName: pipe.name,\n        typeArgumentCount: 0,\n        deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n        pure: pipe.pure,\n    };\n    var res = compilePipeFromMetadata(metadata);\n    var factoryRes = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, metadata), { injectFn: Identifiers$1.directiveInject, target: R3FactoryTarget.Pipe }));\n    var definitionField = outputCtx.constantPool.propertyNameOf(3 /* Pipe */);\n    var ngFactoryDefStatement = new ClassStmt(\n    /* name */ name, \n    /* parent */ null, \n    /* fields */\n    [new ClassField(\n        /* name */ 'fac', \n        /* type */ INFERRED_TYPE, \n        /* modifiers */ [StmtModifier.Static], \n        /* initializer */ factoryRes.factory)], \n    /* getters */ [], \n    /* constructorMethod */ new ClassMethod(null, [], []), \n    /* methods */ []);\n    var pipeDefStatement = new ClassStmt(\n    /* name */ name, \n    /* parent */ null, \n    /* fields */ [new ClassField(\n        /* name */ definitionField, \n        /* type */ INFERRED_TYPE, \n        /* modifiers */ [StmtModifier.Static], \n        /* initializer */ res.expression)], \n    /* getters */ [], \n    /* constructorMethod */ new ClassMethod(null, [], []), \n    /* methods */ []);\n    outputCtx.statements.push(ngFactoryDefStatement, pipeDefStatement);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = /** @class */ (function () {\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = /** @class */ (function () {\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    ParseSpan.prototype.toAbsolute = function (absoluteOffset) {\n        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    };\n    return ParseSpan;\n}());\nvar AST = /** @class */ (function () {\n    function AST(span, \n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    sourceSpan) {\n        this.span = span;\n        this.sourceSpan = sourceSpan;\n    }\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    AST.prototype.toString = function () {\n        return 'AST';\n    };\n    return AST;\n}());\nvar ASTWithName = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ASTWithName, _super);\n    function ASTWithName(span, sourceSpan, nameSpan) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.nameSpan = nameSpan;\n        return _this;\n    }\n    return ASTWithName;\n}(AST));\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Quote, _super);\n    function Quote(span, sourceSpan, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    Quote.prototype.toString = function () {\n        return 'Quote';\n    };\n    return Quote;\n}(AST));\nvar EmptyExpr = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Chain, _super);\n    function Chain(span, sourceSpan, expressions) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Conditional, _super);\n    function Conditional(span, sourceSpan, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PropertyRead, _super);\n    function PropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(ASTWithName));\nvar PropertyWrite = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PropertyWrite, _super);\n    function PropertyWrite(span, sourceSpan, nameSpan, receiver, name, value) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(ASTWithName));\nvar SafePropertyRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SafePropertyRead, _super);\n    function SafePropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(ASTWithName));\nvar KeyedRead = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(KeyedRead, _super);\n    function KeyedRead(span, sourceSpan, obj, key) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(KeyedWrite, _super);\n    function KeyedWrite(span, sourceSpan, obj, key, value) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BindingPipe, _super);\n    function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(ASTWithName));\nvar LiteralPrimitive = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralPrimitive, _super);\n    function LiteralPrimitive(span, sourceSpan, value) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralArray, _super);\n    function LiteralArray(span, sourceSpan, expressions) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralMap, _super);\n    function LiteralMap(span, sourceSpan, keys, values) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Interpolation, _super);\n    function Interpolation(span, sourceSpan, strings, expressions) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Binary, _super);\n    function Binary(span, sourceSpan, operation, left, right) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PrefixNot, _super);\n    function PrefixNot(span, sourceSpan, expression) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar NonNullAssert = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(NonNullAssert, _super);\n    function NonNullAssert(span, sourceSpan, expression) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    NonNullAssert.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitNonNullAssert(this, context);\n    };\n    return NonNullAssert;\n}(AST));\nvar MethodCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MethodCall, _super);\n    function MethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(ASTWithName));\nvar SafeMethodCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(SafeMethodCall, _super);\n    function SafeMethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n        var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(ASTWithName));\nvar FunctionCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FunctionCall, _super);\n    function FunctionCall(span, sourceSpan, target, args) {\n        var _this = _super.call(this, span, sourceSpan) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nvar AbsoluteSourceSpan = /** @class */ (function () {\n    function AbsoluteSourceSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return AbsoluteSourceSpan;\n}());\nvar ASTWithSource = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ASTWithSource, _super);\n    function ASTWithSource(ast, source, location, absoluteOffset, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        return _this;\n    }\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        if (visitor.visitASTWithSource) {\n            return visitor.visitASTWithSource(this, context);\n        }\n        return this.ast.visit(visitor, context);\n    };\n    ASTWithSource.prototype.toString = function () {\n        return this.source + \" in \" + this.location;\n    };\n    return ASTWithSource;\n}(AST));\nvar VariableBinding = /** @class */ (function () {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key name of the LHS along with its span.\n     * @param value optional value for the RHS along with its span.\n     */\n    function VariableBinding(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n    return VariableBinding;\n}());\nvar ExpressionBinding = /** @class */ (function () {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n     * span. Note that the length of the span may not be the same as\n     * `key.source.length`. For example,\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\n     * 2. key.source = ngForOf, key.span is for \"of\"\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n     * @param value optional expression for the RHS.\n     */\n    function ExpressionBinding(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n    return ExpressionBinding;\n}());\nvar RecursiveAstVisitor$1 = /** @class */ (function () {\n    function RecursiveAstVisitor() {\n    }\n    RecursiveAstVisitor.prototype.visit = function (ast, context) {\n        // The default implementation just visits every node.\n        // Classes that extend RecursiveAstVisitor should override this function\n        // to selectively visit the specified node.\n        ast.visit(this, context);\n    };\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        this.visit(ast.left, context);\n        this.visit(ast.right, context);\n    };\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) {\n        this.visitAll(ast.expressions, context);\n    };\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        this.visit(ast.condition, context);\n        this.visit(ast.trueExp, context);\n        this.visit(ast.falseExp, context);\n    };\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        this.visit(ast.exp, context);\n        this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        if (ast.target) {\n            this.visit(ast.target, context);\n        }\n        this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { };\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        this.visitAll(ast.expressions, context);\n    };\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        this.visit(ast.obj, context);\n        this.visit(ast.key, context);\n    };\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        this.visit(ast.obj, context);\n        this.visit(ast.key, context);\n        this.visit(ast.value, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        this.visitAll(ast.expressions, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) {\n        this.visitAll(ast.values, context);\n    };\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { };\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        this.visit(ast.expression, context);\n    };\n    RecursiveAstVisitor.prototype.visitNonNullAssert = function (ast, context) {\n        this.visit(ast.expression, context);\n    };\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        this.visit(ast.receiver, context);\n    };\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.value, context);\n    };\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        this.visit(ast.receiver, context);\n    };\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    };\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { };\n    // This is not part of the AstVisitor interface, just a helper method\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var e_1, _a;\n        try {\n            for (var asts_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(asts), asts_1_1 = asts_1.next(); !asts_1_1.done; asts_1_1 = asts_1.next()) {\n                var ast = asts_1_1.value;\n                this.visit(ast, context);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (asts_1_1 && !asts_1_1.done && (_a = asts_1.return)) _a.call(asts_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer$1 = /** @class */ (function () {\n    function AstTransformer() {\n    }\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) {\n        return ast;\n    };\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    };\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    };\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    };\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));\n    };\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    };\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    };\n    AstTransformer.prototype.visitNonNullAssert = function (ast, context) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    };\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    };\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));\n    };\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    AstTransformer.prototype.visitAll = function (asts) {\n        var res = [];\n        for (var i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    };\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nvar AstMemoryEfficientTransformer = /** @class */ (function () {\n    function AstMemoryEfficientTransformer() {\n    }\n    AstMemoryEfficientTransformer.prototype.visitImplicitReceiver = function (ast, context) {\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitInterpolation = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions)\n            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPropertyRead = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var value = ast.value.visit(this);\n        if (receiver !== ast.receiver || value !== ast.value) {\n            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitMethodCall = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        var receiver = ast.receiver.visit(this);\n        var args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitFunctionCall = function (ast, context) {\n        var target = ast.target && ast.target.visit(this);\n        var args = this.visitAll(ast.args);\n        if (target !== ast.target || args !== ast.args) {\n            return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralArray = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitLiteralMap = function (ast, context) {\n        var values = this.visitAll(ast.values);\n        if (values !== ast.values) {\n            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitBinary = function (ast, context) {\n        var left = ast.left.visit(this);\n        var right = ast.right.visit(this);\n        if (left !== ast.left || right !== ast.right) {\n            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPrefixNot = function (ast, context) {\n        var expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new PrefixNot(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitNonNullAssert = function (ast, context) {\n        var expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitConditional = function (ast, context) {\n        var condition = ast.condition.visit(this);\n        var trueExp = ast.trueExp.visit(this);\n        var falseExp = ast.falseExp.visit(this);\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitPipe = function (ast, context) {\n        var exp = ast.exp.visit(this);\n        var args = this.visitAll(ast.args);\n        if (exp !== ast.exp || args !== ast.args) {\n            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitKeyedRead = function (ast, context) {\n        var obj = ast.obj.visit(this);\n        var key = ast.key.visit(this);\n        if (obj !== ast.obj || key !== ast.key) {\n            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        var obj = ast.obj.visit(this);\n        var key = ast.key.visit(this);\n        var value = ast.value.visit(this);\n        if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitAll = function (asts) {\n        var res = [];\n        var modified = false;\n        for (var i = 0; i < asts.length; ++i) {\n            var original = asts[i];\n            var value = original.visit(this);\n            res[i] = value;\n            modified = modified || value !== original;\n        }\n        return modified ? res : asts;\n    };\n    AstMemoryEfficientTransformer.prototype.visitChain = function (ast, context) {\n        var expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new Chain(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    };\n    AstMemoryEfficientTransformer.prototype.visitQuote = function (ast, context) {\n        return ast;\n    };\n    return AstMemoryEfficientTransformer;\n}());\n// Bindings\nvar ParsedProperty = /** @class */ (function () {\n    function ParsedProperty(name, expression, type, sourceSpan, valueSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n    }\n    return ParsedProperty;\n}());\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nvar ParsedEvent = /** @class */ (function () {\n    // Regular events have a target\n    // Animation events have a phase\n    function ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.targetOrPhase = targetOrPhase;\n        this.type = type;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n    }\n    return ParsedEvent;\n}());\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nvar ParsedVariable = /** @class */ (function () {\n    function ParsedVariable(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    return ParsedVariable;\n}());\nvar BoundElementProperty = /** @class */ (function () {\n    function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, valueSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    return BoundElementProperty;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = /** @class */ (function () {\n    function EventHandlerVars() {\n    }\n    EventHandlerVars.event = variable('$event');\n    return EventHandlerVars;\n}());\nvar ConvertActionBindingResult = /** @class */ (function () {\n    function ConvertActionBindingResult(\n    /**\n     * Render2 compatible statements,\n     */\n    stmts, \n    /**\n     * Variable name used with render2 compatible statements.\n     */\n    allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n        /**\n         * This is bit of a hack. It converts statements which render2 expects to statements which are\n         * expected by render3.\n         *\n         * Example: `<div click=\"doSomething($event)\">` will generate:\n         *\n         * Render3:\n         * ```\n         * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n         * return pd_b;\n         * ```\n         *\n         * but render2 expects:\n         * ```\n         * return ctx.doSomething($event);\n         * ```\n         */\n        // TODO(misko): remove this hack once we no longer support ViewEngine.\n        this.render3Stmts = stmts.map(function (statement) {\n            if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&\n                statement.value instanceof BinaryOperatorExpr) {\n                var lhs = statement.value.lhs;\n                return new ReturnStatement(lhs.value);\n            }\n            return statement;\n        });\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (values) {\n                var entries = keys.map(function (k, i) { return ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }); });\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\n    var actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    var lastIndex = actionStmts.length - 1;\n    var preventDefaultVar = null;\n    if (lastIndex >= 0) {\n        var lastStatement = actionStmts[lastIndex];\n        var returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = /** @class */ (function () {\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\nvar BindingForm;\n(function (BindingForm) {\n    // The general form of binding expression, supports all expressions.\n    BindingForm[BindingForm[\"General\"] = 0] = \"General\";\n    // Try to generate a simple binding (no temporaries or statements)\n    // otherwise generate a general binding\n    BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\";\n})(BindingForm || (BindingForm = {}));\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var currValExpr = createCurrValueExpr(bindingId);\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n    var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    var stmts = getStatementsFromVisitor(visitor, bindingId);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n        return new ConvertPropertyBindingResult([], outputExpr);\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n    var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    var stmts = getStatementsFromVisitor(visitor, bindingId);\n    // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n    var args = outputExpr.args.slice(1);\n    if (expressionWithArgumentsToExtract instanceof Interpolation) {\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n        // args returned to just the value, because we're going to pass it to a special instruction.\n        var strings = expressionWithArgumentsToExtract.strings;\n        if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n            // Single argument interpolate instructions.\n            args = [args[1]];\n        }\n        else if (args.length >= 19) {\n            // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n            // an array of arguments\n            args = [literalArr(args)];\n        }\n    }\n    return { stmts: stmts, args: args };\n}\nfunction getStatementsFromVisitor(visitor, bindingId) {\n    var stmts = [];\n    for (var i = 0; i < visitor.temporaryCount; i++) {\n        stmts.push(temporaryDeclaration(bindingId, i));\n    }\n    return stmts;\n}\nfunction convertBuiltins(converterFactory, ast) {\n    var visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode;\n(function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_BuiltinAstConverter, _super);\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var args = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([ast.exp], ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer$1));\nvar _AstToIrVisitor = /** @class */ (function () {\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this.interpolationFunction = interpolationFunction;\n        this.baseSourceSpan = baseSourceSpan;\n        this.implicitReceiverAccesses = implicitReceiverAccesses;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n        this.usesImplicitReceiver = false;\n    }\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this._visit(ast.target, _Mode.Expression)\n                .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        this.usesImplicitReceiver = true;\n        return this._implicitReceiver;\n    };\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var args = [literal(ast.expressions.length)];\n        for (var i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        if (this.interpolationFunction) {\n            return this.interpolationFunction(args);\n        }\n        return ast.expressions.length <= 9 ?\n            importExpr(Identifiers.inlineInterpolate).callFn(args) :\n            importExpr(Identifiers.interpolate).callFn([\n                args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\n            ]);\n    };\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    };\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var obj = this._visit(ast.obj, _Mode.Expression);\n        var key = this._visit(ast.key, _Mode.Expression);\n        var value = this._visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        // For literal values of null, undefined, true, or false allow type interference\n        // to infer the type.\n        var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n            INFERRED_TYPE :\n            undefined;\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    };\n    _AstToIrVisitor.prototype._getLocal = function (name) {\n        return this._localResolver.getLocal(name);\n    };\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {\n            var args = this.visitAll(ast.args, _Mode.Expression);\n            if (args.length != 1) {\n                throw new Error(\"Invalid call to $any, expected 1 argument but received \" + (args.length || 'none'));\n            }\n            return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n        }\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var args = this.visitAll(ast.args, _Mode.Expression);\n            var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            var result = null;\n            var receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    result = varExpr.callFn(args);\n                }\n                this.addImplicitReceiverAccess(ast.name);\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitNonNullAssert = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var result = null;\n            var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            var receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n                if (result) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                }\n                this.addImplicitReceiverAccess(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        var varExpr = null;\n        if (receiver === this._implicitReceiver) {\n            var localExpr = this._getLocal(ast.name);\n            if (localExpr) {\n                if (localExpr instanceof ReadPropExpr) {\n                    // If the local variable is a property read expression, it's a reference\n                    // to a 'context.property' value and will be used as the target of the\n                    // write expression.\n                    varExpr = localExpr;\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n                else {\n                    // Otherwise it's an error.\n                    var receiver_1 = ast.name;\n                    var value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;\n                    throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to template variable \\\"\" + receiver_1 + \"\\\". Template variables are read-only.\");\n                }\n            }\n        }\n        // If no local expression could be produced, use the original receiver's\n        // property as the target.\n        if (varExpr === null) {\n            varExpr = receiver.prop(ast.name);\n        }\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    };\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this._visit(ast, mode); });\n    };\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n    _AstToIrVisitor.prototype._visit = function (ast, mode) {\n        var result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  .   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        var temporary = undefined;\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            visitBinary: function (ast) {\n                return null;\n            },\n            visitChain: function (ast) {\n                return null;\n            },\n            visitConditional: function (ast) {\n                return null;\n            },\n            visitFunctionCall: function (ast) {\n                return null;\n            },\n            visitImplicitReceiver: function (ast) {\n                return null;\n            },\n            visitInterpolation: function (ast) {\n                return null;\n            },\n            visitKeyedRead: function (ast) {\n                return visit(this, ast.obj);\n            },\n            visitKeyedWrite: function (ast) {\n                return null;\n            },\n            visitLiteralArray: function (ast) {\n                return null;\n            },\n            visitLiteralMap: function (ast) {\n                return null;\n            },\n            visitLiteralPrimitive: function (ast) {\n                return null;\n            },\n            visitMethodCall: function (ast) {\n                return visit(this, ast.receiver);\n            },\n            visitPipe: function (ast) {\n                return null;\n            },\n            visitPrefixNot: function (ast) {\n                return null;\n            },\n            visitNonNullAssert: function (ast) {\n                return null;\n            },\n            visitPropertyRead: function (ast) {\n                return visit(this, ast.receiver);\n            },\n            visitPropertyWrite: function (ast) {\n                return null;\n            },\n            visitQuote: function (ast) {\n                return null;\n            },\n            visitSafeMethodCall: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            visitBinary: function (ast) {\n                return visit(this, ast.left) || visit(this, ast.right);\n            },\n            visitChain: function (ast) {\n                return false;\n            },\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n            },\n            visitFunctionCall: function (ast) {\n                return true;\n            },\n            visitImplicitReceiver: function (ast) {\n                return false;\n            },\n            visitInterpolation: function (ast) {\n                return visitSome(this, ast.expressions);\n            },\n            visitKeyedRead: function (ast) {\n                return false;\n            },\n            visitKeyedWrite: function (ast) {\n                return false;\n            },\n            visitLiteralArray: function (ast) {\n                return true;\n            },\n            visitLiteralMap: function (ast) {\n                return true;\n            },\n            visitLiteralPrimitive: function (ast) {\n                return false;\n            },\n            visitMethodCall: function (ast) {\n                return true;\n            },\n            visitPipe: function (ast) {\n                return true;\n            },\n            visitPrefixNot: function (ast) {\n                return visit(this, ast.expression);\n            },\n            visitNonNullAssert: function (ast) {\n                return visit(this, ast.expression);\n            },\n            visitPropertyRead: function (ast) {\n                return false;\n            },\n            visitPropertyWrite: function (ast) {\n                return false;\n            },\n            visitQuote: function (ast) {\n                return false;\n            },\n            visitSafeMethodCall: function (ast) {\n                return true;\n            },\n            visitSafePropertyRead: function (ast) {\n                return false;\n            }\n        });\n    };\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n    _AstToIrVisitor.prototype.convertSourceSpan = function (span) {\n        if (this.baseSourceSpan) {\n            var start = this.baseSourceSpan.start.moveBy(span.start);\n            var end = this.baseSourceSpan.start.moveBy(span.end);\n            return new ParseSourceSpan(start, end);\n        }\n        else {\n            return null;\n        }\n    };\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n    _AstToIrVisitor.prototype.addImplicitReceiverAccess = function (name) {\n        if (this.implicitReceiverAccesses) {\n            this.implicitReceiverAccesses.add(name);\n        }\n    };\n    return _AstToIrVisitor;\n}());\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        arg.forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = /** @class */ (function () {\n    function DefaultLocalResolver() {\n    }\n    DefaultLocalResolver.prototype.notifyImplicitReceiverUse = function () { };\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(BuiltinFunctionCall, _super);\n    function BuiltinFunctionCall(span, sourceSpan, args, converter) {\n        var _this = _super.call(this, span, sourceSpan, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nvar ShadowCss = /** @class */ (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /*\n     * Shim some cssText with the given selector. Returns cssText that can\n     * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n     *\n     * When strictStyling is true:\n     * - selector is the attribute added to all elements inside the host,\n     * - hostSelector is the attribute added to the host itself.\n     */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([scopedCssText], commentsWithHash).join('\\n');\n    };\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n     **/\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n     **/\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n     */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n     **/\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var r = '';\n        var m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n     */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n     */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var parts = m[2].split(',');\n                var r = [];\n                for (var i = 0; i < parts.length; i++) {\n                    var p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n     */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    // change a selector like 'div' to 'name div'\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var selector = rule.selector;\n            var content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(deepParts), shallowPart = _a[0], otherParts = _a.slice(1);\n            var applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([applyScope(shallowPart)], otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var lre = /\\[/g;\n        var rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    // scope via name and [is=name]\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var attrName = '[' + scopeSelector + ']';\n        var _scopeSelectorPart = function (p) {\n            var scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var scopedSelector = '';\n        var startIndex = 0;\n        var res;\n        var sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        var shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            var separator = res[1];\n            var part_1 = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part_1.indexOf(_polyfillHostNoCombinator) > -1;\n            var scopedPart = shouldScope ? _scopeSelectorPart(part_1) : part_1;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        var part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = /** @class */ (function () {\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    SafeSelector.prototype.content = function () {\n        return this._content;\n    };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = /** @class */ (function () {\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\nfunction processRules(input, ruleCallback) {\n    var inputWithEscapedBlocks = escapeBlocks(input);\n    var nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var selector = m[2];\n        var content = '';\n        var suffix = m[4];\n        var contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = /** @class */ (function () {\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\nfunction escapeBlocks(input) {\n    var inputParts = input.split(_curlyRe);\n    var resultParts = [];\n    var escapedBlocks = [];\n    var bracketCount = 0;\n    var currentBlockParts = [];\n    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = /** @class */ (function () {\n    function StylesCompileDependency(name, moduleUrl, setValue) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.setValue = setValue;\n    }\n    return StylesCompileDependency;\n}());\nvar CompiledStylesheet = /** @class */ (function () {\n    function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n        this.outputCtx = outputCtx;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = /** @class */ (function () {\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    StyleCompiler.prototype.compileComponent = function (outputCtx, comp) {\n        var template = comp.template;\n        return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n            styles: template.styles,\n            styleUrls: template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), this.needsStyleShim(comp), true);\n    };\n    StyleCompiler.prototype.compileStyles = function (outputCtx, comp, stylesheet, shim) {\n        if (shim === void 0) { shim = this.needsStyleShim(comp); }\n        return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n    };\n    StyleCompiler.prototype.needsStyleShim = function (comp) {\n        return comp.template.encapsulation === ViewEncapsulation.Emulated;\n    };\n    StyleCompiler.prototype._compileStyles = function (outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\n        var _this = this;\n        var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var dependencies = [];\n        stylesheet.styleUrls.forEach(function (styleUrl) {\n            var exprIndex = styleExpressions.length;\n            // Note: This placeholder will be filled later.\n            styleExpressions.push(null);\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) { return styleExpressions[exprIndex] = outputCtx.importExpr(value); }));\n        });\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [\n            StmtModifier.Final, StmtModifier.Exported\n        ]);\n        outputCtx.statements.push(stmt);\n        return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    };\n    StyleCompiler.prototype._shimIfNeeded = function (style, shim) {\n        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n    };\n    return StyleCompiler;\n}());\nfunction getStylesVarName(component) {\n    var result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nvar AstPath = /** @class */ (function () {\n    function AstPath(path, position) {\n        if (position === void 0) { position = -1; }\n        this.path = path;\n        this.position = position;\n    }\n    Object.defineProperty(AstPath.prototype, \"empty\", {\n        get: function () {\n            return !this.path || !this.path.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"head\", {\n        get: function () {\n            return this.path[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"tail\", {\n        get: function () {\n            return this.path[this.path.length - 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AstPath.prototype.parentOf = function (node) {\n        return node && this.path[this.path.indexOf(node) - 1];\n    };\n    AstPath.prototype.childOf = function (node) {\n        return this.path[this.path.indexOf(node) + 1];\n    };\n    AstPath.prototype.first = function (ctor) {\n        for (var i = this.path.length - 1; i >= 0; i--) {\n            var item = this.path[i];\n            if (item instanceof ctor)\n                return item;\n        }\n    };\n    AstPath.prototype.push = function (node) {\n        this.path.push(node);\n    };\n    AstPath.prototype.pop = function () {\n        return this.path.pop();\n    };\n    return AstPath;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NodeWithI18n = /** @class */ (function () {\n    function NodeWithI18n(sourceSpan, i18n) {\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    return NodeWithI18n;\n}());\nvar Text$3 = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Text, _super);\n    function Text(value, sourceSpan, i18n) {\n        var _this = _super.call(this, sourceSpan, i18n) || this;\n        _this.value = value;\n        return _this;\n    }\n    Text.prototype.visit = function (visitor, context) {\n        return visitor.visitText(this, context);\n    };\n    return Text;\n}(NodeWithI18n));\nvar Expansion = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Expansion, _super);\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n        var _this = _super.call(this, sourceSpan, i18n) || this;\n        _this.switchValue = switchValue;\n        _this.type = type;\n        _this.cases = cases;\n        _this.switchValueSourceSpan = switchValueSourceSpan;\n        return _this;\n    }\n    Expansion.prototype.visit = function (visitor, context) {\n        return visitor.visitExpansion(this, context);\n    };\n    return Expansion;\n}(NodeWithI18n));\nvar ExpansionCase = /** @class */ (function () {\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    ExpansionCase.prototype.visit = function (visitor, context) {\n        return visitor.visitExpansionCase(this, context);\n    };\n    return ExpansionCase;\n}());\nvar Attribute = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Attribute, _super);\n    function Attribute(name, value, sourceSpan, valueSpan, i18n) {\n        var _this = _super.call(this, sourceSpan, i18n) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.valueSpan = valueSpan;\n        return _this;\n    }\n    Attribute.prototype.visit = function (visitor, context) {\n        return visitor.visitAttribute(this, context);\n    };\n    return Attribute;\n}(NodeWithI18n));\nvar Element$1 = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Element, _super);\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        if (startSourceSpan === void 0) { startSourceSpan = null; }\n        if (endSourceSpan === void 0) { endSourceSpan = null; }\n        var _this = _super.call(this, sourceSpan, i18n) || this;\n        _this.name = name;\n        _this.attrs = attrs;\n        _this.children = children;\n        _this.startSourceSpan = startSourceSpan;\n        _this.endSourceSpan = endSourceSpan;\n        return _this;\n    }\n    Element.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return Element;\n}(NodeWithI18n));\nvar Comment = /** @class */ (function () {\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    Comment.prototype.visit = function (visitor, context) {\n        return visitor.visitComment(this, context);\n    };\n    return Comment;\n}());\nfunction visitAll$1(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var result = [];\n    var visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nvar RecursiveVisitor$1 = /** @class */ (function () {\n    function RecursiveVisitor() {\n    }\n    RecursiveVisitor.prototype.visitElement = function (ast, context) {\n        this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    };\n    RecursiveVisitor.prototype.visitAttribute = function (ast, context) { };\n    RecursiveVisitor.prototype.visitText = function (ast, context) { };\n    RecursiveVisitor.prototype.visitComment = function (ast, context) { };\n    RecursiveVisitor.prototype.visitExpansion = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.cases);\n        });\n    };\n    RecursiveVisitor.prototype.visitExpansionCase = function (ast, context) { };\n    RecursiveVisitor.prototype.visitChildren = function (context, cb) {\n        var results = [];\n        var t = this;\n        function visit(children) {\n            if (children)\n                results.push(visitAll$1(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    };\n    return RecursiveVisitor;\n}());\nfunction spanOf(ast) {\n    var start = ast.sourceSpan.start.offset;\n    var end = ast.sourceSpan.end.offset;\n    if (ast instanceof Element$1) {\n        if (ast.endSourceSpan) {\n            end = ast.endSourceSpan.end.offset;\n        }\n        else if (ast.children && ast.children.length) {\n            end = spanOf(ast.children[ast.children.length - 1]).end;\n        }\n    }\n    return { start: start, end: end };\n}\nfunction findNode(nodes, position) {\n    var path = [];\n    var visitor = new /** @class */ (function (_super) {\n        Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(class_1, _super);\n        function class_1() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        class_1.prototype.visit = function (ast, context) {\n            var span = spanOf(ast);\n            if (span.start <= position && position < span.end) {\n                path.push(ast);\n            }\n            else {\n                // Returning a value here will result in the children being skipped.\n                return true;\n            }\n        };\n        return class_1;\n    }(RecursiveVisitor$1));\n    visitAll$1(visitor, nodes);\n    return new AstPath(path, position);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n    TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n    TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n    TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n    TokenType[TokenType[\"TEXT\"] = 4] = \"TEXT\";\n    TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 5] = \"ESCAPABLE_RAW_TEXT\";\n    TokenType[TokenType[\"RAW_TEXT\"] = 6] = \"RAW_TEXT\";\n    TokenType[TokenType[\"COMMENT_START\"] = 7] = \"COMMENT_START\";\n    TokenType[TokenType[\"COMMENT_END\"] = 8] = \"COMMENT_END\";\n    TokenType[TokenType[\"CDATA_START\"] = 9] = \"CDATA_START\";\n    TokenType[TokenType[\"CDATA_END\"] = 10] = \"CDATA_END\";\n    TokenType[TokenType[\"ATTR_NAME\"] = 11] = \"ATTR_NAME\";\n    TokenType[TokenType[\"ATTR_QUOTE\"] = 12] = \"ATTR_QUOTE\";\n    TokenType[TokenType[\"ATTR_VALUE\"] = 13] = \"ATTR_VALUE\";\n    TokenType[TokenType[\"DOC_TYPE\"] = 14] = \"DOC_TYPE\";\n    TokenType[TokenType[\"EXPANSION_FORM_START\"] = 15] = \"EXPANSION_FORM_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 16] = \"EXPANSION_CASE_VALUE\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 17] = \"EXPANSION_CASE_EXP_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 18] = \"EXPANSION_CASE_EXP_END\";\n    TokenType[TokenType[\"EXPANSION_FORM_END\"] = 19] = \"EXPANSION_FORM_END\";\n    TokenType[TokenType[\"EOF\"] = 20] = \"EOF\";\n})(TokenType || (TokenType = {}));\nvar Token = /** @class */ (function () {\n    function Token(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token;\n}());\nvar TokenError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TokenError, _super);\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = /** @class */ (function () {\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\nfunction tokenize(source, url, getTagDefinition, options) {\n    if (options === void 0) { options = {}; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options).tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = /** @class */ (function () {\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\n// See http://www.w3.org/TR/html51/syntax.html#writing\nvar _Tokenizer = /** @class */ (function () {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    function _Tokenizer(_file, _getTagDefinition, options) {\n        this._getTagDefinition = _getTagDefinition;\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        this._leadingTriviaCodePoints =\n            options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) { return c.codePointAt(0) || 0; });\n        var range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n            new PlainCharacterCursor(_file, range);\n        this._preserveLineEndings = options.preserveLineEndings || false;\n        try {\n            this._cursor.init();\n        }\n        catch (e) {\n            this.handleError(e);\n        }\n    }\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        if (this._preserveLineEndings) {\n            return content;\n        }\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._cursor.peek() !== $EOF) {\n            var start = this._cursor.clone();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                this.handleError(e);\n            }\n        }\n        this._beginToken(TokenType.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (this.isExpansionFormStart()) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._cursor.peek() === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._cursor.clone(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (this._currentTokenStart === null) {\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n        }\n        if (this._currentTokenType === null) {\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n        }\n        var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    };\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    };\n    _Tokenizer.prototype.handleError = function (e) {\n        if (e instanceof CursorError) {\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n        }\n        if (e instanceof _ControlFlowError) {\n            this.errors.push(e.error);\n        }\n        else {\n            throw e;\n        }\n    };\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._cursor.peek() === charCode) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    };\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    };\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var location = this._cursor.clone();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    };\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var len = chars.length;\n        if (this._cursor.charsLeft() < len) {\n            return false;\n        }\n        var initialPosition = this._cursor.clone();\n        for (var i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._cursor = initialPosition;\n                return false;\n            }\n        }\n        return true;\n    };\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var location = this._cursor.clone();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    };\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n    };\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var start = this._cursor.clone();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._cursor.diff(start) < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n    };\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._cursor.peek() !== char) {\n            this._cursor.advance();\n        }\n    };\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._cursor.peek() === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            // Don't rely upon reading directly from `_input` as the actual char value\n            // may have been generated from an escape sequence.\n            var char = String.fromCodePoint(this._cursor.peek());\n            this._cursor.advance();\n            return char;\n        }\n    };\n    _Tokenizer.prototype._decodeEntity = function () {\n        var start = this._cursor.clone();\n        this._cursor.advance();\n        if (this._attemptCharCode($HASH)) {\n            var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var codeStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan());\n            }\n            var strNum = this._cursor.getChars(codeStart);\n            this._cursor.advance();\n            try {\n                var charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (_a) {\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n        }\n        else {\n            var nameStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                this._cursor = nameStart;\n                return '&';\n            }\n            var name_1 = this._cursor.getChars(nameStart);\n            this._cursor.advance();\n            var char = NAMED_ENTITIES[name_1];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name_1), this._cursor.getSpan(start));\n            }\n            return char;\n        }\n    };\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, endMarkerPredicate) {\n        this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n        var parts = [];\n        while (true) {\n            var tagCloseStart = this._cursor.clone();\n            var foundEndMarker = endMarkerPredicate();\n            this._cursor = tagCloseStart;\n            if (foundEndMarker) {\n                break;\n            }\n            parts.push(this._readChar(decodeEntities));\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        this._consumeRawText(false, function () { return _this._attemptStr('-->'); });\n        this._beginToken(TokenType.COMMENT_END);\n        this._requireStr('-->');\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        this._consumeRawText(false, function () { return _this._attemptStr(']]>'); });\n        this._beginToken(TokenType.CDATA_END);\n        this._requireStr(']]>');\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType.DOC_TYPE, start);\n        var contentStart = this._cursor.clone();\n        this._attemptUntilChar($GT);\n        var content = this._cursor.getChars(contentStart);\n        this._cursor.advance();\n        this._endToken([content]);\n    };\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var nameOrPrefixStart = this._cursor.clone();\n        var prefix = '';\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n        var nameStart;\n        if (this._cursor.peek() === $COLON) {\n            prefix = this._cursor.getChars(nameOrPrefixStart);\n            this._cursor.advance();\n            nameStart = this._cursor.clone();\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n        var name = this._cursor.getChars(nameStart);\n        return [prefix, name];\n    };\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var tagName;\n        var prefix;\n        var openTagToken;\n        var tokensBeforeTagOpen = this.tokens.length;\n        var innerStart = this._cursor.clone();\n        try {\n            if (!isAsciiLetter(this._cursor.peek())) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n            }\n            openTagToken = this._consumeTagOpenStart(start);\n            prefix = openTagToken.parts[0];\n            tagName = openTagToken.parts[1];\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid (including invalid \"attributes\"), assume we want a \"<\"\n                this._cursor = innerStart;\n                if (openTagToken) {\n                    this.tokens.length = tokensBeforeTagOpen;\n                }\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\n        }\n    };\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (prefix, tagName, decodeEntities) {\n        var _this = this;\n        var textToken = this._consumeRawText(decodeEntities, function () {\n            if (!_this._attemptCharCode($LT))\n                return false;\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(tagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType.TAG_CLOSE);\n        this._requireCharCodeUntilFn(function (code) { return code === $GT; }, 3);\n        this._cursor.advance(); // Consume the `>`\n        this._endToken([prefix, tagName]);\n    };\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType.TAG_OPEN_START, start);\n        var parts = this._consumePrefixAndName();\n        return this._endToken(parts);\n    };\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        var attrNameStart = this._cursor.peek();\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n        }\n        this._beginToken(TokenType.ATTR_NAME);\n        var prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        var value;\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n            this._beginToken(TokenType.ATTR_QUOTE);\n            var quoteChar = this._cursor.peek();\n            this._cursor.advance();\n            this._endToken([String.fromCodePoint(quoteChar)]);\n            this._beginToken(TokenType.ATTR_VALUE);\n            var parts = [];\n            while (this._cursor.peek() !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._endToken([this._processCarriageReturns(value)]);\n            this._beginToken(TokenType.ATTR_QUOTE);\n            this._cursor.advance();\n            this._endToken([String.fromCodePoint(quoteChar)]);\n        }\n        else {\n            this._beginToken(TokenType.ATTR_VALUE);\n            var valueStart = this._cursor.clone();\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._cursor.getChars(valueStart);\n            this._endToken([this._processCarriageReturns(value)]);\n        }\n    };\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType.EXPANSION_FORM_START);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n        this._beginToken(TokenType.RAW_TEXT);\n        var condition = this._readUntil($COMMA);\n        this._endToken([condition]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.RAW_TEXT);\n        var type = this._readUntil($COMMA);\n        this._endToken([type]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n        var value = this._readUntil($LBRACE).trim();\n        this._endToken([value]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    };\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType.EXPANSION_FORM_END);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    _Tokenizer.prototype._consumeText = function () {\n        var start = this._cursor.clone();\n        this._beginToken(TokenType.TEXT, start);\n        var parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._cursor.peek() === $LT || this._cursor.peek() === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (this.isExpansionFormStart()) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    _Tokenizer.prototype._readUntil = function (char) {\n        var start = this._cursor.clone();\n        this._attemptUntilChar(char);\n        return this._cursor.getChars(start);\n    };\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_CASE_EXP_START;\n    };\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType.EXPANSION_FORM_START;\n    };\n    _Tokenizer.prototype.isExpansionFormStart = function () {\n        if (this._cursor.peek() !== $LBRACE) {\n            return false;\n        }\n        if (this._interpolationConfig) {\n            var start = this._cursor.clone();\n            var isInterpolation = this._attemptStr(this._interpolationConfig.start);\n            this._cursor = start;\n            return !isInterpolation;\n        }\n        return true;\n    };\n    return _Tokenizer;\n}());\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n    return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction mergeTextTokens(srcTokens) {\n    var dstTokens = [];\n    var lastDstToken = undefined;\n    for (var i = 0; i < srcTokens.length; i++) {\n        var token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\nvar PlainCharacterCursor = /** @class */ (function () {\n    function PlainCharacterCursor(fileOrCursor, range) {\n        if (fileOrCursor instanceof PlainCharacterCursor) {\n            this.file = fileOrCursor.file;\n            this.input = fileOrCursor.input;\n            this.end = fileOrCursor.end;\n            var state = fileOrCursor.state;\n            // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n            // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n            // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n            // called in tight loops, this difference matters.\n            this.state = {\n                peek: state.peek,\n                offset: state.offset,\n                line: state.line,\n                column: state.column,\n            };\n        }\n        else {\n            if (!range) {\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\n            }\n            this.file = fileOrCursor;\n            this.input = fileOrCursor.content;\n            this.end = range.endPos;\n            this.state = {\n                peek: -1,\n                offset: range.startPos,\n                line: range.startLine,\n                column: range.startCol,\n            };\n        }\n    }\n    PlainCharacterCursor.prototype.clone = function () {\n        return new PlainCharacterCursor(this);\n    };\n    PlainCharacterCursor.prototype.peek = function () {\n        return this.state.peek;\n    };\n    PlainCharacterCursor.prototype.charsLeft = function () {\n        return this.end - this.state.offset;\n    };\n    PlainCharacterCursor.prototype.diff = function (other) {\n        return this.state.offset - other.state.offset;\n    };\n    PlainCharacterCursor.prototype.advance = function () {\n        this.advanceState(this.state);\n    };\n    PlainCharacterCursor.prototype.init = function () {\n        this.updatePeek(this.state);\n    };\n    PlainCharacterCursor.prototype.getSpan = function (start, leadingTriviaCodePoints) {\n        start = start || this;\n        var cloned = false;\n        if (leadingTriviaCodePoints) {\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n                if (!cloned) {\n                    start = start.clone();\n                    cloned = true;\n                }\n                start.advance();\n            }\n        }\n        return new ParseSourceSpan(new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column), new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));\n    };\n    PlainCharacterCursor.prototype.getChars = function (start) {\n        return this.input.substring(start.state.offset, this.state.offset);\n    };\n    PlainCharacterCursor.prototype.charAt = function (pos) {\n        return this.input.charCodeAt(pos);\n    };\n    PlainCharacterCursor.prototype.advanceState = function (state) {\n        if (state.offset >= this.end) {\n            this.state = state;\n            throw new CursorError('Unexpected character \"EOF\"', this);\n        }\n        var currentChar = this.charAt(state.offset);\n        if (currentChar === $LF) {\n            state.line++;\n            state.column = 0;\n        }\n        else if (!isNewLine(currentChar)) {\n            state.column++;\n        }\n        state.offset++;\n        this.updatePeek(state);\n    };\n    PlainCharacterCursor.prototype.updatePeek = function (state) {\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    };\n    return PlainCharacterCursor;\n}());\nvar EscapedCharacterCursor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(EscapedCharacterCursor, _super);\n    function EscapedCharacterCursor(fileOrCursor, range) {\n        var _this = this;\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\n            _this = _super.call(this, fileOrCursor) || this;\n            _this.internalState = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, fileOrCursor.internalState);\n        }\n        else {\n            _this = _super.call(this, fileOrCursor, range) || this;\n            _this.internalState = _this.state;\n        }\n        return _this;\n    }\n    EscapedCharacterCursor.prototype.advance = function () {\n        this.state = this.internalState;\n        _super.prototype.advance.call(this);\n        this.processEscapeSequence();\n    };\n    EscapedCharacterCursor.prototype.init = function () {\n        _super.prototype.init.call(this);\n        this.processEscapeSequence();\n    };\n    EscapedCharacterCursor.prototype.clone = function () {\n        return new EscapedCharacterCursor(this);\n    };\n    EscapedCharacterCursor.prototype.getChars = function (start) {\n        var cursor = start.clone();\n        var chars = '';\n        while (cursor.internalState.offset < this.internalState.offset) {\n            chars += String.fromCodePoint(cursor.peek());\n            cursor.advance();\n        }\n        return chars;\n    };\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n    EscapedCharacterCursor.prototype.processEscapeSequence = function () {\n        var _this = this;\n        var peek = function () { return _this.internalState.peek; };\n        if (peek() === $BACKSLASH) {\n            // We have hit an escape sequence so we need the internal state to become independent\n            // of the external state.\n            this.internalState = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, this.state);\n            // Move past the backslash\n            this.advanceState(this.internalState);\n            // First check for standard control char sequences\n            if (peek() === $n) {\n                this.state.peek = $LF;\n            }\n            else if (peek() === $r) {\n                this.state.peek = $CR;\n            }\n            else if (peek() === $v) {\n                this.state.peek = $VTAB;\n            }\n            else if (peek() === $t) {\n                this.state.peek = $TAB;\n            }\n            else if (peek() === $b) {\n                this.state.peek = $BSPACE;\n            }\n            else if (peek() === $f) {\n                this.state.peek = $FF;\n            }\n            // Now consider more complex sequences\n            else if (peek() === $u) {\n                // Unicode code-point sequence\n                this.advanceState(this.internalState); // advance past the `u` char\n                if (peek() === $LBRACE) {\n                    // Variable length Unicode, e.g. `\\x{123}`\n                    this.advanceState(this.internalState); // advance past the `{` char\n                    // Advance past the variable number of hex digits until we hit a `}` char\n                    var digitStart = this.clone();\n                    var length_1 = 0;\n                    while (peek() !== $RBRACE) {\n                        this.advanceState(this.internalState);\n                        length_1++;\n                    }\n                    this.state.peek = this.decodeHexDigits(digitStart, length_1);\n                }\n                else {\n                    // Fixed length Unicode, e.g. `\\u1234`\n                    var digitStart = this.clone();\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\n                }\n            }\n            else if (peek() === $x) {\n                // Hex char code, e.g. `\\x2F`\n                this.advanceState(this.internalState); // advance past the `x` char\n                var digitStart = this.clone();\n                this.advanceState(this.internalState);\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\n            }\n            else if (isOctalDigit(peek())) {\n                // Octal char code, e.g. `\\012`,\n                var octal = '';\n                var length_2 = 0;\n                var previous = this.clone();\n                while (isOctalDigit(peek()) && length_2 < 3) {\n                    previous = this.clone();\n                    octal += String.fromCodePoint(peek());\n                    this.advanceState(this.internalState);\n                    length_2++;\n                }\n                this.state.peek = parseInt(octal, 8);\n                // Backup one char\n                this.internalState = previous.internalState;\n            }\n            else if (isNewLine(this.internalState.peek)) {\n                // Line continuation `\\` followed by a new line\n                this.advanceState(this.internalState); // advance over the newline\n                this.state = this.internalState;\n            }\n            else {\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\n                // In that case we just, effectively, skip the backslash from the character.\n                this.state.peek = this.internalState.peek;\n            }\n        }\n    };\n    EscapedCharacterCursor.prototype.decodeHexDigits = function (start, length) {\n        var hex = this.input.substr(start.internalState.offset, length);\n        var charCode = parseInt(hex, 16);\n        if (!isNaN(charCode)) {\n            return charCode;\n        }\n        else {\n            start.state = start.internalState;\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\n        }\n    };\n    return EscapedCharacterCursor;\n}(PlainCharacterCursor));\nvar CursorError = /** @class */ (function () {\n    function CursorError(msg, cursor) {\n        this.msg = msg;\n        this.cursor = cursor;\n    }\n    return CursorError;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TreeError, _super);\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = /** @class */ (function () {\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser = /** @class */ (function () {\n    function Parser(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    Parser.prototype.parse = function (source, url, options) {\n        var tokensAndErrors = tokenize(source, url, this.getTagDefinition, options);\n        var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));\n    };\n    return Parser;\n}());\nvar _TreeBuilder = /** @class */ (function () {\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType.EOF) {\n            if (this._peek.type === TokenType.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||\n                this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    _TreeBuilder.prototype._advance = function () {\n        var prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType.CDATA_END);\n    };\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var text = this._advanceIf(TokenType.RAW_TEXT);\n        this._advanceIf(TokenType.COMMENT_END);\n        var value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var switchValue = this._advance();\n        var type = this._advance();\n        var cases = [];\n        // read =\n        while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n            var expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var start = this._advance();\n        var exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var end = this._advance();\n        exp.push(new Token(TokenType.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(parsedExp.errors);\n            return null;\n        }\n        var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var exp = [];\n        var expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType.EXPANSION_FORM_START ||\n                this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var parent_1 = this._getParentElement();\n            if (parent_1 != null && parent_1.children.length == 0 &&\n                this.getTagDefinition(parent_1.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text$3(text, token.sourceSpan));\n        }\n    };\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        var el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    };\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var prefix = startTagToken.parts[0];\n        var name = startTagToken.parts[1];\n        var attrs = [];\n        while (this._peek.type === TokenType.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var end = this._peek.sourceSpan.start;\n        var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var el = new Element$1(fullName, attrs, [], span, span, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    _TreeBuilder.prototype._pushElement = function (el) {\n        var parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var end = attrName.sourceSpan.end;\n        var value = '';\n        var valueSpan = undefined;\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\n            this._advance();\n        }\n        if (this._peek.type === TokenType.ATTR_VALUE) {\n            var valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\n            var quoteToken = this._advance();\n            end = quoteToken.sourceSpan.end;\n        }\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var container = null;\n        for (var i = this._elementStack.length - 1; i >= 0; i--) {\n            if (!isNgContainer(this._elementStack[i].name)) {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: null, container: container };\n    };\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * @internal\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix === '') {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n            if (prefix === '' && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    HtmlParser.prototype.parse = function (source, url, options) {\n        return _super.prototype.parse.call(this, source, url, options);\n    };\n    return HtmlParser;\n}(Parser));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nvar SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nvar WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nvar NO_WS_REGEXP = new RegExp(\"[^\" + WS_CHARS + \"]\");\nvar WS_REPLACE_REGEXP = new RegExp(\"[\" + WS_CHARS + \"]{2,}\", 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some(function (attr) { return attr.name === PRESERVE_WS_ATTR_NAME; });\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nfunction replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nvar WhitespaceVisitor = /** @class */ (function () {\n    function WhitespaceVisitor() {\n    }\n    WhitespaceVisitor.prototype.visitElement = function (element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    };\n    WhitespaceVisitor.prototype.visitAttribute = function (attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    };\n    WhitespaceVisitor.prototype.visitText = function (text, context) {\n        var isNotBlank = text.value.match(NO_WS_REGEXP);\n        var hasExpansionSibling = context &&\n            (context.prev instanceof Expansion || context.next instanceof Expansion);\n        if (isNotBlank || hasExpansionSibling) {\n            return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\n        }\n        return null;\n    };\n    WhitespaceVisitor.prototype.visitComment = function (comment, context) {\n        return comment;\n    };\n    WhitespaceVisitor.prototype.visitExpansion = function (expansion, context) {\n        return expansion;\n    };\n    WhitespaceVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n        return expansionCase;\n    };\n    return WhitespaceVisitor;\n}());\nfunction removeWhitespaces(htmlAstWithErrors) {\n    return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n    var result = [];\n    nodes.forEach(function (ast, i) {\n        var context = { prev: nodes[i - 1], next: nodes[i + 1] };\n        var astResult = ast.visit(visitor, context);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n */\nfunction expandNodes(nodes) {\n    var expander = new _Expander();\n    return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = /** @class */ (function () {\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ExpansionError, _super);\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * @internal\n */\nvar _Expander = /** @class */ (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    _Expander.prototype.visitAttribute = function (attribute, context) {\n        return attribute;\n    };\n    _Expander.prototype.visitText = function (text, context) {\n        return text;\n    };\n    _Expander.prototype.visitComment = function (comment, context) {\n        return comment;\n    };\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n// Plural forms are expanded to `NgPlural` and `NgPluralCase`s\nfunction _expandPluralForm(ast, errors) {\n    var children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(', ')));\n        }\n        var expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expansionResult.errors));\n        return new Element$1(\"ng-template\", [new Attribute('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n// ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\nfunction _expandDefaultForm(ast, errors) {\n    var children = ast.cases.map(function (c) {\n        var expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expansionResult.errors));\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element$1(\"ng-template\", [new Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element$1(\"ng-template\", [new Attribute('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _a;\n/**\n * A segment of text within the template.\n */\nvar TextAst = /** @class */ (function () {\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    TextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitText(this, context);\n    };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = /** @class */ (function () {\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = /** @class */ (function () {\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    AttrAst.prototype.visit = function (visitor, context) {\n        return visitor.visitAttr(this, context);\n    };\n    return AttrAst;\n}());\nvar BoundPropertyMapping = (_a = {},\n    _a[4 /* Animation */] = 4 /* Animation */,\n    _a[1 /* Attribute */] = 1 /* Attribute */,\n    _a[2 /* Class */] = 2 /* Class */,\n    _a[0 /* Property */] = 0 /* Property */,\n    _a[3 /* Style */] = 3 /* Style */,\n    _a);\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = /** @class */ (function () {\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.isAnimation = this.type === 4 /* Animation */;\n    }\n    BoundElementPropertyAst.fromBoundProperty = function (prop) {\n        var type = BoundPropertyMapping[prop.type];\n        return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n    };\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = /** @class */ (function () {\n    function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n        this.isAnimation = !!this.phase;\n    }\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        return name;\n    };\n    BoundEventAst.fromParsedEvent = function (event) {\n        var target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\n        var phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\n        return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n    };\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = /** @class */ (function () {\n    function ReferenceAst(name, value, originalValue, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.originalValue = originalValue;\n        this.sourceSpan = sourceSpan;\n    }\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = /** @class */ (function () {\n    function VariableAst(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    VariableAst.fromParsedVariable = function (v) {\n        return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n    };\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = /** @class */ (function () {\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = /** @class */ (function () {\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = /** @class */ (function () {\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = /** @class */ (function () {\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = /** @class */ (function () {\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n        this.isModule = isModule;\n    }\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType;\n(function (ProviderAstType) {\n    ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n    ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n    ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n    ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n    ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n})(ProviderAstType || (ProviderAstType = {}));\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = /** @class */ (function () {\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nvar NullTemplateVisitor = /** @class */ (function () {\n    function NullTemplateVisitor() {\n    }\n    NullTemplateVisitor.prototype.visitNgContent = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitEmbeddedTemplate = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitElement = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitReference = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitVariable = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitEvent = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitElementProperty = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitAttr = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitBoundText = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitText = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitDirective = function (ast, context) { };\n    NullTemplateVisitor.prototype.visitDirectiveProperty = function (ast, context) { };\n    return NullTemplateVisitor;\n}());\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nvar RecursiveTemplateAstVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(RecursiveTemplateAstVisitor, _super);\n    function RecursiveTemplateAstVisitor() {\n        return _super.call(this) || this;\n    }\n    // Nodes with children\n    RecursiveTemplateAstVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.references);\n            visit(ast.variables);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitElement = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.attrs);\n            visit(ast.inputs);\n            visit(ast.outputs);\n            visit(ast.references);\n            visit(ast.directives);\n            visit(ast.providers);\n            visit(ast.children);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitDirective = function (ast, context) {\n        return this.visitChildren(context, function (visit) {\n            visit(ast.inputs);\n            visit(ast.hostProperties);\n            visit(ast.hostEvents);\n        });\n    };\n    RecursiveTemplateAstVisitor.prototype.visitChildren = function (context, cb) {\n        var results = [];\n        var t = this;\n        function visit(children) {\n            if (children && children.length)\n                results.push(templateVisitAll(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    };\n    return RecursiveTemplateAstVisitor;\n}(NullTemplateVisitor));\n/**\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var result = [];\n    var visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ProviderError, _super);\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = /** @class */ (function () {\n    function ProviderViewContext(reflector, component) {\n        var _this = this;\n        this.reflector = reflector;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = /** @class */ (function () {\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._queriedTokens = new Map();\n        this.transformedHasViewContainer = false;\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value ||\n                createTokenForExternalReference(_this.viewContext.reflector, Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n            this.transformedHasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        get: function () {\n            // Note: Maps keep their insertion order.\n            var lazyProviders = [];\n            var eagerProviders = [];\n            this._transformedProviders.forEach(function (provider) {\n                if (provider.eager) {\n                    eagerProviders.push(provider);\n                }\n                else {\n                    lazyProviders.push(provider);\n                }\n            });\n            return lazyProviders.concat(eagerProviders);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        get: function () {\n            var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        get: function () {\n            var allMatches = [];\n            this._queriedTokens.forEach(function (matches) {\n                allMatches.push.apply(allMatches, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(matches));\n            });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var queryValue = query.meta.read || defaultValue;\n            var tokenRef = tokenReference(queryValue);\n            var queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var result = [];\n        var currentEl = this;\n        var distance = 0;\n        var queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(queries.filter(function (query) { return query.meta.descendants || distance <= 1; })));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(queries));\n        }\n        return result;\n    };\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider ||\n            ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var transformedUseValue = provider.useValue;\n            var transformedUseExisting = provider.useExisting;\n            var transformedDeps = undefined;\n            if (provider.useExisting != null) {\n                var existingDiDep = _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            else if (provider.useClass) {\n                var deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        if (dep.isAttribute) {\n            var attrValue = this._attrs[dep.token.value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) ===\n                        this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) ===\n                    this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                    this.transformedHasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = false; }\n        var currElement = this;\n        var currEager = eager;\n        var result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(dep.token) ||\n                    this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = /** @class */ (function () {\n    function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this.reflector = reflector;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders, /* isModule */ true);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders, \n        /* isModule */ false);\n    }\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        // Note: Maps keep their insertion order.\n        var lazyProviders = [];\n        var eagerProviders = [];\n        this._transformedProviders.forEach(function (provider) {\n            if (provider.eager) {\n                eagerProviders.push(provider);\n            }\n            else {\n                lazyProviders.push(provider);\n            }\n        });\n        return lazyProviders.concat(eagerProviders);\n    };\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var transformedUseValue = provider.useValue;\n            var transformedUseExisting = provider.useExisting;\n            var transformedDeps = undefined;\n            if (provider.useExisting != null) {\n                var existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = false; }\n        var foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) ===\n                this.reflector.resolveExternalReference(Identifiers.Injector) ||\n                tokenReference(dep.token) ===\n                    this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n                // access providers\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        return dep;\n    };\n    return NgModuleProviderAnalyzer;\n}());\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n    });\n    return providersByToken;\n}\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\n    providers.forEach(function (provider) {\n        var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var lifecycleHooks = provider.token.identifier &&\n                provider.token.identifier.lifecycleHooks ?\n                provider.token.identifier.lifecycleHooks :\n                [];\n            var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var viewQueryId = 1;\n    var viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var contentQueryId = contentQueryStartId;\n    var contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = /** @class */ (function () {\n    function StyleWithImports(style, styleUrls) {\n        this.style = style;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the @import urls that\n * are either relative or don't have a `package:` scheme\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var foundUrls = [];\n    var modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\n        .replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI\n            // scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = /** @class */ (function () {\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this.errors = errors;\n        this.pipesByName = null;\n        this._usedPipes = new Map();\n        // When the `pipes` parameter is `null`, do not check for used pipes\n        // This is used in IVY when we might not know the available pipes at compile time\n        if (pipes) {\n            var pipesByName_1 = new Map();\n            pipes.forEach(function (pipe) { return pipesByName_1.set(pipe.name, pipe); });\n            this.pipesByName = pipesByName_1;\n        }\n    }\n    Object.defineProperty(BindingParser.prototype, \"interpolationConfig\", {\n        get: function () {\n            return this._interpolationConfig;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BindingParser.prototype.getUsedPipes = function () {\n        return Array.from(this._usedPipes.values());\n    };\n    BindingParser.prototype.createBoundHostProperties = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1;\n        }\n        return null;\n    };\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n        return boundProps &&\n            boundProps.map(function (prop) { return _this.createBoundElementProperty(elementSelector, prop); });\n    };\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var targetEvents_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    // TODO: pass a more accurate handlerSpan for this event.\n                    _this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEvents_1;\n        }\n        return null;\n    };\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var sourceInfo = sourceSpan.start.toString();\n        try {\n            var ast = this._exprParser.parseInterpolation(value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);\n        }\n    };\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n    BindingParser.prototype.parseInlineTemplateBinding = function (tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars) {\n        var e_1, _a;\n        var absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n        var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n        try {\n            for (var bindings_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(bindings), bindings_1_1 = bindings_1.next(); !bindings_1_1.done; bindings_1_1 = bindings_1.next()) {\n                var binding = bindings_1_1.value;\n                // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n                // binding within the microsyntax expression so it's more narrow than sourceSpan.\n                var bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n                var key = binding.key.source;\n                var keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n                if (binding instanceof VariableBinding) {\n                    var value = binding.value ? binding.value.source : '$implicit';\n                    var valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n                    targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n                }\n                else if (binding.value) {\n                    var valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n                    this._parsePropertyAst(key, binding.value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n                }\n                else {\n                    targetMatchableAttrs.push([key, '']);\n                    this.parseLiteralAttr(key, null, sourceSpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (bindings_1_1 && !bindings_1_1.done && (_a = bindings_1.return)) _a.call(bindings_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n    BindingParser.prototype._parseTemplateBindings = function (tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n        var _this = this;\n        var sourceInfo = sourceSpan.start.toString();\n        try {\n            var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.value instanceof ASTWithSource) {\n                    _this._checkPipes(binding.value, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) {\n                _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n            });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        if (isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));\n        }\n    };\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        if (name.length === 0) {\n            this._reportError(\"Property name is missing in binding\", sourceSpan);\n        }\n        var isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n        var expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));\n    };\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n        if (name.length === 0) {\n            this._reportError('Animation trigger is missing', sourceSpan);\n        }\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));\n    };\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan, absoluteOffset) {\n        var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n        try {\n            var ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    };\n    BindingParser.prototype.createBoundElementProperty = function (elementSelector, boundProp, skipValidation, mapPropertyName) {\n        if (skipValidation === void 0) { skipValidation = false; }\n        if (mapPropertyName === void 0) { mapPropertyName = true; }\n        if (boundProp.isAnimation) {\n            return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.valueSpan);\n        }\n        var unit = null;\n        var bindingType = undefined;\n        var boundPropertyName = null;\n        var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var securityContexts = undefined;\n        // Check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n                if (!skipValidation) {\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                }\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name_1);\n                }\n                bindingType = 1 /* Attribute */;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = 2 /* Class */;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = 3 /* Style */;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n            bindingType = 0 /* Property */;\n            if (!skipValidation) {\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n            }\n        }\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.valueSpan);\n    };\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n        if (name.length === 0) {\n            this._reportError(\"Event name is missing in binding\", sourceSpan);\n        }\n        if (isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);\n        }\n        else {\n            this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    BindingParser.prototype.calcPossibleSecurityContexts = function (selector, propName, isAttribute) {\n        var prop = this._schemaRegistry.getMappedPropName(propName);\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    };\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, handlerSpan, targetEvents) {\n        var matches = splitAtPeriod(name, [name, '']);\n        var eventName = matches[0];\n        var phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var ast = this._parseAction(expression, handlerSpan);\n                    targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    BindingParser.prototype._parseRegularEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitAtColon(name, [null, name]), 2), target = _a[0], eventName = _a[1];\n        var ast = this._parseAction(expression, handlerSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n        var absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n        try {\n            var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    };\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    };\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        var e_2, _a;\n        try {\n            for (var errors_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {\n                var error = errors_1_1.value;\n                this._reportError(error.message, sourceSpan);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    // Make sure all the used pipes are known in `this.pipesByName`\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast && this.pipesByName) {\n            var collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor$1));\nfunction isAnimationLabel(name) {\n    return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); })));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n    // The difference of two absolute offsets provide the relative offset\n    var startDiff = absoluteSpan.start - sourceSpan.start.offset;\n    var endDiff = absoluteSpan.end - sourceSpan.end.offset;\n    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n    var selectAttr = null;\n    var hrefAttr = null;\n    var relAttr = null;\n    var nonBindable = false;\n    var projectAs = '';\n    ast.attrs.forEach(function (attr) {\n        var lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var nodeName = ast.name.toLowerCase();\n    var type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nvar PreparsedElement = /** @class */ (function () {\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\nvar TEMPLATE_ATTR_PREFIX$1 = '*';\nvar CLASS_ATTR = 'class';\nvar _TEXT_CSS_SELECTOR;\nfunction TEXT_CSS_SELECTOR() {\n    if (!_TEXT_CSS_SELECTOR) {\n        _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n    }\n    return _TEXT_CSS_SELECTOR;\n}\nvar TemplateParseError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TemplateParseError, _super);\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = /** @class */ (function () {\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = /** @class */ (function () {\n    function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._reflector = _reflector;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    Object.defineProperty(TemplateParser.prototype, \"expressionParser\", {\n        get: function () {\n            return this._exprParser;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n        var warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; });\n        var errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n        }\n        return { template: result.templateAst, pipes: result.usedPipes };\n    };\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n        var htmlParseResult = typeof template === 'string' ?\n            this._htmlParser.parse(template, templateUrl, {\n                tokenizeExpansionForms: true,\n                interpolationConfig: this.getInterpolationConfig(component)\n            }) :\n            template;\n        if (!preserveWhitespaces) {\n            htmlParseResult = removeWhitespaces(htmlParseResult);\n        }\n        return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    };\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n        var result;\n        var errors = htmlAstWithErrors.errors;\n        var usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var uniqDirectives = removeSummaryDuplicates(directives);\n            var uniqPipes = removeSummaryDuplicates(pipes);\n            var providerViewContext = new ProviderViewContext(this._reflector, component);\n            var interpolationConfig = undefined;\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n            var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(providerViewContext.errors));\n            usedPipes.push.apply(usedPipes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingParser.getUsedPipes()));\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) {\n                result = templateVisitAll(transform, result);\n            });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(expandedHtmlAst.errors));\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n        return undefined;\n    };\n    /** @internal */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var existingReferences = [];\n        result.filter(function (element) { return !!element.references; })\n            .forEach(function (element) { return element.references.forEach(function (reference) {\n            var name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nvar TemplateParseVisitor = /** @class */ (function () {\n    function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.reflector = reflector;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) {\n        return null;\n    };\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n        return null;\n    };\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n        var valueNoNgsp = replaceNgsp(text.value);\n        var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n        return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n            new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n    };\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) {\n        return null;\n    };\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var queryStartIndex = this.contentQueryStartId;\n        var elName = element.name;\n        var preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var matchableAttrs = [];\n        var elementOrDirectiveProps = [];\n        var elementOrDirectiveRefs = [];\n        var elementVars = [];\n        var events = [];\n        var templateElementOrDirectiveProps = [];\n        var templateMatchableAttrs = [];\n        var templateElementVars = [];\n        var hasInlineTemplates = false;\n        var attrs = [];\n        var isTemplateElement = isNgTemplate(element.name);\n        element.attrs.forEach(function (attr) {\n            var parsedVariables = [];\n            var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            elementVars.push.apply(elementVars, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables.map(function (v) { return VariableAst.fromParsedVariable(v); })));\n            var templateValue;\n            var templateKey;\n            var normalizedName = _this._normalizeAttributeName(attr.name);\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {\n                templateValue = attr.value;\n                templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);\n            }\n            var hasTemplateBinding = templateValue != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                var parsedVariables_1 = [];\n                var absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n                _this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables_1);\n                templateElementVars.push.apply(templateElementVars, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables_1.map(function (v) { return VariableAst.fromParsedVariable(v); })));\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var references = [];\n        var boundDirectivePropNames = new Set();\n        var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n        var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n        var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var projectionSelector = preparsedElement.projectAs != '' ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n        var parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>` element\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>` element\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else {\n            // element other than `<ng-content>` and `<ng-template>`\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n            var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);\n        }\n        if (hasInlineTemplates) {\n            // The element as a *-attribute\n            var templateQueryStartIndex = this.contentQueryStartId;\n            var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n            var directives = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var templateBoundDirectivePropNames = new Set();\n            var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n            var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n            var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n        }\n        return parsedElement;\n    };\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var name = this._normalizeAttributeName(attr.name);\n        var value = attr.value;\n        var srcSpan = attr.sourceSpan;\n        var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n        var boundEvents = [];\n        var bindParts = name.match(BIND_NAME_REGEXP);\n        var hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        }\n        targetEvents.push.apply(targetEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(boundEvents.map(function (e) { return BoundEventAst.fromParsedEvent(e); })));\n        return hasBinding;\n    };\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this._reportError(\"Variable does not have a name\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this._reportError(\"Reference does not have a name\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\n    };\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var directives = newArray(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[_this.directivesIndex.get(directive)] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var matchedReferences = new Set();\n        var component = null;\n        var directiveAsts = directives.map(function (directive) {\n            var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var directiveProperties = [];\n            var boundProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n            var hostProperties = boundProperties.map(function (prop) { return BoundElementPropertyAst.fromBoundProperty(prop); });\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var parsedEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (elOrDirRef.isReferenceToDirective(directive))) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var hostEvents = parsedEvents.map(function (e) { return BoundEventAst.fromParsedEvent(e); });\n            var contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var refToken = null;\n                if (isTemplateElement) {\n                    refToken = createTokenForExternalReference(_this.reflector, Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var elProp = directiveProperties[dirProp];\n                var boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                var boundProp = _this._bindingParser.createBoundElementProperty(elementName, prop);\n                boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return identifierName(directive.directive.type); });\n    };\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param matchElement Whether any directive has matched on the tag name\n     * @param element the html element\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg += \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg += \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, element.sourceSpan);\n        }\n    };\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event\n                    .fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === 0 /* Property */ &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp\n                            .name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = /** @class */ (function () {\n    function NonBindableVisitor() {\n    }\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var ngContentIndex = parent.findNgContentIndex(selector);\n        var children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    NonBindableVisitor.prototype.visitComment = function (comment, context) {\n        return null;\n    };\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n        return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) {\n        return expansion;\n    };\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n        return expansionCase;\n    };\n    return NonBindableVisitor;\n}());\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\nvar ElementOrDirectiveRef = /** @class */ (function () {\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /** Gets whether this is a reference to the given directive. */\n    ElementOrDirectiveRef.prototype.isReferenceToDirective = function (directive) {\n        return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    };\n    return ElementOrDirectiveRef;\n}());\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\nfunction splitExportAs(exportAs) {\n    return exportAs ? exportAs.split(',').map(function (e) { return e.trim(); }) : [];\n}\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = /** @class */ (function () {\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var matcher = new SelectorMatcher();\n        var wildcardNgContentIndex = null;\n        var component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var ngContentSelectors = component.directive.template.ngContentSelectors;\n            for (var i = 0; i < ngContentSelectors.length; i++) {\n                var selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {\n            ngContentIndices.push(ngContentIndex);\n        });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\nfunction createElementCssSelector(elementName, attributes) {\n    var cssSelector = new CssSelector();\n    var elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var i = 0; i < attributes.length; i++) {\n        var attrName = attributes[i][0];\n        var attrNameNoNs = splitNsName(attrName)[1];\n        var attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text$3 && node.value.trim().length == 0;\n}\nfunction removeSummaryDuplicates(items) {\n    var map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nfunction parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // constructed in a [key, value, key, value] format.\n    var styles = [];\n    var i = 0;\n    var parenDepth = 0;\n    var quote = 0 /* QuoteNone */;\n    var valueStart = 0;\n    var propStart = 0;\n    var currentProp = null;\n    var valueHasQuotes = false;\n    while (i < value.length) {\n        var token = value.charCodeAt(i++);\n        switch (token) {\n            case 40 /* OpenParen */:\n                parenDepth++;\n                break;\n            case 41 /* CloseParen */:\n                parenDepth--;\n                break;\n            case 39 /* QuoteSingle */:\n                // valueStart needs to be there since prop values don't\n                // have quotes in CSS\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 39 /* QuoteSingle */;\n                }\n                else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 34 /* QuoteDouble */:\n                // same logic as above\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 34 /* QuoteDouble */;\n                }\n                else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 58 /* Colon */:\n                if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n                    valueStart = i;\n                }\n                break;\n            case 59 /* Semicolon */:\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    var styleVal = value.substring(valueStart, i - 1).trim();\n                    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n                    propStart = i;\n                    valueStart = 0;\n                    currentProp = null;\n                    valueHasQuotes = false;\n                }\n                break;\n        }\n    }\n    if (currentProp && valueStart) {\n        var styleVal = value.substr(valueStart).trim();\n        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n    }\n    return styles;\n}\nfunction stripUnnecessaryQuotes(value) {\n    var qS = value.charCodeAt(0);\n    var qE = value.charCodeAt(value.length - 1);\n    if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {\n        var tempValue = value.substring(1, value.length - 1);\n        // special case to avoid using a multi-quoted string that was just chomped\n        // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n        if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n            value = tempValue;\n        }\n    }\n    return value;\n}\nfunction hyphenate(value) {\n    return value\n        .replace(/[a-z][A-Z]/g, function (v) {\n        return v.charAt(0) + '-' + v.charAt(1);\n    })\n        .toLowerCase();\n}\n\nvar IMPORTANT_FLAG = '!important';\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nvar MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nvar StylingBuilder = /** @class */ (function () {\n    function StylingBuilder(_directiveExpr) {\n        this._directiveExpr = _directiveExpr;\n        /** Whether or not there are any static styling values present */\n        this._hasInitialValues = false;\n        /**\n         *  Whether or not there are any styling bindings present\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n         */\n        this.hasBindings = false;\n        this.hasBindingsWithPipes = false;\n        /** the input for [class] (if it exists) */\n        this._classMapInput = null;\n        /** the input for [style] (if it exists) */\n        this._styleMapInput = null;\n        /** an array of each [style.prop] input */\n        this._singleStyleInputs = null;\n        /** an array of each [class.name] input */\n        this._singleClassInputs = null;\n        this._lastStylingInput = null;\n        this._firstStylingInput = null;\n        // maps are used instead of hash maps because a Map will\n        // retain the ordering of the keys\n        /**\n         * Represents the location of each style binding in the template\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n         * that `width=0` and `height=1`)\n         */\n        this._stylesIndex = new Map();\n        /**\n         * Represents the location of each class binding in the template\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n         * that `big=0` and `hidden=1`)\n         */\n        this._classesIndex = new Map();\n        this._initialStyleValues = [];\n        this._initialClassValues = [];\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n    StylingBuilder.prototype.registerBoundInput = function (input) {\n        // [attr.style] or [attr.class] are skipped in the code below,\n        // they should not be treated as styling-based bindings since\n        // they are intended to be written directly to the attr and\n        // will therefore skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        var binding = null;\n        var name = input.name;\n        switch (input.type) {\n            case 0 /* Property */:\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n                break;\n            case 3 /* Style */:\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n                break;\n            case 2 /* Class */:\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n                break;\n        }\n        return binding ? true : false;\n    };\n    StylingBuilder.prototype.registerInputBasedOnName = function (name, expression, sourceSpan) {\n        var binding = null;\n        var prefix = name.substring(0, 6);\n        var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n        var isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n        if (isStyle || isClass) {\n            var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n            var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n            if (isStyle) {\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n            }\n            else {\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n            }\n        }\n        return binding;\n    };\n    StylingBuilder.prototype.registerStyleInput = function (name, isMapBased, value, sourceSpan, unit) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        name = normalizePropName(name);\n        var _a = parseProperty(name), property = _a.property, hasOverrideFlag = _a.hasOverrideFlag, bindingUnit = _a.unit;\n        var entry = {\n            name: property,\n            sanitize: property ? isStyleSanitizable(property) : true,\n            unit: unit || bindingUnit,\n            value: value,\n            sourceSpan: sourceSpan,\n            hasOverrideFlag: hasOverrideFlag\n        };\n        if (isMapBased) {\n            this._styleMapInput = entry;\n        }\n        else {\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n            registerIntoMap(this._stylesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    };\n    StylingBuilder.prototype.registerClassInput = function (name, isMapBased, value, sourceSpan) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        var _a = parseProperty(name), property = _a.property, hasOverrideFlag = _a.hasOverrideFlag;\n        var entry = { name: property, value: value, sourceSpan: sourceSpan, sanitize: false, hasOverrideFlag: hasOverrideFlag, unit: null };\n        if (isMapBased) {\n            if (this._classMapInput) {\n                throw new Error('[class] and [className] bindings cannot be used on the same element simultaneously');\n            }\n            this._classMapInput = entry;\n        }\n        else {\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n            registerIntoMap(this._classesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    };\n    StylingBuilder.prototype._checkForPipes = function (value) {\n        if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n            this.hasBindingsWithPipes = true;\n        }\n    };\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n    StylingBuilder.prototype.registerStyleAttr = function (value) {\n        this._initialStyleValues = parse(value);\n        this._hasInitialValues = true;\n    };\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n    StylingBuilder.prototype.registerClassAttr = function (value) {\n        this._initialClassValues = value.trim().split(/\\s+/g);\n        this._hasInitialValues = true;\n    };\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n    StylingBuilder.prototype.populateInitialStylingAttrs = function (attrs) {\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n        if (this._initialClassValues.length) {\n            attrs.push(literal(1 /* Classes */));\n            for (var i = 0; i < this._initialClassValues.length; i++) {\n                attrs.push(literal(this._initialClassValues[i]));\n            }\n        }\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n        if (this._initialStyleValues.length) {\n            attrs.push(literal(2 /* Styles */));\n            for (var i = 0; i < this._initialStyleValues.length; i += 2) {\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\n            }\n        }\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n    StylingBuilder.prototype.assignHostAttrs = function (attrs, definitionMap) {\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n            this.populateInitialStylingAttrs(attrs);\n            definitionMap.set('hostAttrs', literalArr(attrs));\n        }\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n    StylingBuilder.prototype.buildClassMapInstruction = function (valueConverter) {\n        if (this._classMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n        }\n        return null;\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n    StylingBuilder.prototype.buildStyleMapInstruction = function (valueConverter) {\n        if (this._styleMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n        }\n        return null;\n    };\n    StylingBuilder.prototype._buildMapBasedInstruction = function (valueConverter, isClassBased, stylingInput) {\n        // each styling binding value is stored in the LView\n        // map-based bindings allocate two slots: one for the\n        // previous binding value and another for the previous\n        // className or style attribute value.\n        var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        // these values must be outside of the update block so that they can\n        // be evaluated (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        var mapValue = stylingInput.value.visit(valueConverter);\n        var reference;\n        if (mapValue instanceof Interpolation) {\n            totalBindingSlotsRequired += mapValue.expressions.length;\n            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                getStyleMapInterpolationExpression(mapValue);\n        }\n        else {\n            reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;\n        }\n        return {\n            reference: reference,\n            calls: [{\n                    supportsInterpolation: true,\n                    sourceSpan: stylingInput.sourceSpan,\n                    allocateBindingSlots: totalBindingSlotsRequired,\n                    params: function (convertFn) {\n                        var convertResult = convertFn(mapValue);\n                        var params = Array.isArray(convertResult) ? convertResult : [convertResult];\n                        return params;\n                    }\n                }]\n        };\n    };\n    StylingBuilder.prototype._buildSingleInputs = function (reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n        var instructions = [];\n        inputs.forEach(function (input) {\n            var previousInstruction = instructions[instructions.length - 1];\n            var value = input.value.visit(valueConverter);\n            var referenceForCall = reference;\n            // each styling binding value is stored in the LView\n            // but there are two values stored for each binding:\n            //   1) the value itself\n            //   2) an intermediate value (concatenation of style up to this point).\n            //      We need to store the intermediate value so that we don't allocate\n            //      the strings on each CD.\n            var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n            if (value instanceof Interpolation) {\n                totalBindingSlotsRequired += value.expressions.length;\n                if (getInterpolationExpressionFn) {\n                    referenceForCall = getInterpolationExpressionFn(value);\n                }\n            }\n            var call = {\n                sourceSpan: input.sourceSpan,\n                allocateBindingSlots: totalBindingSlotsRequired,\n                supportsInterpolation: !!getInterpolationExpressionFn,\n                params: function (convertFn) {\n                    // params => stylingProp(propName, value, suffix|sanitizer)\n                    var params = [];\n                    params.push(literal(input.name));\n                    var convertResult = convertFn(value);\n                    if (Array.isArray(convertResult)) {\n                        params.push.apply(params, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(convertResult));\n                    }\n                    else {\n                        params.push(convertResult);\n                    }\n                    // [style.prop] bindings may use suffix values (e.g. px, em, etc...) and they\n                    // can also use a sanitizer. Sanitization occurs for url-based entries. Having\n                    // the suffix value and a sanitizer together into the instruction doesn't make\n                    // any sense (url-based entries cannot be sanitized).\n                    if (!isClassBased) {\n                        if (input.unit) {\n                            params.push(literal(input.unit));\n                        }\n                        else if (input.sanitize) {\n                            params.push(importExpr(Identifiers$1.defaultStyleSanitizer));\n                        }\n                    }\n                    return params;\n                }\n            };\n            // If we ended up generating a call to the same instruction as the previous styling property\n            // we can chain the calls together safely to save some bytes, otherwise we have to generate\n            // a separate instruction call. This is primarily a concern with interpolation instructions\n            // where we may start off with one `reference`, but end up using another based on the\n            // number of interpolations.\n            if (previousInstruction && previousInstruction.reference === referenceForCall) {\n                previousInstruction.calls.push(call);\n            }\n            else {\n                instructions.push({ reference: referenceForCall, calls: [call] });\n            }\n        });\n        return instructions;\n    };\n    StylingBuilder.prototype._buildClassInputs = function (valueConverter) {\n        if (this._singleClassInputs) {\n            return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);\n        }\n        return [];\n    };\n    StylingBuilder.prototype._buildStyleInputs = function (valueConverter) {\n        if (this._singleStyleInputs) {\n            return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n        }\n        return [];\n    };\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n    StylingBuilder.prototype.buildUpdateLevelInstructions = function (valueConverter) {\n        var instructions = [];\n        if (this.hasBindings) {\n            var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n            if (styleMapInstruction) {\n                instructions.push(styleMapInstruction);\n            }\n            var classMapInstruction = this.buildClassMapInstruction(valueConverter);\n            if (classMapInstruction) {\n                instructions.push(classMapInstruction);\n            }\n            instructions.push.apply(instructions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._buildStyleInputs(valueConverter)));\n            instructions.push.apply(instructions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._buildClassInputs(valueConverter)));\n        }\n        return instructions;\n    };\n    return StylingBuilder;\n}());\nfunction registerIntoMap(map, key) {\n    if (!map.has(key)) {\n        map.set(key, map.size);\n    }\n}\nfunction isStyleSanitizable(prop) {\n    // Note that browsers support both the dash case and\n    // camel case property names when setting through JS.\n    return prop === 'background-image' || prop === 'backgroundImage' || prop === 'background' ||\n        prop === 'border-image' || prop === 'borderImage' || prop === 'border-image-source' ||\n        prop === 'borderImageSource' || prop === 'filter' || prop === 'list-style' ||\n        prop === 'listStyle' || prop === 'list-style-image' || prop === 'listStyleImage' ||\n        prop === 'clip-path' || prop === 'clipPath';\n}\n/**\n * Simple helper function to either provide the constant literal that will house the value\n * here or a null value if the provided values are empty.\n */\nfunction getConstantLiteralFromArray(constantPool, values) {\n    return values.length ? constantPool.getConstLiteral(literalArr(values), true) : NULL_EXPR;\n}\nfunction parseProperty(name) {\n    var hasOverrideFlag = false;\n    var overrideIndex = name.indexOf(IMPORTANT_FLAG);\n    if (overrideIndex !== -1) {\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n        hasOverrideFlag = true;\n    }\n    var unit = '';\n    var property = name;\n    var unitIndex = name.lastIndexOf('.');\n    if (unitIndex > 0) {\n        unit = name.substr(unitIndex + 1);\n        property = name.substring(0, unitIndex);\n    }\n    return { property: property, unit: unit, hasOverrideFlag: hasOverrideFlag };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.classMap;\n        case 3:\n            return Identifiers$1.classMapInterpolate1;\n        case 5:\n            return Identifiers$1.classMapInterpolate2;\n        case 7:\n            return Identifiers$1.classMapInterpolate3;\n        case 9:\n            return Identifiers$1.classMapInterpolate4;\n        case 11:\n            return Identifiers$1.classMapInterpolate5;\n        case 13:\n            return Identifiers$1.classMapInterpolate6;\n        case 15:\n            return Identifiers$1.classMapInterpolate7;\n        case 17:\n            return Identifiers$1.classMapInterpolate8;\n        default:\n            return Identifiers$1.classMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.styleMap;\n        case 3:\n            return Identifiers$1.styleMapInterpolate1;\n        case 5:\n            return Identifiers$1.styleMapInterpolate2;\n        case 7:\n            return Identifiers$1.styleMapInterpolate3;\n        case 9:\n            return Identifiers$1.styleMapInterpolate4;\n        case 11:\n            return Identifiers$1.styleMapInterpolate5;\n        case 13:\n            return Identifiers$1.styleMapInterpolate6;\n        case 15:\n            return Identifiers$1.styleMapInterpolate7;\n        case 17:\n            return Identifiers$1.styleMapInterpolate8;\n        default:\n            return Identifiers$1.styleMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.styleProp;\n        case 3:\n            return Identifiers$1.stylePropInterpolate1;\n        case 5:\n            return Identifiers$1.stylePropInterpolate2;\n        case 7:\n            return Identifiers$1.stylePropInterpolate3;\n        case 9:\n            return Identifiers$1.stylePropInterpolate4;\n        case 11:\n            return Identifiers$1.stylePropInterpolate5;\n        case 13:\n            return Identifiers$1.stylePropInterpolate6;\n        case 15:\n            return Identifiers$1.stylePropInterpolate7;\n        case 17:\n            return Identifiers$1.stylePropInterpolate8;\n        default:\n            return Identifiers$1.stylePropInterpolateV;\n    }\n}\nfunction normalizePropName(prop) {\n    return hyphenate(prop);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1;\n(function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 3] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 5] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 6] = \"Error\";\n})(TokenType$1 || (TokenType$1 = {}));\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = /** @class */ (function () {\n    function Lexer() {\n    }\n    Lexer.prototype.tokenize = function (text) {\n        var scanner = new _Scanner(text);\n        var tokens = [];\n        var token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nvar Token$1 = /** @class */ (function () {\n    function Token(index, end, type, numValue, strValue) {\n        this.index = index;\n        this.end = end;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType$1.Character && this.numValue == code;\n    };\n    Token.prototype.isNumber = function () {\n        return this.type == TokenType$1.Number;\n    };\n    Token.prototype.isString = function () {\n        return this.type == TokenType$1.String;\n    };\n    Token.prototype.isOperator = function (operator) {\n        return this.type == TokenType$1.Operator && this.strValue == operator;\n    };\n    Token.prototype.isIdentifier = function () {\n        return this.type == TokenType$1.Identifier;\n    };\n    Token.prototype.isKeyword = function () {\n        return this.type == TokenType$1.Keyword;\n    };\n    Token.prototype.isKeywordLet = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'let';\n    };\n    Token.prototype.isKeywordAs = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'as';\n    };\n    Token.prototype.isKeywordNull = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'null';\n    };\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'undefined';\n    };\n    Token.prototype.isKeywordTrue = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'true';\n    };\n    Token.prototype.isKeywordFalse = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'false';\n    };\n    Token.prototype.isKeywordThis = function () {\n        return this.type == TokenType$1.Keyword && this.strValue == 'this';\n    };\n    Token.prototype.isError = function () {\n        return this.type == TokenType$1.Error;\n    };\n    Token.prototype.toNumber = function () {\n        return this.type == TokenType$1.Number ? this.numValue : -1;\n    };\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType$1.Character:\n            case TokenType$1.Identifier:\n            case TokenType$1.Keyword:\n            case TokenType$1.Operator:\n            case TokenType$1.String:\n            case TokenType$1.Error:\n                return this.strValue;\n            case TokenType$1.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\nfunction newCharacterToken(index, end, code) {\n    return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n    return new Token$1(index, end, TokenType$1.Identifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n    return new Token$1(index, end, TokenType$1.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n    return new Token$1(index, end, TokenType$1.Operator, 0, text);\n}\nfunction newStringToken(index, end, text) {\n    return new Token$1(index, end, TokenType$1.String, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n    return new Token$1(index, end, TokenType$1.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n    return new Token$1(index, end, TokenType$1.Error, 0, message);\n}\nvar EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');\nvar _Scanner = /** @class */ (function () {\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    _Scanner.prototype.scanToken = function () {\n        var input = this.input, length = this.length;\n        var peek = this.peek, index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, this.index, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, this.index, code);\n    };\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, this.index, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, this.index, str);\n    };\n    _Scanner.prototype.scanIdentifier = function () {\n        var start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n            newIdentifierToken(start, this.index, str);\n    };\n    _Scanner.prototype.scanNumber = function (start) {\n        var simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var str = this.input.substring(start, this.index);\n        var value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, this.index, value);\n    };\n    _Scanner.prototype.scanString = function () {\n        var start = this.index;\n        var quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var buffer = '';\n        var marker = this.index;\n        var input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, this.index, buffer + last);\n    };\n    _Scanner.prototype.error = function (message, offset) {\n        var position = this.index + offset;\n        return newErrorToken(position, this.index, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\nfunction parseIntAutoRadix(text) {\n    var result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = /** @class */ (function () {\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = /** @class */ (function () {\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\nvar defaultInterpolateRegExp = _createInterpolateRegExp(DEFAULT_INTERPOLATION_CONFIG);\nfunction _getInterpolateRegExp(config) {\n    if (config === DEFAULT_INTERPOLATION_CONFIG) {\n        return defaultInterpolateRegExp;\n    }\n    else {\n        return _createInterpolateRegExp(config);\n    }\n}\nfunction _createInterpolateRegExp(config) {\n    var pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser$1 = /** @class */ (function () {\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n        this.simpleExpressionChecker = SimpleExpressionChecker;\n    }\n    Parser.prototype.parseAction = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var sourceToLex = this._stripComments(input);\n        var tokens = this._lexer.tokenize(this._stripComments(input));\n        var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.parseBinding = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.checkSimpleExpression = function (ast) {\n        var checker = new this.simpleExpressionChecker();\n        ast.visit(checker);\n        return checker.errors;\n    };\n    Parser.prototype.parseSimpleBinding = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        var errors = this.checkSimpleExpression(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    Parser.prototype._parseBindingAst = function (input, location, absoluteOffset, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var quote = this._parseQuote(input, location, absoluteOffset);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var sourceToLex = this._stripComments(input);\n        var tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    Parser.prototype._parseQuote = function (input, location, absoluteOffset) {\n        if (input == null)\n            return null;\n        var prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        var span = new ParseSpan(0, input.length);\n        return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n    Parser.prototype.parseTemplateBindings = function (templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n        var tokens = this._lexer.tokenize(templateValue);\n        var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);\n        return parser.parseTemplateBindings({\n            source: templateKey,\n            span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n        });\n    };\n    Parser.prototype.parseInterpolation = function (input, location, absoluteOffset, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var expressions = [];\n        for (var i = 0; i < split.expressions.length; ++i) {\n            var expressionText = split.expressions[i];\n            var sourceToLex = this._stripComments(expressionText);\n            var tokens = this._lexer.tokenize(sourceToLex);\n            var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        var span = new ParseSpan(0, input == null ? 0 : input.length);\n        return new ASTWithSource(new Interpolation(span, span.toAbsolute(absoluteOffset), split.strings, expressions), input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var regexp = _getInterpolateRegExp(interpolationConfig);\n        var parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var strings = [];\n        var expressions = [];\n        var offsets = [];\n        var offset = 0;\n        for (var i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implicit');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    Parser.prototype.wrapLiteralPrimitive = function (input, location, absoluteOffset) {\n        var span = new ParseSpan(0, input == null ? 0 : input.length);\n        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    };\n    Parser.prototype._stripComments = function (input) {\n        var i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    Parser.prototype._commentStart = function (input) {\n        var outerQuote = null;\n        for (var i = 0; i < input.length - 1; i++) {\n            var char = input.charCodeAt(i);\n            var nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var regexp = _getInterpolateRegExp(interpolationConfig);\n        var parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var errLocation = '';\n        for (var j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nvar IvyParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(IvyParser, _super);\n    function IvyParser() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.simpleExpressionChecker = IvySimpleExpressionChecker; //\n        return _this;\n    }\n    return IvyParser;\n}(Parser$1));\nvar _ParseAST = /** @class */ (function () {\n    function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.absoluteOffset = absoluteOffset;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        // Cache of expression start and input indeces to the absolute source span they map to, used to\n        // prevent creating superfluous source spans in `sourceSpan`.\n        // A serial of the expression start and input index is used for mapping because both are stateful\n        // and may change for subsequent expressions visited by the parser.\n        this.sourceSpanCache = new Map();\n        this.index = 0;\n    }\n    _ParseAST.prototype.peek = function (offset) {\n        var i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        get: function () {\n            return this.peek(0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"atEOF\", {\n        /** Whether all the parser input has been processed. */\n        get: function () {\n            return this.index >= this.tokens.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        /**\n         * Index of the next token to be processed, or the end of the last token if all have been\n         * processed.\n         */\n        get: function () {\n            return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"currentEndIndex\", {\n        /**\n         * End index of the last processed token, or the start of the first token if none have been\n         * processed.\n         */\n        get: function () {\n            if (this.index > 0) {\n                var curToken = this.peek(-1);\n                return curToken.end + this.offset;\n            }\n            // No tokens have been processed yet; return the next token's start or the length of the input\n            // if there is no token.\n            if (this.tokens.length === 0) {\n                return this.inputLength + this.offset;\n            }\n            return this.next.index + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"currentAbsoluteOffset\", {\n        /**\n         * Returns the absolute offset of the start of the current token.\n         */\n        get: function () {\n            return this.absoluteOffset + this.inputIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    _ParseAST.prototype.span = function (start) {\n        return new ParseSpan(start, this.currentEndIndex);\n    };\n    _ParseAST.prototype.sourceSpan = function (start) {\n        var serial = start + \"@\" + this.inputIndex;\n        if (!this.sourceSpanCache.has(serial)) {\n            this.sourceSpanCache.set(serial, this.span(start).toAbsolute(this.absoluteOffset));\n        }\n        return this.sourceSpanCache.get(serial);\n    };\n    _ParseAST.prototype.advance = function () {\n        this.index++;\n    };\n    _ParseAST.prototype.consumeOptionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _ParseAST.prototype.peekKeywordLet = function () {\n        return this.next.isKeywordLet();\n    };\n    _ParseAST.prototype.peekKeywordAs = function () {\n        return this.next.isKeywordAs();\n    };\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.consumeOptionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    _ParseAST.prototype.consumeOptionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.consumeOptionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    _ParseAST.prototype.parseChain = function () {\n        var exprs = [];\n        var start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.consumeOptionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.consumeOptionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    };\n    _ParseAST.prototype.parsePipe = function () {\n        var result = this.parseExpression();\n        if (this.consumeOptionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var nameStart = this.inputIndex;\n                var name_1 = this.expectIdentifierOrKeyword();\n                var nameSpan = this.sourceSpan(nameStart);\n                var args = [];\n                while (this.consumeOptionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                var start = result.span.start;\n                result =\n                    new BindingPipe(this.span(start), this.sourceSpan(start), result, name_1, args, nameSpan);\n            } while (this.consumeOptionalOperator('|'));\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseExpression = function () {\n        return this.parseConditional();\n    };\n    _ParseAST.prototype.parseConditional = function () {\n        var start = this.inputIndex;\n        var result = this.parseLogicalOr();\n        if (this.consumeOptionalOperator('?')) {\n            var yes = this.parsePipe();\n            var no = void 0;\n            if (!this.consumeOptionalCharacter($COLON)) {\n                var end = this.inputIndex;\n                var expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var result = this.parseLogicalAnd();\n        while (this.consumeOptionalOperator('||')) {\n            var right = this.parseLogicalAnd();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var result = this.parseEquality();\n        while (this.consumeOptionalOperator('&&')) {\n            var right = this.parseEquality();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var result = this.parseRelational();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var right = this.parseRelational();\n                    var start = result.span.start;\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var result = this.parseAdditive();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var right = this.parseAdditive();\n                    var start = result.span.start;\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var result = this.parseMultiplicative();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var right = this.parseMultiplicative();\n                    var start = result.span.start;\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var result = this.parsePrefix();\n        while (this.next.type == TokenType$1.Operator) {\n            var operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var right = this.parsePrefix();\n                    var start = result.span.start;\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType$1.Operator) {\n            var start = this.inputIndex;\n            var operator = this.next.strValue;\n            var literalSpan = new ParseSpan(start, start);\n            var literalSourceSpan = literalSpan.toAbsolute(this.absoluteOffset);\n            var result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), this.sourceSpan(start), '-', result, new LiteralPrimitive(literalSpan, literalSourceSpan, 0));\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), this.sourceSpan(start), operator, new LiteralPrimitive(literalSpan, literalSourceSpan, 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    _ParseAST.prototype.parseCallChain = function () {\n        var result = this.parsePrimary();\n        var resultStart = result.span.start;\n        while (true) {\n            if (this.consumeOptionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.consumeOptionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.consumeOptionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.consumeOptionalOperator('=')) {\n                    var value = this.parseConditional();\n                    result = new KeyedWrite(this.span(resultStart), this.sourceSpan(resultStart), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);\n                }\n            }\n            else if (this.consumeOptionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result =\n                    new FunctionCall(this.span(resultStart), this.sourceSpan(resultStart), result, args);\n            }\n            else if (this.consumeOptionalOperator('!')) {\n                result = new NonNullAssert(this.span(resultStart), this.sourceSpan(resultStart), result);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    _ParseAST.prototype.parsePrimary = function () {\n        var start = this.inputIndex;\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.consumeOptionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n        }\n        else if (this.next.isString()) {\n            var literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n    };\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.consumeOptionalCharacter($COMMA));\n        }\n        return result;\n    };\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var keys = [];\n        var values = [];\n        var start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.consumeOptionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var quoted = this.next.isString();\n                var key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key: key, quoted: quoted });\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.consumeOptionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    };\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var start = receiver.span.start;\n        var nameStart = this.inputIndex;\n        var id = this.expectIdentifierOrKeyword();\n        var nameSpan = this.sourceSpan(nameStart);\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var span = this.span(start);\n            var sourceSpan = this.sourceSpan(start);\n            return isSafe ? new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args) :\n                new MethodCall(span, sourceSpan, nameSpan, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.consumeOptionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start), this.sourceSpan(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n                }\n            }\n            else {\n                if (this.consumeOptionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n                    }\n                    var value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n                }\n            }\n        }\n    };\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n        return positionals;\n    };\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var result = '';\n        var operatorFound = false;\n        var start = this.currentAbsoluteOffset;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.consumeOptionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return {\n            source: result,\n            span: new AbsoluteSourceSpan(start, start + result.length),\n        };\n    };\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n    _ParseAST.prototype.parseTemplateBindings = function (templateKey) {\n        var bindings = [];\n        // The first binding is for the template key itself\n        // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n        // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n        bindings.push.apply(bindings, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.parseDirectiveKeywordBindings(templateKey)));\n        while (this.index < this.tokens.length) {\n            // If it starts with 'let', then this must be variable declaration\n            var letBinding = this.parseLetBinding();\n            if (letBinding) {\n                bindings.push(letBinding);\n            }\n            else {\n                // Two possible cases here, either `value \"as\" key` or\n                // \"directive-keyword expression\". We don't know which case, but both\n                // \"value\" and \"directive-keyword\" are template binding key, so consume\n                // the key first.\n                var key = this.expectTemplateBindingKey();\n                // Peek at the next token, if it is \"as\" then this must be variable\n                // declaration.\n                var binding = this.parseAsBinding(key);\n                if (binding) {\n                    bindings.push(binding);\n                }\n                else {\n                    // Otherwise the key must be a directive keyword, like \"of\". Transform\n                    // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n                    key.source = templateKey.source + key.source[0].toUpperCase() + key.source.substring(1);\n                    bindings.push.apply(bindings, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.parseDirectiveKeywordBindings(key)));\n                }\n            }\n            this.consumeStatementTerminator();\n        }\n        return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n    };\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n    _ParseAST.prototype.parseDirectiveKeywordBindings = function (key) {\n        var bindings = [];\n        this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n        var value = this.getDirectiveBoundTarget();\n        var spanEnd = this.currentAbsoluteOffset;\n        // The binding could optionally be followed by \"as\". For example,\n        // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n        // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n        // 'key' in the current context now becomes the \"value\" in the next binding.\n        var asBinding = this.parseAsBinding(key);\n        if (!asBinding) {\n            this.consumeStatementTerminator();\n            spanEnd = this.currentAbsoluteOffset;\n        }\n        var sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n        bindings.push(new ExpressionBinding(sourceSpan, key, value));\n        if (asBinding) {\n            bindings.push(asBinding);\n        }\n        return bindings;\n    };\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n    _ParseAST.prototype.getDirectiveBoundTarget = function () {\n        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n            return null;\n        }\n        var ast = this.parsePipe(); // example: \"condition | async\"\n        var _a = ast.span, start = _a.start, end = _a.end;\n        var value = this.input.substring(start, end);\n        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    };\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n    _ParseAST.prototype.parseAsBinding = function (value) {\n        if (!this.peekKeywordAs()) {\n            return null;\n        }\n        this.advance(); // consume the 'as' keyword\n        var key = this.expectTemplateBindingKey();\n        this.consumeStatementTerminator();\n        var sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    };\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n    _ParseAST.prototype.parseLetBinding = function () {\n        if (!this.peekKeywordLet()) {\n            return null;\n        }\n        var spanStart = this.currentAbsoluteOffset;\n        this.advance(); // consume the 'let' keyword\n        var key = this.expectTemplateBindingKey();\n        var value = null;\n        if (this.consumeOptionalOperator('=')) {\n            value = this.expectTemplateBindingKey();\n        }\n        this.consumeStatementTerminator();\n        var sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    };\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n    _ParseAST.prototype.consumeStatementTerminator = function () {\n        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    };\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n    _ParseAST.prototype.skip = function () {\n        var n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = /** @class */ (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) {\n        this.visitAll(ast.expressions);\n    };\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) {\n        this.visitAll(ast.values);\n    };\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitNonNullAssert = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) {\n        this.errors.push('pipes');\n    };\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n/**\n * This class extends SimpleExpressionChecker used in View Engine and performs more strict checks to\n * make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\n * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\n * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\n * Ivy mode only.\n */\nvar IvySimpleExpressionChecker = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(IvySimpleExpressionChecker, _super);\n    function IvySimpleExpressionChecker() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IvySimpleExpressionChecker.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n    };\n    IvySimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n    };\n    return IvySimpleExpressionChecker;\n}(SimpleExpressionChecker));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\nvar _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n    if (!_SECURITY_SCHEMA) {\n        _SECURITY_SCHEMA = {};\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n        registerContext(SecurityContext.HTML, [\n            'iframe|srcdoc',\n            '*|innerHTML',\n            '*|outerHTML',\n        ]);\n        registerContext(SecurityContext.STYLE, ['*|style']);\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n        registerContext(SecurityContext.URL, [\n            '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n            'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n            'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n            'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n        ]);\n        registerContext(SecurityContext.RESOURCE_URL, [\n            'applet|code',\n            'applet|codebase',\n            'base|href',\n            'embed|src',\n            'frame|src',\n            'head|profile',\n            'html|manifest',\n            'iframe|src',\n            'link|href',\n            'media|src',\n            'object|codebase',\n            'object|data',\n            'script|src',\n        ]);\n    }\n    return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n    var e_1, _a;\n    try {\n        for (var specs_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(specs), specs_1_1 = specs_1.next(); !specs_1_1.done; specs_1_1 = specs_1.next()) {\n            var spec = specs_1_1.value;\n            _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (specs_1_1 && !specs_1_1.done && (_a = specs_1.return)) _a.call(specs_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ElementSchemaRegistry = /** @class */ (function () {\n    function ElementSchemaRegistry() {\n    }\n    return ElementSchemaRegistry;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(encodedType.split('|'), 2), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(strType.split('^'), 2), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) {\n                    type[prop] = superType[prop];\n                });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === NO_ERRORS_SCHEMA.name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === NO_ERRORS_SCHEMA.name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === CUSTOM_ELEMENTS_SCHEMA.name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA()['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    };\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {\n        return _ATTR_TO_PROP[propName] || propName;\n    };\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () {\n        return 'ng-component';\n    };\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () {\n        return Object.keys(this._schema);\n    };\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var unit = '';\n        var strVal = val.toString().trim();\n        var errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP$1 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX$1 = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX$1 = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX$1 = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX$1 = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX$1 = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX$1 = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX$1 = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX$1 = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX$1 = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX$1 = 10;\nvar TEMPLATE_ATTR_PREFIX$2 = '*';\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser) {\n    var transformer = new HtmlAstToIvyAst(bindingParser);\n    var ivyNodes = visitAll$1(transformer, htmlNodes);\n    // Errors might originate in either the binding parser or the html to ivy transformer\n    var allErrors = bindingParser.errors.concat(transformer.errors);\n    var errors = allErrors.filter(function (e) { return e.level === ParseErrorLevel.ERROR; });\n    if (errors.length > 0) {\n        var errorString = errors.join('\\n');\n        throw syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n    }\n    return {\n        nodes: ivyNodes,\n        errors: allErrors,\n        styleUrls: transformer.styleUrls,\n        styles: transformer.styles,\n        ngContentSelectors: transformer.ngContentSelectors,\n    };\n}\nvar HtmlAstToIvyAst = /** @class */ (function () {\n    function HtmlAstToIvyAst(bindingParser) {\n        this.bindingParser = bindingParser;\n        this.errors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngContentSelectors = [];\n        this.inI18nBlock = false;\n    }\n    // HTML visitor\n    HtmlAstToIvyAst.prototype.visitElement = function (element) {\n        var e_1, _a;\n        var _this = this;\n        var isI18nRootElement = isI18nRootNode(element.i18n);\n        if (isI18nRootElement) {\n            if (this.inI18nBlock) {\n                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n            }\n            this.inI18nBlock = true;\n        }\n        var preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\n            var contents = textContents(element);\n            if (contents !== null) {\n                this.styles.push(contents);\n            }\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            this.styleUrls.push(preparsedElement.hrefAttr);\n            return null;\n        }\n        // Whether the element is a `<ng-template>`\n        var isTemplateElement = isNgTemplate(element.name);\n        var parsedProperties = [];\n        var boundEvents = [];\n        var variables = [];\n        var references = [];\n        var attributes = [];\n        var i18nAttrsMeta = {};\n        var templateParsedProperties = [];\n        var templateVariables = [];\n        // Whether the element has any *-attribute\n        var elementHasInlineTemplate = false;\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attrs), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var attribute = _c.value;\n                var hasBinding = false;\n                var normalizedName = normalizeAttributeName(attribute.name);\n                // `*attr` defines template bindings\n                var isTemplateBinding = false;\n                if (attribute.i18n) {\n                    i18nAttrsMeta[attribute.name] = attribute.i18n;\n                }\n                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$2)) {\n                    // *-attributes\n                    if (elementHasInlineTemplate) {\n                        this.reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attribute.sourceSpan);\n                    }\n                    isTemplateBinding = true;\n                    elementHasInlineTemplate = true;\n                    var templateValue = attribute.value;\n                    var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$2.length);\n                    var parsedVariables = [];\n                    var absoluteValueOffset = attribute.valueSpan ?\n                        attribute.valueSpan.start.offset :\n                        // If there is no value span the attribute does not have a value, like `attr` in\n                        //`<div attr></div>`. In this case, point to one character beyond the last character of\n                        // the attribute name.\n                        attribute.sourceSpan.start.offset + attribute.name.length;\n                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables);\n                    templateVariables.push.apply(templateVariables, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parsedVariables.map(function (v) { return new Variable(v.name, v.value, v.sourceSpan, v.valueSpan); })));\n                }\n                else {\n                    // Check for variables, events, property bindings, interpolation\n                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n                }\n                if (!hasBinding && !isTemplateBinding) {\n                    // don't include the bindings as attributes as well in the AST\n                    attributes.push(this.visitAttribute(attribute));\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);\n        var parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>`\n            if (element.children &&\n                !element.children.every(function (node) { return isEmptyTextNode(node) || isCommentNode(node); })) {\n                this.reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            var selector = preparsedElement.selectAttr;\n            var attrs = element.attrs.map(function (attr) { return _this.visitAttribute(attr); });\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n            this.ngContentSelectors.push(selector);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>`\n            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        else {\n            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        if (elementHasInlineTemplate) {\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n            // node that contains this node.\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\n            // node for matching against content projection selectors.\n            var attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n            var templateAttrs_1 = [];\n            attrs.literal.forEach(function (attr) { return templateAttrs_1.push(attr); });\n            attrs.bound.forEach(function (attr) { return templateAttrs_1.push(attr); });\n            var hoistedAttrs = parsedElement instanceof Element ?\n                {\n                    attributes: parsedElement.attributes,\n                    inputs: parsedElement.inputs,\n                    outputs: parsedElement.outputs,\n                } :\n                { attributes: [], inputs: [], outputs: [] };\n            // For <ng-template>s with structural directives on them, avoid passing i18n information to\n            // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n            // necessary i18n meta information will be extracted from child elements.\n            var i18n_1 = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n            // TODO(pk): test for this case\n            parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs_1, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n_1);\n        }\n        if (isI18nRootElement) {\n            this.inI18nBlock = false;\n        }\n        return parsedElement;\n    };\n    HtmlAstToIvyAst.prototype.visitAttribute = function (attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);\n    };\n    HtmlAstToIvyAst.prototype.visitText = function (text) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    };\n    HtmlAstToIvyAst.prototype.visitExpansion = function (expansion) {\n        var _this = this;\n        if (!expansion.i18n) {\n            // do not generate Icu in case it was created\n            // outside of i18n block in a template\n            return null;\n        }\n        if (!isI18nRootNode(expansion.i18n)) {\n            throw new Error(\"Invalid type \\\"\" + expansion.i18n.constructor + \"\\\" for \\\"i18n\\\" property of \" + expansion.sourceSpan.toString() + \". Expected a \\\"Message\\\"\");\n        }\n        var message = expansion.i18n;\n        var vars = {};\n        var placeholders = {};\n        // extract VARs from ICUs - we process them separately while\n        // assembling resulting message via goog.getMsg function, since\n        // we need to pass them to top-level goog.getMsg call\n        Object.keys(message.placeholders).forEach(function (key) {\n            var value = message.placeholders[key];\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n                var config = _this.bindingParser.interpolationConfig;\n                // ICU expression is a plain string, not wrapped into start\n                // and end tags, so we wrap it before passing to binding parser\n                var wrapped = \"\" + config.start + value + config.end;\n                vars[key] = _this._visitTextWithInterpolation(wrapped, expansion.sourceSpan);\n            }\n            else {\n                placeholders[key] = _this._visitTextWithInterpolation(value, expansion.sourceSpan);\n            }\n        });\n        return new Icu(vars, placeholders, expansion.sourceSpan, message);\n    };\n    HtmlAstToIvyAst.prototype.visitExpansionCase = function (expansionCase) {\n        return null;\n    };\n    HtmlAstToIvyAst.prototype.visitComment = function (comment) {\n        return null;\n    };\n    // convert view engine `ParsedProperty` to a format suitable for IVY\n    HtmlAstToIvyAst.prototype.extractAttributes = function (elementName, properties, i18nPropsMeta) {\n        var _this = this;\n        var bound = [];\n        var literal = [];\n        properties.forEach(function (prop) {\n            var i18n = i18nPropsMeta[prop.name];\n            if (prop.isLiteral) {\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));\n            }\n            else {\n                // Note that validation is skipped and property mapping is disabled\n                // due to the fact that we need to make sure a given prop is not an\n                // input of a directive and directive matching happens at runtime.\n                var bep = _this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n            }\n        });\n        return { bound: bound, literal: literal };\n    };\n    HtmlAstToIvyAst.prototype.parseAttribute = function (isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n        var name = normalizeAttributeName(attribute.name);\n        var value = attribute.value;\n        var srcSpan = attribute.sourceSpan;\n        var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n        var bindParts = name.match(BIND_NAME_REGEXP$1);\n        var hasBinding = false;\n        if (bindParts) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX$1] != null) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[KW_LET_IDX$1]) {\n                if (isTemplateElement) {\n                    var identifier = bindParts[IDENT_KW_IDX$1];\n                    this.parseVariable(identifier, value, srcSpan, attribute.valueSpan, variables);\n                }\n                else {\n                    this.reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX$1]) {\n                var identifier = bindParts[IDENT_KW_IDX$1];\n                this.parseReference(identifier, value, srcSpan, attribute.valueSpan, references);\n            }\n            else if (bindParts[KW_ON_IDX$1]) {\n                var events = [];\n                this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);\n                addEvents(events, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n                this.parseAssignmentEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n            }\n            else if (bindParts[KW_AT_IDX$1]) {\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n                this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX$1]) {\n                this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n            }\n            else if (bindParts[IDENT_EVENT_IDX$1]) {\n                var events = [];\n                this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);\n                addEvents(events, boundEvents);\n            }\n        }\n        else {\n            hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);\n        }\n        return hasBinding;\n    };\n    HtmlAstToIvyAst.prototype._visitTextWithInterpolation = function (value, sourceSpan, i18n) {\n        var valueNoNgsp = replaceNgsp(value);\n        var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);\n    };\n    HtmlAstToIvyAst.prototype.parseVariable = function (identifier, value, sourceSpan, valueSpan, variables) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(\"Variable does not have a name\", sourceSpan);\n        }\n        variables.push(new Variable(identifier, value, sourceSpan, valueSpan));\n    };\n    HtmlAstToIvyAst.prototype.parseReference = function (identifier, value, sourceSpan, valueSpan, references) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(\"Reference does not have a name\", sourceSpan);\n        }\n        references.push(new Reference(identifier, value, sourceSpan, valueSpan));\n    };\n    HtmlAstToIvyAst.prototype.parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents) {\n        var events = [];\n        this.bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events);\n        addEvents(events, boundEvents);\n    };\n    HtmlAstToIvyAst.prototype.reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    };\n    return HtmlAstToIvyAst;\n}());\nvar NonBindableVisitor$1 = /** @class */ (function () {\n    function NonBindableVisitor() {\n    }\n    NonBindableVisitor.prototype.visitElement = function (ast) {\n        var preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var children = visitAll$1(this, ast.children, null);\n        return new Element(ast.name, visitAll$1(this, ast.attrs), \n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    };\n    NonBindableVisitor.prototype.visitComment = function (comment) {\n        return null;\n    };\n    NonBindableVisitor.prototype.visitAttribute = function (attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);\n    };\n    NonBindableVisitor.prototype.visitText = function (text) {\n        return new Text(text.value, text.sourceSpan);\n    };\n    NonBindableVisitor.prototype.visitExpansion = function (expansion) {\n        return null;\n    };\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase) {\n        return null;\n    };\n    return NonBindableVisitor;\n}());\nvar NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();\nfunction normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n    boundEvents.push.apply(boundEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(events.map(function (e) { return BoundEvent.fromParsedEvent(e); })));\n}\nfunction isEmptyTextNode(node) {\n    return node instanceof Text$3 && node.value.trim().length == 0;\n}\nfunction isCommentNode(node) {\n    return node instanceof Comment;\n}\nfunction textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {\n        return null;\n    }\n    else {\n        return node.children[0].value;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagType;\n(function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n    TagType[TagType[\"PROJECTION\"] = 2] = \"PROJECTION\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nvar I18nContext = /** @class */ (function () {\n    function I18nContext(index, ref, level, templateIndex, meta, registry) {\n        if (level === void 0) { level = 0; }\n        if (templateIndex === void 0) { templateIndex = null; }\n        this.index = index;\n        this.ref = ref;\n        this.level = level;\n        this.templateIndex = templateIndex;\n        this.meta = meta;\n        this.registry = registry;\n        this.bindings = new Set();\n        this.placeholders = new Map();\n        this.isEmitted = false;\n        this._unresolvedCtxCount = 0;\n        this._registry = registry || setupRegistry();\n        this.id = this._registry.getUniqueId();\n    }\n    I18nContext.prototype.appendTag = function (type, node, index, closed) {\n        if (node.isVoid && closed) {\n            return; // ignore \"close\" for void tags\n        }\n        var ph = node.isVoid || !closed ? node.startName : node.closeName;\n        var content = { type: type, index: index, ctx: this.id, isVoid: node.isVoid, closed: closed };\n        updatePlaceholderMap(this.placeholders, ph, content);\n    };\n    Object.defineProperty(I18nContext.prototype, \"icus\", {\n        get: function () {\n            return this._registry.icus;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isRoot\", {\n        get: function () {\n            return this.level === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isResolved\", {\n        get: function () {\n            return this._unresolvedCtxCount === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    I18nContext.prototype.getSerializedPlaceholders = function () {\n        var result = new Map();\n        this.placeholders.forEach(function (values, key) { return result.set(key, values.map(serializePlaceholderValue)); });\n        return result;\n    };\n    // public API to accumulate i18n-related content\n    I18nContext.prototype.appendBinding = function (binding) {\n        this.bindings.add(binding);\n    };\n    I18nContext.prototype.appendIcu = function (name, ref) {\n        updatePlaceholderMap(this._registry.icus, name, ref);\n    };\n    I18nContext.prototype.appendBoundText = function (node) {\n        var _this = this;\n        var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n        phs.forEach(function (values, key) { return updatePlaceholderMap.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([_this.placeholders, key], values)); });\n    };\n    I18nContext.prototype.appendTemplate = function (node, index) {\n        // add open and close tags at the same time,\n        // since we process nested templates separately\n        this.appendTag(TagType.TEMPLATE, node, index, false);\n        this.appendTag(TagType.TEMPLATE, node, index, true);\n        this._unresolvedCtxCount++;\n    };\n    I18nContext.prototype.appendElement = function (node, index, closed) {\n        this.appendTag(TagType.ELEMENT, node, index, closed);\n    };\n    I18nContext.prototype.appendProjection = function (node, index) {\n        // add open and close tags at the same time,\n        // since we process projected content separately\n        this.appendTag(TagType.PROJECTION, node, index, false);\n        this.appendTag(TagType.PROJECTION, node, index, true);\n    };\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n    I18nContext.prototype.forkChildContext = function (index, templateIndex, meta) {\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    };\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n    I18nContext.prototype.reconcileChildContext = function (context) {\n        var _this = this;\n        // set the right context id for open and close\n        // template tags, so we can use it as sub-block ids\n        ['start', 'close'].forEach(function (op) {\n            var key = context.meta[op + \"Name\"];\n            var phs = _this.placeholders.get(key) || [];\n            var tag = phs.find(findTemplateFn(_this.id, context.templateIndex));\n            if (tag) {\n                tag.ctx = context.id;\n            }\n        });\n        // reconcile placeholders\n        var childPhs = context.placeholders;\n        childPhs.forEach(function (values, key) {\n            var phs = _this.placeholders.get(key);\n            if (!phs) {\n                _this.placeholders.set(key, values);\n                return;\n            }\n            // try to find matching template...\n            var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n            if (tmplIdx >= 0) {\n                // ... if found - replace it with nested template content\n                var isCloseTag = key.startsWith('CLOSE');\n                var isTemplateTag = key.endsWith('NG-TEMPLATE');\n                if (isTemplateTag) {\n                    // current template's content is placed before or after\n                    // parent template tag, depending on the open/close atrribute\n                    phs.splice.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([tmplIdx + (isCloseTag ? 0 : 1), 0], values));\n                }\n                else {\n                    var idx = isCloseTag ? values.length - 1 : 0;\n                    values[idx].tmpl = phs[tmplIdx];\n                    phs.splice.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([tmplIdx, 1], values));\n                }\n            }\n            else {\n                // ... otherwise just append content to placeholder value\n                phs.push.apply(phs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(values));\n            }\n            _this.placeholders.set(key, phs);\n        });\n        this._unresolvedCtxCount--;\n    };\n    return I18nContext;\n}());\n//\n// Helper methods\n//\nfunction wrap(symbol, index, contextId, closed) {\n    var state = closed ? '/' : '';\n    return wrapI18nPlaceholder(\"\" + state + symbol + index, contextId);\n}\nfunction wrapTag(symbol, _a, closed) {\n    var index = _a.index, ctx = _a.ctx, isVoid = _a.isVoid;\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n        wrap(symbol, index, ctx, closed);\n}\nfunction findTemplateFn(ctx, templateIndex) {\n    return function (token) { return typeof token === 'object' && token.type === TagType.TEMPLATE &&\n        token.index === templateIndex && token.ctx === ctx; };\n}\nfunction serializePlaceholderValue(value) {\n    var element = function (data, closed) { return wrapTag('#', data, closed); };\n    var template = function (data, closed) { return wrapTag('*', data, closed); };\n    var projection = function (data, closed) { return wrapTag('!', data, closed); };\n    switch (value.type) {\n        case TagType.ELEMENT:\n            // close element tag\n            if (value.closed) {\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n            }\n            // open element tag that also initiates a template\n            if (value.tmpl) {\n                return template(value.tmpl) + element(value) +\n                    (value.isVoid ? template(value.tmpl, true) : '');\n            }\n            return element(value);\n        case TagType.TEMPLATE:\n            return template(value, value.closed);\n        case TagType.PROJECTION:\n            return projection(value, value.closed);\n        default:\n            return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar IcuSerializerVisitor = /** @class */ (function () {\n    function IcuSerializerVisitor() {\n    }\n    IcuSerializerVisitor.prototype.visitText = function (text) {\n        return text.value;\n    };\n    IcuSerializerVisitor.prototype.visitContainer = function (container) {\n        var _this = this;\n        return container.children.map(function (child) { return child.visit(_this); }).join('');\n    };\n    IcuSerializerVisitor.prototype.visitIcu = function (icu) {\n        var _this = this;\n        var strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        var result = \"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \" + strCases.join(' ') + \"}\";\n        return result;\n    };\n    IcuSerializerVisitor.prototype.visitTagPlaceholder = function (ph) {\n        var _this = this;\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            \"\" + this.formatPh(ph.startName) + ph.children.map(function (child) { return child.visit(_this); }).join('') + this.formatPh(ph.closeName);\n    };\n    IcuSerializerVisitor.prototype.visitPlaceholder = function (ph) {\n        return this.formatPh(ph.name);\n    };\n    IcuSerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return this.formatPh(ph.name);\n    };\n    IcuSerializerVisitor.prototype.formatPh = function (value) {\n        return \"{\" + formatI18nPlaceholderName(value, /* useCamelCase */ false) + \"}\";\n    };\n    return IcuSerializerVisitor;\n}());\nvar serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n    return icu.visit(serializer);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nvar PlaceholderRegistry = /** @class */ (function () {\n    function PlaceholderRegistry() {\n        // Count the occurrence of the base name top generate a unique name\n        this._placeHolderNameCounts = {};\n        // Maps signature to placeholder names\n        this._signatureToName = {};\n    }\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var upperTag = tag.toUpperCase();\n        var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var upperTag = tag.toUpperCase();\n        var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var upperName = name.toUpperCase();\n        var signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    // Generate a hash for a tag - does not take attribute order into account\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var start = \"<\" + tag;\n        var strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) {\n        return this._hashTag(\"/\" + tag, {}, false);\n    };\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, customId, visitNodeFn) {\n        return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    };\n}\nfunction noopVisitNodeFn(_html, i18n) {\n    return i18n;\n}\nvar _I18nVisitor = /** @class */ (function () {\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, customId, visitNodeFn) {\n        if (meaning === void 0) { meaning = ''; }\n        if (description === void 0) { description = ''; }\n        if (customId === void 0) { customId = ''; }\n        var context = {\n            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n            icuDepth: 0,\n            placeholderRegistry: new PlaceholderRegistry(),\n            placeholderToContent: {},\n            placeholderToMessage: {},\n            visitNodeFn: visitNodeFn || noopVisitNodeFn,\n        };\n        var i18nodes = visitAll$1(this, nodes, context);\n        return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    };\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var children = visitAll$1(this, el.children, context);\n        var attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        context.placeholderToContent[startPhName] = el.sourceSpan.toString();\n        var closePhName = '';\n        if (!isVoid) {\n            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            context.placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n        return context.visitNodeFn(el, node);\n    };\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        var node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan, context);\n        return context.visitNodeFn(attribute, node);\n    };\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        var node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context);\n        return context.visitNodeFn(text, node);\n    };\n    _I18nVisitor.prototype.visitComment = function (comment, context) {\n        return null;\n    };\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        context.icuDepth++;\n        var i18nIcuCases = {};\n        var i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, context); }), caze.expSourceSpan);\n        });\n        context.icuDepth--;\n        if (context.isIcu || context.icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var expPh = context.placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            context.placeholderToContent[expPh] = icu.switchValue;\n            return context.visitNodeFn(icu, i18nIcu);\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n        var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n        return context.visitNodeFn(icu, node);\n    };\n    _I18nVisitor.prototype.visitExpansionCase = function (_icuCase, _context) {\n        throw new Error('Unreachable code');\n    };\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan, context) {\n        var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var nodes = [];\n        var container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var expression = splitInterpolation.expressions[i];\n            var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            context.placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar setI18nRefs = function (htmlNode, i18nNode) {\n    if (htmlNode instanceof NodeWithI18n) {\n        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n            // This html node represents an ICU but this is a second processing pass, and the legacy id\n            // was computed in the previous pass and stored in the `i18n` property as a message.\n            // We are about to wipe out that property so capture the previous message to be reused when\n            // generating the message for this ICU later. See `_generateI18nMessage()`.\n            i18nNode.previousMessage = htmlNode.i18n;\n        }\n        htmlNode.i18n = i18nNode;\n    }\n    return i18nNode;\n};\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nvar I18nMetaVisitor = /** @class */ (function () {\n    function I18nMetaVisitor(interpolationConfig, keepI18nAttrs, enableI18nLegacyMessageIdFormat) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        if (keepI18nAttrs === void 0) { keepI18nAttrs = false; }\n        if (enableI18nLegacyMessageIdFormat === void 0) { enableI18nLegacyMessageIdFormat = false; }\n        this.interpolationConfig = interpolationConfig;\n        this.keepI18nAttrs = keepI18nAttrs;\n        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n        // whether visited nodes contain i18n information\n        this.hasI18nMeta = false;\n        // i18n message generation factory\n        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n    }\n    I18nMetaVisitor.prototype._generateI18nMessage = function (nodes, meta, visitNodeFn) {\n        if (meta === void 0) { meta = ''; }\n        var _a = this._parseMetadata(meta), meaning = _a.meaning, description = _a.description, customId = _a.customId;\n        var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n        this._setMessageId(message, meta);\n        this._setLegacyIds(message, meta);\n        return message;\n    };\n    I18nMetaVisitor.prototype.visitElement = function (element) {\n        var e_1, _a, e_2, _b;\n        if (hasI18nAttrs(element)) {\n            this.hasI18nMeta = true;\n            var attrs = [];\n            var attrsMeta = {};\n            try {\n                for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attrs), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var attr = _d.value;\n                    if (attr.name === I18N_ATTR) {\n                        // root 'i18n' node attribute\n                        var i18n_1 = element.i18n || attr.value;\n                        var message = this._generateI18nMessage(element.children, i18n_1, setI18nRefs);\n                        // do not assign empty i18n meta\n                        if (message.nodes.length) {\n                            element.i18n = message;\n                        }\n                    }\n                    else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n                        // 'i18n-*' attributes\n                        var key = attr.name.slice(I18N_ATTR_PREFIX.length);\n                        attrsMeta[key] = attr.value;\n                    }\n                    else {\n                        // non-i18n attributes\n                        attrs.push(attr);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            // set i18n meta for attributes\n            if (Object.keys(attrsMeta).length) {\n                try {\n                    for (var attrs_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(attrs), attrs_1_1 = attrs_1.next(); !attrs_1_1.done; attrs_1_1 = attrs_1.next()) {\n                        var attr = attrs_1_1.value;\n                        var meta = attrsMeta[attr.name];\n                        // do not create translation for empty attributes\n                        if (meta !== undefined && attr.value) {\n                            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (attrs_1_1 && !attrs_1_1.done && (_b = attrs_1.return)) _b.call(attrs_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n            if (!this.keepI18nAttrs) {\n                // update element's attributes,\n                // keeping only non-i18n related ones\n                element.attrs = attrs;\n            }\n        }\n        visitAll$1(this, element.children, element.i18n);\n        return element;\n    };\n    I18nMetaVisitor.prototype.visitExpansion = function (expansion, currentMessage) {\n        var message;\n        var meta = expansion.i18n;\n        this.hasI18nMeta = true;\n        if (meta instanceof IcuPlaceholder) {\n            // set ICU placeholder name (e.g. \"ICU_1\"),\n            // generated while processing root element contents,\n            // so we can reference it when we output translation\n            var name_1 = meta.name;\n            message = this._generateI18nMessage([expansion], meta);\n            var icu = icuFromI18nMessage(message);\n            icu.name = name_1;\n        }\n        else {\n            // ICU is a top level message, try to use metadata from container element if provided via\n            // `context` argument. Note: context may not be available for standalone ICUs (without\n            // wrapping element), so fallback to ICU metadata in this case.\n            message = this._generateI18nMessage([expansion], currentMessage || meta);\n        }\n        expansion.i18n = message;\n        return expansion;\n    };\n    I18nMetaVisitor.prototype.visitText = function (text) {\n        return text;\n    };\n    I18nMetaVisitor.prototype.visitAttribute = function (attribute) {\n        return attribute;\n    };\n    I18nMetaVisitor.prototype.visitComment = function (comment) {\n        return comment;\n    };\n    I18nMetaVisitor.prototype.visitExpansionCase = function (expansionCase) {\n        return expansionCase;\n    };\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n    I18nMetaVisitor.prototype._parseMetadata = function (meta) {\n        return typeof meta === 'string' ? parseI18nMeta(meta) :\n            meta instanceof Message ? meta : {};\n    };\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n    I18nMetaVisitor.prototype._setMessageId = function (message, meta) {\n        if (!message.id) {\n            message.id = meta instanceof Message && meta.id || decimalDigest(message);\n        }\n    };\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n    I18nMetaVisitor.prototype._setLegacyIds = function (message, meta) {\n        if (this.enableI18nLegacyMessageIdFormat) {\n            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n        }\n        else if (typeof meta !== 'string') {\n            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n            // `packages/compiler/src/render3/view/template.ts`).\n            // In that case we want to reuse the legacy message generated in the 1st pass (see\n            // `setI18nRefs()`).\n            var previousMessage = meta instanceof Message ?\n                meta :\n                meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n        }\n    };\n    return I18nMetaVisitor;\n}());\n/** I18n separators for metadata **/\nvar I18N_MEANING_SEPARATOR = '|';\nvar I18N_ID_SEPARATOR = '@@';\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nfunction parseI18nMeta(meta) {\n    var _a, _b;\n    if (meta === void 0) { meta = ''; }\n    var customId;\n    var meaning;\n    var description;\n    meta = meta.trim();\n    if (meta) {\n        var idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n        var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n        var meaningAndDesc = void 0;\n        _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''], 2), meaningAndDesc = _a[0], customId = _a[1];\n        _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((descIndex > -1) ?\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n            ['', meaningAndDesc], 2), meaning = _b[0], description = _b[1];\n    }\n    return { customId: customId, meaning: meaning, description: description };\n}\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta) {\n    var tags = [];\n    if (meta.description) {\n        tags.push({ tagName: \"desc\" /* Desc */, text: meta.description });\n    }\n    if (meta.meaning) {\n        tags.push({ tagName: \"meaning\" /* Meaning */, text: meta.meaning });\n    }\n    return tags.length == 0 ? null : new JSDocCommentStmt(tags);\n}\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nvar GOOG_GET_MSG = 'goog.getMsg';\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, params) {\n    var messageString = serializeI18nMessageForGetMsg(message);\n    var args = [literal(messageString)];\n    if (Object.keys(params).length) {\n        args.push(mapLiteral(params, true));\n    }\n    // /**\n    //  * @desc description of message\n    //  * @meaning meaning of message\n    //  */\n    // const MSG_... = goog.getMsg(..);\n    // I18N_X = MSG_...;\n    var statements = [];\n    var jsdocComment = i18nMetaToDocStmt(message);\n    if (jsdocComment !== null) {\n        statements.push(jsdocComment);\n    }\n    statements.push(closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl());\n    statements.push(new ExpressionStatement(variable$1.set(closureVar)));\n    return statements;\n}\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nvar GetMsgSerializerVisitor = /** @class */ (function () {\n    function GetMsgSerializerVisitor() {\n    }\n    GetMsgSerializerVisitor.prototype.formatPh = function (value) {\n        return \"{$\" + formatI18nPlaceholderName(value) + \"}\";\n    };\n    GetMsgSerializerVisitor.prototype.visitText = function (text) {\n        return text.value;\n    };\n    GetMsgSerializerVisitor.prototype.visitContainer = function (container) {\n        var _this = this;\n        return container.children.map(function (child) { return child.visit(_this); }).join('');\n    };\n    GetMsgSerializerVisitor.prototype.visitIcu = function (icu) {\n        return serializeIcuNode(icu);\n    };\n    GetMsgSerializerVisitor.prototype.visitTagPlaceholder = function (ph) {\n        var _this = this;\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            \"\" + this.formatPh(ph.startName) + ph.children.map(function (child) { return child.visit(_this); }).join('') + this.formatPh(ph.closeName);\n    };\n    GetMsgSerializerVisitor.prototype.visitPlaceholder = function (ph) {\n        return this.formatPh(ph.name);\n    };\n    GetMsgSerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return this.formatPh(ph.name);\n    };\n    return GetMsgSerializerVisitor;\n}());\nvar serializerVisitor$1 = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n    return message.nodes.map(function (node) { return node.visit(serializerVisitor$1, null); }).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n    var statements = [];\n    var _a = serializeI18nMessageForLocalize(message), messageParts = _a.messageParts, placeHolders = _a.placeHolders;\n    statements.push(new ExpressionStatement(variable.set(localizedString(message, messageParts, placeHolders, placeHolders.map(function (ph) { return params[ph]; })))));\n    return statements;\n}\nvar MessagePiece = /** @class */ (function () {\n    function MessagePiece(text) {\n        this.text = text;\n    }\n    return MessagePiece;\n}());\nvar LiteralPiece = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(LiteralPiece, _super);\n    function LiteralPiece() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return LiteralPiece;\n}(MessagePiece));\nvar PlaceholderPiece = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PlaceholderPiece, _super);\n    function PlaceholderPiece(name) {\n        return _super.call(this, formatI18nPlaceholderName(name, /* useCamelCase */ false)) || this;\n    }\n    return PlaceholderPiece;\n}(MessagePiece));\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nvar LocalizeSerializerVisitor = /** @class */ (function () {\n    function LocalizeSerializerVisitor() {\n    }\n    LocalizeSerializerVisitor.prototype.visitText = function (text, context) {\n        if (context[context.length - 1] instanceof LiteralPiece) {\n            // Two literal pieces in a row means that there was some comment node in-between.\n            context[context.length - 1].text += text.value;\n        }\n        else {\n            context.push(new LiteralPiece(text.value));\n        }\n    };\n    LocalizeSerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this, context); });\n    };\n    LocalizeSerializerVisitor.prototype.visitIcu = function (icu, context) {\n        context.push(new LiteralPiece(serializeIcuNode(icu)));\n    };\n    LocalizeSerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        context.push(new PlaceholderPiece(ph.startName));\n        if (!ph.isVoid) {\n            ph.children.forEach(function (child) { return child.visit(_this, context); });\n            context.push(new PlaceholderPiece(ph.closeName));\n        }\n    };\n    LocalizeSerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        context.push(new PlaceholderPiece(ph.name));\n    };\n    LocalizeSerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        context.push(new PlaceholderPiece(ph.name));\n    };\n    return LocalizeSerializerVisitor;\n}());\nvar serializerVisitor$2 = new LocalizeSerializerVisitor();\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction serializeI18nMessageForLocalize(message) {\n    var pieces = [];\n    message.nodes.forEach(function (node) { return node.visit(serializerVisitor$2, pieces); });\n    return processMessagePieces(pieces);\n}\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces) {\n    var messageParts = [];\n    var placeHolders = [];\n    if (pieces[0] instanceof PlaceholderPiece) {\n        // The first piece was a placeholder so we need to add an initial empty message part.\n        messageParts.push('');\n    }\n    for (var i = 0; i < pieces.length; i++) {\n        var part = pieces[i];\n        if (part instanceof LiteralPiece) {\n            messageParts.push(part.text);\n        }\n        else {\n            placeHolders.push(part.text);\n            if (pieces[i - 1] instanceof PlaceholderPiece) {\n                // There were two placeholders in a row, so we need to add an empty message part.\n                messageParts.push('');\n            }\n        }\n    }\n    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n        // The last piece was a placeholder so we need to add a final empty message part.\n        messageParts.push('');\n    }\n    return { messageParts: messageParts, placeHolders: placeHolders };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Selector attribute name of `<ng-content>`\nvar NG_CONTENT_SELECT_ATTR$1 = 'select';\n// Attribute name of `ngProjectAs`.\nvar NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n// List of supported global targets for event listeners\nvar GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);\nvar LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags, statements) {\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\nfunction prepareEventListenerParameters(eventAst, handlerName, scope) {\n    if (handlerName === void 0) { handlerName = null; }\n    if (scope === void 0) { scope = null; }\n    var type = eventAst.type, name = eventAst.name, target = eventAst.target, phase = eventAst.phase, handler = eventAst.handler;\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n        throw new Error(\"Unexpected global target '\" + target + \"' defined for '\" + name + \"' event.\\n        Supported list of global targets: \" + Array.from(GLOBAL_TARGET_RESOLVERS.keys()) + \".\");\n    }\n    var eventArgumentName = '$event';\n    var implicitReceiverAccesses = new Set();\n    var implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n        variable(CONTEXT_NAME) :\n        scope.getOrCreateSharedContextVar(0);\n    var bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () { return error('Unexpected interpolation'); }, eventAst.handlerSpan, implicitReceiverAccesses);\n    var statements = [];\n    if (scope) {\n        statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(scope.restoreViewStatement()));\n        statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(scope.variableDeclarations()));\n    }\n    statements.push.apply(statements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingExpr.render3Stmts));\n    var eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;\n    var fnName = handlerName && sanitizeIdentifier(handlerName);\n    var fnArgs = [];\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\n        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n    }\n    var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n    var params = [literal(eventName), handlerFn];\n    if (target) {\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n    return params;\n}\nvar TemplateDefinitionBuilder = /** @class */ (function () {\n    function TemplateDefinitionBuilder(constantPool, parentBindingScope, level, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants) {\n        var _this = this;\n        if (level === void 0) { level = 0; }\n        if (_constants === void 0) { _constants = []; }\n        this.constantPool = constantPool;\n        this.level = level;\n        this.contextName = contextName;\n        this.i18nContext = i18nContext;\n        this.templateIndex = templateIndex;\n        this.templateName = templateName;\n        this.directiveMatcher = directiveMatcher;\n        this.directives = directives;\n        this.pipeTypeByName = pipeTypeByName;\n        this.pipes = pipes;\n        this._namespace = _namespace;\n        this.i18nUseExternalIds = i18nUseExternalIds;\n        this._constants = _constants;\n        this._dataIndex = 0;\n        this._bindingContext = 0;\n        this._prefixCode = [];\n        /**\n         * List of callbacks to generate creation mode instructions. We store them here as we process\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\n         * This ensures all local refs and context variables are available for matching.\n         */\n        this._creationCodeFns = [];\n        /**\n         * List of callbacks to generate update mode instructions. We store them here as we process\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\n         * all local refs and context variables are available for matching.\n         */\n        this._updateCodeFns = [];\n        /** Index of the currently-selected node. */\n        this._currentIndex = 0;\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n        this._tempVariables = [];\n        /**\n         * List of callbacks to build nested templates. Nested templates must not be visited until\n         * after the parent template has finished visiting all of its nodes. This ensures that all\n         * local ref bindings in nested templates are able to find local ref values if the refs\n         * are defined after the template declaration.\n         */\n        this._nestedTemplateFns = [];\n        this._unsupported = unsupported;\n        // i18n context local to this template\n        this.i18n = null;\n        // Number of slots to reserve for pureFunctions\n        this._pureFunctionSlots = 0;\n        // Number of binding slots\n        this._bindingSlots = 0;\n        // Projection slots found in the template. Projection slots can distribute projected\n        // nodes based on a selector, or can just use the wildcard selector to match\n        // all nodes which aren't matching any selector.\n        this._ngContentReservedSlots = [];\n        // Number of non-default selectors found in all parent templates of this template. We need to\n        // track it to properly adjust projection slot index in the `projection` instruction.\n        this._ngContentSelectorsOffset = 0;\n        // Expression that should be used as implicit receiver when converting template\n        // expressions to output AST.\n        this._implicitReceiverExpr = null;\n        // These should be handled in the template or element directly.\n        this.visitReference = invalid$1;\n        this.visitVariable = invalid$1;\n        this.visitTextAttribute = invalid$1;\n        this.visitBoundAttribute = invalid$1;\n        this.visitBoundEvent = invalid$1;\n        this._bindingScope = parentBindingScope.nestedScope(level);\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\n        // characters with underscores.\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n        this._valueConverter = new ValueConverter(constantPool, function () { return _this.allocateDataSlot(); }, function (numSlots) { return _this.allocatePureFunctionSlots(numSlots); }, function (name, localName, slot, value) {\n            var pipeType = pipeTypeByName.get(name);\n            if (pipeType) {\n                _this.pipes.add(pipeType);\n            }\n            _this._bindingScope.set(_this.level, localName, value);\n            _this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);\n        });\n    }\n    TemplateDefinitionBuilder.prototype.buildTemplateFunction = function (nodes, variables, ngContentSelectorsOffset, i18n) {\n        var _this = this;\n        if (ngContentSelectorsOffset === void 0) { ngContentSelectorsOffset = 0; }\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n        if (this._namespace !== Identifiers$1.namespaceHTML) {\n            this.creationInstruction(null, this._namespace);\n        }\n        // Create variable bindings\n        variables.forEach(function (v) { return _this.registerContextVariables(v); });\n        // Initiate i18n context in case:\n        // - this template has parent i18n context\n        // - or the template has i18n meta associated with it,\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n        var initI18nContext = this.i18nContext ||\n            (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n                !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n        var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n        if (initI18nContext) {\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\n        }\n        // This is the initial pass through the nodes of this template. In this pass, we\n        // queue all creation mode and update mode instructions for generation in the second\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n        visitAll(this, nodes);\n        // Add total binding count to pure function count so pure function instructions are\n        // generated with the correct slot offset when update instructions are processed.\n        this._pureFunctionSlots += this._bindingSlots;\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\n        // to account for bindings.\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n        // Nested templates must be processed before creation instructions so template()\n        // instructions can be generated with the correct internal const count.\n        this._nestedTemplateFns.forEach(function (buildTemplateFn) { return buildTemplateFn(); });\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n        // The `projectionDef` instruction is only emitted for the component template and\n        // is skipped for nested templates (<ng-template> tags).\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\n            var parameters = [];\n            // By default the `projectionDef` instructions creates one slot for the wildcard\n            // selector if no parameters are passed. Therefore we only want to allocate a new\n            // array for the projection slots if the default projection slot is not sufficient.\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n                var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) { return s !== '*' ? parseSelectorToR3Selector(s) : s; });\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n            }\n            // Since we accumulate ngContent selectors while processing template elements,\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\n            // any `projection` instructions\n            this.creationInstruction(null, Identifiers$1.projectionDef, parameters, /* prepend */ true);\n        }\n        if (initI18nContext) {\n            this.i18nEnd(null, selfClosingI18nInstruction);\n        }\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n        var creationStatements = this._creationCodeFns.map(function (fn) { return fn(); });\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\n        var updateStatements = this._updateCodeFns.map(function (fn) { return fn(); });\n        //  Variable declaration must occur after binding resolution so we can generate context\n        //  instructions that build on each other.\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\n        var creationVariables = this._bindingScope.viewSnapshotStatements();\n        var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n        var creationBlock = creationStatements.length > 0 ?\n            [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :\n            [];\n        var updateBlock = updateStatements.length > 0 ?\n            [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :\n            [];\n        return fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._prefixCode, creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);\n    };\n    // LocalResolver\n    TemplateDefinitionBuilder.prototype.getLocal = function (name) {\n        return this._bindingScope.get(name);\n    };\n    // LocalResolver\n    TemplateDefinitionBuilder.prototype.notifyImplicitReceiverUse = function () {\n        this._bindingScope.notifyImplicitReceiverUse();\n    };\n    TemplateDefinitionBuilder.prototype.i18nTranslate = function (message, params, ref, transformFn) {\n        var _a;\n        if (params === void 0) { params = {}; }\n        var _ref = ref || variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n        var closureVar = this.i18nGenerateClosureVar(message.id);\n        var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n        (_a = this.constantPool.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(statements));\n        return _ref;\n    };\n    TemplateDefinitionBuilder.prototype.registerContextVariables = function (variable$1) {\n        var scopedName = this._bindingScope.freshReferenceName();\n        var retrievalLevel = this.level;\n        var lhs = variable(variable$1.name + scopedName);\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, function (scope, relativeLevel) {\n            var rhs;\n            if (scope.bindingLevel === retrievalLevel) {\n                // e.g. ctx\n                rhs = variable(CONTEXT_NAME);\n            }\n            else {\n                var sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n                // e.g. ctx_r0   OR  x(2);\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n            }\n            // e.g. const $item$ = x(2).$implicit;\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n    };\n    TemplateDefinitionBuilder.prototype.i18nAppendBindings = function (expressions) {\n        var _this = this;\n        if (expressions.length > 0) {\n            expressions.forEach(function (expression) { return _this.i18n.appendBinding(expression); });\n        }\n    };\n    TemplateDefinitionBuilder.prototype.i18nBindProps = function (props) {\n        var _this = this;\n        var bound = {};\n        Object.keys(props).forEach(function (key) {\n            var prop = props[key];\n            if (prop instanceof Text) {\n                bound[key] = literal(prop.value);\n            }\n            else {\n                var value = prop.value.visit(_this._valueConverter);\n                _this.allocateBindingSlots(value);\n                if (value instanceof Interpolation) {\n                    var strings = value.strings, expressions = value.expressions;\n                    var _a = _this.i18n, id = _a.id, bindings = _a.bindings;\n                    var label = assembleI18nBoundString(strings, bindings.size, id);\n                    _this.i18nAppendBindings(expressions);\n                    bound[key] = literal(label);\n                }\n            }\n        });\n        return bound;\n    };\n    TemplateDefinitionBuilder.prototype.i18nGenerateClosureVar = function (messageId) {\n        var name;\n        var suffix = this.fileBasedI18nSuffix.toUpperCase();\n        if (this.i18nUseExternalIds) {\n            var prefix = getTranslationConstPrefix(\"EXTERNAL_\");\n            var uniqueSuffix = this.constantPool.uniqueName(suffix);\n            name = \"\" + prefix + sanitizeIdentifier(messageId) + \"$$\" + uniqueSuffix;\n        }\n        else {\n            var prefix = getTranslationConstPrefix(suffix);\n            name = this.constantPool.uniqueName(prefix);\n        }\n        return variable(name);\n    };\n    TemplateDefinitionBuilder.prototype.i18nUpdateRef = function (context) {\n        var icus = context.icus, meta = context.meta, isRoot = context.isRoot, isResolved = context.isResolved, isEmitted = context.isEmitted;\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n            context.isEmitted = true;\n            var placeholders = context.getSerializedPlaceholders();\n            var icuMapping_1 = {};\n            var params_1 = placeholders.size ? placeholdersToParams(placeholders) : {};\n            if (icus.size) {\n                icus.forEach(function (refs, key) {\n                    if (refs.length === 1) {\n                        // if we have one ICU defined for a given\n                        // placeholder - just output its reference\n                        params_1[key] = refs[0];\n                    }\n                    else {\n                        // ... otherwise we need to activate post-processing\n                        // to replace ICU placeholders with proper values\n                        var placeholder = wrapI18nPlaceholder(\"\" + I18N_ICU_MAPPING_PREFIX + key);\n                        params_1[key] = literal(placeholder);\n                        icuMapping_1[key] = literalArr(refs);\n                    }\n                });\n            }\n            // translation requires post processing in 2 cases:\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [#1, #2, ...])\n            // - if we have multiple ICUs that refer to the same placeholder name\n            var needsPostprocessing = Array.from(placeholders.values()).some(function (value) { return value.length > 1; }) ||\n                Object.keys(icuMapping_1).length;\n            var transformFn = void 0;\n            if (needsPostprocessing) {\n                transformFn = function (raw) {\n                    var args = [raw];\n                    if (Object.keys(icuMapping_1).length) {\n                        args.push(mapLiteral(icuMapping_1, true));\n                    }\n                    return instruction(null, Identifiers$1.i18nPostprocess, args);\n                };\n            }\n            this.i18nTranslate(meta, params_1, context.ref, transformFn);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.i18nStart = function (span, meta, selfClosing) {\n        if (span === void 0) { span = null; }\n        var index = this.allocateDataSlot();\n        if (this.i18nContext) {\n            this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);\n        }\n        else {\n            var ref_1 = variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));\n            this.i18n = new I18nContext(index, ref_1, 0, this.templateIndex, meta);\n        }\n        // generate i18nStart instruction\n        var _a = this.i18n, id = _a.id, ref = _a.ref;\n        var params = [literal(index), ref];\n        if (id > 0) {\n            // do not push 3rd argument (sub-block id)\n            // into i18nStart call for top level i18n context\n            params.push(literal(id));\n        }\n        this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);\n    };\n    TemplateDefinitionBuilder.prototype.i18nEnd = function (span, selfClosing) {\n        var _this = this;\n        if (span === void 0) { span = null; }\n        if (!this.i18n) {\n            throw new Error('i18nEnd is executed with no i18n context present');\n        }\n        if (this.i18nContext) {\n            this.i18nContext.reconcileChildContext(this.i18n);\n            this.i18nUpdateRef(this.i18nContext);\n        }\n        else {\n            this.i18nUpdateRef(this.i18n);\n        }\n        // setup accumulated bindings\n        var _a = this.i18n, index = _a.index, bindings = _a.bindings;\n        if (bindings.size) {\n            var chainBindings_1 = [];\n            bindings.forEach(function (binding) {\n                chainBindings_1.push({ sourceSpan: span, value: function () { return _this.convertPropertyBinding(binding); } });\n            });\n            // for i18n block, advance to the most recent element index (by taking the current number of\n            // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n            // necessary lifecycle hooks of components/directives are properly flushed.\n            this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings_1);\n            this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);\n        }\n        if (!selfClosing) {\n            this.creationInstruction(span, Identifiers$1.i18nEnd);\n        }\n        this.i18n = null; // reset local i18n context\n    };\n    TemplateDefinitionBuilder.prototype.i18nAttributesInstruction = function (nodeIndex, attrs, sourceSpan) {\n        var _this = this;\n        var hasBindings = false;\n        var i18nAttrArgs = [];\n        var bindings = [];\n        attrs.forEach(function (attr) {\n            var message = attr.i18n;\n            if (attr instanceof TextAttribute) {\n                i18nAttrArgs.push(literal(attr.name), _this.i18nTranslate(message));\n            }\n            else {\n                var converted = attr.value.visit(_this._valueConverter);\n                _this.allocateBindingSlots(converted);\n                if (converted instanceof Interpolation) {\n                    var placeholders = assembleBoundTextPlaceholders(message);\n                    var params = placeholdersToParams(placeholders);\n                    i18nAttrArgs.push(literal(attr.name), _this.i18nTranslate(message, params));\n                    converted.expressions.forEach(function (expression) {\n                        hasBindings = true;\n                        bindings.push({\n                            sourceSpan: sourceSpan,\n                            value: function () { return _this.convertPropertyBinding(expression); },\n                        });\n                    });\n                }\n            }\n        });\n        if (bindings.length > 0) {\n            this.updateInstructionChainWithAdvance(nodeIndex, Identifiers$1.i18nExp, bindings);\n        }\n        if (i18nAttrArgs.length > 0) {\n            var index = literal(this.allocateDataSlot());\n            var args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs), true);\n            this.creationInstruction(sourceSpan, Identifiers$1.i18nAttributes, [index, args]);\n            if (hasBindings) {\n                this.updateInstruction(sourceSpan, Identifiers$1.i18nApply, [index]);\n            }\n        }\n    };\n    TemplateDefinitionBuilder.prototype.getNamespaceInstruction = function (namespaceKey) {\n        switch (namespaceKey) {\n            case 'math':\n                return Identifiers$1.namespaceMathML;\n            case 'svg':\n                return Identifiers$1.namespaceSVG;\n            default:\n                return Identifiers$1.namespaceHTML;\n        }\n    };\n    TemplateDefinitionBuilder.prototype.addNamespaceInstruction = function (nsInstruction, element) {\n        this._namespace = nsInstruction;\n        this.creationInstruction(element.sourceSpan, nsInstruction);\n    };\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n    TemplateDefinitionBuilder.prototype.interpolatedUpdateInstruction = function (instruction, elementIndex, attrName, input, value, params) {\n        var _this = this;\n        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([literal(attrName)], _this.getUpdateInstructionArguments(value), params); });\n    };\n    TemplateDefinitionBuilder.prototype.visitContent = function (ngContent) {\n        var slot = this.allocateDataSlot();\n        var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n        var parameters = [literal(slot)];\n        this._ngContentReservedSlots.push(ngContent.selector);\n        var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) { return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1; });\n        var attributes = this.getAttributeExpressions(nonContentSelectAttributes, [], []);\n        if (attributes.length > 0) {\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n        }\n        else if (projectionSlotIdx !== 0) {\n            parameters.push(literal(projectionSlotIdx));\n        }\n        this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);\n        if (this.i18n) {\n            this.i18n.appendProjection(ngContent.i18n, slot);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitElement = function (element) {\n        var e_1, _a;\n        var _this = this;\n        var elementIndex = this.allocateDataSlot();\n        var stylingBuilder = new StylingBuilder(null);\n        var isNonBindableMode = false;\n        var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n        var i18nAttrs = [];\n        var outputAttrs = [];\n        var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(element.name), 2), namespaceKey = _b[0], elementName = _b[1];\n        var isNgContainer$1 = isNgContainer(element.name);\n        try {\n            // Handle styling, i18n, ngNonBindable attributes\n            for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(element.attributes), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var attr = _d.value;\n                var name_1 = attr.name, value = attr.value;\n                if (name_1 === NON_BINDABLE_ATTR) {\n                    isNonBindableMode = true;\n                }\n                else if (name_1 === 'style') {\n                    stylingBuilder.registerStyleAttr(value);\n                }\n                else if (name_1 === 'class') {\n                    stylingBuilder.registerClassAttr(value);\n                }\n                else {\n                    (attr.i18n ? i18nAttrs : outputAttrs).push(attr);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Match directives on non i18n attributes\n        this.matchDirectives(element.name, element);\n        // Regular element or ng-container creation mode\n        var parameters = [literal(elementIndex)];\n        if (!isNgContainer$1) {\n            parameters.push(literal(elementName));\n        }\n        // Add the attributes\n        var allOtherInputs = [];\n        element.inputs.forEach(function (input) {\n            var stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n            if (!stylingInputWasSet) {\n                if (input.type === 0 /* Property */ && input.i18n) {\n                    i18nAttrs.push(input);\n                }\n                else {\n                    allOtherInputs.push(input);\n                }\n            }\n        });\n        // add attributes for directive and projection matching purposes\n        var attributes = this.getAttributeExpressions(outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], i18nAttrs);\n        parameters.push(this.addAttrsToConsts(attributes));\n        // local refs (ex.: <div #foo #bar=\"baz\">)\n        var refs = this.prepareRefsArray(element.references);\n        parameters.push(this.addToConsts(refs));\n        var wasInNamespace = this._namespace;\n        var currentNamespace = this.getNamespaceInstruction(namespaceKey);\n        // If the namespace is changing now, include an instruction to change it\n        // during element creation.\n        if (currentNamespace !== wasInNamespace) {\n            this.addNamespaceInstruction(currentNamespace, element);\n        }\n        if (this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex);\n        }\n        // Note that we do not append text node instructions and ICUs inside i18n section,\n        // so we exclude them while calculating whether current element has children\n        var hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n            element.children.length > 0;\n        var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n            element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren;\n        var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n        if (createSelfClosingInstruction) {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));\n        }\n        else {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));\n            if (isNonBindableMode) {\n                this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);\n            }\n            if (i18nAttrs.length > 0) {\n                this.i18nAttributesInstruction(elementIndex, i18nAttrs, element.sourceSpan);\n            }\n            // Generate Listeners (outputs)\n            if (element.outputs.length > 0) {\n                var listeners = element.outputs.map(function (outputAst) { return ({\n                    sourceSpan: outputAst.sourceSpan,\n                    params: _this.prepareListenerParameter(element.name, outputAst, elementIndex)\n                }); });\n                this.creationInstructionChain(Identifiers$1.listener, listeners);\n            }\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n            if (isI18nRootElement) {\n                this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);\n            }\n        }\n        // the code here will collect all update-level styling instructions and add them to the\n        // update block of the template function AOT code. Instructions like `styleProp`,\n        // `styleMap`, `classMap`, `classProp`\n        // are all generated and assigned in the code below.\n        var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n        var limit = stylingInstructions.length - 1;\n        for (var i = 0; i <= limit; i++) {\n            var instruction_1 = stylingInstructions[i];\n            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction_1);\n        }\n        // the reason why `undefined` is used is because the renderer understands this as a\n        // special value to symbolize that there is no RHS to this binding\n        // TODO (matsko): revisit this once FW-959 is approached\n        var emptyValueBindInstruction = literal(undefined);\n        var propertyBindings = [];\n        var attributeBindings = [];\n        // Generate element input bindings\n        allOtherInputs.forEach(function (input) {\n            var inputType = input.type;\n            if (inputType === 4 /* Animation */) {\n                var value_1 = input.value.visit(_this._valueConverter);\n                // animation bindings can be presented in the following formats:\n                // 1. [@binding]=\"fooExp\"\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n                // 3. [@binding]\n                // 4. @binding\n                // All formats will be valid for when a synthetic binding is created.\n                // The reasoning for this is because the renderer should get each\n                // synthetic binding value in the order of the array that they are\n                // defined in...\n                var hasValue_1 = value_1 instanceof LiteralPrimitive ? !!value_1.value : true;\n                _this.allocateBindingSlots(value_1);\n                propertyBindings.push({\n                    name: prepareSyntheticPropertyName(input.name),\n                    sourceSpan: input.sourceSpan,\n                    value: function () { return hasValue_1 ? _this.convertPropertyBinding(value_1) : emptyValueBindInstruction; }\n                });\n            }\n            else {\n                // we must skip attributes with associated i18n context, since these attributes are handled\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n                if (input.i18n)\n                    return;\n                var value_2 = input.value.visit(_this._valueConverter);\n                if (value_2 !== undefined) {\n                    var params_2 = [];\n                    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(input.name), 2), attrNamespace = _a[0], attrName_1 = _a[1];\n                    var isAttributeBinding = inputType === 1 /* Attribute */;\n                    var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n                    if (sanitizationRef)\n                        params_2.push(sanitizationRef);\n                    if (attrNamespace) {\n                        var namespaceLiteral = literal(attrNamespace);\n                        if (sanitizationRef) {\n                            params_2.push(namespaceLiteral);\n                        }\n                        else {\n                            // If there wasn't a sanitization ref, we need to add\n                            // an extra param so that we can pass in the namespace.\n                            params_2.push(literal(null), namespaceLiteral);\n                        }\n                    }\n                    _this.allocateBindingSlots(value_2);\n                    if (inputType === 0 /* Property */) {\n                        if (value_2 instanceof Interpolation) {\n                            // prop=\"{{value}}\" and friends\n                            _this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                        }\n                        else {\n                            // [prop]=\"value\"\n                            // Collect all the properties so that we can chain into a single function at the end.\n                            propertyBindings.push({\n                                name: attrName_1,\n                                sourceSpan: input.sourceSpan,\n                                value: function () { return _this.convertPropertyBinding(value_2); },\n                                params: params_2\n                            });\n                        }\n                    }\n                    else if (inputType === 1 /* Attribute */) {\n                        if (value_2 instanceof Interpolation && getInterpolationArgsLength(value_2) > 1) {\n                            // attr.name=\"text{{value}}\" and friends\n                            _this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                        }\n                        else {\n                            var boundValue_1 = value_2 instanceof Interpolation ? value_2.expressions[0] : value_2;\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                            // Collect the attribute bindings so that they can be chained at the end.\n                            attributeBindings.push({\n                                name: attrName_1,\n                                sourceSpan: input.sourceSpan,\n                                value: function () { return _this.convertPropertyBinding(boundValue_1); },\n                                params: params_2\n                            });\n                        }\n                    }\n                    else {\n                        // class prop\n                        _this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, function () {\n                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n                                literal(elementIndex), literal(attrName_1), _this.convertPropertyBinding(value_2)\n                            ], params_2);\n                        });\n                    }\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);\n        }\n        if (attributeBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);\n        }\n        // Traverse element child nodes\n        visitAll(this, element.children);\n        if (!isI18nRootElement && this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex, true);\n        }\n        if (!createSelfClosingInstruction) {\n            // Finish element construction mode.\n            var span = element.endSourceSpan || element.sourceSpan;\n            if (isI18nRootElement) {\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\n            }\n            if (isNonBindableMode) {\n                this.creationInstruction(span, Identifiers$1.enableBindings);\n            }\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitTemplate = function (template) {\n        var _this = this;\n        var NG_TEMPLATE_TAG_NAME = 'ng-template';\n        var templateIndex = this.allocateDataSlot();\n        if (this.i18n) {\n            this.i18n.appendTemplate(template.i18n, templateIndex);\n        }\n        var tagName = sanitizeIdentifier(template.tagName || '');\n        var contextName = \"\" + this.contextName + (tagName ? '_' + tagName : '') + \"_\" + templateIndex;\n        var templateName = contextName + \"_Template\";\n        var parameters = [\n            literal(templateIndex),\n            variable(templateName),\n            // We don't care about the tag's namespace here, because we infer\n            // it based on the parent nodes inside the template instruction.\n            literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName),\n        ];\n        // find directives matching on a given <ng-template> node\n        this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\n        // prepare attributes parameter (including attributes used for directive matching)\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(partitionArray(template.attributes, hasI18nMeta), 2), i18nStaticAttrs = _a[0], staticAttrs = _a[1];\n        var attrsExprs = this.getAttributeExpressions(staticAttrs, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs, i18nStaticAttrs);\n        parameters.push(this.addAttrsToConsts(attrsExprs));\n        // local refs (ex.: <ng-template #foo>)\n        if (template.references && template.references.length) {\n            var refs = this.prepareRefsArray(template.references);\n            parameters.push(this.addToConsts(refs));\n            parameters.push(importExpr(Identifiers$1.templateRefExtractor));\n        }\n        // Create the template function\n        var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);\n        // Nested templates must not be visited until after their parent templates have completed\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n        // be able to support bindings in nested templates to local refs that occur after the\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n        this._nestedTemplateFns.push(function () {\n            var _a;\n            var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this._ngContentReservedSlots.length + _this._ngContentSelectorsOffset, template.i18n);\n            _this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));\n            if (templateVisitor._ngContentReservedSlots.length) {\n                (_a = _this._ngContentReservedSlots).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(templateVisitor._ngContentReservedSlots));\n            }\n        });\n        // e.g. template(1, MyComp_Template_1)\n        this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, function () {\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n            return trimTrailingNulls(parameters);\n        });\n        // handle property bindings e.g. property('ngForOf', ctx.items), et al;\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\n        // Only add normal input/output binding instructions on explicit <ng-template> elements.\n        if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n            var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(partitionArray(template.inputs, hasI18nMeta), 2), i18nInputs = _b[0], inputs = _b[1];\n            var i18nAttrs = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(i18nStaticAttrs, i18nInputs);\n            // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n            // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n            // elements, in case of inline templates, corresponding instructions will be generated in the\n            // nested template function.\n            if (i18nAttrs.length > 0) {\n                this.i18nAttributesInstruction(templateIndex, i18nAttrs, template.sourceSpan);\n            }\n            // Add the input bindings\n            if (inputs.length > 0) {\n                this.templatePropertyBindings(templateIndex, inputs);\n            }\n            // Generate listeners for directive output\n            if (template.outputs.length > 0) {\n                var listeners = template.outputs.map(function (outputAst) { return ({\n                    sourceSpan: outputAst.sourceSpan,\n                    params: _this.prepareListenerParameter('ng_template', outputAst, templateIndex)\n                }); });\n                this.creationInstructionChain(Identifiers$1.listener, listeners);\n            }\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitBoundText = function (text) {\n        var _this = this;\n        if (this.i18n) {\n            var value_3 = text.value.visit(this._valueConverter);\n            this.allocateBindingSlots(value_3);\n            if (value_3 instanceof Interpolation) {\n                this.i18n.appendBoundText(text.i18n);\n                this.i18nAppendBindings(value_3.expressions);\n            }\n            return;\n        }\n        var nodeIndex = this.allocateDataSlot();\n        this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);\n        var value = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () { return _this.getUpdateInstructionArguments(value); });\n        }\n        else {\n            error('Text nodes should be interpolated and never bound directly.');\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitText = function (text) {\n        // when a text element is located within a translatable\n        // block, we exclude this text element from instructions set,\n        // since it will be captured in i18n content and processed at runtime\n        if (!this.i18n) {\n            this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n        }\n    };\n    TemplateDefinitionBuilder.prototype.visitIcu = function (icu) {\n        var initWasInvoked = false;\n        // if an ICU was created outside of i18n block, we still treat\n        // it as a translatable entity and invoke i18nStart and i18nEnd\n        // to generate i18n context and the necessary instructions\n        if (!this.i18n) {\n            initWasInvoked = true;\n            this.i18nStart(null, icu.i18n, true);\n        }\n        var i18n = this.i18n;\n        var vars = this.i18nBindProps(icu.vars);\n        var placeholders = this.i18nBindProps(icu.placeholders);\n        // output ICU directly and keep ICU reference in context\n        var message = icu.i18n;\n        // we always need post-processing function for ICUs, to make sure that:\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n        // inside ICUs)\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n        var transformFn = function (raw) {\n            var params = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, vars), placeholders);\n            var formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);\n            return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n        };\n        // in case the whole i18n message is a single ICU - we do not need to\n        // create a separate top-level translation, we can use the root ref instead\n        // and make this ICU a top-level translation\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\n        if (isSingleI18nIcu(i18n.meta)) {\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n        }\n        else {\n            // output ICU directly and keep ICU reference in context\n            var ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n        }\n        if (initWasInvoked) {\n            this.i18nEnd(null, true);\n        }\n        return null;\n    };\n    TemplateDefinitionBuilder.prototype.allocateDataSlot = function () {\n        return this._dataIndex++;\n    };\n    TemplateDefinitionBuilder.prototype.getConstCount = function () {\n        return this._dataIndex;\n    };\n    TemplateDefinitionBuilder.prototype.getVarCount = function () {\n        return this._pureFunctionSlots;\n    };\n    TemplateDefinitionBuilder.prototype.getConsts = function () {\n        return this._constants;\n    };\n    TemplateDefinitionBuilder.prototype.getNgContentSelectors = function () {\n        return this._ngContentReservedSlots.length ?\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n            null;\n    };\n    TemplateDefinitionBuilder.prototype.bindingContext = function () {\n        return \"\" + this._bindingContext++;\n    };\n    TemplateDefinitionBuilder.prototype.templatePropertyBindings = function (templateIndex, attrs) {\n        var _this = this;\n        var propertyBindings = [];\n        attrs.forEach(function (input) {\n            if (input instanceof BoundAttribute) {\n                var value_4 = input.value.visit(_this._valueConverter);\n                if (value_4 !== undefined) {\n                    _this.allocateBindingSlots(value_4);\n                    if (value_4 instanceof Interpolation) {\n                        // Params typically contain attribute namespace and value sanitizer, which is applicable\n                        // for regular HTML elements, but not applicable for <ng-template> (since props act as\n                        // inputs to directives), so keep params array empty.\n                        var params = [];\n                        // prop=\"{{value}}\" case\n                        _this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value_4), templateIndex, input.name, input, value_4, params);\n                    }\n                    else {\n                        // [prop]=\"value\" case\n                        propertyBindings.push({\n                            name: input.name,\n                            sourceSpan: input.sourceSpan,\n                            value: function () { return _this.convertPropertyBinding(value_4); }\n                        });\n                    }\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);\n        }\n    };\n    // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n    TemplateDefinitionBuilder.prototype.instructionFn = function (fns, span, reference, paramsOrFn, prepend) {\n        if (prepend === void 0) { prepend = false; }\n        fns[prepend ? 'unshift' : 'push'](function () {\n            var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n            return instruction(span, reference, params).toStmt();\n        });\n    };\n    TemplateDefinitionBuilder.prototype.processStylingUpdateInstruction = function (elementIndex, instruction) {\n        var _this = this;\n        var allocateBindingSlots = 0;\n        if (instruction) {\n            var calls_1 = [];\n            instruction.calls.forEach(function (call) {\n                allocateBindingSlots += call.allocateBindingSlots;\n                calls_1.push({\n                    sourceSpan: call.sourceSpan,\n                    value: function () {\n                        return call.params(function (value) { return (call.supportsInterpolation && value instanceof Interpolation) ?\n                            _this.getUpdateInstructionArguments(value) :\n                            _this.convertPropertyBinding(value); });\n                    }\n                });\n            });\n            this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls_1);\n        }\n        return allocateBindingSlots;\n    };\n    TemplateDefinitionBuilder.prototype.creationInstruction = function (span, reference, paramsOrFn, prepend) {\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    };\n    TemplateDefinitionBuilder.prototype.creationInstructionChain = function (reference, calls) {\n        var span = calls.length ? calls[0].sourceSpan : null;\n        this._creationCodeFns.push(function () {\n            return chainedInstruction(reference, calls.map(function (call) { return call.params(); }), span).toStmt();\n        });\n    };\n    TemplateDefinitionBuilder.prototype.updateInstructionWithAdvance = function (nodeIndex, span, reference, paramsOrFn) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n        this.updateInstruction(span, reference, paramsOrFn);\n    };\n    TemplateDefinitionBuilder.prototype.updateInstruction = function (span, reference, paramsOrFn) {\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    };\n    TemplateDefinitionBuilder.prototype.updateInstructionChain = function (reference, bindings) {\n        var span = bindings.length ? bindings[0].sourceSpan : null;\n        this._updateCodeFns.push(function () {\n            var calls = bindings.map(function (property) {\n                var value = property.value();\n                var fnParams = Array.isArray(value) ? value : [value];\n                if (property.params) {\n                    fnParams.push.apply(fnParams, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(property.params));\n                }\n                if (property.name) {\n                    // We want the property name to always be the first function parameter.\n                    fnParams.unshift(literal(property.name));\n                }\n                return fnParams;\n            });\n            return chainedInstruction(reference, calls, span).toStmt();\n        });\n    };\n    TemplateDefinitionBuilder.prototype.updateInstructionChainWithAdvance = function (nodeIndex, reference, bindings) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n        this.updateInstructionChain(reference, bindings);\n    };\n    TemplateDefinitionBuilder.prototype.addAdvanceInstructionIfNecessary = function (nodeIndex, span) {\n        if (nodeIndex !== this._currentIndex) {\n            var delta = nodeIndex - this._currentIndex;\n            if (delta < 1) {\n                throw new Error('advance instruction can only go forwards');\n            }\n            this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);\n            this._currentIndex = nodeIndex;\n        }\n    };\n    TemplateDefinitionBuilder.prototype.allocatePureFunctionSlots = function (numSlots) {\n        var originalSlots = this._pureFunctionSlots;\n        this._pureFunctionSlots += numSlots;\n        return originalSlots;\n    };\n    TemplateDefinitionBuilder.prototype.allocateBindingSlots = function (value) {\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    };\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n    TemplateDefinitionBuilder.prototype.getImplicitReceiverExpr = function () {\n        if (this._implicitReceiverExpr) {\n            return this._implicitReceiverExpr;\n        }\n        return this._implicitReceiverExpr = this.level === 0 ?\n            variable(CONTEXT_NAME) :\n            this._bindingScope.getOrCreateSharedContextVar(0);\n    };\n    TemplateDefinitionBuilder.prototype.convertPropertyBinding = function (value) {\n        var _a;\n        var convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple, function () { return error('Unexpected interpolation'); });\n        var valExpr = convertedPropertyBinding.currValExpr;\n        (_a = this._tempVariables).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(convertedPropertyBinding.stmts));\n        return valExpr;\n    };\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n    TemplateDefinitionBuilder.prototype.getUpdateInstructionArguments = function (value) {\n        var _a;\n        var _b = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()), args = _b.args, stmts = _b.stmts;\n        (_a = this._tempVariables).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts));\n        return args;\n    };\n    TemplateDefinitionBuilder.prototype.matchDirectives = function (elementName, elOrTpl) {\n        var _this = this;\n        if (this.directiveMatcher) {\n            var selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\n            this.directiveMatcher.match(selector, function (cssSelector, staticType) {\n                _this.directives.add(staticType);\n            });\n        }\n    };\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n    TemplateDefinitionBuilder.prototype.getAttributeExpressions = function (renderAttributes, inputs, outputs, styles, templateAttrs, i18nAttrs) {\n        if (templateAttrs === void 0) { templateAttrs = []; }\n        if (i18nAttrs === void 0) { i18nAttrs = []; }\n        var alreadySeen = new Set();\n        var attrExprs = [];\n        var ngProjectAsAttr;\n        renderAttributes.forEach(function (attr) {\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n                ngProjectAsAttr = attr;\n            }\n            attrExprs.push.apply(attrExprs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getAttributeNameLiterals(attr.name), [asLiteral(attr.value)]));\n        });\n        // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n        // ngProjectAs marker in the attribute name slot.\n        if (ngProjectAsAttr) {\n            attrExprs.push.apply(attrExprs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getNgProjectAsLiteral(ngProjectAsAttr)));\n        }\n        function addAttrExpr(key, value) {\n            if (typeof key === 'string') {\n                if (!alreadySeen.has(key)) {\n                    attrExprs.push.apply(attrExprs, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(getAttributeNameLiterals(key)));\n                    value !== undefined && attrExprs.push(value);\n                    alreadySeen.add(key);\n                }\n            }\n            else {\n                attrExprs.push(literal(key));\n            }\n        }\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n        // as single property value cell by cell.\n        if (styles) {\n            styles.populateInitialStylingAttrs(attrExprs);\n        }\n        if (inputs.length || outputs.length) {\n            var attrsLengthBeforeInputs = attrExprs.length;\n            for (var i = 0; i < inputs.length; i++) {\n                var input = inputs[i];\n                // We don't want the animation and attribute bindings in the\n                // attributes array since they aren't used for directive matching.\n                if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {\n                    addAttrExpr(input.name);\n                }\n            }\n            for (var i = 0; i < outputs.length; i++) {\n                var output = outputs[i];\n                if (output.type !== 1 /* Animation */) {\n                    addAttrExpr(output.name);\n                }\n            }\n            // this is a cheap way of adding the marker only after all the input/output\n            // values have been filtered (by not including the animation ones) and added\n            // to the expressions. The marker is important because it tells the runtime\n            // code that this is where attributes without values start...\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));\n            }\n        }\n        if (templateAttrs.length) {\n            attrExprs.push(literal(4 /* Template */));\n            templateAttrs.forEach(function (attr) { return addAttrExpr(attr.name); });\n        }\n        if (i18nAttrs.length) {\n            attrExprs.push(literal(6 /* I18n */));\n            i18nAttrs.forEach(function (attr) { return addAttrExpr(attr.name); });\n        }\n        return attrExprs;\n    };\n    TemplateDefinitionBuilder.prototype.addToConsts = function (expression) {\n        if (isNull(expression)) {\n            return TYPED_NULL_EXPR;\n        }\n        // Try to reuse a literal that's already in the array, if possible.\n        for (var i = 0; i < this._constants.length; i++) {\n            if (this._constants[i].isEquivalent(expression)) {\n                return literal(i);\n            }\n        }\n        return literal(this._constants.push(expression) - 1);\n    };\n    TemplateDefinitionBuilder.prototype.addAttrsToConsts = function (attrs) {\n        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    };\n    TemplateDefinitionBuilder.prototype.prepareRefsArray = function (references) {\n        var _this = this;\n        if (!references || references.length === 0) {\n            return TYPED_NULL_EXPR;\n        }\n        var refsParam = flatten(references.map(function (reference) {\n            var slot = _this.allocateDataSlot();\n            // Generate the update temporary.\n            var variableName = _this._bindingScope.freshReferenceName();\n            var retrievalLevel = _this.level;\n            var lhs = variable(variableName);\n            _this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, function (scope, relativeLevel) {\n                // e.g. nextContext(2);\n                var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n                // e.g. const $foo$ = reference(1);\n                var refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));\n                return nextContextStmt.concat(refExpr.toConstDecl());\n            }, true);\n            return [reference.name, reference.value];\n        }));\n        return asLiteral(refsParam);\n    };\n    TemplateDefinitionBuilder.prototype.prepareListenerParameter = function (tagName, outputAst, index) {\n        var _this = this;\n        return function () {\n            var eventName = outputAst.name;\n            var bindingFnName = outputAst.type === 1 /* Animation */ ?\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\n                sanitizeIdentifier(eventName);\n            var handlerName = _this.templateName + \"_\" + tagName + \"_\" + bindingFnName + \"_\" + index + \"_listener\";\n            var scope = _this._bindingScope.nestedScope(_this._bindingScope.bindingLevel);\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\n        };\n    };\n    return TemplateDefinitionBuilder;\n}());\nvar ValueConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ValueConverter, _super);\n    function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n        var _this = _super.call(this) || this;\n        _this.constantPool = constantPool;\n        _this.allocateSlot = allocateSlot;\n        _this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n        _this.definePipe = definePipe;\n        _this._pipeBindExprs = [];\n        return _this;\n    }\n    // AstMemoryEfficientTransformer\n    ValueConverter.prototype.visitPipe = function (pipe, context) {\n        // Allocate a slot to create the pipe\n        var slot = this.allocateSlot();\n        var slotPseudoLocal = \"PIPE:\" + slot;\n        // Allocate one slot for the result plus one slot per pipe argument\n        var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n        var target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n        var _a = pipeBindingCallInfo(pipe.args), identifier = _a.identifier, isVarLength = _a.isVarLength;\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n        var args = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([pipe.exp], pipe.args);\n        var convertedArgs = isVarLength ?\n            this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n            this.visitAll(args);\n        var pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)\n        ], convertedArgs));\n        this._pipeBindExprs.push(pipeBindExpr);\n        return pipeBindExpr;\n    };\n    ValueConverter.prototype.updatePipeSlotOffsets = function (bindingSlots) {\n        this._pipeBindExprs.forEach(function (pipe) {\n            // update the slot offset arg (index 1) to account for binding slots\n            var slotOffset = pipe.args[1];\n            slotOffset.value += bindingSlots;\n        });\n    };\n    ValueConverter.prototype.visitLiteralArray = function (array, context) {\n        var _this = this;\n        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {\n            // If the literal has calculated (non-literal) elements transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            var literal = literalArr(values);\n            return getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n        });\n    };\n    ValueConverter.prototype.visitLiteralMap = function (map, context) {\n        var _this = this;\n        return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {\n            // If the literal has calculated (non-literal) elements  transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            var literal = literalMap(values.map(function (value, index) { return ({ key: map.keys[index].key, value: value, quoted: map.keys[index].quoted }); }));\n            return getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n        });\n    };\n    return ValueConverter;\n}(AstMemoryEfficientTransformer));\n// Pipes always have at least one parameter, the value they operate on\nvar pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];\nfunction pipeBindingCallInfo(args) {\n    var identifier = pipeBindingIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pipeBindV,\n        isVarLength: !identifier,\n    };\n}\nvar pureFunctionIdentifiers = [\n    Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4,\n    Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8\n];\nfunction pureFunctionCallInfo(args) {\n    var identifier = pureFunctionIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pureFunctionV,\n        isVarLength: !identifier,\n    };\n}\nfunction instruction(span, reference, params) {\n    return importExpr(reference, null, span).callFn(params, span);\n}\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff) {\n    return importExpr(Identifiers$1.nextContext)\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n    var _a = constantPool.getLiteralFactory(literal$1), literalFactory = _a.literalFactory, literalFactoryArguments = _a.literalFactoryArguments;\n    // Allocate 1 slot for the result plus 1 per argument\n    var startSlot = allocateSlots(1 + literalFactoryArguments.length);\n    var _b = pureFunctionCallInfo(literalFactoryArguments), identifier = _b.identifier, isVarLength = _b.isVarLength;\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n    var args = [literal(startSlot), literalFactory];\n    if (isVarLength) {\n        args.push(literalArr(literalFactoryArguments));\n    }\n    else {\n        args.push.apply(args, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(literalFactoryArguments));\n    }\n    return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name) {\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(splitNsName(name), 2), attributeNamespace = _a[0], attributeName = _a[1];\n    var nameLiteral = literal(attributeName);\n    if (attributeNamespace) {\n        return [\n            literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral\n        ];\n    }\n    return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\nvar SHARED_CONTEXT_KEY = '$$shared_ctx$$';\nvar BindingScope = /** @class */ (function () {\n    function BindingScope(bindingLevel, parent) {\n        if (bindingLevel === void 0) { bindingLevel = 0; }\n        if (parent === void 0) { parent = null; }\n        this.bindingLevel = bindingLevel;\n        this.parent = parent;\n        /** Keeps a map from local variables to their BindingData. */\n        this.map = new Map();\n        this.referenceNameIndex = 0;\n        this.restoreViewVariable = null;\n    }\n    BindingScope.createRootScope = function () {\n        return new BindingScope().set(0, '$event', variable('$event'));\n    };\n    BindingScope.prototype.get = function (name) {\n        var current = this;\n        while (current) {\n            var value = current.map.get(name);\n            if (value != null) {\n                if (current !== this) {\n                    // make a local copy and reset the `declare` state\n                    value = {\n                        retrievalLevel: value.retrievalLevel,\n                        lhs: value.lhs,\n                        declareLocalCallback: value.declareLocalCallback,\n                        declare: false,\n                        priority: value.priority,\n                        localRef: value.localRef\n                    };\n                    // Cache the value locally.\n                    this.map.set(name, value);\n                    // Possibly generate a shared context var\n                    this.maybeGenerateSharedContextVar(value);\n                    this.maybeRestoreView(value.retrievalLevel, value.localRef);\n                }\n                if (value.declareLocalCallback && !value.declare) {\n                    value.declare = true;\n                }\n                return value.lhs;\n            }\n            current = current.parent;\n        }\n        // If we get to this point, we are looking for a property on the top level component\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n        // local var we used to store the component context, e.g. const $comp$ = x();\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    };\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n    BindingScope.prototype.set = function (retrievalLevel, name, lhs, priority, declareLocalCallback, localRef) {\n        if (priority === void 0) { priority = 0 /* DEFAULT */; }\n        if (this.map.has(name)) {\n            if (localRef) {\n                // Do not throw an error if it's a local ref and do not update existing value,\n                // so the first defined ref is always returned.\n                return this;\n            }\n            error(\"The name \" + name + \" is already defined in scope to be \" + this.map.get(name));\n        }\n        this.map.set(name, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declare: false,\n            declareLocalCallback: declareLocalCallback,\n            priority: priority,\n            localRef: localRef || false\n        });\n        return this;\n    };\n    // Implemented as part of LocalResolver.\n    BindingScope.prototype.getLocal = function (name) {\n        return this.get(name);\n    };\n    // Implemented as part of LocalResolver.\n    BindingScope.prototype.notifyImplicitReceiverUse = function () {\n        if (this.bindingLevel !== 0) {\n            // Since the implicit receiver is accessed in an embedded view, we need to\n            // ensure that we declare a shared context variable for the current template\n            // in the update variables.\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n        }\n    };\n    BindingScope.prototype.nestedScope = function (level) {\n        var newScope = new BindingScope(level, this);\n        if (level > 0)\n            newScope.generateSharedContextVar(0);\n        return newScope;\n    };\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n    BindingScope.prototype.getOrCreateSharedContextVar = function (retrievalLevel) {\n        var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n        if (!this.map.has(bindingKey)) {\n            this.generateSharedContextVar(retrievalLevel);\n        }\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return this.map.get(bindingKey).lhs;\n    };\n    BindingScope.prototype.getSharedContextName = function (retrievalLevel) {\n        var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    };\n    BindingScope.prototype.maybeGenerateSharedContextVar = function (value) {\n        if (value.priority === 1 /* CONTEXT */ &&\n            value.retrievalLevel < this.bindingLevel) {\n            var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n            if (sharedCtxObj) {\n                sharedCtxObj.declare = true;\n            }\n            else {\n                this.generateSharedContextVar(value.retrievalLevel);\n            }\n        }\n    };\n    BindingScope.prototype.generateSharedContextVar = function (retrievalLevel) {\n        var lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declareLocalCallback: function (scope, relativeLevel) {\n                // const ctx_r0 = nextContext(2);\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n            },\n            declare: false,\n            priority: 2 /* SHARED_CONTEXT */,\n            localRef: false\n        });\n    };\n    BindingScope.prototype.getComponentProperty = function (name) {\n        var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n        componentValue.declare = true;\n        this.maybeRestoreView(0, false);\n        return componentValue.lhs.prop(name);\n    };\n    BindingScope.prototype.maybeRestoreView = function (retrievalLevel, localRefLookup) {\n        // We want to restore the current view in listener fns if:\n        // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\n        // than using the ctx arg. In this case, the retrieval and binding level will be different.\n        // 2 - we are looking up a local ref, which requires restoring the view where the local\n        // ref is stored\n        if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\n            if (!this.parent.restoreViewVariable) {\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n            }\n            this.restoreViewVariable = this.parent.restoreViewVariable;\n        }\n    };\n    BindingScope.prototype.restoreViewStatement = function () {\n        // restoreView($state$);\n        return this.restoreViewVariable ?\n            [instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]).toStmt()] :\n            [];\n    };\n    BindingScope.prototype.viewSnapshotStatements = function () {\n        // const $state$ = getCurrentView();\n        var getCurrentViewInstruction = instruction(null, Identifiers$1.getCurrentView, []);\n        return this.restoreViewVariable ?\n            [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :\n            [];\n    };\n    BindingScope.prototype.isListenerScope = function () {\n        return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    };\n    BindingScope.prototype.variableDeclarations = function () {\n        var _this = this;\n        var currentContextLevel = 0;\n        return Array.from(this.map.values())\n            .filter(function (value) { return value.declare; })\n            .sort(function (a, b) { return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority; })\n            .reduce(function (stmts, value) {\n            var levelDiff = _this.bindingLevel - value.retrievalLevel;\n            var currStmts = value.declareLocalCallback(_this, levelDiff - currentContextLevel);\n            currentContextLevel = levelDiff;\n            return stmts.concat(currStmts);\n        }, []);\n    };\n    BindingScope.prototype.freshReferenceName = function () {\n        var current = this;\n        // Find the top scope as it maintains the global reference count\n        while (current.parent)\n            current = current.parent;\n        var ref = \"\" + REFERENCE_PREFIX + current.referenceNameIndex++;\n        return ref;\n    };\n    return BindingScope;\n}());\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(elementName, attributes) {\n    var cssSelector = new CssSelector();\n    var elementNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elementNameNoNs);\n    Object.getOwnPropertyNames(attributes).forEach(function (name) {\n        var nameNoNs = splitNsName(name)[1];\n        var value = attributes[name];\n        cssSelector.addAttribute(nameNoNs, value);\n        if (name.toLowerCase() === 'class') {\n            var classes = value.trim().split(/\\s+/);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    });\n    return cssSelector;\n}\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    var parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n    return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];\n}\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.propertyInterpolate;\n        case 3:\n            return Identifiers$1.propertyInterpolate1;\n        case 5:\n            return Identifiers$1.propertyInterpolate2;\n        case 7:\n            return Identifiers$1.propertyInterpolate3;\n        case 9:\n            return Identifiers$1.propertyInterpolate4;\n        case 11:\n            return Identifiers$1.propertyInterpolate5;\n        case 13:\n            return Identifiers$1.propertyInterpolate6;\n        case 15:\n            return Identifiers$1.propertyInterpolate7;\n        case 17:\n            return Identifiers$1.propertyInterpolate8;\n        default:\n            return Identifiers$1.propertyInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 3:\n            return Identifiers$1.attributeInterpolate1;\n        case 5:\n            return Identifiers$1.attributeInterpolate2;\n        case 7:\n            return Identifiers$1.attributeInterpolate3;\n        case 9:\n            return Identifiers$1.attributeInterpolate4;\n        case 11:\n            return Identifiers$1.attributeInterpolate5;\n        case 13:\n            return Identifiers$1.attributeInterpolate6;\n        case 15:\n            return Identifiers$1.attributeInterpolate7;\n        case 17:\n            return Identifiers$1.attributeInterpolate8;\n        default:\n            return Identifiers$1.attributeInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.textInterpolate;\n        case 3:\n            return Identifiers$1.textInterpolate1;\n        case 5:\n            return Identifiers$1.textInterpolate2;\n        case 7:\n            return Identifiers$1.textInterpolate3;\n        case 9:\n            return Identifiers$1.textInterpolate4;\n        case 11:\n            return Identifiers$1.textInterpolate5;\n        case 13:\n            return Identifiers$1.textInterpolate6;\n        case 15:\n            return Identifiers$1.textInterpolate7;\n        case 17:\n            return Identifiers$1.textInterpolate8;\n        default:\n            return Identifiers$1.textInterpolateV;\n    }\n}\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nfunction parseTemplate(template, templateUrl, options) {\n    if (options === void 0) { options = {}; }\n    var interpolationConfig = options.interpolationConfig, preserveWhitespaces = options.preserveWhitespaces, enableI18nLegacyMessageIdFormat = options.enableI18nLegacyMessageIdFormat;\n    var bindingParser = makeBindingParser(interpolationConfig);\n    var htmlParser = new HtmlParser();\n    var parseResult = htmlParser.parse(template, templateUrl, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));\n    if (parseResult.errors && parseResult.errors.length > 0) {\n        return {\n            errors: parseResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n    }\n    var rootNodes = parseResult.rootNodes;\n    // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng xi18n) relies on a raw content to generate\n    // message ids\n    var i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n    rootNodes = visitAll$1(i18nMetaVisitor, rootNodes);\n    if (!preserveWhitespaces) {\n        rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);\n        // run i18n meta visitor again in case whitespaces are removed (because that might affect\n        // generated i18n message content) and first pass indicated that i18n content is present in a\n        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n        // mimic existing extraction process (ng xi18n)\n        if (i18nMetaVisitor.hasI18nMeta) {\n            rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n        }\n    }\n    var _a = htmlAstToRender3Ast(rootNodes, bindingParser), nodes = _a.nodes, errors = _a.errors, styleUrls = _a.styleUrls, styles = _a.styles, ngContentSelectors = _a.ngContentSelectors;\n    if (errors && errors.length > 0) {\n        return { errors: errors, nodes: [], styleUrls: [], styles: [], ngContentSelectors: [] };\n    }\n    return { nodes: nodes, styleUrls: styleUrls, styles: styles, ngContentSelectors: ngContentSelectors };\n}\nvar elementRegistry = new DomElementSchemaRegistry();\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nfunction makeBindingParser(interpolationConfig) {\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);\n}\nfunction resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n        case SecurityContext.HTML:\n            return importExpr(Identifiers$1.sanitizeHtml);\n        case SecurityContext.SCRIPT:\n            return importExpr(Identifiers$1.sanitizeScript);\n        case SecurityContext.STYLE:\n            // the compiler does not fill in an instruction for [style.prop?] binding\n            // values because the style algorithm knows internally what props are subject\n            // to sanitization (only [attr.style] values are explicitly sanitized)\n            return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;\n        case SecurityContext.URL:\n            return importExpr(Identifiers$1.sanitizeUrl);\n        case SecurityContext.RESOURCE_URL:\n            return importExpr(Identifiers$1.sanitizeResourceUrl);\n        default:\n            return null;\n    }\n}\nfunction isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof Element;\n}\nfunction isTextNode(node) {\n    return node instanceof Text || node instanceof BoundText || node instanceof Icu;\n}\nfunction hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n}\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nvar NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(message, variable, closureVar, params, transformFn) {\n    if (params === void 0) { params = {}; }\n    var statements = [\n        declareI18nVariable(variable),\n        ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),\n    ];\n    if (transformFn) {\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n    }\n    return statements;\n}\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard() {\n    return typeofExpr(variable(NG_I18N_CLOSURE_MODE))\n        .notIdentical(literal('undefined', STRING_TYPE))\n        .and(variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EMPTY_ARRAY = [];\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nvar ATTR_REGEX = /attr\\.([^\\]]+)/;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n    var definitionMap = new DefinitionMap();\n    var selectors = parseSelectorToR3Selector(meta.selector);\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `selectors: [['', 'someDir', '']]`\n    if (selectors.length > 0) {\n        definitionMap.set('selectors', asLiteral(selectors));\n    }\n    if (meta.queries.length > 0) {\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n    if (meta.viewQueries.length) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    }\n    // e.g. `hostBindings: (rf, ctx) => { ... }\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n    // e.g 'inputs: {a: 'a'}`\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    // e.g 'outputs: {a: 'a'}`\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(function (e) { return literal(e); })));\n    }\n    return definitionMap;\n}\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature]`\n    var features = [];\n    var providers = meta.providers;\n    var viewProviders = meta.viewProviders;\n    if (providers || viewProviders) {\n        var args = [providers || new LiteralArrayExpr([])];\n        if (viewProviders) {\n            args.push(viewProviders);\n        }\n        features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));\n    }\n    if (meta.usesInheritance) {\n        features.push(importExpr(Identifiers$1.InheritDefinitionFeature));\n    }\n    if (meta.fullInheritance) {\n        features.push(importExpr(Identifiers$1.CopyDefinitionFeature));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        features.push(importExpr(Identifiers$1.NgOnChangesFeature));\n    }\n    if (features.length) {\n        definitionMap.set('features', literalArr(features));\n    }\n}\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    var expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()]);\n    var typeParams = createDirectiveTypeParams(meta);\n    var type = expressionType(importExpr(Identifiers$1.DirectiveDefWithMeta, typeParams));\n    return { expression: expression, type: type };\n}\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    var e_1, _a;\n    var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    var selector = meta.selector && CssSelector.parse(meta.selector);\n    var firstSelector = selector && selector[0];\n    // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n    if (firstSelector) {\n        var selectorAttributes = firstSelector.getAttrs();\n        if (selectorAttributes.length) {\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(function (value) { return value != null ? literal(value) : literal(undefined); })), \n            /* forceShared */ true));\n        }\n    }\n    // Generate the CSS matcher that recognize directive\n    var directiveMatcher = null;\n    if (meta.directives.length > 0) {\n        var matcher = new SelectorMatcher();\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(meta.directives), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = _c.value, selector_1 = _d.selector, expression_1 = _d.expression;\n                matcher.addSelectables(CssSelector.parse(selector_1), expression_1);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        directiveMatcher = matcher;\n    }\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n    var templateTypeName = meta.name;\n    var templateName = templateTypeName ? templateTypeName + \"_Template\" : null;\n    var directivesUsed = new Set();\n    var pipesUsed = new Set();\n    var changeDetection = meta.changeDetection;\n    var template = meta.template;\n    var templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n    var ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n    // e.g. `decls: 2`\n    definitionMap.set('decls', literal(templateBuilder.getConstCount()));\n    // e.g. `vars: 2`\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\n    // e.g. `consts: [['one', 'two'], ['three', 'four']]\n    var consts = templateBuilder.getConsts();\n    if (consts.length > 0) {\n        definitionMap.set('consts', literalArr(consts));\n    }\n    definitionMap.set('template', templateFunctionExpression);\n    // e.g. `directives: [MyDirective]`\n    if (directivesUsed.size) {\n        var directivesExpr = literalArr(Array.from(directivesUsed));\n        if (meta.wrapDirectivesAndPipesInClosure) {\n            directivesExpr = fn([], [new ReturnStatement(directivesExpr)]);\n        }\n        definitionMap.set('directives', directivesExpr);\n    }\n    // e.g. `pipes: [MyPipe]`\n    if (pipesUsed.size) {\n        var pipesExpr = literalArr(Array.from(pipesUsed));\n        if (meta.wrapDirectivesAndPipesInClosure) {\n            pipesExpr = fn([], [new ReturnStatement(pipesExpr)]);\n        }\n        definitionMap.set('pipes', pipesExpr);\n    }\n    if (meta.encapsulation === null) {\n        meta.encapsulation = ViewEncapsulation.Emulated;\n    }\n    // e.g. `styles: [str1, str2]`\n    if (meta.styles && meta.styles.length) {\n        var styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n            meta.styles;\n        var strings = styleValues.map(function (str) { return literal(str); });\n        definitionMap.set('styles', literalArr(strings));\n    }\n    else if (meta.encapsulation === ViewEncapsulation.Emulated) {\n        // If there is no style, don't generate css selectors on elements\n        meta.encapsulation = ViewEncapsulation.None;\n    }\n    // Only set view encapsulation if it's not the default value\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\n    }\n    // e.g. `animation: [trigger('123', [])]`\n    if (meta.animations !== null) {\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\n    }\n    // Only set the change detection flag if it's defined and it's not the default.\n    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\n        definitionMap.set('changeDetection', literal(changeDetection));\n    }\n    var expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()]);\n    var typeParams = createDirectiveTypeParams(meta);\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n    var type = expressionType(importExpr(Identifiers$1.ComponentDefWithMeta, typeParams));\n    return { expression: expression, type: type };\n}\n/**\n * A wrapper around `compileDirective` which depends on render2 global analysis data as its input\n * instead of the `R3DirectiveMetadata`.\n *\n * `R3DirectiveMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n * information.\n */\nfunction compileDirectiveFromRender2(outputCtx, directive, reflector, bindingParser) {\n    var name = identifierName(directive.type);\n    name || error(\"Cannot resolver the name of \" + directive.type);\n    var definitionField = outputCtx.constantPool.propertyNameOf(1 /* Directive */);\n    var meta = directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector);\n    var res = compileDirectiveFromMetadata(meta, outputCtx.constantPool, bindingParser);\n    var factoryRes = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, meta), { injectFn: Identifiers$1.directiveInject, target: R3FactoryTarget.Directive }));\n    var ngFactoryDefStatement = new ClassStmt(name, null, [new ClassField('fac', INFERRED_TYPE, [StmtModifier.Static], factoryRes.factory)], [], new ClassMethod(null, [], []), []);\n    var directiveDefStatement = new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []);\n    // Create the partial class to be merged with the actual class.\n    outputCtx.statements.push(ngFactoryDefStatement, directiveDefStatement);\n}\n/**\n * A wrapper around `compileComponent` which depends on render2 global analysis data as its input\n * instead of the `R3DirectiveMetadata`.\n *\n * `R3ComponentMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n * information.\n */\nfunction compileComponentFromRender2(outputCtx, component, render3Ast, reflector, bindingParser, directiveTypeBySel, pipeTypeByName) {\n    var name = identifierName(component.type);\n    name || error(\"Cannot resolver the name of \" + component.type);\n    var definitionField = outputCtx.constantPool.propertyNameOf(2 /* Component */);\n    var summary = component.toSummary();\n    // Compute the R3ComponentMetadata from the CompileDirectiveMetadata\n    var meta = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directiveMetadataFromGlobalMetadata(component, outputCtx, reflector)), { selector: component.selector, template: { nodes: render3Ast.nodes, ngContentSelectors: render3Ast.ngContentSelectors }, directives: [], pipes: typeMapToExpressionMap(pipeTypeByName, outputCtx), viewQueries: queriesFromGlobalMetadata(component.viewQueries, outputCtx), wrapDirectivesAndPipesInClosure: false, styles: (summary.template && summary.template.styles) || EMPTY_ARRAY, encapsulation: (summary.template && summary.template.encapsulation) || ViewEncapsulation.Emulated, interpolation: DEFAULT_INTERPOLATION_CONFIG, animations: null, viewProviders: component.viewProviders.length > 0 ? new WrappedNodeExpr(component.viewProviders) : null, relativeContextFilePath: '', i18nUseExternalIds: true });\n    var res = compileComponentFromMetadata(meta, outputCtx.constantPool, bindingParser);\n    var factoryRes = compileFactoryFunction(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, meta), { injectFn: Identifiers$1.directiveInject, target: R3FactoryTarget.Directive }));\n    var ngFactoryDefStatement = new ClassStmt(name, null, [new ClassField('fac', INFERRED_TYPE, [StmtModifier.Static], factoryRes.factory)], [], new ClassMethod(null, [], []), []);\n    var componentDefStatement = new ClassStmt(name, null, [new ClassField(definitionField, INFERRED_TYPE, [StmtModifier.Static], res.expression)], [], new ClassMethod(null, [], []), []);\n    // Create the partial class to be merged with the actual class.\n    outputCtx.statements.push(ngFactoryDefStatement, componentDefStatement);\n}\n/**\n * Compute `R3DirectiveMetadata` given `CompileDirectiveMetadata` and a `CompileReflector`.\n */\nfunction directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector) {\n    // The global-analysis based Ivy mode in ngc is no longer utilized/supported.\n    throw new Error('unsupported');\n}\n/**\n * Convert `CompileQueryMetadata` into `R3QueryMetadata`.\n */\nfunction queriesFromGlobalMetadata(queries, outputCtx) {\n    return queries.map(function (query) {\n        var read = null;\n        if (query.read && query.read.identifier) {\n            read = outputCtx.importExpr(query.read.identifier.reference);\n        }\n        return {\n            propertyName: query.propertyName,\n            first: query.first,\n            predicate: selectorsFromGlobalMetadata(query.selectors, outputCtx),\n            descendants: query.descendants,\n            read: read,\n            static: !!query.static\n        };\n    });\n}\n/**\n * Convert `CompileTokenMetadata` for query selectors into either an expression for a predicate\n * type, or a list of string predicates.\n */\nfunction selectorsFromGlobalMetadata(selectors, outputCtx) {\n    if (selectors.length > 1 || (selectors.length == 1 && selectors[0].value)) {\n        var selectorStrings = selectors.map(function (value) { return value.value; });\n        selectorStrings.some(function (value) { return !value; }) &&\n            error('Found a type among the string selectors expected');\n        return outputCtx.constantPool.getConstLiteral(literalArr(selectorStrings.map(function (value) { return literal(value); })));\n    }\n    if (selectors.length == 1) {\n        var first = selectors[0];\n        if (first.identifier) {\n            return outputCtx.importExpr(first.identifier.reference);\n        }\n    }\n    error('Unexpected query form');\n    return NULL_EXPR;\n}\nfunction prepareQueryParams(query, constantPool) {\n    var parameters = [getQueryPredicate(query, constantPool), literal(query.descendants)];\n    if (query.read) {\n        parameters.push(query.read);\n    }\n    return parameters;\n}\nfunction convertAttributesToExpressions(attributes) {\n    var e_2, _a;\n    var values = [];\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.getOwnPropertyNames(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var value = attributes[key];\n            values.push(literal(key), value);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return values;\n}\n// Define and update any content queries\nfunction createContentQueriesFunction(queries, constantPool, name) {\n    var e_3, _a;\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    try {\n        for (var queries_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(queries), queries_1_1 = queries_1.next(); !queries_1_1.done; queries_1_1 = queries_1.next()) {\n            var query = queries_1_1.value;\n            var queryInstruction = query.static ? Identifiers$1.staticContentQuery : Identifiers$1.contentQuery;\n            // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n            createStatements.push(importExpr(queryInstruction)\n                .callFn(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([variable('dirIndex')], prepareQueryParams(query, constantPool)))\n                .toStmt());\n            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n            var temporary = tempAllocator();\n            var getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);\n            var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n            var updateDirective = variable(CONTEXT_NAME)\n                .prop(query.propertyName)\n                .set(query.first ? temporary.prop('first') : temporary);\n            updateStatements.push(refresh.and(updateDirective).toStmt());\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (queries_1_1 && !queries_1_1.done && (_a = queries_1.return)) _a.call(queries_1);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    var contentQueriesFnName = name ? name + \"_ContentQueries\" : null;\n    return fn([\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n        new FnParam('dirIndex', null)\n    ], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, contentQueriesFnName);\n}\nfunction stringAsType(str) {\n    return expressionType(literal(str));\n}\nfunction stringMapAsType(map) {\n    var mapValues = Object.keys(map).map(function (key) {\n        var value = Array.isArray(map[key]) ? map[key][0] : map[key];\n        return {\n            key: key,\n            value: literal(value),\n            quoted: true,\n        };\n    });\n    return expressionType(literalMap(mapValues));\n}\nfunction stringArrayAsType(arr) {\n    return arr.length > 0 ? expressionType(literalArr(arr.map(function (value) { return literal(value); }))) :\n        NONE_TYPE;\n}\nfunction createDirectiveTypeParams(meta) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    var selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n    return [\n        typeWithParameters(meta.type.type, meta.typeArgumentCount),\n        selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\n        stringMapAsType(meta.inputs),\n        stringMapAsType(meta.outputs),\n        stringArrayAsType(meta.queries.map(function (q) { return q.propertyName; })),\n    ];\n}\n// Define and update any view queries\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    viewQueries.forEach(function (query) {\n        var queryInstruction = query.static ? Identifiers$1.staticViewQuery : Identifiers$1.viewQuery;\n        // creation, e.g. r3.viewQuery(somePredicate, true);\n        var queryDefinition = importExpr(queryInstruction).callFn(prepareQueryParams(query, constantPool));\n        createStatements.push(queryDefinition.toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        var temporary = tempAllocator();\n        var getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);\n        var refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n        var updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    var viewQueryFnName = name ? name + \"_Query\" : null;\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, viewQueryFnName);\n}\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n    var bindingContext = variable(CONTEXT_NAME);\n    var styleBuilder = new StylingBuilder(bindingContext);\n    var _a = hostBindingsMetadata.specialAttributes, styleAttr = _a.styleAttr, classAttr = _a.classAttr;\n    if (styleAttr !== undefined) {\n        styleBuilder.registerStyleAttr(styleAttr);\n    }\n    if (classAttr !== undefined) {\n        styleBuilder.registerClassAttr(classAttr);\n    }\n    var createStatements = [];\n    var updateStatements = [];\n    var hostBindingSourceSpan = typeSourceSpan;\n    var directiveSummary = metadataAsSummary(hostBindingsMetadata);\n    // Calculate host event bindings\n    var eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n    if (eventBindings && eventBindings.length) {\n        var listeners = createHostListeners(eventBindings, name);\n        createStatements.push.apply(createStatements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(listeners));\n    }\n    // Calculate the host property bindings\n    var bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n    var allOtherBindings = [];\n    // We need to calculate the total amount of binding slots required by\n    // all the instructions together before any value conversions happen.\n    // Value conversions may require additional slots for interpolation and\n    // bindings with pipes. These calculates happen after this block.\n    var totalHostVarsCount = 0;\n    bindings && bindings.forEach(function (binding) {\n        var name = binding.name;\n        var stylingInputWasSet = styleBuilder.registerInputBasedOnName(name, binding.expression, binding.sourceSpan);\n        if (stylingInputWasSet) {\n            totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        }\n        else {\n            allOtherBindings.push(binding);\n            totalHostVarsCount++;\n        }\n    });\n    var valueConverter;\n    var getValueConverter = function () {\n        if (!valueConverter) {\n            var hostVarsCountFn = function (numSlots) {\n                var originalVarsCount = totalHostVarsCount;\n                totalHostVarsCount += numSlots;\n                return originalVarsCount;\n            };\n            valueConverter = new ValueConverter(constantPool, function () { return error('Unexpected node'); }, // new nodes are illegal here\n            hostVarsCountFn, function () { return error('Unexpected pipe'); }); // pipes are illegal here\n        }\n        return valueConverter;\n    };\n    var propertyBindings = [];\n    var attributeBindings = [];\n    var syntheticHostBindings = [];\n    allOtherBindings.forEach(function (binding) {\n        // resolve literal arrays and literal objects\n        var value = binding.expression.visit(getValueConverter());\n        var bindingExpr = bindingFn(bindingContext, value);\n        var _a = getBindingNameAndInstruction(binding), bindingName = _a.bindingName, instruction = _a.instruction, isAttribute = _a.isAttribute;\n        var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(function (context) { return context !== SecurityContext.NONE; });\n        var sanitizerFn = null;\n        if (securityContexts.length) {\n            if (securityContexts.length === 2 &&\n                securityContexts.indexOf(SecurityContext.URL) > -1 &&\n                securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n                // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n                // of different security contexts. In this case we use special santitization function and\n                // select the actual sanitizer at runtime based on a tag name that is provided while\n                // invoking sanitization function.\n                sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);\n            }\n            else {\n                sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n            }\n        }\n        var instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n        if (sanitizerFn) {\n            instructionParams.push(sanitizerFn);\n        }\n        updateStatements.push.apply(updateStatements, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bindingExpr.stmts));\n        if (instruction === Identifiers$1.hostProperty) {\n            propertyBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers$1.attribute) {\n            attributeBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers$1.updateSyntheticHostBinding) {\n            syntheticHostBindings.push(instructionParams);\n        }\n        else {\n            updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());\n        }\n    });\n    if (propertyBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());\n    }\n    if (attributeBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());\n    }\n    if (syntheticHostBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.updateSyntheticHostBinding, syntheticHostBindings).toStmt());\n    }\n    // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n    var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n    if (styleBuilder.hasBindings) {\n        // finally each binding that was registered in the statement above will need to be added to\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n        // are evaluated and updated for the element.\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {\n            if (instruction.calls.length > 0) {\n                var calls_1 = [];\n                instruction.calls.forEach(function (call) {\n                    // we subtract a value of `1` here because the binding slot was already allocated\n                    // at the top of this method when all the input bindings were counted.\n                    totalHostVarsCount +=\n                        Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n                    calls_1.push(convertStylingCall(call, bindingContext, bindingFn));\n                });\n                updateStatements.push(chainedInstruction(instruction.reference, calls_1).toStmt());\n            }\n        });\n    }\n    if (totalHostVarsCount) {\n        definitionMap.set('hostVars', literal(totalHostVarsCount));\n    }\n    if (createStatements.length > 0 || updateStatements.length > 0) {\n        var hostBindingsFnName = name ? name + \"_HostBindings\" : null;\n        var statements = [];\n        if (createStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));\n        }\n        if (updateStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));\n        }\n        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\n    }\n    return null;\n}\nfunction bindingFn(implicit, value) {\n    return convertPropertyBinding(null, implicit, value, 'b', BindingForm.TrySimple, function () { return error('Unexpected interpolation'); });\n}\nfunction convertStylingCall(call, bindingContext, bindingFn) {\n    return call.params(function (value) { return bindingFn(bindingContext, value).currValExpr; });\n}\nfunction getBindingNameAndInstruction(binding) {\n    var bindingName = binding.name;\n    var instruction;\n    // Check to see if this is an attr binding or a property binding\n    var attrMatches = bindingName.match(ATTR_REGEX);\n    if (attrMatches) {\n        bindingName = attrMatches[1];\n        instruction = Identifiers$1.attribute;\n    }\n    else {\n        if (binding.isAnimation) {\n            bindingName = prepareSyntheticPropertyName(bindingName);\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n            // in the context of the component and not the parent. Therefore there is a special\n            // compatibility instruction available for this purpose.\n            instruction = Identifiers$1.updateSyntheticHostBinding;\n        }\n        else {\n            instruction = Identifiers$1.hostProperty;\n        }\n    }\n    return { bindingName: bindingName, instruction: instruction, isAttribute: !!attrMatches };\n}\nfunction createHostListeners(eventBindings, name) {\n    var listeners = [];\n    var syntheticListeners = [];\n    var instructions = [];\n    eventBindings.forEach(function (binding) {\n        var bindingName = binding.name && sanitizeIdentifier(binding.name);\n        var bindingFnName = binding.type === 1 /* Animation */ ?\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n            bindingName;\n        var handlerName = name && bindingName ? name + \"_\" + bindingFnName + \"_HostBindingHandler\" : null;\n        var params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n        if (binding.type == 1 /* Animation */) {\n            syntheticListeners.push(params);\n        }\n        else {\n            listeners.push(params);\n        }\n    });\n    if (syntheticListeners.length > 0) {\n        instructions.push(chainedInstruction(Identifiers$1.componentHostSyntheticListener, syntheticListeners).toStmt());\n    }\n    if (listeners.length > 0) {\n        instructions.push(chainedInstruction(Identifiers$1.listener, listeners).toStmt());\n    }\n    return instructions;\n}\nfunction metadataAsSummary(meta) {\n    // clang-format off\n    return {\n        // This is used by the BindingParser, which only deals with listeners and properties. There's no\n        // need to pass attributes to it.\n        hostAttributes: {},\n        hostListeners: meta.listeners,\n        hostProperties: meta.properties,\n    };\n    // clang-format on\n}\nfunction typeMapToExpressionMap(map, outputCtx) {\n    // Convert each map entry into another entry where the value is an expression importing the type.\n    var entries = Array.from(map).map(function (_a) {\n        var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), key = _b[0], type = _b[1];\n        return [key, outputCtx.importExpr(type)];\n    });\n    return new Map(entries);\n}\nvar HOST_REG_EXP$1 = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n    var e_4, _a;\n    var attributes = {};\n    var listeners = {};\n    var properties = {};\n    var specialAttributes = {};\n    try {\n        for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(Object.keys(host)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var value = host[key];\n            var matches = key.match(HOST_REG_EXP$1);\n            if (matches === null) {\n                switch (key) {\n                    case 'class':\n                        if (typeof value !== 'string') {\n                            // TODO(alxhub): make this a diagnostic.\n                            throw new Error(\"Class binding must be string\");\n                        }\n                        specialAttributes.classAttr = value;\n                        break;\n                    case 'style':\n                        if (typeof value !== 'string') {\n                            // TODO(alxhub): make this a diagnostic.\n                            throw new Error(\"Style binding must be string\");\n                        }\n                        specialAttributes.styleAttr = value;\n                        break;\n                    default:\n                        if (typeof value === 'string') {\n                            attributes[key] = literal(value);\n                        }\n                        else {\n                            attributes[key] = value;\n                        }\n                }\n            }\n            else if (matches[1 /* Binding */] != null) {\n                if (typeof value !== 'string') {\n                    // TODO(alxhub): make this a diagnostic.\n                    throw new Error(\"Property binding must be string\");\n                }\n                // synthetic properties (the ones that have a `@` as a prefix)\n                // are still treated the same as regular properties. Therefore\n                // there is no point in storing them in a separate map.\n                properties[matches[1 /* Binding */]] = value;\n            }\n            else if (matches[2 /* Event */] != null) {\n                if (typeof value !== 'string') {\n                    // TODO(alxhub): make this a diagnostic.\n                    throw new Error(\"Event binding must be string\");\n                }\n                listeners[matches[2 /* Event */]] = value;\n            }\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    return { attributes: attributes, listeners: listeners, properties: properties, specialAttributes: specialAttributes };\n}\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nfunction verifyHostBindings(bindings, sourceSpan) {\n    var summary = metadataAsSummary(bindings);\n    // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n    var bindingParser = makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n    bindingParser.createBoundHostProperties(summary, sourceSpan);\n    return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n    var shadowCss = new ShadowCss();\n    return styles.map(function (style) {\n        return shadowCss.shimCssText(style, selector, hostSelector);\n    });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = /** @class */ (function () {\n    function ResourceLoader() {\n    }\n    ResourceLoader.prototype.get = function (url) {\n        return '';\n    };\n    return ResourceLoader;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerFacadeImpl = /** @class */ (function () {\n    function CompilerFacadeImpl(jitEvaluator) {\n        if (jitEvaluator === void 0) { jitEvaluator = new JitEvaluator(); }\n        this.jitEvaluator = jitEvaluator;\n        this.R3ResolvedDependencyType = R3ResolvedDependencyType;\n        this.R3FactoryTarget = R3FactoryTarget;\n        this.ResourceLoader = ResourceLoader;\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    }\n    CompilerFacadeImpl.prototype.compilePipe = function (angularCoreEnv, sourceMapUrl, facade) {\n        var metadata = {\n            name: facade.name,\n            type: wrapReference$1(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(facade.deps),\n            pipeName: facade.pipeName,\n            pure: facade.pure,\n        };\n        var res = compilePipeFromMetadata(metadata);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n    CompilerFacadeImpl.prototype.compileInjectable = function (angularCoreEnv, sourceMapUrl, facade) {\n        var _a = compileInjectable({\n            name: facade.name,\n            type: wrapReference$1(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: wrapExpression(facade, USE_CLASS),\n            useFactory: wrapExpression(facade, USE_FACTORY),\n            useValue: wrapExpression(facade, USE_VALUE),\n            useExisting: wrapExpression(facade, USE_EXISTING),\n            userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined,\n        }), expression = _a.expression, statements = _a.statements;\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    };\n    CompilerFacadeImpl.prototype.compileInjector = function (angularCoreEnv, sourceMapUrl, facade) {\n        var meta = {\n            name: facade.name,\n            type: wrapReference$1(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            deps: convertR3DependencyMetadataArray(facade.deps),\n            providers: new WrappedNodeExpr(facade.providers),\n            imports: facade.imports.map(function (i) { return new WrappedNodeExpr(i); }),\n        };\n        var res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);\n    };\n    CompilerFacadeImpl.prototype.compileNgModule = function (angularCoreEnv, sourceMapUrl, facade) {\n        var meta = {\n            type: wrapReference$1(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            adjacentType: new WrappedNodeExpr(facade.type),\n            bootstrap: facade.bootstrap.map(wrapReference$1),\n            declarations: facade.declarations.map(wrapReference$1),\n            imports: facade.imports.map(wrapReference$1),\n            exports: facade.exports.map(wrapReference$1),\n            emitInline: true,\n            containsForwardDecls: false,\n            schemas: facade.schemas ? facade.schemas.map(wrapReference$1) : null,\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n        };\n        var res = compileNgModule(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n    CompilerFacadeImpl.prototype.compileDirective = function (angularCoreEnv, sourceMapUrl, facade) {\n        var constantPool = new ConstantPool();\n        var bindingParser = makeBindingParser();\n        var meta = convertDirectiveFacadeToMetadata(facade);\n        var res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    };\n    CompilerFacadeImpl.prototype.compileComponent = function (angularCoreEnv, sourceMapUrl, facade) {\n        // The ConstantPool is a requirement of the JIT'er.\n        var constantPool = new ConstantPool();\n        var interpolationConfig = facade.interpolation ?\n            InterpolationConfig.fromArray(facade.interpolation) :\n            DEFAULT_INTERPOLATION_CONFIG;\n        // Parse the template and check for errors.\n        var template = parseTemplate(facade.template, sourceMapUrl, { preserveWhitespaces: facade.preserveWhitespaces, interpolationConfig: interpolationConfig });\n        if (template.errors !== undefined) {\n            var errors = template.errors.map(function (err) { return err.toString(); }).join(', ');\n            throw new Error(\"Errors during JIT compilation of template for \" + facade.name + \": \" + errors);\n        }\n        // Compile the component metadata, including template, into an expression.\n        // TODO(alxhub): implement inputs, outputs, queries, etc.\n        var metadata = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template: template, wrapDirectivesAndPipesInClosure: false, styles: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(facade.styles, template.styles), encapsulation: facade.encapsulation, interpolation: interpolationConfig, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                null, relativeContextFilePath: '', i18nUseExternalIds: true });\n        var res = compileComponentFromMetadata(metadata, constantPool, makeBindingParser(interpolationConfig));\n        var jitExpressionSourceMap = \"ng:///\" + facade.name + \".js\";\n        return this.jitExpression(res.expression, angularCoreEnv, jitExpressionSourceMap, constantPool.statements);\n    };\n    CompilerFacadeImpl.prototype.compileFactory = function (angularCoreEnv, sourceMapUrl, meta) {\n        var factoryRes = compileFactoryFunction({\n            name: meta.name,\n            type: wrapReference$1(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: meta.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(meta.deps),\n            injectFn: meta.injectFn === 'directiveInject' ? Identifiers.directiveInject :\n                Identifiers.inject,\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.factory, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    };\n    CompilerFacadeImpl.prototype.createParseSourceSpan = function (kind, typeName, sourceUrl) {\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    };\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n    CompilerFacadeImpl.prototype.jitExpression = function (def, context, sourceUrl, preStatements) {\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n        // declaration of $def which is set to the expression being compiled.\n        var statements = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStatements, [\n            new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),\n        ]);\n        var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n        return res['$def'];\n    };\n    return CompilerFacadeImpl;\n}());\nvar USE_CLASS = Object.keys({ useClass: null })[0];\nvar USE_FACTORY = Object.keys({ useFactory: null })[0];\nvar USE_VALUE = Object.keys({ useValue: null })[0];\nvar USE_EXISTING = Object.keys({ useExisting: null })[0];\nvar wrapReference$1 = function (value) {\n    var wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n};\nfunction convertToR3QueryMetadata(facade) {\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade), { predicate: Array.isArray(facade.predicate) ? facade.predicate :\n            new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static });\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n    var inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    var outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    var propMetadata = facade.propMetadata;\n    var inputsFromType = {};\n    var outputsFromType = {};\n    var _loop_1 = function (field) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(function (ann) {\n                if (isInput(ann)) {\n                    inputsFromType[field] =\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n                }\n                else if (isOutput(ann)) {\n                    outputsFromType[field] = ann.bindingPropertyName || field;\n                }\n            });\n        }\n    };\n    for (var field in propMetadata) {\n        _loop_1(field);\n    }\n    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, facade), { typeSourceSpan: facade.typeSourceSpan, type: wrapReference$1(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: convertR3DependencyMetadataArray(facade.deps), host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, inputsFromMetadata), inputsFromType), outputs: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });\n}\nfunction wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return new WrappedNodeExpr(obj[property]);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction computeProvidedIn(providedIn) {\n    if (providedIn == null || typeof providedIn === 'string') {\n        return new LiteralExpr(providedIn);\n    }\n    else {\n        return new WrappedNodeExpr(providedIn);\n    }\n}\nfunction convertR3DependencyMetadata(facade) {\n    var tokenExpr;\n    if (facade.token === null) {\n        tokenExpr = new LiteralExpr(null);\n    }\n    else if (facade.resolved === R3ResolvedDependencyType.Attribute) {\n        tokenExpr = new LiteralExpr(facade.token);\n    }\n    else {\n        tokenExpr = new WrappedNodeExpr(facade.token);\n    }\n    return {\n        token: tokenExpr,\n        attribute: null,\n        resolved: facade.resolved,\n        host: facade.host,\n        optional: facade.optional,\n        self: facade.self,\n        skipSelf: facade.skipSelf,\n    };\n}\nfunction convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    var bindings = parseHostBindings(host || {});\n    // After that check host bindings for errors\n    var errors = verifyHostBindings(bindings, sourceSpan);\n    if (errors.length) {\n        throw new Error(errors.map(function (error) { return error.msg; }).join('\\n'));\n    }\n    var _loop_2 = function (field) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(function (ann) {\n                if (isHostBinding(ann)) {\n                    bindings.properties[ann.hostPropertyName || field] = field;\n                }\n                else if (isHostListener(ann)) {\n                    bindings.listeners[ann.eventName || field] = field + \"(\" + (ann.args || []).join(',') + \")\";\n                }\n            });\n        }\n    };\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n    for (var field in propMetadata) {\n        _loop_2(field);\n    }\n    return bindings;\n}\nfunction isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n    return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n    return value.ngMetadataName === 'Output';\n}\nfunction parseInputOutputs(values) {\n    return values.reduce(function (map, value) {\n        var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(value.split(',').map(function (piece) { return piece.trim(); }), 2), field = _a[0], property = _a[1];\n        map[field] = property || field;\n        return map;\n    }, {});\n}\nfunction publishFacade(global) {\n    var ng = global.ng || (global.ng = {});\n    ng.compilerFacade = new CompilerFacadeImpl();\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar VERSION$1 = new Version('9.1.12');\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = /** @class */ (function () {\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? ViewEncapsulation.Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, _e = _b.jitDevMode, jitDevMode = _e === void 0 ? false : _e, _f = _b.missingTranslation, missingTranslation = _f === void 0 ? null : _f, preserveWhitespaces = _b.preserveWhitespaces, strictInjectionParameters = _b.strictInjectionParameters;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.jitDevMode = !!jitDevMode;\n        this.missingTranslation = missingTranslation;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n    return CompilerConfig;\n}());\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting) {\n    if (defaultSetting === void 0) { defaultSetting = false; }\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = /** @class */ (function () {\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    DirectiveNormalizer.prototype.clearCache = function () {\n        this._resourceLoaderCache.clear();\n    };\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        var template = normalizedDirective.template;\n        this._resourceLoaderCache.delete(template.templateUrl);\n        template.externalStylesheets.forEach(function (stylesheet) {\n            _this._resourceLoaderCache.delete(stylesheet.moduleUrl);\n        });\n    };\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        if (isDefined(prenormData.template)) {\n            if (isDefined(prenormData.templateUrl)) {\n                throw syntaxError(\"'\" + stringify(prenormData\n                    .componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + stringify(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else if (isDefined(prenormData.templateUrl)) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + stringify(prenormData.componentType) + \" is not a string\");\n            }\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + stringify(prenormData.componentType));\n        }\n        if (isDefined(prenormData.preserveWhitespaces) &&\n            typeof prenormData.preserveWhitespaces !== 'boolean') {\n            throw syntaxError(\"The preserveWhitespaces option for component \" + stringify(prenormData.componentType) + \" must be a boolean\");\n        }\n        return SyncAsync.then(this._preParseTemplate(prenormData), function (preparsedTemplate) { return _this._normalizeTemplateMetadata(prenormData, preparsedTemplate); });\n    };\n    DirectiveNormalizer.prototype._preParseTemplate = function (prenomData) {\n        var _this = this;\n        var template;\n        var templateUrl;\n        if (prenomData.template != null) {\n            template = prenomData.template;\n            templateUrl = prenomData.moduleUrl;\n        }\n        else {\n            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n            template = this._fetch(templateUrl);\n        }\n        return SyncAsync.then(template, function (template) { return _this._preparseLoadedTemplate(prenomData, template, templateUrl); });\n    };\n    DirectiveNormalizer.prototype._preparseLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var isInline = !!prenormData.template;\n        var interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\n        var templateUrl = templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl });\n        var rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, { tokenizeExpansionForms: true, interpolationConfig: interpolationConfig });\n        if (rootNodesAndErrors.errors.length > 0) {\n            var errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));\n        var visitor = new TemplatePreparseVisitor();\n        visitAll$1(visitor, rootNodesAndErrors.rootNodes);\n        var templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        var styleUrls = this\n            ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))\n            .styleUrls;\n        return {\n            template: template,\n            templateUrl: templateAbsUrl,\n            isInline: isInline,\n            htmlAst: rootNodesAndErrors,\n            styles: styles,\n            inlineStyleUrls: inlineStyleUrls,\n            styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n        };\n    };\n    DirectiveNormalizer.prototype._normalizeTemplateMetadata = function (prenormData, preparsedTemplate) {\n        var _this = this;\n        return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), function (externalStylesheets) { return _this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets); });\n    };\n    DirectiveNormalizer.prototype._normalizeLoadedTemplateMetadata = function (prenormData, preparsedTemplate, stylesheets) {\n        // Algorithm:\n        // - produce exactly 1 entry per original styleUrl in\n        // CompileTemplateMetadata.externalStylesheets with all styles inlined\n        // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\n        // Reason: be able to determine how many stylesheets there are even without loading\n        // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\n        // (as resource loading may be async)\n        var _this = this;\n        var styles = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preparsedTemplate.styles);\n        this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\n        var styleUrls = preparsedTemplate.styleUrls;\n        var externalStylesheets = styleUrls.map(function (styleUrl) {\n            var stylesheet = stylesheets.get(styleUrl);\n            var styles = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stylesheet.styles);\n            _this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\n            return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });\n        });\n        var encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = ViewEncapsulation.None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: preparsedTemplate.template,\n            templateUrl: preparsedTemplate.templateUrl,\n            htmlAst: preparsedTemplate.htmlAst,\n            styles: styles,\n            styleUrls: styleUrls,\n            ngContentSelectors: preparsedTemplate.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation,\n            isInline: preparsedTemplate.isInline,\n            externalStylesheets: externalStylesheets,\n            preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),\n        });\n    };\n    DirectiveNormalizer.prototype._inlineStyles = function (styleUrls, stylesheets, targetStyles) {\n        var _this = this;\n        styleUrls.forEach(function (styleUrl) {\n            var stylesheet = stylesheets.get(styleUrl);\n            stylesheet.styles.forEach(function (style) { return targetStyles.push(style); });\n            _this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\n        });\n    };\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return SyncAsync.then(SyncAsync.all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return SyncAsync.then(_this._fetch(styleUrl), function (loadedStyle) {\n            var stylesheet = _this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); })), function (_) { return loadedStylesheets; });\n    };\n    DirectiveNormalizer.prototype._normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var moduleUrl = stylesheet.moduleUrl;\n        var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(moduleUrl, url); });\n        var allStyles = stylesheet.styles.map(function (style) {\n            var styleWithImports = extractStyleUrls(_this._urlResolver, moduleUrl, style);\n            allStyleUrls.push.apply(allStyleUrls, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(styleWithImports.styleUrls));\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nvar TemplatePreparseVisitor = /** @class */ (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text$3) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll$1(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) {\n        visitAll$1(this, ast.cases);\n    };\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll$1(this, ast.expression);\n    };\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) {\n        return null;\n    };\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) {\n        return null;\n    };\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) {\n        return null;\n    };\n    return TemplatePreparseVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUERY_METADATA_IDENTIFIERS = [\n    createViewChild,\n    createViewChildren,\n    createContentChild,\n    createContentChildren,\n];\n/*\n * Resolve a `Type` for {@link Directive}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nvar DirectiveResolver = /** @class */ (function () {\n    function DirectiveResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        if (typeMetadata) {\n            var metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var propertyMetadata = this._reflector.propMetadata(type);\n                var guards = this._reflector.guards(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + stringify(type));\n        }\n        return null;\n    };\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, guards, directiveType) {\n        var inputs = [];\n        var outputs = [];\n        var host = {};\n        var queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var input = findLast(propertyMetadata[propName], function (a) { return createInput.isTypeOf(a); });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var output = findLast(propertyMetadata[propName], function (a) { return createOutput.isTypeOf(a); });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var hostBindings = propertyMetadata[propName].filter(function (a) { return createHostBinding.isTypeOf(a); });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var hostListeners = propertyMetadata[propName].filter(function (a) { return createHostListener.isTypeOf(a); });\n            hostListeners.forEach(function (hostListener) {\n                var args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var query = findLast(propertyMetadata[propName], function (a) { return QUERY_METADATA_IDENTIFIERS.some(function (i) { return i.isTypeOf(a); }); });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n    };\n    DirectiveResolver.prototype._extractPublicName = function (def) {\n        return splitAtColon(def, [null, def])[1].trim();\n    };\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var names = new Set();\n        var publicNames = new Set();\n        var reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var i = bindings.length - 1; i >= 0; i--) {\n            var binding = bindings[i];\n            var name_1 = this._extractPublicName(binding);\n            publicNames.add(name_1);\n            if (!names.has(name_1)) {\n                names.add(name_1);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, guards, directiveType) {\n        var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var mergedHost = directive.host ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directive.host), host) : host;\n        var mergedQueries = directive.queries ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, directive.queries), queries) : queries;\n        if (createComponent.isTypeOf(directive)) {\n            var comp = directive;\n            return createComponent({\n                selector: comp.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: comp.exportAs,\n                moduleId: comp.moduleId,\n                queries: mergedQueries,\n                changeDetection: comp.changeDetection,\n                providers: comp.providers,\n                viewProviders: comp.viewProviders,\n                entryComponents: comp.entryComponents,\n                template: comp.template,\n                templateUrl: comp.templateUrl,\n                styles: comp.styles,\n                styleUrls: comp.styleUrls,\n                encapsulation: comp.encapsulation,\n                animations: comp.animations,\n                interpolation: comp.interpolation,\n                preserveWhitespaces: directive.preserveWhitespaces,\n            });\n        }\n        else {\n            return createDirective({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers,\n                guards: guards\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nfunction isDirectiveMetadata(type) {\n    return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\nfunction findLast(arr, condition) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(I18nError, _super);\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\nvar i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = /** @class */ (function () {\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode;\n(function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nvar _Visitor$2 = /** @class */ (function () {\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);\n        var translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var expression = visitAll$1(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var cases = visitAll$1(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && console && console.warn) {\n                        i18nCommentsWarned = true;\n                        var details = comment.sourceSpan.details ? \", \" + comment.sourceSpan.details : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(\"I18n comments are deprecated, use an <ng-container> element instead (\" + comment.sourceSpan.start + details + \")\");\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc =\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        var nodes = this._translateMessage(comment, message);\n                        return visitAll$1(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var wasInI18nNode = this._inI18nNode;\n        var wasInImplicitNode = this._inImplicitNode;\n        var childNodes = [];\n        var translatedChildNodes = undefined;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var i18nAttr = _getI18nAttr(el);\n        var i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll$1(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll$1(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var translatedAttrs = this._translateAttributes(el);\n            return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    };\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    // looks for translatable attributes\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var explicitAttrNameToValue = {};\n        var implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    // add a translatable message\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n            // Do not create empty messages\n            return null;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    // translate the attributes of an element and remove i18n specific attributes\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var attributes = el.attrs;\n        var i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var message = _this._createI18nMessage([attr], meaning, description, id);\n                var nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text$3) {\n                        var value = nodes[0].value;\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var startIndex = this._msgCountAtSectionStart;\n        var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var i = this._messages.length - 1; i >= startIndex; i--) {\n                var ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    };\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    };\n    return _Visitor;\n}());\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var idIndex = i18n.indexOf(ID_SEPARATOR);\n    var descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], 2), meaningAndDesc = _a[0], id = _a[1];\n    var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])((descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], 2), meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id.trim() };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = /** @class */ (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n        return false;\n    };\n    XmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return false;\n    };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    XmlParser.prototype.parse = function (source, url, options) {\n        return _super.prototype.parse.call(this, source, url, options);\n    };\n    return XmlParser;\n}(Parser));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG$1 = 'x';\nvar _MARKER_TAG = 'mrk';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG$1 = 'source';\nvar _SEGMENT_SOURCE_TAG = 'seg-source';\nvar _ALT_TRANS_TAG = 'alt-trans';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar _CONTEXT_GROUP_TAG = 'context-group';\nvar _CONTEXT_TAG = 'context';\n// http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nvar Xliff = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xliff.prototype.write = function (messages, locale) {\n        var visitor = new _WriteVisitor();\n        var transUnits = [];\n        messages.forEach(function (message) {\n            var _a;\n            var contextTags = [];\n            message.sources.forEach(function (source) {\n                var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$2(\"\" + source.startLine)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            var transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            (_a = transUnit.children).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes))], contextTags));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        var body = new Tag('body', {}, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(transUnits, [new CR(4)]));\n        var file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(e));\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xliff.prototype.digest = function (message) {\n        return digest(message);\n    };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = /** @class */ (function () {\n    function _WriteVisitor() {\n    }\n    _WriteVisitor.prototype.visitText = function (text, context) {\n        return [new Text$2(text.value)];\n    };\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype: ctype, 'equiv-text': \"<\" + ph.tag + \"/>\" })];\n        }\n        var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype: ctype, 'equiv-text': \"<\" + ph.tag + \">\" });\n        var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.closeName, ctype: ctype, 'equiv-text': \"</\" + ph.tag + \">\" });\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([startTagPh], this.serialize(ph.children), [closeTagPh]);\n    };\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': \"{{\" + ph.value + \"}}\" })];\n    };\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var equivText = \"{\" + ph.value.expression + \", \" + ph.value.type + \", \" + Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ') + \"}\";\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': equivText })];\n    };\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _WriteVisitor;\n}());\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nvar XliffParser = /** @class */ (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            // ignore those tags\n            case _SOURCE_TAG$1:\n            case _SEGMENT_SOURCE_TAG:\n            case _ALT_TRANS_TAG:\n                break;\n            case _TARGET_TAG:\n                var innerTextStart = element.startSourceSpan.end.offset;\n                var innerTextEnd = element.endSourceSpan.start.offset;\n                var content = element.startSourceSpan.start.file.content;\n                var innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                var localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll$1(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll$1(this, element.children, null);\n        }\n    };\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    XliffParser.prototype.visitText = function (text, context) { };\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XliffParser;\n}());\n// Convert ml nodes (xliff syntax) to i18n nodes\nvar XmlToI18n = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, xmlIcu.rootNodes)));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) {\n        return new Text$1(text.value, text.sourceSpan);\n    };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$1) {\n            var nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n            return null;\n        }\n        if (el.name === _MARKER_TAG) {\n            return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, el.children)));\n        }\n        this._addError(el, \"Unexpected tag\");\n        return null;\n    };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll$1(this, icuCase.expression),\n        };\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _MARKER_TAG$1 = 'mrk';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$2 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit';\n// http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nvar Xliff2 = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xliff2, _super);\n    function Xliff2() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xliff2.prototype.write = function (messages, locale) {\n        var visitor = new _WriteVisitor$1();\n        var units = [];\n        messages.forEach(function (message) {\n            var unit = new Tag(_UNIT_TAG$1, { id: message.id });\n            var notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\n                }\n            }\n            message.sources.forEach(function (source) {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$2(source.filePath + \":\" + source.startLine + (source.endLine !== source.startLine ? ',' + source.endLine : ''))\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            var segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        var file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(units, [new CR(2)]));\n        var xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    Xliff2.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var xliff2Parser = new Xliff2Parser();\n        var _a = xliff2Parser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(e));\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff2 parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xliff2.prototype.digest = function (message) {\n        return decimalDigest(message);\n    };\n    return Xliff2;\n}(Serializer));\nvar _WriteVisitor$1 = /** @class */ (function () {\n    function _WriteVisitor() {\n    }\n    _WriteVisitor.prototype.visitText = function (text, context) {\n        return [new Text$2(text.value)];\n    };\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(node.visit(_this))); });\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Text$2(c + \" {\")], icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            var tagPh = new Tag(_PLACEHOLDER_TAG$2, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: \"<\" + ph.tag + \"/>\",\n            });\n            return [tagPh];\n        }\n        var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: \"<\" + ph.tag + \">\",\n            dispEnd: \"</\" + ph.tag + \">\",\n        });\n        var nodes = [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ph.children.map(function (node) { return node.visit(_this); })));\n        if (nodes.length) {\n            nodes.forEach(function (node) { return tagPc.children.push(node); });\n        }\n        else {\n            tagPc.children.push(new Text$2(''));\n        }\n        return [tagPc];\n    };\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$2, {\n                id: idStr,\n                equiv: ph.name,\n                disp: \"{{\" + ph.value + \"}}\",\n            })];\n    };\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        var cases = Object.keys(ph.value.cases).map(function (value) { return value + ' {...}'; }).join(' ');\n        var idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: idStr, equiv: ph.name, disp: \"{\" + ph.value.expression + \", \" + ph.value.type + \", \" + cases + \"}\" })];\n    };\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._nextPlaceholderId = 0;\n        return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(nodes.map(function (node) { return node.visit(_this); })));\n    };\n    return _WriteVisitor;\n}());\n// Extract messages as xml nodes from the xliff file\nvar Xliff2Parser = /** @class */ (function () {\n    function Xliff2Parser() {\n        this._locale = null;\n    }\n    Xliff2Parser.prototype.parse = function (xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        var xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    Xliff2Parser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG$1 + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG$2:\n                // ignore source message\n                break;\n            case _TARGET_TAG$1:\n                var innerTextStart = element.startSourceSpan.end.offset;\n                var innerTextEnd = element.endSourceSpan.start.offset;\n                var content = element.startSourceSpan.start.file.content;\n                var innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                var localeAttr = element.attrs.find(function (attr) { return attr.name === 'trgLang'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                var versionAttr = element.attrs.find(function (attr) { return attr.name === 'version'; });\n                if (versionAttr) {\n                    var version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, \"The XLIFF file version \" + version + \" is not compatible with XLIFF 2.0 serializer\");\n                    }\n                    else {\n                        visitAll$1(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll$1(this, element.children, null);\n        }\n    };\n    Xliff2Parser.prototype.visitAttribute = function (attribute, context) { };\n    Xliff2Parser.prototype.visitText = function (text, context) { };\n    Xliff2Parser.prototype.visitComment = function (comment, context) { };\n    Xliff2Parser.prototype.visitExpansion = function (expansion, context) { };\n    Xliff2Parser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    Xliff2Parser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return Xliff2Parser;\n}());\n// Convert ml nodes (xliff syntax) to i18n nodes\nvar XmlToI18n$1 = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] : [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, xmlIcu.rootNodes)));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) {\n        return new Text$1(text.value, text.sourceSpan);\n    };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        var _this = this;\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$2:\n                var nameAttr = el.attrs.find(function (attr) { return attr.name === 'equiv'; });\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equiv\\\" attribute\");\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                var startAttr = el.attrs.find(function (attr) { return attr.name === 'equivStart'; });\n                var endAttr = el.attrs.find(function (attr) { return attr.name === 'equivEnd'; });\n                if (!startAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equivStart\\\" attribute\");\n                }\n                else if (!endAttr) {\n                    this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"equivEnd\\\" attribute\");\n                }\n                else {\n                    var startId = startAttr.value;\n                    var endId = endAttr.value;\n                    var nodes = [];\n                    return nodes.concat.apply(nodes, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([new Placeholder('', startId, el.sourceSpan)], el.children.map(function (node) { return node.visit(_this, null); }), [new Placeholder('', endId, el.sourceSpan)]));\n                }\n                break;\n            case _MARKER_TAG$1:\n                return [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, el.children)));\n            default:\n                this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat.apply([], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitAll$1(this, icuCase.expression))),\n        };\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\nvar Xtb = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Xtb.prototype.write = function (messages, locale) {\n        throw new Error('Unsupported');\n    };\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var i18nNodesByMsgId = {};\n        var converter = new XmlToI18n$2();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    Xtb.prototype.digest = function (message) {\n        return digest$1(message);\n    };\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) {\n            throw new Error('Could not overwrite an XTB translation');\n        },\n    });\n}\n// Extract messages as xml nodes from the xtb file\nvar XtbParser = /** @class */ (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var xml = new XmlParser().parse(xtb, url);\n        this._errors = xml.errors;\n        visitAll$1(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll$1(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var innerTextStart = element.startSourceSpan.end.offset;\n                        var innerTextEnd = element.endSourceSpan.start.offset;\n                        var content = element.startSourceSpan.start.file.content;\n                        var innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    XtbParser.prototype.visitText = function (text, context) { };\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XtbParser;\n}());\n// Convert ml nodes (xtb syntax) to i18n nodes\nvar XmlToI18n$2 = /** @class */ (function () {\n    function XmlToI18n() {\n    }\n    XmlToI18n.prototype.convert = function (message, url) {\n        var xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll$1(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    XmlToI18n.prototype.visitText = function (text, context) {\n        return new Text$1(text.value, text.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n        var caseMap = {};\n        visitAll$1(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll$1(this, icuCase.expression),\n        };\n    };\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$3) {\n            var nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$3 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n        return null;\n    };\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = /** @class */ (function () {\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = MissingTranslationStrategy.Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var digestFn = function (m) { return serializer.digest(m); };\n        var mapperFactory = function (m) { return serializer.createNameMapper(m); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    // Returns the translation as HTML nodes from the given source message.\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    TranslationBundle.prototype.has = function (srcMsg) {\n        return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = /** @class */ (function () {\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var text = this._convertToText(srcMsg);\n        // text to html\n        var url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\n        return {\n            nodes: html.rootNodes,\n            errors: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._errors, html.errors),\n        };\n    };\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) {\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\n        // we should then make sure that any special characters are escaped\n        return escapeXml(text.value);\n    };\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var tag = \"\" + ph.tag;\n        var attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var id = this._digest(srcMsg);\n        var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? mapper.toInternalName(name) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = /** @class */ (function () {\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = MissingTranslationStrategy.Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\n        }\n    }\n    I18NHtmlParser.prototype.parse = function (source, url, options) {\n        if (options === void 0) { options = {}; }\n        var interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        var parseResult = this._htmlParser.parse(source, url, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({ interpolationConfig: interpolationConfig }, options));\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\nfunction convertValueToOutputAst(ctx, value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\nvar _ValueOutputAstTransformer = /** @class */ (function () {\n    function _ValueOutputAstTransformer(ctx) {\n        this.ctx = ctx;\n    }\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var values = [];\n        // Note Array.map() must not be used to convert the values because it will\n        // skip over empty elements in arrays constructed using `new Array(length)`,\n        // resulting in `undefined` elements. This breaks the type guarantee that\n        // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\n        // See test case in `value_util_spec.ts`.\n        for (var i = 0; i < arr.length; ++i) {\n            values.push(visitValue(arr[i], this, null /* context */));\n        }\n        return literalArr(values, type);\n    };\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var entries = [];\n        var quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) {\n        return literal(value, type);\n    };\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return this.ctx.importExpr(value);\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mapEntry$1(key, value) {\n    return { key: key, value: value, quoted: false };\n}\nvar InjectableCompiler = /** @class */ (function () {\n    function InjectableCompiler(reflector, alwaysGenerateDef) {\n        this.reflector = reflector;\n        this.alwaysGenerateDef = alwaysGenerateDef;\n        this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n    }\n    InjectableCompiler.prototype.depsArray = function (deps, ctx) {\n        var _this = this;\n        return deps.map(function (dep) {\n            var token = dep;\n            var args = [token];\n            var flags = 0 /* Default */;\n            if (Array.isArray(dep)) {\n                for (var i = 0; i < dep.length; i++) {\n                    var v = dep[i];\n                    if (v) {\n                        if (v.ngMetadataName === 'Optional') {\n                            flags |= 8 /* Optional */;\n                        }\n                        else if (v.ngMetadataName === 'SkipSelf') {\n                            flags |= 4 /* SkipSelf */;\n                        }\n                        else if (v.ngMetadataName === 'Self') {\n                            flags |= 2 /* Self */;\n                        }\n                        else if (v.ngMetadataName === 'Inject') {\n                            token = v.token;\n                        }\n                        else {\n                            token = v;\n                        }\n                    }\n                }\n            }\n            var tokenExpr;\n            if (typeof token === 'string') {\n                tokenExpr = literal(token);\n            }\n            else if (token === _this.tokenInjector) {\n                tokenExpr = importExpr(Identifiers.INJECTOR);\n            }\n            else {\n                tokenExpr = ctx.importExpr(token);\n            }\n            if (flags !== 0 /* Default */) {\n                args = [tokenExpr, literal(flags)];\n            }\n            else {\n                args = [tokenExpr];\n            }\n            return importExpr(Identifiers.inject).callFn(args);\n        });\n    };\n    InjectableCompiler.prototype.factoryFor = function (injectable, ctx) {\n        var retValue;\n        if (injectable.useExisting) {\n            retValue = importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n        }\n        else if (injectable.useFactory) {\n            var deps = injectable.deps || [];\n            if (deps.length > 0) {\n                retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n            }\n            else {\n                return ctx.importExpr(injectable.useFactory);\n            }\n        }\n        else if (injectable.useValue) {\n            retValue = convertValueToOutputAst(ctx, injectable.useValue);\n        }\n        else {\n            var clazz = injectable.useClass || injectable.symbol;\n            var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n            retValue = new InstantiateExpr(ctx.importExpr(clazz), depArgs);\n        }\n        return fn([], [new ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');\n    };\n    InjectableCompiler.prototype.injectableDef = function (injectable, ctx) {\n        var providedIn = NULL_EXPR;\n        if (injectable.providedIn !== undefined) {\n            if (injectable.providedIn === null) {\n                providedIn = NULL_EXPR;\n            }\n            else if (typeof injectable.providedIn === 'string') {\n                providedIn = literal(injectable.providedIn);\n            }\n            else {\n                providedIn = ctx.importExpr(injectable.providedIn);\n            }\n        }\n        var def = [\n            mapEntry$1('factory', this.factoryFor(injectable, ctx)),\n            mapEntry$1('token', ctx.importExpr(injectable.type.reference)),\n            mapEntry$1('providedIn', providedIn),\n        ];\n        return importExpr(Identifiers.defineInjectable).callFn([literalMap(def)]);\n    };\n    InjectableCompiler.prototype.compile = function (injectable, ctx) {\n        if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n            var className = identifierName(injectable.type);\n            var clazz = new ClassStmt(className, null, [\n                new ClassField('prov', INFERRED_TYPE, [StmtModifier.Static], this.injectableDef(injectable, ctx)),\n            ], [], new ClassMethod(null, [], []), []);\n            ctx.statements.push(clazz);\n        }\n    };\n    return InjectableCompiler;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\nvar JIT_SUMMARY_FILE = /\\.ngsummary\\./;\nvar JIT_SUMMARY_NAME = /NgSummary$/;\nfunction ngfactoryFilePath(filePath, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n    return urlWithSuffix[0] + \".ngfactory\" + normalizeGenFileSuffix(urlWithSuffix[1]);\n}\nfunction stripGeneratedFileSuffix(filePath) {\n    return filePath.replace(GENERATED_FILE, '.');\n}\nfunction isGeneratedFile(filePath) {\n    return GENERATED_FILE.test(filePath);\n}\nfunction splitTypescriptSuffix(path, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n    }\n    var lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\nfunction normalizeGenFileSuffix(srcFileSuffix) {\n    return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;\n}\nfunction summaryFileName(fileName) {\n    var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\nfunction summaryForJitFileName(fileName, forceSourceFile) {\n    if (forceSourceFile === void 0) { forceSourceFile = false; }\n    var urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n    return urlWithSuffix[0] + \".ngsummary\" + urlWithSuffix[1];\n}\nfunction stripSummaryForJitFileSuffix(filePath) {\n    return filePath.replace(JIT_SUMMARY_FILE, '.');\n}\nfunction summaryForJitName(symbolName) {\n    return symbolName + \"NgSummary\";\n}\nfunction stripSummaryForJitNameSuffix(symbolName) {\n    return symbolName.replace(JIT_SUMMARY_NAME, '');\n}\nvar LOWERED_SYMBOL = /\\u0275\\d+/;\nfunction isLoweredSymbol(name) {\n    return LOWERED_SYMBOL.test(name);\n}\nfunction createLoweredSymbol(id) {\n    return \"\\u0275\" + id;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar LifecycleHooks;\n(function (LifecycleHooks) {\n    LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n    LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n    LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n    LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n})(LifecycleHooks || (LifecycleHooks = {}));\nvar LIFECYCLE_HOOKS_VALUES = [\n    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n    LifecycleHooks.AfterViewChecked\n];\nfunction hasLifecycleHook(reflector, hook, token) {\n    return reflector.hasLifecycleHook(token, getHookName(hook));\n}\nfunction getAllLifecycleHooks(reflector, token) {\n    return LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(reflector, hook, token); });\n}\nfunction getHookName(hook) {\n    switch (hook) {\n        case LifecycleHooks.OnInit:\n            return 'ngOnInit';\n        case LifecycleHooks.OnDestroy:\n            return 'ngOnDestroy';\n        case LifecycleHooks.DoCheck:\n            return 'ngDoCheck';\n        case LifecycleHooks.OnChanges:\n            return 'ngOnChanges';\n        case LifecycleHooks.AfterContentInit:\n            return 'ngAfterContentInit';\n        case LifecycleHooks.AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case LifecycleHooks.AfterViewInit:\n            return 'ngAfterViewInit';\n        case LifecycleHooks.AfterViewChecked:\n            return 'ngAfterViewChecked';\n        default:\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n            // However Closure Compiler does not understand that and reports an error in typed mode.\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\n            // makes sure tsc still checks this code is unreachable.\n            var unexpected = hook;\n            throw new Error(\"unexpected \" + unexpected);\n    }\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COMPONENT_TYPE = 'ngComponentType';\n// Design notes:\n// - don't lazily create metadata:\n//   For some metadata, we need to do async work sometimes,\n//   so the user has to kick off this loading.\n//   But we want to report errors even when the async work is\n//   not required to check that the user would have been able\n//   to wait correctly.\nvar CompileMetadataResolver = /** @class */ (function () {\n    function CompileMetadataResolver(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        this._config = _config;\n        this._htmlParser = _htmlParser;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n        this._shallowModuleCache = new Map();\n    }\n    CompileMetadataResolver.prototype.getReflector = function () {\n        return this._reflector;\n    };\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var delegate = null;\n        var proxyClass = function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + stringify(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        };\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            proxyClass.prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        proxyClass.overriddenName = name;\n        return proxyClass;\n    };\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        return this._createProxyClass(dirType, name);\n    };\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return {};\n        }\n    };\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            var createComponentFactory = this._reflector.resolveExternalReference(Identifiers.createComponentFactory);\n            return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);\n        }\n    };\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        var _a;\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngContentSelectors));\n        }\n    };\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary || null);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    CompileMetadataResolver.prototype.getHostComponentMetadata = function (compMeta, hostViewType) {\n        var hostType = this.getHostComponentType(compMeta.type.reference);\n        if (!hostViewType) {\n            hostViewType = this.getHostComponentViewClass(hostType);\n        }\n        // Note: ! is ok here as this method should only be called with normalized directive\n        // metadata, which always fills in the selector.\n        var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n        var templateUrl = '';\n        var htmlAst = this._htmlParser.parse(template, templateUrl);\n        return CompileDirectiveMetadata.create({\n            isHost: true,\n            type: { reference: hostType, diDeps: [], lifecycleHooks: [] },\n            template: new CompileTemplateMetadata({\n                encapsulation: ViewEncapsulation.None,\n                template: template,\n                templateUrl: templateUrl,\n                htmlAst: htmlAst,\n                styles: [],\n                styleUrls: [],\n                ngContentSelectors: [],\n                animations: [],\n                isInline: true,\n                externalStylesheets: [],\n                interpolation: null,\n                preserveWhitespaces: false,\n            }),\n            exportAs: null,\n            changeDetection: ChangeDetectionStrategy.Default,\n            inputs: [],\n            outputs: [],\n            host: {},\n            isComponent: true,\n            selector: '*',\n            providers: [],\n            viewProviders: [],\n            queries: [],\n            guards: {},\n            viewQueries: [],\n            componentViewType: hostViewType,\n            rendererType: { id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} },\n            entryComponents: [],\n            componentFactory: null\n        });\n    };\n    CompileMetadataResolver.prototype.loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return null;\n        }\n        directiveType = resolveForwardRef(directiveType);\n        var _a = this.getNonNormalizedDirectiveMetadata(directiveType), annotation = _a.annotation, metadata = _a.metadata;\n        var createDirectiveMetadata = function (templateMetadata) {\n            var normalizedDirMeta = new CompileDirectiveMetadata({\n                isHost: false,\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                guards: metadata.guards,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return null;\n        };\n        if (metadata.isComponent) {\n            var template = metadata.template;\n            var templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n                encapsulation: template.encapsulation,\n                template: template.template,\n                templateUrl: template.templateUrl,\n                styles: template.styles,\n                styleUrls: template.styleUrls,\n                animations: template.animations,\n                interpolation: template.interpolation,\n                preserveWhitespaces: template.preserveWhitespaces\n            });\n            if (isPromise(templateMeta) && isSync) {\n                this._reportError(componentStillLoadingError(directiveType), directiveType);\n                return null;\n            }\n            return SyncAsync.then(templateMeta, createDirectiveMetadata);\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = resolveForwardRef(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var nonNormalizedTemplateMetadata = undefined;\n        if (createComponent.isTypeOf(dirMeta)) {\n            // component\n            var compMeta = dirMeta;\n            assertArrayOfStrings('styles', compMeta.styles);\n            assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', compMeta.interpolation);\n            var animations = compMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: noUndefined(compMeta.encapsulation),\n                template: noUndefined(compMeta.template),\n                templateUrl: noUndefined(compMeta.templateUrl),\n                htmlAst: null,\n                styles: compMeta.styles || [],\n                styleUrls: compMeta.styleUrls || [],\n                animations: animations || [],\n                interpolation: noUndefined(compMeta.interpolation),\n                isInline: !!compMeta.template,\n                externalStylesheets: [],\n                ngContentSelectors: [],\n                preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\n            });\n        }\n        var changeDetectionStrategy = null;\n        var viewProviders = [];\n        var entryComponentMetadata = [];\n        var selector = dirMeta.selector;\n        if (createComponent.isTypeOf(dirMeta)) {\n            // Component\n            var compMeta = dirMeta;\n            changeDetectionStrategy = compMeta.changeDetection;\n            if (compMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (compMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\n                    .map(function (type) { return _this._getEntryComponentMetadata(type); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                selector = null;\n            }\n        }\n        var providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var queries = [];\n        var viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var metadata = CompileDirectiveMetadata.create({\n            isHost: false,\n            selector: selector,\n            exportAs: noUndefined(dirMeta.exportAs),\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs || [],\n            outputs: dirMeta.outputs || [],\n            host: dirMeta.host || {},\n            providers: providers || [],\n            viewProviders: viewProviders || [],\n            queries: queries || [],\n            guards: dirMeta.guards || {},\n            viewQueries: viewQueries || [],\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                null,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n            componentFactory: null\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var dirMeta = this._directiveCache.get(directiveType);\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    CompileMetadataResolver.prototype.isDirective = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Directive) ||\n            this._directiveResolver.isDirective(type);\n    };\n    CompileMetadataResolver.prototype.isAbstractDirective = function (type) {\n        var summary = this._loadSummary(type, CompileSummaryKind.Directive);\n        if (summary && !summary.isComponent) {\n            return !summary.selector;\n        }\n        var meta = this._directiveResolver.resolve(type, false);\n        if (meta && !createComponent.isTypeOf(meta)) {\n            return !meta.selector;\n        }\n        return false;\n    };\n    CompileMetadataResolver.prototype.isPipe = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||\n            this._pipeResolver.isPipe(type);\n    };\n    CompileMetadataResolver.prototype.isNgModule = function (type) {\n        return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||\n            this._ngModuleResolver.isNgModule(type);\n    };\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType, alreadyCollecting) {\n        if (alreadyCollecting === void 0) { alreadyCollecting = null; }\n        var moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);\n        if (!moduleSummary) {\n            var moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var promise = _this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    CompileMetadataResolver.prototype.getShallowModuleMetadata = function (moduleType) {\n        var compileMeta = this._shallowModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\n        compileMeta = {\n            type: this._getTypeMetadata(moduleType),\n            rawExports: ngModuleMeta.exports,\n            rawImports: ngModuleMeta.imports,\n            rawProviders: ngModuleMeta.providers,\n        };\n        this._shallowModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound, alreadyCollecting) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        if (alreadyCollecting === void 0) { alreadyCollecting = null; }\n        moduleType = resolveForwardRef(moduleType);\n        var compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var declaredDirectives = [];\n        var exportedNonModuleIdentifiers = [];\n        var declaredPipes = [];\n        var importedModules = [];\n        var exportedModules = [];\n        var providers = [];\n        var entryComponents = [];\n        var bootstrapComponents = [];\n        var schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var importedModuleType = undefined;\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType)));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    if (!alreadyCollecting)\n                        alreadyCollecting = new Set();\n                    if (alreadyCollecting.has(importedModuleType)) {\n                        _this._reportError(syntaxError(_this._getTypeDescriptor(importedModuleType) + \" '\" + stringifyType(importedType) + \"' is imported recursively by the module '\" + stringifyType(moduleType) + \"'.\"), moduleType);\n                        return;\n                    }\n                    alreadyCollecting.add(importedModuleType);\n                    var importedModuleSummary = _this.getNgModuleSummary(importedModuleType, alreadyCollecting);\n                    alreadyCollecting.delete(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                if (!alreadyCollecting)\n                    alreadyCollecting = new Set();\n                if (alreadyCollecting.has(exportedType)) {\n                    _this._reportError(syntaxError(_this._getTypeDescriptor(exportedType) + \" '\" + stringify(exportedType) + \"' is exported recursively by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                alreadyCollecting.add(exportedType);\n                var exportedModuleSummary = _this.getNgModuleSummary(exportedType, alreadyCollecting);\n                alreadyCollecting.delete(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this.isDirective(declaredType)) {\n                    if (_this.isAbstractDirective(declaredType)) {\n                        _this._reportError(syntaxError(\"Directive \" + stringifyType(declaredType) + \" has no selector, please add it!\"), declaredType);\n                    }\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var exportedDirectives = [];\n        var exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType)));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return _this._getEntryComponentMetadata(type); })));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(bootstrapComponents.map(function (type) { return _this._getEntryComponentMetadata(type.reference); })));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(flattenAndDedupeArray(meta.schemas)));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id || null,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, compileMeta.type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (isValidType(type)) {\n            if (this.isDirective(type)) {\n                return 'directive';\n            }\n            if (this.isPipe(type)) {\n                return 'pipe';\n            }\n            if (this.isNgModule(type)) {\n                return 'module';\n            }\n        }\n        if (type.provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var result = new TransitiveCompileNgModuleMetadata();\n        var modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var tokenRef = tokenReference(entry.provider.token);\n                var prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = resolveForwardRef(type);\n        return { reference: type };\n    };\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var annotations = this._reflector.tryAnnotations(type);\n        return annotations.some(function (ann) { return createInjectable.isTypeOf(ann); });\n    };\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    CompileMetadataResolver.prototype.getInjectableMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        var typeMetadata = typeSummary ?\n            typeSummary.type :\n            this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n        var annotations = this._reflector.annotations(type).filter(function (ann) { return createInjectable.isTypeOf(ann); });\n        if (annotations.length === 0) {\n            return null;\n        }\n        var meta = annotations[annotations.length - 1];\n        return {\n            symbol: type,\n            type: typeMetadata,\n            providedIn: meta.providedIn,\n            useValue: meta.useValue,\n            useClass: meta.useClass,\n            useExisting: meta.useExisting,\n            useFactory: meta.useFactory,\n            deps: meta.deps,\n        };\n    };\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n        };\n    };\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = resolveForwardRef(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta || null;\n    };\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = resolveForwardRef(pipeType);\n        var pipeAnnotation = this._pipeResolver.resolve(pipeType);\n        var pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: !!pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var hasUnknownDeps = false;\n        var params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var dependenciesMetadata = params.map(function (param) {\n            var isAttribute = false;\n            var isHost = false;\n            var isSelf = false;\n            var isSkipSelf = false;\n            var isOptional = false;\n            var token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (createHost.isTypeOf(paramEntry)) {\n                        isHost = true;\n                    }\n                    else if (createSelf.isTypeOf(paramEntry)) {\n                        isSelf = true;\n                    }\n                    else if (createSkipSelf.isTypeOf(paramEntry)) {\n                        isSkipSelf = true;\n                    }\n                    else if (createOptional.isTypeOf(paramEntry)) {\n                        isOptional = true;\n                    }\n                    else if (createAttribute.isTypeOf(paramEntry)) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (createInject.isTypeOf(paramEntry)) {\n                        token = paramEntry.token;\n                    }\n                    else if (createInjectionToken.isTypeOf(paramEntry) ||\n                        paramEntry instanceof StaticSymbol) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return {};\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var depsTokens = dependenciesMetadata.map(function (dep) { return dep.token ? stringifyType(dep.token) : '?'; }).join(', ');\n            var message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v6.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = resolveForwardRef(token);\n        var compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = resolveForwardRef(provider);\n                var providerMeta = undefined;\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var providersInfo = providers\n                        .reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ?\n                        debugInfo :\n                        'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token ===\n                    _this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._getEntryComponentsFromProvider(providerMeta, type)));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var components = [];\n        var collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };\n        }\n        var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: dirSummary.componentFactory };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n        return null;\n    };\n    CompileMetadataResolver.prototype._getInjectableTypeMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var compileDeps = undefined;\n        var compileTypeMetadata = null;\n        var compileFactoryMetadata = null;\n        var token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata =\n                this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) {\n        return selector.split(/\\s*,\\s*/);\n    };\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants,\n            propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : null,\n            static: q.static\n        };\n    };\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var i = 0; i < tree.length; i++) {\n            var item = resolveForwardRef(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof Type);\n}\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return stringify(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n */\nfunction componentStillLoadingError(compType) {\n    var error = Error(\"Can't compile synchronously as \" + stringify(compType) + \" is still being loaded!\");\n    error[ERROR_COMPONENT_TYPE] = compType;\n    return error;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction providerDef(ctx, providerAst) {\n    var flags = 0 /* None */;\n    if (!providerAst.eager) {\n        flags |= 4096 /* LazyProvider */;\n    }\n    if (providerAst.providerType === ProviderAstType.PrivateService) {\n        flags |= 8192 /* PrivateProvider */;\n    }\n    if (providerAst.isModule) {\n        flags |= 1073741824 /* TypeModuleProvider */;\n    }\n    providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n        // for regular providers, we only support ngOnDestroy\n        if (lifecycleHook === LifecycleHooks.OnDestroy ||\n            providerAst.providerType === ProviderAstType.Directive ||\n            providerAst.providerType === ProviderAstType.Component) {\n            flags |= lifecycleHookToNodeFlag(lifecycleHook);\n        }\n    });\n    var _a = providerAst.multiProvider ?\n        multiProviderDef(ctx, flags, providerAst.providers) :\n        singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return {\n        providerExpr: providerExpr,\n        flags: providerFlags,\n        depsExpr: depsExpr,\n        tokenExpr: tokenExpr(ctx, providerAst.token),\n    };\n}\nfunction multiProviderDef(ctx, flags, providers) {\n    var allDepDefs = [];\n    var allParams = [];\n    var exprs = providers.map(function (provider, providerIndex) {\n        var expr;\n        if (provider.useClass) {\n            var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(ctx, provider.useValue);\n        }\n        return expr;\n    });\n    var providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return {\n        providerExpr: providerExpr,\n        flags: flags | 1024 /* TypeFactoryProvider */,\n        depsExpr: literalArr(allDepDefs)\n    };\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(ctx, dep));\n            return variable(paramName);\n        });\n    }\n}\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\n    var providerExpr;\n    var deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n        flags |= 16384 /* TypeDirective */;\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n            flags |= 512 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n            flags |= 1024 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags |= 2048 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n            flags |= 256 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var depsExpr = literalArr(deps.map(function (dep) { return depDef(ctx, dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\nfunction tokenExpr(ctx, tokenMeta) {\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n        literal(tokenMeta.value);\n}\nfunction depDef(ctx, dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isHost\n    var expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);\n    var flags = 0 /* None */;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isSelf) {\n        flags |= 4 /* Self */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var nodeFlag = 0 /* None */;\n    switch (lifecycleHook) {\n        case LifecycleHooks.AfterContentChecked:\n            nodeFlag = 2097152 /* AfterContentChecked */;\n            break;\n        case LifecycleHooks.AfterContentInit:\n            nodeFlag = 1048576 /* AfterContentInit */;\n            break;\n        case LifecycleHooks.AfterViewChecked:\n            nodeFlag = 8388608 /* AfterViewChecked */;\n            break;\n        case LifecycleHooks.AfterViewInit:\n            nodeFlag = 4194304 /* AfterViewInit */;\n            break;\n        case LifecycleHooks.DoCheck:\n            nodeFlag = 262144 /* DoCheck */;\n            break;\n        case LifecycleHooks.OnChanges:\n            nodeFlag = 524288 /* OnChanges */;\n            break;\n        case LifecycleHooks.OnDestroy:\n            nodeFlag = 131072 /* OnDestroy */;\n            break;\n        case LifecycleHooks.OnInit:\n            nodeFlag = 65536 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\nfunction componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n    var entryComponentFactories = entryComponents.map(function (entryComponent) { return ctx.importExpr(entryComponent.componentFactory); });\n    var token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n    var classMeta = {\n        diDeps: [\n            { isValue: true, value: literalArr(entryComponentFactories) },\n            { token: token, isSkipSelf: true, isOptional: true },\n            { token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef) },\n        ],\n        lifecycleHooks: [],\n        reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n    };\n    var _a = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token: token,\n        multi: false,\n        useClass: classMeta,\n    }), providerExpr = _a.providerExpr, providerFlags = _a.flags, depsExpr = _a.depsExpr;\n    return { providerExpr: providerExpr, flags: providerFlags, depsExpr: depsExpr, tokenExpr: tokenExpr(ctx, token) };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NgModuleCompileResult = /** @class */ (function () {\n    function NgModuleCompileResult(ngModuleFactoryVar) {\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n    }\n    return NgModuleCompileResult;\n}());\nvar LOG_VAR = variable('_l');\nvar NgModuleCompiler = /** @class */ (function () {\n    function NgModuleCompiler(reflector) {\n        this.reflector = reflector;\n    }\n    NgModuleCompiler.prototype.compile = function (ctx, ngModuleMeta, extraProviders) {\n        var sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n        var bootstrapComponents = ngModuleMeta.bootstrapComponents;\n        var providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n        var providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]\n            .concat(providerParser.parse().map(function (provider) { return providerDef(ctx, provider); }))\n            .map(function (_a) {\n            var providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr = _a.tokenExpr;\n            return importExpr(Identifiers.moduleProviderDef).callFn([\n                literal(flags), tokenExpr, providerExpr, depsExpr\n            ]);\n        });\n        var ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);\n        var ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);\n        var ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([\n            ctx.importExpr(ngModuleMeta.type.reference),\n            literalArr(bootstrapComponents.map(function (id) { return ctx.importExpr(id.reference); })),\n            ngModuleDefFactory\n        ]));\n        if (ngModuleMeta.id) {\n            var id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) :\n                ctx.importExpr(ngModuleMeta.id);\n            var registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn)\n                .callFn([id, variable(ngModuleFactoryVar)])\n                .toStmt();\n            ctx.statements.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(ngModuleFactoryVar);\n    };\n    NgModuleCompiler.prototype.createStub = function (ctx, ngModuleReference) {\n        this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);\n    };\n    NgModuleCompiler.prototype._createNgModuleFactory = function (ctx, reference, value) {\n        var ngModuleFactoryVar = identifierName({ reference: reference }) + \"NgFactory\";\n        var ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(value)\n            .toDeclStmt(importType(Identifiers.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);\n        ctx.statements.push(ngModuleFactoryStmt);\n    };\n    return NgModuleCompiler;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolves types to {@link NgModule}.\n */\nvar NgModuleResolver = /** @class */ (function () {\n    function NgModuleResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    NgModuleResolver.prototype.isNgModule = function (type) {\n        return this._reflector.annotations(type).some(createNgModule.isTypeOf);\n    };\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + stringify(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _debugFilePath = '/debug/lib';\nfunction debugOutputAstAsTypeScript(ast) {\n    var converter = new _TsEmitterVisitor();\n    var ctx = EmitterVisitorContext.createRoot();\n    var asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = /** @class */ (function () {\n    function TypeScriptEmitter() {\n    }\n    TypeScriptEmitter.prototype.emitStatementsAndContext = function (genFilePath, stmts, preamble, emitSourceMaps, referenceFilter, importFilter) {\n        if (preamble === void 0) { preamble = ''; }\n        if (emitSourceMaps === void 0) { emitSourceMaps = true; }\n        var converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n        var ctx = EmitterVisitorContext.createRoot();\n        converter.visitAllStatements(stmts, ctx);\n        var preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedModuleName) {\n            var reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + exportedModuleName + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + importedModuleName + \"';\"));\n        });\n        var sm = emitSourceMaps ?\n            ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\n            '';\n        var lines = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preambleLines, [ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        ctx.setPreambleLineCount(preambleLines.length);\n        return { sourceText: lines.join('\\n'), context: ctx };\n    };\n    TypeScriptEmitter.prototype.emitStatements = function (genFilePath, stmts, preamble) {\n        if (preamble === void 0) { preamble = ''; }\n        return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(_TsEmitterVisitor, _super);\n    function _TsEmitterVisitor(referenceFilter, importFilter) {\n        var _this = _super.call(this, false) || this;\n        _this.referenceFilter = referenceFilter;\n        _this.importFilter = importFilter;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n    // In SNC mode, [] have the type never[], so we cast here to any[].\n    // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n    // start with [].concat. see https://github.com/angular/angular/pull/11846\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        var result = _super.prototype.visitAssertNotNullExpr.call(this, ast, ctx);\n        ctx.print(ast, '!');\n        return result;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\n            !stmt.type) {\n            // check for a reexport\n            var _a = stmt.value.value, name_1 = _a.name, moduleName = _a.moduleName;\n            if (moduleName) {\n                var reexports = this.reexports.get(moduleName);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(moduleName, reexports);\n                }\n                reexports.push({ name: name_1, as: stmt.name });\n                return null;\n            }\n        }\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        if (stmt.value) {\n            ctx.print(stmt, \" = \");\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n    };\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\");\n        ast.type.visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        if (field.hasModifier(StmtModifier.Static)) {\n            ctx.print(null, 'static ');\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        if (field.initializer) {\n            ctx.print(null, ' = ');\n            field.initializer.visitExpression(this, ctx);\n        }\n        ctx.println(null, \";\");\n    };\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        if (ast.name) {\n            ctx.print(ast, 'function ');\n            ctx.print(ast, ast.name);\n        }\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        if (!ast.name) {\n            ctx.print(ast, \" => \");\n        }\n        ctx.println(ast, '{');\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [\n                StmtModifier.Final\n            ])].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitBuiltinType = function (type, ctx) {\n        var typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            case BuiltinTypeName.None:\n                typeStr = 'never';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        var _this = this;\n        ast.value.visitExpression(this, ctx);\n        if (ast.typeParams !== null) {\n            ctx.print(null, '<');\n            this.visitAllObjects(function (type) { return _this.visitType(type, ctx); }, ast.typeParams, ctx, ',');\n            ctx.print(null, '>');\n        }\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var name = value.name, moduleName = value.moduleName;\n        if (this.referenceFilter && this.referenceFilter(value)) {\n            ctx.print(null, '(null as any)');\n            return;\n        }\n        if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n            var prefix = this.importsWithPrefixes.get(moduleName);\n            if (prefix == null) {\n                prefix = \"i\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(moduleName, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        ctx.print(null, name);\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var suppliedParameters = typeParams || [];\n            if (suppliedParameters.length > 0) {\n                ctx.print(null, \"<\");\n                this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Resolve a `Type` for {@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nvar PipeResolver = /** @class */ (function () {\n    function PipeResolver(_reflector) {\n        this._reflector = _reflector;\n    }\n    PipeResolver.prototype.isPipe = function (type) {\n        var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n        return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n    };\n    /**\n     * Return {@link Pipe} for a given `Type`.\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var metas = this._reflector.annotations(resolveForwardRef(type));\n        if (metas) {\n            var annotation = findLast(metas, createPipe.isTypeOf);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + stringify(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generates code that is used to type check templates.\n */\nvar TypeCheckCompiler = /** @class */ (function () {\n    function TypeCheckCompiler(options, reflector) {\n        this.options = options;\n        this.reflector = reflector;\n    }\n    /**\n     * Important notes:\n     * - This must not produce new `import` statements, but only refer to types outside\n     *   of the file via the variables provided via externalReferenceVars.\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\n     * - This must not produce any exports, as this would pollute the .d.ts file\n     *   and also violate the point above.\n     */\n    TypeCheckCompiler.prototype.compileComponent = function (componentId, component, template, usedPipes, externalReferenceVars, ctx) {\n        var _this = this;\n        var pipes = new Map();\n        usedPipes.forEach(function (p) { return pipes.set(p.name, p.type.reference); });\n        var embeddedViewCount = 0;\n        var viewBuilderFactory = function (parent, guards) {\n            var embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(_this.options, _this.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n        var visitor = viewBuilderFactory(null, []);\n        visitor.visitAll([], template);\n        return visitor.build(componentId);\n    };\n    return TypeCheckCompiler;\n}());\nvar DYNAMIC_VAR_NAME = '_any';\nvar TypeCheckLocalResolver = /** @class */ (function () {\n    function TypeCheckLocalResolver() {\n    }\n    TypeCheckLocalResolver.prototype.notifyImplicitReceiverUse = function () { };\n    TypeCheckLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            // References to the event should not be type-checked.\n            // TODO(chuckj): determine a better type for the event.\n            return variable(DYNAMIC_VAR_NAME);\n        }\n        return null;\n    };\n    return TypeCheckLocalResolver;\n}());\nvar defaultResolver = new TypeCheckLocalResolver();\nvar ViewBuilder = /** @class */ (function () {\n    function ViewBuilder(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {\n        this.options = options;\n        this.reflector = reflector;\n        this.externalReferenceVars = externalReferenceVars;\n        this.parent = parent;\n        this.component = component;\n        this.isHostComponent = isHostComponent;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.pipes = pipes;\n        this.guards = guards;\n        this.ctx = ctx;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.refOutputVars = new Map();\n        this.variables = [];\n        this.children = [];\n        this.updates = [];\n        this.actions = [];\n    }\n    ViewBuilder.prototype.getOutputVar = function (type) {\n        var varName;\n        if (type === this.component && this.isHostComponent) {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        else if (type instanceof StaticSymbol) {\n            varName = this.externalReferenceVars.get(type);\n        }\n        else {\n            varName = DYNAMIC_VAR_NAME;\n        }\n        if (!varName) {\n            throw new Error(\"Illegal State: referring to a type without a variable \" + JSON.stringify(type));\n        }\n        return varName;\n    };\n    ViewBuilder.prototype.getTypeGuardExpressions = function (ast) {\n        var e_1, _a, e_2, _b;\n        var result = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this.guards);\n        try {\n            for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(ast.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var directive = _d.value;\n                try {\n                    for (var _e = (e_2 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(directive.inputs)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                        var input = _f.value;\n                        var guard = directive.directive.guards[input.directiveName];\n                        if (guard) {\n                            var useIf = guard === 'UseIf';\n                            result.push({\n                                guard: guard,\n                                useIf: useIf,\n                                expression: {\n                                    context: this.component,\n                                    value: input.value,\n                                    sourceSpan: input.sourceSpan,\n                                },\n                            });\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        this.variables = variables;\n        templateVisitAll(this, astNodes);\n    };\n    ViewBuilder.prototype.build = function (componentId, targetStatements) {\n        var e_3, _a;\n        var _this = this;\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(componentId, targetStatements); });\n        var viewStmts = [variable(DYNAMIC_VAR_NAME).set(NULL_EXPR).toDeclStmt(DYNAMIC_TYPE)];\n        var bindingCount = 0;\n        this.updates.forEach(function (expression) {\n            var _a = _this.preprocessUpdateExpression(expression), sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n            var bindingId = \"\" + bindingCount++;\n            var nameResolver = context === _this.component ? _this : defaultResolver;\n            var _b = convertPropertyBinding(nameResolver, variable(_this.getOutputVar(context)), value, bindingId, BindingForm.General), stmts = _b.stmts, currValExpr = _b.currValExpr;\n            stmts.push(new ExpressionStatement(currValExpr));\n            viewStmts.push.apply(viewStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n        });\n        this.actions.forEach(function (_a) {\n            var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n            var bindingId = \"\" + bindingCount++;\n            var nameResolver = context === _this.component ? _this : defaultResolver;\n            var stmts = convertActionBinding(nameResolver, variable(_this.getOutputVar(context)), value, bindingId).stmts;\n            viewStmts.push.apply(viewStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n        });\n        if (this.guards.length) {\n            var guardExpression = undefined;\n            try {\n                for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(this.guards), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var guard = _c.value;\n                    var _d = this.preprocessUpdateExpression(guard.expression), context = _d.context, value = _d.value;\n                    var bindingId = \"\" + bindingCount++;\n                    var nameResolver = context === this.component ? this : defaultResolver;\n                    // We only support support simple expressions and ignore others as they\n                    // are unlikely to affect type narrowing.\n                    var _e = convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.TrySimple), stmts = _e.stmts, currValExpr = _e.currValExpr;\n                    if (stmts.length == 0) {\n                        var guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n                        guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            if (guardExpression) {\n                viewStmts = [new IfStmt(guardExpression, viewStmts)];\n            }\n        }\n        var viewName = \"_View_\" + componentId + \"_\" + this.embeddedViewIndex;\n        var viewFactory = new DeclareFunctionStmt(viewName, [], viewStmts);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var astWithSource = ast.value;\n        var inter = astWithSource.ast;\n        inter.expressions.forEach(function (expr) {\n            return _this.updates.push({ context: _this.component, value: expr, sourceSpan: ast.sourceSpan });\n        });\n    };\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        this.visitElementOrTemplate(ast);\n        // Note: The old view compiler used to use an `any` type\n        // for the context in any embedded view.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n            // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n            // stamped out if ngIf is truthy so any bindings in the template can assume that,\n            // if a nullable type is used for ngIf, that expression is not null or undefined.\n            var guards = this.getTypeGuardExpressions(ast);\n            var childVisitor = this.viewBuilderFactory(this, guards);\n            this.children.push(childVisitor);\n            childVisitor.visitAll(ast.variables, ast.children);\n        }\n    };\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        this.visitElementOrTemplate(ast);\n        var inputDefs = [];\n        var updateRendererExpressions = [];\n        var outputDefs = [];\n        ast.inputs.forEach(function (inputAst) {\n            _this.updates.push({ context: _this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan });\n        });\n        templateVisitAll(this, ast.children);\n    };\n    ViewBuilder.prototype.visitElementOrTemplate = function (ast) {\n        var _this = this;\n        ast.directives.forEach(function (dirAst) {\n            _this.visitDirective(dirAst);\n        });\n        ast.references.forEach(function (ref) {\n            var outputVarType = null;\n            // Note: The old view compiler used to use an `any` type\n            // for directives exposed via `exportAs`.\n            // We keep this behaivor behind a flag for now.\n            if (ref.value && ref.value.identifier && _this.options.fullTemplateTypeCheck) {\n                outputVarType = ref.value.identifier.reference;\n            }\n            else {\n                outputVarType = BuiltinTypeName.Dynamic;\n            }\n            _this.refOutputVars.set(ref.name, outputVarType);\n        });\n        ast.outputs.forEach(function (outputAst) {\n            _this.actions.push({ context: _this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan });\n        });\n    };\n    ViewBuilder.prototype.visitDirective = function (dirAst) {\n        var _this = this;\n        var dirType = dirAst.directive.type.reference;\n        dirAst.inputs.forEach(function (input) { return _this.updates.push({ context: _this.component, value: input.value, sourceSpan: input.sourceSpan }); });\n        // Note: The old view compiler used to use an `any` type\n        // for expressions in host properties / events.\n        // We keep this behaivor behind a flag for now.\n        if (this.options.fullTemplateTypeCheck) {\n            dirAst.hostProperties.forEach(function (inputAst) { return _this.updates.push({ context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan }); });\n            dirAst.hostEvents.forEach(function (hostEventAst) { return _this.actions.push({\n                context: dirType,\n                value: hostEventAst.handler,\n                sourceSpan: hostEventAst.sourceSpan\n            }); });\n        }\n    };\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () { };\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return variable(this.getOutputVar(BuiltinTypeName.Dynamic));\n        }\n        for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\n            var outputVarType = void 0;\n            // check references\n            outputVarType = currBuilder.refOutputVars.get(name);\n            if (outputVarType == null) {\n                // check variables\n                var varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n                if (varAst) {\n                    outputVarType = BuiltinTypeName.Dynamic;\n                }\n            }\n            if (outputVarType != null) {\n                return variable(this.getOutputVar(outputVarType));\n            }\n        }\n        return null;\n    };\n    ViewBuilder.prototype.pipeOutputVar = function (name) {\n        var pipe = this.pipes.get(name);\n        if (!pipe) {\n            throw new Error(\"Illegal State: Could not find pipe \" + name + \" in template of \" + this.component);\n        }\n        return this.getOutputVar(pipe);\n    };\n    ViewBuilder.prototype.preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return function (args) {\n                    var arr = literalArr(args);\n                    // Note: The old view compiler used to use an `any` type\n                    // for arrays.\n                    return _this.options.fullTemplateTypeCheck ? arr : arr.cast(DYNAMIC_TYPE);\n                }; },\n                createLiteralMapConverter: function (keys) {\n                    return function (values) {\n                        var entries = keys.map(function (k, i) { return ({\n                            key: k.key,\n                            value: values[i],\n                            quoted: k.quoted,\n                        }); });\n                        var map = literalMap(entries);\n                        // Note: The old view compiler used to use an `any` type\n                        // for maps.\n                        return _this.options.fullTemplateTypeCheck ? map : map.cast(DYNAMIC_TYPE);\n                    };\n                },\n                createPipeConverter: function (name, argCount) { return function (args) {\n                    // Note: The old view compiler used to use an `any` type\n                    // for pipes.\n                    var pipeExpr = _this.options.fullTemplateTypeCheck ?\n                        variable(_this.pipeOutputVar(name)) :\n                        variable(_this.getOutputVar(BuiltinTypeName.Dynamic));\n                    return pipeExpr.callMethod('transform', args);\n                }; },\n            }, expression.value)\n        };\n    };\n    ViewBuilder.prototype.visitNgContent = function (ast, context) { };\n    ViewBuilder.prototype.visitText = function (ast, context) { };\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar ViewCompileResult = /** @class */ (function () {\n    function ViewCompileResult(viewClassVar, rendererTypeVar) {\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = /** @class */ (function () {\n    function ViewCompiler(_reflector) {\n        this._reflector = _reflector;\n    }\n    ViewCompiler.prototype.compileComponent = function (outputCtx, component, template, styles, usedPipes) {\n        var _a;\n        var _this = this;\n        var embeddedViewCount = 0;\n        var renderComponentVarName = undefined;\n        if (!component.isHost) {\n            var template_1 = component.template;\n            var customRenderData = [];\n            if (template_1.animations && template_1.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template_1.animations), true));\n            }\n            var renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = renderComponentVar.name;\n            outputCtx.statements.push(renderComponentVar\n                .set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(template_1.encapsulation), false),\n                    new LiteralMapEntry('styles', styles, false),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)\n                ])]))\n                .toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));\n        }\n        var viewBuilderFactory = function (parent) {\n            var embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder$1(_this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory);\n        };\n        var visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        (_a = outputCtx.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(visitor.build()));\n        return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n    };\n    return ViewCompiler;\n}());\nvar LOG_VAR$1 = variable('_l');\nvar VIEW_VAR = variable('_v');\nvar CHECK_VAR = variable('_ck');\nvar COMP_VAR = variable('_co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder$1 = /** @class */ (function () {\n    function ViewBuilder(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory) {\n        this.reflector = reflector;\n        this.outputCtx = outputCtx;\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        // Need Object.create so that we don't have builtin values...\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ?\n            DYNAMIC_TYPE :\n            expressionType(outputCtx.importExpr(this.component.type.reference));\n        this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n    }\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var queryId = queryIndex + 1;\n                var bindingType = query.first ? 0 /* First */ : 1 /* All */;\n                var flags = 134217728 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(query);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(Identifiers.queryDef).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var viewFlags = 0 /* None */;\n        if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var updateFn;\n        if (updateStmts.length > 0) {\n            var preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(CHECK_VAR.name, INFERRED_TYPE),\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE)\n            ], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStmts, updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 8 /* TypeNgContent */,\n            nodeDef: importExpr(Identifiers.ngContentDef)\n                .callFn([literal(ast.ngContentIndex), literal(ast.index)])\n        }); });\n    };\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // Static text nodes have no check function\n        var checkIndex = -1;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(checkIndex),\n                literal(ast.ngContentIndex),\n                literalArr([literal(ast.value)]),\n            ])\n        }); });\n    };\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var astWithSource = ast.value;\n        var inter = astWithSource.ast;\n        var updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(Identifiers.textDef).callFn([\n                literal(checkIndex),\n                literal(ast.ngContentIndex),\n                literalArr(inter.strings.map(function (s) { return literal(s); })),\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.anchorDef).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        // Using a null element name creates an anchor.\n        var elName = isNgContainer(ast.name) ? null : ast.name;\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var inputDefs = [];\n        var updateRendererExpressions = [];\n        var outputDefs = [];\n        if (elName) {\n            var hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: COMP_VAR,\n                inputAst: inputAst,\n                dirAst: null,\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(_a, 2), target = _b[0], eventName = _b[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var childCount = this.nodes.length - nodeIndex - 1;\n        var compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var compRendererType = NULL_EXPR;\n        var compView = NULL_EXPR;\n        if (compAst) {\n            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n        }\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(Identifiers.elementDef).callFn([\n                literal(checkIndex),\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var flags = 0 /* None */;\n        if (ast.hasViewContainer) {\n            flags |= 16777216 /* EmbeddedViews */;\n        }\n        var usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(elementEventFullName(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(elementEventFullName(target, name), [target, name]);\n            });\n        });\n        var hostBindings = [];\n        var hostEvents = [];\n        this._visitComponentFactoryResolverProvider(ast.directives);\n        ast.providers.forEach(function (providerAst) {\n            var dirAst = undefined;\n            ast.directives.forEach(function (localDirAst) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(dirHostBindings));\n                hostEvents.push.apply(hostEvents, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(dirHostEvents));\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var valueType = undefined;\n            if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var valueType = undefined;\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) ===\n                _this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, refs, queryMatches, usedEvents) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var queryId = dirAst.contentQueryStartId + queryIndex;\n            var flags = 67108864 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(query);\n            var bindingType = query.first ? 0 /* First */ : 1 /* All */;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(Identifiers.queryDef).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 32768 /* Component */;\n        }\n        var inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var outputDefs = [];\n        var dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n        var hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst,\n            dirAst: dirAst,\n        }); });\n        // Check index is the same as the node index during compilation\n        // They might only differ at runtime\n        var checkIndex = nodeIndex;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 16384 /* TypeDirective */ | flags,\n            nodeDef: importExpr(Identifiers.directiveDef).callFn([\n                literal(checkIndex),\n                literal(flags),\n                queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount),\n                providerExpr,\n                depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR,\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    };\n    ViewBuilder.prototype._visitComponentFactoryResolverProvider = function (directives) {\n        var componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n            var _a = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, flags = _a.flags, tokenExpr = _a.tokenExpr;\n            this._addProviderNode({\n                providerExpr: providerExpr,\n                depsExpr: depsExpr,\n                flags: flags,\n                tokenExpr: tokenExpr,\n                queryMatchExprs: [],\n                sourceSpan: componentDirMeta.sourceSpan\n            });\n        }\n    };\n    ViewBuilder.prototype._addProviderNode = function (data) {\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: data.sourceSpan,\n            nodeFlags: data.flags,\n            nodeDef: importExpr(Identifiers.providerDef).callFn([\n                literal(data.flags),\n                data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR,\n                data.tokenExpr, data.providerExpr, data.depsExpr\n            ])\n        }); });\n    };\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var flags = 0 /* None */;\n        var queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(this.outputCtx, providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerFlags = _a.flags, tokenExpr = _a.tokenExpr;\n        return {\n            flags: flags | providerFlags,\n            queryMatchExprs: queryMatchExprs,\n            providerExpr: providerExpr,\n            depsExpr: depsExpr,\n            tokenExpr: tokenExpr,\n            sourceSpan: providerAst.sourceSpan\n        };\n    };\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var currViewExpr = VIEW_VAR;\n        for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);\n            }\n            // check variables\n            var varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () {\n        // Not needed in View Engine as View Engine walks through the generated\n        // expressions to figure out if the implicit receiver is used and needs\n        // to be generated as part of the pre-update statements.\n    };\n    ViewBuilder.prototype._createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var valueExpr_1 = importExpr(Identifiers.EMPTY_ARRAY);\n            return function () { return valueExpr_1; };\n        }\n        var checkIndex = this.nodes.length;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureArray */,\n            nodeDef: importExpr(Identifiers.pureArrayDef).callFn([\n                literal(checkIndex),\n                literal(argCount),\n            ])\n        }); });\n        return function (args) { return callCheckStmt(checkIndex, args); };\n    };\n    ViewBuilder.prototype._createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var valueExpr_2 = importExpr(Identifiers.EMPTY_MAP);\n            return function () { return valueExpr_2; };\n        }\n        var map = literalMap(keys.map(function (e, i) { return (Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, e), { value: literal(i) })); }));\n        var checkIndex = this.nodes.length;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 64 /* TypePureObject */,\n            nodeDef: importExpr(Identifiers.pureObjectDef).callFn([\n                literal(checkIndex),\n                map,\n            ])\n        }); });\n        return function (args) { return callCheckStmt(checkIndex, args); };\n    };\n    ViewBuilder.prototype._createPipeConverter = function (expression, name, argCount) {\n        var pipe = this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; });\n        if (pipe.pure) {\n            var checkIndex_1 = this.nodes.length;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 128 /* TypePurePipe */,\n                nodeDef: importExpr(Identifiers.purePipeDef).callFn([\n                    literal(checkIndex_1),\n                    literal(argCount),\n                ])\n            }); });\n            // find underlying pipe in the component view\n            var compViewExpr = VIEW_VAR;\n            var compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var pipeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var nodeValueExpr_1 = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var _this = this;\n        var nodeIndex = this.nodes.length;\n        var flags = 0 /* None */;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === LifecycleHooks.OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var depExprs = pipe.type.diDeps.map(function (diDep) { return depDef(_this.outputCtx, diDep); });\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePipe */,\n            nodeDef: importExpr(Identifiers.pipeDef).callFn([\n                literal(flags), _this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * For the AST in `UpdateExpression.value`:\n     * - create nodes for pipes, literal arrays and, literal maps,\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n     *\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) {\n                    return _this._createLiteralArrayConverter(expression.sourceSpan, argCount);\n                },\n                createLiteralMapConverter: function (keys) {\n                    return _this._createLiteralMapConverter(expression.sourceSpan, keys);\n                },\n                createPipeConverter: function (name, argCount) {\n                    return _this._createPipeConverter(expression, name, argCount);\n                }\n            }, expression.value)\n        };\n    };\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var self = this;\n        var updateBindingCount = 0;\n        var updateRendererStmts = [];\n        var updateDirectivesStmts = [];\n        var nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false)));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0)));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var updateStmts = [];\n            var exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var bindingId = \"\" + updateBindingCount++;\n                var nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); })));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var handleEventStmts = [];\n        var handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var bindingId = \"\" + handleEventBindingCount++;\n            var nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var fullEventName = elementEventFullName(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE),\n                new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),\n                new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)\n            ], Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(preStmts, handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\nfunction needsAdditionalRootNode(astNodes) {\n    var lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\nfunction elementBindingDef(inputAst, dirAst) {\n    var inputType = inputAst.type;\n    switch (inputType) {\n        case 1 /* Attribute */:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case 0 /* Property */:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case 4 /* Animation */:\n            var bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case 2 /* Class */:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case 3 /* Style */:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n        default:\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n            // However Closure Compiler does not understand that and reports an error in typed mode.\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\n            // makes sure tsc still checks this code is unreachable.\n            var unexpected = inputType;\n            throw new Error(\"unexpected \" + unexpected);\n    }\n}\nfunction fixedAttrsDef(elementAst) {\n    var mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) {\n        mapResult[attrAst.name] = attrAst.value;\n    });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var value = dirAst.directive.hostAttributes[name];\n            var prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)], exprs));\n    }\n}\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(Identifiers.unwrapValue).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\nfunction calcStaticDynamicQueryFlags(query) {\n    var flags = 0 /* None */;\n    // Note: We only make queries static that query for a single item and the user specifically\n    // set the to be static. This is because of backwards compatibility with the old view compiler...\n    if (query.first && query.static) {\n        flags |= 268435456 /* StaticQuery */;\n    }\n    else {\n        flags |= 536870912 /* DynamicQuery */;\n    }\n    return flags;\n}\nfunction elementEventFullName(target, name) {\n    return target ? target + \":\" + name : name;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = /** @class */ (function () {\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var _a;\n        var htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig: interpolationConfig });\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(i18nParserResult.messages));\n        return [];\n    };\n    // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n    MessageBundle.prototype.getMessages = function () {\n        return this._messages;\n    };\n    MessageBundle.prototype.write = function (serializer, filterSources) {\n        var messages = {};\n        var mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var _a;\n            var id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                (_a = messages[id].sources).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(message.sources));\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        var msgList = Object.keys(messages).map(function (id) {\n            var mapper = serializer.createNameMapper(messages[id]);\n            var src = messages[id];\n            var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach(function (source) { return source.filePath = filterSources(source.filePath); });\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nvar MapPlaceholderNames = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var startName = mapper.toPublicName(ph.startName);\n        var closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        var children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = /** @class */ (function () {\n    function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        if (typeof sourceOrStmts === 'string') {\n            this.source = sourceOrStmts;\n            this.stmts = null;\n        }\n        else {\n            this.source = null;\n            this.stmts = sourceOrStmts;\n        }\n    }\n    GeneratedFile.prototype.isEquivalent = function (other) {\n        if (this.genFileUrl !== other.genFileUrl) {\n            return false;\n        }\n        if (this.source) {\n            return this.source === other.source;\n        }\n        if (other.stmts == null) {\n            return false;\n        }\n        // Note: the constructor guarantees that if this.source is not filled,\n        // then this.stmts is.\n        return areAllEquivalent(this.stmts, other.stmts);\n    };\n    return GeneratedFile;\n}());\nfunction toTypeScript(file, preamble) {\n    if (preamble === void 0) { preamble = ''; }\n    if (!file.stmts) {\n        throw new Error(\"Illegal state: No stmts present on GeneratedFile \" + file.genFileUrl);\n    }\n    return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction listLazyRoutes(moduleMeta, reflector) {\n    var e_1, _a, e_2, _b;\n    var allLazyRoutes = [];\n    try {\n        for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(moduleMeta.transitiveModule.providers), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var _e = _d.value, provider = _e.provider, module = _e.module;\n            if (tokenReference(provider.token) === reflector.ROUTES) {\n                var loadChildren = _collectLoadChildren(provider.useValue);\n                try {\n                    for (var loadChildren_1 = (e_2 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(loadChildren)), loadChildren_1_1 = loadChildren_1.next(); !loadChildren_1_1.done; loadChildren_1_1 = loadChildren_1.next()) {\n                        var route = loadChildren_1_1.value;\n                        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (loadChildren_1_1 && !loadChildren_1_1.done && (_b = loadChildren_1.return)) _b.call(loadChildren_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return allLazyRoutes;\n}\nfunction _collectLoadChildren(routes, target) {\n    var e_3, _a;\n    if (target === void 0) { target = []; }\n    if (typeof routes === 'string') {\n        target.push(routes);\n    }\n    else if (Array.isArray(routes)) {\n        try {\n            for (var routes_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\n                var route = routes_1_1.value;\n                _collectLoadChildren(route, target);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n    }\n    else if (routes.loadChildren) {\n        _collectLoadChildren(routes.loadChildren, target);\n    }\n    else if (routes.children) {\n        _collectLoadChildren(routes.children, target);\n    }\n    return target;\n}\nfunction parseLazyRoute(route, reflector, module) {\n    var _a = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__read\"])(route.split('#'), 2), routePath = _a[0], routeName = _a[1];\n    var referencedModule = reflector.resolveExternalReference({\n        moduleName: routePath,\n        name: routeName,\n    }, module ? module.filePath : undefined);\n    return { route: route, module: module || referencedModule, referencedModule: referencedModule };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\nvar ResolvedStaticSymbol = /** @class */ (function () {\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 4;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = /** @class */ (function () {\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        // Note: this will only contain StaticSymbols without members!\n        this.resolvedSymbols = new Map();\n        // Note: this will only contain StaticSymbols without members!\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return this._resolveSymbolMembers(staticSymbol);\n        }\n        // Note: always ask for a summary first,\n        // as we might have read shallow metadata via a .d.ts file\n        // for the symbol.\n        var resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);\n        if (resultFromSummary) {\n            return resultFromSummary;\n        }\n        var resultFromCache = this.resolvedSymbols.get(staticSymbol);\n        if (resultFromCache) {\n            return resultFromCache;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        return this.resolvedSymbols.get(staticSymbol);\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param staticSymbol the symbol for which to generate a import symbol\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol, useSummaries) {\n        if (useSummaries === void 0) { useSummaries = true; }\n        if (staticSymbol.members.length) {\n            var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n        if (summarizedFileName !== staticSymbol.filePath) {\n            var summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n            var baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n            var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n            return baseImportAs ? this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :\n                null;\n        }\n        var result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n        if (!result) {\n            result = this.importAs.get(staticSymbol);\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isGeneratedFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    StaticSymbolResolver.prototype.getKnownModuleName = function (filePath) {\n        return this.knownFileNameToModuleNames.get(filePath) || null;\n    };\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    StaticSymbolResolver.prototype.recordModuleNameForFileName = function (fileName, moduleName) {\n        this.knownFileNameToModuleNames.set(fileName, moduleName);\n    };\n    /**\n     * Invalidate all information derived from the given file and return the\n     * static symbols contained in the file.\n     *\n     * @param fileName the file to invalidate\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        var e_1, _a;\n        this.metadataCache.delete(fileName);\n        var symbols = this.symbolFromFile.get(fileName);\n        if (!symbols) {\n            return [];\n        }\n        this.symbolFromFile.delete(fileName);\n        try {\n            for (var symbols_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n                var symbol = symbols_1_1.value;\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return symbols;\n    };\n    /** @internal */\n    StaticSymbolResolver.prototype.ignoreErrorsFor = function (cb) {\n        var recorder = this.errorRecorder;\n        this.errorRecorder = function () { };\n        try {\n            return cb();\n        }\n        finally {\n            this.errorRecorder = recorder;\n        }\n    };\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var members = staticSymbol.members;\n        var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var value = baseMetadata;\n            for (var i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     * @param members a symbol for a static member of the named type\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n     * metadata.\n     *\n     * @param filePath the absolute path to examine for decorators.\n     * @returns true if any class in the file has a decorator.\n     */\n    StaticSymbolResolver.prototype.hasDecorators = function (filePath) {\n        var metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            return Object.keys(metadata['metadata']).some(function (metadataKey) {\n                var entry = metadata['metadata'][metadataKey];\n                return entry && entry.__symbolic === 'class' && entry.decorators;\n            });\n        }\n        return false;\n    };\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        var summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n        if (summarySymbols) {\n            return summarySymbols;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n        this._createSymbolsOf(filePath);\n        return this.symbolFromFile.get(filePath) || [];\n    };\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var e_2, _a, e_3, _b;\n        var _this = this;\n        if (this.symbolFromFile.has(filePath)) {\n            return;\n        }\n        var resolvedSymbols = [];\n        var metadata = this.getModuleMetadata(filePath);\n        if (metadata['importAs']) {\n            // Index bundle indices should use the importAs module name defined\n            // in the bundle.\n            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // Handle the symbols loaded by 'export *' directives.\n                    var resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule && resolvedModule !== filePath) {\n                        var nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            try {\n                for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(metadata['exports']), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var moduleExport = _d.value;\n                    _loop_1(moduleExport);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        // handle the actual metadata. Has to be after the exports\n        // as there might be collisions in the names, and we want the symbols\n        // of the current module to win ofter reexports.\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var symbolMeta = metadata['metadata'][metadataKey];\n                var name = unescapeIdentifier(metadataKey);\n                var symbol = _this.getStaticSymbol(filePath, name);\n                var origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + _this.host.getOutputName(filePath)));\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        var uniqueSymbols = new Set();\n        try {\n            for (var resolvedSymbols_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(resolvedSymbols), resolvedSymbols_1_1 = resolvedSymbols_1.next(); !resolvedSymbols_1_1.done; resolvedSymbols_1_1 = resolvedSymbols_1.next()) {\n                var resolvedSymbol = resolvedSymbols_1_1.value;\n                this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\n                uniqueSymbols.add(resolvedSymbol.symbol);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (resolvedSymbols_1_1 && !resolvedSymbols_1_1.done && (_b = resolvedSymbols_1.return)) _b.call(resolvedSymbols_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\n    };\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        var _this = this;\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        var isTsFile = TS.test(sourceSymbol.filePath);\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var _originalFileMemo;\n        var getOriginalName = function () {\n            if (!_originalFileMemo) {\n                // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n                // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n                // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n                // location as it is not important to finding the file.\n                _originalFileMemo =\n                    _this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                        .replace(/^.*node_modules[/\\\\]/, ''));\n            }\n            return _originalFileMemo;\n        };\n        var self = this;\n        var ReferenceTransformer = /** @class */ (function (_super) {\n            Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])((map['parameters'] || [])));\n                    var result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var module = map['module'];\n                    var name_1 = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name_1) {\n                        return null;\n                    }\n                    var filePath = void 0;\n                    if (module) {\n                        filePath = self.resolveModule(module, sourceSymbol.filePath);\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module + \" relative to \" + self.host.getMetadataFor(sourceSymbol.filePath) + \".\",\n                                line: map['line'],\n                                character: map['character'],\n                                fileName: getOriginalName()\n                            };\n                        }\n                        return {\n                            __symbolic: 'resolved',\n                            symbol: self.getStaticSymbol(filePath, name_1),\n                            line: map['line'],\n                            character: map['character'],\n                            fileName: getOriginalName()\n                        };\n                    }\n                    else if (functionParams.indexOf(name_1) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name_1 };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name_1)) {\n                            return self.getStaticSymbol(topLevelPath, name_1);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else if (symbolic === 'error') {\n                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"])({}, map), { fileName: getOriginalName() });\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        var unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n        if (unwrappedTransformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n            this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param module an absolute path to a module file.\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md && md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + this.host.getOutputName(module) + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage));\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : '')));\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, undefined, containingFile);\n        }\n        return null;\n    };\n    return StaticSymbolResolver;\n}());\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\nfunction unwrapResolvedMetadata(metadata) {\n    if (metadata && metadata.__symbolic === 'resolved') {\n        return metadata.symbol;\n    }\n    return metadata;\n}\n\nfunction serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types, createExternalSymbolReexports) {\n    if (createExternalSymbolReexports === void 0) { createExternalSymbolReexports = false; }\n    var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return toJsonSerializer.addSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add type summaries.\n    types.forEach(function (_a) {\n        var summary = _a.summary, metadata = _a.metadata;\n        toJsonSerializer.addSummary({ symbol: summary.type.reference, metadata: undefined, type: summary });\n    });\n    var _a = toJsonSerializer.serialize(createExternalSymbolReexports), json = _a.json, exportAs = _a.exportAs;\n    if (forJitCtx) {\n        var forJitSerializer_1 = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n        types.forEach(function (_a) {\n            var summary = _a.summary, metadata = _a.metadata;\n            forJitSerializer_1.addSourceType(summary, metadata);\n        });\n        toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach(function (summary) {\n            if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n                forJitSerializer_1.addLibType(summary.type);\n            }\n        });\n        forJitSerializer_1.serialize(exportAs);\n    }\n    return { json: json, exportAs: exportAs };\n}\nfunction deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\n    var deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n    return deserializer.deserialize(libraryFileName, json);\n}\nfunction createForJitStub(outputCtx, reference) {\n    return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);\n}\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\n    var fnName = summaryForJitName(reference.name);\n    outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [\n        StmtModifier.Final, StmtModifier.Exported\n    ]));\n}\nvar ToJsonSerializer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(ToJsonSerializer, _super);\n    function ToJsonSerializer(symbolResolver, summaryResolver, srcFileName) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        _this.srcFileName = srcFileName;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.reexportedBy = new Map();\n        // This now contains a `__symbol: number` in the place of\n        // StaticSymbols, but otherwise has the same shape as the original objects.\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        _this.unprocessedSymbolSummariesBySymbol = new Map();\n        _this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n        return _this;\n    }\n    ToJsonSerializer.prototype.addSummary = function (summary) {\n        var _this = this;\n        var unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n        var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!unprocessedSummary) {\n            unprocessedSummary = { symbol: summary.symbol, metadata: undefined };\n            this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n            processedSummary = { symbol: this.processValue(summary.symbol, 0 /* None */) };\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        if (!unprocessedSummary.metadata && summary.metadata) {\n            var metadata_1 = summary.metadata || {};\n            if (metadata_1.__symbolic === 'class') {\n                // For classes, we keep everything except their class decorators.\n                // We need to keep e.g. the ctor args, method names, method decorators\n                // so that the class can be extended in another compilation unit.\n                // We don't keep the class decorators as\n                // 1) they refer to data\n                //   that should not cause a rebuild of downstream compilation units\n                //   (e.g. inline templates of @Component, or @NgModule.declarations)\n                // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n                var clone_1 = {};\n                Object.keys(metadata_1).forEach(function (propName) {\n                    if (propName !== 'decorators') {\n                        clone_1[propName] = metadata_1[propName];\n                    }\n                });\n                metadata_1 = clone_1;\n            }\n            else if (isCall(metadata_1)) {\n                if (!isFunctionCall(metadata_1) && !isMethodCallOnVariable(metadata_1)) {\n                    // Don't store complex calls as we won't be able to simplify them anyways later on.\n                    metadata_1 = {\n                        __symbolic: 'error',\n                        message: 'Complex function calls are not supported.',\n                    };\n                }\n            }\n            // Note: We need to keep storing ctor calls for e.g.\n            // `export const x = new InjectionToken(...)`\n            unprocessedSummary.metadata = metadata_1;\n            processedSummary.metadata = this.processValue(metadata_1, 1 /* ResolveValue */);\n            if (metadata_1 instanceof StaticSymbol &&\n                this.summaryResolver.isLibraryFile(metadata_1.filePath)) {\n                var declarationSymbol = this.symbols[this.indexBySymbol.get(metadata_1)];\n                if (!isLoweredSymbol(declarationSymbol.name)) {\n                    // Note: symbols that were introduced during codegen in the user file can have a reexport\n                    // if a user used `export *`. However, we can't rely on this as tsickle will change\n                    // `export *` into named exports, using only the information from the typechecker.\n                    // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n                    // and omits them when expanding `export *`.\n                    // So we have to keep reexporting these symbols manually via .ngfactory files.\n                    this.reexportedBy.set(declarationSymbol, summary.symbol);\n                }\n            }\n        }\n        if (!unprocessedSummary.type && summary.type) {\n            unprocessedSummary.type = summary.type;\n            // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n            // as the type summaries already contain the transitive data that they require\n            // (in a minimal way).\n            processedSummary.type = this.processValue(summary.type, 0 /* None */);\n            // except for reexported directives / pipes, so we need to store\n            // their summaries explicitly.\n            if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n                var ngModuleSummary = summary.type;\n                ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                    var symbol = id.reference;\n                    if (_this.summaryResolver.isLibraryFile(symbol.filePath) &&\n                        !_this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n                        var summary_1 = _this.summaryResolver.resolveSummary(symbol);\n                        if (summary_1) {\n                            _this.addSummary(summary_1);\n                        }\n                    }\n                });\n            }\n        }\n    };\n    /**\n     * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\n     * This can be enabled if external symbols should be re-exported by the current module in\n     * order to avoid dynamically generated module dependencies which can break strict dependency\n     * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\n     */\n    ToJsonSerializer.prototype.serialize = function (createExternalSymbolReexports) {\n        var _this = this;\n        var exportAs = [];\n        var json = JSON.stringify({\n            moduleName: this.moduleName,\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var importAs = undefined;\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var reexportSymbol = _this.reexportedBy.get(symbol);\n                    if (reexportSymbol) {\n                        // In case the given external static symbol is already manually exported by the\n                        // user, we just proxy the external static symbol reference to the manual export.\n                        // This ensures that the AOT compiler imports the external symbol through the\n                        // user export and does not introduce another dependency which is not needed.\n                        importAs = _this.indexBySymbol.get(reexportSymbol);\n                    }\n                    else if (createExternalSymbolReexports) {\n                        // In this case, the given external static symbol is *not* manually exported by\n                        // the user, and we manually create a re-export in the factory file so that we\n                        // don't introduce another module dependency. This is useful when running within\n                        // Bazel so that the AOT compiler does not introduce any module dependencies\n                        // which can break the strict dependency enforcement. (e.g. as in Google3)\n                        // Read more about this here: https://github.com/angular/angular/issues/25644\n                        var summary = _this.unprocessedSymbolSummariesBySymbol.get(symbol);\n                        if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n                            importAs = symbol.name + \"_\" + index;\n                            exportAs.push({ symbol: symbol, exportAs: importAs });\n                        }\n                    }\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    filePath: _this.summaryResolver.toSummaryFileName(symbol.filePath, _this.srcFileName),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    ToJsonSerializer.prototype.processValue = function (value, flags) {\n        return visitValue(value, this, flags);\n    };\n    ToJsonSerializer.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var index = this.visitStaticSymbol(baseSymbol, context);\n            return { __symbol: index, members: value.members };\n        }\n    };\n    /**\n     * Strip line and character numbers from ngsummaries.\n     * Emitting them causes white spaces changes to retrigger upstream\n     * recompilations in bazel.\n     * TODO: find out a way to have line and character numbers in errors without\n     * excessive recompilation in bazel.\n     */\n    ToJsonSerializer.prototype.visitStringMap = function (map, context) {\n        if (map['__symbolic'] === 'resolved') {\n            return visitValue(map['symbol'], this, context);\n        }\n        if (map['__symbolic'] === 'error') {\n            delete map['line'];\n            delete map['character'];\n        }\n        return _super.prototype.visitStringMap.call(this, map, context);\n    };\n    /**\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\n     * resolved to a type or could not be resolved.\n     */\n    ToJsonSerializer.prototype.visitStaticSymbol = function (baseSymbol, flags) {\n        var index = this.indexBySymbol.get(baseSymbol);\n        var summary = null;\n        if (flags & 1 /* ResolveValue */ &&\n            this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n            if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n                // the summary for this symbol was already added\n                // -> nothing to do.\n                return index;\n            }\n            summary = this.loadSummary(baseSymbol);\n            if (summary && summary.metadata instanceof StaticSymbol) {\n                // The summary is a reexport\n                index = this.visitStaticSymbol(summary.metadata, flags);\n                // reset the summary as it is just a reexport, so we don't want to store it.\n                summary = null;\n            }\n        }\n        else if (index != null) {\n            // Note: == on purpose to compare with undefined!\n            // No summary and the symbol is already added -> nothing to do.\n            return index;\n        }\n        // Note: == on purpose to compare with undefined!\n        if (index == null) {\n            index = this.symbols.length;\n            this.symbols.push(baseSymbol);\n        }\n        this.indexBySymbol.set(baseSymbol, index);\n        if (summary) {\n            this.addSummary(summary);\n        }\n        return index;\n    };\n    ToJsonSerializer.prototype.loadSummary = function (symbol) {\n        var summary = this.summaryResolver.resolveSummary(symbol);\n        if (!summary) {\n            // some symbols might originate from a plain typescript library\n            // that just exported .d.ts and .metadata.json files, i.e. where no summary\n            // files were created.\n            var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n            if (resolvedSymbol) {\n                summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n            }\n        }\n        return summary;\n    };\n    return ToJsonSerializer;\n}(ValueTransformer));\nvar ForJitSerializer = /** @class */ (function () {\n    function ForJitSerializer(outputCtx, symbolResolver, summaryResolver) {\n        this.outputCtx = outputCtx;\n        this.symbolResolver = symbolResolver;\n        this.summaryResolver = summaryResolver;\n        this.data = [];\n    }\n    ForJitSerializer.prototype.addSourceType = function (summary, metadata) {\n        this.data.push({ summary: summary, metadata: metadata, isLibrary: false });\n    };\n    ForJitSerializer.prototype.addLibType = function (summary) {\n        this.data.push({ summary: summary, metadata: null, isLibrary: true });\n    };\n    ForJitSerializer.prototype.serialize = function (exportAsArr) {\n        var e_1, _a, e_2, _b, e_3, _c;\n        var _this = this;\n        var exportAsBySymbol = new Map();\n        try {\n            for (var exportAsArr_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(exportAsArr), exportAsArr_1_1 = exportAsArr_1.next(); !exportAsArr_1_1.done; exportAsArr_1_1 = exportAsArr_1.next()) {\n                var _d = exportAsArr_1_1.value, symbol = _d.symbol, exportAs = _d.exportAs;\n                exportAsBySymbol.set(symbol, exportAs);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (exportAsArr_1_1 && !exportAsArr_1_1.done && (_a = exportAsArr_1.return)) _a.call(exportAsArr_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var ngModuleSymbols = new Set();\n        try {\n            for (var _e = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(this.data), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var _g = _f.value, summary = _g.summary, metadata = _g.metadata, isLibrary = _g.isLibrary;\n                if (summary.summaryKind === CompileSummaryKind.NgModule) {\n                    // collect the symbols that refer to NgModule classes.\n                    // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n                    // we don't add the summaries of all referenced symbols when we serialize type summaries.\n                    // See serializeSummaries for details.\n                    ngModuleSymbols.add(summary.type.reference);\n                    var modSummary = summary;\n                    try {\n                        for (var _h = (e_3 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(modSummary.modules)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                            var mod = _j.value;\n                            ngModuleSymbols.add(mod.reference);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                }\n                if (!isLibrary) {\n                    var fnName = summaryForJitName(summary.type.reference.name);\n                    createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        ngModuleSymbols.forEach(function (ngModuleSymbol) {\n            if (_this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n                var exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n                var jitExportAsName = summaryForJitName(exportAs);\n                _this.outputCtx.statements.push(variable(jitExportAsName)\n                    .set(_this.serializeSummaryRef(ngModuleSymbol))\n                    .toDeclStmt(null, [StmtModifier.Exported]));\n            }\n        });\n    };\n    ForJitSerializer.prototype.serializeSummaryWithDeps = function (summary, metadata) {\n        var _this = this;\n        var expressions = [this.serializeSummary(summary)];\n        var providers = [];\n        if (metadata instanceof CompileNgModuleMetadata) {\n            expressions.push.apply(expressions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(\n            // For directives / pipes, we only add the declared ones,\n            // and rely on transitively importing NgModules to get the transitive\n            // summaries.\n            metadata.declaredDirectives.concat(metadata.declaredPipes)\n                .map(function (type) { return type.reference; })\n                // For modules,\n                // we also add the summaries for modules\n                // from libraries.\n                // This is ok as we produce reexports for all transitive modules.\n                .concat(metadata.transitiveModule.modules.map(function (type) { return type.reference; })\n                .filter(function (ref) { return ref !== metadata.type.reference; }))\n                .map(function (ref) { return _this.serializeSummaryRef(ref); })));\n            // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n            // and we already have transitive modules.\n            providers = metadata.providers;\n        }\n        else if (summary.summaryKind === CompileSummaryKind.Directive) {\n            var dirSummary = summary;\n            providers = dirSummary.providers.concat(dirSummary.viewProviders);\n        }\n        // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n        // declaredDirectives / declaredPipes), as we allow\n        // providers without ctor arguments to skip the `@Injectable` decorator,\n        // i.e. we didn't generate .ngsummary.ts files for these.\n        expressions.push.apply(expressions, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(providers.filter(function (provider) { return !!provider.useClass; }).map(function (provider) { return _this.serializeSummary({\n            summaryKind: CompileSummaryKind.Injectable,\n            type: provider.useClass\n        }); })));\n        return literalArr(expressions);\n    };\n    ForJitSerializer.prototype.serializeSummaryRef = function (typeSymbol) {\n        var jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n        return this.outputCtx.importExpr(jitImportedSymbol);\n    };\n    ForJitSerializer.prototype.serializeSummary = function (data) {\n        var outputCtx = this.outputCtx;\n        var Transformer = /** @class */ (function () {\n            function Transformer() {\n            }\n            Transformer.prototype.visitArray = function (arr, context) {\n                var _this = this;\n                return literalArr(arr.map(function (entry) { return visitValue(entry, _this, context); }));\n            };\n            Transformer.prototype.visitStringMap = function (map, context) {\n                var _this = this;\n                return new LiteralMapExpr(Object.keys(map).map(function (key) { return new LiteralMapEntry(key, visitValue(map[key], _this, context), false); }));\n            };\n            Transformer.prototype.visitPrimitive = function (value, context) {\n                return literal(value);\n            };\n            Transformer.prototype.visitOther = function (value, context) {\n                if (value instanceof StaticSymbol) {\n                    return outputCtx.importExpr(value);\n                }\n                else {\n                    throw new Error(\"Illegal State: Encountered value \" + value);\n                }\n            };\n            return Transformer;\n        }());\n        return visitValue(data, new Transformer(), null);\n    };\n    return ForJitSerializer;\n}());\nvar FromJsonDeserializer = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(FromJsonDeserializer, _super);\n    function FromJsonDeserializer(symbolCache, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        _this.summaryResolver = summaryResolver;\n        return _this;\n    }\n    FromJsonDeserializer.prototype.deserialize = function (libraryFileName, json) {\n        var _this = this;\n        var data = JSON.parse(json);\n        var allImportAs = [];\n        this.symbols = data.symbols.map(function (serializedSymbol) { return _this.symbolCache.get(_this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name); });\n        data.symbols.forEach(function (serializedSymbol, index) {\n            var symbol = _this.symbols[index];\n            var importAs = serializedSymbol.importAs;\n            if (typeof importAs === 'number') {\n                allImportAs.push({ symbol: symbol, importAs: _this.symbols[importAs] });\n            }\n            else if (typeof importAs === 'string') {\n                allImportAs.push({ symbol: symbol, importAs: _this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs) });\n            }\n        });\n        var summaries = visitValue(data.summaries, this, null);\n        return { moduleName: data.moduleName, summaries: summaries, importAs: allImportAs };\n    };\n    FromJsonDeserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var baseSymbol = this.symbols[map['__symbol']];\n            var members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return FromJsonDeserializer;\n}(ValueTransformer));\nfunction isCall(metadata) {\n    return metadata && metadata.__symbolic === 'call';\n}\nfunction isFunctionCall(metadata) {\n    return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\n}\nfunction isMethodCallOnVariable(metadata) {\n    return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\n        unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = /** @class */ (function () {\n    function AotCompiler(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\n        this._config = _config;\n        this._options = _options;\n        this._host = _host;\n        this.reflector = reflector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._typeCheckCompiler = _typeCheckCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._injectableCompiler = _injectableCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._symbolResolver = _symbolResolver;\n        this._templateAstCache = new Map();\n        this._analyzedFiles = new Map();\n        this._analyzedFilesForInjectables = new Map();\n    }\n    AotCompiler.prototype.clearCache = function () {\n        this._metadataResolver.clearCache();\n    };\n    AotCompiler.prototype.analyzeModulesSync = function (rootFiles) {\n        var _this = this;\n        var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        analyzeResult.ngModules.forEach(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true); });\n        return analyzeResult;\n    };\n    AotCompiler.prototype.analyzeModulesAsync = function (rootFiles) {\n        var _this = this;\n        var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n        return Promise\n            .all(analyzeResult.ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () { return analyzeResult; });\n    };\n    AotCompiler.prototype._analyzeFile = function (fileName) {\n        var analyzedFile = this._analyzedFiles.get(fileName);\n        if (!analyzedFile) {\n            analyzedFile =\n                analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n            this._analyzedFiles.set(fileName, analyzedFile);\n        }\n        return analyzedFile;\n    };\n    AotCompiler.prototype._analyzeFileForInjectables = function (fileName) {\n        var analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n        if (!analyzedFile) {\n            analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);\n            this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n        }\n        return analyzedFile;\n    };\n    AotCompiler.prototype.findGeneratedFileNames = function (fileName) {\n        var _this = this;\n        var genFileNames = [];\n        var file = this._analyzeFile(fileName);\n        // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n        // or a reference to a non source file.\n        // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n        // Only do this for StubEmitFlags.Basic, as adding a type check block\n        // does not change this file (as we generate type check blocks based on NgModules).\n        if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n            file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n            genFileNames.push(ngfactoryFilePath(file.fileName, true));\n            if (this._options.enableSummariesForJit) {\n                genFileNames.push(summaryForJitFileName(file.fileName, true));\n            }\n        }\n        var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n        file.directives.forEach(function (dirSymbol) {\n            var compMeta = _this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;\n            if (!compMeta.isComponent) {\n                return;\n            }\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template.styleUrls.forEach(function (styleUrl) {\n                var normalizedUrl = _this._host.resourceNameToFileName(styleUrl, file.fileName);\n                if (!normalizedUrl) {\n                    throw syntaxError(\"Couldn't resolve resource \" + styleUrl + \" relative to \" + file.fileName);\n                }\n                var needsShim = (compMeta.template.encapsulation ||\n                    _this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n                genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n                if (_this._options.allowEmptyCodegenFiles) {\n                    genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n                }\n            });\n        });\n        return genFileNames;\n    };\n    AotCompiler.prototype.emitBasicStub = function (genFileName, originalFileName) {\n        var outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            if (!originalFileName) {\n                throw new Error(\"Assertion error: require the original file for .ngfactory.ts stubs. File: \" + genFileName);\n            }\n            var originalFile = this._analyzeFile(originalFileName);\n            this._createNgFactoryStub(outputCtx, originalFile, 1 /* Basic */);\n        }\n        else if (genFileName.endsWith('.ngsummary.ts')) {\n            if (this._options.enableSummariesForJit) {\n                if (!originalFileName) {\n                    throw new Error(\"Assertion error: require the original file for .ngsummary.ts stubs. File: \" + genFileName);\n                }\n                var originalFile = this._analyzeFile(originalFileName);\n                _createEmptyStub(outputCtx);\n                originalFile.ngModules.forEach(function (ngModule) {\n                    // create exports that user code can reference\n                    createForJitStub(outputCtx, ngModule.type.reference);\n                });\n            }\n        }\n        else if (genFileName.endsWith('.ngstyle.ts')) {\n            _createEmptyStub(outputCtx);\n        }\n        // Note: for the stubs, we don't need a property srcFileUrl,\n        // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n        // correct srcFileUrl.\n        // This is good as e.g. for .ngstyle.ts files we can't derive\n        // the url of components based on the genFileUrl.\n        return this._codegenSourceModule('unknown', outputCtx);\n    };\n    AotCompiler.prototype.emitTypeCheckStub = function (genFileName, originalFileName) {\n        var originalFile = this._analyzeFile(originalFileName);\n        var outputCtx = this._createOutputContext(genFileName);\n        if (genFileName.endsWith('.ngfactory.ts')) {\n            this._createNgFactoryStub(outputCtx, originalFile, 2 /* TypeCheck */);\n        }\n        return outputCtx.statements.length > 0 ?\n            this._codegenSourceModule(originalFile.fileName, outputCtx) :\n            null;\n    };\n    AotCompiler.prototype.loadFilesAsync = function (fileNames, tsFiles) {\n        var _this = this;\n        var files = fileNames.map(function (fileName) { return _this._analyzeFile(fileName); });\n        var loadingPromises = [];\n        files.forEach(function (file) { return file.ngModules.forEach(function (ngModule) {\n            return loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false));\n        }); });\n        var analyzedInjectables = tsFiles.map(function (tsFile) { return _this._analyzeFileForInjectables(tsFile); });\n        return Promise.all(loadingPromises).then(function (_) { return ({\n            analyzedModules: mergeAndValidateNgFiles(files),\n            analyzedInjectables: analyzedInjectables,\n        }); });\n    };\n    AotCompiler.prototype.loadFilesSync = function (fileNames, tsFiles) {\n        var _this = this;\n        var files = fileNames.map(function (fileName) { return _this._analyzeFile(fileName); });\n        files.forEach(function (file) { return file.ngModules.forEach(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true); }); });\n        var analyzedInjectables = tsFiles.map(function (tsFile) { return _this._analyzeFileForInjectables(tsFile); });\n        return {\n            analyzedModules: mergeAndValidateNgFiles(files),\n            analyzedInjectables: analyzedInjectables,\n        };\n    };\n    AotCompiler.prototype._createNgFactoryStub = function (outputCtx, file, emitFlags) {\n        var _this = this;\n        var componentId = 0;\n        file.ngModules.forEach(function (ngModuleMeta, ngModuleIndex) {\n            // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n            // so we don't change the .ngfactory file too much when adding the type-check block.\n            // create exports that user code can reference\n            _this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n            // add references to the symbols from the metadata.\n            // These can be used by the type check block for components,\n            // and they also cause TypeScript to include these files into the program too,\n            // which will make them part of the analyzedFiles.\n            var externalReferences = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngModuleMeta.transitiveModule.directives.map(function (d) { return d.reference; }), ngModuleMeta.transitiveModule.pipes.map(function (d) { return d.reference; }), ngModuleMeta.importedModules.map(function (m) { return m.type.reference; }), ngModuleMeta.exportedModules.map(function (m) { return m.type.reference; }), _this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]));\n            var externalReferenceVars = new Map();\n            externalReferences.forEach(function (ref, typeIndex) {\n                externalReferenceVars.set(ref, \"_decl\" + ngModuleIndex + \"_\" + typeIndex);\n            });\n            externalReferenceVars.forEach(function (varName, reference) {\n                outputCtx.statements.push(variable(varName)\n                    .set(NULL_EXPR.cast(DYNAMIC_TYPE))\n                    .toDeclStmt(expressionType(outputCtx.importExpr(reference, /* typeParams */ null, /* useSummaries */ false))));\n            });\n            if (emitFlags & 2 /* TypeCheck */) {\n                // add the type-check block for all components of the NgModule\n                ngModuleMeta.declaredDirectives.forEach(function (dirId) {\n                    var compMeta = _this._metadataResolver.getDirectiveMetadata(dirId.reference);\n                    if (!compMeta.isComponent) {\n                        return;\n                    }\n                    componentId++;\n                    _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_Host_\" + componentId, ngModuleMeta, _this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\n                    _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_\" + componentId, ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n                });\n            }\n        });\n        if (outputCtx.statements.length === 0) {\n            _createEmptyStub(outputCtx);\n        }\n    };\n    AotCompiler.prototype._externalIdentifierReferences = function (references) {\n        var e_1, _a;\n        var result = [];\n        try {\n            for (var references_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(references), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {\n                var reference = references_1_1.value;\n                var token = createTokenForExternalReference(this.reflector, reference);\n                if (token.identifier) {\n                    result.push(token.identifier.reference);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (references_1_1 && !references_1_1.done && (_a = references_1.return)) _a.call(references_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return result;\n    };\n    AotCompiler.prototype._createTypeCheckBlock = function (ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\n        var _a;\n        var _b = this._parseTemplate(compMeta, moduleMeta, directives), parsedTemplate = _b.template, usedPipes = _b.pipes;\n        (_a = ctx.statements).push.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx)));\n    };\n    AotCompiler.prototype.emitMessageBundle = function (analyzeResult, locale) {\n        var _this = this;\n        var errors = [];\n        var htmlParser = new HtmlParser();\n        // TODO(vicb): implicit tags & attributes\n        var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        analyzeResult.files.forEach(function (file) {\n            var compMetas = [];\n            file.directives.forEach(function (directiveType) {\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(directiveType);\n                if (dirMeta && dirMeta.isComponent) {\n                    compMetas.push(dirMeta);\n                }\n            });\n            compMetas.forEach(function (compMeta) {\n                var html = compMeta.template.template;\n                // Template URL points to either an HTML or TS file depending on whether\n                // the file is used with `templateUrl:` or `template:`, respectively.\n                var templateUrl = compMeta.template.templateUrl;\n                var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n            });\n        });\n        if (errors.length) {\n            throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n        }\n        return messageBundle;\n    };\n    AotCompiler.prototype.emitAllPartialModules = function (_a, r3Files) {\n        var _this = this;\n        var ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files;\n        var contextMap = new Map();\n        var getContext = function (fileName) {\n            if (!contextMap.has(fileName)) {\n                contextMap.set(fileName, _this._createOutputContext(fileName));\n            }\n            return contextMap.get(fileName);\n        };\n        files.forEach(function (file) { return _this._compilePartialModule(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables, getContext(file.fileName)); });\n        r3Files.forEach(function (file) { return _this._compileShallowModules(file.fileName, file.shallowModules, getContext(file.fileName)); });\n        return Array.from(contextMap.values())\n            .map(function (context) { return ({\n            fileName: context.genFilePath,\n            statements: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(context.constantPool.statements, context.statements),\n        }); });\n    };\n    AotCompiler.prototype._compileShallowModules = function (fileName, shallowModules, context) {\n        var _this = this;\n        shallowModules.forEach(function (module) { return compileNgModuleFromRender2(context, module, _this._injectableCompiler); });\n    };\n    AotCompiler.prototype._compilePartialModule = function (fileName, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables, context) {\n        var _this = this;\n        var errors = [];\n        var schemaRegistry = new DomElementSchemaRegistry();\n        var hostBindingParser = new BindingParser(this._templateParser.expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [], errors);\n        // Process all components and directives\n        directives.forEach(function (directiveType) {\n            var directiveMetadata = _this._metadataResolver.getDirectiveMetadata(directiveType);\n            if (directiveMetadata.isComponent) {\n                var module = ngModuleByPipeOrDirective.get(directiveType);\n                module ||\n                    error(\"Cannot determine the module for component '\" + identifierName(directiveMetadata.type) + \"'\");\n                var htmlAst = directiveMetadata.template.htmlAst;\n                var preserveWhitespaces = directiveMetadata.template.preserveWhitespaces;\n                if (!preserveWhitespaces) {\n                    htmlAst = removeWhitespaces(htmlAst);\n                }\n                var render3Ast = htmlAstToRender3Ast(htmlAst.rootNodes, hostBindingParser);\n                // Map of StaticType by directive selectors\n                var directiveTypeBySel_1 = new Map();\n                var directives_1 = module.transitiveModule.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n                directives_1.forEach(function (directive) {\n                    if (directive.selector) {\n                        directiveTypeBySel_1.set(directive.selector, directive.type.reference);\n                    }\n                });\n                // Map of StaticType by pipe names\n                var pipeTypeByName_1 = new Map();\n                var pipes_1 = module.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n                pipes_1.forEach(function (pipe) {\n                    pipeTypeByName_1.set(pipe.name, pipe.type.reference);\n                });\n                compileComponentFromRender2(context, directiveMetadata, render3Ast, _this.reflector, hostBindingParser, directiveTypeBySel_1, pipeTypeByName_1);\n            }\n            else {\n                compileDirectiveFromRender2(context, directiveMetadata, _this.reflector, hostBindingParser);\n            }\n        });\n        pipes.forEach(function (pipeType) {\n            var pipeMetadata = _this._metadataResolver.getPipeMetadata(pipeType);\n            if (pipeMetadata) {\n                compilePipeFromRender2(context, pipeMetadata, _this.reflector);\n            }\n        });\n        injectables.forEach(function (injectable) { return _this._injectableCompiler.compile(injectable, context); });\n    };\n    AotCompiler.prototype.emitAllPartialModules2 = function (files) {\n        var _this = this;\n        // Using reduce like this is a select many pattern (where map is a select pattern)\n        return files.reduce(function (r, file) {\n            r.push.apply(r, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this._emitPartialModule2(file.fileName, file.injectables)));\n            return r;\n        }, []);\n    };\n    AotCompiler.prototype._emitPartialModule2 = function (fileName, injectables) {\n        var _this = this;\n        var context = this._createOutputContext(fileName);\n        injectables.forEach(function (injectable) { return _this._injectableCompiler.compile(injectable, context); });\n        if (context.statements && context.statements.length > 0) {\n            return [{ fileName: fileName, statements: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(context.constantPool.statements, context.statements) }];\n        }\n        return [];\n    };\n    AotCompiler.prototype.emitAllImpls = function (analyzeResult) {\n        var _this = this;\n        var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective, files = analyzeResult.files;\n        var sourceModules = files.map(function (file) { return _this._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n        return flatten(sourceModules);\n    };\n    AotCompiler.prototype._compileImplFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n        var generatedFiles = [];\n        var outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n        generatedFiles.push.apply(generatedFiles, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx)));\n        // compile all ng modules\n        ngModules.forEach(function (ngModuleMeta) { return _this._compileModule(outputCtx, ngModuleMeta); });\n        // compile components\n        directives.forEach(function (dirType) {\n            var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);\n            if (!compMeta.isComponent) {\n                return;\n            }\n            var ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            // compile styles\n            var componentStylesheet = _this._styleCompiler.compileComponent(outputCtx, compMeta);\n            // Note: compMeta is a component and therefore template is non null.\n            compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n                // Note: fill non shim and shim style files as they might\n                // be shared by component with and without ViewEncapsulation.\n                var shim = _this._styleCompiler.needsStyleShim(compMeta);\n                generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n                if (_this._options.allowEmptyCodegenFiles) {\n                    generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n                }\n            });\n            // compile components\n            var compViewVars = _this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n            _this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n        });\n        if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n            var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    AotCompiler.prototype._createSummary = function (srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n        var _this = this;\n        var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var typeData = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ngModules.map(function (meta) { return ({\n            summary: _this._metadataResolver.getNgModuleSummary(meta.type.reference),\n            metadata: _this._metadataResolver.getNgModuleMetadata(meta.type.reference)\n        }); }), directives.map(function (ref) { return ({\n            summary: _this._metadataResolver.getDirectiveSummary(ref),\n            metadata: _this._metadataResolver.getDirectiveMetadata(ref)\n        }); }), pipes.map(function (ref) { return ({\n            summary: _this._metadataResolver.getPipeSummary(ref),\n            metadata: _this._metadataResolver.getPipeMetadata(ref)\n        }); }), injectables.map(function (ref) { return ({\n            summary: _this._metadataResolver.getInjectableSummary(ref.symbol),\n            metadata: _this._metadataResolver.getInjectableSummary(ref.symbol).type\n        }); }));\n        var forJitOutputCtx = this._options.enableSummariesForJit ?\n            this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n            null;\n        var _a = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n                StmtModifier.Exported\n            ]));\n        });\n        var summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n        var result = [summaryJson];\n        if (forJitOutputCtx) {\n            result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n        }\n        return result;\n    };\n    AotCompiler.prototype._compileModule = function (outputCtx, ngModule) {\n        var providers = [];\n        if (this._options.locale) {\n            var normalizedLocale = this._options.locale.replace(/_/g, '-');\n            providers.push({\n                token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),\n                useValue: normalizedLocale,\n            });\n        }\n        if (this._options.i18nFormat) {\n            providers.push({\n                token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._options.i18nFormat\n            });\n        }\n        this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    };\n    AotCompiler.prototype._compileComponentFactory = function (outputCtx, compMeta, ngModule, fileSuffix) {\n        var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n        var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n        var compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var inputsExprs = [];\n        for (var propName in compMeta.inputs) {\n            var templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var outputsExprs = [];\n        for (var propName in compMeta.outputs) {\n            var templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        outputCtx.statements.push(variable(compFactoryVar)\n            .set(importExpr(Identifiers.createComponentFactory).callFn([\n            literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(compMeta.template.ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(Identifiers.ComponentFactory, [expressionType(outputCtx.importExpr(compMeta.type.reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));\n    };\n    AotCompiler.prototype._compileComponent = function (outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n        var _a = this._parseTemplate(compMeta, ngModule, directiveIdentifiers), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n        }\n        return viewResult;\n    };\n    AotCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n        var _this = this;\n        if (this._templateAstCache.has(compMeta.type.reference)) {\n            return this._templateAstCache.get(compMeta.type.reference);\n        }\n        var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n        var directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n        this._templateAstCache.set(compMeta.type.reference, result);\n        return result;\n    };\n    AotCompiler.prototype._createOutputContext = function (genFilePath) {\n        var _this = this;\n        var importExpr$1 = function (symbol, typeParams, useSummaries) {\n            if (typeParams === void 0) { typeParams = null; }\n            if (useSummaries === void 0) { useSummaries = true; }\n            if (!(symbol instanceof StaticSymbol)) {\n                throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(symbol));\n            }\n            var arity = _this._symbolResolver.getTypeArity(symbol) || 0;\n            var _a = _this._symbolResolver.getImportAs(symbol, useSummaries) || symbol, filePath = _a.filePath, name = _a.name, members = _a.members;\n            var importModule = _this._fileNameToModuleName(filePath, genFilePath);\n            // It should be good enough to compare filePath to genFilePath and if they are equal\n            // there is a self reference. However, ngfactory files generate to .ts but their\n            // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n            // and is tracked by #17705.\n            var selfReference = _this._fileNameToModuleName(genFilePath, genFilePath);\n            var moduleName = importModule === selfReference ? null : importModule;\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var suppliedTypeParams = typeParams || [];\n            var missingTypeParamsCount = arity - suppliedTypeParams.length;\n            var allTypeParams = suppliedTypeParams.concat(newArray(missingTypeParamsCount, DYNAMIC_TYPE));\n            return members.reduce(function (expr, memberName) { return expr.prop(memberName); }, importExpr(new ExternalReference(moduleName, name, null), allTypeParams));\n        };\n        return { statements: [], genFilePath: genFilePath, importExpr: importExpr$1, constantPool: new ConstantPool() };\n    };\n    AotCompiler.prototype._fileNameToModuleName = function (importedFilePath, containingFilePath) {\n        return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n            this._symbolResolver.getKnownModuleName(importedFilePath) ||\n            this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n    };\n    AotCompiler.prototype._codegenStyles = function (srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\n        var outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));\n        var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n        _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n        return this._codegenSourceModule(srcFileUrl, outputCtx);\n    };\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, ctx) {\n        return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    };\n    AotCompiler.prototype.listLazyRoutes = function (entryRoute, analyzedModules) {\n        var e_2, _a, e_3, _b;\n        var self = this;\n        if (entryRoute) {\n            var symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n            return visitLazyRoute(symbol);\n        }\n        else if (analyzedModules) {\n            var allLazyRoutes = [];\n            try {\n                for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(analyzedModules.ngModules), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var ngModule = _d.value;\n                    var lazyRoutes = listLazyRoutes(ngModule, this.reflector);\n                    try {\n                        for (var lazyRoutes_1 = (e_3 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(lazyRoutes)), lazyRoutes_1_1 = lazyRoutes_1.next(); !lazyRoutes_1_1.done; lazyRoutes_1_1 = lazyRoutes_1.next()) {\n                            var lazyRoute = lazyRoutes_1_1.value;\n                            allLazyRoutes.push(lazyRoute);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (lazyRoutes_1_1 && !lazyRoutes_1_1.done && (_b = lazyRoutes_1.return)) _b.call(lazyRoutes_1);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            return allLazyRoutes;\n        }\n        else {\n            throw new Error(\"Either route or analyzedModules has to be specified!\");\n        }\n        function visitLazyRoute(symbol, seenRoutes, allLazyRoutes) {\n            var e_4, _a;\n            if (seenRoutes === void 0) { seenRoutes = new Set(); }\n            if (allLazyRoutes === void 0) { allLazyRoutes = []; }\n            // Support pointing to default exports, but stop recursing there,\n            // as the StaticReflector does not yet support default exports.\n            if (seenRoutes.has(symbol) || !symbol.name) {\n                return allLazyRoutes;\n            }\n            seenRoutes.add(symbol);\n            var lazyRoutes = listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);\n            try {\n                for (var lazyRoutes_2 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(lazyRoutes), lazyRoutes_2_1 = lazyRoutes_2.next(); !lazyRoutes_2_1.done; lazyRoutes_2_1 = lazyRoutes_2.next()) {\n                    var lazyRoute = lazyRoutes_2_1.value;\n                    allLazyRoutes.push(lazyRoute);\n                    visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (lazyRoutes_2_1 && !lazyRoutes_2_1.done && (_a = lazyRoutes_2.return)) _a.call(lazyRoutes_2);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n            return allLazyRoutes;\n        }\n    };\n    return AotCompiler;\n}());\nfunction _createEmptyStub(outputCtx) {\n    // Note: We need to produce at least one import statement so that\n    // TypeScript knows that the file is an es6 module. Otherwise our generated\n    // exports / imports won't be emitted properly by TypeScript.\n    outputCtx.statements.push(importExpr(Identifiers.ComponentFactory).toStmt());\n}\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n    });\n}\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\nfunction analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\n    return mergeAnalyzedFiles(files);\n}\nfunction analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\nfunction validateAnalyzedModules(analyzedModules) {\n    if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n        var messages = analyzedModules.symbolsMissingModule.map(function (s) { return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\"; });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return analyzedModules;\n}\n// Analyzes all of the program files,\n// including files that are not part of the program\n// but are referenced by an NgModule.\nfunction _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var seenFiles = new Set();\n    var files = [];\n    var visitFile = function (fileName) {\n        if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n            return false;\n        }\n        seenFiles.add(fileName);\n        var analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n        files.push(analyzedFile);\n        analyzedFile.ngModules.forEach(function (ngModule) {\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return visitFile(modMeta.reference.filePath); });\n        });\n    };\n    fileNames.forEach(function (fileName) { return visitFile(fileName); });\n    return files;\n}\nfunction analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\n    var abstractDirectives = [];\n    var directives = [];\n    var pipes = [];\n    var injectables = [];\n    var ngModules = [];\n    var hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n    var exportsNonSourceFiles = false;\n    var isDeclarationFile = fileName.endsWith('.d.ts');\n    // Don't analyze .d.ts files that have no decorators as a shortcut\n    // to speed up the analysis. This prevents us from\n    // resolving the references in these files.\n    // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n    // which is not the case when .d.ts files are treated as input files.\n    if (!isDeclarationFile || hasDecorators) {\n        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n            var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var symbolMeta = resolvedSymbol.metadata;\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n                return;\n            }\n            var isNgSymbol = false;\n            if (symbolMeta.__symbolic === 'class') {\n                if (metadataResolver.isDirective(symbol)) {\n                    isNgSymbol = true;\n                    // This directive either has a selector or doesn't. Selector-less directives get tracked\n                    // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\n                    // directives at all, really, other than to persist their metadata. This is done so that\n                    // apps will have an easier time migrating to Ivy, which requires the selector-less\n                    // annotations to be applied.\n                    if (!metadataResolver.isAbstractDirective(symbol)) {\n                        // The directive is an ordinary directive.\n                        directives.push(symbol);\n                    }\n                    else {\n                        // The directive has no selector and is an \"abstract\" directive, so track it\n                        // accordingly.\n                        abstractDirectives.push(symbol);\n                    }\n                }\n                else if (metadataResolver.isPipe(symbol)) {\n                    isNgSymbol = true;\n                    pipes.push(symbol);\n                }\n                else if (metadataResolver.isNgModule(symbol)) {\n                    var ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n                    if (ngModule) {\n                        isNgSymbol = true;\n                        ngModules.push(ngModule);\n                    }\n                }\n                else if (metadataResolver.isInjectable(symbol)) {\n                    isNgSymbol = true;\n                    var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n                    if (injectable) {\n                        injectables.push(injectable);\n                    }\n                }\n            }\n            if (!isNgSymbol) {\n                exportsNonSourceFiles =\n                    exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n            }\n        });\n    }\n    return {\n        fileName: fileName,\n        directives: directives,\n        abstractDirectives: abstractDirectives,\n        pipes: pipes,\n        ngModules: ngModules,\n        injectables: injectables,\n        exportsNonSourceFiles: exportsNonSourceFiles,\n    };\n}\nfunction analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {\n    var injectables = [];\n    var shallowModules = [];\n    if (staticSymbolResolver.hasDecorators(fileName)) {\n        staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n            var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var symbolMeta = resolvedSymbol.metadata;\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n                return;\n            }\n            if (symbolMeta.__symbolic === 'class') {\n                if (metadataResolver.isInjectable(symbol)) {\n                    var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n                    if (injectable) {\n                        injectables.push(injectable);\n                    }\n                }\n                else if (metadataResolver.isNgModule(symbol)) {\n                    var module = metadataResolver.getShallowModuleMetadata(symbol);\n                    if (module) {\n                        shallowModules.push(module);\n                    }\n                }\n            }\n        });\n    }\n    return { fileName: fileName, injectables: injectables, shallowModules: shallowModules };\n}\nfunction isValueExportingNonSourceFile(host, metadata) {\n    var exportsNonSourceFiles = false;\n    var Visitor = /** @class */ (function () {\n        function Visitor() {\n        }\n        Visitor.prototype.visitArray = function (arr, context) {\n            var _this = this;\n            arr.forEach(function (v) { return visitValue(v, _this, context); });\n        };\n        Visitor.prototype.visitStringMap = function (map, context) {\n            var _this = this;\n            Object.keys(map).forEach(function (key) { return visitValue(map[key], _this, context); });\n        };\n        Visitor.prototype.visitPrimitive = function (value, context) { };\n        Visitor.prototype.visitOther = function (value, context) {\n            if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n                exportsNonSourceFiles = true;\n            }\n        };\n        return Visitor;\n    }());\n    visitValue(metadata, new Visitor(), null);\n    return exportsNonSourceFiles;\n}\nfunction mergeAnalyzedFiles(analyzedFiles) {\n    var allNgModules = [];\n    var ngModuleByPipeOrDirective = new Map();\n    var allPipesAndDirectives = new Set();\n    analyzedFiles.forEach(function (af) {\n        af.ngModules.forEach(function (ngModule) {\n            allNgModules.push(ngModule);\n            ngModule.declaredDirectives.forEach(function (d) { return ngModuleByPipeOrDirective.set(d.reference, ngModule); });\n            ngModule.declaredPipes.forEach(function (p) { return ngModuleByPipeOrDirective.set(p.reference, ngModule); });\n        });\n        af.directives.forEach(function (d) { return allPipesAndDirectives.add(d); });\n        af.pipes.forEach(function (p) { return allPipesAndDirectives.add(p); });\n    });\n    var symbolsMissingModule = [];\n    allPipesAndDirectives.forEach(function (ref) {\n        if (!ngModuleByPipeOrDirective.has(ref)) {\n            symbolsMissingModule.push(ref);\n        }\n    });\n    return {\n        ngModules: allNgModules,\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        symbolsMissingModule: symbolsMissingModule,\n        files: analyzedFiles\n    };\n}\nfunction mergeAndValidateNgFiles(files) {\n    return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar FORMATTED_MESSAGE = 'ngFormattedMessage';\nfunction indentStr(level) {\n    if (level <= 0)\n        return '';\n    if (level < 6)\n        return ['', ' ', '  ', '   ', '    ', '     '][level];\n    var half = indentStr(Math.floor(level / 2));\n    return half + half + (level % 2 === 1 ? ' ' : '');\n}\nfunction formatChain(chain, indent) {\n    var e_1, _a;\n    if (indent === void 0) { indent = 0; }\n    if (!chain)\n        return '';\n    var position = chain.position ?\n        chain.position.fileName + \"(\" + (chain.position.line + 1) + \",\" + (chain.position.column + 1) + \")\" :\n        '';\n    var prefix = position && indent === 0 ? position + \": \" : '';\n    var postfix = position && indent !== 0 ? \" at \" + position : '';\n    var message = \"\" + prefix + chain.message + postfix;\n    if (chain.next) {\n        try {\n            for (var _b = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(chain.next), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var kid = _c.value;\n                message += '\\n' + formatChain(kid, indent + 2);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    return \"\" + indentStr(indent) + message;\n}\nfunction formattedError(chain) {\n    var message = formatChain(chain) + '.';\n    var error = syntaxError(message);\n    error[FORMATTED_MESSAGE] = true;\n    error.chain = chain;\n    error.position = chain.position;\n    return error;\n}\nfunction isFormattedError(error) {\n    return !!error[FORMATTED_MESSAGE];\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar ANGULAR_ROUTER = '@angular/router';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\nvar USE_VALUE$1 = 'useValue';\nvar PROVIDE = 'provide';\nvar REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);\nvar TYPEGUARD_POSTFIX = 'TypeGuard';\nvar USE_IF = 'UseIf';\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = /** @class */ (function () {\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        var _this = this;\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.shallowAnnotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.staticCache = new Map();\n        this.conversionMap = new Map();\n        this.resolvedExternalReferences = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n    }\n    StaticReflector.prototype.componentModuleUrl = function (typeOrFunc) {\n        var staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * Invalidate the specified `symbols` on program change.\n     * @param symbols\n     */\n    StaticReflector.prototype.invalidateSymbols = function (symbols) {\n        var e_1, _a;\n        try {\n            for (var symbols_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n                var symbol = symbols_1_1.value;\n                this.annotationCache.delete(symbol);\n                this.shallowAnnotationCache.delete(symbol);\n                this.propertyCache.delete(symbol);\n                this.parameterCache.delete(symbol);\n                this.methodCache.delete(symbol);\n                this.staticCache.delete(symbol);\n                this.conversionMap.delete(symbol);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    StaticReflector.prototype.resolveExternalReference = function (ref, containingFile) {\n        var key = undefined;\n        if (!containingFile) {\n            key = ref.moduleName + \":\" + ref.name;\n            var declarationSymbol_1 = this.resolvedExternalReferences.get(key);\n            if (declarationSymbol_1)\n                return declarationSymbol_1;\n        }\n        var refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);\n        var declarationSymbol = this.findSymbolDeclaration(refSymbol);\n        if (!containingFile) {\n            this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);\n            this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n        }\n        if (key) {\n            this.resolvedExternalReferences.set(key, declarationSymbol);\n        }\n        return declarationSymbol;\n    };\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    StaticReflector.prototype.tryFindDeclaration = function (moduleUrl, name, containingFile) {\n        var _this = this;\n        return this.symbolResolver.ignoreErrorsFor(function () { return _this.findDeclaration(moduleUrl, name, containingFile); });\n    };\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol) {\n            var resolvedMetadata = resolvedSymbol.metadata;\n            if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n                resolvedMetadata = resolvedMetadata.symbol;\n            }\n            if (resolvedMetadata instanceof StaticSymbol) {\n                return this.findSymbolDeclaration(resolvedSymbol.metadata);\n            }\n        }\n        return symbol;\n    };\n    StaticReflector.prototype.tryAnnotations = function (type) {\n        var originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        try {\n            return this.annotations(type);\n        }\n        finally {\n            this.errorRecorder = originalRecorder;\n        }\n    };\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        return this._annotations(type, function (type, decorators) { return _this.simplify(type, decorators); }, this.annotationCache);\n    };\n    StaticReflector.prototype.shallowAnnotations = function (type) {\n        var _this = this;\n        return this._annotations(type, function (type, decorators) { return _this.simplify(type, decorators, true); }, this.shallowAnnotationCache);\n    };\n    StaticReflector.prototype._annotations = function (type, simplify, annotationCache) {\n        var annotations = annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var classMetadata = this.getTypeMetadata(type);\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(parentAnnotations));\n            }\n            var ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = simplify(type, classMetadata['decorators']);\n                if (ownAnnotations_1) {\n                    annotations.push.apply(annotations, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(ownAnnotations_1));\n                }\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n                    var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return requiredType.isTypeOf(ann); }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(formatMetadataError(metadataError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[summary.type.summaryKind] + \" in another compilation unit without duplicating the decorator\", \n                        /* summary */ undefined, \"Please add a \" + requiredAnnotationTypes.map(function (type) { return type.ngMetadataName; })\n                            .join(' or ') + \" decorator to the class\"), type), type);\n                    }\n                }\n            }\n            annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    propMetadata[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var propData = members_1[propName];\n                var prop = propData\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var decorators = [];\n                if (propMetadata[propName]) {\n                    decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(propMetadata[propName]));\n                }\n                propMetadata[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this.simplify(type, prop['decorators'])));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    StaticReflector.prototype.parameters = function (type) {\n        var _this = this;\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var classMetadata = this.getTypeMetadata(type);\n                var parentType = this.findParentType(type, classMetadata);\n                var members = classMetadata ? classMetadata['members'] : null;\n                var ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var ctor = ctorData.find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var rawParameterTypes = ctor['parameters'] || [];\n                    var parameterDecorators_1 = this.simplify(type, ctor['parameterDecorators'] || []);\n                    parameters_1 = [];\n                    rawParameterTypes.forEach(function (rawParamType, index) {\n                        var nestedResult = [];\n                        var paramType = _this.trySimplify(type, rawParamType);\n                        if (paramType)\n                            nestedResult.push(paramType);\n                        var decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(decorators));\n                        }\n                        parameters_1.push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    StaticReflector.prototype._methodNames = function (type) {\n        var methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    methodNames[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var propData = members_2[propName];\n                var isMethod = propData.some(function (a) { return a['__symbolic'] == 'method'; });\n                methodNames[propName] = methodNames[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    StaticReflector.prototype._staticMembers = function (type) {\n        var staticMembers = this.staticCache.get(type);\n        if (!staticMembers) {\n            var classMetadata = this.getTypeMetadata(type);\n            var staticMemberData = classMetadata['statics'] || {};\n            staticMembers = Object.keys(staticMemberData);\n            this.staticCache.set(type, staticMembers);\n        }\n        return staticMembers;\n    };\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    StaticReflector.prototype.guards = function (type) {\n        var e_2, _a;\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"guards received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return {};\n        }\n        var staticMembers = this._staticMembers(type);\n        var result = {};\n        try {\n            for (var staticMembers_1 = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(staticMembers), staticMembers_1_1 = staticMembers_1.next(); !staticMembers_1_1.done; staticMembers_1_1 = staticMembers_1.next()) {\n                var name_1 = staticMembers_1_1.value;\n                if (name_1.endsWith(TYPEGUARD_POSTFIX)) {\n                    var property = name_1.substr(0, name_1.length - TYPEGUARD_POSTFIX.length);\n                    var value = void 0;\n                    if (property.endsWith(USE_IF)) {\n                        property = name_1.substr(0, property.length - USE_IF.length);\n                        value = USE_IF;\n                    }\n                    else {\n                        value = this.getStaticSymbol(type.filePath, type.name, [name_1]);\n                    }\n                    result[property] = value;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (staticMembers_1_1 && !staticMembers_1_1.done && (_a = staticMembers_1.return)) _a.call(staticMembers_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return result;\n    };\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], args)))(); });\n    };\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n        this.ANALYZE_FOR_ENTRY_COMPONENTS =\n            this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * Simplify but discard any errors\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /** @internal */\n    StaticReflector.prototype.simplify = function (context, value, lazy) {\n        if (lazy === void 0) { lazy = false; }\n        var self = this;\n        var scope = BindingScope$1.empty;\n        var calling = new Map();\n        var rootContext = context;\n        function simplifyInContext(context, value, depth, references) {\n            function resolveReferenceValue(staticSymbol) {\n                var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            function simplifyEagerly(value) {\n                return simplifyInContext(context, value, depth, 0);\n            }\n            function simplifyLazily(value) {\n                return simplifyInContext(context, value, depth, references + 1);\n            }\n            function simplifyNested(nestedContext, value) {\n                if (nestedContext === context) {\n                    // If the context hasn't changed let the exception propagate unmodified.\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\n                }\n                try {\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\n                }\n                catch (e) {\n                    if (isMetadataError(e)) {\n                        // Propagate the message text up but add a message to the chain that explains how we got\n                        // here.\n                        // e.chain implies e.symbol\n                        var summaryMsg = e.chain ? 'references \\'' + e.symbol.name + '\\'' : errorSummary(e);\n                        var summary = \"'\" + nestedContext.name + \"' \" + summaryMsg;\n                        var chain = { message: summary, position: e.position, next: e.chain };\n                        // TODO(chuckj): retrieve the position information indirectly from the collectors node\n                        // map if the metadata is from a .ts file.\n                        self.error({\n                            message: e.message,\n                            advise: e.advise,\n                            context: e.context,\n                            chain: chain,\n                            symbol: nestedContext\n                        }, context);\n                    }\n                    else {\n                        // It is probably an internal error.\n                        throw e;\n                    }\n                }\n            }\n            function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        self.error({\n                            message: 'Recursion is not supported',\n                            summary: \"called '\" + functionSymbol.name + \"' recursively\",\n                            value: targetFunction\n                        }, functionSymbol);\n                    }\n                    try {\n                        var value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var parameters = targetFunction['parameters'];\n                            var defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyNested(context, arg); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(defaults.slice(args.length).map(function (value) { return simplify(value); })));\n                            }\n                            calling.set(functionSymbol, true);\n                            var functionScope = BindingScope$1.build();\n                            for (var i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var oldScope = scope;\n                            var result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyNested(functionSymbol, value_1);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                var position = undefined;\n                if (targetExpression && targetExpression.__symbolic == 'resolved') {\n                    var line = targetExpression.line;\n                    var character = targetExpression.character;\n                    var fileName = targetExpression.fileName;\n                    if (fileName != null && line != null && character != null) {\n                        position = { fileName: fileName, line: line, column: character };\n                    }\n                }\n                self.error({\n                    message: FUNCTION_CALL_NOT_SUPPORTED,\n                    context: functionSymbol,\n                    value: targetFunction,\n                    position: position\n                }, context);\n            }\n            function simplify(expression) {\n                var e_3, _a, e_4, _b;\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (Array.isArray(expression)) {\n                    var result_2 = [];\n                    try {\n                        for (var _c = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(expression), _d = _c.next(); !_d.done; _d = _c.next()) {\n                            var item = _d.value;\n                            // Check for a spread expression\n                            if (item && item.__symbolic === 'spread') {\n                                // We call with references as 0 because we require the actual value and cannot\n                                // tolerate a reference here.\n                                var spreadArray = simplifyEagerly(item.expression);\n                                if (Array.isArray(spreadArray)) {\n                                    try {\n                                        for (var spreadArray_1 = (e_4 = void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__values\"])(spreadArray)), spreadArray_1_1 = spreadArray_1.next(); !spreadArray_1_1.done; spreadArray_1_1 = spreadArray_1.next()) {\n                                            var spreadItem = spreadArray_1_1.value;\n                                            result_2.push(spreadItem);\n                                        }\n                                    }\n                                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                    finally {\n                                        try {\n                                            if (spreadArray_1_1 && !spreadArray_1_1.done && (_b = spreadArray_1.return)) _b.call(spreadArray_1);\n                                        }\n                                        finally { if (e_4) throw e_4.error; }\n                                    }\n                                    continue;\n                                }\n                            }\n                            var value_2 = simplify(item);\n                            if (shouldIgnore(value_2)) {\n                                continue;\n                            }\n                            result_2.push(value_2);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols or if we are in a reference context and\n                    // the symbol doesn't have members.\n                    if (expression === self.injectionToken || self.conversionMap.has(expression) ||\n                        (references > 0 && !expression.members.length)) {\n                        return expression;\n                    }\n                    else {\n                        var staticSymbol = expression;\n                        var declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue != null) {\n                            return simplifyNested(staticSymbol, declarationValue);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var indexTarget = simplifyEagerly(expression['expression']);\n                                var index = simplifyEagerly(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var member = expression['member'];\n                                var selectContext = context;\n                                var selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue != null) {\n                                        return simplifyNested(selectContext, declarationValue);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyNested(selectContext, selectTarget[member]);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references, as symbol references have\n                                // been converted into 'resolved'\n                                // in the StaticSymbolResolver.\n                                var name_2 = expression['name'];\n                                var localValue = scope.resolve(name_2);\n                                if (localValue != BindingScope$1.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'resolved':\n                                try {\n                                    return simplify(expression.symbol);\n                                }\n                                catch (e) {\n                                    // If an error is reported evaluating the symbol record the position of the\n                                    // reference in the error so it can\n                                    // be reported in the error message generated from the exception.\n                                    if (isMetadataError(e) && expression.fileName != null &&\n                                        expression.line != null && expression.character != null) {\n                                        e.position = {\n                                            fileName: expression.fileName,\n                                            line: expression.line,\n                                            column: expression.character\n                                        };\n                                    }\n                                    throw e;\n                                }\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        // OpaqueToken is supported too as it is required by the language service to\n                                        // support v4 and prior versions of Angular.\n                                        return context;\n                                    }\n                                    var argExpressions = expression['arguments'] || [];\n                                    var converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var args = argExpressions.map(function (arg) { return simplifyNested(context, arg); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions, expression['expression']);\n                                    }\n                                }\n                                return IGNORE;\n                            case 'error':\n                                var message = expression.message;\n                                if (expression['line'] != null) {\n                                    self.error({\n                                        message: message,\n                                        context: expression.context,\n                                        value: expression,\n                                        position: {\n                                            fileName: expression['fileName'],\n                                            line: expression['line'],\n                                            column: expression['character']\n                                        }\n                                    }, context);\n                                }\n                                else {\n                                    self.error({ message: message, context: expression.context }, context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) {\n                        if (REFERENCE_SET.has(name)) {\n                            if (name === USE_VALUE$1 && PROVIDE in expression) {\n                                // If this is a provider expression, check for special tokens that need the value\n                                // during analysis.\n                                var provide = simplify(expression.provide);\n                                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                                    return simplify(value);\n                                }\n                            }\n                            return simplifyLazily(value);\n                        }\n                        return simplify(value);\n                    });\n                }\n                return IGNORE;\n            }\n            return simplify(value);\n        }\n        var result;\n        try {\n            result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n        }\n        catch (e) {\n            if (this.errorRecorder) {\n                this.reportError(e, context);\n            }\n            else {\n                throw formatMetadataError(e, context);\n            }\n        }\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(formatMetadataError(error, context), (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    StaticReflector.prototype.error = function (_a, reportingContext) {\n        var message = _a.message, summary = _a.summary, advise = _a.advise, position = _a.position, context = _a.context, value = _a.value, symbol = _a.symbol, chain = _a.chain;\n        this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);\n    };\n    return StaticReflector;\n}());\nvar METADATA_ERROR = 'ngMetadataError';\nfunction metadataError(message, summary, advise, position, symbol, context, chain) {\n    var error = syntaxError(message);\n    error[METADATA_ERROR] = true;\n    if (advise)\n        error.advise = advise;\n    if (position)\n        error.position = position;\n    if (summary)\n        error.summary = summary;\n    if (context)\n        error.context = context;\n    if (chain)\n        error.chain = chain;\n    if (symbol)\n        error.symbol = symbol;\n    return error;\n}\nfunction isMetadataError(error) {\n    return !!error[METADATA_ERROR];\n}\nvar REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\nvar VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\nvar DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\nvar COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\nvar FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\nvar REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\nvar LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\nfunction expandedMessage(message, context) {\n    switch (message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (context && context.className) {\n                return \"References to a non-exported class are not supported in decorators but \" + context.className + \" was referenced.\";\n            }\n            break;\n        case VARIABLE_NOT_INITIALIZED:\n            return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n        case COULD_NOT_RESOLVE_TYPE:\n            if (context && context.typeName) {\n                return \"Could not resolve type \" + context.typeName;\n            }\n            break;\n        case FUNCTION_CALL_NOT_SUPPORTED:\n            if (context && context.name) {\n                return \"Function calls are not supported in decorators but '\" + context.name + \"' was called\";\n            }\n            return 'Function calls are not supported in decorators';\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (context && context.name) {\n                return \"Reference to a local (non-exported) symbols are not supported in decorators but '\" + context.name + \"' was referenced\";\n            }\n            break;\n        case LAMBDA_NOT_SUPPORTED:\n            return \"Function expressions are not supported in decorators\";\n    }\n    return message;\n}\nfunction messageAdvise(message, context) {\n    switch (message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (context && context.className) {\n                return \"Consider exporting '\" + context.className + \"'\";\n            }\n            break;\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'Consider simplifying to avoid destructuring';\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (context && context.name) {\n                return \"Consider exporting '\" + context.name + \"'\";\n            }\n            break;\n        case LAMBDA_NOT_SUPPORTED:\n            return \"Consider changing the function expression into an exported function\";\n    }\n    return undefined;\n}\nfunction errorSummary(error) {\n    if (error.summary) {\n        return error.summary;\n    }\n    switch (error.message) {\n        case REFERENCE_TO_NONEXPORTED_CLASS:\n            if (error.context && error.context.className) {\n                return \"references non-exported class \" + error.context.className;\n            }\n            break;\n        case VARIABLE_NOT_INITIALIZED:\n            return 'is not initialized';\n        case DESTRUCTURE_NOT_SUPPORTED:\n            return 'is a destructured variable';\n        case COULD_NOT_RESOLVE_TYPE:\n            return 'could not be resolved';\n        case FUNCTION_CALL_NOT_SUPPORTED:\n            if (error.context && error.context.name) {\n                return \"calls '\" + error.context.name + \"'\";\n            }\n            return \"calls a function\";\n        case REFERENCE_TO_LOCAL_SYMBOL:\n            if (error.context && error.context.name) {\n                return \"references local variable \" + error.context.name;\n            }\n            return \"references a local variable\";\n    }\n    return 'contains the error';\n}\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var result = {};\n    Object.keys(input).forEach(function (key) {\n        var value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\nvar BindingScope$1 = /** @class */ (function () {\n    function BindingScope() {\n    }\n    BindingScope.build = function () {\n        var current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    BindingScope.missing = {};\n    BindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\n    return BindingScope;\n}());\nvar PopulatedScope = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(PopulatedScope, _super);\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;\n    };\n    return PopulatedScope;\n}(BindingScope$1));\nfunction formatMetadataMessageChain(chain, advise) {\n    var expanded = expandedMessage(chain.message, chain.context);\n    var nesting = chain.symbol ? \" in '\" + chain.symbol.name + \"'\" : '';\n    var message = \"\" + expanded + nesting;\n    var position = chain.position;\n    var next = chain.next ?\n        formatMetadataMessageChain(chain.next, advise) :\n        advise ? { message: advise } : undefined;\n    return { message: message, position: position, next: next ? [next] : undefined };\n}\nfunction formatMetadataError(e, context) {\n    if (isMetadataError(e)) {\n        // Produce a formatted version of the and leaving enough information in the original error\n        // to recover the formatting information to eventually produce a diagnostic error message.\n        var position = e.position;\n        var chain = {\n            message: \"Error during template compile of '\" + context.name + \"'\",\n            position: position,\n            next: { message: e.message, next: e.chain, context: e.context, symbol: e.symbol }\n        };\n        var advise = e.advise || messageAdvise(e.message, e.context);\n        return formattedError(formatMetadataMessageChain(chain, advise));\n    }\n    return e;\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = /** @class */ (function () {\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        // Note: this will only contain StaticSymbols without members!\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Map();\n        // Note: this will only contain StaticSymbols without members!\n        this.importAs = new Map();\n        this.knownFileNameToModuleNames = new Map();\n    }\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n    };\n    AotSummaryResolver.prototype.toSummaryFileName = function (filePath, referringSrcFileName) {\n        return this.host.toSummaryFileName(filePath, referringSrcFileName);\n    };\n    AotSummaryResolver.prototype.fromSummaryFileName = function (fileName, referringLibFileName) {\n        return this.host.fromSummaryFileName(fileName, referringLibFileName);\n    };\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        var rootSymbol = staticSymbol.members.length ?\n            this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :\n            staticSymbol;\n        var summary = this.summaryCache.get(rootSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = this.summaryCache.get(staticSymbol);\n        }\n        return (rootSymbol === staticSymbol && summary) || null;\n    };\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        if (this._loadSummaryFile(filePath)) {\n            return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n        }\n        return null;\n    };\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return this.importAs.get(staticSymbol);\n    };\n    /**\n     * Converts a file path to a module name that can be used as an `import`.\n     */\n    AotSummaryResolver.prototype.getKnownModuleName = function (importedFilePath) {\n        return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n    };\n    AotSummaryResolver.prototype.addSummary = function (summary) {\n        this.summaryCache.set(summary.symbol, summary);\n    };\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        var hasSummary = this.loadedFilePaths.get(filePath);\n        if (hasSummary != null) {\n            return hasSummary;\n        }\n        var json = null;\n        if (this.isLibraryFile(filePath)) {\n            var summaryFilePath = summaryFileName(filePath);\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n        }\n        hasSummary = json != null;\n        this.loadedFilePaths.set(filePath, hasSummary);\n        if (json) {\n            var _a = deserializeSummaries(this.staticSymbolCache, this, filePath, json), moduleName = _a.moduleName, summaries = _a.summaries, importAs = _a.importAs;\n            summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n            if (moduleName) {\n                this.knownFileNameToModuleNames.set(filePath, moduleName);\n            }\n            importAs.forEach(function (importAs) {\n                _this.importAs.set(importAs.symbol, importAs.importAs);\n            });\n        }\n        return hasSummary;\n    };\n    return AotSummaryResolver;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction createAotUrlResolver(host) {\n    return {\n        resolve: function (basePath, url) {\n            var filePath = host.resourceNameToFileName(url, basePath);\n            if (!filePath) {\n                throw syntaxError(\"Couldn't resolve resource \" + url + \" from \" + basePath);\n            }\n            return filePath;\n        }\n    };\n}\n/**\n * Creates a new AotCompiler based on options and a host.\n */\nfunction createAotCompiler(compilerHost, options, errorCollector) {\n    var translations = options.translations || '';\n    var urlResolver = createAotUrlResolver(compilerHost);\n    var symbolCache = new StaticSymbolCache();\n    var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\n    var htmlParser;\n    if (!!options.enableIvy) {\n        // Ivy handles i18n at the compiler level so we must use a regular parser\n        htmlParser = new HtmlParser();\n    }\n    else {\n        htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n    }\n    var config = new CompilerConfig({\n        defaultEncapsulation: ViewEncapsulation.Emulated,\n        useJit: false,\n        missingTranslation: options.missingTranslation,\n        preserveWhitespaces: options.preserveWhitespaces,\n        strictInjectionParameters: options.strictInjectionParameters,\n    });\n    var normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var expressionParser = new Parser$1(new Lexer());\n    var elementSchemaRegistry = new DomElementSchemaRegistry();\n    var tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var viewCompiler = new ViewCompiler(staticReflector);\n    var typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\n    var compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(), summaryResolver, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n\nvar SummaryResolver = /** @class */ (function () {\n    function SummaryResolver() {\n    }\n    return SummaryResolver;\n}());\nvar JitSummaryResolver = /** @class */ (function () {\n    function JitSummaryResolver() {\n        this._summaries = new Map();\n    }\n    JitSummaryResolver.prototype.isLibraryFile = function () {\n        return false;\n    };\n    JitSummaryResolver.prototype.toSummaryFileName = function (fileName) {\n        return fileName;\n    };\n    JitSummaryResolver.prototype.fromSummaryFileName = function (fileName) {\n        return fileName;\n    };\n    JitSummaryResolver.prototype.resolveSummary = function (reference) {\n        return this._summaries.get(reference) || null;\n    };\n    JitSummaryResolver.prototype.getSymbolsOf = function () {\n        return [];\n    };\n    JitSummaryResolver.prototype.getImportAs = function (reference) {\n        return reference;\n    };\n    JitSummaryResolver.prototype.getKnownModuleName = function (fileName) {\n        return null;\n    };\n    JitSummaryResolver.prototype.addSummary = function (summary) {\n        this._summaries.set(summary.symbol, summary);\n    };\n    return JitSummaryResolver;\n}());\n\nfunction interpretStatements(statements, reflector) {\n    var ctx = new _ExecutionContext(null, null, null, new Map());\n    var visitor = new StatementInterpreter(reflector);\n    visitor.visitAllStatements(statements, ctx);\n    var result = {};\n    ctx.exports.forEach(function (exportName) {\n        result[exportName] = ctx.vars.get(exportName);\n    });\n    return result;\n}\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var childCtx = ctx.createChildWihtLocalVars();\n    for (var i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = /** @class */ (function () {\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n        this.exports = [];\n    }\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = /** @class */ (function () {\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[method.name] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) {\n            _this[field.name] = undefined;\n        });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = /** @class */ (function () {\n    function StatementInterpreter(reflector) {\n        this.reflector = reflector;\n    }\n    StatementInterpreter.prototype.debugAst = function (ast) {\n        return debugOutputAstAsTypeScript(ast);\n    };\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        var initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n        ctx.vars.set(stmt.name, initialValue);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var value = expr.value.visitExpression(this, ctx);\n        var currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    StatementInterpreter.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n        throw new Error('Cannot interpret a WrappedNodeExpr.');\n    };\n    StatementInterpreter.prototype.visitTypeofExpr = function (ast, ctx) {\n        throw new Error('Cannot interpret a TypeofExpr');\n    };\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return Object.getPrototypeOf(ctx.instance);\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var index = expr.index.visitExpression(this, ctx);\n        var value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var receiver = expr.receiver.visitExpression(this, ctx);\n        var args = this.visitAllExpressions(expr.args, ctx);\n        var result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args));\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(args));\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[expr.name].apply(receiver, args);\n        }\n        return result;\n    };\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var args = this.visitAllExpressions(stmt.args, ctx);\n        var fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var fn = stmt.fn.visitExpression(this, ctx);\n            return fn.apply(null, args);\n        }\n    };\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) {\n        return null;\n    };\n    StatementInterpreter.prototype.visitJSDocCommentStmt = function (stmt, context) {\n        return null;\n    };\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var args = this.visitAllExpressions(ast.args, ctx);\n        var clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])([void 0], args)))();\n    };\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) {\n        return ast.value;\n    };\n    StatementInterpreter.prototype.visitLocalizedString = function (ast, context) {\n        return null;\n    };\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n        return this.reflector.resolveExternalReference(ast.value);\n    };\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n        return ast.condition.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            ctx.exports.push(stmt.name);\n        }\n        return null;\n    };\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var result;\n        var receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var receiver = ast.receiver.visitExpression(this, ctx);\n        var prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var result = {};\n        ast.entries.forEach(function (entry) { return result[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var i = 0; i < statements.length; i++) {\n            var stmt = statements[i];\n            var val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = /** @class */ (function () {\n    function JitCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._summaryResolver = _summaryResolver;\n        this._reflector = _reflector;\n        this._jitEvaluator = _jitEvaluator;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this.getExtraNgModuleProviders = getExtraNgModuleProviders;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n        this._addedAotSummaries = new Set();\n    }\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    };\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    };\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    };\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    };\n    JitCompiler.prototype.getComponentFactory = function (component) {\n        var summary = this._metadataResolver.getDirectiveSummary(component);\n        return summary.componentFactory;\n    };\n    JitCompiler.prototype.loadAotSummaries = function (summaries) {\n        this.clearCache();\n        this._addAotSummaries(summaries);\n    };\n    JitCompiler.prototype._addAotSummaries = function (fn) {\n        if (this._addedAotSummaries.has(fn)) {\n            return;\n        }\n        this._addedAotSummaries.add(fn);\n        var summaries = fn();\n        for (var i = 0; i < summaries.length; i++) {\n            var entry = summaries[i];\n            if (typeof entry === 'function') {\n                this._addAotSummaries(entry);\n            }\n            else {\n                var summary = entry;\n                this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });\n            }\n        }\n    };\n    JitCompiler.prototype.hasAotSummary = function (ref) {\n        return !!this._summaryResolver.resolveSummary(ref);\n    };\n    JitCompiler.prototype._filterJitIdentifiers = function (ids) {\n        var _this = this;\n        return ids.map(function (mod) { return mod.reference; }).filter(function (ref) { return !_this.hasAotSummary(ref); });\n    };\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        });\n    };\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n            var componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return {\n                ngModuleFactory: _this._compileModule(moduleType),\n                componentFactories: componentFactories\n            };\n        });\n    };\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var loading = [];\n        var mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        // Note: for runtime compilation, we want to transitively compile all modules,\n        // so we also need to load the declared directives / pipes for all nested modules.\n        this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {\n            // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n            var moduleMeta = _this._metadataResolver.getNgModuleMetadata(nestedNgModule);\n            _this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {\n                var promise = _this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            _this._filterJitIdentifiers(moduleMeta.declaredPipes)\n                .forEach(function (ref) { return _this._metadataResolver.getOrLoadPipeMetadata(ref); });\n        });\n        return SyncAsync.all(loading);\n    };\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n        if (!ngModuleFactory) {\n            var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);\n            // Always provide a bound Compiler\n            var extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n            var outputCtx = createOutputContext();\n            var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n            ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n            this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * @internal\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        var moduleByJitDirective = new Map();\n        var templates = new Set();\n        var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n        transJitModules.forEach(function (localMod) {\n            var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                moduleByJitDirective.set(dirRef, localModuleMeta);\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(dirMeta.componentFactory);\n                    }\n                }\n            });\n        });\n        transJitModules.forEach(function (localMod) {\n            var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n            _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n                var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                if (!_this.hasAotSummary(entryComponentType.componentType)) {\n                    var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n                    templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                }\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    JitCompiler.prototype.clearCache = function () {\n        // Note: don't clear the _addedAotSummaries, as they don't change!\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + stringify(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var compMeta = template.compMeta;\n        var externalStylesheetsByModuleUrl = new Map();\n        var outputContext = createOutputContext();\n        var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n        compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n            var compiledStylesheet = _this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n            externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);\n        });\n        this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n        var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._parseTemplate(compMeta, template.ngModule, template.directives), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);\n        var evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n        var viewClass = evalResult[compileResult.viewClassVar];\n        var rendererType = evalResult[compileResult.rendererTypeVar];\n        template.compiled(viewClass, rendererType);\n    };\n    JitCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n        var _this = this;\n        // Note: ! is ok here as components always have a template.\n        var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n        var directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n    };\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n            var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.setValue(nestedStylesArr);\n        });\n    };\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n    };\n    JitCompiler.prototype._interpretOrJit = function (sourceUrl, statements) {\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(statements, this._reflector);\n        }\n        else {\n            return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n        }\n    };\n    return JitCompiler;\n}());\nvar CompiledTemplate = /** @class */ (function () {\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = null;\n        this.isCompiled = false;\n    }\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        this.compMeta.componentViewType.setDelegate(viewClass);\n        for (var prop in rendererType) {\n            this.compMeta.rendererType[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\nfunction createOutputContext() {\n    var importExpr$1 = function (symbol) {\n        return importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol });\n    };\n    return { statements: [], genFilePath: '', importExpr: importExpr$1, constantPool: new ConstantPool() };\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides access to reflection data about symbols that the compiler needs.\n */\nvar CompileReflector = /** @class */ (function () {\n    function CompileReflector() {\n    }\n    return CompileReflector;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {@link UrlResolver} with no package prefix.\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\nvar UrlResolver = /** @class */ (function () {\n    function UrlResolverImpl(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     */\n    UrlResolverImpl.prototype.resolve = function (baseUrl, url) {\n        var resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var resolvedParts = _split(resolvedUrl);\n        var prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolverImpl;\n}());\n/**\n * Extract the scheme of a URL.\n */\nfunction getUrlScheme(url) {\n    var match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n// The code below is adapted from Traceur:\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param opt_scheme The scheme such as 'http'.\n * @param opt_userInfo The user name before the '@'.\n * @param opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param opt_port The port number.\n * @param opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param opt_queryData The URI-encoded query data.\n * @param opt_fragment The URI-encoded fragment identifier.\n * @return The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' + // scheme - ignore special characters\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' + // userInfo\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + // domain - restrict to letters,\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' + // port\n    ')?' +\n    '([^?#]+)?' + // path\n    '(?:\\\\?([^#]*))?' + // query\n    '(?:#(.*))?' + // fragment\n    '$');\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\nvar _ComponentIndex;\n(function (_ComponentIndex) {\n    _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\n    _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\n    _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\n    _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\n    _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\n    _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\n    _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\n})(_ComponentIndex || (_ComponentIndex = {}));\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param uri The URI string to examine.\n * @return Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return uri.match(_splitRe);\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param path A non-empty path component.\n * @return Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var leadingSlash = path[0] == '/' ? '/' : '';\n    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n        var segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param base The URL acting as the base URL.\n * @param to The URL to resolve.\n */\nfunction _resolveUrl(base, url) {\n    var parts = _split(encodeURI(url));\n    var baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Extractor = /** @class */ (function () {\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var _a = analyzeAndValidateNgModules(rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var errors = [];\n            files.forEach(function (file) {\n                var compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var html = compMeta.template.template;\n                    // Template URL points to either an HTML or TS file depending on\n                    // whether the file is used with `templateUrl:` or `template:`,\n                    // respectively.\n                    var templateUrl = compMeta.template.templateUrl;\n                    var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                    errors.push.apply(errors, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__spread\"])(_this.messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    Extractor.create = function (host, locale) {\n        var htmlParser = new HtmlParser();\n        var urlResolver = createAotUrlResolver(host);\n        var symbolCache = new StaticSymbolCache();\n        var summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        var config = new CompilerConfig({ defaultEncapsulation: ViewEncapsulation.Emulated, useJit: false });\n        var normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var elementSchemaRegistry = new DomElementSchemaRegistry();\n        var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nvar R3TargetBinder = /** @class */ (function () {\n    function R3TargetBinder(directiveMatcher) {\n        this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n    R3TargetBinder.prototype.bind = function (target) {\n        if (!target.template) {\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n            throw new Error('Binding without a template not yet supported');\n        }\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\n        // scopes in the template and makes them available for later use.\n        var scope = Scope.apply(target.template);\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n        //   - references: Map of #references to their targets.\n        var _a = DirectiveBinder.apply(target.template, this.directiveMatcher), directives = _a.directives, bindings = _a.bindings, references = _a.references;\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n        // template. This extracts all the metadata that doesn't depend on directive matching.\n        var _b = TemplateBinder.apply(target.template, scope), expressions = _b.expressions, symbols = _b.symbols, nestingLevel = _b.nestingLevel, usedPipes = _b.usedPipes;\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, usedPipes);\n    };\n    return R3TargetBinder;\n}());\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nvar Scope = /** @class */ (function () {\n    function Scope(parentScope) {\n        this.parentScope = parentScope;\n        /**\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n         */\n        this.namedEntities = new Map();\n        /**\n         * Child `Scope`s for immediately nested `Template`s.\n         */\n        this.childScopes = new Map();\n    }\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n    Scope.apply = function (template) {\n        var scope = new Scope();\n        scope.ingest(template);\n        return scope;\n    };\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n    Scope.prototype.ingest = function (template) {\n        var _this = this;\n        if (template instanceof Template) {\n            // Variables on an <ng-template> are defined in the inner scope.\n            template.variables.forEach(function (node) { return _this.visitVariable(node); });\n            // Process the nodes of the template.\n            template.children.forEach(function (node) { return node.visit(_this); });\n        }\n        else {\n            // No overarching `Template` instance, so process the nodes directly.\n            template.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    Scope.prototype.visitElement = function (element) {\n        var _this = this;\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\n        element.references.forEach(function (node) { return _this.visitReference(node); });\n        // Recurse into the `Element`'s children.\n        element.children.forEach(function (node) { return node.visit(_this); });\n    };\n    Scope.prototype.visitTemplate = function (template) {\n        var _this = this;\n        // References on a <ng-template> are defined in the outer scope, so capture them before\n        // processing the template's child scope.\n        template.references.forEach(function (node) { return _this.visitReference(node); });\n        // Next, create an inner scope and process the template within it.\n        var scope = new Scope(this);\n        scope.ingest(template);\n        this.childScopes.set(template, scope);\n    };\n    Scope.prototype.visitVariable = function (variable) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(variable);\n    };\n    Scope.prototype.visitReference = function (reference) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(reference);\n    };\n    // Unused visitors.\n    Scope.prototype.visitContent = function (content) { };\n    Scope.prototype.visitBoundAttribute = function (attr) { };\n    Scope.prototype.visitBoundEvent = function (event) { };\n    Scope.prototype.visitBoundText = function (text) { };\n    Scope.prototype.visitText = function (text) { };\n    Scope.prototype.visitTextAttribute = function (attr) { };\n    Scope.prototype.visitIcu = function (icu) { };\n    Scope.prototype.maybeDeclare = function (thing) {\n        // Declare something with a name, as long as that name isn't taken.\n        if (!this.namedEntities.has(thing.name)) {\n            this.namedEntities.set(thing.name, thing);\n        }\n    };\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n    Scope.prototype.lookup = function (name) {\n        if (this.namedEntities.has(name)) {\n            // Found in the local scope.\n            return this.namedEntities.get(name);\n        }\n        else if (this.parentScope !== undefined) {\n            // Not in the local scope, but there's a parent scope so check there.\n            return this.parentScope.lookup(name);\n        }\n        else {\n            // At the top level and it wasn't found.\n            return null;\n        }\n    };\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n    Scope.prototype.getChildScope = function (template) {\n        var res = this.childScopes.get(template);\n        if (res === undefined) {\n            throw new Error(\"Assertion error: child scope for \" + template + \" not found\");\n        }\n        return res;\n    };\n    return Scope;\n}());\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nvar DirectiveBinder = /** @class */ (function () {\n    function DirectiveBinder(matcher, directives, bindings, references) {\n        this.matcher = matcher;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n    DirectiveBinder.apply = function (template, selectorMatcher) {\n        var directives = new Map();\n        var bindings = new Map();\n        var references = new Map();\n        var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n        matcher.ingest(template);\n        return { directives: directives, bindings: bindings, references: references };\n    };\n    DirectiveBinder.prototype.ingest = function (template) {\n        var _this = this;\n        template.forEach(function (node) { return node.visit(_this); });\n    };\n    DirectiveBinder.prototype.visitElement = function (element) {\n        this.visitElementOrTemplate(element.name, element);\n    };\n    DirectiveBinder.prototype.visitTemplate = function (template) {\n        this.visitElementOrTemplate('ng-template', template);\n    };\n    DirectiveBinder.prototype.visitElementOrTemplate = function (elementName, node) {\n        var _this = this;\n        // First, determine the HTML shape of the node for the purpose of directive matching.\n        // Do this by building up a `CssSelector` for the node.\n        var cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\n        var directives = [];\n        this.matcher.match(cssSelector, function (_, directive) { return directives.push(directive); });\n        if (directives.length > 0) {\n            this.directives.set(node, directives);\n        }\n        // Resolve any references that are created on this node.\n        node.references.forEach(function (ref) {\n            var dirTarget = null;\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\n            // (if there is one). Otherwise it matches the host node itself (either an element or\n            // <ng-template> node).\n            if (ref.value.trim() === '') {\n                // This could be a reference to a component if there is one.\n                dirTarget = directives.find(function (dir) { return dir.isComponent; }) || null;\n            }\n            else {\n                // This should be a reference to a directive exported via exportAs.\n                dirTarget =\n                    directives.find(function (dir) { return dir.exportAs !== null && dir.exportAs.some(function (value) { return value === ref.value; }); }) ||\n                        null;\n                // Check if a matching directive was found.\n                if (dirTarget === null) {\n                    // No matching directive was found - this reference points to an unknown target. Leave it\n                    // unmapped.\n                    return;\n                }\n            }\n            if (dirTarget !== null) {\n                // This reference points to a directive.\n                _this.references.set(ref, { directive: dirTarget, node: node });\n            }\n            else {\n                // This reference points to the node itself.\n                _this.references.set(ref, node);\n            }\n        });\n        var setAttributeBinding = function (attribute, ioType) {\n            var dir = directives.find(function (dir) { return dir[ioType].hasOwnProperty(attribute.name); });\n            var binding = dir !== undefined ? dir : node;\n            _this.bindings.set(attribute, binding);\n        };\n        // Node inputs (bound attributes) and text attributes can be bound to an\n        // input on a directive.\n        node.inputs.forEach(function (input) { return setAttributeBinding(input, 'inputs'); });\n        node.attributes.forEach(function (attr) { return setAttributeBinding(attr, 'inputs'); });\n        if (node instanceof Template) {\n            node.templateAttrs.forEach(function (attr) { return setAttributeBinding(attr, 'inputs'); });\n        }\n        // Node outputs (bound events) can be bound to an output on a directive.\n        node.outputs.forEach(function (output) { return setAttributeBinding(output, 'outputs'); });\n        // Recurse into the node's children.\n        node.children.forEach(function (child) { return child.visit(_this); });\n    };\n    // Unused visitors.\n    DirectiveBinder.prototype.visitContent = function (content) { };\n    DirectiveBinder.prototype.visitVariable = function (variable) { };\n    DirectiveBinder.prototype.visitReference = function (reference) { };\n    DirectiveBinder.prototype.visitTextAttribute = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundAttribute = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundEvent = function (attribute) { };\n    DirectiveBinder.prototype.visitBoundAttributeOrEvent = function (node) { };\n    DirectiveBinder.prototype.visitText = function (text) { };\n    DirectiveBinder.prototype.visitBoundText = function (text) { };\n    DirectiveBinder.prototype.visitIcu = function (icu) { };\n    return DirectiveBinder;\n}());\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nvar TemplateBinder = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"])(TemplateBinder, _super);\n    function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        _this.symbols = symbols;\n        _this.usedPipes = usedPipes;\n        _this.nestingLevel = nestingLevel;\n        _this.scope = scope;\n        _this.template = template;\n        _this.level = level;\n        _this.pipesUsed = [];\n        // Save a bit of processing time by constructing this closure in advance.\n        _this.visitNode = function (node) { return node.visit(_this); };\n        return _this;\n    }\n    // This method is defined to reconcile the type of TemplateBinder since both\n    // RecursiveAstVisitor and Visitor define the visit() method in their\n    // interfaces.\n    TemplateBinder.prototype.visit = function (node, context) {\n        if (node instanceof AST) {\n            node.visit(this, context);\n        }\n        else {\n            node.visit(this);\n        }\n    };\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n    TemplateBinder.apply = function (template, scope) {\n        var expressions = new Map();\n        var symbols = new Map();\n        var nestingLevel = new Map();\n        var usedPipes = new Set();\n        // The top-level template has nesting level 0.\n        var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n        binder.ingest(template);\n        return { expressions: expressions, symbols: symbols, nestingLevel: nestingLevel, usedPipes: usedPipes };\n    };\n    TemplateBinder.prototype.ingest = function (template) {\n        if (template instanceof Template) {\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n            // and references were all processed in the scope of the containing template.\n            template.variables.forEach(this.visitNode);\n            template.children.forEach(this.visitNode);\n            // Set the nesting level.\n            this.nestingLevel.set(template, this.level);\n        }\n        else {\n            // Visit each node from the top-level template.\n            template.forEach(this.visitNode);\n        }\n    };\n    TemplateBinder.prototype.visitElement = function (element) {\n        // Visit the inputs, outputs, and children of the element.\n        element.inputs.forEach(this.visitNode);\n        element.outputs.forEach(this.visitNode);\n        element.children.forEach(this.visitNode);\n    };\n    TemplateBinder.prototype.visitTemplate = function (template) {\n        // First, visit inputs, outputs and template attributes of the template node.\n        template.inputs.forEach(this.visitNode);\n        template.outputs.forEach(this.visitNode);\n        template.templateAttrs.forEach(this.visitNode);\n        // References are also evaluated in the outer context.\n        template.references.forEach(this.visitNode);\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n        var childScope = this.scope.getChildScope(template);\n        var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n        binder.ingest(template);\n    };\n    TemplateBinder.prototype.visitVariable = function (variable) {\n        // Register the `Variable` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(variable, this.template);\n        }\n    };\n    TemplateBinder.prototype.visitReference = function (reference) {\n        // Register the `Reference` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(reference, this.template);\n        }\n    };\n    // Unused template visitors\n    TemplateBinder.prototype.visitText = function (text) { };\n    TemplateBinder.prototype.visitContent = function (content) { };\n    TemplateBinder.prototype.visitTextAttribute = function (attribute) { };\n    TemplateBinder.prototype.visitIcu = function (icu) { };\n    // The remaining visitors are concerned with processing AST expressions within template bindings\n    TemplateBinder.prototype.visitBoundAttribute = function (attribute) {\n        attribute.value.visit(this);\n    };\n    TemplateBinder.prototype.visitBoundEvent = function (event) {\n        event.handler.visit(this);\n    };\n    TemplateBinder.prototype.visitBoundText = function (text) {\n        text.value.visit(this);\n    };\n    TemplateBinder.prototype.visitPipe = function (ast, context) {\n        this.usedPipes.add(ast.name);\n        return _super.prototype.visitPipe.call(this, ast, context);\n    };\n    // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n    TemplateBinder.prototype.visitPropertyRead = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitPropertyRead.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitSafePropertyRead = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitSafePropertyRead.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitPropertyWrite = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitPropertyWrite.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitMethodCall = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitMethodCall.call(this, ast, context);\n    };\n    TemplateBinder.prototype.visitSafeMethodCall = function (ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return _super.prototype.visitSafeMethodCall.call(this, ast, context);\n    };\n    TemplateBinder.prototype.maybeMap = function (scope, ast, name) {\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n        // `AST` expression that maps to a `Variable` or `Reference`.\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\n            return;\n        }\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n        // probably a property on the top-level component context.\n        var target = this.scope.lookup(name);\n        if (target !== null) {\n            this.bindings.set(ast, target);\n        }\n    };\n    return TemplateBinder;\n}(RecursiveAstVisitor$1));\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nvar R3BoundTarget = /** @class */ (function () {\n    function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, usedPipes) {\n        this.target = target;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n        this.exprTargets = exprTargets;\n        this.symbols = symbols;\n        this.nestingLevel = nestingLevel;\n        this.usedPipes = usedPipes;\n    }\n    R3BoundTarget.prototype.getDirectivesOfNode = function (node) {\n        return this.directives.get(node) || null;\n    };\n    R3BoundTarget.prototype.getReferenceTarget = function (ref) {\n        return this.references.get(ref) || null;\n    };\n    R3BoundTarget.prototype.getConsumerOfBinding = function (binding) {\n        return this.bindings.get(binding) || null;\n    };\n    R3BoundTarget.prototype.getExpressionTarget = function (expr) {\n        return this.exprTargets.get(expr) || null;\n    };\n    R3BoundTarget.prototype.getTemplateOfSymbol = function (symbol) {\n        return this.symbols.get(symbol) || null;\n    };\n    R3BoundTarget.prototype.getNestingLevel = function (template) {\n        return this.nestingLevel.get(template) || 0;\n    };\n    R3BoundTarget.prototype.getUsedDirectives = function () {\n        var set = new Set();\n        this.directives.forEach(function (dirs) { return dirs.forEach(function (dir) { return set.add(dir); }); });\n        return Array.from(set.values());\n    };\n    R3BoundTarget.prototype.getUsedPipes = function () {\n        return Array.from(this.usedPipes);\n    };\n    return R3BoundTarget;\n}());\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(_global);\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n//# sourceMappingURL=compiler.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvZmVzbTUvY29tcGlsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvZmVzbTUvY29tcGlsZXIuanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjkuMS4xMlxuICogKGMpIDIwMTAtMjAyMCBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG5pbXBvcnQgeyBfX2Fzc2lnbiwgX19zcHJlYWQsIF9fZXh0ZW5kcywgX192YWx1ZXMsIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRhZ0NvbnRlbnRUeXBlO1xuKGZ1bmN0aW9uIChUYWdDb250ZW50VHlwZSkge1xuICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUkFXX1RFWFRcIl0gPSAwXSA9IFwiUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDFdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlBBUlNBQkxFX0RBVEFcIl0gPSAyXSA9IFwiUEFSU0FCTEVfREFUQVwiO1xufSkoVGFnQ29udGVudFR5cGUgfHwgKFRhZ0NvbnRlbnRUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgaWYgKGVsZW1lbnROYW1lWzBdICE9ICc6Jykge1xuICAgICAgICByZXR1cm4gW251bGwsIGVsZW1lbnROYW1lXTtcbiAgICB9XG4gICAgdmFyIGNvbG9uSW5kZXggPSBlbGVtZW50TmFtZS5pbmRleE9mKCc6JywgMSk7XG4gICAgaWYgKGNvbG9uSW5kZXggPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZm9ybWF0IFxcXCJcIiArIGVsZW1lbnROYW1lICsgXCJcXFwiIGV4cGVjdGluZyBcXFwiOm5hbWVzcGFjZTpuYW1lXFxcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtlbGVtZW50TmFtZS5zbGljZSgxLCBjb2xvbkluZGV4KSwgZWxlbWVudE5hbWUuc2xpY2UoY29sb25JbmRleCArIDEpXTtcbn1cbi8vIGA8bmctY29udGFpbmVyPmAgdGFncyB3b3JrIHRoZSBzYW1lIHJlZ2FyZGxlc3MgdGhlIG5hbWVzcGFjZVxuZnVuY3Rpb24gaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGFpbmVyJztcbn1cbi8vIGA8bmctY29udGVudD5gIHRhZ3Mgd29yayB0aGUgc2FtZSByZWdhcmRsZXNzIHRoZSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGlzTmdDb250ZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy1jb250ZW50Jztcbn1cbi8vIGA8bmctdGVtcGxhdGU+YCB0YWdzIHdvcmsgdGhlIHNhbWUgcmVnYXJkbGVzcyB0aGUgbmFtZXNwYWNlXG5mdW5jdGlvbiBpc05nVGVtcGxhdGUodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLXRlbXBsYXRlJztcbn1cbmZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbn1cbmZ1bmN0aW9uIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKSB7XG4gICAgcmV0dXJuIHByZWZpeCA/IFwiOlwiICsgcHJlZml4ICsgXCI6XCIgKyBsb2NhbE5hbWUgOiBsb2NhbE5hbWU7XG59XG4vLyBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI25hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2VzXG4vLyBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW50aXRpZXMuanNvblxuLy8gVGhpcyBsaXN0IGlzIG5vdCBleGhhdXN0aXZlIHRvIGtlZXAgdGhlIGNvbXBpbGVyIGZvb3RwcmludCBsb3cuXG4vLyBUaGUgYCYjMTIzO2AgLyBgJiN4MWFiO2Agc3ludGF4IHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2UgZG9lcyBub3Rcbi8vIGV4aXN0LlxudmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICdhbXAnOiAnJicsXG4gICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgJ2d0JzogJz4nLFxuICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICd6d25qJzogJ1xcdTIwMEMnLFxufTtcbi8vIFRoZSAmbmdzcDsgcHNldWRvLWVudGl0eSBpcyBkZW5vdGluZyBhIHNwYWNlLiBzZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFydC1sYW5nL2FuZ3VsYXIvYmxvYi8wYmI2MTEzODdkMjlkNjViNWFmN2Y5ZDI1MTVhYjU3MWZkM2ZiZWU0L190ZXN0cy90ZXN0L2NvbXBpbGVyL3ByZXNlcnZlX3doaXRlc3BhY2VfdGVzdC5kYXJ0XG52YXIgTkdTUF9VTklDT0RFID0gJ1xcdUU1MDAnO1xuTkFNRURfRU5USVRJRVNbJ25nc3AnXSA9IE5HU1BfVU5JQ09ERTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEh0bWxUYWdEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxUYWdEZWZpbml0aW9uKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBjbG9zZWRCeUNoaWxkcmVuID0gX2IuY2xvc2VkQnlDaGlsZHJlbiwgaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBfYi5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCwgX2MgPSBfYi5jb250ZW50VHlwZSwgY29udGVudFR5cGUgPSBfYyA9PT0gdm9pZCAwID8gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQSA6IF9jLCBfZCA9IF9iLmNsb3NlZEJ5UGFyZW50LCBjbG9zZWRCeVBhcmVudCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IF9iLmlzVm9pZCwgaXNWb2lkID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIF9mID0gX2IuaWdub3JlRmlyc3RMZiwgaWdub3JlRmlyc3RMZiA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mO1xuICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY2xvc2VkQnlDaGlsZHJlbiAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMuY2xvc2VkQnlDaGlsZHJlblt0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gY2xvc2VkQnlQYXJlbnQgfHwgaXNWb2lkO1xuICAgICAgICB0aGlzLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgIH1cbiAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUuaXNDbG9zZWRCeUNoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWb2lkIHx8IG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW47XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFRhZ0RlZmluaXRpb247XG59KCkpO1xudmFyIF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGZ1bGx5IGNvbmZvcm0gdG8gdGhlIEhUTUw1IHNwZWMuXG52YXIgVEFHX0RFRklOSVRJT05TO1xuZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIGlmICghVEFHX0RFRklOSVRJT05TKSB7XG4gICAgICAgIF9ERUZBVUxUX1RBR19ERUZJTklUSU9OID0gbmV3IEh0bWxUYWdEZWZpbml0aW9uKCk7XG4gICAgICAgIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAgICAgICAgICdiYXNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ21ldGEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdlbWJlZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdsaW5rJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdpbnB1dCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdwYXJhbSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdzb3VyY2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnd2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3AnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsXG4gICAgICAgICAgICAgICAgICAgICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsXG4gICAgICAgICAgICAgICAgICAgICdoNicsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ21haW4nLCAnbmF2JywgJ29sJyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGhlYWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10gfSksXG4gICAgICAgICAgICAndGJvZHknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0cic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICAgICAgICAgJ21hdGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ21hdGgnIH0pLFxuICAgICAgICAgICAgJ2xpJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydsaSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAgICAgICAgICdkZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncmInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3J0Yyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3JwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ29wdGlvbic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0aW9uJywgJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3ByZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnc3R5bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgICAgICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAgICAgICAgICd0ZXh0YXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQsIGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBfREVGQVVMVF9UQUdfREVGSU5JVElPTjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TRUxFQ1RPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCcoXFxcXDpub3RcXFxcKCl8JyArIC8vIDE6IFwiOm5vdChcIlxuICAgICcoKFtcXFxcLlxcXFwjXT8pWy1cXFxcd10rKXwnICsgLy8gMjogXCJ0YWdcIjsgMzogXCIuXCIvXCIjXCI7XG4gICAgLy8gXCItXCIgc2hvdWxkIGFwcGVhciBmaXJzdCBpbiB0aGUgcmVnZXhwIGJlbG93IGFzIEZGMzEgcGFyc2VzIFwiWy4tXFx3XVwiIGFzIGEgcmFuZ2VcbiAgICAvLyA0OiBhdHRyaWJ1dGU7IDU6IGF0dHJpYnV0ZV9zdHJpbmc7IDY6IGF0dHJpYnV0ZV92YWx1ZVxuICAgICcoPzpcXFxcWyhbLS5cXFxcdypdKykoPzo9KFtcXFwiXFwnXT8pKFteXFxcXF1cXFwiXFwnXSopXFxcXDUpP1xcXFxdKXwnICsgLy8gXCJbbmFtZV1cIiwgXCJbbmFtZT12YWx1ZV1cIixcbiAgICAvLyBcIltuYW1lPVwidmFsdWVcIl1cIixcbiAgICAvLyBcIltuYW1lPSd2YWx1ZSddXCJcbiAgICAnKFxcXFwpKXwnICsgLy8gNzogXCIpXCJcbiAgICAnKFxcXFxzKixcXFxccyopJywgLy8gODogXCIsXCJcbidnJyk7XG4vKipcbiAqIEEgY3NzIHNlbGVjdG9yIGNvbnRhaW5zIGFuIGVsZW1lbnQgbmFtZSxcbiAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxuICogb2Ygc2VsZWN0aW5nIHN1YnNldHMgb3V0IG9mIHRoZW0uXG4gKi9cbnZhciBDc3NTZWxlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VsZWN0b3JzIGFyZSBlbmNvZGVkIGluIHBhaXJzIHdoZXJlOlxuICAgICAgICAgKiAtIGV2ZW4gbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgICogLSBvZGQgbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBTZWxlY3RvcjogYFtrZXkxPXZhbHVlMV1ba2V5Ml1gIHdvdWxkIHBhcnNlIHRvOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogWydrZXkxJywgJ3ZhbHVlMScsICdrZXkyJywgJyddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBDc3NTZWxlY3Rvci5wYXJzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgX2FkZFJlc3VsdCA9IGZ1bmN0aW9uIChyZXMsIGNzc1NlbCkge1xuICAgICAgICAgICAgaWYgKGNzc1NlbC5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAhY3NzU2VsLmVsZW1lbnQgJiYgY3NzU2VsLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICBjc3NTZWwuYXR0cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBjc3NTZWwuZWxlbWVudCA9ICcqJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKGNzc1NlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY3NzU2VsZWN0b3I7XG4gICAgICAgIHZhciBpbk5vdCA9IGZhbHNlO1xuICAgICAgICBfU0VMRUNUT1JfUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IF9TRUxFQ1RPUl9SRUdFWFAuZXhlYyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxIC8qIE5PVCAqL10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaW4gYSBzZWxlY3RvciBpcyBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRhZyA9IG1hdGNoWzIgLyogVEFHICovXTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMyAvKiBQUkVGSVggKi9dO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAjaGFzaFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZSgnaWQnLCB0YWcuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUodGFnLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0RWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBtYXRjaFs0IC8qIEFUVFJJQlVURSAqL107XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5hZGRBdHRyaWJ1dGUoYXR0cmlidXRlLCBtYXRjaFs2IC8qIEFUVFJJQlVURV9WQUxVRSAqL10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzcgLyogTk9UX0VORCAqL10pIHtcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs4IC8qIFNFUEFSQVRPUiAqL10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBzZWxlY3RvcnMgaW4gOm5vdCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3RvciA9IGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0VsZW1lbnRTZWxlY3RvcigpICYmIHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJiB0aGlzLmF0dHJzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaGFzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmVsZW1lbnQ7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9O1xuICAgIC8qKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRoaXMuZWxlbWVudCB8fCAnZGl2JztcbiAgICAgICAgdmFyIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHZhciBhdHRycyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV0gIT09ICcnID8gXCI9XFxcIlwiICsgdGhpcy5hdHRyc1tpICsgMV0gKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgYXR0cnMgKz0gXCIgXCIgKyBhdHRyTmFtZSArIGF0dHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkuaXNWb2lkID8gXCI8XCIgKyB0YWdOYW1lICsgY2xhc3NBdHRyICsgYXR0cnMgKyBcIi8+XCIgOlxuICAgICAgICAgICAgXCI8XCIgKyB0YWdOYW1lICsgY2xhc3NBdHRyICsgYXR0cnMgKyBcIj48L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICAgIH07XG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmdldEF0dHJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2NsYXNzJywgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQodGhpcy5hdHRycyk7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKG5hbWUsIHZhbHVlICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgfHwgJycpO1xuICAgIH07XG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfTtcbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmVsZW1lbnQgfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gcmVzICs9IFwiLlwiICsga2xhc3M7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5hdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lXzEgKyAodmFsdWUgPyAnPScgKyB2YWx1ZSA6ICcnKSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XG59KCkpO1xuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xudmFyIFNlbGVjdG9yTWF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NQYXJ0aWFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hdHRyVmFsdWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cyA9IFtdO1xuICAgIH1cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIG5vdE1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XG4gICAgICAgIGlmIChjc3NTZWxlY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgdmFyIHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgaSA9PT0gY2xhc3NOYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGkgPT09IGF0dHJzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwLnNldChuYW1lXzIsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVQYXJ0aWFsTWFwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHBhcnRpYWxNYXAuZ2V0KG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydGlhbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxNYXAuc2V0KG5hbWVfMiwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0c1tpXS5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2NsYXNzTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMyA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWVfMyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZV8zKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fbWF0Y2hUZXJtaW5hbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGFibGVzID0gbWFwLmdldChuYW1lKSB8fCBbXTtcbiAgICAgICAgdmFyIHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGFibGU7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXN0ZWRTZWxlY3RvciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbmVzdGVkU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBnZXQgcmlkIG9mIHJlY3Vyc2lvbiBhbmQgbWVhc3VyZSBhZ2FpblxuICAgICAgICAvLyBUT0RPKHBlcmYpOiBkb24ndCBwYXNzIHRoZSB3aG9sZSBzZWxlY3RvciBpbnRvIHRoZSByZWN1cnNpb24sXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXG4gICAgICAgIHJldHVybiBuZXN0ZWRTZWxlY3Rvci5tYXRjaChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XG59KCkpO1xudmFyIFNlbGVjdG9yTGlzdENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0b3JMaXN0Q29udGV4dChzZWxlY3RvcnMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgIHRoaXMuYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XG59KCkpO1xuLy8gU3RvcmUgY29udGV4dCB0byBwYXNzIGJhY2sgc2VsZWN0b3IgYW5kIGNvbnRleHQgd2hlbiBhIHNlbGVjdG9yIGlzIG1hdGNoZWRcbnZhciBTZWxlY3RvckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VsZWN0b3JDb250ZXh0KHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgfVxuICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTZWxlY3RvckNvbnRleHQ7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgY3JlYXRlSW5qZWN0ID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSW5qZWN0JywgZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiAoeyB0b2tlbjogdG9rZW4gfSk7IH0pO1xudmFyIGNyZWF0ZUluamVjdGlvblRva2VuID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSW5qZWN0aW9uVG9rZW4nLCBmdW5jdGlvbiAoZGVzYykgeyByZXR1cm4gKHsgX2Rlc2M6IGRlc2MsIMm1cHJvdjogdW5kZWZpbmVkIH0pOyB9KTtcbnZhciBjcmVhdGVBdHRyaWJ1dGUgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdBdHRyaWJ1dGUnLCBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkgeyByZXR1cm4gKHsgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlTmFtZSB9KTsgfSk7XG52YXIgY3JlYXRlQ29udGVudENoaWxkcmVuID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnQ29udGVudENoaWxkcmVuJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICByZXR1cm4gKF9fYXNzaWduKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBmaXJzdDogZmFsc2UsIGlzVmlld1F1ZXJ5OiBmYWxzZSwgZGVzY2VuZGFudHM6IGZhbHNlIH0sIGRhdGEpKTtcbn0pO1xudmFyIGNyZWF0ZUNvbnRlbnRDaGlsZCA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0NvbnRlbnRDaGlsZCcsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApIHsgZGF0YSA9IHt9OyB9XG4gICAgcmV0dXJuIChfX2Fzc2lnbih7IHNlbGVjdG9yOiBzZWxlY3RvciwgZmlyc3Q6IHRydWUsIGlzVmlld1F1ZXJ5OiBmYWxzZSwgZGVzY2VuZGFudHM6IHRydWUgfSwgZGF0YSkpO1xufSk7XG52YXIgY3JlYXRlVmlld0NoaWxkcmVuID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnVmlld0NoaWxkcmVuJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0ge307IH1cbiAgICByZXR1cm4gKF9fYXNzaWduKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBmaXJzdDogZmFsc2UsIGlzVmlld1F1ZXJ5OiB0cnVlLCBkZXNjZW5kYW50czogdHJ1ZSB9LCBkYXRhKSk7XG59KTtcbnZhciBjcmVhdGVWaWV3Q2hpbGQgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdWaWV3Q2hpbGQnLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRhdGEpIHtcbiAgICByZXR1cm4gKF9fYXNzaWduKHsgc2VsZWN0b3I6IHNlbGVjdG9yLCBmaXJzdDogdHJ1ZSwgaXNWaWV3UXVlcnk6IHRydWUsIGRlc2NlbmRhbnRzOiB0cnVlIH0sIGRhdGEpKTtcbn0pO1xudmFyIGNyZWF0ZURpcmVjdGl2ZSA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0RpcmVjdGl2ZScsIGZ1bmN0aW9uIChkaXIpIHtcbiAgICBpZiAoZGlyID09PSB2b2lkIDApIHsgZGlyID0ge307IH1cbiAgICByZXR1cm4gZGlyO1xufSk7XG52YXIgVmlld0VuY2Fwc3VsYXRpb247XG4oZnVuY3Rpb24gKFZpZXdFbmNhcHN1bGF0aW9uKSB7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJFbXVsYXRlZFwiXSA9IDBdID0gXCJFbXVsYXRlZFwiO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTmF0aXZlXCJdID0gMV0gPSBcIk5hdGl2ZVwiO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJTaGFkb3dEb21cIl0gPSAzXSA9IFwiU2hhZG93RG9tXCI7XG59KShWaWV3RW5jYXBzdWxhdGlvbiB8fCAoVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xudmFyIENoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gMF0gPSBcIk9uUHVzaFwiO1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XG59KShDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB8fCAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIGNyZWF0ZUNvbXBvbmVudCA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0NvbXBvbmVudCcsIGZ1bmN0aW9uIChjKSB7XG4gICAgaWYgKGMgPT09IHZvaWQgMCkgeyBjID0ge307IH1cbiAgICByZXR1cm4gKF9fYXNzaWduKHsgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0IH0sIGMpKTtcbn0pO1xudmFyIGNyZWF0ZVBpcGUgPSBtYWtlTWV0YWRhdGFGYWN0b3J5KCdQaXBlJywgZnVuY3Rpb24gKHApIHsgcmV0dXJuIChfX2Fzc2lnbih7IHB1cmU6IHRydWUgfSwgcCkpOyB9KTtcbnZhciBjcmVhdGVJbnB1dCA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0lucHV0JywgZnVuY3Rpb24gKGJpbmRpbmdQcm9wZXJ0eU5hbWUpIHsgcmV0dXJuICh7IGJpbmRpbmdQcm9wZXJ0eU5hbWU6IGJpbmRpbmdQcm9wZXJ0eU5hbWUgfSk7IH0pO1xudmFyIGNyZWF0ZU91dHB1dCA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ091dHB1dCcsIGZ1bmN0aW9uIChiaW5kaW5nUHJvcGVydHlOYW1lKSB7IHJldHVybiAoeyBiaW5kaW5nUHJvcGVydHlOYW1lOiBiaW5kaW5nUHJvcGVydHlOYW1lIH0pOyB9KTtcbnZhciBjcmVhdGVIb3N0QmluZGluZyA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0hvc3RCaW5kaW5nJywgZnVuY3Rpb24gKGhvc3RQcm9wZXJ0eU5hbWUpIHsgcmV0dXJuICh7IGhvc3RQcm9wZXJ0eU5hbWU6IGhvc3RQcm9wZXJ0eU5hbWUgfSk7IH0pO1xudmFyIGNyZWF0ZUhvc3RMaXN0ZW5lciA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0hvc3RMaXN0ZW5lcicsIGZ1bmN0aW9uIChldmVudE5hbWUsIGFyZ3MpIHsgcmV0dXJuICh7IGV2ZW50TmFtZTogZXZlbnROYW1lLCBhcmdzOiBhcmdzIH0pOyB9KTtcbnZhciBjcmVhdGVOZ01vZHVsZSA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ05nTW9kdWxlJywgZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZTsgfSk7XG52YXIgY3JlYXRlSW5qZWN0YWJsZSA9IG1ha2VNZXRhZGF0YUZhY3RvcnkoJ0luamVjdGFibGUnLCBmdW5jdGlvbiAoaW5qZWN0YWJsZSkge1xuICAgIGlmIChpbmplY3RhYmxlID09PSB2b2lkIDApIHsgaW5qZWN0YWJsZSA9IHt9OyB9XG4gICAgcmV0dXJuIGluamVjdGFibGU7XG59KTtcbnZhciBDVVNUT01fRUxFTUVOVFNfU0NIRU1BID0ge1xuICAgIG5hbWU6ICdjdXN0b20tZWxlbWVudHMnXG59O1xudmFyIE5PX0VSUk9SU19TQ0hFTUEgPSB7XG4gICAgbmFtZTogJ25vLWVycm9ycy1zY2hlbWEnXG59O1xudmFyIGNyZWF0ZU9wdGlvbmFsID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnT3B0aW9uYWwnKTtcbnZhciBjcmVhdGVTZWxmID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnU2VsZicpO1xudmFyIGNyZWF0ZVNraXBTZWxmID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnU2tpcFNlbGYnKTtcbnZhciBjcmVhdGVIb3N0ID0gbWFrZU1ldGFkYXRhRmFjdG9yeSgnSG9zdCcpO1xudmFyIFR5cGUgPSBGdW5jdGlvbjtcbnZhciBTZWN1cml0eUNvbnRleHQ7XG4oZnVuY3Rpb24gKFNlY3VyaXR5Q29udGV4dCkge1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiSFRNTFwiXSA9IDFdID0gXCJIVE1MXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNUWUxFXCJdID0gMl0gPSBcIlNUWUxFXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNDUklQVFwiXSA9IDNdID0gXCJTQ1JJUFRcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiVVJMXCJdID0gNF0gPSBcIlVSTFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJSRVNPVVJDRV9VUkxcIl0gPSA1XSA9IFwiUkVTT1VSQ0VfVVJMXCI7XG59KShTZWN1cml0eUNvbnRleHQgfHwgKFNlY3VyaXR5Q29udGV4dCA9IHt9KSk7XG52YXIgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5KSB7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJFcnJvclwiXSA9IDBdID0gXCJFcnJvclwiO1xuICAgIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W01pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W1wiV2FybmluZ1wiXSA9IDFdID0gXCJXYXJuaW5nXCI7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJJZ25vcmVcIl0gPSAyXSA9IFwiSWdub3JlXCI7XG59KShNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSB8fCAoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xuZnVuY3Rpb24gbWFrZU1ldGFkYXRhRmFjdG9yeShuYW1lLCBwcm9wcykge1xuICAgIC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBhcyBhIGZ1bmN0aW9uLCBub3QgYSBmYXQgYXJyb3csIHNvIHRoYXQgRVMyMDE1IGRldm1vZGUgcHJvZHVjZXMgY29kZVxuICAgIC8vIHRoYXQgd29ya3Mgd2l0aCB0aGUgc3RhdGljX3JlZmxlY3Rvci50cyBpbiB0aGUgVmlld0VuZ2luZSBjb21waWxlci5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLCBgX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3RvcmAgYXNzdW1lcyB0aGF0IHRoZSB2YWx1ZSByZXR1cm5lZCBoZXJlIGNhbiBiZVxuICAgIC8vIG5ldydlZC5cbiAgICBmdW5jdGlvbiBmYWN0b3J5KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSBwcm9wcyA/IHByb3BzLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpIDoge307XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7IG5nTWV0YWRhdGFOYW1lOiBuYW1lIH0sIHZhbHVlcyk7XG4gICAgfVxuICAgIGZhY3RvcnkuaXNUeXBlT2YgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLm5nTWV0YWRhdGFOYW1lID09PSBuYW1lOyB9O1xuICAgIGZhY3RvcnkubmdNZXRhZGF0YU5hbWUgPSBuYW1lO1xuICAgIHJldHVybiBmYWN0b3J5O1xufVxuZnVuY3Rpb24gcGFyc2VyU2VsZWN0b3JUb1NpbXBsZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID8gX19zcHJlYWQoWzggLyogQ0xBU1MgKi9dLCBzZWxlY3Rvci5jbGFzc05hbWVzKSA6XG4gICAgICAgIFtdO1xuICAgIHZhciBlbGVtZW50TmFtZSA9IHNlbGVjdG9yLmVsZW1lbnQgJiYgc2VsZWN0b3IuZWxlbWVudCAhPT0gJyonID8gc2VsZWN0b3IuZWxlbWVudCA6ICcnO1xuICAgIHJldHVybiBfX3NwcmVhZChbZWxlbWVudE5hbWVdLCBzZWxlY3Rvci5hdHRycywgY2xhc3Nlcyk7XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvTmVnYXRpdmVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciBjbGFzc2VzID0gc2VsZWN0b3IuY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5jbGFzc05hbWVzLmxlbmd0aCA/IF9fc3ByZWFkKFs4IC8qIENMQVNTICovXSwgc2VsZWN0b3IuY2xhc3NOYW1lcykgOlxuICAgICAgICBbXTtcbiAgICBpZiAoc2VsZWN0b3IuZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX19zcHJlYWQoW1xuICAgICAgICAgICAgMSAvKiBOT1QgKi8gfCA0IC8qIEVMRU1FTlQgKi8sIHNlbGVjdG9yLmVsZW1lbnRcbiAgICAgICAgXSwgc2VsZWN0b3IuYXR0cnMsIGNsYXNzZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rvci5hdHRycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkKFsxIC8qIE5PVCAqLyB8IDIgLyogQVRUUklCVVRFICovXSwgc2VsZWN0b3IuYXR0cnMsIGNsYXNzZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNsYXNzTmFtZXMgJiYgc2VsZWN0b3IuY2xhc3NOYW1lcy5sZW5ndGggPyBfX3NwcmVhZChbMSAvKiBOT1QgKi8gfCA4IC8qIENMQVNTICovXSwgc2VsZWN0b3IuY2xhc3NOYW1lcykgOlxuICAgICAgICAgICAgW107XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VyU2VsZWN0b3JUb1IzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICB2YXIgcG9zaXRpdmUgPSBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHZhciBuZWdhdGl2ZSA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycyAmJiBzZWxlY3Rvci5ub3RTZWxlY3RvcnMubGVuZ3RoID9cbiAgICAgICAgc2VsZWN0b3Iubm90U2VsZWN0b3JzLm1hcChmdW5jdGlvbiAobm90U2VsZWN0b3IpIHsgcmV0dXJuIHBhcnNlclNlbGVjdG9yVG9OZWdhdGl2ZVNlbGVjdG9yKG5vdFNlbGVjdG9yKTsgfSkgOlxuICAgICAgICBbXTtcbiAgICByZXR1cm4gcG9zaXRpdmUuY29uY2F0LmFwcGx5KHBvc2l0aXZlLCBfX3NwcmVhZChuZWdhdGl2ZSkpO1xufVxuZnVuY3Rpb24gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA/IENzc1NlbGVjdG9yLnBhcnNlKHNlbGVjdG9yKS5tYXAocGFyc2VyU2VsZWN0b3JUb1IzU2VsZWN0b3IpIDogW107XG59XG5cbnZhciBjb3JlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBjcmVhdGVJbmplY3Q6IGNyZWF0ZUluamVjdCxcbiAgICBjcmVhdGVJbmplY3Rpb25Ub2tlbjogY3JlYXRlSW5qZWN0aW9uVG9rZW4sXG4gICAgY3JlYXRlQXR0cmlidXRlOiBjcmVhdGVBdHRyaWJ1dGUsXG4gICAgY3JlYXRlQ29udGVudENoaWxkcmVuOiBjcmVhdGVDb250ZW50Q2hpbGRyZW4sXG4gICAgY3JlYXRlQ29udGVudENoaWxkOiBjcmVhdGVDb250ZW50Q2hpbGQsXG4gICAgY3JlYXRlVmlld0NoaWxkcmVuOiBjcmVhdGVWaWV3Q2hpbGRyZW4sXG4gICAgY3JlYXRlVmlld0NoaWxkOiBjcmVhdGVWaWV3Q2hpbGQsXG4gICAgY3JlYXRlRGlyZWN0aXZlOiBjcmVhdGVEaXJlY3RpdmUsXG4gICAgZ2V0IFZpZXdFbmNhcHN1bGF0aW9uICgpIHsgcmV0dXJuIFZpZXdFbmNhcHN1bGF0aW9uOyB9LFxuICAgIGdldCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSAoKSB7IHJldHVybiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTsgfSxcbiAgICBjcmVhdGVDb21wb25lbnQ6IGNyZWF0ZUNvbXBvbmVudCxcbiAgICBjcmVhdGVQaXBlOiBjcmVhdGVQaXBlLFxuICAgIGNyZWF0ZUlucHV0OiBjcmVhdGVJbnB1dCxcbiAgICBjcmVhdGVPdXRwdXQ6IGNyZWF0ZU91dHB1dCxcbiAgICBjcmVhdGVIb3N0QmluZGluZzogY3JlYXRlSG9zdEJpbmRpbmcsXG4gICAgY3JlYXRlSG9zdExpc3RlbmVyOiBjcmVhdGVIb3N0TGlzdGVuZXIsXG4gICAgY3JlYXRlTmdNb2R1bGU6IGNyZWF0ZU5nTW9kdWxlLFxuICAgIGNyZWF0ZUluamVjdGFibGU6IGNyZWF0ZUluamVjdGFibGUsXG4gICAgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQTogQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSxcbiAgICBOT19FUlJPUlNfU0NIRU1BOiBOT19FUlJPUlNfU0NIRU1BLFxuICAgIGNyZWF0ZU9wdGlvbmFsOiBjcmVhdGVPcHRpb25hbCxcbiAgICBjcmVhdGVTZWxmOiBjcmVhdGVTZWxmLFxuICAgIGNyZWF0ZVNraXBTZWxmOiBjcmVhdGVTa2lwU2VsZixcbiAgICBjcmVhdGVIb3N0OiBjcmVhdGVIb3N0LFxuICAgIFR5cGU6IFR5cGUsXG4gICAgZ2V0IFNlY3VyaXR5Q29udGV4dCAoKSB7IHJldHVybiBTZWN1cml0eUNvbnRleHQ7IH0sXG4gICAgZ2V0IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ICgpIHsgcmV0dXJuIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5OyB9LFxuICAgIHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3I6IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Jcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLy8vIFR5cGVzXG52YXIgVHlwZU1vZGlmaWVyO1xuKGZ1bmN0aW9uIChUeXBlTW9kaWZpZXIpIHtcbiAgICBUeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyW1wiQ29uc3RcIl0gPSAwXSA9IFwiQ29uc3RcIjtcbn0pKFR5cGVNb2RpZmllciB8fCAoVHlwZU1vZGlmaWVyID0ge30pKTtcbnZhciBUeXBlJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZShtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFR5cGUucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gVHlwZTtcbn0oKSk7XG52YXIgQnVpbHRpblR5cGVOYW1lO1xuKGZ1bmN0aW9uIChCdWlsdGluVHlwZU5hbWUpIHtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRHluYW1pY1wiXSA9IDBdID0gXCJEeW5hbWljXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkJvb2xcIl0gPSAxXSA9IFwiQm9vbFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJTdHJpbmdcIl0gPSAyXSA9IFwiU3RyaW5nXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkludFwiXSA9IDNdID0gXCJJbnRcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiTnVtYmVyXCJdID0gNF0gPSBcIk51bWJlclwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJGdW5jdGlvblwiXSA9IDVdID0gXCJGdW5jdGlvblwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJJbmZlcnJlZFwiXSA9IDZdID0gXCJJbmZlcnJlZFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOb25lXCJdID0gN10gPSBcIk5vbmVcIjtcbn0pKEJ1aWx0aW5UeXBlTmFtZSB8fCAoQnVpbHRpblR5cGVOYW1lID0ge30pKTtcbnZhciBCdWlsdGluVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVpbHRpblR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVpbHRpblR5cGUobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQnVpbHRpblR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpblR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQnVpbHRpblR5cGU7XG59KFR5cGUkMSkpO1xudmFyIEV4cHJlc3Npb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uVHlwZSh2YWx1ZSwgbW9kaWZpZXJzLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFeHByZXNzaW9uVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgQXJyYXlUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlUeXBlKG9mLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vZiA9IG9mO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5VHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlUeXBlO1xufShUeXBlJDEpKTtcbnZhciBNYXBUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFR5cGUodmFsdWVUeXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXBUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljKTtcbnZhciBJTkZFUlJFRF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZCk7XG52YXIgQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbnZhciBJTlRfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW50KTtcbnZhciBOVU1CRVJfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuTnVtYmVyKTtcbnZhciBTVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbnZhciBGVU5DVElPTl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbik7XG52YXIgTk9ORV9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Ob25lKTtcbi8vLy8vIEV4cHJlc3Npb25zXG52YXIgQmluYXJ5T3BlcmF0b3I7XG4oZnVuY3Rpb24gKEJpbmFyeU9wZXJhdG9yKSB7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJFcXVhbHNcIl0gPSAwXSA9IFwiRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RFcXVhbHNcIl0gPSAxXSA9IFwiTm90RXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJJZGVudGljYWxcIl0gPSAyXSA9IFwiSWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RJZGVudGljYWxcIl0gPSAzXSA9IFwiTm90SWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDRdID0gXCJNaW51c1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiUGx1c1wiXSA9IDVdID0gXCJQbHVzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJEaXZpZGVcIl0gPSA2XSA9IFwiRGl2aWRlXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNdWx0aXBseVwiXSA9IDddID0gXCJNdWx0aXBseVwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTW9kdWxvXCJdID0gOF0gPSBcIk1vZHVsb1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQW5kXCJdID0gOV0gPSBcIkFuZFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiT3JcIl0gPSAxMF0gPSBcIk9yXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaXR3aXNlQW5kXCJdID0gMTFdID0gXCJCaXR3aXNlQW5kXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlclwiXSA9IDEyXSA9IFwiTG93ZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyRXF1YWxzXCJdID0gMTNdID0gXCJMb3dlckVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyXCJdID0gMTRdID0gXCJCaWdnZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlckVxdWFsc1wiXSA9IDE1XSA9IFwiQmlnZ2VyRXF1YWxzXCI7XG59KShCaW5hcnlPcGVyYXRvciB8fCAoQmluYXJ5T3BlcmF0b3IgPSB7fSkpO1xuZnVuY3Rpb24gbnVsbFNhZmVJc0VxdWl2YWxlbnQoYmFzZSwgb3RoZXIpIHtcbiAgICBpZiAoYmFzZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgPT0gb3RoZXI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlLmlzRXF1aXZhbGVudChvdGhlcik7XG59XG5mdW5jdGlvbiBhcmVBbGxFcXVpdmFsZW50KGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIGxlbiA9IGJhc2UubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFiYXNlW2ldLmlzRXF1aXZhbGVudChvdGhlcltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBFeHByZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24odHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24gKGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsRm4gPSBmdW5jdGlvbiAocGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnN0YW50aWF0ZUV4cHIodGhpcywgcGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKHRydWVDYXNlLCBmYWxzZUNhc2UsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIodGhpcywgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5JZGVudGljYWwsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RJZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnBsdXMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLlBsdXMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTW9kdWxvLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaXR3aXNlQW5kID0gZnVuY3Rpb24gKHJocywgc291cmNlU3BhbiwgcGFyZW5zKSB7XG4gICAgICAgIGlmIChwYXJlbnMgPT09IHZvaWQgMCkgeyBwYXJlbnMgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpdHdpc2VBbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3BhbiwgcGFyZW5zKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4pIHtcbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgdHlwZWQgbnVsbCB0byBhbGxvdyBzdHJpY3ROdWxsQ2hlY2tzIHRvIG5hcnJvdyB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFRZUEVEX05VTExfRVhQUiwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXN0RXhwcih0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RtdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMsIG51bGwpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb247XG59KCkpO1xudmFyIEJ1aWx0aW5WYXI7XG4oZnVuY3Rpb24gKEJ1aWx0aW5WYXIpIHtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJUaGlzXCJdID0gMF0gPSBcIlRoaXNcIjtcbiAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJTdXBlclwiXSA9IDFdID0gXCJTdXBlclwiO1xuICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIkNhdGNoRXJyb3JcIl0gPSAyXSA9IFwiQ2F0Y2hFcnJvclwiO1xuICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIkNhdGNoU3RhY2tcIl0gPSAzXSA9IFwiQ2F0Y2hTdGFja1wiO1xufSkoQnVpbHRpblZhciB8fCAoQnVpbHRpblZhciA9IHt9KSk7XG52YXIgUmVhZFZhckV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRWYXJFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWRWYXJFeHByKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLmJ1aWx0aW4gPT09IGUuYnVpbHRpbjtcbiAgICB9O1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1aWx0IGluIHZhcmlhYmxlIFwiICsgdGhpcy5idWlsdGluICsgXCIgY2FuIG5vdCBiZSBhc3NpZ25lZCB0by5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVZhckV4cHIodGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFR5cGVvZkV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFR5cGVvZkV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHlwZW9mRXhwcihleHByLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHIgPSBleHByO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFR5cGVvZkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHlwZW9mRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFR5cGVvZkV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVHlwZW9mRXhwciAmJiBlLmV4cHIuaXNFcXVpdmFsZW50KHRoaXMuZXhwcik7XG4gICAgfTtcbiAgICBUeXBlb2ZFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByLmlzQ29uc3RhbnQoKTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlb2ZFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JhcHBlZE5vZGVFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcmFwcGVkTm9kZUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JhcHBlZE5vZGVFeHByKG5vZGUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV3JhcHBlZE5vZGVFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyYXBwZWROb2RlRXhwciAmJiB0aGlzLm5vZGUgPT09IGUubm9kZTtcbiAgICB9O1xuICAgIFdyYXBwZWROb2RlRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgV3JhcHBlZE5vZGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyYXBwZWROb2RlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcmFwcGVkTm9kZUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBXcml0ZVZhckV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlVmFyRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXcml0ZVZhckV4cHIobmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgV3JpdGVWYXJFeHByICYmIHRoaXMubmFtZSA9PT0gZS5uYW1lICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVWYXJFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRoaXMubmFtZSwgdGhpcy52YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0NvbnN0RGVjbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgfTtcbiAgICByZXR1cm4gV3JpdGVWYXJFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgV3JpdGVLZXlFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXcml0ZUtleUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdyaXRlS2V5RXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZUtleUV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMuaW5kZXguaXNFcXVpdmFsZW50KGUuaW5kZXgpICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBXcml0ZUtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlS2V5RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlUHJvcEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV3JpdGVQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXcml0ZVByb3BFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlUHJvcEV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMubmFtZSA9PT0gZS5uYW1lICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBCdWlsdGluTWV0aG9kO1xuKGZ1bmN0aW9uIChCdWlsdGluTWV0aG9kKSB7XG4gICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQ29uY2F0QXJyYXlcIl0gPSAwXSA9IFwiQ29uY2F0QXJyYXlcIjtcbiAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJTdWJzY3JpYmVPYnNlcnZhYmxlXCJdID0gMV0gPSBcIlN1YnNjcmliZU9ic2VydmFibGVcIjtcbiAgICBCdWlsdGluTWV0aG9kW0J1aWx0aW5NZXRob2RbXCJCaW5kXCJdID0gMl0gPSBcIkJpbmRcIjtcbn0pKEJ1aWx0aW5NZXRob2QgfHwgKEJ1aWx0aW5NZXRob2QgPSB7fSkpO1xudmFyIEludm9rZU1ldGhvZEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludm9rZU1ldGhvZEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52b2tlTWV0aG9kRXhwcihyZWNlaXZlciwgbWV0aG9kLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBtZXRob2Q7XG4gICAgICAgICAgICBfdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEludm9rZU1ldGhvZEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSW52b2tlTWV0aG9kRXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5uYW1lID09PSBlLm5hbWUgJiYgdGhpcy5idWlsdGluID09PSBlLmJ1aWx0aW4gJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncyk7XG4gICAgfTtcbiAgICBJbnZva2VNZXRob2RFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBJbnZva2VNZXRob2RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZU1ldGhvZEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW52b2tlTWV0aG9kRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEludm9rZUZ1bmN0aW9uRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludm9rZUZ1bmN0aW9uRXhwcihmbiwgYXJncywgdHlwZSwgc291cmNlU3BhbiwgcHVyZSkge1xuICAgICAgICBpZiAocHVyZSA9PT0gdm9pZCAwKSB7IHB1cmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mbiA9IGZuO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMucHVyZSA9IHB1cmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEludm9rZUZ1bmN0aW9uRXhwciAmJiB0aGlzLmZuLmlzRXF1aXZhbGVudChlLmZuKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncykgJiYgdGhpcy5wdXJlID09PSBlLnB1cmU7XG4gICAgfTtcbiAgICBJbnZva2VGdW5jdGlvbkV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEludm9rZUZ1bmN0aW9uRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW52b2tlRnVuY3Rpb25FeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgSW5zdGFudGlhdGVFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5zdGFudGlhdGVFeHByKGNsYXNzRXhwciwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0ZUV4cHIgJiYgdGhpcy5jbGFzc0V4cHIuaXNFcXVpdmFsZW50KGUuY2xhc3NFeHByKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncyk7XG4gICAgfTtcbiAgICBJbnN0YW50aWF0ZUV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHIgJiYgdGhpcy52YWx1ZSA9PT0gZS52YWx1ZTtcbiAgICB9O1xuICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIExpdGVyYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTG9jYWxpemVkU3RyaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2NhbGl6ZWRTdHJpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTG9jYWxpemVkU3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTVFJJTkdfVFlQRSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWV0YUJsb2NrID0gbWV0YUJsb2NrO1xuICAgICAgICBfdGhpcy5tZXNzYWdlUGFydHMgPSBtZXNzYWdlUGFydHM7XG4gICAgICAgIF90aGlzLnBsYWNlSG9sZGVyTmFtZXMgPSBwbGFjZUhvbGRlck5hbWVzO1xuICAgICAgICBfdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvY2FsaXplZFN0cmluZy5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGUgaW5zdGFuY2VvZiBMb2NhbGl6ZWRTdHJpbmcgJiYgdGhpcy5tZXNzYWdlID09PSBlLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExvY2FsaXplZFN0cmluZy5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTG9jYWxpemVkU3RyaW5nLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExvY2FsaXplZFN0cmluZyh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG1ldGFgIGFuZCBgbWVzc2FnZVBhcnRgIGludG8gXCJjb29rZWRcIiBhbmQgXCJyYXdcIiBzdHJpbmdzIHRoYXQgY2FuIGJlIHVzZWRcbiAgICAgKiBpbiBhIGAkbG9jYWxpemVgIHRhZ2dlZCBzdHJpbmcuIFRoZSBmb3JtYXQgb2YgdGhlIG1ldGFkYXRhIGlzIHRoZSBzYW1lIGFzIHRoYXQgcGFyc2VkIGJ5XG4gICAgICogYHBhcnNlSTE4bk1ldGEoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0YSBUaGUgbWV0YWRhdGEgdG8gc2VyaWFsaXplXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJ0IFRoZSBmaXJzdCBwYXJ0IG9mIHRoZSB0YWdnZWQgc3RyaW5nXG4gICAgICovXG4gICAgTG9jYWxpemVkU3RyaW5nLnByb3RvdHlwZS5zZXJpYWxpemVJMThuSGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIE1FQU5JTkdfU0VQQVJBVE9SID0gJ3wnO1xuICAgICAgICB2YXIgSURfU0VQQVJBVE9SID0gJ0BAJztcbiAgICAgICAgdmFyIExFR0FDWV9JRF9JTkRJQ0FUT1IgPSAn4pCfJztcbiAgICAgICAgdmFyIG1ldGFCbG9jayA9IHRoaXMubWV0YUJsb2NrLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subWVhbmluZykge1xuICAgICAgICAgICAgbWV0YUJsb2NrID0gXCJcIiArIHRoaXMubWV0YUJsb2NrLm1lYW5pbmcgKyBNRUFOSU5HX1NFUEFSQVRPUiArIG1ldGFCbG9jaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2suY3VzdG9tSWQpIHtcbiAgICAgICAgICAgIG1ldGFCbG9jayA9IFwiXCIgKyBtZXRhQmxvY2sgKyBJRF9TRVBBUkFUT1IgKyB0aGlzLm1ldGFCbG9jay5jdXN0b21JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subGVnYWN5SWRzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFCbG9jay5sZWdhY3lJZHMuZm9yRWFjaChmdW5jdGlvbiAobGVnYWN5SWQpIHtcbiAgICAgICAgICAgICAgICBtZXRhQmxvY2sgPSBcIlwiICsgbWV0YUJsb2NrICsgTEVHQUNZX0lEX0lORElDQVRPUiArIGxlZ2FjeUlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIHRoaXMubWVzc2FnZVBhcnRzWzBdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYHBsYWNlaG9sZGVyTmFtZWAgYW5kIGBtZXNzYWdlUGFydGAgaW50byBcImNvb2tlZFwiIGFuZCBcInJhd1wiIHN0cmluZ3MgdGhhdFxuICAgICAqIGNhbiBiZSB1c2VkIGluIGEgYCRsb2NhbGl6ZWAgdGFnZ2VkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlck5hbWUgVGhlIHBsYWNlaG9sZGVyIG5hbWUgdG8gc2VyaWFsaXplXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJ0IFRoZSBmb2xsb3dpbmcgbWVzc2FnZSBzdHJpbmcgYWZ0ZXIgdGhpcyBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIExvY2FsaXplZFN0cmluZy5wcm90b3R5cGUuc2VyaWFsaXplSTE4blRlbXBsYXRlUGFydCA9IGZ1bmN0aW9uIChwYXJ0SW5kZXgpIHtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyTmFtZSA9IHRoaXMucGxhY2VIb2xkZXJOYW1lc1twYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgdmFyIG1lc3NhZ2VQYXJ0ID0gdGhpcy5tZXNzYWdlUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhwbGFjZWhvbGRlck5hbWUsIG1lc3NhZ2VQYXJ0KTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbGl6ZWRTdHJpbmc7XG59KEV4cHJlc3Npb24pKTtcbnZhciBlc2NhcGVTbGFzaGVzID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7IH07XG52YXIgZXNjYXBlU3RhcnRpbmdDb2xvbiA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9eOi8sICdcXFxcOicpOyB9O1xudmFyIGVzY2FwZUNvbG9ucyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC86L2csICdcXFxcOicpOyB9O1xudmFyIGVzY2FwZUZvck1lc3NhZ2VQYXJ0ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvYC9nLCAnXFxcXGAnKS5yZXBsYWNlKC9cXCR7L2csICckXFxcXHsnKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBge2Nvb2tlZCwgcmF3fWAgb2JqZWN0IGZyb20gdGhlIGBtZXRhQmxvY2tgIGFuZCBgbWVzc2FnZVBhcnRgLlxuICpcbiAqIFRoZSBgcmF3YCB0ZXh0IG11c3QgaGF2ZSB2YXJpb3VzIGNoYXJhY3RlciBzZXF1ZW5jZXMgZXNjYXBlZDpcbiAqICogXCJcXFwiIHdvdWxkIG90aGVyd2lzZSBpbmRpY2F0ZSB0aGF0IHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLlxuICogKiBcImBcIiBhbmQgXCIke1wiIGFyZSB0ZW1wbGF0ZSBzdHJpbmcgY29udHJvbCBzZXF1ZW5jZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJlbWF0dXJlbHkgaW5kaWNhdGVcbiAqICAgdGhlIGVuZCBvZiBhIG1lc3NhZ2UgcGFydC5cbiAqICogXCI6XCIgaW5zaWRlIGEgbWV0YWJsb2NrIHdvdWxkIHByZW1hdHVyZWx5IGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIG1ldGFibG9jay5cbiAqICogXCI6XCIgYXQgdGhlIHN0YXJ0IG9mIGEgbWVzc2FnZVBhcnQgd2l0aCBubyBtZXRhYmxvY2sgd291bGQgZXJyb25lb3VzbHkgaW5kaWNhdGUgdGhlIHN0YXJ0IG9mIGFcbiAqICAgbWV0YWJsb2NrLlxuICpcbiAqIEBwYXJhbSBtZXRhQmxvY2sgQW55IG1ldGFkYXRhIHRoYXQgc2hvdWxkIGJlIHByZXBlbmRlZCB0byB0aGUgc3RyaW5nXG4gKiBAcGFyYW0gbWVzc2FnZVBhcnQgVGhlIG1lc3NhZ2UgcGFydCBvZiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0KSB7XG4gICAgaWYgKG1ldGFCbG9jayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tlZDogbWVzc2FnZVBhcnQsXG4gICAgICAgICAgICByYXc6IGVzY2FwZUZvck1lc3NhZ2VQYXJ0KGVzY2FwZVN0YXJ0aW5nQ29sb24oZXNjYXBlU2xhc2hlcyhtZXNzYWdlUGFydCkpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tlZDogXCI6XCIgKyBtZXRhQmxvY2sgKyBcIjpcIiArIG1lc3NhZ2VQYXJ0LFxuICAgICAgICAgICAgcmF3OiBlc2NhcGVGb3JNZXNzYWdlUGFydChcIjpcIiArIGVzY2FwZUNvbG9ucyhlc2NhcGVTbGFzaGVzKG1ldGFCbG9jaykpICsgXCI6XCIgKyBlc2NhcGVTbGFzaGVzKG1lc3NhZ2VQYXJ0KSlcbiAgICAgICAgfTtcbiAgICB9XG59XG52YXIgRXh0ZXJuYWxFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHRlcm5hbEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXh0ZXJuYWxFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEV4dGVybmFsRXhwciAmJiB0aGlzLnZhbHVlLm5hbWUgPT09IGUudmFsdWUubmFtZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS5tb2R1bGVOYW1lID09PSBlLnZhbHVlLm1vZHVsZU5hbWUgJiYgdGhpcy52YWx1ZS5ydW50aW1lID09PSBlLnZhbHVlLnJ1bnRpbWU7XG4gICAgfTtcbiAgICBFeHRlcm5hbEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEV4dGVybmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHRlcm5hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZXJuYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRXh0ZXJuYWxSZWZlcmVuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxSZWZlcmVuY2UobW9kdWxlTmFtZSwgbmFtZSwgcnVudGltZSkge1xuICAgICAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICAgIH1cbiAgICByZXR1cm4gRXh0ZXJuYWxSZWZlcmVuY2U7XG59KCkpO1xudmFyIENvbmRpdGlvbmFsRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcihjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB0cnVlQ2FzZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIF90aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgX3RoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25kaXRpb25hbEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ29uZGl0aW9uYWxFeHByICYmIHRoaXMuY29uZGl0aW9uLmlzRXF1aXZhbGVudChlLmNvbmRpdGlvbikgJiZcbiAgICAgICAgICAgIHRoaXMudHJ1ZUNhc2UuaXNFcXVpdmFsZW50KGUudHJ1ZUNhc2UpICYmIG51bGxTYWZlSXNFcXVpdmFsZW50KHRoaXMuZmFsc2VDYXNlLCBlLmZhbHNlQ2FzZSk7XG4gICAgfTtcbiAgICBDb25kaXRpb25hbEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbmRpdGlvbmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTm90RXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm90RXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RFeHByKGNvbmRpdGlvbiwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBCT09MX1RZUEUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOb3RFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIE5vdEV4cHIgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KGUuY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIE5vdEV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE5vdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm90RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOb3RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQXNzZXJ0Tm90TnVsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNzZXJ0Tm90TnVsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3NlcnROb3ROdWxsKGNvbmRpdGlvbiwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25kaXRpb24udHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFzc2VydE5vdE51bGwucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQXNzZXJ0Tm90TnVsbCAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pO1xuICAgIH07XG4gICAgQXNzZXJ0Tm90TnVsbC5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQXNzZXJ0Tm90TnVsbC5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBc3NlcnROb3ROdWxsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBBc3NlcnROb3ROdWxsO1xufShFeHByZXNzaW9uKSk7XG52YXIgQ2FzdEV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhc3RFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhc3RFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FzdEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ2FzdEV4cHIgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfTtcbiAgICBDYXN0RXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQ2FzdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FzdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FzdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBGblBhcmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZuUGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIEZuUGFyYW0ucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBwYXJhbS5uYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEZuUGFyYW07XG59KCkpO1xudmFyIEZ1bmN0aW9uRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIHNvdXJjZVNwYW4sIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEZ1bmN0aW9uRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFyYW1zLCBlLnBhcmFtcykgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdGF0ZW1lbnRzLCBlLnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25FeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BlcmF0b3JFeHByKG9wZXJhdG9yLCBsaHMsIHJocywgdHlwZSwgc291cmNlU3BhbiwgcGFyZW5zKSB7XG4gICAgICAgIGlmIChwYXJlbnMgPT09IHZvaWQgMCkgeyBwYXJlbnMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgbGhzLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIF90aGlzLnJocyA9IHJocztcbiAgICAgICAgX3RoaXMucGFyZW5zID0gcGFyZW5zO1xuICAgICAgICBfdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEJpbmFyeU9wZXJhdG9yRXhwciAmJiB0aGlzLm9wZXJhdG9yID09PSBlLm9wZXJhdG9yICYmXG4gICAgICAgICAgICB0aGlzLmxocy5pc0VxdWl2YWxlbnQoZS5saHMpICYmIHRoaXMucmhzLmlzRXF1aXZhbGVudChlLnJocyk7XG4gICAgfTtcbiAgICBCaW5hcnlPcGVyYXRvckV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEJpbmFyeU9wZXJhdG9yRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQmluYXJ5T3BlcmF0b3JFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgUmVhZFByb3BFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWFkUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhZFByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBSZWFkUHJvcEV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMubmFtZSA9PT0gZS5uYW1lO1xuICAgIH07XG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVhZFByb3BFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVByb3BFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMubmFtZSwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZFByb3BFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgUmVhZEtleUV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlYWRLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRLZXlFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLmluZGV4LmlzRXF1aXZhbGVudChlLmluZGV4KTtcbiAgICB9O1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5pbmRleCwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gUmVhZEtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBMaXRlcmFsQXJyYXlFeHByID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsQXJyYXlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaXRlcmFsQXJyYXlFeHByLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmV2ZXJ5KGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmlzQ29uc3RhbnQoKTsgfSk7XG4gICAgfTtcbiAgICBMaXRlcmFsQXJyYXlFeHByLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIExpdGVyYWxBcnJheUV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmVudHJpZXMsIGUuZW50cmllcyk7XG4gICAgfTtcbiAgICBMaXRlcmFsQXJyYXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5RXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIExpdGVyYWxNYXBFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRW50cnkoa2V5LCB2YWx1ZSwgcXVvdGVkKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVvdGVkID0gcXVvdGVkO1xuICAgIH1cbiAgICBMaXRlcmFsTWFwRW50cnkucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleSA9PT0gZS5rZXkgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcEVudHJ5O1xufSgpKTtcbnZhciBMaXRlcmFsTWFwRXhwciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcEV4cHIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTGl0ZXJhbE1hcEV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmVudHJpZXMsIGUuZW50cmllcyk7XG4gICAgfTtcbiAgICBMaXRlcmFsTWFwRXhwci5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5ldmVyeShmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS52YWx1ZS5pc0NvbnN0YW50KCk7IH0pO1xuICAgIH07XG4gICAgTGl0ZXJhbE1hcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbE1hcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDb21tYUV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbW1hRXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tYUV4cHIocGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21tYUV4cHIucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQ29tbWFFeHByICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5wYXJ0cywgZS5wYXJ0cyk7XG4gICAgfTtcbiAgICBDb21tYUV4cHIucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbW1hRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tYUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWFFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgVEhJU19FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuVGhpcywgbnVsbCwgbnVsbCk7XG52YXIgU1VQRVJfRVhQUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLlN1cGVyLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9FUlJPUl9WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaEVycm9yLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaFN0YWNrLCBudWxsLCBudWxsKTtcbnZhciBOVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgbnVsbCwgbnVsbCk7XG52YXIgVFlQRURfTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIElORkVSUkVEX1RZUEUsIG51bGwpO1xuLy8vLyBTdGF0ZW1lbnRzXG52YXIgU3RtdE1vZGlmaWVyO1xuKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiRmluYWxcIl0gPSAwXSA9IFwiRmluYWxcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiUHJpdmF0ZVwiXSA9IDFdID0gXCJQcml2YXRlXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIkV4cG9ydGVkXCJdID0gMl0gPSBcIkV4cG9ydGVkXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlN0YXRpY1wiXSA9IDNdID0gXCJTdGF0aWNcIjtcbn0pKFN0bXRNb2RpZmllciB8fCAoU3RtdE1vZGlmaWVyID0ge30pKTtcbnZhciBTdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbiB8fCBudWxsO1xuICAgIH1cbiAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50O1xufSgpKTtcbnZhciBEZWNsYXJlVmFyU3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVjbGFyZVZhclN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVjbGFyZVZhclN0bXQobmFtZSwgdmFsdWUsIHR5cGUsIG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZSB8fCAodmFsdWUgJiYgdmFsdWUudHlwZSkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZWNsYXJlVmFyU3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBEZWNsYXJlVmFyU3RtdCAmJiB0aGlzLm5hbWUgPT09IHN0bXQubmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMudmFsdWUgPyAhIXN0bXQudmFsdWUgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoc3RtdC52YWx1ZSkgOiAhc3RtdC52YWx1ZSk7XG4gICAgfTtcbiAgICBEZWNsYXJlVmFyU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVWYXJTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY2xhcmVWYXJTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBEZWNsYXJlRnVuY3Rpb25TdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlRnVuY3Rpb25TdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEZWNsYXJlRnVuY3Rpb25TdG10LnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIERlY2xhcmVGdW5jdGlvblN0bXQgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcmFtcywgc3RtdC5wYXJhbXMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuc3RhdGVtZW50cywgc3RtdC5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cHJlc3Npb25TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHIgPSBleHByO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgRXhwcmVzc2lvblN0YXRlbWVudCAmJiB0aGlzLmV4cHIuaXNFcXVpdmFsZW50KHN0bXQuZXhwcik7XG4gICAgfTtcbiAgICBFeHByZXNzaW9uU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcbn0oU3RhdGVtZW50KSk7XG52YXIgUmV0dXJuU3RhdGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXR1cm5TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChzdG10LnZhbHVlKTtcbiAgICB9O1xuICAgIFJldHVyblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xufShTdGF0ZW1lbnQpKTtcbnZhciBBYnN0cmFjdENsYXNzUGFydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENsYXNzUGFydCh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICB9XG4gICAgQWJzdHJhY3RDbGFzc1BhcnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDbGFzc1BhcnQ7XG59KCkpO1xudmFyIENsYXNzRmllbGQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzRmllbGQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NGaWVsZChuYW1lLCB0eXBlLCBtb2RpZmllcnMsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2xhc3NGaWVsZC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gZi5uYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIENsYXNzRmllbGQ7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NNZXRob2QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzTWV0aG9kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsYXNzTWV0aG9kKG5hbWUsIHBhcmFtcywgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgX3RoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2xhc3NNZXRob2QucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IG0ubmFtZSAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMuYm9keSwgbS5ib2R5KTtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc01ldGhvZDtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbnZhciBDbGFzc0dldHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2xhc3NHZXR0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NHZXR0ZXIobmFtZSwgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsYXNzR2V0dGVyLnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBtLm5hbWUgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmJvZHksIG0uYm9keSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NHZXR0ZXI7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NTdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc1N0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xhc3NTdG10KG5hbWUsIHBhcmVudCwgZmllbGRzLCBnZXR0ZXJzLCBjb25zdHJ1Y3Rvck1ldGhvZCwgbWV0aG9kcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycywgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgX3RoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICBfdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgX3RoaXMuY29uc3RydWN0b3JNZXRob2QgPSBjb25zdHJ1Y3Rvck1ldGhvZDtcbiAgICAgICAgX3RoaXMubWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2xhc3NTdG10LnByb3RvdHlwZS5pc0VxdWl2YWxlbnQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIENsYXNzU3RtdCAmJiB0aGlzLm5hbWUgPT09IHN0bXQubmFtZSAmJlxuICAgICAgICAgICAgbnVsbFNhZmVJc0VxdWl2YWxlbnQodGhpcy5wYXJlbnQsIHN0bXQucGFyZW50KSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmZpZWxkcywgc3RtdC5maWVsZHMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuZ2V0dGVycywgc3RtdC5nZXR0ZXJzKSAmJlxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvck1ldGhvZC5pc0VxdWl2YWxlbnQoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5tZXRob2RzLCBzdG10Lm1ldGhvZHMpO1xuICAgIH07XG4gICAgQ2xhc3NTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc1N0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIElmU3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWZTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElmU3RtdChjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgX3RoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgICAgX3RoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIElmU3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBJZlN0bXQgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KHN0bXQuY29uZGl0aW9uKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnRydWVDYXNlLCBzdG10LnRydWVDYXNlKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmZhbHNlQ2FzZSwgc3RtdC5mYWxzZUNhc2UpO1xuICAgIH07XG4gICAgSWZTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWZTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIElmU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgQ29tbWVudFN0bXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbW1lbnRTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbW1lbnRTdG10KGNvbW1lbnQsIG11bHRpbGluZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobXVsdGlsaW5lID09PSB2b2lkIDApIHsgbXVsdGlsaW5lID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIF90aGlzLm11bHRpbGluZSA9IG11bHRpbGluZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21tZW50U3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBDb21tZW50U3RtdDtcbiAgICB9O1xuICAgIENvbW1lbnRTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29tbWVudFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEpTRG9jQ29tbWVudFN0bXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTRG9jQ29tbWVudFN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNEb2NDb21tZW50U3RtdCh0YWdzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0YWdzID09PSB2b2lkIDApIHsgdGFncyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEpTRG9jQ29tbWVudFN0bXQucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgSlNEb2NDb21tZW50U3RtdCAmJiB0aGlzLnRvU3RyaW5nKCkgPT09IHN0bXQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEpTRG9jQ29tbWVudFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRKU0RvY0NvbW1lbnRTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgSlNEb2NDb21tZW50U3RtdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVUYWdzKHRoaXMudGFncyk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNEb2NDb21tZW50U3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgVHJ5Q2F0Y2hTdG10ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcnlDYXRjaFN0bXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJ5Q2F0Y2hTdG10KGJvZHlTdG10cywgY2F0Y2hTdG10cywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ib2R5U3RtdHMgPSBib2R5U3RtdHM7XG4gICAgICAgIF90aGlzLmNhdGNoU3RtdHMgPSBjYXRjaFN0bXRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBUcnlDYXRjaFN0bXQgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmJvZHlTdG10cywgc3RtdC5ib2R5U3RtdHMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuY2F0Y2hTdG10cywgc3RtdC5jYXRjaFN0bXRzKTtcbiAgICB9O1xuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUcnlDYXRjaFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRocm93U3RtdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3dTdG10LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm93U3RtdChlcnJvciwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRocm93U3RtdC5wcm90b3R5cGUuaXNFcXVpdmFsZW50ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBUcnlDYXRjaFN0bXQgJiYgdGhpcy5lcnJvci5pc0VxdWl2YWxlbnQoc3RtdC5lcnJvcik7XG4gICAgfTtcbiAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUaHJvd1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3dTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBBc3RUcmFuc2Zvcm1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUeXBlb2ZFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgVHlwZW9mRXhwcihleHByLmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVWYXJFeHByKGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudHlwZSwgZXhwci5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci50eXBlLCBleHByLnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBXcml0ZVByb3BFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLm5hbWUsIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnR5cGUsIGV4cHIuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGFzdC5idWlsdGluIHx8IGFzdC5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnZva2VNZXRob2RFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIG1ldGhvZCwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMb2NhbGl6ZWRTdHJpbmcgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExvY2FsaXplZFN0cmluZyhhc3QubWV0YUJsb2NrLCBhc3QubWVzc2FnZVBhcnRzLCBhc3QucGxhY2VIb2xkZXJOYW1lcywgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5leHByZXNzaW9ucywgY29udGV4dCksIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIoYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ29uZGl0aW9uYWxFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBOb3RFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEFzc2VydE5vdE51bGwoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ2FzdEV4cHIoYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEZ1bmN0aW9uRXhwcihhc3QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoYXN0Lm9wZXJhdG9yLCBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBSZWFkUHJvcEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0Lm5hbWUsIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFJlYWRLZXlFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTGl0ZXJhbEFycmF5RXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW50cmllcyA9IGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoZW50cnkua2V5LCBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpLCBlbnRyeS5xdW90ZWQpOyB9KTtcbiAgICAgICAgdmFyIG1hcFR5cGUgPSBuZXcgTWFwVHlwZShhc3QudmFsdWVUeXBlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTGl0ZXJhbE1hcEV4cHIoZW50cmllcywgbWFwVHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ29tbWFFeHByKHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJzLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RtdC52YWx1ZSAmJiBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRGVjbGFyZVZhclN0bXQoc3RtdC5uYW1lLCB2YWx1ZSwgc3RtdC50eXBlLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRGVjbGFyZUZ1bmN0aW9uU3RtdChzdG10Lm5hbWUsIHN0bXQucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGNvbnRleHQpLCBzdG10LnR5cGUsIHN0bXQubW9kaWZpZXJzLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRXhwcmVzc2lvblN0YXRlbWVudChzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBSZXR1cm5TdGF0ZW1lbnQoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnQgPSBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHZhciBnZXR0ZXJzID0gc3RtdC5nZXR0ZXJzLm1hcChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBuZXcgQ2xhc3NHZXR0ZXIoZ2V0dGVyLm5hbWUsIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY29udGV4dCksIGdldHRlci50eXBlLCBnZXR0ZXIubW9kaWZpZXJzKTsgfSk7XG4gICAgICAgIHZhciBjdG9yTWV0aG9kID0gc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAmJlxuICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKHN0bXQuY29uc3RydWN0b3JNZXRob2QubmFtZSwgc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMsIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY29udGV4dCksIHN0bXQuY29uc3RydWN0b3JNZXRob2QudHlwZSwgc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5tb2RpZmllcnMpO1xuICAgICAgICB2YXIgbWV0aG9kcyA9IHN0bXQubWV0aG9kcy5tYXAoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gbmV3IENsYXNzTWV0aG9kKG1ldGhvZC5uYW1lLCBtZXRob2QucGFyYW1zLCBfdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGNvbnRleHQpLCBtZXRob2QudHlwZSwgbWV0aG9kLm1vZGlmaWVycyk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBDbGFzc1N0bXQoc3RtdC5uYW1lLCBwYXJlbnQsIHN0bXQuZmllbGRzLCBnZXR0ZXJzLCBjdG9yTWV0aG9kLCBtZXRob2RzLCBzdG10Lm1vZGlmaWVycywgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBJZlN0bXQoc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFRyeUNhdGNoU3RtdCh0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChzdG10LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEpTRG9jQ29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KHN0bXQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdG10cywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN0VHJhbnNmb3JtZXI7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVjdXJzaXZlQXN0VmlzaXRvcigpIHtcbiAgICB9XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoYXN0LnR5cGUpIHtcbiAgICAgICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCdWlsdGluVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0eXBlLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGUudHlwZVBhcmFtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZS50eXBlUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBfdGhpcy52aXNpdFR5cGUocGFyYW0sIGNvbnRleHQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlb2ZFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExvY2FsaXplZFN0cmluZyA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFzdC50eXBlUGFyYW1zKSB7XG4gICAgICAgICAgICBhc3QudHlwZVBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnZpc2l0VHlwZShfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHBycywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBleHBycy5mb3JFYWNoKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiBleHByLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChzdG10LnZhbHVlKSB7XG4gICAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC50eXBlKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSkge1xuICAgICAgICAgICAgc3RtdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KTsgfSk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNhdGNoU3RtdHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRKU0RvY0NvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3RtdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gZmluZFJlYWRWYXJOYW1lcyhzdG10cykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9SZWFkVmFyVmlzaXRvcigpO1xuICAgIHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICByZXR1cm4gdmlzaXRvci52YXJOYW1lcztcbn1cbnZhciBfUmVhZFZhclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9SZWFkVmFyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfUmVhZFZhclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICBfUmVhZFZhclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QubmFtZSkge1xuICAgICAgICAgICAgdGhpcy52YXJOYW1lcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIF9SZWFkVmFyVmlzaXRvcjtcbn0oUmVjdXJzaXZlQXN0VmlzaXRvcikpO1xuZnVuY3Rpb24gY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlcyhzdG10cykge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9GaW5kRXh0ZXJuYWxSZWZlcmVuY2VzVmlzaXRvcigpO1xuICAgIHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICByZXR1cm4gdmlzaXRvci5leHRlcm5hbFJlZmVyZW5jZXM7XG59XG52YXIgX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfRmluZEV4dGVybmFsUmVmZXJlbmNlc1Zpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXh0ZXJuYWxSZWZlcmVuY2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZWZlcmVuY2VzLnB1c2goZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByLmNhbGwodGhpcywgZSwgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gX0ZpbmRFeHRlcm5hbFJlZmVyZW5jZXNWaXNpdG9yO1xufShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG5mdW5jdGlvbiBhcHBseVNvdXJjZVNwYW5Ub1N0YXRlbWVudElmTmVlZGVkKHN0bXQsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIXNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIoc291cmNlU3Bhbik7XG4gICAgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQodHJhbnNmb3JtZXIsIG51bGwpO1xufVxuZnVuY3Rpb24gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoZXhwciwgc291cmNlU3Bhbikge1xuICAgIGlmICghc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24odHJhbnNmb3JtZXIsIG51bGwpO1xufVxudmFyIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZShvYmouY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMob2JqKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNsb25lW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG4gICAgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1FeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFleHByLnNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9jbG9uZShleHByKTtcbiAgICAgICAgICAgIGV4cHIuc291cmNlU3BhbiA9IHRoaXMuc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghc3RtdC5zb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBzdG10ID0gdGhpcy5fY2xvbmUoc3RtdCk7XG4gICAgICAgICAgICBzdG10LnNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyO1xufShBc3RUcmFuc2Zvcm1lcikpO1xuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpbXBvcnRFeHByKGlkLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKGlkLCBudWxsLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVNb2RpZmllcnMgPT09IHZvaWQgMCkgeyB0eXBlTW9kaWZpZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBpZCAhPSBudWxsID8gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcywgbnVsbCksIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb25UeXBlKGV4cHIsIHR5cGVNb2RpZmllcnMsIHR5cGVQYXJhbXMpIHtcbiAgICBpZiAodHlwZU1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IHR5cGVNb2RpZmllcnMgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycywgdHlwZVBhcmFtcyk7XG59XG5mdW5jdGlvbiB0eXBlb2ZFeHByKGV4cHIpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVvZkV4cHIoZXhwcik7XG59XG5mdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGUua2V5LCBlLnZhbHVlLCBlLnF1b3RlZCk7IH0pLCB0eXBlLCBudWxsKTtcbn1cbmZ1bmN0aW9uIG5vdChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBOb3RFeHByKGV4cHIsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm90TnVsbChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnROb3ROdWxsKGV4cHIsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHIocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGlmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UpIHtcbiAgICByZXR1cm4gbmV3IElmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UpO1xufVxuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbG9jYWxpemVkU3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZWhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTG9jYWxpemVkU3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZWhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpc051bGwoZXhwKSB7XG4gICAgcmV0dXJuIGV4cCBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmIGV4cC52YWx1ZSA9PT0gbnVsbDtcbn1cbi8qXG4gKiBTZXJpYWxpemVzIGEgYFRhZ2AgaW50byBhIHN0cmluZy5cbiAqIFJldHVybnMgYSBzdHJpbmcgbGlrZSBcIiBAZm9vIHtiYXJ9IGJhelwiIChub3RlIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgYmVmb3JlIGBAZm9vYCkuXG4gKi9cbmZ1bmN0aW9uIHRhZ1RvU3RyaW5nKHRhZykge1xuICAgIHZhciBvdXQgPSAnJztcbiAgICBpZiAodGFnLnRhZ05hbWUpIHtcbiAgICAgICAgb3V0ICs9IFwiIEBcIiArIHRhZy50YWdOYW1lO1xuICAgIH1cbiAgICBpZiAodGFnLnRleHQpIHtcbiAgICAgICAgaWYgKHRhZy50ZXh0Lm1hdGNoKC9cXC9cXCp8XFwqXFwvLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNEb2MgdGV4dCBjYW5ub3QgY29udGFpbiBcIi8qXCIgYW5kIFwiKi9cIicpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICcgKyB0YWcudGV4dC5yZXBsYWNlKC9AL2csICdcXFxcQCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVGFncyh0YWdzKSB7XG4gICAgdmFyIGVfMiwgX2E7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgdmFyIG91dCA9ICcqXFxuJztcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciB0YWdzXzEgPSBfX3ZhbHVlcyh0YWdzKSwgdGFnc18xXzEgPSB0YWdzXzEubmV4dCgpOyAhdGFnc18xXzEuZG9uZTsgdGFnc18xXzEgPSB0YWdzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGFnc18xXzEudmFsdWU7XG4gICAgICAgICAgICBvdXQgKz0gJyAqJztcbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWdUb1N0cmluZyBpcyBtdWx0aS1saW5lLCBpbnNlcnQgXCIgKiBcIiBwcmVmaXhlcyBvbiBzdWJzZXF1ZW50IGxpbmVzLlxuICAgICAgICAgICAgb3V0ICs9IHRhZ1RvU3RyaW5nKHRhZykucmVwbGFjZSgvXFxuL2csICdcXG4gKiAnKTtcbiAgICAgICAgICAgIG91dCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRhZ3NfMV8xICYmICF0YWdzXzFfMS5kb25lICYmIChfYSA9IHRhZ3NfMS5yZXR1cm4pKSBfYS5jYWxsKHRhZ3NfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbiAgICBvdXQgKz0gJyAnO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0rKFthLXowLTldKS9nO1xuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKERBU0hfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbVsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc3BsaXRBdENvbG9uKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnOicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuZnVuY3Rpb24gc3BsaXRBdFBlcmlvZChpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJy4nLCBkZWZhdWx0VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIF9zcGxpdEF0KGlucHV0LCBjaGFyYWN0ZXIsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICB2YXIgY2hhcmFjdGVySW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgaWYgKGNoYXJhY3RlckluZGV4ID09IC0xKVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlcztcbiAgICByZXR1cm4gW2lucHV0LnNsaWNlKDAsIGNoYXJhY3RlckluZGV4KS50cmltKCksIGlucHV0LnNsaWNlKGNoYXJhY3RlckluZGV4ICsgMSkudHJpbSgpXTtcbn1cbmZ1bmN0aW9uIHZpc2l0VmFsdWUodmFsdWUsIHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheSh2YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmljdFN0cmluZ01hcCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmltaXRpdmUodmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzaXRvci52aXNpdE90aGVyKHZhbHVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbm9VbmRlZmluZWQodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbDtcbn1cbnZhciBWYWx1ZVRyYW5zZm9ybWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhbHVlVHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBWYWx1ZVRyYW5zZm9ybWVyO1xufSgpKTtcbnZhciBTeW5jQXN5bmMgPSB7XG4gICAgYXNzZXJ0U3luYzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiB2YWx1ZSBjYW5ub3QgYmUgYSBwcm9taXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHRoZW46IGZ1bmN0aW9uICh2YWx1ZSwgY2IpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJvbWlzZSh2YWx1ZSkgPyB2YWx1ZS50aGVuKGNiKSA6IGNiKHZhbHVlKTtcbiAgICB9LFxuICAgIGFsbDogZnVuY3Rpb24gKHN5bmNBc3luY1ZhbHVlcykge1xuICAgICAgICByZXR1cm4gc3luY0FzeW5jVmFsdWVzLnNvbWUoaXNQcm9taXNlKSA/IFByb21pc2UuYWxsKHN5bmNBc3luY1ZhbHVlcykgOiBzeW5jQXN5bmNWYWx1ZXM7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBcIiArIG1zZyk7XG59XG5mdW5jdGlvbiBzeW50YXhFcnJvcihtc2csIHBhcnNlRXJyb3JzKSB7XG4gICAgdmFyIGVycm9yID0gRXJyb3IobXNnKTtcbiAgICBlcnJvcltFUlJPUl9TWU5UQVhfRVJST1JdID0gdHJ1ZTtcbiAgICBpZiAocGFyc2VFcnJvcnMpXG4gICAgICAgIGVycm9yW0VSUk9SX1BBUlNFX0VSUk9SU10gPSBwYXJzZUVycm9ycztcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xudmFyIEVSUk9SX1BBUlNFX0VSUk9SUyA9ICduZ1BhcnNlRXJyb3JzJztcbmZ1bmN0aW9uIGlzU3ludGF4RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3JbRVJST1JfU1lOVEFYX0VSUk9SXTtcbn1cbmZ1bmN0aW9uIGdldFBhcnNlRXJyb3JzKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yW0VSUk9SX1BBUlNFX0VSUk9SU10gfHwgW107XG59XG4vLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzcGVjaWFsIG1lYW5pbmcgaW4gUmVndWxhciBFeHByZXNzaW9uc1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG52YXIgU1RSSU5HX01BUF9QUk9UTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG5mdW5jdGlvbiBpc1N0cmljdFN0cmluZ01hcChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xufVxuZnVuY3Rpb24gdXRmOEVuY29kZShzdHIpIHtcbiAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIGRlY29kZSBzdXJyb2dhdGVcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkYmZmICYmIHN0ci5sZW5ndGggPiAoaW5kZXggKyAxKSkge1xuICAgICAgICAgICAgdmFyIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0b2tlbi5tYXAoc3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgfVxuICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdG9rZW4ubmFtZTtcbiAgICB9XG4gICAgaWYgKCF0b2tlbi50b1N0cmluZykge1xuICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIC8vIFdBUk5JTkc6IGRvIG5vdCB0cnkgdG8gYEpTT04uc3RyaW5naWZ5KHRva2VuKWAgaGVyZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzQ0MFxuICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJycgKyByZXM7XG4gICAgfVxuICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG59XG4vKipcbiAqIExhemlseSByZXRyaWV2ZXMgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGEgZm9yd2FyZFJlZi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWYodHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX2ZvcndhcmRfcmVmX18nKSkge1xuICAgICAgICByZXR1cm4gdHlwZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGFyZ3VtZW50IGlzIHNoYXBlZCBsaWtlIGEgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgLy8gYWxsb3cgYW55IFByb21pc2UvQSsgY29tcGxpYW50IHRoZW5hYmxlLlxuICAgIC8vIEl0J3MgdXAgdG8gdGhlIGNhbGxlciB0byBlbnN1cmUgdGhhdCBvYmoudGhlbiBjb25mb3JtcyB0byB0aGUgc3BlY1xuICAgIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG52YXIgVmVyc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZXJzaW9uKGZ1bGwpIHtcbiAgICAgICAgdGhpcy5mdWxsID0gZnVsbDtcbiAgICAgICAgdmFyIHNwbGl0cyA9IGZ1bGwuc3BsaXQoJy4nKTtcbiAgICAgICAgdGhpcy5tYWpvciA9IHNwbGl0c1swXTtcbiAgICAgICAgdGhpcy5taW5vciA9IHNwbGl0c1sxXTtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHNwbGl0cy5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBWZXJzaW9uO1xufSgpKTtcbnZhciBfX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbnZhciBfX3NlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiBzZWxmO1xudmFyIF9fZ2xvYmFsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsO1xuLy8gQ2hlY2sgX19nbG9iYWwgZmlyc3QsIGJlY2F1c2UgaW4gTm9kZSB0ZXN0cyBib3RoIF9fZ2xvYmFsIGFuZCBfX3dpbmRvdyBtYXkgYmUgZGVmaW5lZCBhbmQgX2dsb2JhbFxuLy8gc2hvdWxkIGJlIF9fZ2xvYmFsIGluIHRoYXQgY2FzZS5cbnZhciBfZ2xvYmFsID0gX19nbG9iYWwgfHwgX193aW5kb3cgfHwgX19zZWxmO1xuZnVuY3Rpb24gbmV3QXJyYXkoc2l6ZSwgdmFsdWUpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGxpc3QucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBQYXJ0aXRpb25zIGEgZ2l2ZW4gYXJyYXkgaW50byAyIGFycmF5cywgYmFzZWQgb24gYSBib29sZWFuIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBjb25kaXRpb25cbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBhcnIgSW5wdXQgYXJyYXkgdGhhdCBzaG91bGQgYmUgcGFydGl0aW9uZWRcbiAqIEBwYXJhbSBjb25kaXRpb25GbiBDb25kaXRpb24gZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggaXRlbSBpbiBhIGdpdmVuIGFycmF5IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbkFycmF5KGFyciwgY29uZGl0aW9uRm4pIHtcbiAgICB2YXIgdHJ1dGh5ID0gW107XG4gICAgdmFyIGZhbHN5ID0gW107XG4gICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgKGNvbmRpdGlvbkZuKGl0ZW0pID8gdHJ1dGh5IDogZmFsc3kpLnB1c2goaXRlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENPTlNUQU5UX1BSRUZJWCA9ICdfYyc7XG4vKipcbiAqIGBDb25zdGFudFBvb2xgIHRyaWVzIHRvIHJldXNlIGxpdGVyYWwgZmFjdG9yaWVzIHdoZW4gdHdvIG9yIG1vcmUgbGl0ZXJhbHMgYXJlIGlkZW50aWNhbC5cbiAqIFdlIGRldGVybWluZSB3aGV0aGVyIGxpdGVyYWxzIGFyZSBpZGVudGljYWwgYnkgY3JlYXRpbmcgYSBrZXkgb3V0IG9mIHRoZWlyIEFTVCB1c2luZyB0aGVcbiAqIGBLZXlWaXNpdG9yYC4gVGhpcyBjb25zdGFudCBpcyB1c2VkIHRvIHJlcGxhY2UgZHluYW1pYyBleHByZXNzaW9ucyB3aGljaCBjYW4ndCBiZSBzYWZlbHlcbiAqIGNvbnZlcnRlZCBpbnRvIGEga2V5LiBFLmcuIGdpdmVuIGFuIGV4cHJlc3Npb24gYHtmb286IGJhcigpfWAsIHNpbmNlIHdlIGRvbid0IGtub3cgd2hhdFxuICogdGhlIHJlc3VsdCBvZiBgYmFyYCB3aWxsIGJlLCB3ZSBjcmVhdGUgYSBrZXkgdGhhdCBsb29rcyBsaWtlIGB7Zm9vOiA8dW5rbm93bj59YC4gTm90ZVxuICogdGhhdCB3ZSB1c2UgYSB2YXJpYWJsZSwgcmF0aGVyIHRoYW4gc29tZXRoaW5nIGxpa2UgYG51bGxgIGluIG9yZGVyIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gKi9cbnZhciBVTktOT1dOX1ZBTFVFX0tFWSA9IHZhcmlhYmxlKCc8dW5rbm93bj4nKTtcbi8qKlxuICogQ29udGV4dCB0byB1c2Ugd2hlbiBwcm9kdWNpbmcgYSBrZXkuXG4gKlxuICogVGhpcyBlbnN1cmVzIHdlIHNlZSB0aGUgY29uc3RhbnQgbm90IHRoZSByZWZlcmVuY2UgdmFyaWFibGUgd2hlbiBwcm9kdWNpbmdcbiAqIGEga2V5LlxuICovXG52YXIgS0VZX0NPTlRFWFQgPSB7fTtcbi8qKlxuICogQSBub2RlIHRoYXQgaXMgYSBwbGFjZS1ob2xkZXIgdGhhdCBhbGxvd3MgdGhlIG5vZGUgdG8gYmUgcmVwbGFjZWQgd2hlbiB0aGUgYWN0dWFsXG4gKiBub2RlIGlzIGtub3duLlxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSBjb25zdGFudCBwb29sIHRvIGNoYW5nZSBhbiBleHByZXNzaW9uIGZyb20gYSBkaXJlY3QgcmVmZXJlbmNlIHRvXG4gKiBhIGNvbnN0YW50IHRvIGEgc2hhcmVkIGNvbnN0YW50LiBJdCByZXR1cm5zIGEgZml4LXVwIG5vZGUgdGhhdCBpcyBsYXRlciBhbGxvd2VkIHRvXG4gKiBjaGFuZ2UgdGhlIHJlZmVyZW5jZWQgZXhwcmVzc2lvbi5cbiAqL1xudmFyIEZpeHVwRXhwcmVzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRml4dXBFeHByZXNzaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpeHVwRXhwcmVzc2lvbihyZXNvbHZlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXNvbHZlZC50eXBlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICBfdGhpcy5vcmlnaW5hbCA9IHJlc29sdmVkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpeHVwRXhwcmVzc2lvbi5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IEtFWV9DT05URVhUKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHByb2R1Y2luZyBhIGtleSB3ZSB3YW50IHRvIHRyYXZlcnNlIHRoZSBjb25zdGFudCBub3QgdGhlXG4gICAgICAgICAgICAvLyB2YXJpYWJsZSB1c2VkIHRvIHJlZmVyIHRvIGl0LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWwudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWQudmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaXh1cEV4cHJlc3Npb24ucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgRml4dXBFeHByZXNzaW9uICYmIHRoaXMucmVzb2x2ZWQuaXNFcXVpdmFsZW50KGUucmVzb2x2ZWQpO1xuICAgIH07XG4gICAgRml4dXBFeHByZXNzaW9uLnByb3RvdHlwZS5pc0NvbnN0YW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZpeHVwRXhwcmVzc2lvbi5wcm90b3R5cGUuZml4dXAgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnJlc29sdmVkID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zaGFyZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeHVwRXhwcmVzc2lvbjtcbn0oRXhwcmVzc2lvbikpO1xuLyoqXG4gKiBBIGNvbnN0YW50IHBvb2wgYWxsb3dzIGEgY29kZSBlbWl0dGVyIHRvIHNoYXJlIGNvbnN0YW50IGluIGFuIG91dHB1dCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb25zdGFudCBwb29sIGFsc28gc3VwcG9ydHMgc2hhcmluZyBhY2Nlc3MgdG8gaXZ5IGRlZmluaXRpb25zIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb25zdGFudFBvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnRQb29sKCkge1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5saXRlcmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXRlcmFsRmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluamVjdG9yRGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlRGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGlwZURlZmluaXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5leHROYW1lSW5kZXggPSAwO1xuICAgIH1cbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLmdldENvbnN0TGl0ZXJhbCA9IGZ1bmN0aW9uIChsaXRlcmFsLCBmb3JjZVNoYXJlZCkge1xuICAgICAgICBpZiAobGl0ZXJhbCBpbnN0YW5jZW9mIExpdGVyYWxFeHByIHx8IGxpdGVyYWwgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIERvIG5vIHB1dCBzaW1wbGUgbGl0ZXJhbHMgaW50byB0aGUgY29uc3RhbnQgcG9vbCBvciB0cnkgdG8gcHJvZHVjZSBhIGNvbnN0YW50IGZvciBhXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBjb25zdGFudC5cbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKGxpdGVyYWwpO1xuICAgICAgICB2YXIgZml4dXAgPSB0aGlzLmxpdGVyYWxzLmdldChrZXkpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFmaXh1cCkge1xuICAgICAgICAgICAgZml4dXAgPSBuZXcgRml4dXBFeHByZXNzaW9uKGxpdGVyYWwpO1xuICAgICAgICAgICAgdGhpcy5saXRlcmFscy5zZXQoa2V5LCBmaXh1cCk7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghbmV3VmFsdWUgJiYgIWZpeHVwLnNoYXJlZCkgfHwgKG5ld1ZhbHVlICYmIGZvcmNlU2hhcmVkKSkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZXhwcmVzc2lvbiB3aXRoIGEgdmFyaWFibGVcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmZyZXNoTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzLnB1c2godmFyaWFibGUobmFtZV8xKS5zZXQobGl0ZXJhbCkudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgICAgICAgZml4dXAuZml4dXAodmFyaWFibGUobmFtZV8xKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeHVwO1xuICAgIH07XG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS5nZXREZWZpbml0aW9uID0gZnVuY3Rpb24gKHR5cGUsIGtpbmQsIGN0eCwgZm9yY2VTaGFyZWQpIHtcbiAgICAgICAgaWYgKGZvcmNlU2hhcmVkID09PSB2b2lkIDApIHsgZm9yY2VTaGFyZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLmRlZmluaXRpb25zT2Yoa2luZCk7XG4gICAgICAgIHZhciBmaXh1cCA9IGRlZmluaXRpb25zLmdldCh0eXBlKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmICghZml4dXApIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHlOYW1lT2Yoa2luZCk7XG4gICAgICAgICAgICBmaXh1cCA9IG5ldyBGaXh1cEV4cHJlc3Npb24oY3R4LmltcG9ydEV4cHIodHlwZSkucHJvcChwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgZGVmaW5pdGlvbnMuc2V0KHR5cGUsIGZpeHVwKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFuZXdWYWx1ZSAmJiAhZml4dXAuc2hhcmVkKSB8fCAobmV3VmFsdWUgJiYgZm9yY2VTaGFyZWQpKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKG5hbWVfMikuc2V0KGZpeHVwLnJlc29sdmVkKS50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgICAgICBmaXh1cC5maXh1cCh2YXJpYWJsZShuYW1lXzIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4dXA7XG4gICAgfTtcbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLmdldExpdGVyYWxGYWN0b3J5ID0gZnVuY3Rpb24gKGxpdGVyYWwpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGJ1aWxkcyBhbiBhcnJheSBvZiBhIG1peCBvZiBjb25zdGFudCBhbmQgdmFyaWFibGUgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGxpdGVyYWwgaW5zdGFuY2VvZiBMaXRlcmFsQXJyYXlFeHByKSB7XG4gICAgICAgICAgICB2YXIgYXJndW1lbnRzRm9yS2V5ID0gbGl0ZXJhbC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5pc0NvbnN0YW50KCkgPyBlIDogVU5LTk9XTl9WQUxVRV9LRVk7IH0pO1xuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2YobGl0ZXJhbEFycihhcmd1bWVudHNGb3JLZXkpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMaXRlcmFsRmFjdG9yeShrZXksIGxpdGVyYWwuZW50cmllcywgZnVuY3Rpb24gKGVudHJpZXMpIHsgcmV0dXJuIGxpdGVyYWxBcnIoZW50cmllcyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25Gb3JLZXkgPSBsaXRlcmFsTWFwKGxpdGVyYWwuZW50cmllcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZS5pc0NvbnN0YW50KCkgPyBlLnZhbHVlIDogVU5LTk9XTl9WQUxVRV9LRVksXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBlLnF1b3RlZFxuICAgICAgICAgICAgfSk7IH0pKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKGV4cHJlc3Npb25Gb3JLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExpdGVyYWxGYWN0b3J5KGtleSwgbGl0ZXJhbC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS52YWx1ZTsgfSksIGZ1bmN0aW9uIChlbnRyaWVzKSB7IHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAga2V5OiBsaXRlcmFsLmVudHJpZXNbaW5kZXhdLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBsaXRlcmFsLmVudHJpZXNbaW5kZXhdLnF1b3RlZFxuICAgICAgICAgICAgfSk7IH0pKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnN0YW50UG9vbC5wcm90b3R5cGUuX2dldExpdGVyYWxGYWN0b3J5ID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzLCByZXN1bHRNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpdGVyYWxGYWN0b3J5ID0gdGhpcy5saXRlcmFsRmFjdG9yaWVzLmdldChrZXkpO1xuICAgICAgICB2YXIgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgPSB2YWx1ZXMuZmlsdGVyKChmdW5jdGlvbiAoZSkgeyByZXR1cm4gIWUuaXNDb25zdGFudCgpOyB9KSk7XG4gICAgICAgIGlmICghbGl0ZXJhbEZhY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRFeHByZXNzaW9ucyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKGUsIGluZGV4KSB7IHJldHVybiBlLmlzQ29uc3RhbnQoKSA/IF90aGlzLmdldENvbnN0TGl0ZXJhbChlLCB0cnVlKSA6IHZhcmlhYmxlKFwiYVwiICsgaW5kZXgpOyB9KTtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gcmVzdWx0RXhwcmVzc2lvbnMuZmlsdGVyKGlzVmFyaWFibGUpLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gbmV3IEZuUGFyYW0oZS5uYW1lLCBEWU5BTUlDX1RZUEUpOyB9KTtcbiAgICAgICAgICAgIHZhciBwdXJlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZuKHBhcmFtZXRlcnMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdE1hcChyZXN1bHRFeHByZXNzaW9ucykpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgICAgICB2YXIgbmFtZV8zID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKG5hbWVfMykuc2V0KHB1cmVGdW5jdGlvbkRlY2xhcmF0aW9uKS50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtcbiAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIGxpdGVyYWxGYWN0b3J5ID0gdmFyaWFibGUobmFtZV8zKTtcbiAgICAgICAgICAgIHRoaXMubGl0ZXJhbEZhY3Rvcmllcy5zZXQoa2V5LCBsaXRlcmFsRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGl0ZXJhbEZhY3Rvcnk6IGxpdGVyYWxGYWN0b3J5LCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50czogbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2R1Y2UgYSB1bmlxdWUgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBuYW1lIG1pZ2h0IGJlIHVuaXF1ZSBhbW9uZyBkaWZmZXJlbnQgcHJlZml4ZXMgaWYgYW55IG9mIHRoZSBwcmVmaXhlcyBlbmQgaW5cbiAgICAgKiBhIGRpZ2l0IHNvIHRoZSBwcmVmaXggc2hvdWxkIGJlIGEgY29uc3RhbnQgc3RyaW5nIChub3QgYmFzZWQgb24gdXNlciBpbnB1dCkgYW5kXG4gICAgICogbXVzdCBub3QgZW5kIGluIGEgZGlnaXQuXG4gICAgICovXG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS51bmlxdWVOYW1lID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHRoaXMubmV4dE5hbWVJbmRleCsrO1xuICAgIH07XG4gICAgQ29uc3RhbnRQb29sLnByb3RvdHlwZS5kZWZpbml0aW9uc09mID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogQ29tcG9uZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudERlZmluaXRpb25zO1xuICAgICAgICAgICAgY2FzZSAxIC8qIERpcmVjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RpdmVEZWZpbml0aW9ucztcbiAgICAgICAgICAgIGNhc2UgMCAvKiBJbmplY3RvciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3RvckRlZmluaXRpb25zO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFBpcGUgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGlwZURlZmluaXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5rbm93biBkZWZpbml0aW9uIGtpbmQgXCIgKyBraW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50RGVmaW5pdGlvbnM7XG4gICAgfTtcbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLnByb3BlcnR5TmFtZU9mID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIDIgLyogQ29tcG9uZW50ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnybVjbXAnO1xuICAgICAgICAgICAgY2FzZSAxIC8qIERpcmVjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ8m1ZGlyJztcbiAgICAgICAgICAgIGNhc2UgMCAvKiBJbmplY3RvciAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ8m1aW5qJztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBQaXBlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnybVwaXBlJztcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVua25vd24gZGVmaW5pdGlvbiBraW5kIFwiICsga2luZCk7XG4gICAgICAgIHJldHVybiAnPHVua25vd24+JztcbiAgICB9O1xuICAgIENvbnN0YW50UG9vbC5wcm90b3R5cGUuZnJlc2hOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlxdWVOYW1lKENPTlNUQU5UX1BSRUZJWCk7XG4gICAgfTtcbiAgICBDb25zdGFudFBvb2wucHJvdG90eXBlLmtleU9mID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmlzaXRFeHByZXNzaW9uKG5ldyBLZXlWaXNpdG9yKCksIEtFWV9DT05URVhUKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudFBvb2w7XG59KCkpO1xuLyoqXG4gKiBWaXNpdG9yIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIDIgZXhwcmVzc2lvbnMgYXJlIGVxdWl2YWxlbnQgYW5kIGNhbiBiZSBzaGFyZWQgaW4gdGhlXG4gKiBgQ29uc3RhbnRQb29sYC5cbiAqXG4gKiBXaGVuIHRoZSBpZCAoc3RyaW5nKSBnZW5lcmF0ZWQgYnkgdGhlIHZpc2l0b3IgaXMgZXF1YWwsIGV4cHJlc3Npb25zIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQuXG4gKi9cbnZhciBLZXlWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleVZpc2l0b3IoKSB7XG4gICAgICAgIHRoaXMudmlzaXRXcmFwcGVkTm9kZUV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0V3JpdGVWYXJFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlS2V5RXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRXcml0ZVByb3BFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEluc3RhbnRpYXRlRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRDb25kaXRpb25hbEV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Tm90RXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRBc3NlcnROb3ROdWxsRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRDYXN0RXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdFJlYWRQcm9wRXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRSZWFkS2V5RXhwciA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRDb21tYUV4cHIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0TG9jYWxpemVkU3RyaW5nID0gaW52YWxpZDtcbiAgICB9XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAodHlwZW9mIGFzdC52YWx1ZSA9PT0gJ3N0cmluZycgPyAnXCInICsgYXN0LnZhbHVlICsgJ1wiJyA6IGFzdC52YWx1ZSk7XG4gICAgfTtcbiAgICBLZXlWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBcIltcIiArIGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pLmpvaW4oJywnKSArIFwiXVwiO1xuICAgIH07XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1hcEtleSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIHF1b3RlID0gZW50cnkucXVvdGVkID8gJ1wiJyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBxdW90ZSArIGVudHJ5LmtleSArIHF1b3RlO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWFwRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBLZXkoZW50cnkpICsgXCI6XCIgKyBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBhc3QuZW50cmllcy5tYXAobWFwRW50cnkpLmpvaW4oJywnKTtcbiAgICB9O1xuICAgIEtleVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLm1vZHVsZU5hbWUgPyBcIkVYOlwiICsgYXN0LnZhbHVlLm1vZHVsZU5hbWUgKyBcIjpcIiArIGFzdC52YWx1ZS5uYW1lIDpcbiAgICAgICAgICAgIFwiRVg6XCIgKyBhc3QudmFsdWUucnVudGltZS5uYW1lO1xuICAgIH07XG4gICAgS2V5VmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBcIlZBUjpcIiArIG5vZGUubmFtZTtcbiAgICB9O1xuICAgIEtleVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZW9mRXhwciA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBcIlRZUEVPRjpcIiArIG5vZGUuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5VmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBpbnZhbGlkKGFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGU6IFZpc2l0b3IgXCIgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiBkb2Vzbid0IGhhbmRsZSBcIiArIGFyZy5jb25zdHJ1Y3Rvci5uYW1lKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGUoZSkge1xuICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZFZhckV4cHI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIElkZW50aWZpZXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElkZW50aWZpZXJzKCkge1xuICAgIH1cbiAgICBJZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0ge1xuICAgICAgICBuYW1lOiAnQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUycsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5FbGVtZW50UmVmID0geyBuYW1lOiAnRWxlbWVudFJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5OZ01vZHVsZVJlZiA9IHsgbmFtZTogJ05nTW9kdWxlUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYgPSB7IG5hbWU6ICdWaWV3Q29udGFpbmVyUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0ge1xuICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuUXVlcnlMaXN0ID0geyBuYW1lOiAnUXVlcnlMaXN0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlRlbXBsYXRlUmVmID0geyBuYW1lOiAnVGVtcGxhdGVSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuUmVuZGVyZXIyID0geyBuYW1lOiAnUmVuZGVyZXIyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSB7XG4gICAgICAgIG5hbWU6ICfJtUNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICBuYW1lOiAnQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkgPSB7IG5hbWU6ICdDb21wb25lbnRGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLkNvbXBvbmVudFJlZiA9IHsgbmFtZTogJ0NvbXBvbmVudFJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkgPSB7IG5hbWU6ICdOZ01vZHVsZUZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuY3JlYXRlTW9kdWxlRmFjdG9yeSA9IHtcbiAgICAgICAgbmFtZTogJ8m1Y21mJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLm1vZHVsZURlZiA9IHtcbiAgICAgICAgbmFtZTogJ8m1bW9kJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLm1vZHVsZVByb3ZpZGVyRGVmID0ge1xuICAgICAgICBuYW1lOiAnybVtcGQnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4gPSB7XG4gICAgICAgIG5hbWU6ICfJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeScsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5pbmplY3QgPSB7IG5hbWU6ICfJtcm1aW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLmRpcmVjdGl2ZUluamVjdCA9IHsgbmFtZTogJ8m1ybVkaXJlY3RpdmVJbmplY3QnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuSU5KRUNUT1IgPSB7IG5hbWU6ICdJTkpFQ1RPUicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5JbmplY3RvciA9IHsgbmFtZTogJ0luamVjdG9yJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlID0geyBuYW1lOiAnybXJtWRlZmluZUluamVjdGFibGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuSW5qZWN0YWJsZURlZiA9IHsgbmFtZTogJ8m1ybVJbmplY3RhYmxlRGVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0ge1xuICAgICAgICBuYW1lOiAnVmlld0VuY2Fwc3VsYXRpb24nLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgICAgIG5hbWU6ICdDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneScsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6ICdTZWN1cml0eUNvbnRleHQnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuTE9DQUxFX0lEID0geyBuYW1lOiAnTE9DQUxFX0lEJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQgPSB7XG4gICAgICAgIG5hbWU6ICdUUkFOU0xBVElPTlNfRk9STUFUJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlID0ge1xuICAgICAgICBuYW1lOiAnybVpbmxpbmVJbnRlcnBvbGF0ZScsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1aW50ZXJwb2xhdGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuRU1QVFlfQVJSQVkgPSB7IG5hbWU6ICfJtUVNUFRZX0FSUkFZJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLkVNUFRZX01BUCA9IHsgbmFtZTogJ8m1RU1QVFlfTUFQJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLlJlbmRlcmVyID0geyBuYW1lOiAnUmVuZGVyZXInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMudmlld0RlZiA9IHsgbmFtZTogJ8m1dmlkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnREZWYgPSB7IG5hbWU6ICfJtWVsZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5hbmNob3JEZWYgPSB7IG5hbWU6ICfJtWFuZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy50ZXh0RGVmID0geyBuYW1lOiAnybV0ZWQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmID0geyBuYW1lOiAnybVkaWQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgSWRlbnRpZmllcnMucHJvdmlkZXJEZWYgPSB7IG5hbWU6ICfJtXByZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5xdWVyeURlZiA9IHsgbmFtZTogJ8m1cXVkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnB1cmVBcnJheURlZiA9IHsgbmFtZTogJ8m1cGFkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnB1cmVPYmplY3REZWYgPSB7IG5hbWU6ICfJtXBvZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5wdXJlUGlwZURlZiA9IHsgbmFtZTogJ8m1cHBkJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGVEZWYgPSB7IG5hbWU6ICfJtXBpZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5ub2RlVmFsdWUgPSB7IG5hbWU6ICfJtW5vdicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy5uZ0NvbnRlbnREZWYgPSB7IG5hbWU6ICfJtW5jZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICBJZGVudGlmaWVycy51bndyYXBWYWx1ZSA9IHsgbmFtZTogJ8m1dW52JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLmNyZWF0ZVJlbmRlcmVyVHlwZTIgPSB7IG5hbWU6ICfJtWNydCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbiAgICAvLyB0eXBlIG9ubHlcbiAgICBJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyID0ge1xuICAgICAgICBuYW1lOiAnUmVuZGVyZXJUeXBlMicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUsXG4gICAgfTtcbiAgICAvLyB0eXBlIG9ubHlcbiAgICBJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiA9IHtcbiAgICAgICAgbmFtZTogJ8m1Vmlld0RlZmluaXRpb24nLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ8m1Y2NmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuICAgIElkZW50aWZpZXJzLnNldENsYXNzTWV0YWRhdGEgPSB7IG5hbWU6ICfJtXNldENsYXNzTWV0YWRhdGEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4gICAgcmV0dXJuIElkZW50aWZpZXJzO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yUmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgIHJldHVybiB7IGlkZW50aWZpZXI6IHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JFeHRlcm5hbFJlZmVyZW5jZShyZWZsZWN0b3IsIHJlZmVyZW5jZSkge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkZvclJlZmVyZW5jZShyZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKHJlZmVyZW5jZSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBhIHJlZmVyZW5jZSB0byBhIHN0YXRpYyB0eXBlLlxuICpcbiAqIFRoaXMgdG9rZW4gaXMgdW5pcXVlIGZvciBhIGZpbGVQYXRoIGFuZCBuYW1lIGFuZCBjYW4gYmUgdXNlZCBhcyBhIGhhc2ggdGFibGUga2V5LlxuICovXG52YXIgU3RhdGljU3ltYm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XG4gICAgfVxuICAgIFN0YXRpY1N5bWJvbC5wcm90b3R5cGUuYXNzZXJ0Tm9NZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogc3ltYm9sIHdpdGhvdXQgbWVtYmVycyBleHBlY3RlZCwgYnV0IGdvdCBcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMpICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljU3ltYm9sO1xufSgpKTtcbi8qKlxuICogQSBjYWNoZSBvZiBzdGF0aWMgc3ltYm9sIHVzZWQgYnkgdGhlIFN0YXRpY1JlZmxlY3RvciB0byByZXR1cm4gdGhlIHNhbWUgc3ltYm9sIGZvciB0aGVcbiAqIHNhbWUgc3ltYm9sIHZhbHVlcy5cbiAqL1xudmFyIFN0YXRpY1N5bWJvbENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY1N5bWJvbENhY2hlKCkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBTdGF0aWNTeW1ib2xDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICBtZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcbiAgICAgICAgdmFyIG1lbWJlclN1ZmZpeCA9IG1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBtZW1iZXJzLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICB2YXIga2V5ID0gXCJcXFwiXCIgKyBkZWNsYXJhdGlvbkZpbGUgKyBcIlxcXCIuXCIgKyBuYW1lICsgbWVtYmVyU3VmZml4O1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTdGF0aWNTeW1ib2woZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbENhY2hlO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gZ3JvdXAgMDogXCJbcHJvcF0gb3IgKGV2ZW50KSBvciBAdHJpZ2dlclwiXG4vLyBncm91cCAxOiBcInByb3BcIiBmcm9tIFwiW3Byb3BdXCJcbi8vIGdyb3VwIDI6IFwiZXZlbnRcIiBmcm9tIFwiKGV2ZW50KVwiXG4vLyBncm91cCAzOiBcIkB0cmlnZ2VyXCIgZnJvbSBcIkB0cmlnZ2VyXCJcbnZhciBIT1NUX1JFR19FWFAgPSAvXig/Oig/OlxcWyhbXlxcXV0rKVxcXSl8KD86XFwoKFteXFwpXSspXFwpKSl8KFxcQFstXFx3XSspJC87XG5mdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xufVxudmFyIF9hbm9ueW1vdXNUeXBlSW5kZXggPSAwO1xuZnVuY3Rpb24gaWRlbnRpZmllck5hbWUoY29tcGlsZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWNvbXBpbGVJZGVudGlmaWVyIHx8ICFjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLm5hbWU7XG4gICAgfVxuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICB2YXIgaWRlbnRpZmllciA9IHN0cmluZ2lmeShyZWYpO1xuICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgIC8vIGNhc2U6IGFub255bW91cyBmdW5jdGlvbnMhXG4gICAgICAgIGlkZW50aWZpZXIgPSBcImFub255bW91c19cIiArIF9hbm9ueW1vdXNUeXBlSW5kZXgrKztcbiAgICAgICAgcmVmWydfX2Fub255bW91c1R5cGUnXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZGVudGlmaWVyID0gc2FuaXRpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlkZW50aWZpZXJNb2R1bGVVcmwoY29tcGlsZUlkZW50aWZpZXIpIHtcbiAgICB2YXIgcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlUGF0aDtcbiAgICB9XG4gICAgLy8gUnVudGltZSB0eXBlXG4gICAgcmV0dXJuIFwiLi9cIiArIHN0cmluZ2lmeShyZWYpO1xufVxuZnVuY3Rpb24gdmlld0NsYXNzTmFtZShjb21wVHlwZSwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgcmV0dXJuIFwiVmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiX1wiICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xufVxuZnVuY3Rpb24gcmVuZGVyZXJUeXBlTmFtZShjb21wVHlwZSkge1xuICAgIHJldHVybiBcIlJlbmRlclR5cGVfXCIgKyBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogY29tcFR5cGUgfSk7XG59XG5mdW5jdGlvbiBob3N0Vmlld0NsYXNzTmFtZShjb21wVHlwZSkge1xuICAgIHJldHVybiBcIkhvc3RWaWV3X1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pO1xufVxuZnVuY3Rpb24gY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcFR5cGUpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGNvbXBUeXBlIH0pICsgXCJOZ0ZhY3RvcnlcIjtcbn1cbnZhciBDb21waWxlU3VtbWFyeUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBpbGVTdW1tYXJ5S2luZCkge1xuICAgIENvbXBpbGVTdW1tYXJ5S2luZFtDb21waWxlU3VtbWFyeUtpbmRbXCJQaXBlXCJdID0gMF0gPSBcIlBpcGVcIjtcbiAgICBDb21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kW1wiRGlyZWN0aXZlXCJdID0gMV0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIENvbXBpbGVTdW1tYXJ5S2luZFtDb21waWxlU3VtbWFyeUtpbmRbXCJOZ01vZHVsZVwiXSA9IDJdID0gXCJOZ01vZHVsZVwiO1xuICAgIENvbXBpbGVTdW1tYXJ5S2luZFtDb21waWxlU3VtbWFyeUtpbmRbXCJJbmplY3RhYmxlXCJdID0gM10gPSBcIkluamVjdGFibGVcIjtcbn0pKENvbXBpbGVTdW1tYXJ5S2luZCB8fCAoQ29tcGlsZVN1bW1hcnlLaW5kID0ge30pKTtcbmZ1bmN0aW9uIHRva2VuTmFtZSh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZSAhPSBudWxsID8gc2FuaXRpemVJZGVudGlmaWVyKHRva2VuLnZhbHVlKSA6IGlkZW50aWZpZXJOYW1lKHRva2VuLmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gdG9rZW5SZWZlcmVuY2UodG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaWRlbnRpZmllciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5pZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICovXG52YXIgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzO1xuICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybCB8fCBudWxsO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IF9ub3JtYWxpemVBcnJheShzdHlsZVVybHMpO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHRlbXBsYXRlLlxuICovXG52YXIgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIGVuY2Fwc3VsYXRpb24gPSBfYS5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9hLnRlbXBsYXRlVXJsLCBodG1sQXN0ID0gX2EuaHRtbEFzdCwgc3R5bGVzID0gX2Euc3R5bGVzLCBzdHlsZVVybHMgPSBfYS5zdHlsZVVybHMsIGV4dGVybmFsU3R5bGVzaGVldHMgPSBfYS5leHRlcm5hbFN0eWxlc2hlZXRzLCBhbmltYXRpb25zID0gX2EuYW5pbWF0aW9ucywgbmdDb250ZW50U2VsZWN0b3JzID0gX2EubmdDb250ZW50U2VsZWN0b3JzLCBpbnRlcnBvbGF0aW9uID0gX2EuaW50ZXJwb2xhdGlvbiwgaXNJbmxpbmUgPSBfYS5pc0lubGluZSwgcHJlc2VydmVXaGl0ZXNwYWNlcyA9IF9hLnByZXNlcnZlV2hpdGVzcGFjZXM7XG4gICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICB0aGlzLmh0bWxBc3QgPSBodG1sQXN0O1xuICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IF9ub3JtYWxpemVBcnJheShzdHlsZVVybHMpO1xuICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBfbm9ybWFsaXplQXJyYXkoZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMgPyBmbGF0dGVuKGFuaW1hdGlvbnMpIDogW107XG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gbmdDb250ZW50U2VsZWN0b3JzIHx8IFtdO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbiAmJiBpbnRlcnBvbGF0aW9uLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaW50ZXJwb2xhdGlvbicgc2hvdWxkIGhhdmUgYSBzdGFydCBhbmQgYW4gZW5kIHN5bWJvbC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgdGhpcy5pc0lubGluZSA9IGlzSW5saW5lO1xuICAgICAgICB0aGlzLnByZXNlcnZlV2hpdGVzcGFjZXMgPSBwcmVzZXJ2ZVdoaXRlc3BhY2VzO1xuICAgIH1cbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IHRoaXMuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiB0aGlzLmFuaW1hdGlvbnNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlVGVtcGxhdGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIGRpcmVjdGl2ZS5cbiAqL1xudmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIGlzSG9zdCA9IF9hLmlzSG9zdCwgdHlwZSA9IF9hLnR5cGUsIGlzQ29tcG9uZW50ID0gX2EuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Euc2VsZWN0b3IsIGV4cG9ydEFzID0gX2EuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9hLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2EuaW5wdXRzLCBvdXRwdXRzID0gX2Eub3V0cHV0cywgaG9zdExpc3RlbmVycyA9IF9hLmhvc3RMaXN0ZW5lcnMsIGhvc3RQcm9wZXJ0aWVzID0gX2EuaG9zdFByb3BlcnRpZXMsIGhvc3RBdHRyaWJ1dGVzID0gX2EuaG9zdEF0dHJpYnV0ZXMsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9hLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYS5xdWVyaWVzLCBndWFyZHMgPSBfYS5ndWFyZHMsIHZpZXdRdWVyaWVzID0gX2Eudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9hLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYS5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2EucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2EuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdQcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgIHRoaXMuZ3VhcmRzID0gZ3VhcmRzO1xuICAgICAgICB0aGlzLnZpZXdRdWVyaWVzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdRdWVyaWVzKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFZpZXdUeXBlID0gY29tcG9uZW50Vmlld1R5cGU7XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlID0gcmVuZGVyZXJUeXBlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnkgPSBjb21wb25lbnRGYWN0b3J5O1xuICAgIH1cbiAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBpc0hvc3QgPSBfYS5pc0hvc3QsIHR5cGUgPSBfYS50eXBlLCBpc0NvbXBvbmVudCA9IF9hLmlzQ29tcG9uZW50LCBzZWxlY3RvciA9IF9hLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYS5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9hLmlucHV0cywgb3V0cHV0cyA9IF9hLm91dHB1dHMsIGhvc3QgPSBfYS5ob3N0LCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnMsIHZpZXdQcm92aWRlcnMgPSBfYS52aWV3UHJvdmlkZXJzLCBxdWVyaWVzID0gX2EucXVlcmllcywgZ3VhcmRzID0gX2EuZ3VhcmRzLCB2aWV3UXVlcmllcyA9IF9hLnZpZXdRdWVyaWVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYS5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlID0gX2EudGVtcGxhdGUsIGNvbXBvbmVudFZpZXdUeXBlID0gX2EuY29tcG9uZW50Vmlld1R5cGUsIHJlbmRlcmVyVHlwZSA9IF9hLnJlbmRlcmVyVHlwZSwgY29tcG9uZW50RmFjdG9yeSA9IF9hLmNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgIHZhciBob3N0TGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciBob3N0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgaG9zdEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgaWYgKGhvc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaG9zdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnNbbWF0Y2hlc1syXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRzTWFwID0ge307XG4gICAgICAgIGlmIChpbnB1dHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICBpbnB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICBpZiAob3V0cHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdEF0Q29sb24oYmluZENvbmZpZywgW2JpbmRDb25maWcsIGJpbmRDb25maWddKTtcbiAgICAgICAgICAgICAgICBvdXRwdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgaXNIb3N0OiBpc0hvc3QsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6ICEhaXNDb21wb25lbnQsXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogZXhwb3J0QXMsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgIGlucHV0czogaW5wdXRzTWFwLFxuICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0c01hcCxcbiAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICBob3N0UHJvcGVydGllczogaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogaG9zdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiBxdWVyaWVzLFxuICAgICAgICAgICAgZ3VhcmRzOiBndWFyZHMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBjb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogcmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6IHRoaXMuaXNDb21wb25lbnQsXG4gICAgICAgICAgICBzZWxlY3RvcjogdGhpcy5zZWxlY3RvcixcbiAgICAgICAgICAgIGV4cG9ydEFzOiB0aGlzLmV4cG9ydEFzLFxuICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cyxcbiAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IHRoaXMuaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiB0aGlzLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IHRoaXMuaG9zdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHRoaXMucHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdGhpcy52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgcXVlcmllczogdGhpcy5xdWVyaWVzLFxuICAgICAgICAgICAgZ3VhcmRzOiB0aGlzLmd1YXJkcyxcbiAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB0aGlzLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiB0aGlzLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogdGhpcy5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSAmJiB0aGlzLnRlbXBsYXRlLnRvU3VtbWFyeSgpLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IHRoaXMuY29tcG9uZW50Vmlld1R5cGUsXG4gICAgICAgICAgICByZW5kZXJlclR5cGU6IHRoaXMucmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogdGhpcy5jb21wb25lbnRGYWN0b3J5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xufSgpKTtcbnZhciBDb21waWxlUGlwZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVQaXBlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBuYW1lID0gX2EubmFtZSwgcHVyZSA9IF9hLnB1cmU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHVyZSA9ICEhcHVyZTtcbiAgICB9XG4gICAgQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcHVyZTogdGhpcy5wdXJlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVBpcGVNZXRhZGF0YTtcbn0oKSk7XG52YXIgQ29tcGlsZVNoYWxsb3dNb2R1bGVNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlU2hhbGxvd01vZHVsZU1ldGFkYXRhKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZVNoYWxsb3dNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIG1vZHVsZS5cbiAqL1xudmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgcHJvdmlkZXJzID0gX2EucHJvdmlkZXJzLCBkZWNsYXJlZERpcmVjdGl2ZXMgPSBfYS5kZWNsYXJlZERpcmVjdGl2ZXMsIGV4cG9ydGVkRGlyZWN0aXZlcyA9IF9hLmV4cG9ydGVkRGlyZWN0aXZlcywgZGVjbGFyZWRQaXBlcyA9IF9hLmRlY2xhcmVkUGlwZXMsIGV4cG9ydGVkUGlwZXMgPSBfYS5leHBvcnRlZFBpcGVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYS5lbnRyeUNvbXBvbmVudHMsIGJvb3RzdHJhcENvbXBvbmVudHMgPSBfYS5ib290c3RyYXBDb21wb25lbnRzLCBpbXBvcnRlZE1vZHVsZXMgPSBfYS5pbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcyA9IF9hLmV4cG9ydGVkTW9kdWxlcywgc2NoZW1hcyA9IF9hLnNjaGVtYXMsIHRyYW5zaXRpdmVNb2R1bGUgPSBfYS50cmFuc2l0aXZlTW9kdWxlLCBpZCA9IF9hLmlkO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGVjbGFyZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkRGlyZWN0aXZlcyk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkRGlyZWN0aXZlcyk7XG4gICAgICAgIHRoaXMuZGVjbGFyZWRQaXBlcyA9IF9ub3JtYWxpemVBcnJheShkZWNsYXJlZFBpcGVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkUGlwZXMpO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLmJvb3RzdHJhcENvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoYm9vdHN0cmFwQ29tcG9uZW50cyk7XG4gICAgICAgIHRoaXMuaW1wb3J0ZWRNb2R1bGVzID0gX25vcm1hbGl6ZUFycmF5KGltcG9ydGVkTW9kdWxlcyk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRNb2R1bGVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkTW9kdWxlcyk7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IF9ub3JtYWxpemVBcnJheShzY2hlbWFzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkIHx8IG51bGw7XG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGUgfHwgbnVsbDtcbiAgICB9XG4gICAgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IHRoaXMudHJhbnNpdGl2ZU1vZHVsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IG1vZHVsZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IG1vZHVsZS5wcm92aWRlcnMsXG4gICAgICAgICAgICBtb2R1bGVzOiBtb2R1bGUubW9kdWxlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogbW9kdWxlLmV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IG1vZHVsZS5leHBvcnRlZFBpcGVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG59KCkpO1xudmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLnBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnBpcGVzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzID0gW107XG4gICAgICAgIHRoaXMubW9kdWxlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IFtdO1xuICAgIH1cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaCh7IHByb3ZpZGVyOiBwcm92aWRlciwgbW9kdWxlOiBtb2R1bGUgfSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aXZlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMucGlwZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGlwZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhwb3J0ZWRQaXBlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kdWxlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEVudHJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGVjKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKGVjLmNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoZWMuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKGVjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG5mdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiB8fCBbXTtcbn1cbnZhciBQcm92aWRlck1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJNZXRhKHRva2VuLCBfYSkge1xuICAgICAgICB2YXIgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMudXNlQ2xhc3MgPSB1c2VDbGFzcyB8fCBudWxsO1xuICAgICAgICB0aGlzLnVzZVZhbHVlID0gdXNlVmFsdWU7XG4gICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgdGhpcy51c2VGYWN0b3J5ID0gdXNlRmFjdG9yeSB8fCBudWxsO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5tdWx0aSA9ICEhbXVsdGk7XG4gICAgfVxuICAgIHJldHVybiBQcm92aWRlck1ldGE7XG59KCkpO1xuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgIHZhciBmbGF0SXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBmbGF0dGVuKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBqaXRTb3VyY2VVcmwodXJsKSB7XG4gICAgLy8gTm90ZTogV2UgbmVlZCAzIFwiL1wiIHNvIHRoYXQgbmcgc2hvd3MgdXAgYXMgYSBzZXBhcmF0ZSBkb21haW5cbiAgICAvLyBpbiB0aGUgY2hyb21lIGRldiB0b29scy5cbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXHcrOlxcL1xcL1tcXHc6LV0rKT8oXFwvKyk/LywgJ25nOi8vLycpO1xufVxuZnVuY3Rpb24gdGVtcGxhdGVTb3VyY2VVcmwobmdNb2R1bGVUeXBlLCBjb21wTWV0YSwgdGVtcGxhdGVNZXRhKSB7XG4gICAgdmFyIHVybDtcbiAgICBpZiAodGVtcGxhdGVNZXRhLmlzSW5saW5lKSB7XG4gICAgICAgIGlmIChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgLy8gTm90ZTogYSAudHMgZmlsZSBtaWdodCBjb250YWluIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCBpbmxpbmUgdGVtcGxhdGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnaXZlIHRoZW0gdW5pcXVlIHVybHMsIGFzIHRoZXNlIHdpbGwgYmUgdXNlZCBmb3Igc291cmNlbWFwcy5cbiAgICAgICAgICAgIHVybCA9IGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoICsgXCIuXCIgKyBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5uYW1lICsgXCIuaHRtbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5odG1sXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sID8gdXJsIDogaml0U291cmNlVXJsKHVybCk7XG59XG5mdW5jdGlvbiBzaGFyZWRTdHlsZXNoZWV0Sml0VXJsKG1ldGEsIGlkKSB7XG4gICAgdmFyIHBhdGhQYXJ0cyA9IG1ldGEubW9kdWxlVXJsLnNwbGl0KC9cXC9cXFxcL2cpO1xuICAgIHZhciBiYXNlTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGppdFNvdXJjZVVybChcImNzcy9cIiArIGlkICsgYmFzZU5hbWUgKyBcIi5uZ3N0eWxlLmpzXCIpO1xufVxuZnVuY3Rpb24gbmdNb2R1bGVKaXRVcmwobW9kdWxlTWV0YSkge1xuICAgIHJldHVybiBqaXRTb3VyY2VVcmwoaWRlbnRpZmllck5hbWUobW9kdWxlTWV0YS50eXBlKSArIFwiL21vZHVsZS5uZ2ZhY3RvcnkuanNcIik7XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZUppdFVybChuZ01vZHVsZVR5cGUsIGNvbXBNZXRhKSB7XG4gICAgcmV0dXJuIGppdFNvdXJjZVVybChpZGVudGlmaWVyTmFtZShuZ01vZHVsZVR5cGUpICsgXCIvXCIgKyBpZGVudGlmaWVyTmFtZShjb21wTWV0YS50eXBlKSArIFwiLm5nZmFjdG9yeS5qc1wiKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENPUkUkMSA9ICdAYW5ndWxhci9jb3JlJztcbnZhciBJZGVudGlmaWVycyQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElkZW50aWZpZXJzKCkge1xuICAgIH1cbiAgICAvKiBNZXRob2RzICovXG4gICAgSWRlbnRpZmllcnMuTkVXX01FVEhPRCA9ICdmYWN0b3J5JztcbiAgICBJZGVudGlmaWVycy5UUkFOU0ZPUk1fTUVUSE9EID0gJ3RyYW5zZm9ybSc7XG4gICAgSWRlbnRpZmllcnMuUEFUQ0hfREVQUyA9ICdwYXRjaGVkRGVwcyc7XG4gICAgLyogSW5zdHJ1Y3Rpb25zICovXG4gICAgSWRlbnRpZmllcnMubmFtZXNwYWNlSFRNTCA9IHsgbmFtZTogJ8m1ybVuYW1lc3BhY2VIVE1MJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubmFtZXNwYWNlTWF0aE1MID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZU1hdGhNTCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLm5hbWVzcGFjZVNWRyA9IHsgbmFtZTogJ8m1ybVuYW1lc3BhY2VTVkcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5lbGVtZW50ID0geyBuYW1lOiAnybXJtWVsZW1lbnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5lbGVtZW50U3RhcnQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudFN0YXJ0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZWxlbWVudEVuZCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50RW5kJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc2VsZWN0ID0geyBuYW1lOiAnybXJtXNlbGVjdCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmFkdmFuY2UgPSB7IG5hbWU6ICfJtcm1YWR2YW5jZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnVwZGF0ZVN5bnRoZXRpY0hvc3RCaW5kaW5nID0geyBuYW1lOiAnybXJtXVwZGF0ZVN5bnRoZXRpY0hvc3RCaW5kaW5nJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY29tcG9uZW50SG9zdFN5bnRoZXRpY0xpc3RlbmVyID0geyBuYW1lOiAnybXJtWNvbXBvbmVudEhvc3RTeW50aGV0aWNMaXN0ZW5lcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZSA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc1Byb3AgPSB7IG5hbWU6ICfJtcm1Y2xhc3NQcm9wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lclN0YXJ0ID0geyBuYW1lOiAnybXJtWVsZW1lbnRDb250YWluZXJTdGFydCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJFbmQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lckVuZCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXIgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlTWFwID0geyBuYW1lOiAnybXJtXN0eWxlTWFwJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXAgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXAnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3AgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubmV4dENvbnRleHQgPSB7IG5hbWU6ICfJtcm1bmV4dENvbnRleHQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy50ZW1wbGF0ZUNyZWF0ZSA9IHsgbmFtZTogJ8m1ybV0ZW1wbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHQgPSB7IG5hbWU6ICfJtcm1dGV4dCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmVuYWJsZUJpbmRpbmdzID0geyBuYW1lOiAnybXJtWVuYWJsZUJpbmRpbmdzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZGlzYWJsZUJpbmRpbmdzID0geyBuYW1lOiAnybXJtWRpc2FibGVCaW5kaW5ncycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmdldEN1cnJlbnRWaWV3ID0geyBuYW1lOiAnybXJtWdldEN1cnJlbnRWaWV3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnJlc3RvcmVWaWV3ID0geyBuYW1lOiAnybXJtXJlc3RvcmVWaWV3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMCA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMSA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24xJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMiA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24yJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMyA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24zJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNCA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb240JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNSA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb241JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNiA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb242JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNyA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb243JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uOCA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb244JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uViA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb25WJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucGlwZUJpbmQxID0geyBuYW1lOiAnybXJtXBpcGVCaW5kMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGVCaW5kMiA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5waXBlQmluZDMgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucGlwZUJpbmQ0ID0geyBuYW1lOiAnybXJtXBpcGVCaW5kNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGVCaW5kViA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZFYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5ob3N0UHJvcGVydHkgPSB7IG5hbWU6ICfJtcm1aG9zdFByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHkgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pMThuID0geyBuYW1lOiAnybXJtWkxOG4nLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pMThuQXR0cmlidXRlcyA9IHsgbmFtZTogJ8m1ybVpMThuQXR0cmlidXRlcycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG5FeHAgPSB7IG5hbWU6ICfJtcm1aTE4bkV4cCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmkxOG5TdGFydCA9IHsgbmFtZTogJ8m1ybVpMThuU3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pMThuRW5kID0geyBuYW1lOiAnybXJtWkxOG5FbmQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pMThuQXBwbHkgPSB7IG5hbWU6ICfJtcm1aTE4bkFwcGx5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaTE4blBvc3Rwcm9jZXNzID0geyBuYW1lOiAnybXJtWkxOG5Qb3N0cHJvY2VzcycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnBpcGUgPSB7IG5hbWU6ICfJtcm1cGlwZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb2plY3Rpb24gPSB7IG5hbWU6ICfJtcm1cHJvamVjdGlvbicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnByb2plY3Rpb25EZWYgPSB7IG5hbWU6ICfJtcm1cHJvamVjdGlvbkRlZicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnJlZmVyZW5jZSA9IHsgbmFtZTogJ8m1ybVyZWZlcmVuY2UnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pbmplY3QgPSB7IG5hbWU6ICfJtcm1aW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaW5qZWN0QXR0cmlidXRlID0geyBuYW1lOiAnybXJtWluamVjdEF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmluamVjdFBpcGVDaGFuZ2VEZXRlY3RvclJlZiA9IHsgbmFtZTogJ8m1ybVpbmplY3RQaXBlQ2hhbmdlRGV0ZWN0b3JSZWYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kaXJlY3RpdmVJbmplY3QgPSB7IG5hbWU6ICfJtcm1ZGlyZWN0aXZlSW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuaW52YWxpZEZhY3RvcnkgPSB7IG5hbWU6ICfJtcm1aW52YWxpZEZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5pbnZhbGlkRmFjdG9yeURlcCA9IHsgbmFtZTogJ8m1ybVpbnZhbGlkRmFjdG9yeURlcCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnRlbXBsYXRlUmVmRXh0cmFjdG9yID0geyBuYW1lOiAnybXJtXRlbXBsYXRlUmVmRXh0cmFjdG9yJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucmVzb2x2ZVdpbmRvdyA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlV2luZG93JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMucmVzb2x2ZURvY3VtZW50ID0geyBuYW1lOiAnybXJtXJlc29sdmVEb2N1bWVudCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnJlc29sdmVCb2R5ID0geyBuYW1lOiAnybXJtXJlc29sdmVCb2R5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZGVmaW5lQ29tcG9uZW50ID0geyBuYW1lOiAnybXJtWRlZmluZUNvbXBvbmVudCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNldENvbXBvbmVudFNjb3BlID0geyBuYW1lOiAnybXJtXNldENvbXBvbmVudFNjb3BlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuQ29tcG9uZW50RGVmV2l0aE1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICfJtcm1Q29tcG9uZW50RGVmV2l0aE1ldGEnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5GYWN0b3J5RGVmID0ge1xuICAgICAgICBuYW1lOiAnybXJtUZhY3RvcnlEZWYnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVEaXJlY3RpdmUgPSB7XG4gICAgICAgIG5hbWU6ICfJtcm1ZGVmaW5lRGlyZWN0aXZlJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuRGlyZWN0aXZlRGVmV2l0aE1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICfJtcm1RGlyZWN0aXZlRGVmV2l0aE1ldGEnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5JbmplY3RvckRlZiA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVJbmplY3RvckRlZicsXG4gICAgICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbiAgICB9O1xuICAgIElkZW50aWZpZXJzLmRlZmluZUluamVjdG9yID0ge1xuICAgICAgICBuYW1lOiAnybXJtWRlZmluZUluamVjdG9yJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuTmdNb2R1bGVEZWZXaXRoTWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVOZ01vZHVsZURlZldpdGhNZXRhJyxcbiAgICAgICAgbW9kdWxlTmFtZTogQ09SRSQxLFxuICAgIH07XG4gICAgSWRlbnRpZmllcnMuTW9kdWxlV2l0aFByb3ZpZGVycyA9IHtcbiAgICAgICAgbmFtZTogJ01vZHVsZVdpdGhQcm92aWRlcnMnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVOZ01vZHVsZSA9IHsgbmFtZTogJ8m1ybVkZWZpbmVOZ01vZHVsZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNldE5nTW9kdWxlU2NvcGUgPSB7IG5hbWU6ICfJtcm1c2V0TmdNb2R1bGVTY29wZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLlBpcGVEZWZXaXRoTWV0YSA9IHsgbmFtZTogJ8m1ybVQaXBlRGVmV2l0aE1ldGEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5kZWZpbmVQaXBlID0geyBuYW1lOiAnybXJtWRlZmluZVBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5xdWVyeVJlZnJlc2ggPSB7IG5hbWU6ICfJtcm1cXVlcnlSZWZyZXNoJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMudmlld1F1ZXJ5ID0geyBuYW1lOiAnybXJtXZpZXdRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnN0YXRpY1ZpZXdRdWVyeSA9IHsgbmFtZTogJ8m1ybVzdGF0aWNWaWV3UXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zdGF0aWNDb250ZW50UXVlcnkgPSB7IG5hbWU6ICfJtcm1c3RhdGljQ29udGVudFF1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMubG9hZFF1ZXJ5ID0geyBuYW1lOiAnybXJtWxvYWRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmNvbnRlbnRRdWVyeSA9IHsgbmFtZTogJ8m1ybVjb250ZW50UXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5OZ09uQ2hhbmdlc0ZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1TmdPbkNoYW5nZXNGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuSW5oZXJpdERlZmluaXRpb25GZWF0dXJlID0geyBuYW1lOiAnybXJtUluaGVyaXREZWZpbml0aW9uRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLkNvcHlEZWZpbml0aW9uRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVDb3B5RGVmaW5pdGlvbkZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5Qcm92aWRlcnNGZWF0dXJlID0geyBuYW1lOiAnybXJtVByb3ZpZGVyc0ZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5saXN0ZW5lciA9IHsgbmFtZTogJ8m1ybVsaXN0ZW5lcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLmdldEZhY3RvcnlPZiA9IHtcbiAgICAgICAgbmFtZTogJ8m1ybVnZXRGYWN0b3J5T2YnLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICBJZGVudGlmaWVycy5nZXRJbmhlcml0ZWRGYWN0b3J5ID0ge1xuICAgICAgICBuYW1lOiAnybXJtWdldEluaGVyaXRlZEZhY3RvcnknLFxuICAgICAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG4gICAgfTtcbiAgICAvLyBzYW5pdGl6YXRpb24tcmVsYXRlZCBmdW5jdGlvbnNcbiAgICBJZGVudGlmaWVycy5zYW5pdGl6ZUh0bWwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVIdG1sJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc2FuaXRpemVTdHlsZSA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVN0eWxlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuZGVmYXVsdFN0eWxlU2FuaXRpemVyID0geyBuYW1lOiAnybXJtWRlZmF1bHRTdHlsZVNhbml0aXplcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNhbml0aXplUmVzb3VyY2VVcmwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVSZXNvdXJjZVVybCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuICAgIElkZW50aWZpZXJzLnNhbml0aXplU2NyaXB0ID0geyBuYW1lOiAnybXJtXNhbml0aXplU2NyaXB0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgSWRlbnRpZmllcnMuc2FuaXRpemVVcmwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVVcmwnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbiAgICBJZGVudGlmaWVycy5zYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVVcmxPclJlc291cmNlVXJsJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG4gICAgcmV0dXJuIElkZW50aWZpZXJzO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBtYXAgd2l0aCBgRXhwcmVzc2lvbmAgdmFsdWVzIGludG8gYSBgTGl0ZXJhbE1hcEV4cHJgLlxuICovXG5mdW5jdGlvbiBtYXBUb01hcEV4cHJlc3Npb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICAvLyBUaGUgYXNzZXJ0aW9uIGhlcmUgaXMgYmVjYXVzZSByZWFsbHkgVHlwZVNjcmlwdCBkb2Vzbid0IGFsbG93IHVzIHRvIGV4cHJlc3MgdGhhdCBpZiB0aGVcbiAgICAgICAgLy8ga2V5IGlzIHByZXNlbnQsIGl0IHdpbGwgaGF2ZSBhIHZhbHVlLCBidXQgdGhpcyBpcyB0cnVlIGluIHJlYWxpdHkuXG4gICAgICAgIHZhbHVlOiBtYXBba2V5XSxcbiAgICAgICAgcXVvdGVkOiBmYWxzZSxcbiAgICB9KTsgfSk7XG4gICAgcmV0dXJuIGxpdGVyYWxNYXAocmVzdWx0KTtcbn1cbi8qKlxuICogQ29udmVydCBtZXRhZGF0YSBpbnRvIGFuIGBFeHByZXNzaW9uYCBpbiB0aGUgZ2l2ZW4gYE91dHB1dENvbnRleHRgLlxuICpcbiAqIFRoaXMgb3BlcmF0aW9uIHdpbGwgaGFuZGxlIGFycmF5cywgcmVmZXJlbmNlcyB0byBzeW1ib2xzLCBvciBsaXRlcmFsIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gY29udmVydE1ldGFUb091dHB1dChtZXRhLCBjdHgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhKSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihtZXRhLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGNvbnZlcnRNZXRhVG9PdXRwdXQoZW50cnksIGN0eCk7IH0pKTtcbiAgICB9XG4gICAgaWYgKG1ldGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5pbXBvcnRFeHByKG1ldGEpO1xuICAgIH1cbiAgICBpZiAobWV0YSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKG1ldGEpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogVW5zdXBwb3J0ZWQgb3IgdW5rbm93biBtZXRhZGF0YTogXCIgKyBtZXRhKTtcbn1cbmZ1bmN0aW9uIHR5cGVXaXRoUGFyYW1ldGVycyh0eXBlLCBudW1QYXJhbXMpIHtcbiAgICB2YXIgcGFyYW1zID0gbnVsbDtcbiAgICBpZiAobnVtUGFyYW1zID4gMCkge1xuICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1QYXJhbXM7IGkrKykge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUodHlwZSwgbnVsbCwgcGFyYW1zKTtcbn1cbnZhciBBTklNQVRFX1NZTUJPTF9QUkVGSVggPSAnQCc7XG5mdW5jdGlvbiBwcmVwYXJlU3ludGhldGljUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gXCJcIiArIEFOSU1BVEVfU1lNQk9MX1BSRUZJWCArIG5hbWU7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBBTklNQVRFX1NZTUJPTF9QUkVGSVggKyBuYW1lICsgXCIuXCIgKyBwaGFzZTtcbn1cbmZ1bmN0aW9uIGlzU3ludGhldGljUHJvcGVydHlPckxpc3RlbmVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFURV9TWU1CT0xfUFJFRklYO1xufVxuZnVuY3Rpb24gZ2V0U3ludGhldGljUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgICAvLyB0aGlzIHdpbGwgc3RyaXAgb3V0IGxpc3RlbmVyIHBoYXNlIHZhbHVlcy4uLlxuICAgIC8vIEBmb28uc3RhcnQgPT4gQGZvb1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKCcuJyk7XG4gICAgbmFtZSA9IGkgPiAwID8gbmFtZS5zdWJzdHJpbmcoMCwgaSkgOiBuYW1lO1xuICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gQU5JTUFURV9TWU1CT0xfUFJFRklYKSB7XG4gICAgICAgIG5hbWUgPSBBTklNQVRFX1NZTUJPTF9QUkVGSVggKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lckZ1bmN0aW9uTmFtZShuYW1lLCBwaGFzZSkge1xuICAgIHJldHVybiBcImFuaW1hdGlvbl9cIiArIG5hbWUgKyBcIl9cIiArIHBoYXNlO1xufVxuZnVuY3Rpb24gaml0T25seUd1YXJkZWRFeHByZXNzaW9uKGV4cHIpIHtcbiAgICB2YXIgbmdKaXRNb2RlID0gbmV3IEV4dGVybmFsRXhwcih7IG5hbWU6ICduZ0ppdE1vZGUnLCBtb2R1bGVOYW1lOiBudWxsIH0pO1xuICAgIHZhciBqaXRGbGFnTm90RGVmaW5lZCA9IG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCBuZXcgVHlwZW9mRXhwcihuZ0ppdE1vZGUpLCBsaXRlcmFsKCd1bmRlZmluZWQnKSk7XG4gICAgdmFyIGppdEZsYWdVbmRlZmluZWRPclRydWUgPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk9yLCBqaXRGbGFnTm90RGVmaW5lZCwgbmdKaXRNb2RlLCAvKiB0eXBlICovIHVuZGVmaW5lZCwgXG4gICAgLyogc291cmNlU3BhbiAqLyB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkFuZCwgaml0RmxhZ1VuZGVmaW5lZE9yVHJ1ZSwgZXhwcik7XG59XG5mdW5jdGlvbiB3cmFwUmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgdmFyIHdyYXBwZWQgPSBuZXcgV3JhcHBlZE5vZGVFeHByKHZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZTogd3JhcHBlZCwgdHlwZTogd3JhcHBlZCB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgJEVPRiA9IDA7XG52YXIgJEJTUEFDRSA9IDg7XG52YXIgJFRBQiA9IDk7XG52YXIgJExGID0gMTA7XG52YXIgJFZUQUIgPSAxMTtcbnZhciAkRkYgPSAxMjtcbnZhciAkQ1IgPSAxMztcbnZhciAkU1BBQ0UgPSAzMjtcbnZhciAkQkFORyA9IDMzO1xudmFyICREUSA9IDM0O1xudmFyICRIQVNIID0gMzU7XG52YXIgJCQgPSAzNjtcbnZhciAkUEVSQ0VOVCA9IDM3O1xudmFyICRBTVBFUlNBTkQgPSAzODtcbnZhciAkU1EgPSAzOTtcbnZhciAkTFBBUkVOID0gNDA7XG52YXIgJFJQQVJFTiA9IDQxO1xudmFyICRTVEFSID0gNDI7XG52YXIgJFBMVVMgPSA0MztcbnZhciAkQ09NTUEgPSA0NDtcbnZhciAkTUlOVVMgPSA0NTtcbnZhciAkUEVSSU9EID0gNDY7XG52YXIgJFNMQVNIID0gNDc7XG52YXIgJENPTE9OID0gNTg7XG52YXIgJFNFTUlDT0xPTiA9IDU5O1xudmFyICRMVCA9IDYwO1xudmFyICRFUSA9IDYxO1xudmFyICRHVCA9IDYyO1xudmFyICRRVUVTVElPTiA9IDYzO1xudmFyICQwID0gNDg7XG52YXIgJDcgPSA1NTtcbnZhciAkOSA9IDU3O1xudmFyICRBID0gNjU7XG52YXIgJEUgPSA2OTtcbnZhciAkRiA9IDcwO1xudmFyICRYID0gODg7XG52YXIgJFogPSA5MDtcbnZhciAkTEJSQUNLRVQgPSA5MTtcbnZhciAkQkFDS1NMQVNIID0gOTI7XG52YXIgJFJCUkFDS0VUID0gOTM7XG52YXIgJENBUkVUID0gOTQ7XG52YXIgJF8gPSA5NTtcbnZhciAkYSA9IDk3O1xudmFyICRiID0gOTg7XG52YXIgJGUgPSAxMDE7XG52YXIgJGYgPSAxMDI7XG52YXIgJG4gPSAxMTA7XG52YXIgJHIgPSAxMTQ7XG52YXIgJHQgPSAxMTY7XG52YXIgJHUgPSAxMTc7XG52YXIgJHYgPSAxMTg7XG52YXIgJHggPSAxMjA7XG52YXIgJHogPSAxMjI7XG52YXIgJExCUkFDRSA9IDEyMztcbnZhciAkQkFSID0gMTI0O1xudmFyICRSQlJBQ0UgPSAxMjU7XG52YXIgJE5CU1AgPSAxNjA7XG52YXIgJFBJUEUgPSAxMjQ7XG52YXIgJFRJTERBID0gMTI2O1xudmFyICRBVCA9IDY0O1xudmFyICRCVCA9IDk2O1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gJFRBQiAmJiBjb2RlIDw9ICRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xufVxuZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBpc0RpZ2l0KGNvZGUpO1xufVxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJExGIHx8IGNvZGUgPT09ICRDUjtcbn1cbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkNztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFBhcnNlTG9jYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VMb2NhdGlvbihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQgIT0gbnVsbCA/IHRoaXMuZmlsZS51cmwgKyBcIkBcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2wgOiB0aGlzLmZpbGUudXJsO1xuICAgIH07XG4gICAgUGFyc2VMb2NhdGlvbi5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA+IDAgJiYgZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGRlbHRhKys7XG4gICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUtLTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpb3JMaW5lID0gc291cmNlLnN1YnN0cigwLCBvZmZzZXQgLSAxKS5sYXN0SW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKCRMRikpO1xuICAgICAgICAgICAgICAgIGNvbCA9IHByaW9yTGluZSA+IDAgPyBvZmZzZXQgLSBwcmlvckxpbmUgOiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLmZpbGUsIG9mZnNldCwgbGluZSwgY29sKTtcbiAgICB9O1xuICAgIC8vIFJldHVybiB0aGUgc291cmNlIGFyb3VuZCB0aGUgbG9jYXRpb25cbiAgICAvLyBVcCB0byBgbWF4Q2hhcnNgIG9yIGBtYXhMaW5lc2Agb24gZWFjaCBzaWRlIG9mIHRoZSBsb2NhdGlvblxuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAobWF4Q2hhcnMsIG1heExpbmVzKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5maWxlLmNvbnRlbnQ7XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoc3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID4gY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBjb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgY3R4Q2hhcnMgPSAwO1xuICAgICAgICAgICAgdmFyIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIHN0YXJ0T2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgY3R4Q2hhcnMrKztcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFtzdGFydE9mZnNldF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4Q2hhcnMgPSAwO1xuICAgICAgICAgICAgY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN0eENoYXJzIDwgbWF4Q2hhcnMgJiYgZW5kT2Zmc2V0IDwgY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgY3R4Q2hhcnMrKztcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFtlbmRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBjb250ZW50LnN1YnN0cmluZyhzdGFydE9mZnNldCwgdGhpcy5vZmZzZXQpLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBjb250ZW50LnN1YnN0cmluZyh0aGlzLm9mZnNldCwgZW5kT2Zmc2V0ICsgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlTG9jYXRpb247XG59KCkpO1xudmFyIFBhcnNlU291cmNlRmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVNvdXJjZUZpbGUoY29udGVudCwgdXJsKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VTb3VyY2VGaWxlO1xufSgpKTtcbnZhciBQYXJzZVNvdXJjZVNwYW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICBQYXJzZVNvdXJjZVNwYW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlU291cmNlU3Bhbjtcbn0oKSk7XG52YXIgUGFyc2VFcnJvckxldmVsO1xuKGZ1bmN0aW9uIChQYXJzZUVycm9yTGV2ZWwpIHtcbiAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG59KShQYXJzZUVycm9yTGV2ZWwgfHwgKFBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG52YXIgUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHNwYW4sIG1zZywgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1I7IH1cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUuY29udGV4dHVhbE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsIDMpO1xuICAgICAgICByZXR1cm4gY3R4ID8gdGhpcy5tc2cgKyBcIiAoXFxcIlwiICsgY3R4LmJlZm9yZSArIFwiW1wiICsgUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdICsgXCIgLT5dXCIgKyBjdHguYWZ0ZXIgKyBcIlxcXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5tc2c7XG4gICAgfTtcbiAgICBQYXJzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSB0aGlzLnNwYW4uZGV0YWlscyA/IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzIDogJyc7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCkgKyBcIjogXCIgKyB0aGlzLnNwYW4uc3RhcnQgKyBkZXRhaWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuZnVuY3Rpb24gdHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZSkge1xuICAgIHZhciBtb2R1bGVVcmwgPSBpZGVudGlmaWVyTW9kdWxlVXJsKHR5cGUpO1xuICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IG1vZHVsZVVybCAhPSBudWxsID8gXCJpbiBcIiArIGtpbmQgKyBcIiBcIiArIGlkZW50aWZpZXJOYW1lKHR5cGUpICsgXCIgaW4gXCIgKyBtb2R1bGVVcmwgOlxuICAgICAgICBcImluIFwiICsga2luZCArIFwiIFwiICsgaWRlbnRpZmllck5hbWUodHlwZSk7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4obmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgLTEsIC0xLCAtMSksIG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIFNvdXJjZSBTcGFuIG9iamVjdCBmb3IgYSBnaXZlbiBSMyBUeXBlIGZvciBKSVQgbW9kZS5cbiAqXG4gKiBAcGFyYW0ga2luZCBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICogQHBhcmFtIHR5cGVOYW1lIG5hbWUgb2YgdGhlIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKiBAcGFyYW0gc291cmNlVXJsIHJlZmVyZW5jZSB0byBDb21wb25lbnQgb3IgRGlyZWN0aXZlIHNvdXJjZS5cbiAqIEByZXR1cm5zIGluc3RhbmNlIG9mIFBhcnNlU291cmNlU3BhbiB0aGF0IHJlcHJlc2VudCBhIGdpdmVuIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyB0eXBlTmFtZSArIFwiIGluIFwiICsgc291cmNlVXJsO1xuICAgIHZhciBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcbnZhciBCb3VuZFRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRUZXh0KHZhbHVlLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgQm91bmRUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kVGV4dDtcbn0oKSk7XG52YXIgVGV4dEF0dHJpYnV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0QXR0cmlidXRlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgVGV4dEF0dHJpYnV0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRleHRBdHRyaWJ1dGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEF0dHJpYnV0ZTtcbn0oKSk7XG52YXIgQm91bmRBdHRyaWJ1dGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRBdHRyaWJ1dGUobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBCb3VuZEF0dHJpYnV0ZS5mcm9tQm91bmRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCwgaTE4bikge1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kQXR0cmlidXRlKHByb3AubmFtZSwgcHJvcC50eXBlLCBwcm9wLnNlY3VyaXR5Q29udGV4dCwgcHJvcC52YWx1ZSwgcHJvcC51bml0LCBwcm9wLnNvdXJjZVNwYW4sIHByb3AudmFsdWVTcGFuLCBpMThuKTtcbiAgICB9O1xuICAgIEJvdW5kQXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRBdHRyaWJ1dGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRBdHRyaWJ1dGU7XG59KCkpO1xudmFyIEJvdW5kRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRFdmVudChuYW1lLCB0eXBlLCBoYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmhhbmRsZXJTcGFuID0gaGFuZGxlclNwYW47XG4gICAgfVxuICAgIEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50eXBlID09PSAwIC8qIFJlZ3VsYXIgKi8gPyBldmVudC50YXJnZXRPclBoYXNlIDogbnVsbDtcbiAgICAgICAgdmFyIHBoYXNlID0gZXZlbnQudHlwZSA9PT0gMSAvKiBBbmltYXRpb24gKi8gPyBldmVudC50YXJnZXRPclBoYXNlIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEV2ZW50KGV2ZW50Lm5hbWUsIGV2ZW50LnR5cGUsIGV2ZW50LmhhbmRsZXIsIHRhcmdldCwgcGhhc2UsIGV2ZW50LnNvdXJjZVNwYW4sIGV2ZW50LmhhbmRsZXJTcGFuKTtcbiAgICB9O1xuICAgIEJvdW5kRXZlbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEV2ZW50KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kRXZlbnQ7XG59KCkpO1xudmFyIEVsZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBpbnB1dHMsIG91dHB1dHMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIGVtcHR5IHRoZW4gdGhlIHNvdXJjZSBzcGFuIHNob3VsZCBpbmNsdWRlIGFueSBjbG9zaW5nIHRhZ1xuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIHN0YXJ0U291cmNlU3BhbiAmJiBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQsIGVuZFNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufSgpKTtcbnZhciBUZW1wbGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZSh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBpbnB1dHMsIG91dHB1dHMsIHRlbXBsYXRlQXR0cnMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSB0YWdOYW1lO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUF0dHJzID0gdGVtcGxhdGVBdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIFRlbXBsYXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGVtcGxhdGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGU7XG59KCkpO1xudmFyIENvbnRlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGVudChzZWxlY3RvciwgYXR0cmlidXRlcywgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIENvbnRlbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb250ZW50KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRlbnQ7XG59KCkpO1xudmFyIFZhcmlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZhcmlhYmxlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG4gICAgVmFyaWFibGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZTtcbn0oKSk7XG52YXIgUmVmZXJlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2U7XG59KCkpO1xudmFyIEljdSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJY3UodmFycywgcGxhY2Vob2xkZXJzLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBJY3UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3UodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gSWN1O1xufSgpKTtcbnZhciBOdWxsVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdWxsVmlzaXRvcigpIHtcbiAgICB9XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIE51bGxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kRXZlbnQgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IH07XG4gICAgTnVsbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBOdWxsVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1KSB7IH07XG4gICAgcmV0dXJuIE51bGxWaXNpdG9yO1xufSgpKTtcbnZhciBSZWN1cnNpdmVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB0ZW1wbGF0ZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgdGVtcGxhdGUuY2hpbGRyZW4pO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgdmlzaXRBbGwodGhpcywgdGVtcGxhdGUudmFyaWFibGVzKTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRFdmVudCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHsgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVmlzaXRvcjtcbn0oKSk7XG52YXIgVHJhbnNmb3JtVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1WaXNpdG9yKCkge1xuICAgIH1cbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgbmV3QXR0cmlidXRlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgICB2YXIgbmV3SW5wdXRzID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQuaW5wdXRzKTtcbiAgICAgICAgdmFyIG5ld091dHB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5vdXRwdXRzKTtcbiAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgbmV3UmVmZXJlbmNlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBpZiAobmV3QXR0cmlidXRlcyAhPSBlbGVtZW50LmF0dHJpYnV0ZXMgfHwgbmV3SW5wdXRzICE9IGVsZW1lbnQuaW5wdXRzIHx8XG4gICAgICAgICAgICBuZXdPdXRwdXRzICE9IGVsZW1lbnQub3V0cHV0cyB8fCBuZXdDaGlsZHJlbiAhPSBlbGVtZW50LmNoaWxkcmVuIHx8XG4gICAgICAgICAgICBuZXdSZWZlcmVuY2VzICE9IGVsZW1lbnQucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgbmV3QXR0cmlidXRlcywgbmV3SW5wdXRzLCBuZXdPdXRwdXRzLCBuZXdDaGlsZHJlbiwgbmV3UmVmZXJlbmNlcywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIG5ld0F0dHJpYnV0ZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuYXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBuZXdJbnB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuaW5wdXRzKTtcbiAgICAgICAgdmFyIG5ld091dHB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUub3V0cHV0cyk7XG4gICAgICAgIHZhciBuZXdUZW1wbGF0ZUF0dHJzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMpO1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgbmV3UmVmZXJlbmNlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgdmFyIG5ld1ZhcmlhYmxlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS52YXJpYWJsZXMpO1xuICAgICAgICBpZiAobmV3QXR0cmlidXRlcyAhPSB0ZW1wbGF0ZS5hdHRyaWJ1dGVzIHx8IG5ld0lucHV0cyAhPSB0ZW1wbGF0ZS5pbnB1dHMgfHxcbiAgICAgICAgICAgIG5ld091dHB1dHMgIT0gdGVtcGxhdGUub3V0cHV0cyB8fCBuZXdUZW1wbGF0ZUF0dHJzICE9IHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMgfHxcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuICE9IHRlbXBsYXRlLmNoaWxkcmVuIHx8IG5ld1JlZmVyZW5jZXMgIT0gdGVtcGxhdGUucmVmZXJlbmNlcyB8fFxuICAgICAgICAgICAgbmV3VmFyaWFibGVzICE9IHRlbXBsYXRlLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZS50YWdOYW1lLCBuZXdBdHRyaWJ1dGVzLCBuZXdJbnB1dHMsIG5ld091dHB1dHMsIG5ld1RlbXBsYXRlQXR0cnMsIG5ld0NoaWxkcmVuLCBuZXdSZWZlcmVuY2VzLCBuZXdWYXJpYWJsZXMsIHRlbXBsYXRlLnNvdXJjZVNwYW4sIHRlbXBsYXRlLnN0YXJ0U291cmNlU3BhbiwgdGVtcGxhdGUuZW5kU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfTtcbiAgICBUcmFuc2Zvcm1WaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgIH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRFdmVudCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9O1xuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgVHJhbnNmb3JtVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIFRyYW5zZm9ybVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSkge1xuICAgICAgICByZXR1cm4gaWN1O1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zZm9ybVZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gdmlzaXRBbGwodmlzaXRvciwgbm9kZXMpIHtcbiAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpc2l0b3IudmlzaXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGVzXzEgPSBfX3ZhbHVlcyhub2RlcyksIG5vZGVzXzFfMSA9IG5vZGVzXzEubmV4dCgpOyAhbm9kZXNfMV8xLmRvbmU7IG5vZGVzXzFfMSA9IG5vZGVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB2aXNpdG9yLnZpc2l0KG5vZGUpIHx8IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChub2Rlc18xXzEgJiYgIW5vZGVzXzFfMS5kb25lICYmIChfYSA9IG5vZGVzXzEucmV0dXJuKSkgX2EuY2FsbChub2Rlc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5vZGVzXzIgPSBfX3ZhbHVlcyhub2RlcyksIG5vZGVzXzJfMSA9IG5vZGVzXzIubmV4dCgpOyAhbm9kZXNfMl8xLmRvbmU7IG5vZGVzXzJfMSA9IG5vZGVzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBub2RlLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzXzJfMSAmJiAhbm9kZXNfMl8xLmRvbmUgJiYgKF9iID0gbm9kZXNfMi5yZXR1cm4pKSBfYi5jYWxsKG5vZGVzXzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BbGwodmlzaXRvciwgbm9kZXMpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBub2Rlc18zID0gX192YWx1ZXMobm9kZXMpLCBub2Rlc18zXzEgPSBub2Rlc18zLm5leHQoKTsgIW5vZGVzXzNfMS5kb25lOyBub2Rlc18zXzEgPSBub2Rlc18zLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18zXzEudmFsdWU7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgbmV3Tm9kZSAhPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobm9kZXNfM18xICYmICFub2Rlc18zXzEuZG9uZSAmJiAoX2EgPSBub2Rlc18zLnJldHVybikpIF9hLmNhbGwobm9kZXNfMyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZCA/IHJlc3VsdCA6IG5vZGVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbm9kZXMgbWVzc2FnZSBBU1RcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJUb01lc3NhZ2UgbWFwcyBwbGFjZWhvbGRlciBuYW1lcyB0byBtZXNzYWdlcyAodXNlZCBmb3IgbmVzdGVkIElDVSBtZXNzYWdlcylcbiAgICAgKiBAcGFyYW0gbWVhbmluZ1xuICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSBjdXN0b21JZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2Uobm9kZXMsIHBsYWNlaG9sZGVycywgcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyVG9NZXNzYWdlID0gcGxhY2Vob2xkZXJUb01lc3NhZ2U7XG4gICAgICAgIHRoaXMubWVhbmluZyA9IG1lYW5pbmc7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jdXN0b21JZCA9IGN1c3RvbUlkO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5jdXN0b21JZDtcbiAgICAgICAgLyoqIFRoZSBpZHMgdG8gdXNlIGlmIHRoZXJlIGFyZSBubyBjdXN0b20gaWQgYW5kIGlmIGBpMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0YCBpcyBub3QgZW1wdHkgKi9cbiAgICAgICAgdGhpcy5sZWdhY3lJZHMgPSBbXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZTogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5saW5lICsgMSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2w6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuY29sICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZTogbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uc291cmNlU3Bhbi5lbmQubGluZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5jb2wgKyAxXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZTtcbn0oKSk7XG52YXIgVGV4dCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufSgpKTtcbi8vIFRPRE8odmljYik6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXMgbm9kZSAodnMgYW4gYXJyYXkpID9cbnZhciBDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRhaW5lcjtcbn0oKSk7XG52YXIgSWN1JDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWN1KGV4cHJlc3Npb24sIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSWN1LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEljdTtcbn0oKSk7XG52YXIgVGFnUGxhY2Vob2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFnUGxhY2Vob2xkZXIodGFnLCBhdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zdGFydE5hbWUgPSBzdGFydE5hbWU7XG4gICAgICAgIHRoaXMuY2xvc2VOYW1lID0gY2xvc2VOYW1lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBUYWdQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRhZ1BsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhZ1BsYWNlaG9sZGVyO1xufSgpKTtcbnZhciBQbGFjZWhvbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGFjZWhvbGRlcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIFBsYWNlaG9sZGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIEljdVBsYWNlaG9sZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEljdVBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgSWN1UGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3VQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJY3VQbGFjZWhvbGRlcjtcbn0oKSk7XG4vLyBDbG9uZSB0aGUgQVNUXG52YXIgQ2xvbmVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsb25lVmlzaXRvcigpIHtcbiAgICB9XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcihjaGlsZHJlbiwgY29udGFpbmVyLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgdmFyIG1zZyA9IG5ldyBJY3UkMShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHBoLnN0YXJ0TmFtZSwgcGguY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBDbG9uZVZpc2l0b3I7XG59KCkpO1xuLy8gVmlzaXQgYWxsIHRoZSBub2RlcyByZWN1cnNpdmVseVxudmFyIFJlY3Vyc2VWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHBoLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkgeyB9O1xuICAgIHJldHVybiBSZWN1cnNlVmlzaXRvcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUmV0dXJuIHRoZSBtZXNzYWdlIGlkIG9yIGNvbXB1dGUgaXQgdXNpbmcgdGhlIFhMSUZGMSBkaWdlc3QuXG4gKi9cbmZ1bmN0aW9uIGRpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuaWQgfHwgY29tcHV0ZURpZ2VzdChtZXNzYWdlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWVzc2FnZSBpZCB1c2luZyB0aGUgWExJRkYxIGRpZ2VzdC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZURpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHNoYTEoc2VyaWFsaXplTm9kZXMobWVzc2FnZS5ub2Rlcykuam9pbignJykgKyAoXCJbXCIgKyBtZXNzYWdlLm1lYW5pbmcgKyBcIl1cIikpO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIG1lc3NhZ2UgaWQgb3IgY29tcHV0ZSBpdCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWVzc2FnZSBpZCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCk7XG4gICAgdmFyIHBhcnRzID0gbWVzc2FnZS5ub2Rlcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaXQodmlzaXRvciwgbnVsbCk7IH0pO1xuICAgIHJldHVybiBjb21wdXRlTXNnSWQocGFydHMuam9pbignJyksIG1lc3NhZ2UubWVhbmluZyk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBUaGUgdmlzaXRvciBpcyBhbHNvIHVzZWQgaW4gdGhlIGkxOG4gcGFyc2VyIHRlc3RzXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBfU2VyaWFsaXplclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJWaXNpdG9yKCkge1xuICAgIH1cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnZhbHVlO1xuICAgIH07XG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiXVwiO1xuICAgIH07XG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBpY3UuZXhwcmVzc2lvbiArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCI+XCIgKyBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIjwvcGggbmFtZT1cXFwiXCIgKyBwaC5jbG9zZU5hbWUgKyBcIlxcXCI+XCI7XG4gICAgfTtcbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBoLnZhbHVlID8gXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUgKyBcIjwvcGg+XCIgOiBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCIvPlwiO1xuICAgIH07XG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBcIjxwaCBpY3UgbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUudmlzaXQodGhpcykgKyBcIjwvcGg+XCI7XG4gICAgfTtcbiAgICByZXR1cm4gX1NlcmlhbGl6ZXJWaXNpdG9yO1xufSgpKTtcbnZhciBzZXJpYWxpemVyVmlzaXRvciA9IG5ldyBfU2VyaWFsaXplclZpc2l0b3IoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS52aXNpdChzZXJpYWxpemVyVmlzaXRvciwgbnVsbCk7IH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogSWdub3JlIHRoZSBJQ1UgZXhwcmVzc2lvbnMgc28gdGhhdCBtZXNzYWdlIElEcyBzdGF5cyBpZGVudGljYWwgaWYgb25seSB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgLy8gRG8gbm90IHRha2UgdGhlIGV4cHJlc3Npb24gaW50byBhY2NvdW50XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcjtcbn0oX1NlcmlhbGl6ZXJWaXNpdG9yKSk7XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBkZXNpZ25lZCBub3QgdGVzdGVkIHdpdGggc2VjdXJpdHkgaW4gbWluZC5cbiAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAqL1xuZnVuY3Rpb24gc2hhMShzdHIpIHtcbiAgICB2YXIgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICB2YXIgd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4LCBFbmRpYW4uQmlnKTtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGggKiA4O1xuICAgIHZhciB3ID0gbmV3QXJyYXkoODApO1xuICAgIHZhciBhID0gMHg2NzQ1MjMwMSwgYiA9IDB4ZWZjZGFiODksIGMgPSAweDk4YmFkY2ZlLCBkID0gMHgxMDMyNTQ3NiwgZSA9IDB4YzNkMmUxZjA7XG4gICAgd29yZHMzMltsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gICAgd29yZHMzMlsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgdmFyIGgwID0gYSwgaDEgPSBiLCBoMiA9IGMsIGgzID0gZCwgaDQgPSBlO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmtWYWwgPSBmayhqLCBiLCBjLCBkKTtcbiAgICAgICAgICAgIHZhciBmID0gZmtWYWxbMF07XG4gICAgICAgICAgICB2YXIgayA9IGZrVmFsWzFdO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBbcm9sMzIoYSwgNSksIGYsIGUsIGssIHdbal1dLnJlZHVjZShhZGQzMik7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IHJvbDMyKGIsIDMwKTtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGFkZDMyKGEsIGgwKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIGgxKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIGgyKTtcbiAgICAgICAgZCA9IGFkZDMyKGQsIGgzKTtcbiAgICAgICAgZSA9IGFkZDMyKGUsIGg0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0hleFN0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFthLCBiLCBjLCBkLCBlXSkpO1xufVxuZnVuY3Rpb24gZmsoaW5kZXgsIGIsIGMsIGQpIHtcbiAgICBpZiAoaW5kZXggPCAyMCkge1xuICAgICAgICByZXR1cm4gWyhiICYgYykgfCAofmIgJiBkKSwgMHg1YTgyNzk5OV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDQwKSB7XG4gICAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweDZlZDllYmExXTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgNjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCksIDB4OGYxYmJjZGNdO1xuICAgIH1cbiAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHhjYTYyYzFkNl07XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIGZpbmdlcnByaW50IG9mIHRoZSBnaXZlbiBzdHJpbmdcbiAqXG4gKiBUaGUgb3V0cHV0IGlzIDY0IGJpdCBudW1iZXIgZW5jb2RlZCBhcyBhIGRlY2ltYWwgc3RyaW5nXG4gKlxuICogYmFzZWQgb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvYmxvYi9tYXN0ZXIvc3JjL2NvbS9nb29nbGUvamF2YXNjcmlwdC9qc2NvbXAvR29vZ2xlSnNNZXNzYWdlSWRHZW5lcmF0b3IuamF2YVxuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChzdHIpIHtcbiAgICB2YXIgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICB2YXIgaGkgPSBoYXNoMzIodXRmOCwgMCk7XG4gICAgdmFyIGxvID0gaGFzaDMyKHV0ZjgsIDEwMjA3Mik7XG4gICAgaWYgKGhpID09IDAgJiYgKGxvID09IDAgfHwgbG8gPT0gMSkpIHtcbiAgICAgICAgaGkgPSBoaSBeIDB4MTMwZjliZWY7XG4gICAgICAgIGxvID0gbG8gXiAtMHg2YjVmNTZkODtcbiAgICB9XG4gICAgcmV0dXJuIFtoaSwgbG9dO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1zZ0lkKG1zZywgbWVhbmluZykge1xuICAgIGlmIChtZWFuaW5nID09PSB2b2lkIDApIHsgbWVhbmluZyA9ICcnOyB9XG4gICAgdmFyIG1zZ0ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQobXNnKTtcbiAgICBpZiAobWVhbmluZykge1xuICAgICAgICB2YXIgbWVhbmluZ0ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQobWVhbmluZyk7XG4gICAgICAgIG1zZ0ZpbmdlcnByaW50ID0gYWRkNjQocm9sNjQobXNnRmluZ2VycHJpbnQsIDEpLCBtZWFuaW5nRmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICB2YXIgaGkgPSBtc2dGaW5nZXJwcmludFswXTtcbiAgICB2YXIgbG8gPSBtc2dGaW5nZXJwcmludFsxXTtcbiAgICByZXR1cm4gYnl0ZVN0cmluZ1RvRGVjU3RyaW5nKHdvcmRzMzJUb0J5dGVTdHJpbmcoW2hpICYgMHg3ZmZmZmZmZiwgbG9dKSk7XG59XG5mdW5jdGlvbiBoYXNoMzIoc3RyLCBjKSB7XG4gICAgdmFyIGEgPSAweDllMzc3OWI5LCBiID0gMHg5ZTM3NzliOTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpICsgMTIgPD0gbGVuOyBpICs9IDEyKSB7XG4gICAgICAgIGEgPSBhZGQzMihhLCB3b3JkQXQoc3RyLCBpLCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoc3RyLCBpICsgNCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBjID0gYWRkMzIoYywgd29yZEF0KHN0ciwgaSArIDgsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgdmFyIHJlcyA9IG1peChhLCBiLCBjKTtcbiAgICAgICAgYSA9IHJlc1swXSwgYiA9IHJlc1sxXSwgYyA9IHJlc1syXTtcbiAgICB9XG4gICAgYSA9IGFkZDMyKGEsIHdvcmRBdChzdHIsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICBiID0gYWRkMzIoYiwgd29yZEF0KHN0ciwgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAvLyB0aGUgZmlyc3QgYnl0ZSBvZiBjIGlzIHJlc2VydmVkIGZvciB0aGUgbGVuZ3RoXG4gICAgYyA9IGFkZDMyKGMsIGxlbik7XG4gICAgYyA9IGFkZDMyKGMsIHdvcmRBdChzdHIsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSA8PCA4KTtcbiAgICByZXR1cm4gbWl4KGEsIGIsIGMpWzJdO1xufVxuLy8gY2xhbmctZm9ybWF0IG9mZlxuZnVuY3Rpb24gbWl4KGEsIGIsIGMpIHtcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgODtcbiAgICBjID0gc3ViMzIoYywgYSk7XG4gICAgYyA9IHN1YjMyKGMsIGIpO1xuICAgIGMgXj0gYiA+Pj4gMTM7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDEyO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDE2O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiA1O1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAzO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDEwO1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxNTtcbiAgICByZXR1cm4gW2EsIGIsIGNdO1xufVxuLy8gY2xhbmctZm9ybWF0IG9uXG4vLyBVdGlsc1xudmFyIEVuZGlhbjtcbihmdW5jdGlvbiAoRW5kaWFuKSB7XG4gICAgRW5kaWFuW0VuZGlhbltcIkxpdHRsZVwiXSA9IDBdID0gXCJMaXR0bGVcIjtcbiAgICBFbmRpYW5bRW5kaWFuW1wiQmlnXCJdID0gMV0gPSBcIkJpZ1wiO1xufSkoRW5kaWFuIHx8IChFbmRpYW4gPSB7fSkpO1xuZnVuY3Rpb24gYWRkMzIoYSwgYikge1xuICAgIHJldHVybiBhZGQzMnRvNjQoYSwgYilbMV07XG59XG5mdW5jdGlvbiBhZGQzMnRvNjQoYSwgYikge1xuICAgIHZhciBsb3cgPSAoYSAmIDB4ZmZmZikgKyAoYiAmIDB4ZmZmZik7XG4gICAgdmFyIGhpZ2ggPSAoYSA+Pj4gMTYpICsgKGIgPj4+IDE2KSArIChsb3cgPj4+IDE2KTtcbiAgICByZXR1cm4gW2hpZ2ggPj4+IDE2LCAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKV07XG59XG5mdW5jdGlvbiBhZGQ2NChhLCBiKSB7XG4gICAgdmFyIGFoID0gYVswXSwgYWwgPSBhWzFdO1xuICAgIHZhciBiaCA9IGJbMF0sIGJsID0gYlsxXTtcbiAgICB2YXIgcmVzdWx0ID0gYWRkMzJ0bzY0KGFsLCBibCk7XG4gICAgdmFyIGNhcnJ5ID0gcmVzdWx0WzBdO1xuICAgIHZhciBsID0gcmVzdWx0WzFdO1xuICAgIHZhciBoID0gYWRkMzIoYWRkMzIoYWgsIGJoKSwgY2FycnkpO1xuICAgIHJldHVybiBbaCwgbF07XG59XG5mdW5jdGlvbiBzdWIzMihhLCBiKSB7XG4gICAgdmFyIGxvdyA9IChhICYgMHhmZmZmKSAtIChiICYgMHhmZmZmKTtcbiAgICB2YXIgaGlnaCA9IChhID4+IDE2KSAtIChiID4+IDE2KSArIChsb3cgPj4gMTYpO1xuICAgIHJldHVybiAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKTtcbn1cbi8vIFJvdGF0ZSBhIDMyYiBudW1iZXIgbGVmdCBgY291bnRgIHBvc2l0aW9uXG5mdW5jdGlvbiByb2wzMihhLCBjb3VudCkge1xuICAgIHJldHVybiAoYSA8PCBjb3VudCkgfCAoYSA+Pj4gKDMyIC0gY291bnQpKTtcbn1cbi8vIFJvdGF0ZSBhIDY0YiBudW1iZXIgbGVmdCBgY291bnRgIHBvc2l0aW9uXG5mdW5jdGlvbiByb2w2NChudW0sIGNvdW50KSB7XG4gICAgdmFyIGhpID0gbnVtWzBdLCBsbyA9IG51bVsxXTtcbiAgICB2YXIgaCA9IChoaSA8PCBjb3VudCkgfCAobG8gPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgdmFyIGwgPSAobG8gPDwgY291bnQpIHwgKGhpID4+PiAoMzIgLSBjb3VudCkpO1xuICAgIHJldHVybiBbaCwgbF07XG59XG5mdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyLCBlbmRpYW4pIHtcbiAgICB2YXIgc2l6ZSA9IChzdHIubGVuZ3RoICsgMykgPj4+IDI7XG4gICAgdmFyIHdvcmRzMzIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB3b3JkczMyW2ldID0gd29yZEF0KHN0ciwgaSAqIDQsIGVuZGlhbik7XG4gICAgfVxuICAgIHJldHVybiB3b3JkczMyO1xufVxuZnVuY3Rpb24gYnl0ZUF0KHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gc3RyLmxlbmd0aCA/IDAgOiBzdHIuY2hhckNvZGVBdChpbmRleCkgJiAweGZmO1xufVxuZnVuY3Rpb24gd29yZEF0KHN0ciwgaW5kZXgsIGVuZGlhbikge1xuICAgIHZhciB3b3JkID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSBFbmRpYW4uQmlnKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgKDI0IC0gOCAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgd29yZCArPSBieXRlQXQoc3RyLCBpbmRleCArIGkpIDw8IDggKiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JkO1xufVxuZnVuY3Rpb24gd29yZHMzMlRvQnl0ZVN0cmluZyh3b3JkczMyKSB7XG4gICAgcmV0dXJuIHdvcmRzMzIucmVkdWNlKGZ1bmN0aW9uIChzdHIsIHdvcmQpIHsgcmV0dXJuIHN0ciArIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKTsgfSwgJycpO1xufVxuZnVuY3Rpb24gd29yZDMyVG9CeXRlU3RyaW5nKHdvcmQpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHdvcmQgPj4+IDggKiAoMyAtIGkpKSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYnl0ZVN0cmluZ1RvSGV4U3RyaW5nKHN0cikge1xuICAgIHZhciBoZXggPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGJ5dGVBdChzdHIsIGkpO1xuICAgICAgICBoZXggKz0gKGIgPj4+IDQpLnRvU3RyaW5nKDE2KSArIChiICYgMHgwZikudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCk7XG59XG4vLyBiYXNlZCBvbiBodHRwOi8vd3d3LmRhbnZrLm9yZy9oZXgyZGVjLmh0bWwgKEpTIGNhbiBub3QgaGFuZGxlIG1vcmUgdGhhbiA1NmIpXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9EZWNTdHJpbmcoc3RyKSB7XG4gICAgdmFyIGRlY2ltYWwgPSAnJztcbiAgICB2YXIgdG9UaGVQb3dlciA9ICcxJztcbiAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGRlY2ltYWwgPSBhZGRCaWdJbnQoZGVjaW1hbCwgbnVtYmVyVGltZXNCaWdJbnQoYnl0ZUF0KHN0ciwgaSksIHRvVGhlUG93ZXIpKTtcbiAgICAgICAgdG9UaGVQb3dlciA9IG51bWJlclRpbWVzQmlnSW50KDI1NiwgdG9UaGVQb3dlcik7XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XG59XG4vLyB4IGFuZCB5IGRlY2ltYWwsIGxvd2VzdCBzaWduaWZpY2FudCBkaWdpdCBmaXJzdFxuZnVuY3Rpb24gYWRkQmlnSW50KHgsIHkpIHtcbiAgICB2YXIgc3VtID0gJyc7XG4gICAgdmFyIGxlbiA9IE1hdGgubWF4KHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGNhcnJ5ID0gMDsgaSA8IGxlbiB8fCBjYXJyeTsgaSsrKSB7XG4gICAgICAgIHZhciB0bXBTdW0gPSBjYXJyeSArICsoeFtpXSB8fCAwKSArICsoeVtpXSB8fCAwKTtcbiAgICAgICAgaWYgKHRtcFN1bSA+PSAxMCkge1xuICAgICAgICAgICAgY2FycnkgPSAxO1xuICAgICAgICAgICAgc3VtICs9IHRtcFN1bSAtIDEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICAgICAgc3VtICs9IHRtcFN1bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuZnVuY3Rpb24gbnVtYmVyVGltZXNCaWdJbnQobnVtLCBiKSB7XG4gICAgdmFyIHByb2R1Y3QgPSAnJztcbiAgICB2YXIgYlRvVGhlUG93ZXIgPSBiO1xuICAgIGZvciAoOyBudW0gIT09IDA7IG51bSA9IG51bSA+Pj4gMSkge1xuICAgICAgICBpZiAobnVtICYgMSlcbiAgICAgICAgICAgIHByb2R1Y3QgPSBhZGRCaWdJbnQocHJvZHVjdCwgYlRvVGhlUG93ZXIpO1xuICAgICAgICBiVG9UaGVQb3dlciA9IGFkZEJpZ0ludChiVG9UaGVQb3dlciwgYlRvVGhlUG93ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZHVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcigpIHtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhIG5hbWUgbWFwcGVyLCBzZWUgYFBsYWNlaG9sZGVyTWFwcGVyYFxuICAgIC8vIFJldHVybmluZyBgbnVsbGAgbWVhbnMgdGhhdCBubyBuYW1lIG1hcHBpbmcgaXMgdXNlZC5cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5jcmVhdGVOYW1lTWFwcGVyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2VyaWFsaXplcjtcbn0oKSk7XG4vKipcbiAqIEEgc2ltcGxlIG1hcHBlciB0aGF0IHRha2UgYSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYW4gaW50ZXJuYWwgbmFtZSB0byBhIHB1YmxpYyBuYW1lXG4gKi9cbnZhciBTaW1wbGVQbGFjZWhvbGRlck1hcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIsIF9zdXBlcik7XG4gICAgLy8gY3JlYXRlIGEgbWFwcGluZyBmcm9tIHRoZSBtZXNzYWdlXG4gICAgZnVuY3Rpb24gU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgbWFwTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXBOYW1lID0gbWFwTmFtZTtcbiAgICAgICAgX3RoaXMuaW50ZXJuYWxUb1B1YmxpYyA9IHt9O1xuICAgICAgICBfdGhpcy5wdWJsaWNUb05leHRJZCA9IHt9O1xuICAgICAgICBfdGhpcy5wdWJsaWNUb0ludGVybmFsID0ge307XG4gICAgICAgIG1lc3NhZ2Uubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS50b1B1YmxpY05hbWUgPSBmdW5jdGlvbiAoaW50ZXJuYWxOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVG9QdWJsaWMuaGFzT3duUHJvcGVydHkoaW50ZXJuYWxOYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWNbaW50ZXJuYWxOYW1lXSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvSW50ZXJuYWxOYW1lID0gZnVuY3Rpb24gKHB1YmxpY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljVG9JbnRlcm5hbC5oYXNPd25Qcm9wZXJ0eShwdWJsaWNOYW1lKSA/IHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIuY2FsbCh0aGlzLCBwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGgubmFtZSk7XG4gICAgfTtcbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH07XG4gICAgLy8gWE1CIHBsYWNlaG9sZGVycyBjb3VsZCBvbmx5IGNvbnRhaW5zIEEtWiwgMC05IGFuZCBfXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKGludGVybmFsTmFtZSkge1xuICAgICAgICBpZiAoIWludGVybmFsTmFtZSB8fCB0aGlzLmludGVybmFsVG9QdWJsaWMuaGFzT3duUHJvcGVydHkoaW50ZXJuYWxOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdWJsaWNOYW1lID0gdGhpcy5tYXBOYW1lKGludGVybmFsTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBYTUIgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIHZhciBuZXh0SWQgPSB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdO1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXSA9IG5leHRJZCArIDE7XG4gICAgICAgICAgICBwdWJsaWNOYW1lID0gcHVibGljTmFtZSArIFwiX1wiICsgbmV4dElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbFRvUHVibGljW2ludGVybmFsTmFtZV0gPSBwdWJsaWNOYW1lO1xuICAgICAgICB0aGlzLnB1YmxpY1RvSW50ZXJuYWxbcHVibGljTmFtZV0gPSBpbnRlcm5hbE5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXI7XG59KFJlY3Vyc2VWaXNpdG9yKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICB9XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3RyQXR0cnMgPSB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKHRhZy5hdHRycyk7XG4gICAgICAgIGlmICh0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIi8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQudmFsdWU7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lICsgXCI9XFxcIlwiICsgYXR0cnNbbmFtZV0gKyBcIlxcXCJcIjsgfSkuam9pbignICcpO1xuICAgICAgICByZXR1cm4gc3RyQXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIHN0ckF0dHJzIDogJyc7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXREb2N0eXBlID0gZnVuY3Rpb24gKGRvY3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwiPCFET0NUWVBFIFwiICsgZG9jdHlwZS5yb290VGFnICsgXCIgW1xcblwiICsgZG9jdHlwZS5kdGQgKyBcIlxcbl0+XCI7XG4gICAgfTtcbiAgICByZXR1cm4gX1Zpc2l0b3I7XG59KCkpO1xudmFyIF92aXNpdG9yID0gbmV3IF9WaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemUobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF92aXNpdG9yKTsgfSkuam9pbignJyk7XG59XG52YXIgRGVjbGFyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjbGFyYXRpb24odW5lc2NhcGVkQXR0cnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBlc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbn0oKSk7XG52YXIgRG9jdHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N0eXBlKHJvb3RUYWcsIGR0ZCkge1xuICAgICAgICB0aGlzLnJvb3RUYWcgPSByb290VGFnO1xuICAgICAgICB0aGlzLmR0ZCA9IGR0ZDtcbiAgICB9XG4gICAgRG9jdHlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERvY3R5cGUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9jdHlwZTtcbn0oKSk7XG52YXIgVGFnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhZyhuYW1lLCB1bmVzY2FwZWRBdHRycywgY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHVuZXNjYXBlZEF0dHJzID09PSB2b2lkIDApIHsgdW5lc2NhcGVkQXR0cnMgPSB7fTsgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IFtdOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBlc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVGFnLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGFnKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhZztcbn0oKSk7XG52YXIgVGV4dCQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleHQodW5lc2NhcGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVzY2FwZVhtbCh1bmVzY2FwZWRWYWx1ZSk7XG4gICAgfVxuICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHQ7XG59KCkpO1xudmFyIENSID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDUiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDUih3cykge1xuICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiXFxuXCIgKyBuZXcgQXJyYXkod3MgKyAxKS5qb2luKCcgJykpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDUjtcbn0oVGV4dCQyKSk7XG52YXIgX0VTQ0FQRURfQ0hBUlMgPSBbXG4gICAgWy8mL2csICcmYW1wOyddLFxuICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgIFsvJy9nLCAnJmFwb3M7J10sXG4gICAgWy88L2csICcmbHQ7J10sXG4gICAgWy8+L2csICcmZ3Q7J10sXG5dO1xuLy8gRXNjYXBlIGBfRVNDQVBFRF9DSEFSU2AgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gdGV4dCB3aXRoIGVuY29kZWQgZW50aXRpZXNcbmZ1bmN0aW9uIGVzY2FwZVhtbCh0ZXh0KSB7XG4gICAgcmV0dXJuIF9FU0NBUEVEX0NIQVJTLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZW50cnkpIHsgcmV0dXJuIHRleHQucmVwbGFjZShlbnRyeVswXSwgZW50cnlbMV0pOyB9LCB0ZXh0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG52YXIgX01FU1NBR0VfVEFHID0gJ21zZyc7XG52YXIgX1BMQUNFSE9MREVSX1RBRyA9ICdwaCc7XG52YXIgX0VYQU1QTEVfVEFHID0gJ2V4JztcbnZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xudmFyIF9ET0NUWVBFID0gXCI8IUVMRU1FTlQgbWVzc2FnZWJ1bmRsZSAobXNnKSo+XFxuPCFBVFRMSVNUIG1lc3NhZ2VidW5kbGUgY2xhc3MgQ0RBVEEgI0lNUExJRUQ+XFxuXFxuPCFFTEVNRU5UIG1zZyAoI1BDREFUQXxwaHxzb3VyY2UpKj5cXG48IUFUVExJU1QgbXNnIGlkIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgc2VxIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbmFtZSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIGRlc2MgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBtZWFuaW5nIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgb2Jzb2xldGUgKG9ic29sZXRlKSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHhtbDpzcGFjZSAoZGVmYXVsdHxwcmVzZXJ2ZSkgXFxcImRlZmF1bHRcXFwiPlxcbjwhQVRUTElTVCBtc2cgaXNfaGlkZGVuIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBzb3VyY2UgKCNQQ0RBVEEpPlxcblxcbjwhRUxFTUVOVCBwaCAoI1BDREFUQXxleCkqPlxcbjwhQVRUTElTVCBwaCBuYW1lIENEQVRBICNSRVFVSVJFRD5cXG5cXG48IUVMRU1FTlQgZXggKCNQQ0RBVEEpPlwiO1xudmFyIFhtYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWG1iLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhtYigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBYbWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yJDEoKTtcbiAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IFRhZyhfTUVTU0FHRVNfVEFHKTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZVRhZ3MgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VUYWdzLnB1c2gobmV3IFRhZyhfU09VUkNFX1RBRywge30sIFtuZXcgVGV4dCQyKHNvdXJjZS5maWxlUGF0aCArIFwiOlwiICsgc291cmNlLnN0YXJ0TGluZSArIChzb3VyY2UuZW5kTGluZSAhPT0gc291cmNlLnN0YXJ0TGluZSA/ICcsJyArIHNvdXJjZS5lbmRMaW5lIDogJycpKV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgX19zcHJlYWQoc291cmNlVGFncywgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigpKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgIG5ldyBEb2N0eXBlKF9NRVNTQUdFU19UQUcsIF9ET0NUWVBFKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgZXhhbXBsZVZpc2l0b3IuYWRkRGVmYXVsdEV4YW1wbGVzKHJvb3ROb2RlKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH07XG4gICAgWG1iLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGlnZXN0JDEobWVzc2FnZSk7XG4gICAgfTtcbiAgICBYbWIucHJvdG90eXBlLmNyZWF0ZU5hbWVNYXBwZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIHRvUHVibGljTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1iO1xufShTZXJpYWxpemVyKSk7XG52YXIgX1Zpc2l0b3IkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICB9XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2RlcywgX19zcHJlYWQobm9kZS52aXNpdChfdGhpcykpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZChbbmV3IFRleHQkMihjICsgXCIge1wiKV0sIGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGFnQXNUZXh0ID0gbmV3IFRleHQkMihcIjxcIiArIHBoLnRhZyArIFwiPlwiKTtcbiAgICAgICAgdmFyIHN0YXJ0RXggPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICAvLyBUQyByZXF1aXJlcyBQSCB0byBoYXZlIGEgbm9uIGVtcHR5IEVYLCBhbmQgdXNlcyB0aGUgdGV4dCBub2RlIHRvIHNob3cgdGhlIFwib3JpZ2luYWxcIiB2YWx1ZS5cbiAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgbmFtZTogcGguc3RhcnROYW1lIH0sIFtzdGFydEV4LCBzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9zZVRhZ0FzVGV4dCA9IG5ldyBUZXh0JDIoXCI8L1wiICsgcGgudGFnICsgXCI+XCIpO1xuICAgICAgICB2YXIgY2xvc2VFeCA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2Nsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBuYW1lOiBwaC5jbG9zZU5hbWUgfSwgW2Nsb3NlRXgsIGNsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZChbc3RhcnRUYWdQaF0sIHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQXNUZXh0ID0gbmV3IFRleHQkMihcInt7XCIgKyBwaC52YWx1ZSArIFwifX1cIik7XG4gICAgICAgIC8vIEV4YW1wbGUgdGFnIG5lZWRzIHRvIGJlIG5vdC1lbXB0eSBmb3IgVEMuXG4gICAgICAgIHZhciBleFRhZyA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2ludGVycG9sYXRpb25Bc1RleHRdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICAgICAgbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IG5hbWU6IHBoLm5hbWUgfSwgW2V4VGFnLCBpbnRlcnBvbGF0aW9uQXNUZXh0XSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpY3VFeHByZXNzaW9uID0gcGgudmFsdWUuZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIGljdVR5cGUgPSBwaC52YWx1ZS50eXBlO1xuICAgICAgICB2YXIgaWN1Q2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyAnIHsuLi59JzsgfSkuam9pbignICcpO1xuICAgICAgICB2YXIgaWN1QXNUZXh0ID0gbmV3IFRleHQkMihcIntcIiArIGljdUV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3VUeXBlICsgXCIsIFwiICsgaWN1Q2FzZXMgKyBcIn1cIik7XG4gICAgICAgIHZhciBleFRhZyA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2ljdUFzVGV4dF0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgICAgICBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgbmFtZTogcGgubmFtZSB9LCBbZXhUYWcsIGljdUFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1Zpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gZGlnZXN0JDEobWVzc2FnZSkge1xuICAgIHJldHVybiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xufVxuLy8gVEMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBleGFtcGxlIG9uIHBsYWNlaG9sZGVyc1xudmFyIEV4YW1wbGVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUuYWRkRGVmYXVsdEV4YW1wbGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgaWYgKCF0YWcuY2hpbGRyZW4gfHwgdGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4VGV4dCA9IG5ldyBUZXh0JDIodGFnLmF0dHJzWyduYW1lJ10gfHwgJy4uLicpO1xuICAgICAgICAgICAgICAgIHRhZy5jaGlsZHJlbiA9IFtuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtleFRleHRdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YWcuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7IH07XG4gICAgRXhhbXBsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7IH07XG4gICAgcmV0dXJuIEV4YW1wbGVWaXNpdG9yO1xufSgpKTtcbi8vIFhNQi9YVEIgcGxhY2Vob2xkZXJzIGNhbiBvbmx5IGNvbnRhaW4gQS1aLCAwLTkgYW5kIF9cbmZ1bmN0aW9uIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxOYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW15BLVowLTlfXS9nLCAnXycpO1xufVxuXG4vKiBDbG9zdXJlIHZhcmlhYmxlcyBob2xkaW5nIG1lc3NhZ2VzIG11c3QgYmUgbmFtZWQgYE1TR19bQS1aMC05XStgICovXG52YXIgQ0xPU1VSRV9UUkFOU0xBVElPTl9QUkVGSVggPSAnTVNHXyc7XG4vKiBQcmVmaXggZm9yIG5vbi1gZ29vZy5nZXRNc2dgIGkxOG4tcmVsYXRlZCB2YXJzICovXG52YXIgVFJBTlNMQVRJT05fUFJFRklYID0gJ0kxOE5fJztcbi8qKiBOYW1lIG9mIHRoZSBpMThuIGF0dHJpYnV0ZXMgKiovXG52YXIgSTE4Tl9BVFRSID0gJ2kxOG4nO1xudmFyIEkxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuLyoqIFByZWZpeCBvZiB2YXIgZXhwcmVzc2lvbnMgdXNlZCBpbiBJQ1VzICovXG52YXIgSTE4Tl9JQ1VfVkFSX1BSRUZJWCA9ICdWQVJfJztcbi8qKiBQcmVmaXggb2YgSUNVIGV4cHJlc3Npb25zIGZvciBwb3N0IHByb2Nlc3NpbmcgKi9cbnZhciBJMThOX0lDVV9NQVBQSU5HX1BSRUZJWCA9ICdJMThOX0VYUF8nO1xuLyoqIFBsYWNlaG9sZGVyIHdyYXBwZXIgZm9yIGkxOG4gZXhwcmVzc2lvbnMgKiovXG52YXIgSTE4Tl9QTEFDRUhPTERFUl9TWU1CT0wgPSAn77+9JztcbmZ1bmN0aW9uIGlzSTE4bkF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IEkxOE5fQVRUUiB8fCBuYW1lLnN0YXJ0c1dpdGgoSTE4Tl9BVFRSX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc0kxOG5Sb290Tm9kZShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlO1xufVxuZnVuY3Rpb24gaXNTaW5nbGVJMThuSWN1KG1ldGEpIHtcbiAgICByZXR1cm4gaXNJMThuUm9vdE5vZGUobWV0YSkgJiYgbWV0YS5ub2Rlcy5sZW5ndGggPT09IDEgJiYgbWV0YS5ub2Rlc1swXSBpbnN0YW5jZW9mIEljdSQxO1xufVxuZnVuY3Rpb24gaGFzSTE4bk1ldGEobm9kZSkge1xuICAgIHJldHVybiAhIW5vZGUuaTE4bjtcbn1cbmZ1bmN0aW9uIGhhc0kxOG5BdHRycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuYXR0cnMuc29tZShmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gaXNJMThuQXR0cmlidXRlKGF0dHIubmFtZSk7IH0pO1xufVxuZnVuY3Rpb24gaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5ub2Rlc1swXTtcbn1cbmZ1bmN0aW9uIHdyYXBJMThuUGxhY2Vob2xkZXIoY29udGVudCwgY29udGV4dElkKSB7XG4gICAgaWYgKGNvbnRleHRJZCA9PT0gdm9pZCAwKSB7IGNvbnRleHRJZCA9IDA7IH1cbiAgICB2YXIgYmxvY2tJZCA9IGNvbnRleHRJZCA+IDAgPyBcIjpcIiArIGNvbnRleHRJZCA6ICcnO1xuICAgIHJldHVybiBcIlwiICsgSTE4Tl9QTEFDRUhPTERFUl9TWU1CT0wgKyBjb250ZW50ICsgYmxvY2tJZCArIEkxOE5fUExBQ0VIT0xERVJfU1lNQk9MO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVJMThuQm91bmRTdHJpbmcoc3RyaW5ncywgYmluZGluZ1N0YXJ0SW5kZXgsIGNvbnRleHRJZCkge1xuICAgIGlmIChiaW5kaW5nU3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IGJpbmRpbmdTdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChjb250ZXh0SWQgPT09IHZvaWQgMCkgeyBjb250ZXh0SWQgPSAwOyB9XG4gICAgaWYgKCFzdHJpbmdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHZhciBhY2MgPSAnJztcbiAgICB2YXIgbGFzdElkeCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgICAgICBhY2MgKz0gXCJcIiArIHN0cmluZ3NbaV0gKyB3cmFwSTE4blBsYWNlaG9sZGVyKGJpbmRpbmdTdGFydEluZGV4ICsgaSwgY29udGV4dElkKTtcbiAgICB9XG4gICAgYWNjICs9IHN0cmluZ3NbbGFzdElkeF07XG4gICAgcmV0dXJuIGFjYztcbn1cbmZ1bmN0aW9uIGdldFNlcU51bWJlckdlbmVyYXRvcihzdGFydHNBdCkge1xuICAgIGlmIChzdGFydHNBdCA9PT0gdm9pZCAwKSB7IHN0YXJ0c0F0ID0gMDsgfVxuICAgIHZhciBjdXJyZW50ID0gc3RhcnRzQXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnJlbnQrKzsgfTtcbn1cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyc1RvUGFyYW1zKHBsYWNlaG9sZGVycykge1xuICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICBwbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBrZXkpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBsaXRlcmFsKHZhbHVlcy5sZW5ndGggPiAxID8gXCJbXCIgKyB2YWx1ZXMuam9pbignfCcpICsgXCJdXCIgOiB2YWx1ZXNbMF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlck1hcChtYXAsIG5hbWUpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFsdWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIF9fc3ByZWFkKHZhbHVlcykpO1xuICAgIG1hcC5zZXQobmFtZSwgY3VycmVudCk7XG59XG5mdW5jdGlvbiBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXRhLCBiaW5kaW5nU3RhcnRJbmRleCwgY29udGV4dElkKSB7XG4gICAgaWYgKGJpbmRpbmdTdGFydEluZGV4ID09PSB2b2lkIDApIHsgYmluZGluZ1N0YXJ0SW5kZXggPSAwOyB9XG4gICAgaWYgKGNvbnRleHRJZCA9PT0gdm9pZCAwKSB7IGNvbnRleHRJZCA9IDA7IH1cbiAgICB2YXIgc3RhcnRJZHggPSBiaW5kaW5nU3RhcnRJbmRleDtcbiAgICB2YXIgcGxhY2Vob2xkZXJzID0gbmV3IE1hcCgpO1xuICAgIHZhciBub2RlID0gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgPyBtZXRhLm5vZGVzLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb250YWluZXI7IH0pIDogbWV0YTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlXG4gICAgICAgICAgICAuY2hpbGRyZW5cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFBsYWNlaG9sZGVyOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gd3JhcEkxOG5QbGFjZWhvbGRlcihzdGFydElkeCArIGlkeCwgY29udGV4dElkKTtcbiAgICAgICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHBsYWNlaG9sZGVycywgY2hpbGQubmFtZSwgY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGxhY2Vob2xkZXJzO1xufVxuLyoqXG4gKiBGb3JtYXQgdGhlIHBsYWNlaG9sZGVyIG5hbWVzIGluIGEgbWFwIG9mIHBsYWNlaG9sZGVycyB0byBleHByZXNzaW9ucy5cbiAqXG4gKiBUaGUgcGxhY2Vob2xkZXIgbmFtZXMgYXJlIGNvbnZlcnRlZCBmcm9tIFwiaW50ZXJuYWxcIiBmb3JtYXQgKGUuZy4gYFNUQVJUX1RBR19ESVZfMWApIHRvIFwiZXh0ZXJuYWxcIlxuICogZm9ybWF0IChlLmcuIGBzdGFydFRhZ0Rpdl8xYCkuXG4gKlxuICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiBwbGFjZWhvbGRlciBuYW1lcyB0byBleHByZXNzaW9ucy5cbiAqIEBwYXJhbSB1c2VDYW1lbENhc2Ugd2hldGhlciB0byBjYW1lbENhc2UgdGhlIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiBmb3JtYXR0aW5nLlxuICogQHJldHVybnMgQSBuZXcgbWFwIG9mIGZvcm1hdHRlZCBwbGFjZWhvbGRlciBuYW1lcyB0byBleHByZXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gaTE4bkZvcm1hdFBsYWNlaG9sZGVyTmFtZXMocGFyYW1zLCB1c2VDYW1lbENhc2UpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICB2YXIgX3BhcmFtcyA9IHt9O1xuICAgIGlmIChwYXJhbXMgJiYgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF9wYXJhbXNbZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShrZXksIHVzZUNhbWVsQ2FzZSldID0gcGFyYW1zW2tleV07IH0pO1xuICAgIH1cbiAgICByZXR1cm4gX3BhcmFtcztcbn1cbi8qKlxuICogQ29udmVydHMgaW50ZXJuYWwgcGxhY2Vob2xkZXIgbmFtZXMgdG8gcHVibGljLWZhY2luZyBmb3JtYXRcbiAqIChmb3IgZXhhbXBsZSB0byB1c2UgaW4gZ29vZy5nZXRNc2cgY2FsbCkuXG4gKiBFeGFtcGxlOiBgU1RBUlRfVEFHX0RJVl8xYCBpcyBjb252ZXJ0ZWQgdG8gYHN0YXJ0VGFnRGl2XzFgLlxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBwbGFjZWhvbGRlciBuYW1lIHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZFxuICogQHJldHVybnMgRm9ybWF0dGVkIHBsYWNlaG9sZGVyIG5hbWVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShuYW1lLCB1c2VDYW1lbENhc2UpIHtcbiAgICBpZiAodXNlQ2FtZWxDYXNlID09PSB2b2lkIDApIHsgdXNlQ2FtZWxDYXNlID0gdHJ1ZTsgfVxuICAgIHZhciBwdWJsaWNOYW1lID0gdG9QdWJsaWNOYW1lKG5hbWUpO1xuICAgIGlmICghdXNlQ2FtZWxDYXNlKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNOYW1lO1xuICAgIH1cbiAgICB2YXIgY2h1bmtzID0gcHVibGljTmFtZS5zcGxpdCgnXycpO1xuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIG5vIFwiX1wiIGZvdW5kIC0ganVzdCBsb3dlcmNhc2UgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHZhciBwb3N0Zml4O1xuICAgIC8vIGVqZWN0IGxhc3QgZWxlbWVudCBpZiBpdCdzIGEgbnVtYmVyXG4gICAgaWYgKC9eXFxkKyQvLnRlc3QoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcG9zdGZpeCA9IGNodW5rcy5wb3AoKTtcbiAgICB9XG4gICAgdmFyIHJhdyA9IGNodW5rcy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3ICs9IGNodW5rcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7IH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdGZpeCA/IHJhdyArIFwiX1wiICsgcG9zdGZpeCA6IHJhdztcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcHJlZml4IGZvciB0cmFuc2xhdGlvbiBjb25zdCBuYW1lLlxuICpcbiAqIEBwYXJhbSBleHRyYSBBZGRpdGlvbmFsIGxvY2FsIHByZWZpeCB0aGF0IHNob3VsZCBiZSBpbmplY3RlZCBpbnRvIHRyYW5zbGF0aW9uIHZhciBuYW1lXG4gKiBAcmV0dXJucyBDb21wbGV0ZSB0cmFuc2xhdGlvbiBjb25zdCBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb25Db25zdFByZWZpeChleHRyYSkge1xuICAgIHJldHVybiAoXCJcIiArIENMT1NVUkVfVFJBTlNMQVRJT05fUFJFRklYICsgZXh0cmEpLnRvVXBwZXJDYXNlKCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIEFTVCB0byBkZWNsYXJlIGEgdmFyaWFibGUuIEUuZy4gYHZhciBJMThOXzE7YC5cbiAqIEBwYXJhbSB2YXJpYWJsZSB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gZGVjbGFyZS5cbiAqL1xuZnVuY3Rpb24gZGVjbGFyZUkxOG5WYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodmFyaWFibGUubmFtZSwgdW5kZWZpbmVkLCBJTkZFUlJFRF9UWVBFLCBudWxsLCB2YXJpYWJsZS5zb3VyY2VTcGFuKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3Qga2V5IGNvbnRhaW5zIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycywgdGh1cyB0aGUga2V5IHNob3VsZCBiZSB3cmFwcGVkIGluXG4gKiBxdW90ZXMuIE5vdGU6IHdlIGRvIG5vdCB3cmFwIGFsbCBrZXlzIGludG8gcXVvdGVzLCBhcyBpdCBtYXkgaGF2ZSBpbXBhY3Qgb24gbWluaWZpY2F0aW9uIGFuZCBtYXlcbiAqIGJvdCB3b3JrIGluIHNvbWUgY2FzZXMgd2hlbiBvYmplY3Qga2V5cyBhcmUgbWFuZ2xlZCBieSBtaW5pZmllci5cbiAqXG4gKiBUT0RPKEZXLTExMzYpOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgb2Ygd29ya2luZyB3aXRoXG4gKiBpbnB1dHMgdGhhdCBjb250YWluIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycy5cbiAqL1xudmFyIFVOU0FGRV9PQkpFQ1RfS0VZX05BTUVfUkVHRVhQID0gL1stLl0vO1xuLyoqIE5hbWUgb2YgdGhlIHRlbXBvcmFyeSB0byB1c2UgZHVyaW5nIGRhdGEgYmluZGluZyAqL1xudmFyIFRFTVBPUkFSWV9OQU1FID0gJ190Jztcbi8qKiBOYW1lIG9mIHRoZSBjb250ZXh0IHBhcmFtZXRlciBwYXNzZWQgaW50byBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG52YXIgQ09OVEVYVF9OQU1FID0gJ2N0eCc7XG4vKiogTmFtZSBvZiB0aGUgUmVuZGVyRmxhZyBwYXNzZWQgaW50byBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG52YXIgUkVOREVSX0ZMQUdTID0gJ3JmJztcbi8qKiBUaGUgcHJlZml4IHJlZmVyZW5jZSB2YXJpYWJsZXMgKi9cbnZhciBSRUZFUkVOQ0VfUFJFRklYID0gJ19yJztcbi8qKiBUaGUgbmFtZSBvZiB0aGUgaW1wbGljaXQgY29udGV4dCByZWZlcmVuY2UgKi9cbnZhciBJTVBMSUNJVF9SRUZFUkVOQ0UgPSAnJGltcGxpY2l0Jztcbi8qKiBOb24gYmluZGFibGUgYXR0cmlidXRlIG5hbWUgKiovXG52YXIgTk9OX0JJTkRBQkxFX0FUVFIgPSAnbmdOb25CaW5kYWJsZSc7XG4vKipcbiAqIENyZWF0ZXMgYW4gYWxsb2NhdG9yIGZvciBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAqXG4gKiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBzdGF0ZW1lbnRzIHRoZSBmaXJzdCB0aW1lIHRoZSBhbGxvY2F0b3IgaXMgaW52b2tlZC5cbiAqL1xuZnVuY3Rpb24gdGVtcG9yYXJ5QWxsb2NhdG9yKHN0YXRlbWVudHMsIG5hbWUpIHtcbiAgICB2YXIgdGVtcCA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IERlY2xhcmVWYXJTdG10KFRFTVBPUkFSWV9OQU1FLCB1bmRlZmluZWQsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgdGVtcCA9IHZhcmlhYmxlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG59XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChmZWF0dXJlKSB7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVpbGRlciBcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGRvZXNuJ3Qgc3VwcG9ydCBcIiArIGZlYXR1cmUgKyBcIiB5ZXRcIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZlYXR1cmUgXCIgKyBmZWF0dXJlICsgXCIgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7XG59XG5mdW5jdGlvbiBpbnZhbGlkJDEoYXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZTogVmlzaXRvciBcIiArIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiIGRvZXNuJ3QgaGFuZGxlIFwiICsgYXJnLmNvbnN0cnVjdG9yLm5hbWUpO1xufVxuZnVuY3Rpb24gYXNMaXRlcmFsKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKHZhbHVlLm1hcChhc0xpdGVyYWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdGVyYWwodmFsdWUsIElORkVSUkVEX1RZUEUpO1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwoa2V5cywga2VlcERlY2xhcmVkKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGtleXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1hcFRvRXhwcmVzc2lvbihrZXlzLCBrZWVwRGVjbGFyZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hcFRvRXhwcmVzc2lvbihtYXAsIGtlZXBEZWNsYXJlZCkge1xuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gY2Fub25pY2FsIHN5bnRheDogYGRpclByb3A6IHB1YmxpY1Byb3BgXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgICAgIHZhciBkZWNsYXJlZE5hbWU7XG4gICAgICAgIHZhciBwdWJsaWNOYW1lO1xuICAgICAgICB2YXIgbWluaWZpZWROYW1lO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIF9hID0gX19yZWFkKHZhbHVlLCAyKSwgcHVibGljTmFtZSA9IF9hWzBdLCBkZWNsYXJlZE5hbWUgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9iID0gX19yZWFkKHNwbGl0QXRDb2xvbihrZXksIFtrZXksIHZhbHVlXSksIDIpLCBkZWNsYXJlZE5hbWUgPSBfYlswXSwgcHVibGljTmFtZSA9IF9iWzFdO1xuICAgICAgICB9XG4gICAgICAgIG1pbmlmaWVkTmFtZSA9IGRlY2xhcmVkTmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogbWluaWZpZWROYW1lLFxuICAgICAgICAgICAgLy8gcHV0IHF1b3RlcyBhcm91bmQga2V5cyB0aGF0IGNvbnRhaW4gcG90ZW50aWFsbHkgdW5zYWZlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIHF1b3RlZDogVU5TQUZFX09CSkVDVF9LRVlfTkFNRV9SRUdFWFAudGVzdChtaW5pZmllZE5hbWUpLFxuICAgICAgICAgICAgdmFsdWU6IChrZWVwRGVjbGFyZWQgJiYgcHVibGljTmFtZSAhPT0gZGVjbGFyZWROYW1lKSA/XG4gICAgICAgICAgICAgICAgbGl0ZXJhbEFycihbYXNMaXRlcmFsKHB1YmxpY05hbWUpLCBhc0xpdGVyYWwoZGVjbGFyZWROYW1lKV0pIDpcbiAgICAgICAgICAgICAgICBhc0xpdGVyYWwocHVibGljTmFtZSlcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG4vKipcbiAqICBSZW1vdmUgdHJhaWxpbmcgbnVsbCBub2RlcyBhcyB0aGV5IGFyZSBpbXBsaWVkLlxuICovXG5mdW5jdGlvbiB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKSB7XG4gICAgd2hpbGUgKGlzTnVsbChwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnlQcmVkaWNhdGUocXVlcnksIGNvbnN0YW50UG9vbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5LnByZWRpY2F0ZSkpIHtcbiAgICAgICAgdmFyIHByZWRpY2F0ZV8xID0gW107XG4gICAgICAgIHF1ZXJ5LnByZWRpY2F0ZS5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gRWFjaCBpdGVtIGluIHByZWRpY2F0ZXMgYXJyYXkgbWF5IGNvbnRhaW4gc3RyaW5ncyB3aXRoIGNvbW1hLXNlcGFyYXRlZCByZWZzXG4gICAgICAgICAgICAvLyAoZm9yIGV4LiAncmVmLCByZWYxLCAuLi4sIHJlZk4nKSwgdGh1cyB3ZSBleHRyYWN0IGluZGl2aWR1YWwgcmVmcyBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgLy8gYXMgc2VwYXJhdGUgYXJyYXkgZW50aXRpZXNcbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSBzZWxlY3Rvci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIGxpdGVyYWwodG9rZW4udHJpbSgpKTsgfSk7XG4gICAgICAgICAgICBwcmVkaWNhdGVfMS5wdXNoLmFwcGx5KHByZWRpY2F0ZV8xLCBfX3NwcmVhZChzZWxlY3RvcnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIocHJlZGljYXRlXzEpLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBxdWVyeS5wcmVkaWNhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIERlZmluaXRpb25NYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmaW5pdGlvbk1hcCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgRGVmaW5pdGlvbk1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVmaW5pdGlvbk1hcC5wcm90b3R5cGUudG9MaXRlcmFsTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcCh0aGlzLnZhbHVlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmaW5pdGlvbk1hcDtcbn0oKSk7XG4vKipcbiAqIEV4dHJhY3QgYSBtYXAgb2YgcHJvcGVydGllcyB0byB2YWx1ZXMgZm9yIGEgZ2l2ZW4gZWxlbWVudCBvciB0ZW1wbGF0ZSBub2RlLCB3aGljaCBjYW4gYmUgdXNlZFxuICogYnkgdGhlIGRpcmVjdGl2ZSBtYXRjaGluZyBtYWNoaW5lcnkuXG4gKlxuICogQHBhcmFtIGVsT3JUcGwgdGhlIGVsZW1lbnQgb3IgdGVtcGxhdGUgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm4gYW4gb2JqZWN0IHNldCB1cCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nLiBGb3IgYXR0cmlidXRlcyBvbiB0aGUgZWxlbWVudC90ZW1wbGF0ZSwgdGhpc1xuICogb2JqZWN0IG1hcHMgYSBwcm9wZXJ0eSBuYW1lIHRvIGl0cyAoc3RhdGljKSB2YWx1ZS4gRm9yIGFueSBiaW5kaW5ncywgdGhpcyBtYXAgc2ltcGx5IG1hcHMgdGhlXG4gKiBwcm9wZXJ0eSBuYW1lIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cnNGb3JEaXJlY3RpdmVNYXRjaGluZyhlbE9yVHBsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXNNYXAgPSB7fTtcbiAgICBpZiAoZWxPclRwbCBpbnN0YW5jZW9mIFRlbXBsYXRlICYmIGVsT3JUcGwudGFnTmFtZSAhPT0gJ25nLXRlbXBsYXRlJykge1xuICAgICAgICBlbE9yVHBsLnRlbXBsYXRlQXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYXR0cmlidXRlc01hcFthLm5hbWVdID0gJyc7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWxPclRwbC5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIGlmICghaXNJMThuQXR0cmlidXRlKGEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzTWFwW2EubmFtZV0gPSBhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxPclRwbC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc01hcFtpLm5hbWVdID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICBlbE9yVHBsLm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgYXR0cmlidXRlc01hcFtvLm5hbWVdID0gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlc01hcDtcbn1cbi8qKiBSZXR1cm5zIGEgY2FsbCBleHByZXNzaW9uIHRvIGEgY2hhaW5lZCBpbnN0cnVjdGlvbiwgZS5nLiBgcHJvcGVydHkocGFyYW1zWzBdKShwYXJhbXNbMV0pYC4gKi9cbmZ1bmN0aW9uIGNoYWluZWRJbnN0cnVjdGlvbihyZWZlcmVuY2UsIGNhbGxzLCBzcGFuKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKHJlZmVyZW5jZSwgbnVsbCwgc3Bhbik7XG4gICAgaWYgKGNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uY2FsbEZuKGNhbGxzW2ldLCBzcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQWRkIGEgYmxhbmsgaW52b2NhdGlvbiwgaW4gY2FzZSB0aGUgYGNhbGxzYCBhcnJheSBpcyBlbXB0eS5cbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uY2FsbEZuKFtdLCBzcGFuKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb247XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWQgdG8gYmUgcGFzc2VkIHRvIGEgZ2VuZXJhdGVkIGluc3RydWN0aW9uIGluIHRoZSBjYXNlIG9mXG4gKiBpbnRlcnBvbGF0aW9uIGluc3RydWN0aW9ucy5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIGludGVycG9sYXRpb24gYXN0XG4gKi9cbmZ1bmN0aW9uIGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pIHtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBpbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zLCBzdHJpbmdzID0gaW50ZXJwb2xhdGlvbi5zdHJpbmdzO1xuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEgJiYgc3RyaW5ncy5sZW5ndGggPT09IDIgJiYgc3RyaW5nc1swXSA9PT0gJycgJiYgc3RyaW5nc1sxXSA9PT0gJycpIHtcbiAgICAgICAgLy8gSWYgdGhlIGludGVycG9sYXRpb24gaGFzIG9uZSBpbnRlcnBvbGF0ZWQgdmFsdWUsIGJ1dCB0aGUgcHJlZml4IGFuZCBzdWZmaXggYXJlIGJvdGggZW1wdHlcbiAgICAgICAgLy8gc3RyaW5ncywgd2Ugb25seSBwYXNzIG9uZSBhcmd1bWVudCwgdG8gYSBzcGVjaWFsIGluc3RydWN0aW9uIGxpa2UgYHByb3BlcnR5SW50ZXJwb2xhdGVgIG9yXG4gICAgICAgIC8vIGB0ZXh0SW50ZXJwb2xhdGVgLlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9ucy5sZW5ndGggKyBzdHJpbmdzLmxlbmd0aDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGU7XG4oZnVuY3Rpb24gKFIzRmFjdG9yeURlbGVnYXRlVHlwZSkge1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJDbGFzc1wiXSA9IDBdID0gXCJDbGFzc1wiO1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJGYWN0b3J5XCJdID0gMl0gPSBcIkZhY3RvcnlcIjtcbn0pKFIzRmFjdG9yeURlbGVnYXRlVHlwZSB8fCAoUjNGYWN0b3J5RGVsZWdhdGVUeXBlID0ge30pKTtcbnZhciBSM0ZhY3RvcnlUYXJnZXQ7XG4oZnVuY3Rpb24gKFIzRmFjdG9yeVRhcmdldCkge1xuICAgIFIzRmFjdG9yeVRhcmdldFtSM0ZhY3RvcnlUYXJnZXRbXCJEaXJlY3RpdmVcIl0gPSAwXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgUjNGYWN0b3J5VGFyZ2V0W1IzRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBSM0ZhY3RvcnlUYXJnZXRbUjNGYWN0b3J5VGFyZ2V0W1wiSW5qZWN0YWJsZVwiXSA9IDJdID0gXCJJbmplY3RhYmxlXCI7XG4gICAgUjNGYWN0b3J5VGFyZ2V0W1IzRmFjdG9yeVRhcmdldFtcIlBpcGVcIl0gPSAzXSA9IFwiUGlwZVwiO1xuICAgIFIzRmFjdG9yeVRhcmdldFtSM0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoUjNGYWN0b3J5VGFyZ2V0IHx8IChSM0ZhY3RvcnlUYXJnZXQgPSB7fSkpO1xuLyoqXG4gKiBSZXNvbHZlZCB0eXBlIG9mIGEgZGVwZW5kZW5jeS5cbiAqXG4gKiBPY2Nhc2lvbmFsbHksIGRlcGVuZGVuY2llcyB3aWxsIGhhdmUgc3BlY2lhbCBzaWduaWZpY2FuY2Ugd2hpY2ggaXMga25vd24gc3RhdGljYWxseS4gSW4gdGhhdFxuICogY2FzZSB0aGUgYFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZWAgaW5mb3JtcyB0aGUgZmFjdG9yeSBnZW5lcmF0b3IgdGhhdCBhIHBhcnRpY3VsYXIgZGVwZW5kZW5jeVxuICogc2hvdWxkIGJlIGdlbmVyYXRlZCBzcGVjaWFsbHkgKHVzdWFsbHkgYnkgY2FsbGluZyBhIHNwZWNpYWwgaW5qZWN0aW9uIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlXG4gKiBzdGFuZGFyZCBvbmUpLlxuICovXG52YXIgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlO1xuKGZ1bmN0aW9uIChSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIG5vcm1hbCB0b2tlbiBkZXBlbmRlbmN5LlxuICAgICAqL1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJUb2tlblwiXSA9IDBdID0gXCJUb2tlblwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZXBlbmRlbmN5IGlzIGZvciBhbiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBUaGUgdG9rZW4gZXhwcmVzc2lvbiBpcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAqL1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJBdHRyaWJ1dGVcIl0gPSAxXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgLyoqXG4gICAgICogSW5qZWN0aW5nIHRoZSBgQ2hhbmdlRGV0ZWN0b3JSZWZgIHRva2VuLiBOZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHdoZW4gaW5qZWN0ZWQgaW50byBhIHBpcGUuXG4gICAgICovXG4gICAgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlW1IzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtcIkNoYW5nZURldGVjdG9yUmVmXCJdID0gMl0gPSBcIkNoYW5nZURldGVjdG9yUmVmXCI7XG4gICAgLyoqXG4gICAgICogQW4gaW52YWxpZCBkZXBlbmRlbmN5IChubyB0b2tlbiBjb3VsZCBiZSBkZXRlcm1pbmVkKS4gQW4gZXJyb3Igc2hvdWxkIGJlIHRocm93biBhdCBydW50aW1lLlxuICAgICAqL1xuICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVbXCJJbnZhbGlkXCJdID0gM10gPSBcIkludmFsaWRcIjtcbn0pKFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZSB8fCAoUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlID0ge30pKTtcbi8qKlxuICogQ29uc3RydWN0IGEgZmFjdG9yeSBmdW5jdGlvbiBleHByZXNzaW9uIGZvciB0aGUgZ2l2ZW4gYFIzRmFjdG9yeU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihtZXRhKSB7XG4gICAgdmFyIHQgPSB2YXJpYWJsZSgndCcpO1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIGN0b3JEZXBzVHlwZSA9IE5PTkVfVFlQRTtcbiAgICAvLyBUaGUgdHlwZSB0byBpbnN0YW50aWF0ZSB2aWEgY29uc3RydWN0b3IgaW52b2NhdGlvbi4gSWYgdGhlcmUgaXMgbm8gZGVsZWdhdGVkIGZhY3RvcnksIG1lYW5pbmdcbiAgICAvLyB0aGlzIHR5cGUgaXMgYWx3YXlzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3IgaW52b2NhdGlvbiwgdGhlbiB0aGlzIGlzIHRoZSB0eXBlLXRvLWNyZWF0ZVxuICAgIC8vIHBhcmFtZXRlciBwcm92aWRlZCBieSB0aGUgdXNlciAodCkgaWYgc3BlY2lmaWVkLCBvciB0aGUgY3VycmVudCB0eXBlIGlmIG5vdC4gSWYgdGhlcmUgaXMgYVxuICAgIC8vIGRlbGVnYXRlZCBmYWN0b3J5ICh3aGljaCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3VycmVudCB0eXBlKSB0aGVuIHRoaXMgaXMgb25seSB0aGUgdHlwZS10by1cbiAgICAvLyBjcmVhdGUgcGFyYW1ldGVyICh0KS5cbiAgICB2YXIgdHlwZUZvckN0b3IgPSAhaXNEZWxlZ2F0ZWRNZXRhZGF0YShtZXRhKSA/XG4gICAgICAgIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIHQsIG1ldGEuaW50ZXJuYWxUeXBlKSA6XG4gICAgICAgIHQ7XG4gICAgdmFyIGN0b3JFeHByID0gbnVsbDtcbiAgICBpZiAobWV0YS5kZXBzICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIGEgY29uc3RydWN0b3IgKGVpdGhlciBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgZGVmaW5lZCkuXG4gICAgICAgIGlmIChtZXRhLmRlcHMgIT09ICdpbnZhbGlkJykge1xuICAgICAgICAgICAgY3RvckV4cHIgPSBuZXcgSW5zdGFudGlhdGVFeHByKHR5cGVGb3JDdG9yLCBpbmplY3REZXBlbmRlbmNpZXMobWV0YS5kZXBzLCBtZXRhLmluamVjdEZuLCBtZXRhLnRhcmdldCA9PT0gUjNGYWN0b3J5VGFyZ2V0LlBpcGUpKTtcbiAgICAgICAgICAgIGN0b3JEZXBzVHlwZSA9IGNyZWF0ZUN0b3JEZXBzVHlwZShtZXRhLmRlcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYmFzZUZhY3RvcnkgPSB2YXJpYWJsZShcIlxcdTAyNzVcIiArIG1ldGEubmFtZSArIFwiX0Jhc2VGYWN0b3J5XCIpO1xuICAgICAgICB2YXIgZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5nZXRJbmhlcml0ZWRGYWN0b3J5KTtcbiAgICAgICAgdmFyIGJhc2VGYWN0b3J5U3RtdCA9IGJhc2VGYWN0b3J5LnNldChnZXRJbmhlcml0ZWRGYWN0b3J5LmNhbGxGbihbbWV0YS5pbnRlcm5hbFR5cGVdKSlcbiAgICAgICAgICAgIC50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuRXhwb3J0ZWQsIFN0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYmFzZUZhY3RvcnlTdG10KTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY29uc3RydWN0b3IsIHVzZSB0aGUgYmFzZSBjbGFzcycgZmFjdG9yeSB0byBjb25zdHJ1Y3QgdHlwZUZvckN0b3IuXG4gICAgICAgIGN0b3JFeHByID0gYmFzZUZhY3RvcnkuY2FsbEZuKFt0eXBlRm9yQ3Rvcl0pO1xuICAgIH1cbiAgICB2YXIgY3RvckV4cHJGaW5hbCA9IGN0b3JFeHByO1xuICAgIHZhciBib2R5ID0gW107XG4gICAgdmFyIHJldEV4cHIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG1ha2VDb25kaXRpb25hbEZhY3Rvcnkobm9uQ3RvckV4cHIpIHtcbiAgICAgICAgdmFyIHIgPSB2YXJpYWJsZSgncicpO1xuICAgICAgICBib2R5LnB1c2goci5zZXQoTlVMTF9FWFBSKS50b0RlY2xTdG10KCkpO1xuICAgICAgICB2YXIgY3RvclN0bXQgPSBudWxsO1xuICAgICAgICBpZiAoY3RvckV4cHJGaW5hbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3RvclN0bXQgPSByLnNldChjdG9yRXhwckZpbmFsKS50b1N0bXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0b3JTdG10ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmludmFsaWRGYWN0b3J5KS5jYWxsRm4oW10pLnRvU3RtdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChpZlN0bXQodCwgW2N0b3JTdG10XSwgW3Iuc2V0KG5vbkN0b3JFeHByKS50b1N0bXQoKV0pKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGlmIChpc0RlbGVnYXRlZE1ldGFkYXRhKG1ldGEpICYmIG1ldGEuZGVsZWdhdGVUeXBlID09PSBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuRmFjdG9yeSkge1xuICAgICAgICB2YXIgZGVsZWdhdGVGYWN0b3J5ID0gdmFyaWFibGUoXCJcXHUwMjc1XCIgKyBtZXRhLm5hbWUgKyBcIl9CYXNlRmFjdG9yeVwiKTtcbiAgICAgICAgdmFyIGdldEZhY3RvcnlPZiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5nZXRGYWN0b3J5T2YpO1xuICAgICAgICBpZiAobWV0YS5kZWxlZ2F0ZS5pc0VxdWl2YWxlbnQobWV0YS5pbnRlcm5hbFR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBjb21waWxpbmcgZmFjdG9yeSB0aGF0IGRlbGVnYXRlcyB0byBpdHNlbGZcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGVnYXRlRmFjdG9yeVN0bXQgPSBkZWxlZ2F0ZUZhY3Rvcnkuc2V0KGdldEZhY3RvcnlPZi5jYWxsRm4oW21ldGEuZGVsZWdhdGVdKSkudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBbXG4gICAgICAgICAgICBTdG10TW9kaWZpZXIuRXhwb3J0ZWQsIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICBdKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGRlbGVnYXRlRmFjdG9yeVN0bXQpO1xuICAgICAgICByZXRFeHByID0gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShkZWxlZ2F0ZUZhY3RvcnkuY2FsbEZuKFtdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVsZWdhdGVkTWV0YWRhdGEobWV0YSkpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlIGlzIGNyZWF0ZWQgd2l0aCBhIGRlbGVnYXRlZCBmYWN0b3J5LiBJZiBhIHR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxcbiAgICAgICAgLy8gdGhlIGZhY3RvcnkgaW5zdGVhZC5cbiAgICAgICAgdmFyIGRlbGVnYXRlQXJncyA9IGluamVjdERlcGVuZGVuY2llcyhtZXRhLmRlbGVnYXRlRGVwcywgbWV0YS5pbmplY3RGbiwgbWV0YS50YXJnZXQgPT09IFIzRmFjdG9yeVRhcmdldC5QaXBlKTtcbiAgICAgICAgLy8gRWl0aGVyIGNhbGwgYG5ldyBkZWxlZ2F0ZSguLi4pYCBvciBgZGVsZWdhdGUoLi4uKWAgZGVwZW5kaW5nIG9uIG1ldGEuZGVsZWdhdGVUeXBlLlxuICAgICAgICB2YXIgZmFjdG9yeUV4cHIgPSBuZXcgKG1ldGEuZGVsZWdhdGVUeXBlID09PSBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuQ2xhc3MgP1xuICAgICAgICAgICAgSW5zdGFudGlhdGVFeHByIDpcbiAgICAgICAgICAgIEludm9rZUZ1bmN0aW9uRXhwcikobWV0YS5kZWxlZ2F0ZSwgZGVsZWdhdGVBcmdzKTtcbiAgICAgICAgcmV0RXhwciA9IG1ha2VDb25kaXRpb25hbEZhY3RvcnkoZmFjdG9yeUV4cHIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0V4cHJlc3Npb25GYWN0b3J5TWV0YWRhdGEobWV0YSkpIHtcbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBkZWNpZGUgd2hldGhlciB0byBsb3dlciB0aGUgdmFsdWUgaGVyZSBvciBpbiB0aGUgY2FsbGVyXG4gICAgICAgIHJldEV4cHIgPSBtYWtlQ29uZGl0aW9uYWxGYWN0b3J5KG1ldGEuZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXRFeHByID0gY3RvckV4cHI7XG4gICAgfVxuICAgIGlmIChyZXRFeHByICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KHJldEV4cHIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuaW52YWxpZEZhY3RvcnkpLmNhbGxGbihbXSkudG9TdG10KCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmYWN0b3J5OiBmbihbbmV3IEZuUGFyYW0oJ3QnLCBEWU5BTUlDX1RZUEUpXSwgYm9keSwgSU5GRVJSRURfVFlQRSwgdW5kZWZpbmVkLCBtZXRhLm5hbWUgKyBcIl9GYWN0b3J5XCIpLFxuICAgICAgICBzdGF0ZW1lbnRzOiBzdGF0ZW1lbnRzLFxuICAgICAgICB0eXBlOiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuRmFjdG9yeURlZiwgW3R5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCksIGN0b3JEZXBzVHlwZV0pKVxuICAgIH07XG59XG5mdW5jdGlvbiBpbmplY3REZXBlbmRlbmNpZXMoZGVwcywgaW5qZWN0Rm4sIGlzUGlwZSkge1xuICAgIHJldHVybiBkZXBzLm1hcChmdW5jdGlvbiAoZGVwLCBpbmRleCkgeyByZXR1cm4gY29tcGlsZUluamVjdERlcGVuZGVuY3koZGVwLCBpbmplY3RGbiwgaXNQaXBlLCBpbmRleCk7IH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZUluamVjdERlcGVuZGVuY3koZGVwLCBpbmplY3RGbiwgaXNQaXBlLCBpbmRleCkge1xuICAgIC8vIEludGVycHJldCB0aGUgZGVwZW5kZW5jeSBhY2NvcmRpbmcgdG8gaXRzIHJlc29sdmVkIHR5cGUuXG4gICAgc3dpdGNoIChkZXAucmVzb2x2ZWQpIHtcbiAgICAgICAgY2FzZSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuVG9rZW46XG4gICAgICAgIGNhc2UgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkNoYW5nZURldGVjdG9yUmVmOlxuICAgICAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGluamVjdGlvbiBmbGFncyBhY2NvcmRpbmcgdG8gdGhlIG1ldGFkYXRhLlxuICAgICAgICAgICAgdmFyIGZsYWdzID0gMCAvKiBEZWZhdWx0ICovIHwgKGRlcC5zZWxmID8gMiAvKiBTZWxmICovIDogMCkgfFxuICAgICAgICAgICAgICAgIChkZXAuc2tpcFNlbGYgPyA0IC8qIFNraXBTZWxmICovIDogMCkgfCAoZGVwLmhvc3QgPyAxIC8qIEhvc3QgKi8gOiAwKSB8XG4gICAgICAgICAgICAgICAgKGRlcC5vcHRpb25hbCA/IDggLyogT3B0aW9uYWwgKi8gOiAwKTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZGVwZW5kZW5jeSBpcyBvcHRpb25hbCBvciBvdGhlcndpc2UgaGFzIG5vbi1kZWZhdWx0IGZsYWdzLCB0aGVuIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vIHBhcmFtZXRlcnMgZGVzY3JpYmluZyBob3cgdG8gaW5qZWN0IHRoZSBkZXBlbmRlbmN5IG11c3QgYmUgcGFzc2VkIHRvIHRoZSBpbmplY3QgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIHRoYXQncyBiZWluZyB1c2VkLlxuICAgICAgICAgICAgdmFyIGZsYWdzUGFyYW0gPSAoZmxhZ3MgIT09IDAgLyogRGVmYXVsdCAqLyB8fCBkZXAub3B0aW9uYWwpID8gbGl0ZXJhbChmbGFncykgOiBudWxsO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNlcGFyYXRlIGluc3RydWN0aW9uIGZvciBpbmplY3RpbmcgQ2hhbmdlRGV0ZWN0b3JSZWYgaW50byBhIHBpcGUuXG4gICAgICAgICAgICBpZiAoaXNQaXBlICYmIGRlcC5yZXNvbHZlZCA9PT0gUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkNoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5pbmplY3RQaXBlQ2hhbmdlRGV0ZWN0b3JSZWYpLmNhbGxGbihmbGFnc1BhcmFtID8gW2ZsYWdzUGFyYW1dIDogW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGFyZ3VtZW50cyB0byB0aGUgaW5qZWN0Rm4gY2FsbC5cbiAgICAgICAgICAgIHZhciBpbmplY3RBcmdzID0gW2RlcC50b2tlbl07XG4gICAgICAgICAgICBpZiAoZmxhZ3NQYXJhbSkge1xuICAgICAgICAgICAgICAgIGluamVjdEFyZ3MucHVzaChmbGFnc1BhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKGluamVjdEZuKS5jYWxsRm4oaW5qZWN0QXJncyk7XG4gICAgICAgIGNhc2UgUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlLkF0dHJpYnV0ZTpcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGF0dHJpYnV0ZXMsIHRoZSBhdHRyaWJ1dGUgbmFtZSBpbiBxdWVzdGlvbiBpcyBnaXZlbiBhcyB0aGUgdG9rZW4uXG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmluamVjdEF0dHJpYnV0ZSkuY2FsbEZuKFtkZXAudG9rZW5dKTtcbiAgICAgICAgY2FzZSBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuSW52YWxpZDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuaW52YWxpZEZhY3RvcnlEZXApLmNhbGxGbihbbGl0ZXJhbChpbmRleCldKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bnN1cHBvcnRlZChcIlVua25vd24gUjNSZXNvbHZlZERlcGVuZGVuY3lUeXBlOiBcIiArIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZVtkZXAucmVzb2x2ZWRdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDdG9yRGVwc1R5cGUoZGVwcykge1xuICAgIHZhciBoYXNUeXBlcyA9IGZhbHNlO1xuICAgIHZhciBhdHRyaWJ1dGVUeXBlcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBjcmVhdGVDdG9yRGVwVHlwZShkZXApO1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzVHlwZXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbChudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYXNUeXBlcykge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycihhdHRyaWJ1dGVUeXBlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE5PTkVfVFlQRTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDdG9yRGVwVHlwZShkZXApIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGlmIChkZXAucmVzb2x2ZWQgPT09IFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5BdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGRlcC5hdHRyaWJ1dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ2F0dHJpYnV0ZScsIHZhbHVlOiBkZXAuYXR0cmlidXRlLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkZXAub3B0aW9uYWwpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnb3B0aW9uYWwnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5ob3N0KSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ2hvc3QnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5zZWxmKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ3NlbGYnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5za2lwU2VsZikge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdza2lwU2VsZicsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcy5sZW5ndGggPiAwID8gbGl0ZXJhbE1hcChlbnRyaWVzKSA6IG51bGw7XG59XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHVzZWZ1bCBmb3IgZXh0cmFjdGluZyBgUjNEZXBlbmRlbmN5TWV0YWRhdGFgIGZyb20gYSBSZW5kZXIyXG4gKiBgQ29tcGlsZVR5cGVNZXRhZGF0YWAgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZGVuY2llc0Zyb21HbG9iYWxNZXRhZGF0YSh0eXBlLCBvdXRwdXRDdHgsIHJlZmxlY3Rvcikge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIC8vIFVzZSB0aGUgYENvbXBpbGVSZWZsZWN0b3JgIHRvIGxvb2sgdXAgcmVmZXJlbmNlcyB0byBzb21lIHdlbGwta25vd24gQW5ndWxhciB0eXBlcy4gVGhlc2Ugd2lsbFxuICAgIC8vIGJlIGNvbXBhcmVkIHdpdGggdGhlIHRva2VuIHRvIHN0YXRpY2FsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHRva2VuIGhhcyBzaWduaWZpY2FuY2UgdG9cbiAgICAvLyBBbmd1bGFyLCBhbmQgc2V0IHRoZSBjb3JyZWN0IGBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGVgIGFzIGEgcmVzdWx0LlxuICAgIHZhciBpbmplY3RvclJlZiA9IHJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpO1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgdHlwZSdzIERJIGRlcGVuZGVuY2llcyBhbmQgcHJvZHVjZSBgUjNEZXBlbmRlbmN5TWV0YWRhdGFgIGZvciBlYWNoIG9mIHRoZW0uXG4gICAgdmFyIGRlcHMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHR5cGUuZGlEZXBzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5LnRva2VuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuUmVmID0gdG9rZW5SZWZlcmVuY2UoZGVwZW5kZW5jeS50b2tlbik7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZGVwZW5kZW5jeS5pc0F0dHJpYnV0ZSA/XG4gICAgICAgICAgICAgICAgICAgIFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5BdHRyaWJ1dGUgOlxuICAgICAgICAgICAgICAgICAgICBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUuVG9rZW47XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgbW9zdCBkZXBlbmRlbmNpZXMsIHRoZSB0b2tlbiB3aWxsIGJlIGEgcmVmZXJlbmNlIHRvIGEgdHlwZS4gU29tZXRpbWVzLFxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGl0IGNhbiBiZSBhIHN0cmluZywgaW4gdGhlIGNhc2Ugb2Ygb2xkZXIgQW5ndWxhciBjb2RlIG9yIEBBdHRyaWJ1dGUgaW5qZWN0aW9uLlxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuUmVmIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sID8gb3V0cHV0Q3R4LmltcG9ydEV4cHIodG9rZW5SZWYpIDogbGl0ZXJhbCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBkZXBlbmRlbmN5LlxuICAgICAgICAgICAgICAgIGRlcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6ICEhZGVwZW5kZW5jeS5pc0hvc3QsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiAhIWRlcGVuZGVuY3kuaXNPcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZjogISFkZXBlbmRlbmN5LmlzU2VsZixcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNlbGY6ICEhZGVwZW5kZW5jeS5pc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWQoJ2RlcGVuZGVuY3kgd2l0aG91dCBhIHRva2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBkZXBzO1xufVxuZnVuY3Rpb24gaXNEZWxlZ2F0ZWRNZXRhZGF0YShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEuZGVsZWdhdGVUeXBlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GYWN0b3J5TWV0YWRhdGEobWV0YSkge1xuICAgIHJldHVybiBtZXRhLmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gY29tcGlsZUluamVjdGFibGUobWV0YSkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgIHZhciBmYWN0b3J5TWV0YSA9IHtcbiAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICB0eXBlOiBtZXRhLnR5cGUsXG4gICAgICAgIGludGVybmFsVHlwZTogbWV0YS5pbnRlcm5hbFR5cGUsXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiBtZXRhLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICBkZXBzOiBbXSxcbiAgICAgICAgaW5qZWN0Rm46IElkZW50aWZpZXJzLmluamVjdCxcbiAgICAgICAgdGFyZ2V0OiBSM0ZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSxcbiAgICB9O1xuICAgIGlmIChtZXRhLnVzZUNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbWV0YS51c2VDbGFzcyBoYXMgdHdvIG1vZGVzIG9mIG9wZXJhdGlvbi4gRWl0aGVyIGRlcHMgYXJlIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSBgbmV3YCBpc1xuICAgICAgICAvLyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBjbGFzcyB3aXRoIGRlcGVuZGVuY2llcyBpbmplY3RlZCwgb3IgZGVwcyBhcmUgbm90IHNwZWNpZmllZCBhbmRcbiAgICAgICAgLy8gdGhlIGZhY3Rvcnkgb2YgdGhlIGNsYXNzIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgc3BlY2lhbCBjYXNlIGV4aXN0cyBmb3IgdXNlQ2xhc3M6IFR5cGUgd2hlcmUgVHlwZSBpcyB0aGUgaW5qZWN0YWJsZSB0eXBlIGl0c2VsZiBhbmQgbm9cbiAgICAgICAgLy8gZGVwcyBhcmUgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlICd1c2VDbGFzcycgaXMgZWZmZWN0aXZlbHkgaWdub3JlZC5cbiAgICAgICAgdmFyIHVzZUNsYXNzT25TZWxmID0gbWV0YS51c2VDbGFzcy5pc0VxdWl2YWxlbnQobWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgICAgICB2YXIgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1ldGEudXNlckRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVwcyA9IG1ldGEudXNlckRlcHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmFjdG9yeTogKCkgPT4gbmV3IG1ldGEudXNlQ2xhc3MoLi4uZGVwcylcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oX19hc3NpZ24oX19hc3NpZ24oe30sIGZhY3RvcnlNZXRhKSwgeyBkZWxlZ2F0ZTogbWV0YS51c2VDbGFzcywgZGVsZWdhdGVEZXBzOiBkZXBzLCBkZWxlZ2F0ZVR5cGU6IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5DbGFzcyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXNlQ2xhc3NPblNlbGYpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oZmFjdG9yeU1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVsZWdhdGVUb0ZhY3RvcnkobWV0YS50eXBlLnZhbHVlLCBtZXRhLnVzZUNsYXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhLnVzZUZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobWV0YS51c2VyRGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmYWN0b3J5TWV0YSksIHsgZGVsZWdhdGU6IG1ldGEudXNlRmFjdG9yeSwgZGVsZWdhdGVEZXBzOiBtZXRhLnVzZXJEZXBzIHx8IFtdLCBkZWxlZ2F0ZVR5cGU6IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5GdW5jdGlvbiB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgZmFjdG9yeTogZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KG1ldGEudXNlRmFjdG9yeS5jYWxsRm4oW10pKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudXNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOb3RlOiBpdCdzIHNhZmUgdG8gdXNlIGBtZXRhLnVzZVZhbHVlYCBpbnN0ZWFkIG9mIHRoZSBgVVNFX1ZBTFVFIGluIG1ldGFgIGNoZWNrIHVzZWQgZm9yXG4gICAgICAgIC8vIGNsaWVudCBjb2RlIGJlY2F1c2UgbWV0YS51c2VWYWx1ZSBpcyBhbiBFeHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgZGVmaW5lZCBldmVuIGlmIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmYWN0b3J5TWV0YSksIHsgZXhwcmVzc2lvbjogbWV0YS51c2VWYWx1ZSB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudXNlRXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1c2VFeGlzdGluZyBpcyBhbiBgaW5qZWN0YCBjYWxsIG9uIHRoZSBleGlzdGluZyB0b2tlbi5cbiAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmFjdG9yeU1ldGEpLCB7IGV4cHJlc3Npb246IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW5qZWN0KS5jYWxsRm4oW21ldGEudXNlRXhpc3RpbmddKSB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBkZWxlZ2F0ZVRvRmFjdG9yeShtZXRhLnR5cGUudmFsdWUsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICB9XG4gICAgdmFyIHRva2VuID0gbWV0YS5pbnRlcm5hbFR5cGU7XG4gICAgdmFyIGluamVjdGFibGVQcm9wcyA9IHsgdG9rZW46IHRva2VuLCBmYWN0b3J5OiByZXN1bHQuZmFjdG9yeSB9O1xuICAgIC8vIE9ubHkgZ2VuZXJhdGUgcHJvdmlkZWRJbiBwcm9wZXJ0eSBpZiBpdCBoYXMgYSBub24tbnVsbCB2YWx1ZVxuICAgIGlmIChtZXRhLnByb3ZpZGVkSW4udmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5qZWN0YWJsZVByb3BzLnByb3ZpZGVkSW4gPSBtZXRhLnByb3ZpZGVkSW47XG4gICAgfVxuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy7Jtcm1ZGVmaW5lSW5qZWN0YWJsZSkuY2FsbEZuKFttYXBUb01hcEV4cHJlc3Npb24oaW5qZWN0YWJsZVByb3BzKV0pO1xuICAgIHZhciB0eXBlID0gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSW5qZWN0YWJsZURlZiwgW3R5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgc3RhdGVtZW50czogcmVzdWx0LnN0YXRlbWVudHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlbGVnYXRlVG9GYWN0b3J5KHR5cGUsIGludGVybmFsVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXRlbWVudHM6IFtdLFxuICAgICAgICAvLyBJZiB0eXBlcyBhcmUgdGhlIHNhbWUsIHdlIGNhbiBnZW5lcmF0ZSBgZmFjdG9yeTogdHlwZS7JtWZhY2BcbiAgICAgICAgLy8gSWYgdHlwZXMgYXJlIGRpZmZlcmVudCwgd2UgaGF2ZSB0byBnZW5lcmF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBpbnRlcm5hbCB0eXBlIGhhcyBiZWVuIHJlc29sdmVkIChgZmFjdG9yeTogZnVuY3Rpb24odCkgeyByZXR1cm4gdHlwZS7JtWZhYyh0KTsgfWApXG4gICAgICAgIGZhY3Rvcnk6IHR5cGUubm9kZSA9PT0gaW50ZXJuYWxUeXBlLm5vZGUgP1xuICAgICAgICAgICAgaW50ZXJuYWxUeXBlLnByb3AoJ8m1ZmFjJykgOlxuICAgICAgICAgICAgZm4oW25ldyBGblBhcmFtKCd0JywgRFlOQU1JQ19UWVBFKV0sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGludGVybmFsVHlwZS5jYWxsTWV0aG9kKCfJtWZhYycsIFt2YXJpYWJsZSgndCcpXSkpXSlcbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBhc3NlcnRBcnJheU9mU3RyaW5ncyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIFVOVVNBQkxFX0lOVEVSUE9MQVRJT05fUkVHRVhQUyA9IFtcbiAgICAvXlxccyokLyxcbiAgICAvWzw+XS8sXG4gICAgL15be31dJC8sXG4gICAgLyYoI3xbYS16XSkvaSxcbiAgICAvXlxcL1xcLy8sXG5dO1xuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5LCBbc3RhcnQsIGVuZF0uXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzdGFydF8xID0gdmFsdWVbMF07XG4gICAgICAgIHZhciBlbmRfMSA9IHZhbHVlWzFdO1xuICAgICAgICAvLyBDaGVjayBmb3IgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2xzXG4gICAgICAgIFVOVVNBQkxFX0lOVEVSUE9MQVRJT05fUkVHRVhQUy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydF8xKSB8fCByZWdleHAudGVzdChlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbJ1wiICsgc3RhcnRfMSArIFwiJywgJ1wiICsgZW5kXzEgKyBcIiddIGNvbnRhaW5zIHVudXNhYmxlIGludGVycG9sYXRpb24gc3ltYm9sLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSW50ZXJwb2xhdGlvbkNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkgPSBmdW5jdGlvbiAobWFya2Vycykge1xuICAgICAgICBpZiAoIW1hcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgbWFya2Vycyk7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnO1xufSgpKTtcbnZhciBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHID0gbmV3IEludGVycG9sYXRpb25Db25maWcoJ3t7JywgJ319Jyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdFxudmFyIFZFUlNJT04gPSAzO1xudmFyIEpTX0I2NF9QUkVGSVggPSAnIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJztcbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUgPT09IHZvaWQgMCkgeyBmaWxlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICB0aGlzLmhhc01hcHBpbmdzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZSBjb250ZW50IGlzIGBudWxsYCB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGVjdGVkIHRvIGJlIGxvYWRlZCB1c2luZyB0aGUgVVJMXG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAodXJsLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09PSB2b2lkIDApIHsgY29udGVudCA9IG51bGw7IH1cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyh1cmwpKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50LnNldCh1cmwsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpbmVzLnB1c2goW10pO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPSBmdW5jdGlvbiAoY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudExpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbGluZSBtdXN0IGJlIGFkZGVkIGJlZm9yZSBtYXBwaW5ncyBjYW4gYmUgYWRkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAhPSBudWxsICYmICF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyhzb3VyY2VVcmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNvdXJjZSBmaWxlIFxcXCJcIiArIHNvdXJjZVVybCArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29sdW1uIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwIDwgdGhpcy5sYXN0Q29sMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFwcGluZyBzaG91bGQgYmUgYWRkZWQgaW4gb3V0cHV0IG9yZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgJiYgKHNvdXJjZUxpbmUwID09IG51bGwgfHwgc291cmNlQ29sMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNvdXJjZSBsb2NhdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYSBzb3VyY2UgdXJsIGlzIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gY29sMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZS5wdXNoKHsgY29sMDogY29sMCwgc291cmNlVXJsOiBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwOiBzb3VyY2VMaW5lMCwgc291cmNlQ29sMDogc291cmNlQ29sMCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZSwgXCJjdXJyZW50TGluZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM2MjE2XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5oYXNNYXBwaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5zb3VyY2VzQ29udGVudC5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKHVybCwgaSkge1xuICAgICAgICAgICAgc291cmNlc0luZGV4LnNldCh1cmwsIGkpO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHVybCk7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudC5wdXNoKF90aGlzLnNvdXJjZXNDb250ZW50LmdldCh1cmwpIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcHBpbmdzID0gJyc7XG4gICAgICAgIHZhciBsYXN0Q29sMCA9IDA7XG4gICAgICAgIHZhciBsYXN0U291cmNlSW5kZXggPSAwO1xuICAgICAgICB2YXIgbGFzdFNvdXJjZUxpbmUwID0gMDtcbiAgICAgICAgdmFyIGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50cykge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIHNlZ0FzU3RyID0gdG9CYXNlNjRWTFEoc2VnbWVudC5jb2wwIC0gbGFzdENvbDApO1xuICAgICAgICAgICAgICAgIGxhc3RDb2wwID0gc2VnbWVudC5jb2wwO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnNvdXJjZVVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgaW5kZXggaW50byB0aGUg4oCcc291cmNlc+KAnSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0Jhc2U2NFZMUShzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSAtIGxhc3RTb3VyY2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VJbmRleCA9IHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VMaW5lMCAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9IHNlZ21lbnQuc291cmNlTGluZTA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9IHRvQmFzZTY0VkxRKHNlZ21lbnQuc291cmNlQ29sMCAtIGxhc3RTb3VyY2VDb2wwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUNvbDAgPSBzZWdtZW50LnNvdXJjZUNvbDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdBc1N0cjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9ICc7JztcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3Muc2xpY2UoMCwgLTEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2ZpbGUnOiB0aGlzLmZpbGUgfHwgJycsXG4gICAgICAgICAgICAndmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnc291cmNlUm9vdCc6ICcnLFxuICAgICAgICAgICAgJ3NvdXJjZXMnOiBzb3VyY2VzLFxuICAgICAgICAgICAgJ3NvdXJjZXNDb250ZW50Jzogc291cmNlc0NvbnRlbnQsXG4gICAgICAgICAgICAnbWFwcGluZ3MnOiBtYXBwaW5ncyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9Kc0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xufSgpKTtcbmZ1bmN0aW9uIHRvQmFzZTY0U3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGI2NCA9ICcnO1xuICAgIHZhbHVlID0gdXRmOEVuY29kZSh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBpMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIGkyID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICB2YXIgaTMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaXNOYU4oaTIpID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGlzTmFOKGkyKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgfHwgaXNOYU4oaTMpID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VkxRKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSA8IDAgPyAoKC12YWx1ZSkgPDwgMSkgKyAxIDogdmFsdWUgPDwgMTtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZG8ge1xuICAgICAgICB2YXIgZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxudmFyIEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5mdW5jdGlvbiB0b0Jhc2U2NERpZ2l0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBlbmNvZGUgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCA2M11cIik7XG4gICAgfVxuICAgIHJldHVybiBCNjRfRElHSVRTW3ZhbHVlXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbnZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xudmFyIF9JTkRFTlRfV0lUSCA9ICcgICc7XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSB2YXJpYWJsZSgnZXJyb3InLCBudWxsLCBudWxsKTtcbnZhciBDQVRDSF9TVEFDS19WQVIkMSA9IHZhcmlhYmxlKCdzdGFjaycsIG51bGwsIG51bGwpO1xudmFyIF9FbWl0dGVkTGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB0aGlzLnBhcnRzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNyY1NwYW5zID0gW107XG4gICAgfVxuICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG59KCkpO1xudmFyIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2luZGVudCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgIHRoaXMuX3ByZWFtYmxlTGluZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbbmV3IF9FbWl0dGVkTGluZShfaW5kZW50KV07XG4gICAgfVxuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dCgwKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcIl9jdXJyZW50TGluZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM2MjE2XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lc1t0aGlzLl9saW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludGxuID0gZnVuY3Rpb24gKGZyb20sIGxhc3RQYXJ0KSB7XG4gICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgdGhpcy5wcmludChmcm9tIHx8IG51bGwsIGxhc3RQYXJ0LCB0cnVlKTtcbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUubGluZUlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoICsgdGhpcy5fY3VycmVudExpbmUucGFydHNMZW5ndGg7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKGZyb20sIHBhcnQsIG5ld0xpbmUpIHtcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzTGVuZ3RoICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuc3JjU3BhbnMucHVzaChmcm9tICYmIGZyb20uc291cmNlU3BhbiB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucHVzaChuZXcgX0VtaXR0ZWRMaW5lKHRoaXMuX2luZGVudCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnJlbW92ZUVtcHR5TGFzdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmluY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5kZWNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudC0tO1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHVzaENsYXNzID0gZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIHRoaXMuX2NsYXNzZXMucHVzaChjbGF6eik7XG4gICAgfTtcbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnBvcENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5wb3AoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcImN1cnJlbnRDbGFzc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUxpbmVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnBhcnRzLmxlbmd0aCA+IDAgPyBfY3JlYXRlSW5kZW50KGwuaW5kZW50KSArIGwucGFydHMuam9pbignJykgOiAnJzsgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2VNYXBHZW5lcmF0b3IgPSBmdW5jdGlvbiAoZ2VuRmlsZVBhdGgsIHN0YXJ0c0F0TGluZSkge1xuICAgICAgICBpZiAoc3RhcnRzQXRMaW5lID09PSB2b2lkIDApIHsgc3RhcnRzQXRMaW5lID0gMDsgfVxuICAgICAgICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCk7XG4gICAgICAgIHZhciBmaXJzdE9mZnNldE1hcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RPZmZzZXRNYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzaW5nbGUgc3BhY2Ugc28gdGhhdCB0b29scyB3b24ndCB0cnkgdG8gbG9hZCB0aGUgZmlsZSBmcm9tIGRpc2suXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgYXJlIHVzaW5nIHZpcnR1YWwgdXJscyBsaWtlIGBuZzovLy9gLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gcHJvdmlkZSBhIGNvbnRlbnQgaGVyZS5cbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKGdlbkZpbGVQYXRoLCAnICcpLmFkZE1hcHBpbmcoMCwgZ2VuRmlsZVBhdGgsIDAsIDApO1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydHNBdExpbmU7IGkrKykge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGxpbmVJZHgpIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaW5lKCk7XG4gICAgICAgICAgICB2YXIgc3BhbnMgPSBsaW5lLnNyY1NwYW5zO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gbGluZS5wYXJ0cztcbiAgICAgICAgICAgIHZhciBjb2wwID0gbGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNwYW5JZHggPSAwO1xuICAgICAgICAgICAgLy8gc2tpcCBsZWFkaW5nIHBhcnRzIHdpdGhvdXQgc291cmNlIHNwYW5zXG4gICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiAhc3BhbnNbc3BhbklkeF0pIHtcbiAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiBsaW5lSWR4ID09PSAwICYmIGNvbDAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBGaXJzdE9mZnNldElmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGFuID0gc3BhbnNbc3BhbklkeF07XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNwYW4uc3RhcnQuZmlsZTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlTGluZSA9IHNwYW4uc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sID0gc3Bhbi5zdGFydC5jb2w7XG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShzb3VyY2UudXJsLCBzb3VyY2UuY29udGVudClcbiAgICAgICAgICAgICAgICAgICAgLmFkZE1hcHBpbmcoY29sMCwgc291cmNlLnVybCwgc291cmNlTGluZSwgc291cmNlQ29sKTtcbiAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIHBhcnRzIHdpdGhvdXQgc3BhbiBvciB0aGUgc2FtZSBzcGFuIHRvIHRoZSBwcmV2aW91cyBzZWdtZW50XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwYW5JZHggPCBzcGFucy5sZW5ndGggJiYgKHNwYW4gPT09IHNwYW5zW3NwYW5JZHhdIHx8ICFzcGFuc1tzcGFuSWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH07XG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5zZXRQcmVhbWJsZUxpbmVDb3VudCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlYW1ibGVMaW5lQ291bnQgPSBjb3VudDtcbiAgICB9O1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuc3Bhbk9mID0gZnVuY3Rpb24gKGxpbmUsIGNvbHVtbikge1xuICAgICAgICB2YXIgZW1pdHRlZExpbmUgPSB0aGlzLl9saW5lc1tsaW5lIC0gdGhpcy5fcHJlYW1ibGVMaW5lQ291bnRdO1xuICAgICAgICBpZiAoZW1pdHRlZExpbmUpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zTGVmdCA9IGNvbHVtbiAtIF9jcmVhdGVJbmRlbnQoZW1pdHRlZExpbmUuaW5kZW50KS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBlbWl0dGVkTGluZS5wYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBlbWl0dGVkTGluZS5wYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IGNvbHVtbnNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVkTGluZS5zcmNTcGFuc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zTGVmdCAtPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZUxpbmVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbCBzdHJpcCB0aGlzIGZyb20gcHVibGlzaGVkIGQudHMgZmlsZXMgZHVlIHRvXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmVzLmxlbmd0aCAmJiB0aGlzLl9saW5lc1t0aGlzLl9saW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xufSgpKTtcbnZhciBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0RW1pdHRlclZpc2l0b3IoX2VzY2FwZURvbGxhckluU3RyaW5ncykge1xuICAgICAgICB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MgPSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzO1xuICAgIH1cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJyZXR1cm4gXCIpO1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCAnOycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJpZiAoXCIpO1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICB2YXIgaGFzRWxzZUNhc2UgPSBzdG10LmZhbHNlQ2FzZSAhPSBudWxsICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKCk7XG4gICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwidGhyb3cgXCIpO1xuICAgICAgICBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIjtcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIi8qIFwiICsgc3RtdC5jb21tZW50ICsgXCIgKi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIi8vIFwiICsgbGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SlNEb2NDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIvKlwiICsgc3RtdC50b1N0cmluZygpICsgXCIqL1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiW1wiKTtcbiAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiXSA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5nZXRCdWlsdGluTWV0aG9kTmFtZShleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLlwiICsgbmFtZSArIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCBcIixcIik7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fic3RyYWN0IGVtaXR0ZXIgY2Fubm90IHZpc2l0IFdyYXBwZWROb2RlRXhwci4nKTtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZW9mRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsICd0eXBlb2YgJyk7XG4gICAgICAgIGV4cHIuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAnc3VwZXInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICd0aGlzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLkNhdGNoRXJyb3I6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjazpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX1NUQUNLX1ZBUiQxLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB2YXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGVzY2FwZUlkZW50aWZpZXIodmFsdWUsIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgXCJcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TG9jYWxpemVkU3RyaW5nID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBoZWFkID0gYXN0LnNlcmlhbGl6ZUkxOG5IZWFkKCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICckbG9jYWxpemUgYCcgKyBoZWFkLnJhdyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXN0Lm1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyR7Jyk7XG4gICAgICAgICAgICBhc3QuZXhwcmVzc2lvbnNbaSAtIDFdLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgXCJ9XCIgKyBhc3Quc2VyaWFsaXplSTE4blRlbXBsYXRlUGFydChpKS5yYXcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsICdgJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnPyAnKTtcbiAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnOiAnKTtcbiAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnIScpO1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQml0d2lzZUFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QucGFyZW5zKVxuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiLlwiKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIik7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJdXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIntcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcihlbnRyeS5rZXksIF90aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MsIGVudHJ5LnF1b3RlZCkgKyBcIjpcIik7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7XG4gICAgICAgIH0sIGFzdC5lbnRyaWVzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcikge1xuICAgICAgICB2YXIgaW5jcmVtZW50ZWRJbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5saW5lTGVuZ3RoKCkgPiA4MCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNyZW1lbnRlZEluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWF0aW9uIGFyZSBtYXJrZWQgd2l0aCBkb3VibGUgaW5kZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudGVkSW5kZW50KSB7XG4gICAgICAgICAgICAvLyBjb250aW51YXRpb24gYXJlIG1hcmtlZCB3aXRoIGRvdWJsZSBpbmRlbnQuXG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRzLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjdHgpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUpIHtcbiAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGJvZHkgPSBpbnB1dC5yZXBsYWNlKF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG1hdGNoW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURvbGxhciA/ICdcXFxcJCcgOiAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcIiArIG1hdGNoWzBdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlcXVpcmVzUXVvdGVzID0gYWx3YXlzUXVvdGUgfHwgIV9MRUdBTF9JREVOVElGSUVSX1JFLnRlc3QoYm9keSk7XG4gICAgcmV0dXJuIHJlcXVpcmVzUXVvdGVzID8gXCInXCIgKyBib2R5ICsgXCInXCIgOiBib2R5O1xufVxuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzICs9IF9JTkRFTlRfV0lUSDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiLnByb3RvdHlwZSk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKHN0bXQsIGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzTWV0aG9kKHN0bXQsIG1ldGhvZCwgY3R4KTsgfSk7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKHN0bXQsIGdldHRlciwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiICsgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLCAnXCIgKyBnZXR0ZXIubmFtZSArIFwiJywgeyBnZXQ6IGZ1bmN0aW9uKCkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAoZ2V0dGVyLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn19KTtcIik7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKHN0bXQsIG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAobWV0aG9kLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ2YXIgc2VsZiA9IHRoaXM7XCIpO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn07XCIpO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbWl0IGEgV3JhcHBlZE5vZGVFeHByIGluIEphdmFzY3JpcHQuJyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluID09PSBCdWlsdGluVmFyLlRoaXMpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICdzZWxmJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuU3VwZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidzdXBlcicgbmVlZHMgdG8gYmUgaGFuZGxlZCBhdCBhIHBhcmVudCBhc3Qgbm9kZSwgbm90IGF0IHRoZSB2YXJpYWJsZSBsZXZlbCFcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInZhciBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChzdG10LnZhbHVlKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgJyA9ICcpO1xuICAgICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIjtcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgZm5FeHByID0gZXhwci5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICBjdHguY3VycmVudENsYXNzLnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIi5jYWxsKHRoaXNcIik7XG4gICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwci5jYWxsKHRoaXMsIGV4cHIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiZnVuY3Rpb25cIiArIChhc3QubmFtZSA/ICcgJyArIGFzdC5uYW1lIDogJycpICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgY2F0Y2hTdG10cyA9IFtDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMb2NhbGl6ZWRTdHJpbmcgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb252b2x1dGVkIHBpZWNlIG9mIGNvZGUgaXMgZWZmZWN0aXZlbHkgdGhlIGRvd25sZXZlbGxlZCBlcXVpdmFsZW50IG9mXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUgYC4uLmBcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGxpa2U6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUoX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIsIC4uLik7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgYCRsb2NhbGl6ZWAgZnVuY3Rpb24gZXhwZWN0cyBhIFwidGVtcGxhdGUgb2JqZWN0XCIsIHdoaWNoIGlzIGFuIGFycmF5IG9mIFwiY29va2VkXCIgc3RyaW5nc1xuICAgICAgICAvLyBwbHVzIGEgYHJhd2AgcHJvcGVydHkgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBcInJhd1wiIHN0cmluZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIHNvbWUgZW52aXJvbm1lbnRzIGEgaGVscGVyIGZ1bmN0aW9uIGNhbGxlZCBgX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpYCBtaWdodCBiZVxuICAgICAgICAvLyBhdmFpbGFibGUsIGluIHdoaWNoIGNhc2Ugd2UgdXNlIHRoYXQuIE90aGVyd2lzZSB3ZSBtdXN0IGNyZWF0ZSBvdXIgb3duIGhlbHBlciBmdW5jdGlvblxuICAgICAgICAvLyBpbmxpbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIHRoZSBpbmxpbmUgZnVuY3Rpb24sIGlmIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIGlzIGF2YWlsYWJsZSB3ZSB1c2UgdGhhdCB0byBhdHRhY2ggdGhlXG4gICAgICAgIC8vIGByYXdgIGFycmF5LlxuICAgICAgICBjdHgucHJpbnQoYXN0LCAnJGxvY2FsaXplKCh0aGlzJiZ0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0fHxmdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHk/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJyYXdcIix7dmFsdWU6dH0pOmUucmF3PXQsZX0pKCcpO1xuICAgICAgICB2YXIgcGFydHMgPSBbYXN0LnNlcmlhbGl6ZUkxOG5IZWFkKCldO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFzdC5tZXNzYWdlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goYXN0LnNlcmlhbGl6ZUkxOG5UZW1wbGF0ZVBhcnQoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiICsgcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBlc2NhcGVJZGVudGlmaWVyKHBhcnQuY29va2VkLCBmYWxzZSk7IH0pLmpvaW4oJywgJykgKyBcIl0sIFwiKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJbXCIgKyBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIGVzY2FwZUlkZW50aWZpZXIocGFydC5yYXcsIGZhbHNlKTsgfSkuam9pbignLCAnKSArIFwiXSlcIik7XG4gICAgICAgIGFzdC5leHByZXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnLCAnKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb24udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGN0eCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGN0eC5wcmludChudWxsLCBwYXJhbS5uYW1lKTsgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gbWFuYWdlIHRoZSBldmFsdWF0aW9uIG9mIEpJVCBnZW5lcmF0ZWQgY29kZS5cbiAqL1xudmFyIEppdEV2YWx1YXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKaXRFdmFsdWF0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBUaGUgVVJMIG9mIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gc3RhdGVtZW50cyBBbiBhcnJheSBvZiBBbmd1bGFyIHN0YXRlbWVudCBBU1Qgbm9kZXMgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEBwYXJhbSByZWZsZWN0b3IgQSBoZWxwZXIgdXNlZCB3aGVuIGNvbnZlcnRpbmcgdGhlIHN0YXRlbWVudHMgdG8gZXhlY3V0YWJsZSBjb2RlLlxuICAgICAqIEBwYXJhbSBjcmVhdGVTb3VyY2VNYXBzIElmIHRydWUgdGhlbiBjcmVhdGUgYSBzb3VyY2UtbWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGUgYW5kIGluY2x1ZGUgaXRcbiAgICAgKiBpbmxpbmUgYXMgYSBzb3VyY2UtbWFwIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqL1xuICAgIEppdEV2YWx1YXRvci5wcm90b3R5cGUuZXZhbHVhdGVTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHNvdXJjZVVybCwgc3RhdGVtZW50cywgcmVmbGVjdG9yLCBjcmVhdGVTb3VyY2VNYXBzKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgSml0RW1pdHRlclZpc2l0b3IocmVmbGVjdG9yKTtcbiAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KCk7XG4gICAgICAgIC8vIEVuc3VyZSBnZW5lcmF0ZWQgY29kZSBpcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwICYmICFpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgc3RhdGVtZW50cyA9IF9fc3ByZWFkKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KClcbiAgICAgICAgICAgIF0sIHN0YXRlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY29udmVydGVyLmNyZWF0ZVJldHVyblN0bXQoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVDb2RlKHNvdXJjZVVybCwgY3R4LCBjb252ZXJ0ZXIuZ2V0QXJncygpLCBjcmVhdGVTb3VyY2VNYXBzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlIGEgcGllY2Ugb2YgSklUIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqIEBwYXJhbSBzb3VyY2VVcmwgVGhlIFVSTCBvZiB0aGlzIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqIEBwYXJhbSBjdHggQSBjb250ZXh0IG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIEFTVCBvZiB0aGUgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQHBhcmFtIHZhcnMgQSBtYXAgY29udGFpbmluZyB0aGUgbmFtZXMgYW5kIHZhbHVlcyBvZiB2YXJpYWJsZXMgdGhhdCB0aGUgZXZhbHVhdGVkIGNvZGUgbWlnaHRcbiAgICAgKiByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIGNyZWF0ZVNvdXJjZU1hcCBJZiB0cnVlIHRoZW4gY3JlYXRlIGEgc291cmNlLW1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlIGFuZCBpbmNsdWRlIGl0XG4gICAgICogaW5saW5lIGFzIGEgc291cmNlLW1hcCBjb21tZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyB0aGUgY29kZS5cbiAgICAgKi9cbiAgICBKaXRFdmFsdWF0b3IucHJvdG90eXBlLmV2YWx1YXRlQ29kZSA9IGZ1bmN0aW9uIChzb3VyY2VVcmwsIGN0eCwgdmFycywgY3JlYXRlU291cmNlTWFwKSB7XG4gICAgICAgIHZhciBmbkJvZHkgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcIiArIGN0eC50b1NvdXJjZSgpICsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgc291cmNlVXJsO1xuICAgICAgICB2YXIgZm5BcmdOYW1lcyA9IFtdO1xuICAgICAgICB2YXIgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYXJnTmFtZSBpbiB2YXJzKSB7XG4gICAgICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgICAgICAgICAgZm5BcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjcmVhdGVTb3VyY2VNYXApIHtcbiAgICAgICAgICAgIC8vIHVzaW5nIGBuZXcgRnVuY3Rpb24oLi4uKWAgZ2VuZXJhdGVzIGEgaGVhZGVyLCAxIGxpbmUgb2Ygbm8gYXJndW1lbnRzLCAyIGxpbmVzIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gRS5nLiBgYGBcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGFub255bW91cyhhLGIsY1xuICAgICAgICAgICAgLy8gLyoqLykgeyAuLi4gfWBgYFxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXJkIGNvZGUgdGhpcyBmYWN0LCBzbyB3ZSBhdXRvIGRldGVjdCBpdCB2aWEgYW4gZW1wdHkgZnVuY3Rpb24gZmlyc3QuXG4gICAgICAgICAgICB2YXIgZW1wdHlGbiA9IG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgX19zcHJlYWQoW3ZvaWQgMF0sIGZuQXJnTmFtZXMuY29uY2F0KCdyZXR1cm4gbnVsbDsnKSkpKSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgaGVhZGVyTGluZXMgPSBlbXB0eUZuLnNsaWNlKDAsIGVtcHR5Rm4uaW5kZXhPZigncmV0dXJuIG51bGw7JykpLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm5Cb2R5ICs9IFwiXFxuXCIgKyBjdHgudG9Tb3VyY2VNYXBHZW5lcmF0b3Ioc291cmNlVXJsLCBoZWFkZXJMaW5lcykudG9Kc0NvbW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIF9fc3ByZWFkKFt2b2lkIDBdLCBmbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKSkpKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGdW5jdGlvbihmbiwgZm5BcmdWYWx1ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIEpJVCBnZW5lcmF0ZWQgZnVuY3Rpb24gYnkgY2FsbGluZyBpdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHRlc3RzIHRvIGNhcHR1cmUgdGhlIGZ1bmN0aW9ucyB0aGF0IGFyZSBnZW5lcmF0ZWRcbiAgICAgKiBieSB0aGlzIGBKaXRFdmFsdWF0b3JgIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGV4ZWN1dGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIEppdEV2YWx1YXRvci5wcm90b3R5cGUuZXhlY3V0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFdmFsdWF0b3I7XG59KCkpO1xuLyoqXG4gKiBBbiBBbmd1bGFyIEFTVCB2aXNpdG9yIHRoYXQgY29udmVydHMgQVNUIG5vZGVzIGludG8gZXhlY3V0YWJsZSBKYXZhU2NyaXB0IGNvZGUuXG4gKi9cbnZhciBKaXRFbWl0dGVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSml0RW1pdHRlclZpc2l0b3IocmVmbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgX3RoaXMuX2V2YWxBcmdOYW1lcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBfdGhpcy5fZXZhbEV4cG9ydGVkVmFycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5jcmVhdGVSZXR1cm5TdG10ID0gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICB2YXIgc3RtdCA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQobmV3IExpdGVyYWxNYXBFeHByKHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMubWFwKGZ1bmN0aW9uIChyZXN1bHRWYXIpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkocmVzdWx0VmFyLCB2YXJpYWJsZShyZXN1bHRWYXIpLCBmYWxzZSk7IH0pKSk7XG4gICAgICAgIHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRBcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZhbEFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5fZXZhbEFyZ05hbWVzW2ldXSA9IHRoaXMuX2V2YWxBcmdWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHRoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShhc3QudmFsdWUpLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIGFzdC5ub2RlLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10LmNhbGwodGhpcywgc3RtdCwgY3R4KTtcbiAgICB9O1xuICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdC5jYWxsKHRoaXMsIHN0bXQsIGN0eCk7XG4gICAgfTtcbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQuY2FsbCh0aGlzLCBzdG10LCBjdHgpO1xuICAgIH07XG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbCA9IGZ1bmN0aW9uIChhc3QsIHZhbHVlLCBjdHgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IHZhbHVlIH0pIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goXCJqaXRfXCIgKyBuYW1lXzEgKyBcIl9cIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG5mdW5jdGlvbiBpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50LmlzRXF1aXZhbGVudChsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGBDb21waWxlUmVmbGVjdG9yYCB3aGljaCByZXNvbHZlcyByZWZlcmVuY2VzIHRvIEBhbmd1bGFyL2NvcmVcbiAqIHN5bWJvbHMgYXQgcnVudGltZSwgYWNjb3JkaW5nIHRvIGEgY29uc3VtZXItcHJvdmlkZWQgbWFwcGluZy5cbiAqXG4gKiBPbmx5IHN1cHBvcnRzIGByZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2VgLCBhbGwgb3RoZXIgbWV0aG9kcyB0aHJvdy5cbiAqL1xudmFyIFIzSml0UmVmbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFIzSml0UmVmbGVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgLy8gVGhpcyByZWZsZWN0b3Igb25seSBoYW5kbGVzIEBhbmd1bGFyL2NvcmUgaW1wb3J0cy5cbiAgICAgICAgaWYgKHJlZi5tb2R1bGVOYW1lICE9PSAnQGFuZ3VsYXIvY29yZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGV4dGVybmFsIHJlZmVyZW5jZSB0byBcIiArIHJlZi5tb2R1bGVOYW1lICsgXCIsIG9ubHkgcmVmZXJlbmNlcyB0byBAYW5ndWxhci9jb3JlIGFyZSBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc093blByb3BlcnR5KHJlZi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWUgcHJvdmlkZWQgZm9yIEBhbmd1bGFyL2NvcmUgc3ltYm9sICdcIiArIHJlZi5uYW1lICsgXCInLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W3JlZi5uYW1lXTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICBSM0ppdFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5zaGFsbG93QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS50cnlBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xuICAgIH07XG4gICAgUjNKaXRSZWZsZWN0b3IucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5ndWFyZHMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIFIzSml0UmVmbGVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRNb2R1bGVVcmwgPSBmdW5jdGlvbiAodHlwZSwgY21wTWV0YWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUjNKaXRSZWZsZWN0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBtYXBFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgcXVvdGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWFwTGl0ZXJhbChvYmosIHF1b3RlZCkge1xuICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBxdW90ZWQ6IHF1b3RlZCxcbiAgICAgICAgdmFsdWU6IG9ialtrZXldLFxuICAgIH0pOyB9KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uc3RydWN0IGFuIGBSM05nTW9kdWxlRGVmYCBmb3IgdGhlIGdpdmVuIGBSM05nTW9kdWxlTWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGUobWV0YSkge1xuICAgIHZhciBpbnRlcm5hbFR5cGUgPSBtZXRhLmludGVybmFsVHlwZSwgbW9kdWxlVHlwZSA9IG1ldGEudHlwZSwgYm9vdHN0cmFwID0gbWV0YS5ib290c3RyYXAsIGRlY2xhcmF0aW9ucyA9IG1ldGEuZGVjbGFyYXRpb25zLCBpbXBvcnRzID0gbWV0YS5pbXBvcnRzLCBleHBvcnRzID0gbWV0YS5leHBvcnRzLCBzY2hlbWFzID0gbWV0YS5zY2hlbWFzLCBjb250YWluc0ZvcndhcmREZWNscyA9IG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHMsIGVtaXRJbmxpbmUgPSBtZXRhLmVtaXRJbmxpbmUsIGlkID0gbWV0YS5pZDtcbiAgICB2YXIgYWRkaXRpb25hbFN0YXRlbWVudHMgPSBbXTtcbiAgICB2YXIgZGVmaW5pdGlvbk1hcCA9IHsgdHlwZTogaW50ZXJuYWxUeXBlIH07XG4gICAgLy8gT25seSBnZW5lcmF0ZSB0aGUga2V5cyBpbiB0aGUgbWV0YWRhdGEgaWYgdGhlIGFycmF5cyBoYXZlIHZhbHVlcy5cbiAgICBpZiAoYm9vdHN0cmFwLmxlbmd0aCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLmJvb3RzdHJhcCA9IHJlZnNUb0FycmF5KGJvb3RzdHJhcCwgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgIH1cbiAgICAvLyBJZiByZXF1ZXN0ZWQgdG8gZW1pdCBzY29wZSBpbmZvcm1hdGlvbiBpbmxpbmUsIHBhc3MgdGhlIGRlY2xhcmF0aW9ucywgaW1wb3J0cyBhbmQgZXhwb3J0cyB0b1xuICAgIC8vIHRoZSBgybXJtWRlZmluZU5nTW9kdWxlYCBjYWxsLiBUaGUgSklUIGNvbXBpbGF0aW9uIHVzZXMgdGhpcy5cbiAgICBpZiAoZW1pdElubGluZSkge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5kZWNsYXJhdGlvbnMgPSByZWZzVG9BcnJheShkZWNsYXJhdGlvbnMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuaW1wb3J0cyA9IHJlZnNUb0FycmF5KGltcG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuZXhwb3J0cyA9IHJlZnNUb0FycmF5KGV4cG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBub3QgZW1pdHRpbmcgaW5saW5lLCB0aGUgc2NvcGUgaW5mb3JtYXRpb24gaXMgbm90IHBhc3NlZCBpbnRvIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGFzIGl0IHdvdWxkXG4gICAgLy8gcHJldmVudCB0cmVlLXNoYWtpbmcgb2YgdGhlIGRlY2xhcmF0aW9ucywgaW1wb3J0cyBhbmQgZXhwb3J0cyByZWZlcmVuY2VzLlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgc2V0TmdNb2R1bGVTY29wZUNhbGwgPSBnZW5lcmF0ZVNldE5nTW9kdWxlU2NvcGVDYWxsKG1ldGEpO1xuICAgICAgICBpZiAoc2V0TmdNb2R1bGVTY29wZUNhbGwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTdGF0ZW1lbnRzLnB1c2goc2V0TmdNb2R1bGVTY29wZUNhbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzY2hlbWFzICYmIHNjaGVtYXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2NoZW1hcyA9IGxpdGVyYWxBcnIoc2NoZW1hcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLnZhbHVlOyB9KSk7XG4gICAgfVxuICAgIGlmIChpZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLmlkID0gaWQ7XG4gICAgfVxuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZU5nTW9kdWxlKS5jYWxsRm4oW21hcFRvTWFwRXhwcmVzc2lvbihkZWZpbml0aW9uTWFwKV0pO1xuICAgIHZhciB0eXBlID0gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5OZ01vZHVsZURlZldpdGhNZXRhLCBbXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShtb2R1bGVUeXBlLnR5cGUpLCB0dXBsZVR5cGVPZihkZWNsYXJhdGlvbnMpLCB0dXBsZVR5cGVPZihpbXBvcnRzKSxcbiAgICAgICAgdHVwbGVUeXBlT2YoZXhwb3J0cylcbiAgICBdKSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgdHlwZTogdHlwZSwgYWRkaXRpb25hbFN0YXRlbWVudHM6IGFkZGl0aW9uYWxTdGF0ZW1lbnRzIH07XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGNhbGwgdG8gYMm1ybVzZXROZ01vZHVsZVNjb3BlYCB3aXRoIGFsbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24gc28gdGhhdCB0aGVcbiAqIHRyYW5zaXRpdmUgbW9kdWxlIHNjb3BlIGNhbiBiZSBjb21wdXRlZCBkdXJpbmcgcnVudGltZSBpbiBKSVQgbW9kZS4gVGhpcyBjYWxsIGlzIG1hcmtlZCBwdXJlXG4gKiBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZXMgdG8gZGVjbGFyYXRpb25zLCBpbXBvcnRzIGFuZCBleHBvcnRzIG1heSBiZSBlbGlkZWQgY2F1c2luZyB0aGVzZVxuICogc3ltYm9scyB0byBiZWNvbWUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSkge1xuICAgIHZhciBtb2R1bGVUeXBlID0gbWV0YS5hZGphY2VudFR5cGUsIGRlY2xhcmF0aW9ucyA9IG1ldGEuZGVjbGFyYXRpb25zLCBpbXBvcnRzID0gbWV0YS5pbXBvcnRzLCBleHBvcnRzID0gbWV0YS5leHBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscyA9IG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHM7XG4gICAgdmFyIHNjb3BlTWFwID0ge307XG4gICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgc2NvcGVNYXAuZGVjbGFyYXRpb25zID0gcmVmc1RvQXJyYXkoZGVjbGFyYXRpb25zLCBjb250YWluc0ZvcndhcmREZWNscyk7XG4gICAgfVxuICAgIGlmIChpbXBvcnRzLmxlbmd0aCkge1xuICAgICAgICBzY29wZU1hcC5pbXBvcnRzID0gcmVmc1RvQXJyYXkoaW1wb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgc2NvcGVNYXAuZXhwb3J0cyA9IHJlZnNUb0FycmF5KGV4cG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjb3BlTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHNldE5nTW9kdWxlU2NvcGUoLi4uKVxuICAgIHZhciBmbkNhbGwgPSBuZXcgSW52b2tlRnVuY3Rpb25FeHByKFxuICAgIC8qIGZuICovIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zZXROZ01vZHVsZVNjb3BlKSwgXG4gICAgLyogYXJncyAqLyBbbW9kdWxlVHlwZSwgbWFwVG9NYXBFeHByZXNzaW9uKHNjb3BlTWFwKV0pO1xuICAgIC8vIChuZ0ppdE1vZGUgZ3VhcmQpICYmIHNldE5nTW9kdWxlU2NvcGUoLi4uKVxuICAgIHZhciBndWFyZGVkQ2FsbCA9IGppdE9ubHlHdWFyZGVkRXhwcmVzc2lvbihmbkNhbGwpO1xuICAgIC8vIGZ1bmN0aW9uKCkgeyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLik7IH1cbiAgICB2YXIgaWlmZSA9IG5ldyBGdW5jdGlvbkV4cHIoXG4gICAgLyogcGFyYW1zICovIFtdLCBcbiAgICAvKiBzdGF0ZW1lbnRzICovIFtndWFyZGVkQ2FsbC50b1N0bXQoKV0pO1xuICAgIC8vIChmdW5jdGlvbigpIHsgKG5nSml0TW9kZSBndWFyZCkgJiYgc2V0TmdNb2R1bGVTY29wZSguLi4pOyB9KSgpXG4gICAgdmFyIGlpZmVDYWxsID0gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihcbiAgICAvKiBmbiAqLyBpaWZlLCBcbiAgICAvKiBhcmdzICovIFtdKTtcbiAgICByZXR1cm4gaWlmZUNhbGwudG9TdG10KCk7XG59XG5mdW5jdGlvbiBjb21waWxlSW5qZWN0b3IobWV0YSkge1xuICAgIHZhciByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICB0eXBlOiBtZXRhLnR5cGUsXG4gICAgICAgIGludGVybmFsVHlwZTogbWV0YS5pbnRlcm5hbFR5cGUsXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICBkZXBzOiBtZXRhLmRlcHMsXG4gICAgICAgIGluamVjdEZuOiBJZGVudGlmaWVycyQxLmluamVjdCxcbiAgICAgICAgdGFyZ2V0OiBSM0ZhY3RvcnlUYXJnZXQuTmdNb2R1bGUsXG4gICAgfSk7XG4gICAgdmFyIGRlZmluaXRpb25NYXAgPSB7XG4gICAgICAgIGZhY3Rvcnk6IHJlc3VsdC5mYWN0b3J5LFxuICAgIH07XG4gICAgaWYgKG1ldGEucHJvdmlkZXJzICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAucHJvdmlkZXJzID0gbWV0YS5wcm92aWRlcnM7XG4gICAgfVxuICAgIGlmIChtZXRhLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLmltcG9ydHMgPSBsaXRlcmFsQXJyKG1ldGEuaW1wb3J0cyk7XG4gICAgfVxuICAgIHZhciBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZUluamVjdG9yKS5jYWxsRm4oW21hcFRvTWFwRXhwcmVzc2lvbihkZWZpbml0aW9uTWFwKV0pO1xuICAgIHZhciB0eXBlID0gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5JbmplY3RvckRlZiwgW25ldyBFeHByZXNzaW9uVHlwZShtZXRhLnR5cGUudHlwZSldKSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgdHlwZTogdHlwZSwgc3RhdGVtZW50czogcmVzdWx0LnN0YXRlbWVudHMgfTtcbn1cbi8vIFRPRE8oYWx4aHViKTogaW50ZWdyYXRlIHRoaXMgd2l0aCBgY29tcGlsZU5nTW9kdWxlYC4gQ3VycmVudGx5IHRoZSB0d28gYXJlIHNlcGFyYXRlIG9wZXJhdGlvbnMuXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGVGcm9tUmVuZGVyMihjdHgsIG5nTW9kdWxlLCBpbmplY3RhYmxlQ29tcGlsZXIpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGUudHlwZSk7XG4gICAgdmFyIHJhd0ltcG9ydHMgPSBuZ01vZHVsZS5yYXdJbXBvcnRzID8gW25nTW9kdWxlLnJhd0ltcG9ydHNdIDogW107XG4gICAgdmFyIHJhd0V4cG9ydHMgPSBuZ01vZHVsZS5yYXdFeHBvcnRzID8gW25nTW9kdWxlLnJhd0V4cG9ydHNdIDogW107XG4gICAgdmFyIGluamVjdG9yRGVmQXJnID0gbWFwTGl0ZXJhbCh7XG4gICAgICAgICdmYWN0b3J5JzogaW5qZWN0YWJsZUNvbXBpbGVyLmZhY3RvcnlGb3IoeyB0eXBlOiBuZ01vZHVsZS50eXBlLCBzeW1ib2w6IG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlIH0sIGN0eCksXG4gICAgICAgICdwcm92aWRlcnMnOiBjb252ZXJ0TWV0YVRvT3V0cHV0KG5nTW9kdWxlLnJhd1Byb3ZpZGVycywgY3R4KSxcbiAgICAgICAgJ2ltcG9ydHMnOiBjb252ZXJ0TWV0YVRvT3V0cHV0KF9fc3ByZWFkKHJhd0ltcG9ydHMsIHJhd0V4cG9ydHMpLCBjdHgpLFxuICAgIH0pO1xuICAgIHZhciBpbmplY3RvckRlZiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWZpbmVJbmplY3RvcikuY2FsbEZuKFtpbmplY3RvckRlZkFyZ10pO1xuICAgIGN0eC5zdGF0ZW1lbnRzLnB1c2gobmV3IENsYXNzU3RtdChcbiAgICAvKiBuYW1lICovIGNsYXNzTmFtZSwgXG4gICAgLyogcGFyZW50ICovIG51bGwsIFxuICAgIC8qIGZpZWxkcyAqLyBbbmV3IENsYXNzRmllbGQoXG4gICAgICAgIC8qIG5hbWUgKi8gJ8m1aW5qJywgXG4gICAgICAgIC8qIHR5cGUgKi8gSU5GRVJSRURfVFlQRSwgXG4gICAgICAgIC8qIG1vZGlmaWVycyAqLyBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIFxuICAgICAgICAvKiBpbml0aWFsaXplciAqLyBpbmplY3RvckRlZildLCBcbiAgICAvKiBnZXR0ZXJzICovIFtdLCBcbiAgICAvKiBjb25zdHJ1Y3Rvck1ldGhvZCAqLyBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgXG4gICAgLyogbWV0aG9kcyAqLyBbXSkpO1xufVxuZnVuY3Rpb24gYWNjZXNzRXhwb3J0U2NvcGUobW9kdWxlKSB7XG4gICAgdmFyIHNlbGVjdG9yU2NvcGUgPSBuZXcgUmVhZFByb3BFeHByKG1vZHVsZSwgJ8m1bW9kJyk7XG4gICAgcmV0dXJuIG5ldyBSZWFkUHJvcEV4cHIoc2VsZWN0b3JTY29wZSwgJ2V4cG9ydGVkJyk7XG59XG5mdW5jdGlvbiB0dXBsZVR5cGVPZihleHApIHtcbiAgICB2YXIgdHlwZXMgPSBleHAubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHR5cGVvZkV4cHIocmVmLnR5cGUpOyB9KTtcbiAgICByZXR1cm4gZXhwLmxlbmd0aCA+IDAgPyBleHByZXNzaW9uVHlwZShsaXRlcmFsQXJyKHR5cGVzKSkgOiBOT05FX1RZUEU7XG59XG5mdW5jdGlvbiByZWZzVG9BcnJheShyZWZzLCBzaG91bGRGb3J3YXJkRGVjbGFyZSkge1xuICAgIHZhciB2YWx1ZXMgPSBsaXRlcmFsQXJyKHJlZnMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHJlZi52YWx1ZTsgfSkpO1xuICAgIHJldHVybiBzaG91bGRGb3J3YXJkRGVjbGFyZSA/IGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZXMpXSkgOiB2YWx1ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgdmFyIGRlZmluaXRpb25NYXBWYWx1ZXMgPSBbXTtcbiAgICAvLyBlLmcuIGBuYW1lOiAnbXlQaXBlJ2BcbiAgICBkZWZpbml0aW9uTWFwVmFsdWVzLnB1c2goeyBrZXk6ICduYW1lJywgdmFsdWU6IGxpdGVyYWwobWV0YWRhdGEucGlwZU5hbWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15UGlwZWBcbiAgICBkZWZpbml0aW9uTWFwVmFsdWVzLnB1c2goeyBrZXk6ICd0eXBlJywgdmFsdWU6IG1ldGFkYXRhLnR5cGUudmFsdWUsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgLy8gZS5nLiBgcHVyZTogdHJ1ZWBcbiAgICBkZWZpbml0aW9uTWFwVmFsdWVzLnB1c2goeyBrZXk6ICdwdXJlJywgdmFsdWU6IGxpdGVyYWwobWV0YWRhdGEucHVyZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lUGlwZSkuY2FsbEZuKFtsaXRlcmFsTWFwKGRlZmluaXRpb25NYXBWYWx1ZXMpXSk7XG4gICAgdmFyIHR5cGUgPSBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLlBpcGVEZWZXaXRoTWV0YSwgW1xuICAgICAgICB0eXBlV2l0aFBhcmFtZXRlcnMobWV0YWRhdGEudHlwZS50eXBlLCBtZXRhZGF0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShuZXcgTGl0ZXJhbEV4cHIobWV0YWRhdGEucGlwZU5hbWUpKSxcbiAgICBdKSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiwgdHlwZTogdHlwZSB9O1xufVxuLyoqXG4gKiBXcml0ZSBhIHBpcGUgZGVmaW5pdGlvbiB0byB0aGUgb3V0cHV0IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVQaXBlRnJvbVJlbmRlcjIob3V0cHV0Q3R4LCBwaXBlLCByZWZsZWN0b3IpIHtcbiAgICB2YXIgbmFtZSA9IGlkZW50aWZpZXJOYW1lKHBpcGUudHlwZSk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBlcnJvcihcIkNhbm5vdCByZXNvbHZlIHRoZSBuYW1lIG9mIFwiICsgcGlwZS50eXBlKTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBvdXRwdXRDdHguaW1wb3J0RXhwcihwaXBlLnR5cGUucmVmZXJlbmNlKTtcbiAgICB2YXIgbWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UodHlwZSksXG4gICAgICAgIGludGVybmFsVHlwZTogdHlwZSxcbiAgICAgICAgcGlwZU5hbWU6IHBpcGUubmFtZSxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgIGRlcHM6IGRlcGVuZGVuY2llc0Zyb21HbG9iYWxNZXRhZGF0YShwaXBlLnR5cGUsIG91dHB1dEN0eCwgcmVmbGVjdG9yKSxcbiAgICAgICAgcHVyZTogcGlwZS5wdXJlLFxuICAgIH07XG4gICAgdmFyIHJlcyA9IGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICB2YXIgZmFjdG9yeVJlcyA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oX19hc3NpZ24oX19hc3NpZ24oe30sIG1ldGFkYXRhKSwgeyBpbmplY3RGbjogSWRlbnRpZmllcnMkMS5kaXJlY3RpdmVJbmplY3QsIHRhcmdldDogUjNGYWN0b3J5VGFyZ2V0LlBpcGUgfSkpO1xuICAgIHZhciBkZWZpbml0aW9uRmllbGQgPSBvdXRwdXRDdHguY29uc3RhbnRQb29sLnByb3BlcnR5TmFtZU9mKDMgLyogUGlwZSAqLyk7XG4gICAgdmFyIG5nRmFjdG9yeURlZlN0YXRlbWVudCA9IG5ldyBDbGFzc1N0bXQoXG4gICAgLyogbmFtZSAqLyBuYW1lLCBcbiAgICAvKiBwYXJlbnQgKi8gbnVsbCwgXG4gICAgLyogZmllbGRzICovXG4gICAgW25ldyBDbGFzc0ZpZWxkKFxuICAgICAgICAvKiBuYW1lICovICfJtWZhYycsIFxuICAgICAgICAvKiB0eXBlICovIElORkVSUkVEX1RZUEUsIFxuICAgICAgICAvKiBtb2RpZmllcnMgKi8gW1N0bXRNb2RpZmllci5TdGF0aWNdLCBcbiAgICAgICAgLyogaW5pdGlhbGl6ZXIgKi8gZmFjdG9yeVJlcy5mYWN0b3J5KV0sIFxuICAgIC8qIGdldHRlcnMgKi8gW10sIFxuICAgIC8qIGNvbnN0cnVjdG9yTWV0aG9kICovIG5ldyBDbGFzc01ldGhvZChudWxsLCBbXSwgW10pLCBcbiAgICAvKiBtZXRob2RzICovIFtdKTtcbiAgICB2YXIgcGlwZURlZlN0YXRlbWVudCA9IG5ldyBDbGFzc1N0bXQoXG4gICAgLyogbmFtZSAqLyBuYW1lLCBcbiAgICAvKiBwYXJlbnQgKi8gbnVsbCwgXG4gICAgLyogZmllbGRzICovIFtuZXcgQ2xhc3NGaWVsZChcbiAgICAgICAgLyogbmFtZSAqLyBkZWZpbml0aW9uRmllbGQsIFxuICAgICAgICAvKiB0eXBlICovIElORkVSUkVEX1RZUEUsIFxuICAgICAgICAvKiBtb2RpZmllcnMgKi8gW1N0bXRNb2RpZmllci5TdGF0aWNdLCBcbiAgICAgICAgLyogaW5pdGlhbGl6ZXIgKi8gcmVzLmV4cHJlc3Npb24pXSwgXG4gICAgLyogZ2V0dGVycyAqLyBbXSwgXG4gICAgLyogY29uc3RydWN0b3JNZXRob2QgKi8gbmV3IENsYXNzTWV0aG9kKG51bGwsIFtdLCBbXSksIFxuICAgIC8qIG1ldGhvZHMgKi8gW10pO1xuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2gobmdGYWN0b3J5RGVmU3RhdGVtZW50LCBwaXBlRGVmU3RhdGVtZW50KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFBhcnNlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVyckxvY2F0aW9uID0gZXJyTG9jYXRpb247XG4gICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG59KCkpO1xudmFyIFBhcnNlU3BhbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVNwYW4oc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICBQYXJzZVNwYW4ucHJvdG90eXBlLnRvQWJzb2x1dGUgPSBmdW5jdGlvbiAoYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oYWJzb2x1dGVPZmZzZXQgKyB0aGlzLnN0YXJ0LCBhYnNvbHV0ZU9mZnNldCArIHRoaXMuZW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZVNwYW47XG59KCkpO1xudmFyIEFTVCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU1Qoc3BhbiwgXG4gICAgLyoqXG4gICAgICogQWJzb2x1dGUgbG9jYXRpb24gb2YgdGhlIGV4cHJlc3Npb24gQVNUIGluIGEgc291cmNlIGNvZGUgZmlsZS5cbiAgICAgKi9cbiAgICBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdBU1QnO1xuICAgIH07XG4gICAgcmV0dXJuIEFTVDtcbn0oKSk7XG52YXIgQVNUV2l0aE5hbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhOYW1lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFTVFdpdGhOYW1lKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWVTcGFuID0gbmFtZVNwYW47XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFTVFdpdGhOYW1lO1xufShBU1QpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICpcbiAqIHF1b3RlID0gcHJlZml4IGA6YCB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICogcHJlZml4ID0gaWRlbnRpZmllclxuICogdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBhcmJpdHJhcnkgc3RyaW5nXG4gKlxuICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gKiBjb252ZXJ0cyBpdCBpbnRvIGFub3RoZXIgQVNUIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW5zIHF1b3RlZCBleHByZXNzaW9ucy5cbiAqIEl0IGlzIG1lYW50IHRvIGFsbG93IHRoaXJkLXBhcnR5IGRldmVsb3BlcnMgdG8gZXh0ZW5kIEFuZ3VsYXIgdGVtcGxhdGVcbiAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gKiB0aGVyZWZvcmUgbm90IGludGVycHJldGVkIGJ5IHRoZSBBbmd1bGFyJ3Mgb3duIGV4cHJlc3Npb24gcGFyc2VyLlxuICovXG52YXIgUXVvdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1b3RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFF1b3RlKHNwYW4sIHNvdXJjZVNwYW4sIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgX3RoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgX3RoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UXVvdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnUXVvdGUnO1xuICAgIH07XG4gICAgcmV0dXJuIFF1b3RlO1xufShBU1QpKTtcbnZhciBFbXB0eUV4cHIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5RXhwciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eUV4cHIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5RXhwcjtcbn0oQVNUKSk7XG52YXIgSW1wbGljaXRSZWNlaXZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbn0oQVNUKSk7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGFpbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFpbihzcGFuLCBzb3VyY2VTcGFuLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYWluLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGFpbih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFpbjtcbn0oQVNUKSk7XG52YXIgQ29uZGl0aW9uYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKHNwYW4sIHNvdXJjZVNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy50cnVlRXhwID0gdHJ1ZUV4cDtcbiAgICAgICAgX3RoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25kaXRpb25hbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG59KEFTVCkpO1xudmFyIFByb3BlcnR5UmVhZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5UmVhZChzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbn0oQVNUV2l0aE5hbWUpKTtcbnZhciBQcm9wZXJ0eVdyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eVdyaXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJvcGVydHlXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9wZXJ0eVdyaXRlO1xufShBU1RXaXRoTmFtZSkpO1xudmFyIFNhZmVQcm9wZXJ0eVJlYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVQcm9wZXJ0eVJlYWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVByb3BlcnR5UmVhZChzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUV2l0aE5hbWUpKTtcbnZhciBLZXllZFJlYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEtleWVkUmVhZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgc291cmNlU3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbnZhciBLZXllZFdyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUoc3Bhbiwgc291cmNlU3Bhbiwgb2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9iaiA9IG9iajtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEtleWVkV3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbn0oQVNUKSk7XG52YXIgQmluZGluZ1BpcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmRpbmdQaXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKHNwYW4sIHNvdXJjZVNwYW4sIGV4cCwgbmFtZSwgYXJncywgbmFtZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cCA9IGV4cDtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJpbmRpbmdQaXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdQaXBlO1xufShBU1RXaXRoTmFtZSkpO1xudmFyIExpdGVyYWxQcmltaXRpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzb3VyY2VTcGFuLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpdGVyYWxQcmltaXRpdmUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxQcmltaXRpdmUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcbn0oQVNUKSk7XG52YXIgTGl0ZXJhbEFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xufShBU1QpKTtcbnZhciBMaXRlcmFsTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwgc291cmNlU3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwO1xufShBU1QpKTtcbnZhciBJbnRlcnBvbGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oc3Bhbiwgc291cmNlU3Bhbiwgc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uO1xufShBU1QpKTtcbnZhciBCaW5hcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5hcnkoc3Bhbiwgc291cmNlU3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICBfdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeTtcbn0oQVNUKSk7XG52YXIgUHJlZml4Tm90ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcmVmaXhOb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlZml4Tm90KHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlZml4Tm90LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmVmaXhOb3QodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlZml4Tm90O1xufShBU1QpKTtcbnZhciBOb25OdWxsQXNzZXJ0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb25OdWxsQXNzZXJ0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vbk51bGxBc3NlcnQoc3Bhbiwgc291cmNlU3BhbiwgZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOb25OdWxsQXNzZXJ0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb25OdWxsQXNzZXJ0KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vbk51bGxBc3NlcnQ7XG59KEFTVCkpO1xudmFyIE1ldGhvZENhbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRNZXRob2RDYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1ldGhvZENhbGw7XG59KEFTVFdpdGhOYW1lKSk7XG52YXIgU2FmZU1ldGhvZENhbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVNZXRob2RDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUV2l0aE5hbWUpKTtcbnZhciBGdW5jdGlvbkNhbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uQ2FsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkNhbGwoc3Bhbiwgc291cmNlU3BhbiwgdGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgX3RoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnVuY3Rpb25DYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25DYWxsO1xufShBU1QpKTtcbi8qKlxuICogUmVjb3JkcyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgYSB0ZXh0IHNwYW4gaW4gYSBzb3VyY2UgZmlsZSwgd2hlcmUgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIHRoZVxuICogc3RhcnRpbmcgYW5kIGVuZGluZyBieXRlIG9mZnNldHMsIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRleHQgc3BhbiBpbiBhIHNvdXJjZSBmaWxlLlxuICovXG52YXIgQWJzb2x1dGVTb3VyY2VTcGFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic29sdXRlU291cmNlU3BhbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBBYnNvbHV0ZVNvdXJjZVNwYW47XG59KCkpO1xudmFyIEFTVFdpdGhTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3IFBhcnNlU3BhbigwLCBzb3VyY2UgPT09IG51bGwgPyAwIDogc291cmNlLmxlbmd0aCksIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oYWJzb2x1dGVPZmZzZXQsIHNvdXJjZSA9PT0gbnVsbCA/IGFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXQgKyBzb3VyY2UubGVuZ3RoKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXN0ID0gYXN0O1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHZpc2l0b3IudmlzaXRBU1RXaXRoU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFTVFdpdGhTb3VyY2UodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xufShBU1QpKTtcbnZhciBWYXJpYWJsZUJpbmRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gZW50aXJlIHNwYW4gb2YgdGhlIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIGtleSBuYW1lIG9mIHRoZSBMSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgb3B0aW9uYWwgdmFsdWUgZm9yIHRoZSBSSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYXJpYWJsZUJpbmRpbmcoc291cmNlU3Bhbiwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gVmFyaWFibGVCaW5kaW5nO1xufSgpKTtcbnZhciBFeHByZXNzaW9uQmluZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhbiBlbnRpcmUgc3BhbiBvZiB0aGUgYmluZGluZy5cbiAgICAgKiBAcGFyYW0ga2V5IGJpbmRpbmcgbmFtZSwgbGlrZSBuZ0Zvck9mLCBuZ0ZvclRyYWNrQnksIG5nSWYsIGFsb25nIHdpdGggaXRzXG4gICAgICogc3Bhbi4gTm90ZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIHNwYW4gbWF5IG5vdCBiZSB0aGUgc2FtZSBhc1xuICAgICAqIGBrZXkuc291cmNlLmxlbmd0aGAuIEZvciBleGFtcGxlLFxuICAgICAqIDEuIGtleS5zb3VyY2UgPSBuZ0Zvciwga2V5LnNwYW4gaXMgZm9yIFwibmdGb3JcIlxuICAgICAqIDIuIGtleS5zb3VyY2UgPSBuZ0Zvck9mLCBrZXkuc3BhbiBpcyBmb3IgXCJvZlwiXG4gICAgICogMy4ga2V5LnNvdXJjZSA9IG5nRm9yVHJhY2tCeSwga2V5LnNwYW4gaXMgZm9yIFwidHJhY2tCeVwiXG4gICAgICogQHBhcmFtIHZhbHVlIG9wdGlvbmFsIGV4cHJlc3Npb24gZm9yIHRoZSBSSFMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbkJpbmRpbmcoc291cmNlU3Bhbiwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gRXhwcmVzc2lvbkJpbmRpbmc7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWN1cnNpdmVBc3RWaXNpdG9yKCkge1xuICAgIH1cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdCB2aXNpdHMgZXZlcnkgbm9kZS5cbiAgICAgICAgLy8gQ2xhc3NlcyB0aGF0IGV4dGVuZCBSZWN1cnNpdmVBc3RWaXNpdG9yIHNob3VsZCBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIC8vIHRvIHNlbGVjdGl2ZWx5IHZpc2l0IHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICAgICAgYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmxlZnQsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yaWdodCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5jb25kaXRpb24sIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC50cnVlRXhwLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZmFsc2VFeHAsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5leHAsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoYXN0LnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdChhc3QudGFyZ2V0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5vYmosIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5vYmosIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnZhbHVlLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgIH07XG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgQXN0VmlzaXRvciBpbnRlcmZhY2UsIGp1c3QgYSBoZWxwZXIgbWV0aG9kXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgY29udGV4dCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGFzdHNfMSA9IF9fdmFsdWVzKGFzdHMpLCBhc3RzXzFfMSA9IGFzdHNfMS5uZXh0KCk7ICFhc3RzXzFfMS5kb25lOyBhc3RzXzFfMSA9IGFzdHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXN0ID0gYXN0c18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdChhc3QsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0c18xXzEgJiYgIWFzdHNfMV8xLmRvbmUgJiYgKF9hID0gYXN0c18xLnJldHVybikpIF9hLmNhbGwoYXN0c18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG59KCkpO1xudmFyIEFzdFRyYW5zZm9ybWVyJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN0VHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc3RyaW5ncywgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC52YWx1ZSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZENhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnRhcmdldC52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25OdWxsQXNzZXJ0KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuZXhwLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncyksIGFzdC5uYW1lU3Bhbik7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qub2JqLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpLCBhc3QudmFsdWUudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1b3RlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnByZWZpeCwgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbi8vIEEgdHJhbnNmb3JtZXIgdGhhdCBvbmx5IGNyZWF0ZXMgbmV3IG5vZGVzIGlmIHRoZSB0cmFuc2Zvcm1lciBtYWtlcyBhIGNoYW5nZSBvclxuLy8gYSBjaGFuZ2UgaXMgbWFkZSBhIGNoaWxkIG5vZGUuXG52YXIgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIoKSB7XG4gICAgfVxuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0cmluZ3MsIGV4cHJlc3Npb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgdmFsdWUgIT09IGFzdC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVdyaXRlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyIHx8IGFyZ3MgIT09IGFzdC5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1ldGhvZENhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyIHx8IGFyZ3MgIT09IGFzdC5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBhc3QudGFyZ2V0ICYmIGFzdC50YXJnZXQudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IGFzdC50YXJnZXQgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgdGFyZ2V0LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IGFzdC52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5rZXlzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBsZWZ0ID0gYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciByaWdodCA9IGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGxlZnQgIT09IGFzdC5sZWZ0IHx8IHJpZ2h0ICE9PSBhc3QucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uICE9PSBhc3QuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IGFzdC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vbk51bGxBc3NlcnQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICB2YXIgdHJ1ZUV4cCA9IGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB2YXIgZmFsc2VFeHAgPSBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChjb25kaXRpb24gIT09IGFzdC5jb25kaXRpb24gfHwgdHJ1ZUV4cCAhPT0gYXN0LnRydWVFeHAgfHwgZmFsc2VFeHAgIT09IGFzdC5mYWxzZUV4cCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXhwID0gYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKGV4cCAhPT0gYXN0LmV4cCB8fCBhcmdzICE9PSBhc3QuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cCwgYXN0Lm5hbWUsIGFyZ3MsIGFzdC5uYW1lU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgIHZhciBrZXkgPSBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3Qub2JqIHx8IGtleSAhPT0gYXN0LmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBvYmosIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvYmogPSBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICB2YXIga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3Qub2JqIHx8IGtleSAhPT0gYXN0LmtleSB8fCB2YWx1ZSAhPT0gYXN0LnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cykge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFzdHNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvcmlnaW5hbC52aXNpdCh0aGlzKTtcbiAgICAgICAgICAgIHJlc1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgbW9kaWZpZWQgPSBtb2RpZmllZCB8fCB2YWx1ZSAhPT0gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkID8gcmVzIDogYXN0cztcbiAgICB9O1xuICAgIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIHJldHVybiBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vLyBCaW5kaW5nc1xudmFyIFBhcnNlZFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgICAgdGhpcy5pc0xpdGVyYWwgPSB0aGlzLnR5cGUgPT09IFBhcnNlZFByb3BlcnR5VHlwZS5MSVRFUkFMX0FUVFI7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpb24gPSB0aGlzLnR5cGUgPT09IFBhcnNlZFByb3BlcnR5VHlwZS5BTklNQVRJT047XG4gICAgfVxuICAgIHJldHVybiBQYXJzZWRQcm9wZXJ0eTtcbn0oKSk7XG52YXIgUGFyc2VkUHJvcGVydHlUeXBlO1xuKGZ1bmN0aW9uIChQYXJzZWRQcm9wZXJ0eVR5cGUpIHtcbiAgICBQYXJzZWRQcm9wZXJ0eVR5cGVbUGFyc2VkUHJvcGVydHlUeXBlW1wiREVGQVVMVFwiXSA9IDBdID0gXCJERUZBVUxUXCI7XG4gICAgUGFyc2VkUHJvcGVydHlUeXBlW1BhcnNlZFByb3BlcnR5VHlwZVtcIkxJVEVSQUxfQVRUUlwiXSA9IDFdID0gXCJMSVRFUkFMX0FUVFJcIjtcbiAgICBQYXJzZWRQcm9wZXJ0eVR5cGVbUGFyc2VkUHJvcGVydHlUeXBlW1wiQU5JTUFUSU9OXCJdID0gMl0gPSBcIkFOSU1BVElPTlwiO1xufSkoUGFyc2VkUHJvcGVydHlUeXBlIHx8IChQYXJzZWRQcm9wZXJ0eVR5cGUgPSB7fSkpO1xudmFyIFBhcnNlZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlZ3VsYXIgZXZlbnRzIGhhdmUgYSB0YXJnZXRcbiAgICAvLyBBbmltYXRpb24gZXZlbnRzIGhhdmUgYSBwaGFzZVxuICAgIGZ1bmN0aW9uIFBhcnNlZEV2ZW50KG5hbWUsIHRhcmdldE9yUGhhc2UsIHR5cGUsIGhhbmRsZXIsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudGFyZ2V0T3JQaGFzZSA9IHRhcmdldE9yUGhhc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaGFuZGxlclNwYW4gPSBoYW5kbGVyU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlZEV2ZW50O1xufSgpKTtcbi8qKlxuICogUGFyc2VkVmFyaWFibGUgcmVwcmVzZW50cyBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIGEgbWljcm9zeW50YXggZXhwcmVzc2lvbi5cbiAqL1xudmFyIFBhcnNlZFZhcmlhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlZFZhcmlhYmxlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlZFZhcmlhYmxlO1xufSgpKTtcbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eShuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eTtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFdmVudEhhbmRsZXJWYXJzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnM7XG59KCkpO1xudmFyIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KFxuICAgIC8qKlxuICAgICAqIFJlbmRlcjIgY29tcGF0aWJsZSBzdGF0ZW1lbnRzLFxuICAgICAqL1xuICAgIHN0bXRzLCBcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSBuYW1lIHVzZWQgd2l0aCByZW5kZXIyIGNvbXBhdGlibGUgc3RhdGVtZW50cy5cbiAgICAgKi9cbiAgICBhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGFsbG93RGVmYXVsdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYml0IG9mIGEgaGFjay4gSXQgY29udmVydHMgc3RhdGVtZW50cyB3aGljaCByZW5kZXIyIGV4cGVjdHMgdG8gc3RhdGVtZW50cyB3aGljaCBhcmVcbiAgICAgICAgICogZXhwZWN0ZWQgYnkgcmVuZGVyMy5cbiAgICAgICAgICpcbiAgICAgICAgICogRXhhbXBsZTogYDxkaXYgY2xpY2s9XCJkb1NvbWV0aGluZygkZXZlbnQpXCI+YCB3aWxsIGdlbmVyYXRlOlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZW5kZXIzOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogY29uc3QgcGRfYjphbnkgPSAoKDxhbnk+Y3R4LmRvU29tZXRoaW5nKCRldmVudCkpICE9PSBmYWxzZSk7XG4gICAgICAgICAqIHJldHVybiBwZF9iO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogYnV0IHJlbmRlcjIgZXhwZWN0czpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHJldHVybiBjdHguZG9Tb21ldGhpbmcoJGV2ZW50KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPKG1pc2tvKTogcmVtb3ZlIHRoaXMgaGFjayBvbmNlIHdlIG5vIGxvbmdlciBzdXBwb3J0IFZpZXdFbmdpbmUuXG4gICAgICAgIHRoaXMucmVuZGVyM1N0bXRzID0gc3RtdHMubWFwKGZ1bmN0aW9uIChzdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZW1lbnQgaW5zdGFuY2VvZiBEZWNsYXJlVmFyU3RtdCAmJiBzdGF0ZW1lbnQubmFtZSA9PSBhbGxvd0RlZmF1bHQubmFtZSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlbWVudC52YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeU9wZXJhdG9yRXhwcikge1xuICAgICAgICAgICAgICAgIHZhciBsaHMgPSBzdGF0ZW1lbnQudmFsdWUubGhzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuU3RhdGVtZW50KGxocy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvbiBpc1xuICogdXNlZCBpbiBhbiBhY3Rpb24gYmluZGluZyAoZS5nLiBhbiBldmVudCBoYW5kbGVyKS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEFjdGlvbkJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYWN0aW9uLCBiaW5kaW5nSWQsIGludGVycG9sYXRpb25GdW5jdGlvbiwgYmFzZVNvdXJjZVNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcykge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIHZhciBhY3Rpb25XaXRob3V0QnVpbHRpbnMgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IGZ1bmN0aW9uIChhcmdDb3VudCkge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBhcnJheXMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gbGl0ZXJhbEFycihhcmdzKTsgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgbWFwcyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrLCBpKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGsua2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBxdW90ZWQ6IGsucXVvdGVkLFxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcChlbnRyaWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBpcGVDb252ZXJ0ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBBY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB0byBjb250YWluIHBpcGVzLiBQaXBlOiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSwgYWN0aW9uKTtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24sIGJhc2VTb3VyY2VTcGFuLCBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMpO1xuICAgIHZhciBhY3Rpb25TdG10cyA9IFtdO1xuICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKGFjdGlvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5TdGF0ZW1lbnQpLCBhY3Rpb25TdG10cyk7XG4gICAgcHJlcGVuZFRlbXBvcmFyeURlY2xzKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgYWN0aW9uU3RtdHMpO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICB2YXIgbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgcHJldmVudERlZmF1bHRWYXIgPSBudWxsO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgIHZhciByZXR1cm5FeHByID0gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihsYXN0U3RhdGVtZW50KTtcbiAgICAgICAgaWYgKHJldHVybkV4cHIpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gY2FzdCB0aGUgcmVzdWx0IG9mIHRoZSBtZXRob2QgY2FsbCB0byBkeW5hbWljLFxuICAgICAgICAgICAgLy8gYXMgaXQgbWlnaHQgYmUgYSB2b2lkIG1ldGhvZCFcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0VmFyID0gY3JlYXRlUHJldmVudERlZmF1bHRWYXIoYmluZGluZ0lkKTtcbiAgICAgICAgICAgIGFjdGlvblN0bXRzW2xhc3RJbmRleF0gPVxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0VmFyLnNldChyZXR1cm5FeHByLmNhc3QoRFlOQU1JQ19UWVBFKS5ub3RJZGVudGljYWwobGl0ZXJhbChmYWxzZSkpKVxuICAgICAgICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb252ZXJ0QWN0aW9uQmluZGluZ1Jlc3VsdChhY3Rpb25TdG10cywgcHJldmVudERlZmF1bHRWYXIpO1xufVxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbnZhciBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByKSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgIH1cbiAgICByZXR1cm4gQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdDtcbn0oKSk7XG52YXIgQmluZGluZ0Zvcm07XG4oZnVuY3Rpb24gKEJpbmRpbmdGb3JtKSB7XG4gICAgLy8gVGhlIGdlbmVyYWwgZm9ybSBvZiBiaW5kaW5nIGV4cHJlc3Npb24sIHN1cHBvcnRzIGFsbCBleHByZXNzaW9ucy5cbiAgICBCaW5kaW5nRm9ybVtCaW5kaW5nRm9ybVtcIkdlbmVyYWxcIl0gPSAwXSA9IFwiR2VuZXJhbFwiO1xuICAgIC8vIFRyeSB0byBnZW5lcmF0ZSBhIHNpbXBsZSBiaW5kaW5nIChubyB0ZW1wb3JhcmllcyBvciBzdGF0ZW1lbnRzKVxuICAgIC8vIG90aGVyd2lzZSBnZW5lcmF0ZSBhIGdlbmVyYWwgYmluZGluZ1xuICAgIEJpbmRpbmdGb3JtW0JpbmRpbmdGb3JtW1wiVHJ5U2ltcGxlXCJdID0gMV0gPSBcIlRyeVNpbXBsZVwiO1xufSkoQmluZGluZ0Zvcm0gfHwgKEJpbmRpbmdGb3JtID0ge30pKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvblxuICogaXMgdXNlZCBpbiBwcm9wZXJ0eSBiaW5kaW5nLiBUaGUgZXhwcmVzc2lvbiBoYXMgdG8gYmUgcHJlcHJvY2Vzc2VkIHZpYVxuICogYGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGluc2AuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucywgYmluZGluZ0lkLCBmb3JtLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICBpZiAoIWxvY2FsUmVzb2x2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlciA9IG5ldyBEZWZhdWx0TG9jYWxSZXNvbHZlcigpO1xuICAgIH1cbiAgICB2YXIgY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJZCk7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKTtcbiAgICB2YXIgb3V0cHV0RXhwciA9IGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnMudmlzaXQodmlzaXRvciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgdmFyIHN0bXRzID0gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCk7XG4gICAgaWYgKHZpc2l0b3IudXNlc0ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlci5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCk7XG4gICAgfVxuICAgIGlmICh2aXNpdG9yLnRlbXBvcmFyeUNvdW50ID09PSAwICYmIGZvcm0gPT0gQmluZGluZ0Zvcm0uVHJ5U2ltcGxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChbXSwgb3V0cHV0RXhwcik7XG4gICAgfVxuICAgIHN0bXRzLnB1c2goY3VyclZhbEV4cHIuc2V0KG91dHB1dEV4cHIpLnRvRGVjbFN0bXQoRFlOQU1JQ19UWVBFLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgIHJldHVybiBuZXcgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdChzdG10cywgY3VyclZhbEV4cHIpO1xufVxuLyoqXG4gKiBHaXZlbiBzb21lIGV4cHJlc3Npb24sIHN1Y2ggYXMgYSBiaW5kaW5nIG9yIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiwgYW5kIGEgY29udGV4dCBleHByZXNzaW9uIHRvXG4gKiBsb29rIHZhbHVlcyB1cCBvbiwgdmlzaXQgZWFjaCBmYWNldCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiByZXNvbHZpbmcgdmFsdWVzIGZyb20gdGhlIGNvbnRleHRcbiAqIGV4cHJlc3Npb24gc3VjaCB0aGF0IGEgbGlzdCBvZiBhcmd1bWVudHMgY2FuIGJlIGRlcml2ZWQgZnJvbSB0aGUgZm91bmQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXNcbiAqIGFyZ3VtZW50cyB0byBhbiBleHRlcm5hbCB1cGRhdGUgaW5zdHJ1Y3Rpb24uXG4gKlxuICogQHBhcmFtIGxvY2FsUmVzb2x2ZXIgVGhlIHJlc29sdmVyIHRvIHVzZSB0byBsb29rIHVwIGV4cHJlc3Npb25zIGJ5IG5hbWUgYXBwcm9wcmlhdGVseVxuICogQHBhcmFtIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBjb250ZXh0IHZhcmlhYmxlIHVzZWQgdG8gY3JlYXRlXG4gKiB0aGUgZmluYWwgYXJndW1lbnQgZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSBleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCBUaGUgZXhwcmVzc2lvbiB0byB2aXNpdCB0byBmaWd1cmUgb3V0IHdoYXQgdmFsdWVzIG5lZWQgdG9cbiAqIGJlIHJlc29sdmVkIGFuZCB3aGF0IGFyZ3VtZW50cyBsaXN0IHRvIGJ1aWxkLlxuICogQHBhcmFtIGJpbmRpbmdJZCBBIG5hbWUgcHJlZml4IHVzZWQgdG8gY3JlYXRlIHRlbXBvcmFyeSB2YXJpYWJsZSBuYW1lcyBpZiB0aGV5J3JlIG5lZWRlZCBmb3IgdGhlXG4gKiBhcmd1bWVudHMgZ2VuZXJhdGVkXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBleHByZXNzaW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIGluc3RydWN0aW9uIGV4cHJlc3Npb25zIGxpa2VcbiAqIGBvLmltcG9ydEV4cHIoUjMucHJvcGVydHlJbnRlcnBvbGF0ZSkuY2FsbEZuKHJlc3VsdClgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRVcGRhdGVBcmd1bWVudHMobG9jYWxSZXNvbHZlciwgY29udGV4dFZhcmlhYmxlRXhwcmVzc2lvbiwgZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3QsIGJpbmRpbmdJZCkge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBjb250ZXh0VmFyaWFibGVFeHByZXNzaW9uLCBiaW5kaW5nSWQsIHVuZGVmaW5lZCk7XG4gICAgdmFyIG91dHB1dEV4cHIgPSBleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdC52aXNpdCh2aXNpdG9yLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICBpZiAodmlzaXRvci51c2VzSW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgdmFyIHN0bXRzID0gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCk7XG4gICAgLy8gUmVtb3ZpbmcgdGhlIGZpcnN0IGFyZ3VtZW50LCBiZWNhdXNlIGl0IHdhcyBhIGxlbmd0aCBmb3IgVmlld0VuZ2luZSwgbm90IEl2eS5cbiAgICB2YXIgYXJncyA9IG91dHB1dEV4cHIuYXJncy5zbGljZSgxKTtcbiAgICBpZiAoZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3QgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBpbnRlcnBvbGF0aW9uIG9mIDEgdmFsdWUgd2l0aCBhbiBlbXB0eSBwcmVmaXggYW5kIHN1ZmZpeCwgcmVkdWNlIHRoZVxuICAgICAgICAvLyBhcmdzIHJldHVybmVkIHRvIGp1c3QgdGhlIHZhbHVlLCBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIHBhc3MgaXQgdG8gYSBzcGVjaWFsIGluc3RydWN0aW9uLlxuICAgICAgICB2YXIgc3RyaW5ncyA9IGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0LnN0cmluZ3M7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJykge1xuICAgICAgICAgICAgLy8gU2luZ2xlIGFyZ3VtZW50IGludGVycG9sYXRlIGluc3RydWN0aW9ucy5cbiAgICAgICAgICAgIGFyZ3MgPSBbYXJnc1sxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMTkpIHtcbiAgICAgICAgICAgIC8vIDE5IG9yIG1vcmUgYXJndW1lbnRzIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBgaW50ZXJwb2xhdGVWYC1zdHlsZSBpbnN0cnVjdGlvbnMsIHdoaWNoIGFjY2VwdFxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICAgICAgICBhcmdzID0gW2xpdGVyYWxBcnIoYXJncyldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0bXRzOiBzdG10cywgYXJnczogYXJncyB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCkge1xuICAgIHZhciBzdG10cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaXRvci50ZW1wb3JhcnlDb3VudDsgaSsrKSB7XG4gICAgICAgIHN0bXRzLnB1c2godGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBzdG10cztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCdWlsdGlucyhjb252ZXJ0ZXJGYWN0b3J5LCBhc3QpIHtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBfQnVpbHRpbkFzdENvbnZlcnRlcihjb252ZXJ0ZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IpO1xufVxuZnVuY3Rpb24gdGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBcInRtcF9cIiArIGJpbmRpbmdJZCArIFwiX1wiICsgdGVtcG9yYXJ5TnVtYmVyO1xufVxuZnVuY3Rpb24gdGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpLCBOVUxMX0VYUFIpO1xufVxuZnVuY3Rpb24gcHJlcGVuZFRlbXBvcmFyeURlY2xzKHRlbXBvcmFyeUNvdW50LCBiaW5kaW5nSWQsIHN0YXRlbWVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQodGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCBpKSk7XG4gICAgfVxufVxudmFyIF9Nb2RlO1xuKGZ1bmN0aW9uIChfTW9kZSkge1xuICAgIF9Nb2RlW19Nb2RlW1wiU3RhdGVtZW50XCJdID0gMF0gPSBcIlN0YXRlbWVudFwiO1xuICAgIF9Nb2RlW19Nb2RlW1wiRXhwcmVzc2lvblwiXSA9IDFdID0gXCJFeHByZXNzaW9uXCI7XG59KShfTW9kZSB8fCAoX01vZGUgPSB7fSkpO1xuZnVuY3Rpb24gZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuU3RhdGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGEgc3RhdGVtZW50LCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbiBleHByZXNzaW9uLCBidXQgc2F3IFwiICsgYXN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbnZhciBfQnVpbHRpbkFzdENvbnZlcnRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoX0J1aWx0aW5Bc3RDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0J1aWx0aW5Bc3RDb252ZXJ0ZXIoX2NvbnZlcnRlckZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NvbnZlcnRlckZhY3RvcnkgPSBfY29udmVydGVyRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfQnVpbHRpbkFzdENvbnZlcnRlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IF9fc3ByZWFkKFthc3QuZXhwXSwgYXN0LmFyZ3MpLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVQaXBlQ29udmVydGVyKGFzdC5uYW1lLCBhcmdzLmxlbmd0aCkpO1xuICAgIH07XG4gICAgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IGFzdC5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpKTtcbiAgICB9O1xuICAgIF9CdWlsdGluQXN0Q29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gYXN0LnZhbHVlcy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcihhc3Qua2V5cykpO1xuICAgIH07XG4gICAgcmV0dXJuIF9CdWlsdGluQXN0Q29udmVydGVyO1xufShBc3RUcmFuc2Zvcm1lciQxKSk7XG52YXIgX0FzdFRvSXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Bc3RUb0lyVmlzaXRvcihfbG9jYWxSZXNvbHZlciwgX2ltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uLCBiYXNlU291cmNlU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYmFzZVNvdXJjZVNwYW4gPSBiYXNlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMgPSBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXM7XG4gICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Jlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeSA9IDA7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1pbnVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRGl2aWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Nb2R1bG87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5BbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5PcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG9wZXJhdGlvbiBcIiArIGFzdC5vcGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKG9wLCB0aGlzLl92aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMuX3Zpc2l0KGFzdC5yaWdodCwgX01vZGUuRXhwcmVzc2lvbiksIHVuZGVmaW5lZCwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIG1vZGUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92aXNpdChhc3QuY29uZGl0aW9uLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMuX3Zpc2l0KGFzdC50cnVlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LmZhbHNlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBQaXBlcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9ucy4gUGlwZTogXCIgKyBhc3QubmFtZSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgY29udmVydGVkQXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgZm5SZXN1bHQ7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBCdWlsdGluRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBmblJlc3VsdCA9IGFzdC5jb252ZXJ0ZXIoY29udmVydGVkQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmblJlc3VsdCA9IHRoaXMuX3Zpc2l0KGFzdC50YXJnZXQsIF9Nb2RlLkV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgLmNhbGxGbihjb252ZXJ0ZWRBcmdzLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGZuUmVzdWx0KTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbbGl0ZXJhbChhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1tpXSkpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb25GdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoIDw9IDkgP1xuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbmxpbmVJbnRlcnBvbGF0ZSkuY2FsbEZuKGFyZ3MpIDpcbiAgICAgICAgICAgIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgYXJnc1swXSwgbGl0ZXJhbEFycihhcmdzLnNsaWNlKDEpLCB1bmRlZmluZWQsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKVxuICAgICAgICAgICAgXSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl92aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKS5rZXkodGhpcy5fdmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLl92aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgb2JqLmtleShrZXkpLnNldCh2YWx1ZSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBhcnJheXMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBtYXBzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zXCIpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIC8vIEZvciBsaXRlcmFsIHZhbHVlcyBvZiBudWxsLCB1bmRlZmluZWQsIHRydWUsIG9yIGZhbHNlIGFsbG93IHR5cGUgaW50ZXJmZXJlbmNlXG4gICAgICAgIC8vIHRvIGluZmVyIHRoZSB0eXBlLlxuICAgICAgICB2YXIgdHlwZSA9IGFzdC52YWx1ZSA9PT0gbnVsbCB8fCBhc3QudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBhc3QudmFsdWUgPT09IHRydWUgfHwgYXN0LnZhbHVlID09PSB0cnVlID9cbiAgICAgICAgICAgIElORkVSUkVEX1RZUEUgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbChhc3QudmFsdWUsIHR5cGUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl9nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFJlc29sdmVyLmdldExvY2FsKG5hbWUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGlmIChhc3QucmVjZWl2ZXIgaW5zdGFuY2VvZiBJbXBsaWNpdFJlY2VpdmVyICYmIGFzdC5uYW1lID09ICckYW55Jykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxsIHRvICRhbnksIGV4cGVjdGVkIDEgYXJndW1lbnQgYnV0IHJlY2VpdmVkIFwiICsgKGFyZ3MubGVuZ3RoIHx8ICdub25lJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF0uY2FzdChEWU5BTUlDX1RZUEUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhckV4cHIuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEltcGxpY2l0UmVjZWl2ZXJBY2Nlc3MoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncywgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBub3QodGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGFzc2VydE5vdE51bGwodGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXZVc2VzSW1wbGljaXRSZWNlaXZlciA9IHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl92aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgXCJ1c2VzSW1wbGljaXRSZWNlaXZlclwiIHN0YXRlIHNpbmNlIHRoZSBpbXBsaWNpdFxuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgcmVzb2x2ZWQgbG9jYWwgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlciA9IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzKGFzdC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl92aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgdmFyIHZhckV4cHIgPSBudWxsO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbEV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICBpZiAobG9jYWxFeHByKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsRXhwciBpbnN0YW5jZW9mIFJlYWRQcm9wRXhwcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbG9jYWwgdmFyaWFibGUgaXMgYSBwcm9wZXJ0eSByZWFkIGV4cHJlc3Npb24sIGl0J3MgYSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSAnY29udGV4dC5wcm9wZXJ0eScgdmFsdWUgYW5kIHdpbGwgYmUgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB3cml0ZSBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXJFeHByID0gbG9jYWxFeHByO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBcInVzZXNJbXBsaWNpdFJlY2VpdmVyXCIgc3RhdGUgc2luY2UgdGhlIGltcGxpY2l0XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVyIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYSByZXNvbHZlZCBsb2NhbCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEltcGxpY2l0UmVjZWl2ZXJBY2Nlc3MoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0J3MgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlcl8xID0gYXN0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IChhc3QudmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0eVJlYWQpID8gYXN0LnZhbHVlLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhc3NpZ24gdmFsdWUgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdG8gdGVtcGxhdGUgdmFyaWFibGUgXFxcIlwiICsgcmVjZWl2ZXJfMSArIFwiXFxcIi4gVGVtcGxhdGUgdmFyaWFibGVzIGFyZSByZWFkLW9ubHkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBsb2NhbCBleHByZXNzaW9uIGNvdWxkIGJlIHByb2R1Y2VkLCB1c2UgdGhlIG9yaWdpbmFsIHJlY2VpdmVyJ3NcbiAgICAgICAgLy8gcHJvcGVydHkgYXMgdGhlIHRhcmdldC5cbiAgICAgICAgaWYgKHZhckV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhckV4cHIgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFyRXhwci5zZXQodGhpcy5fdmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgbW9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gYXN0cy5tYXAoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdW90ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGV2YWx1YXRpb24hXFxuICAgICAgICBTdGF0ZW1lbnQ6IFwiICsgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uICsgXCIgbG9jYXRlZCBhdCBcIiArIGFzdC5sb2NhdGlvbik7XG4gICAgfTtcbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl92aXNpdCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U2FmZUFjY2VzcyA9IGZ1bmN0aW9uIChhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIGxlZnQgcGFydCBvZiB0aGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgIC8vIENvbnNpZGVyLCBmb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb246IGE/LmIuYz8uZC5lXG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiB0aGUgYXN0OlxuICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgLy8gICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgPy4gICBlXG4gICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgLy8gICAgIC4gICAgZFxuICAgICAgICAvLyAgICAvIFxcXG4gICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgLy8gIC8gIFxcXG4gICAgICAgIC8vIGEgICAgYlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIC8tLS0tID8gLS0tLVxcXG4gICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgLy8gICAgIGEgICAvLS0tID8gLS0tXFwgIG51bGxcbiAgICAgICAgLy8gICAgICAgIC8gICAgIHwgICAgIFxcXG4gICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgIC8vICAgICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgICAuICBjICAgLiAgIGVcbiAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgYSAgIGIgIC4gICBkXG4gICAgICAgIC8vICAgICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgLy8gICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgIGEgICBiXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBndWFyZCBjb25kaXRpb24gaXMgdGhlIGxlZnQgaGFuZCBvZiB0aGUgbGVmdCBtb3N0IHNhZmUgYWNjZXNzIG5vZGVcbiAgICAgICAgLy8gd2hpY2ggY29tZXMgaW4gYXMgbGVmdE1vc3RTYWZlIHRvIHRoaXMgcm91dGluZS5cbiAgICAgICAgdmFyIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy5fdmlzaXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIHRlbXBvcmFyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnkobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gaGFzIG1ldGhvZCBjYWxscyBvciBwaXBlcyB0aGVuIHdlIG5lZWQgdG8gc2F2ZSB0aGUgcmVzdWx0IGludG8gYVxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGF2b2lkIGNhbGxpbmcgc3RhdGVmdWwgb3IgaW1wdXJlIGNvZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgcmVzdWx0IGluIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGVcbiAgICAgICAgICAgIGd1YXJkZWRFeHByZXNzaW9uID0gdGVtcG9yYXJ5LnNldChndWFyZGVkRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdE1hcC5zZXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCB0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGFzdCB0byBhbiB1bmd1YXJkZWQgYWNjZXNzIHRvIHRoZSByZWNlaXZlcidzIG1lbWJlci4gVGhlIG1hcCB3aWxsIHN1YnN0aXR1dGVcbiAgICAgICAgLy8gbGVmdE1vc3ROb2RlIHdpdGggaXRzIHVuZ3VhcmRlZCB2ZXJzaW9uIGluIHRoZSBjYWxsIHRvIGB0aGlzLnZpc2l0KClgLlxuICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IE1ldGhvZENhbGwobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5zb3VyY2VTcGFuLCBsZWZ0TW9zdFNhZmUubmFtZVNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUsIGxlZnRNb3N0U2FmZS5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBQcm9wZXJ0eVJlYWQobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5zb3VyY2VTcGFuLCBsZWZ0TW9zdFNhZmUubmFtZVNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgIHZhciBhY2Nlc3MgPSB0aGlzLl92aXNpdChhc3QsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgIC8vIG9uY2UgYnV0IGlzIHNhZmVyIGlmIHRoZSBjb252ZXJzaW9uIGlzIGNoYW5nZWQgdG8gdHJhdmVyc2UgdGhlIG5vZGVzIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICB0aGlzLl9ub2RlTWFwLmRlbGV0ZShsZWZ0TW9zdFNhZmUpO1xuICAgICAgICAvLyBJZiB3ZSBhbGxvY2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2R1Y2UgdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBjb25kaXRpb24uY29uZGl0aW9uYWwobGl0ZXJhbChudWxsKSwgYWNjZXNzKSk7XG4gICAgfTtcbiAgICAvLyBHaXZlbiBhbiBleHByZXNzaW9uIG9mIHRoZSBmb3JtIGE/LmIuYz8uZC5lIHRoZW4gdGhlIGxlZnQgbW9zdCBzYWZlIG5vZGUgaXNcbiAgICAvLyB0aGUgKGE/LmIpLiBUaGUgLiBhbmQgPy4gYXJlIGxlZnQgYXNzb2NpYXRpdmUgdGh1cyBjYW4gYmUgcmV3cml0dGVuIGFzOlxuICAgIC8vICgoKChhPy5jKS5iKS5jKT8uZCkuZS4gVGhpcyByZXR1cm5zIHRoZSBtb3N0IGRlZXBseSBuZXN0ZWQgc2FmZSByZWFkIG9yXG4gICAgLy8gc2FmZSBtZXRob2QgY2FsbCBhcyB0aGlzIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGluaXRpYWxseSB0bzpcbiAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmMuYi5jPy5kLmVcbiAgICAvLyB0aGVuIHRvOlxuICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYi5jID09IG51bGwgPyBudWxsIDogYS5iLmMuZC5lXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0Lm9iaik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdHJ1ZSBvZiB0aGUgQVNUIGluY2x1ZGVzIGEgbWV0aG9kIG9yIGEgcGlwZSBpbmRpY2F0aW5nIHRoYXQsIGlmIHRoZVxuICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAvLyB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgc3RvcmVkIGludG8gYSB0ZW1wb3JhcnkgdmFyaWFibGUuXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5uZWVkc1RlbXBvcmFyeSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdCAmJiAoX3RoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZpc2l0U29tZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh2aXNpdG9yLCBhc3QpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QubGVmdCkgfHwgdmlzaXQodGhpcywgYXN0LnJpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8IHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXROb25OdWxsQXNzZXJ0OiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGU6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuYWxsb2NhdGVUZW1wb3JhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH07XG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWJzb2x1dGUgYFBhcnNlU291cmNlU3BhbmAgZnJvbSB0aGUgcmVsYXRpdmUgYFBhcnNlU3BhbmAuXG4gICAgICpcbiAgICAgKiBgUGFyc2VTcGFuYCBvYmplY3RzIGFyZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgdGhlc2UgdG8gZnVsbCBgUGFyc2VTb3VyY2VTcGFuYCBvYmplY3RzIHRoYXRcbiAgICAgKiBzaG93IHdoZXJlIHRoZSBzcGFuIGlzIHdpdGhpbiB0aGUgb3ZlcmFsbCBzb3VyY2UgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGFuIHRoZSByZWxhdGl2ZSBzcGFuIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMgYSBgUGFyc2VTb3VyY2VTcGFuYCBmb3IgdGhlIGdpdmVuIHNwYW4gb3IgbnVsbCBpZiBub1xuICAgICAqIGBiYXNlU291cmNlU3BhbmAgd2FzIHByb3ZpZGVkIHRvIHRoaXMgY2xhc3MuXG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U291cmNlU3BhbiA9IGZ1bmN0aW9uIChzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmJhc2VTb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShzcGFuLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmJhc2VTb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShzcGFuLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQWRkcyB0aGUgbmFtZSBvZiBhbiBBU1QgdG8gdGhlIGxpc3Qgb2YgaW1wbGljaXQgcmVjZWl2ZXIgYWNjZXNzZXMuICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5hZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcy5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gZmxhdHRlblN0YXRlbWVudHMoYXJnLCBvdXRwdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZmxhdHRlblN0YXRlbWVudHMoZW50cnksIG91dHB1dCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYXJnKTtcbiAgICB9XG59XG52YXIgRGVmYXVsdExvY2FsUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdExvY2FsUmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIERlZmF1bHRMb2NhbFJlc29sdmVyLnByb3RvdHlwZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIERlZmF1bHRMb2NhbFJlc29sdmVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzLmV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRMb2NhbFJlc29sdmVyO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0lkKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGJpbmRpbmdJZCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG59XG5mdW5jdGlvbiBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJwZF9cIiArIGJpbmRpbmdJZCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKHN0bXQpIHtcbiAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gc3RtdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgQnVpbHRpbkZ1bmN0aW9uQ2FsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVpbHRpbkZ1bmN0aW9uQ2FsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdWlsdGluRnVuY3Rpb25DYWxsKHNwYW4sIHNvdXJjZVNwYW4sIGFyZ3MsIGNvbnZlcnRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBzb3VyY2VTcGFuLCBudWxsLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMuY29udmVydGVyID0gY29udmVydGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdWlsdGluRnVuY3Rpb25DYWxsO1xufShGdW5jdGlvbkNhbGwpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIGZpbGUgaXMgYSBwb3J0IG9mIHNoYWRvd0NTUyBmcm9tIHdlYmNvbXBvbmVudHMuanMgdG8gVHlwZVNjcmlwdC5cbiAqXG4gKiBQbGVhc2UgbWFrZSBzdXJlIHRvIGtlZXAgdG8gZWRpdHMgaW4gc3luYyB3aXRoIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBTb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi80ZWZlY2Q3ZTBlL3NyYy9TaGFkb3dDU1MvU2hhZG93Q1NTLmpzXG4gKlxuICogVGhlIG9yaWdpbmFsIGZpbGUgbGV2ZWwgY29tbWVudCBpcyByZXByb2R1Y2VkIGJlbG93XG4gKi9cbi8qXG4gIFRoaXMgaXMgYSBsaW1pdGVkIHNoaW0gZm9yIFNoYWRvd0RPTSBjc3Mgc3R5bGluZy5cbiAgaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy93ZWJjb21wb25lbnRzL3Jhdy1maWxlL3RpcC9zcGVjL3NoYWRvdy9pbmRleC5odG1sI3N0eWxlc1xuXG4gIFRoZSBpbnRlbnRpb24gaGVyZSBpcyB0byBzdXBwb3J0IG9ubHkgdGhlIHN0eWxpbmcgZmVhdHVyZXMgd2hpY2ggY2FuIGJlXG4gIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcbiAgbW9zdCBvYnZpb3VzIHBpdGZhbGxzIGFuZCBkbyBzbyB3aXRob3V0IGNvbXByb21pc2luZyBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuICBGb3IgU2hhZG93RE9NIHN0eWxpbmcgdGhhdCdzIG5vdCBjb3ZlcmVkIGhlcmUsIGEgc2V0IG9mIGJlc3QgcHJhY3RpY2VzXG4gIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxuXG4gIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHNwZWNpZmljIFNoYWRvd0RPTSBzdHlsaW5nIGZlYXR1cmVzIGFuZCBhIGJyaWVmXG4gIGRpc2N1c3Npb24gb2YgdGhlIGFwcHJvYWNoIHVzZWQgdG8gc2hpbS5cblxuICBTaGltbWVkIGZlYXR1cmVzOlxuXG4gICogOmhvc3QsIDpob3N0LWNvbnRleHQ6IFNoYWRvd0RPTSBhbGxvd3Mgc3R5bGluZyBvZiB0aGUgc2hhZG93Um9vdCdzIGhvc3RcbiAgZWxlbWVudCB1c2luZyB0aGUgOmhvc3QgcnVsZS4gVG8gc2hpbSB0aGlzIGZlYXR1cmUsIHRoZSA6aG9zdCBzdHlsZXMgYXJlXG4gIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxuICBkb2N1bWVudCBsZXZlbCBzdHlsZXNoZWV0LlxuICBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSBzY29wZSBuYW1lIG9mIC5mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICA6aG9zdCB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgYmVjb21lczpcblxuICAgIC5mb28ge1xuICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgIH1cblxuICAqIGVuY2Fwc3VsYXRpb246IFN0eWxlcyBkZWZpbmVkIHdpdGhpbiBTaGFkb3dET00sIGFwcGx5IG9ubHkgdG9cbiAgZG9tIGluc2lkZSB0aGUgU2hhZG93RE9NLiBQb2x5bWVyIHVzZXMgb25lIG9mIHR3byB0ZWNobmlxdWVzIHRvIGltcGxlbWVudFxuICB0aGlzIGZlYXR1cmUuXG5cbiAgQnkgZGVmYXVsdCwgcnVsZXMgYXJlIHByZWZpeGVkIHdpdGggdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZVxuICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xuICBvZiB0aGUgZWxlbWVudCdzIFNoYWRvd0RPTS4gRm9yIGV4YW1wbGUsXG5cbiAgZGl2IHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gIHgtZm9vIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuXG4gIEFsdGVybmF0aXZlbHksIGlmIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLnN0cmljdFN0eWxpbmcgaXMgc2V0IHRvIHRydWUgdGhlblxuICBzZWxlY3RvcnMgYXJlIHNjb3BlZCBieSBhZGRpbmcgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHN1ZmZpeCB0byBlYWNoXG4gIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxuICBpbiB0aGUgZWxlbWVudCdzIFNoYWRvd0RPTSB0ZW1wbGF0ZSBpcyBhbHNvIGdpdmVuIHRoZSBzY29wZSBhdHRyaWJ1dGUuXG4gIFRodXMsIHRoZXNlIHJ1bGVzIG1hdGNoIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBzY29wZSBhdHRyaWJ1dGUuXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICBkaXYge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cbiAgICBkaXZbeC1mb29dIHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBOb3RlIHRoYXQgZWxlbWVudHMgdGhhdCBhcmUgZHluYW1pY2FsbHkgYWRkZWQgdG8gYSBzY29wZSBtdXN0IGhhdmUgdGhlIHNjb3BlXG4gIHNlbGVjdG9yIGFkZGVkIHRvIHRoZW0gbWFudWFsbHkuXG5cbiAgKiB1cHBlci9sb3dlciBib3VuZCBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgd2hpY2ggYXJlIGRlZmluZWQgb3V0c2lkZSBhXG4gIHNoYWRvd1Jvb3Qgc2hvdWxkIG5vdCBjcm9zcyB0aGUgU2hhZG93RE9NIGJvdW5kYXJ5IGFuZCBzaG91bGQgbm90IGFwcGx5XG4gIGluc2lkZSBhIHNoYWRvd1Jvb3QuXG5cbiAgVGhpcyBzdHlsaW5nIGJlaGF2aW9yIGlzIG5vdCBlbXVsYXRlZC4gU29tZSBwb3NzaWJsZSB3YXlzIHRvIGRvIHRoaXMgdGhhdFxuICB3ZXJlIHJlamVjdGVkIGR1ZSB0byBjb21wbGV4aXR5IGFuZC9vciBwZXJmb3JtYW5jZSBjb25jZXJucyBpbmNsdWRlOiAoMSkgcmVzZXRcbiAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XG4gICgyKSByZS1pbXBsZW1lbnQgY3NzIGluIGphdmFzY3JpcHQuXG5cbiAgQXMgYW4gYWx0ZXJuYXRpdmUsIHVzZXJzIHNob3VsZCBtYWtlIHN1cmUgdG8gdXNlIHNlbGVjdG9yc1xuICBzcGVjaWZpYyB0byB0aGUgc2NvcGUgaW4gd2hpY2ggdGhleSBhcmUgd29ya2luZy5cblxuICAqIDo6ZGlzdHJpYnV0ZWQ6IFRoaXMgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBJdCdzIG9mdGVuIG5vdCBuZWNlc3NhcnlcbiAgdG8gc3R5bGUgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgaW5zZXJ0aW9uIHBvaW50IGFuZCBpbnN0ZWFkLCBkZXNjZW5kYW50c1xuICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxuICBleHRyYSBub2RlIGFyb3VuZCBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIHN0eWxlIHRoYXQgbm9kZSdzIGNvbnRlbnRzXG4gIHZpYSBkZXNjZW5kZW50IHNlbGVjdG9ycy4gRm9yIGV4YW1wbGUsIHdpdGggYSBzaGFkb3dSb290IGxpa2UgdGhpczpcblxuICAgIDxzdHlsZT5cbiAgICAgIDo6Y29udGVudChkaXYpIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gICAgPGNvbnRlbnQ+PC9jb250ZW50PlxuXG4gIGNvdWxkIGJlY29tZTpcblxuICAgIDxzdHlsZT5cbiAgICAgIC8gKkBwb2x5ZmlsbCAuY29udGVudC1jb250YWluZXIgZGl2ICogL1xuICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudC1jb250YWluZXJcIj5cbiAgICAgIDxjb250ZW50PjwvY29udGVudD5cbiAgICA8L2Rpdj5cblxuICBOb3RlIHRoZSB1c2Ugb2YgQHBvbHlmaWxsIGluIHRoZSBjb21tZW50IGFib3ZlIGEgU2hhZG93RE9NIHNwZWNpZmljIHN0eWxlXG4gIGRlY2xhcmF0aW9uLiBUaGlzIGlzIGEgZGlyZWN0aXZlIHRvIHRoZSBzdHlsaW5nIHNoaW0gdG8gdXNlIHRoZSBzZWxlY3RvclxuICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cbiovXG52YXIgU2hhZG93Q3NzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNoYWRvd0NzcygpIHtcbiAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBTaGltIHNvbWUgY3NzVGV4dCB3aXRoIHRoZSBnaXZlbiBzZWxlY3Rvci4gUmV0dXJucyBjc3NUZXh0IHRoYXQgY2FuXG4gICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgICpcbiAgICAgKiBXaGVuIHN0cmljdFN0eWxpbmcgaXMgdHJ1ZTpcbiAgICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAgKiAtIGhvc3RTZWxlY3RvciBpcyB0aGUgYXR0cmlidXRlIGFkZGVkIHRvIHRoZSBob3N0IGl0c2VsZi5cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgIHZhciBjb21tZW50c1dpdGhIYXNoID0gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpcENvbW1lbnRzKGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcbiAgICAgICAgdmFyIHNjb3BlZENzc1RleHQgPSB0aGlzLl9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZChbc2NvcGVkQ3NzVGV4dF0sIGNvbW1lbnRzV2l0aEhhc2gpLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcbiAgICAgKiB1cCB0aGUgY3NzIHBhcnNlcjsgd2UgcmVseSBvbiBkZWNvcmF0aW5nIHRoZSBzdHlsZXNoZWV0IHdpdGggaW5lcnQgcnVsZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICpcbiAgICAgKiBwb2x5ZmlsbC1uZXh0LXNlbGVjdG9yIHsgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7IH1cbiAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBzY29wZU5hbWUgbWVudS1pdGVtIHtcbiAgICAgKlxuICAgICAqKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogcG9seWZpbGwtcnVsZSB7XG4gICAgICogICBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJztcbiAgICAgKiAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7Li4ufVxuICAgICAqXG4gICAgICoqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnRSdWxlUmUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBFbnN1cmUgc3R5bGVzIGFyZSBzY29wZWQuIFBzZXVkby1zY29waW5nIHRha2VzIGEgcnVsZSBsaWtlOlxuICAgICAqXG4gICAgICogIC5mb28gey4uLiB9XG4gICAgICpcbiAgICAgKiAgYW5kIGNvbnZlcnRzIHRoaXMgdG9cbiAgICAgKlxuICAgICAqICBzY29wZU5hbWUgLmZvbyB7IC4uLiB9XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVDc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgdW5zY29wZWRSdWxlcyA9IHRoaXMuX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIC8vIHJlcGxhY2UgOmhvc3QgYW5kIDpob3N0LWNvbnRleHQgLXNoYWRvd2Nzc2hvc3QgYW5kIC1zaGFkb3djc3Nob3N0IHJlc3BlY3RpdmVseVxuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KTtcbiAgICAgICAgaWYgKHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNzc1RleHQgPSBjc3NUZXh0ICsgJ1xcbicgKyB1bnNjb3BlZFJ1bGVzO1xuICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICogYW5kIGRvIG5vdCBwcm9jZXNzIHZpYSBDU1NPTS4gKENTU09NIGlzIGRlc3RydWN0aXZlIHRvIHJ1bGVzIG9uIHJhcmVcbiAgICAgKiBvY2Nhc2lvbnMsIGUuZy4gLXdlYmtpdC1jYWxjIG9uIFNhZmFyaS4pXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogQHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUge1xuICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICogLi4uIH1cbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBtZW51LWl0ZW0gey4uLn1cbiAgICAgKlxuICAgICAqKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKG0gPSBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmV4ZWMoY3NzVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLypcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyXG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdC1jb250ZXh0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIHNjb3BlTmFtZSA+IC5iYXIgeyB9XG4gICAgICpcbiAgICAgKiBhbmRcbiAgICAgKlxuICAgICAqIDpob3N0LWNvbnRleHQoLmZvbzpob3N0KSAuYmFyIHsgLi4uIH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gLmJhciB7IC4uLiB9XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvblJ1bGUgPSBmdW5jdGlvbiAoY3NzVGV4dCwgcmVnRXhwLCBwYXJ0UmVwbGFjZXIpIHtcbiAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBtWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgbVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICBpZiAocGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3QpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29sb25Ib3N0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XG4gICAgICogYnkgcmVwbGFjaW5nIHdpdGggc3BhY2UuXG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBfc2hhZG93RE9NU2VsZWN0b3JzUmUucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhdHRlcm4pIHsgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKHBhdHRlcm4sICcgJyk7IH0sIGNzc1RleHQpO1xuICAgIH07XG4gICAgLy8gY2hhbmdlIGEgc2VsZWN0b3IgbGlrZSAnZGl2JyB0byAnbmFtZSBkaXYnXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9ICdAJykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF90aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkZWVwUGFydHMpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChkZWVwUGFydHMpLCBzaGFsbG93UGFydCA9IF9hWzBdLCBvdGhlclBhcnRzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICB2YXIgYXBwbHlTY29wZSA9IGZ1bmN0aW9uIChzaGFsbG93UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWQoW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXSwgb3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgIH07XG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fbWFrZVNjb3BlTWF0Y2hlciA9IGZ1bmN0aW9uIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgIHNjb3BlU2VsZWN0b3IgPSBzY29wZVNlbGVjdG9yLnJlcGxhY2UobHJlLCAnXFxcXFsnKS5yZXBsYWNlKHJyZSwgJ1xcXFxdJyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKCcgKyBzY29wZVNlbGVjdG9yICsgJyknICsgX3NlbGVjdG9yUmVTdWZmaXgsICdtJyk7XG4gICAgfTtcbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIGZyb20gd2ViY29tcG9uZW50cy5qczogc2NvcGVTZWxlY3RvciBjb3VsZCBub3QgYmUgYW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAvLyBJbiBBbmRyb2lkIGJyb3dzZXIsIHRoZSBsYXN0SW5kZXggaXMgbm90IHJlc2V0IHdoZW4gdGhlIHJlZ2V4IGlzIHVzZWQgaW4gU3RyaW5nLnJlcGxhY2UoKVxuICAgICAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKF9wb2x5ZmlsbEhvc3RSZS50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeV8xID0gdGhpcy5zdHJpY3RTdHlsaW5nID8gXCJbXCIgKyBob3N0U2VsZWN0b3IgKyBcIl1cIiA6IHNjb3BlU2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsIGZ1bmN0aW9uIChobmMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoLyhbXjpdKikoOiopKC4qKS8sIGZ1bmN0aW9uIChfLCBiZWZvcmUsIGNvbG9uLCBhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlICsgcmVwbGFjZUJ5XzEgKyBjb2xvbiArIGFmdGVyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH07XG4gICAgLy8gcmV0dXJuIGEgc2VsZWN0b3Igd2l0aCBbbmFtZV0gc3VmZml4IG9uIGVhY2ggc2ltcGxlIHNlbGVjdG9yXG4gICAgLy8gZS5nLiAuZm9vLmJhciA+IC56b3QgYmVjb21lcyAuZm9vW25hbWVdLmJhcltuYW1lXSA+IC56b3RbbmFtZV0gIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gJ1snICsgc2NvcGVTZWxlY3RvciArICddJztcbiAgICAgICAgdmFyIF9zY29wZVNlbGVjdG9yUGFydCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNhZmVDb250ZW50ID0gbmV3IFNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudCgpO1xuICAgICAgICB2YXIgc2NvcGVkU2VsZWN0b3IgPSAnJztcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gICAgICAgIC8vIElmIGEgc2VsZWN0b3IgYXBwZWFycyBiZWZvcmUgOmhvc3QgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgICAgIC8vIG1hdGNoZXMgb24gYW5jZXN0b3IgZWxlbWVudHMgYW5kIG5vdCBvbiBlbGVtZW50cyBpbiB0aGUgaG9zdCdzIHNoYWRvd1xuICAgICAgICAvLyBgOmhvc3QtY29udGV4dChkaXYpYCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyBgLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcmRpdiwgZGl2IC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JgXG4gICAgICAgIC8vIHRoZSBgZGl2YCBpcyBub3QgcGFydCBvZiB0aGUgY29tcG9uZW50IGluIHRoZSAybmQgc2VsZWN0b3JzIGFuZCBzaG91bGQgbm90IGJlIHNjb3BlZC5cbiAgICAgICAgLy8gSGlzdG9yaWNhbGx5IGBjb21wb25lbnQtdGFnOmhvc3RgIHdhcyBtYXRjaGluZyB0aGUgY29tcG9uZW50IHNvIHdlIGFsc28gd2FudCB0byBwcmVzZXJ2ZVxuICAgICAgICAvLyB0aGlzIGJlaGF2aW9yIHRvIGF2b2lkIGJyZWFraW5nIGxlZ2FjeSBhcHBzIChpdCBzaG91bGQgbm90IG1hdGNoKS5cbiAgICAgICAgLy8gVGhlIGJlaGF2aW9yIHNob3VsZCBiZTpcbiAgICAgICAgLy8gLSBgdGFnOmhvc3RgIC0+IGB0YWdbaF1gICh0aGlzIGlzIHRvIGF2b2lkIGJyZWFraW5nIGxlZ2FjeSBhcHBzLCBzaG91bGQgbm90IG1hdGNoIGFueXRoaW5nKVxuICAgICAgICAvLyAtIGB0YWcgOmhvc3RgIC0+IGB0YWcgW2hdYCAoYHRhZ2AgaXMgbm90IHNjb3BlZCBiZWNhdXNlIGl0J3MgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAgICAgLy8gICBgOmhvc3QtY29udGV4dCh0YWcpYClcbiAgICAgICAgdmFyIGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIC8vIE9ubHkgc2NvcGUgcGFydHMgYWZ0ZXIgdGhlIGZpcnN0IGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYCB3aGVuIGl0IGlzIHByZXNlbnRcbiAgICAgICAgdmFyIHNob3VsZFNjb3BlID0gIWhhc0hvc3Q7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHJlc1sxXTtcbiAgICAgICAgICAgIHZhciBwYXJ0XzEgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydF8xLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgICAgIHZhciBzY29wZWRQYXJ0ID0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydF8xKSA6IHBhcnRfMTtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnQgPSBzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIHJldHVybiBzYWZlQ29udGVudC5yZXN0b3JlKHNjb3BlZFNlbGVjdG9yKTtcbiAgICB9O1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhZG93Q3NzO1xufSgpKTtcbnZhciBTYWZlU2VsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIGZ1bmN0aW9uIChfLCBwc2V1ZG8sIGV4cCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCBmdW5jdGlvbiAocGgsIGluZGV4KSB7IHJldHVybiBfdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XTsgfSk7XG4gICAgfTtcbiAgICBTYWZlU2VsZWN0b3IucHJvdG90eXBlLmNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTZWxlY3Rvcjtcbn0oKSk7XG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG52YXIgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0Jztcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgJylcXFxcKSk/KFteLHtdKiknO1xudmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbnZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbi8vIFRoZSBkZWVwIGNvbWJpbmF0b3IgaXMgZGVwcmVjYXRlZCBpbiB0aGUgQ1NTIHNwZWNcbi8vIFN1cHBvcnQgZm9yIGA+Pj5gLCBgZGVlcGAsIGA6Om5nLWRlZXBgIGlzIHRoZW4gYWxzbyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMTc2NzdcbnZhciBfc2hhZG93RGVlcFNlbGVjdG9ycyA9IC8oPzo+Pj4pfCg/OlxcL2RlZXBcXC8pfCg/Ojo6bmctZGVlcCkvZztcbnZhciBfc2VsZWN0b3JSZVN1ZmZpeCA9ICcoWz5cXFxcc34rXFxbLix7Ol1bXFxcXHNcXFxcU10qKT8kJztcbnZhciBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG52YXIgX2NvbG9uSG9zdENvbnRleHRSZSA9IC86aG9zdC1jb250ZXh0L2dpbTtcbnZhciBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxudmFyIF9jb21tZW50V2l0aEhhc2hSZSA9IC9cXC9cXCpcXHMqI1xccypzb3VyY2UoTWFwcGluZyk/VVJMPVtcXHNcXFNdKz9cXCpcXC8vZztcbmZ1bmN0aW9uIGV4dHJhY3RDb21tZW50c1dpdGhIYXNoKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0Lm1hdGNoKF9jb21tZW50V2l0aEhhc2hSZSkgfHwgW107XG59XG52YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG52YXIgX2N1cmx5UmUgPSAvKFt7fV0pL2c7XG52YXIgT1BFTl9DVVJMWSA9ICd7JztcbnZhciBDTE9TRV9DVVJMWSA9ICd9JztcbnZhciBCTE9DS19QTEFDRUhPTERFUiA9ICclQkxPQ0slJztcbnZhciBDc3NSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gQ3NzUnVsZTtcbn0oKSk7XG5mdW5jdGlvbiBwcm9jZXNzUnVsZXMoaW5wdXQsIHJ1bGVDYWxsYmFjaykge1xuICAgIHZhciBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0KTtcbiAgICB2YXIgbmV4dEJsb2NrSW5kZXggPSAwO1xuICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAnJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IG1bNF07XG4gICAgICAgIHZhciBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChzdWZmaXggJiYgc3VmZml4LnN0YXJ0c1dpdGgoJ3snICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgY29udGVudFByZWZpeCA9ICd7JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZSA9IHJ1bGVDYWxsYmFjayhuZXcgQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkpO1xuICAgICAgICByZXR1cm4gXCJcIiArIG1bMV0gKyBydWxlLnNlbGVjdG9yICsgbVszXSArIGNvbnRlbnRQcmVmaXggKyBydWxlLmNvbnRlbnQgKyBzdWZmaXg7XG4gICAgfSk7XG59XG52YXIgU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3MoZXNjYXBlZFN0cmluZywgYmxvY2tzKSB7XG4gICAgICAgIHRoaXMuZXNjYXBlZFN0cmluZyA9IGVzY2FwZWRTdHJpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3M7XG59KCkpO1xuZnVuY3Rpb24gZXNjYXBlQmxvY2tzKGlucHV0KSB7XG4gICAgdmFyIGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XG4gICAgdmFyIHJlc3VsdFBhcnRzID0gW107XG4gICAgdmFyIGVzY2FwZWRCbG9ja3MgPSBbXTtcbiAgICB2YXIgYnJhY2tldENvdW50ID0gMDtcbiAgICB2YXIgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICBmb3IgKHZhciBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBpbnB1dFBhcnRzLmxlbmd0aDsgcGFydEluZGV4KyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbnZhciBIT1NUX0FUVFIgPSBcIl9uZ2hvc3QtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XG52YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KG5hbWUsIG1vZHVsZVVybCwgc2V0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUgPSBzZXRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xufSgpKTtcbnZhciBDb21waWxlZFN0eWxlc2hlZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZWRTdHlsZXNoZWV0KG91dHB1dEN0eCwgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIGlzU2hpbW1lZCwgbWV0YSkge1xuICAgICAgICB0aGlzLm91dHB1dEN0eCA9IG91dHB1dEN0eDtcbiAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVkU3R5bGVzaGVldDtcbn0oKSk7XG52YXIgU3R5bGVDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF91cmxSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgIH1cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBjb21wLnRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVN0eWxlcyhvdXRwdXRDdHgsIGNvbXAsIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICBtb2R1bGVVcmw6IGlkZW50aWZpZXJNb2R1bGVVcmwoY29tcC50eXBlKVxuICAgICAgICB9KSwgdGhpcy5uZWVkc1N0eWxlU2hpbShjb21wKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlU3R5bGVzID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcCwgc3R5bGVzaGVldCwgc2hpbSkge1xuICAgICAgICBpZiAoc2hpbSA9PT0gdm9pZCAwKSB7IHNoaW0gPSB0aGlzLm5lZWRzU3R5bGVTaGltKGNvbXApOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU3R5bGVzKG91dHB1dEN0eCwgY29tcCwgc3R5bGVzaGVldCwgc2hpbSwgZmFsc2UpO1xuICAgIH07XG4gICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUubmVlZHNTdHlsZVNoaW0gPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gY29tcC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICB9O1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlU3R5bGVzID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgY29tcCwgc3R5bGVzaGVldCwgc2hpbSwgaXNDb21wb25lbnRTdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHlsZUV4cHJlc3Npb25zID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChwbGFpblN0eWxlKSB7IHJldHVybiBsaXRlcmFsKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KTtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICBzdHlsZXNoZWV0LnN0eWxlVXJscy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVVybCkge1xuICAgICAgICAgICAgdmFyIGV4cHJJbmRleCA9IHN0eWxlRXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgLy8gTm90ZTogVGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGZpbGxlZCBsYXRlci5cbiAgICAgICAgICAgIHN0eWxlRXhwcmVzc2lvbnMucHVzaChudWxsKTtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG5ldyBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShnZXRTdHlsZXNWYXJOYW1lKG51bGwpLCBzdHlsZVVybCwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzdHlsZUV4cHJlc3Npb25zW2V4cHJJbmRleF0gPSBvdXRwdXRDdHguaW1wb3J0RXhwcih2YWx1ZSk7IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHN0eWxlcyB2YXJpYWJsZSBjb250YWlucyBwbGFpbiBzdHJpbmdzIGFuZCBhcnJheXMgb2Ygb3RoZXIgc3R5bGVzIGFycmF5cyAocmVjdXJzaXZlKSxcbiAgICAgICAgLy8gc28gd2Ugc2V0IGl0cyB0eXBlIHRvIGR5bmFtaWMuXG4gICAgICAgIHZhciBzdHlsZXNWYXIgPSBnZXRTdHlsZXNWYXJOYW1lKGlzQ29tcG9uZW50U3R5bGVzaGVldCA/IGNvbXAgOiBudWxsKTtcbiAgICAgICAgdmFyIHN0bXQgPSB2YXJpYWJsZShzdHlsZXNWYXIpXG4gICAgICAgICAgICAuc2V0KGxpdGVyYWxBcnIoc3R5bGVFeHByZXNzaW9ucywgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBbU3RtdE1vZGlmaWVyLkZpbmFsXSA6IFtcbiAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXG4gICAgICAgIF0pO1xuICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHN0bXQpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVkU3R5bGVzaGVldChvdXRwdXRDdHgsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBzaGltLCBzdHlsZXNoZWV0KTtcbiAgICB9O1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUsIHNoaW0pIHtcbiAgICAgICAgcmV0dXJuIHNoaW0gPyB0aGlzLl9zaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUsIENPTlRFTlRfQVRUUiwgSE9TVF9BVFRSKSA6IHN0eWxlO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlQ29tcGlsZXI7XG59KCkpO1xuZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gXCJzdHlsZXNcIjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJlc3VsdCArPSBcIl9cIiArIGlkZW50aWZpZXJOYW1lKGNvbXBvbmVudC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIHBhdGggaXMgYW4gb3JkZXJlZCBzZXQgb2YgZWxlbWVudHMuIFR5cGljYWxseSBhIHBhdGggaXMgdG8gIGFcbiAqIHBhcnRpY3VsYXIgb2Zmc2V0IGluIGEgc291cmNlIGZpbGUuIFRoZSBoZWFkIG9mIHRoZSBsaXN0IGlzIHRoZSB0b3BcbiAqIG1vc3Qgbm9kZS4gVGhlIHRhaWwgaXMgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgb2Zmc2V0IGRpcmVjdGx5LlxuICpcbiAqIEZvciBleGFtcGxlLCB0aGUgZXhwcmVzc2lvbiBgYSArIGIgKyBjYCBtaWdodCBoYXZlIGFuIGFzdCB0aGF0IGxvb2tzXG4gKiBsaWtlOlxuICogICAgICtcbiAqICAgIC8gXFxcbiAqICAgYSAgICtcbiAqICAgICAgLyBcXFxuICogICAgIGIgICBjXG4gKlxuICogVGhlIHBhdGggdG8gdGhlIG5vZGUgYXQgb2Zmc2V0IDkgd291bGQgYmUgYFsnKycgYXQgMS0xMCwgJysnIGF0IDctMTAsXG4gKiAnYycgYXQgOS0xMF1gIGFuZCB0aGUgcGF0aCB0aGUgbm9kZSBhdCBvZmZzZXQgMSB3b3VsZCBiZVxuICogYFsnKycgYXQgMS0xMCwgJ2EnIGF0IDEtMl1gLlxuICovXG52YXIgQXN0UGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RQYXRoKHBhdGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gLTE7IH1cbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwiZW1wdHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5wYXRoIHx8ICF0aGlzLnBhdGgubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXN0UGF0aC5wcm90b3R5cGUsIFwiaGVhZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aFswXTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzdFBhdGgucHJvdG90eXBlLCBcInRhaWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBc3RQYXRoLnByb3RvdHlwZS5wYXJlbnRPZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlICYmIHRoaXMucGF0aFt0aGlzLnBhdGguaW5kZXhPZihub2RlKSAtIDFdO1xuICAgIH07XG4gICAgQXN0UGF0aC5wcm90b3R5cGUuY2hpbGRPZiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5wYXRoLmluZGV4T2Yobm9kZSkgKyAxXTtcbiAgICB9O1xuICAgIEFzdFBhdGgucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzdFBhdGgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLnBhdGgucHVzaChub2RlKTtcbiAgICB9O1xuICAgIEFzdFBhdGgucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3RQYXRoO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE5vZGVXaXRoSTE4biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlV2l0aEkxOG4oc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZVdpdGhJMThuO1xufSgpKTtcbnZhciBUZXh0JDMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRleHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzb3VyY2VTcGFuLCBpMThuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHQ7XG59KE5vZGVXaXRoSTE4bikpO1xudmFyIEV4cGFuc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwYW5zaW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzb3VyY2VTcGFuLCBpMThuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgX3RoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgX3RoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cGFuc2lvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHBhbnNpb247XG59KE5vZGVXaXRoSTE4bikpO1xudmFyIEV4cGFuc2lvbkNhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uQ2FzZSh2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNvdXJjZVNwYW4gPSB2YWx1ZVNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgfVxuICAgIEV4cGFuc2lvbkNhc2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb25DYXNlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cGFuc2lvbkNhc2U7XG59KCkpO1xudmFyIEF0dHJpYnV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXR0cmlidXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNvdXJjZVNwYW4sIGkxOG4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXR0cmlidXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cmlidXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJpYnV0ZTtcbn0oTm9kZVdpdGhJMThuKSk7XG52YXIgRWxlbWVudCQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgaWYgKHN0YXJ0U291cmNlU3BhbiA9PT0gdm9pZCAwKSB7IHN0YXJ0U291cmNlU3BhbiA9IG51bGw7IH1cbiAgICAgICAgaWYgKGVuZFNvdXJjZVNwYW4gPT09IHZvaWQgMCkgeyBlbmRTb3VyY2VTcGFuID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzb3VyY2VTcGFuLCBpMThuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgX3RoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICBfdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufShOb2RlV2l0aEkxOG4pKTtcbnZhciBDb21tZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbW1lbnQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBDb21tZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tZW50O1xufSgpKTtcbmZ1bmN0aW9uIHZpc2l0QWxsJDEodmlzaXRvciwgbm9kZXMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG52YXIgUmVjdXJzaXZlVmlzaXRvciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmF0dHJzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5jaGlsZHJlbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBSZWN1cnNpdmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5jYXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVjdXJzaXZlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFJlY3Vyc2l2ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoY29udGV4dCwgY2IpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiB2aXNpdChjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2aXNpdEFsbCQxKHQsIGNoaWxkcmVuLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2IodmlzaXQpO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVmlzaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBzcGFuT2YoYXN0KSB7XG4gICAgdmFyIHN0YXJ0ID0gYXN0LnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgIHZhciBlbmQgPSBhc3Quc291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBFbGVtZW50JDEpIHtcbiAgICAgICAgaWYgKGFzdC5lbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBlbmQgPSBhc3QuZW5kU291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5jaGlsZHJlbiAmJiBhc3QuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgPSBzcGFuT2YoYXN0LmNoaWxkcmVuW2FzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSkuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlKG5vZGVzLCBwb3NpdGlvbikge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBzcGFuID0gc3Bhbk9mKGFzdCk7XG4gICAgICAgICAgICBpZiAoc3Bhbi5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8IHNwYW4uZW5kKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5pbmcgYSB2YWx1ZSBoZXJlIHdpbGwgcmVzdWx0IGluIHRoZSBjaGlsZHJlbiBiZWluZyBza2lwcGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KFJlY3Vyc2l2ZVZpc2l0b3IkMSkpO1xuICAgIHZpc2l0QWxsJDEodmlzaXRvciwgbm9kZXMpO1xuICAgIHJldHVybiBuZXcgQXN0UGF0aChwYXRoLCBwb3NpdGlvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGU7XG4oZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfT1BFTl9TVEFSVFwiXSA9IDBdID0gXCJUQUdfT1BFTl9TVEFSVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfT1BFTl9FTkRcIl0gPSAxXSA9IFwiVEFHX09QRU5fRU5EXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19PUEVOX0VORF9WT0lEXCJdID0gMl0gPSBcIlRBR19PUEVOX0VORF9WT0lEXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19DTE9TRVwiXSA9IDNdID0gXCJUQUdfQ0xPU0VcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEVYVFwiXSA9IDRdID0gXCJURVhUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDVdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiUkFXX1RFWFRcIl0gPSA2XSA9IFwiUkFXX1RFWFRcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ09NTUVOVF9TVEFSVFwiXSA9IDddID0gXCJDT01NRU5UX1NUQVJUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfRU5EXCJdID0gOF0gPSBcIkNPTU1FTlRfRU5EXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNEQVRBX1NUQVJUXCJdID0gOV0gPSBcIkNEQVRBX1NUQVJUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNEQVRBX0VORFwiXSA9IDEwXSA9IFwiQ0RBVEFfRU5EXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkFUVFJfTkFNRVwiXSA9IDExXSA9IFwiQVRUUl9OQU1FXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkFUVFJfUVVPVEVcIl0gPSAxMl0gPSBcIkFUVFJfUVVPVEVcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQVRUUl9WQUxVRVwiXSA9IDEzXSA9IFwiQVRUUl9WQUxVRVwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJET0NfVFlQRVwiXSA9IDE0XSA9IFwiRE9DX1RZUEVcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fU1RBUlRcIl0gPSAxNV0gPSBcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCJdID0gMTZdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIl0gPSAxN10gPSBcIkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCJdID0gMThdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX0VORFwiXSA9IDE5XSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVPRlwiXSA9IDIwXSA9IFwiRU9GXCI7XG59KShUb2tlblR5cGUgfHwgKFRva2VuVHlwZSA9IHt9KSk7XG52YXIgVG9rZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW4odHlwZSwgcGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xudmFyIFRva2VuRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRva2VuRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9rZW5FcnJvcihlcnJvck1zZywgdG9rZW5UeXBlLCBzcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIGVycm9yTXNnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRva2VuRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUb2tlbml6ZVJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZVJlc3VsdCh0b2tlbnMsIGVycm9ycykge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBUb2tlbml6ZVJlc3VsdDtcbn0oKSk7XG5mdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIHVybCwgZ2V0VGFnRGVmaW5pdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIG5ldyBfVG9rZW5pemVyKG5ldyBQYXJzZVNvdXJjZUZpbGUoc291cmNlLCB1cmwpLCBnZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKS50b2tlbml6ZSgpO1xufVxudmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG5mdW5jdGlvbiBfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGNoYXJDb2RlKSB7XG4gICAgdmFyIGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgXFxcIlwiICsgY2hhciArIFwiXFxcIlwiO1xufVxuZnVuY3Rpb24gX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHlTcmMpIHtcbiAgICByZXR1cm4gXCJVbmtub3duIGVudGl0eSBcXFwiXCIgKyBlbnRpdHlTcmMgKyBcIlxcXCIgLSB1c2UgdGhlIFxcXCImIzxkZWNpbWFsPjtcXFwiIG9yICBcXFwiJiN4PGhleD47XFxcIiBzeW50YXhcIjtcbn1cbnZhciBfQ29udHJvbEZsb3dFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbn0oKSk7XG4vLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI3dyaXRpbmdcbnZhciBfVG9rZW5pemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfZmlsZSBUaGUgaHRtbCBzb3VyY2UgZmlsZSBiZWluZyB0b2tlbml6ZWQuXG4gICAgICogQHBhcmFtIF9nZXRUYWdEZWZpbml0aW9uIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHJpZXZlIGEgdGFnIGRlZmluaXRpb24gZm9yIGEgZ2l2ZW4gdGFnIG5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvZiB0aGUgdG9rZW5pemF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9Ub2tlbml6ZXIoX2ZpbGUsIF9nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2dldFRhZ0RlZmluaXRpb24gPSBfZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IG9wdGlvbnMudG9rZW5pemVFeHBhbnNpb25Gb3JtcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbkNvbmZpZyB8fCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB0aGlzLl9sZWFkaW5nVHJpdmlhQ29kZVBvaW50cyA9XG4gICAgICAgICAgICBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycyAmJiBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY29kZVBvaW50QXQoMCkgfHwgMDsgfSk7XG4gICAgICAgIHZhciByYW5nZSA9IG9wdGlvbnMucmFuZ2UgfHwgeyBlbmRQb3M6IF9maWxlLmNvbnRlbnQubGVuZ3RoLCBzdGFydFBvczogMCwgc3RhcnRMaW5lOiAwLCBzdGFydENvbDogMCB9O1xuICAgICAgICB0aGlzLl9jdXJzb3IgPSBvcHRpb25zLmVzY2FwZWRTdHJpbmcgPyBuZXcgRXNjYXBlZENoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpIDpcbiAgICAgICAgICAgIG5ldyBQbGFpbkNoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcmVzZXJ2ZUxpbmVFbmRpbmdzID0gb3B0aW9ucy5wcmVzZXJ2ZUxpbmVFbmRpbmdzIHx8IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcmVzZXJ2ZUxpbmVFbmRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl90b2tlbml6ZUljdSAmJiB0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRU9GKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgYW4gSUNVIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0V4cGFuc2lvbkZvcm1TdGFydCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFeHBhbnNpb25DYXNlU3RhcnQodGhpcy5fY3Vyc29yLnBlZWsoKSkgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpOyB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSB0eXBlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9rZW5FcnJvcignUHJvZ3JhbW1pbmcgZXJyb3IgLSBhdHRlbXB0ZWQgdG8gZW5kIGEgdG9rZW4gd2hlbiB0aGVyZSB3YXMgbm8gc3RhcnQgdG8gdGhlIHRva2VuJywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb2tlbkVycm9yKCdQcm9ncmFtbWluZyBlcnJvciAtIGF0dGVtcHRlZCB0byBlbmQgYSB0b2tlbiB3aGljaCBoYXMgbm8gdG9rZW4gdHlwZScsIG51bGwsIHRoaXMuX2N1cnNvci5nZXRTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCB0aGlzLl9jdXJzb3IuZ2V0U3Bhbih0aGlzLl9jdXJyZW50VG9rZW5TdGFydCwgdGhpcy5fbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMpKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChtc2csIHNwYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIiAoRG8geW91IGhhdmUgYW4gdW5lc2NhcGVkIFxcXCJ7XFxcIiBpbiB5b3VyIHRlbXBsYXRlPyBVc2UgXFxcInt7ICd7JyB9fVxcXCIpIHRvIGVzY2FwZSBpdC4pXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gbmV3IFRva2VuRXJyb3IobXNnLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBzcGFuKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29udHJvbEZsb3dFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ3Vyc29yRXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSB0aGlzLl9jcmVhdGVFcnJvcihlLm1zZywgdGhpcy5fY3Vyc29yLmdldFNwYW4oZS5jdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUodGhpcy5fY3Vyc29yLnBlZWsoKSwgY2hhckNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX2N1cnNvci5wZWVrKCkpLCB0aGlzLl9jdXJzb3IuZ2V0U3Bhbihsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICB2YXIgbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLmNoYXJzTGVmdCgpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gcGFyc2UgdGhlIHN0cmluZyBmYWlscywgd2Ugd2FudCB0byByZXNldCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgYXR0ZW1wdFxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IGluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlU3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRTdHIoY2hhcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX2N1cnNvci5wZWVrKCkpLCB0aGlzLl9jdXJzb3IuZ2V0U3Bhbihsb2NhdGlvbikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5fY3Vyc29yLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbGVuKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKHByZWRpY2F0ZSk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IuZGlmZihzdGFydCkgPCBsZW4pIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0VW50aWxDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkQ2hhciA9IGZ1bmN0aW9uIChkZWNvZGVFbnRpdGllcykge1xuICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUVudGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmVseSB1cG9uIHJlYWRpbmcgZGlyZWN0bHkgZnJvbSBgX2lucHV0YCBhcyB0aGUgYWN0dWFsIGNoYXIgdmFsdWVcbiAgICAgICAgICAgIC8vIG1heSBoYXZlIGJlZW4gZ2VuZXJhdGVkIGZyb20gYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgdmFyIGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLl9jdXJzb3IucGVlaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICB2YXIgaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICB2YXIgY29kZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0ck51bSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhjb2RlU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2codGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWVTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuYW1lU3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMobmFtZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgY2hhciA9IE5BTUVEX0VOVElUSUVTW25hbWVfMV07XG4gICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWVfMSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0ID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzLCBlbmRNYXJrZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihkZWNvZGVFbnRpdGllcyA/IFRva2VuVHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQgOiBUb2tlblR5cGUuUkFXX1RFWFQpO1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgZm91bmRFbmRNYXJrZXIgPSBlbmRNYXJrZXJQcmVkaWNhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRhZ0Nsb3NlU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRFbmRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0tPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ09NTUVOVF9FTkQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCctLT4nKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5DREFUQV9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJ11dPicpOyB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQ0RBVEFfRU5EKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignXV0+Jyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRG9jVHlwZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5ET0NfVFlQRSwgc3RhcnQpO1xuICAgICAgICB2YXIgY29udGVudFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29udGVudFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbnRlbnRdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUHJlZml4QW5kTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVPclByZWZpeFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHZhciBwcmVmaXggPSAnJztcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRDT0xPTiAmJiAhaXNQcmVmaXhFbmQodGhpcy5fY3Vyc29yLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRDT0xPTikge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVPclByZWZpeFN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCBwcmVmaXggPT09ICcnID8gMCA6IDEpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgIHZhciBwcmVmaXg7XG4gICAgICAgIHZhciBvcGVuVGFnVG9rZW47XG4gICAgICAgIHZhciB0b2tlbnNCZWZvcmVUYWdPcGVuID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5uZXJTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW5UYWdUb2tlbiA9IHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgcHJlZml4ID0gb3BlblRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgdGFnTmFtZSA9IG9wZW5UYWdUb2tlbi5wYXJ0c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkU0xBU0ggJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJEdUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBzdGFydCB0YWcgaXMgaW52YWxpZCAoaW5jbHVkaW5nIGludmFsaWQgXCJhdHRyaWJ1dGVzXCIpLCBhc3N1bWUgd2Ugd2FudCBhIFwiPFwiXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gaW5uZXJTdGFydDtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IHRva2Vuc0JlZm9yZVRhZ09wZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5URVhULCBzdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oWyc8J10pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmNvbnRlbnRUeXBlO1xuICAgICAgICBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKHByZWZpeCwgdGFnTmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKHByZWZpeCwgdGFnTmFtZSwgZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGRlY29kZUVudGl0aWVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSh0YWdOYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLlRBR19DTE9TRSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIGNvZGUgPT09ICRHVDsgfSwgMyk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7IC8vIENvbnN1bWUgdGhlIGA+YFxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbcHJlZml4LCB0YWdOYW1lXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5UQUdfT1BFTl9TVEFSVCwgc3RhcnQpO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXR0ck5hbWVTdGFydCA9IHRoaXMuX2N1cnNvci5wZWVrKCk7XG4gICAgICAgIGlmIChhdHRyTmFtZVN0YXJ0ID09PSAkU1EgfHwgYXR0ck5hbWVTdGFydCA9PT0gJERRKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGF0dHJOYW1lU3RhcnQpLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5BVFRSX05BTUUpO1xuICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFNRIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICREUSkge1xuICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQVRUUl9RVU9URSk7XG4gICAgICAgICAgICB2YXIgcXVvdGVDaGFyID0gdGhpcy5fY3Vyc29yLnBlZWsoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbU3RyaW5nLmZyb21Db2RlUG9pbnQocXVvdGVDaGFyKV0pO1xuICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuQVRUUl9WQUxVRSk7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gcGFydHMuam9pbignJyk7XG4gICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLkFUVFJfUVVPVEUpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtTdHJpbmcuZnJvbUNvZGVQb2ludChxdW90ZUNoYXIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5BVFRSX1ZBTFVFKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyh2YWx1ZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IFRva2VuVHlwZS5UQUdfT1BFTl9FTkRfVk9JRCA6IFRva2VuVHlwZS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnQ2xvc2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuVEFHX0NMT1NFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5SQVdfVEVYVCk7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5SQVdfVEVYVCk7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWFkVW50aWwoJExCUkFDRSkudHJpbSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2luSW50ZXJwb2xhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoIXRoaXMuX2lzVGV4dEVuZCgpKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNUZXh0RW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJExUIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRFT0YpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0V4cGFuc2lvbkZvcm1TdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYW4gZXhwYW5zaW9uIGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkUkJSQUNFICYmIHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgYW5kIGV4cGFuc2lvbiBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKGNoYXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KTtcbiAgICB9O1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQ7XG4gICAgfTtcbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5pc0V4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uID0gdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuICFpc0ludGVycG9sYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gX1Rva2VuaXplcjtcbn0oKSk7XG5mdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAhaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRFT0Y7XG59XG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRTTEFTSCB8fFxuICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbn1cbmZ1bmN0aW9uIGlzUHJlZml4RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0RW50aXR5RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUhleERpZ2l0KGNvZGUpO1xufVxuZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgIT09ICRSQlJBQ0U7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xufVxuZnVuY3Rpb24gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbn1cbmZ1bmN0aW9uIG1lcmdlVGV4dFRva2VucyhzcmNUb2tlbnMpIHtcbiAgICB2YXIgZHN0VG9rZW5zID0gW107XG4gICAgdmFyIGxhc3REc3RUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlLlRFWFQgJiYgdG9rZW4udHlwZSA9PSBUb2tlblR5cGUuVEVYVCkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbnZhciBQbGFpbkNoYXJhY3RlckN1cnNvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGFpbkNoYXJhY3RlckN1cnNvcihmaWxlT3JDdXJzb3IsIHJhbmdlKSB7XG4gICAgICAgIGlmIChmaWxlT3JDdXJzb3IgaW5zdGFuY2VvZiBQbGFpbkNoYXJhY3RlckN1cnNvcikge1xuICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZU9yQ3Vyc29yLmZpbGU7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZmlsZU9yQ3Vyc29yLmlucHV0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaWxlT3JDdXJzb3IuZW5kO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZmlsZU9yQ3Vyc29yLnN0YXRlO1xuICAgICAgICAgICAgLy8gTm90ZTogYXZvaWQgdXNpbmcgYHsuLi5maWxlT3JDdXJzb3Iuc3RhdGV9YCBoZXJlIGFzIHRoYXQgaGFzIGEgc2V2ZXJlIHBlcmZvcm1hbmNlIHBlbmFsdHkuXG4gICAgICAgICAgICAvLyBJbiBFUzUgYnVuZGxlcyB0aGUgb2JqZWN0IHNwcmVhZCBvcGVyYXRvciBpcyB0cmFuc2xhdGVkIGludG8gdGhlIGBfX2Fzc2lnbmAgaGVscGVyLCB3aGljaFxuICAgICAgICAgICAgLy8gaXMgbm90IG9wdGltaXplZCBieSBWTXMgYXMgZWZmaWNpZW50bHkgYXMgYSByYXcgb2JqZWN0IGxpdGVyYWwuIFNpbmNlIHRoaXMgY29uc3RydWN0b3IgaXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCBpbiB0aWdodCBsb29wcywgdGhpcyBkaWZmZXJlbmNlIG1hdHRlcnMuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHBlZWs6IHN0YXRlLnBlZWssXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGF0ZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbGluZTogc3RhdGUubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXRlLmNvbHVtbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZyBlcnJvcjogdGhlIHJhbmdlIGFyZ3VtZW50IG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIGZpbGUgYXJndW1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlT3JDdXJzb3I7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZmlsZU9yQ3Vyc29yLmNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHJhbmdlLmVuZFBvcztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcGVlazogLTEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiByYW5nZS5zdGFydFBvcyxcbiAgICAgICAgICAgICAgICBsaW5lOiByYW5nZS5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiByYW5nZS5zdGFydENvbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGxhaW5DaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluQ2hhcmFjdGVyQ3Vyc29yKHRoaXMpO1xuICAgIH07XG4gICAgUGxhaW5DaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlZWs7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuY2hhcnNMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXRlLm9mZnNldDtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5kaWZmID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm9mZnNldCAtIG90aGVyLnN0YXRlLm9mZnNldDtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBlZWsodGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMpIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCB0aGlzO1xuICAgICAgICB2YXIgY2xvbmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChsZWFkaW5nVHJpdmlhQ29kZVBvaW50cykge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuZGlmZihzdGFydCkgPiAwICYmIGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzLmluZGV4T2Yoc3RhcnQucGVlaygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsb25lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzdGFydC5maWxlLCBzdGFydC5zdGF0ZS5vZmZzZXQsIHN0YXJ0LnN0YXRlLmxpbmUsIHN0YXJ0LnN0YXRlLmNvbHVtbiksIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgdGhpcy5zdGF0ZS5vZmZzZXQsIHRoaXMuc3RhdGUubGluZSwgdGhpcy5zdGF0ZS5jb2x1bW4pKTtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5nZXRDaGFycyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQuc3RhdGUub2Zmc2V0LCB0aGlzLnN0YXRlLm9mZnNldCk7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuY2hhckF0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfTtcbiAgICBQbGFpbkNoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuYWR2YW5jZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPj0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBDdXJzb3JFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCJFT0ZcIicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50Q2hhciA9IHRoaXMuY2hhckF0KHN0YXRlLm9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJExGKSB7XG4gICAgICAgICAgICBzdGF0ZS5saW5lKys7XG4gICAgICAgICAgICBzdGF0ZS5jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc05ld0xpbmUoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQrKztcbiAgICAgICAgdGhpcy51cGRhdGVQZWVrKHN0YXRlKTtcbiAgICB9O1xuICAgIFBsYWluQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS51cGRhdGVQZWVrID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnBlZWsgPSBzdGF0ZS5vZmZzZXQgPj0gdGhpcy5lbmQgPyAkRU9GIDogdGhpcy5jaGFyQXQoc3RhdGUub2Zmc2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBQbGFpbkNoYXJhY3RlckN1cnNvcjtcbn0oKSk7XG52YXIgRXNjYXBlZENoYXJhY3RlckN1cnNvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXNjYXBlZENoYXJhY3RlckN1cnNvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yKGZpbGVPckN1cnNvciwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZpbGVPckN1cnNvciBpbnN0YW5jZW9mIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZmlsZU9yQ3Vyc29yKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxTdGF0ZSA9IF9fYXNzaWduKHt9LCBmaWxlT3JDdXJzb3IuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZpbGVPckN1cnNvciwgcmFuZ2UpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5pbnRlcm5hbFN0YXRlID0gX3RoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmFkdmFuY2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRXNjYXBlU2VxdWVuY2UoKTtcbiAgICB9O1xuICAgIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFc2NhcGVTZXF1ZW5jZSgpO1xuICAgIH07XG4gICAgRXNjYXBlZENoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXNjYXBlZENoYXJhY3RlckN1cnNvcih0aGlzKTtcbiAgICB9O1xuICAgIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IucHJvdG90eXBlLmdldENoYXJzID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICB2YXIgY2hhcnMgPSAnJztcbiAgICAgICAgd2hpbGUgKGN1cnNvci5pbnRlcm5hbFN0YXRlLm9mZnNldCA8IHRoaXMuaW50ZXJuYWxTdGF0ZS5vZmZzZXQpIHtcbiAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGN1cnNvci5wZWVrKCkpO1xuICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBlc2NhcGUgc2VxdWVuY2UgdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHRleHQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gZW5zdXJlIHRoYXQgYHBlZWtgIGhhcyB0aGUgdW5lc2NhcGVkIHZhbHVlIG9mIGVzY2FwZSBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgRXNjYXBlZENoYXJhY3RlckN1cnNvci5wcm90b3R5cGUucHJvY2Vzc0VzY2FwZVNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGVlayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmludGVybmFsU3RhdGUucGVlazsgfTtcbiAgICAgICAgaWYgKHBlZWsoKSA9PT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBoaXQgYW4gZXNjYXBlIHNlcXVlbmNlIHNvIHdlIG5lZWQgdGhlIGludGVybmFsIHN0YXRlIHRvIGJlY29tZSBpbmRlcGVuZGVudFxuICAgICAgICAgICAgLy8gb2YgdGhlIGV4dGVybmFsIHN0YXRlLlxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gX19hc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gTW92ZSBwYXN0IHRoZSBiYWNrc2xhc2hcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBmb3Igc3RhbmRhcmQgY29udHJvbCBjaGFyIHNlcXVlbmNlc1xuICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gJG4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkTEY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICRyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJENSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRWVEFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRUQUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICRiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJEJTUEFDRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkRkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgY29uc2lkZXIgbW9yZSBjb21wbGV4IHNlcXVlbmNlc1xuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdSkge1xuICAgICAgICAgICAgICAgIC8vIFVuaWNvZGUgY29kZS1wb2ludCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2UgcGFzdCB0aGUgYHVgIGNoYXJcbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAkTEJSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlIGxlbmd0aCBVbmljb2RlLCBlLmcuIGBcXHh7MTIzfWBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBwYXN0IHRoZSBge2AgY2hhclxuICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIHZhcmlhYmxlIG51bWJlciBvZiBoZXggZGlnaXRzIHVudGlsIHdlIGhpdCBhIGB9YCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWdpdFN0YXJ0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGVlaygpICE9PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoXzErKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmRlY29kZUhleERpZ2l0cyhkaWdpdFN0YXJ0LCBsZW5ndGhfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCBsZW5ndGggVW5pY29kZSwgZS5nLiBgXFx1MTIzNGBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHgpIHtcbiAgICAgICAgICAgICAgICAvLyBIZXggY2hhciBjb2RlLCBlLmcuIGBcXHgyRmBcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGB4YCBjaGFyXG4gICAgICAgICAgICAgICAgdmFyIGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmRlY29kZUhleERpZ2l0cyhkaWdpdFN0YXJ0LCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2N0YWxEaWdpdChwZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2N0YWwgY2hhciBjb2RlLCBlLmcuIGBcXDAxMmAsXG4gICAgICAgICAgICAgICAgdmFyIG9jdGFsID0gJyc7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8yID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzT2N0YWxEaWdpdChwZWVrKCkpICYmIGxlbmd0aF8yIDwgMykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgb2N0YWwgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocGVlaygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoXzIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gcGFyc2VJbnQob2N0YWwsIDgpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2t1cCBvbmUgY2hhclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHByZXZpb3VzLmludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc05ld0xpbmUodGhpcy5pbnRlcm5hbFN0YXRlLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZSBjb250aW51YXRpb24gYFxcYCBmb2xsb3dlZCBieSBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBvdmVyIHRoZSBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGBpZmAgYmxvY2tzIHdlcmUgZXhlY3V0ZWQgdGhlbiB3ZSBqdXN0IGhhdmUgYW4gZXNjYXBlZCBub3JtYWwgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSBqdXN0LCBlZmZlY3RpdmVseSwgc2tpcCB0aGUgYmFja3NsYXNoIGZyb20gdGhlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmludGVybmFsU3RhdGUucGVlaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXNjYXBlZENoYXJhY3RlckN1cnNvci5wcm90b3R5cGUuZGVjb2RlSGV4RGlnaXRzID0gZnVuY3Rpb24gKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGhleCA9IHRoaXMuaW5wdXQuc3Vic3RyKHN0YXJ0LmludGVybmFsU3RhdGUub2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB2YXIgY2hhckNvZGUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgaWYgKCFpc05hTihjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnN0YXRlID0gc3RhcnQuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBDdXJzb3JFcnJvcignSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yO1xufShQbGFpbkNoYXJhY3RlckN1cnNvcikpO1xudmFyIEN1cnNvckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEN1cnNvckVycm9yKG1zZywgY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG4gICAgcmV0dXJuIEN1cnNvckVycm9yO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRyZWVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJlZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUcmVlRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJlZUVycm9yO1xufShQYXJzZUVycm9yKSk7XG52YXIgUGFyc2VUcmVlUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlVHJlZVJlc3VsdChyb290Tm9kZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHJvb3ROb2RlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZVRyZWVSZXN1bHQ7XG59KCkpO1xudmFyIFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgIH1cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB0b2tlbnNBbmRFcnJvcnMgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRyZWVBbmRFcnJvcnMgPSBuZXcgX1RyZWVCdWlsZGVyKHRva2Vuc0FuZEVycm9ycy50b2tlbnMsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJlZUFuZEVycm9ycy5yb290Tm9kZXMsIHRva2Vuc0FuZEVycm9ycy5lcnJvcnMuY29uY2F0KHRyZWVBbmRFcnJvcnMuZXJyb3JzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbnZhciBfVHJlZUJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1RyZWVCdWlsZGVyKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgIH1cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUuRU9GKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuVEFHX09QRU5fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lU3RhcnRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLlRBR19DTE9TRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkNEQVRBX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuVEVYVCB8fCB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5SQVdfVEVYVCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBvdGhlciB0b2tlbnMuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodGhpcy5fcm9vdE5vZGVzLCB0aGlzLl9lcnJvcnMpO1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbHdheXMgYW4gRU9GIHRva2VuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMudG9rZW5zW3RoaXMuX2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlSWYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZS5DREFUQV9FTkQpO1xuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlLlJBV19URVhUKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZS5DT01NRU5UX0VORCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRleHQgIT0gbnVsbCA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb24gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdmFyIGNhc2VzID0gW107XG4gICAgICAgIC8vIHJlYWQgPVxuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICBpZiAoIWV4cENhc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHRva2VuLnNvdXJjZVNwYW4uc3RhcnQsIHRoaXMuX3BlZWsuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wYXJzZUV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgLy8gcmVhZCB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHVudGlsIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB2YXIgZXhwID0gdGhpcy5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCk7XG4gICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIGV4cC5wdXNoKG5ldyBUb2tlbihUb2tlblR5cGUuRU9GLCBbXSwgZW5kLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgdmFyIHBhcnNlZEV4cCA9IG5ldyBfVHJlZUJ1aWxkZXIoZXhwLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgIGlmIChwYXJzZWRFeHAuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX2Vycm9ycy5jb25jYXQocGFyc2VkRXhwLmVycm9ycyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odmFsdWUuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdmFyIGV4cFNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZSh2YWx1ZS5wYXJ0c1swXSwgcGFyc2VkRXhwLnJvb3ROb2Rlcywgc291cmNlU3BhbiwgdmFsdWUuc291cmNlU3BhbiwgZXhwU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBleHAgPSBbXTtcbiAgICAgICAgdmFyIGV4cGFuc2lvbkZvcm1TdGFjayA9IFtUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wdXNoKHRoaXMuX3BlZWsudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvbkZvcm1TdGFjay5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5FT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cC5wdXNoKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgdGV4dFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudF8xICE9IG51bGwgJiYgcGFyZW50XzEuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50XzEubmFtZSkuaWdub3JlRmlyc3RMZikge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCQzKHRleHQsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY2xvc2VWb2lkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwgJiYgdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lU3RhcnRUYWcgPSBmdW5jdGlvbiAoc3RhcnRUYWdUb2tlbikge1xuICAgICAgICB2YXIgcHJlZml4ID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgdmFyIG5hbWUgPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdO1xuICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkFUVFJfTkFNRSkge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IGEgdG9rZW4gZm9yIHRoZSBlbmQgdGFnLi4uXG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5UQUdfT1BFTl9FTkRfVk9JRCkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSk7XG4gICAgICAgICAgICBpZiAoISh0YWdEZWYuY2FuU2VsZkNsb3NlIHx8IGdldE5zUHJlZml4KGZ1bGxOYW1lKSAhPT0gbnVsbCB8fCB0YWdEZWYuaXNWb2lkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgXCJPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFxcXCJcIiArIHN0YXJ0VGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLlRBR19PUEVOX0VORCkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCQxKGZ1bGxOYW1lLCBhdHRycywgW10sIHNwYW4sIHNwYW4sIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX3B1c2hFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGVsLmVuZFNvdXJjZVNwYW4gPSBzcGFuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wdXNoRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnRFbCAmJiB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50RWwubmFtZSkuaXNDbG9zZWRCeUNoaWxkKGVsLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQoZWwpO1xuICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChlbCk7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRW5kVGFnID0gZnVuY3Rpb24gKGVuZFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShlbmRUYWdUb2tlbi5wYXJ0c1swXSwgZW5kVGFnVG9rZW4ucGFydHNbMV0sIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgZXJyTXNnID0gXCJVbmV4cGVjdGVkIGNsb3NpbmcgdGFnIFxcXCJcIiArIGZ1bGxOYW1lICsgXCJcXFwiLiBJdCBtYXkgaGFwcGVuIHdoZW4gdGhlIHRhZyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBieSBhbm90aGVyIHRhZy4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2Nsb3NpbmctZWxlbWVudHMtdGhhdC1oYXZlLWltcGxpZWQtZW5kLXRhZ3NcIjtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIGVyck1zZykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wb3BFbGVtZW50ID0gZnVuY3Rpb24gKGZ1bGxOYW1lKSB7XG4gICAgICAgIGZvciAodmFyIHN0YWNrSW5kZXggPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJbmRleCA+PSAwOyBzdGFja0luZGV4LS0pIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnNwbGljZShzdGFja0luZGV4LCB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gc3RhY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgZnVsbE5hbWUgPSBtZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICB2YXIgZW5kID0gYXR0ck5hbWUuc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICB2YXIgdmFsdWVTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUuQVRUUl9RVU9URSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZS5BVFRSX1ZBTFVFKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVUb2tlbiA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIGVuZCA9IHZhbHVlVG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgICAgICB2YWx1ZVNwYW4gPSB2YWx1ZVRva2VuLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlLkFUVFJfUVVPVEUpIHtcbiAgICAgICAgICAgIHZhciBxdW90ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgZW5kID0gcXVvdGVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZShmdWxsTmFtZSwgdmFsdWUsIG5ldyBQYXJzZVNvdXJjZVNwYW4oYXR0ck5hbWUuc291cmNlU3Bhbi5zdGFydCwgZW5kKSwgdmFsdWVTcGFuKTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCA/IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgPG5nLWNvbnRhaW5lcj5gIGVsZW1lbnRzIGFyZSBza2lwcGVkIGFzIHRoZXkgYXJlIG5vdCByZW5kZXJlZCBhcyBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCFpc05nQ29udGFpbmVyKHRoaXMuX2VsZW1lbnRTdGFja1tpXS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW2ldLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFN0YWNrW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhcmVudDogbnVsbCwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICB9O1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkZFRvUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBub2RlIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgdGhlIGNvbnRhaW5lci5cbiAgICAgKiBXaGVuIG5vIGNvbnRhaW5lciBpcyBnaXZlbiwgdGhlIG5vZGUgaXMgYXBwZW5kZWQgYXMgYSBjaGlsZCBvZiB0aGUgcGFyZW50LlxuICAgICAqIEFsc28gdXBkYXRlcyB0aGUgZWxlbWVudCBzdGFjayBhY2NvcmRpbmdseS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBjb250YWluZXIgd2l0aCB0aGUgbmV3IG5vZGUgaW4gdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuX2VsZW1lbnRTdGFjay5pbmRleE9mKGNvbnRhaW5lciksIDAsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRFbGVtZW50RnVsbE5hbWUgPSBmdW5jdGlvbiAocHJlZml4LCBsb2NhbE5hbWUsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJycpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4IHx8ICcnO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJycgJiYgcGFyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIF9UcmVlQnVpbGRlcjtcbn0oKSk7XG5mdW5jdGlvbiBsYXN0T25TdGFjayhzdGFjaywgZWxlbWVudCkge1xuICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSHRtbFBhcnNlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ2V0SHRtbFRhZ0RlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWxQYXJzZXI7XG59KFBhcnNlcikpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJFU0VSVkVfV1NfQVRUUl9OQU1FID0gJ25nUHJlc2VydmVXaGl0ZXNwYWNlcyc7XG52YXIgU0tJUF9XU19UUklNX1RBR1MgPSBuZXcgU2V0KFsncHJlJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3NjcmlwdCcsICdzdHlsZSddKTtcbi8vIEVxdWl2YWxlbnQgdG8gXFxzIHdpdGggXFx1MDBhMCAobm9uLWJyZWFraW5nIHNwYWNlKSBleGNsdWRlZC5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cFxudmFyIFdTX0NIQVJTID0gJyBcXGZcXG5cXHJcXHRcXHZcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZic7XG52YXIgTk9fV1NfUkVHRVhQID0gbmV3IFJlZ0V4cChcIlteXCIgKyBXU19DSEFSUyArIFwiXVwiKTtcbnZhciBXU19SRVBMQUNFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBXU19DSEFSUyArIFwiXXsyLH1cIiwgJ2cnKTtcbmZ1bmN0aW9uIGhhc1ByZXNlcnZlV2hpdGVzcGFjZXNBdHRyKGF0dHJzKSB7XG4gICAgcmV0dXJuIGF0dHJzLnNvbWUoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gUFJFU0VSVkVfV1NfQVRUUl9OQU1FOyB9KTtcbn1cbi8qKlxuICogQW5ndWxhciBEYXJ0IGludHJvZHVjZWQgJm5nc3A7IGFzIGEgcGxhY2Vob2xkZXIgZm9yIG5vbi1yZW1vdmFibGUgc3BhY2UsIHNlZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJ0LWxhbmcvYW5ndWxhci9ibG9iLzBiYjYxMTM4N2QyOWQ2NWI1YWY3ZjlkMjUxNWFiNTcxZmQzZmJlZTQvX3Rlc3RzL3Rlc3QvY29tcGlsZXIvcHJlc2VydmVfd2hpdGVzcGFjZV90ZXN0LmRhcnQjTDI1LUwzMlxuICogSW4gQW5ndWxhciBEYXJ0ICZuZ3NwOyBpcyBjb252ZXJ0ZWQgdG8gdGhlIDB4RTUwMCBQVUEgKFByaXZhdGUgVXNlIEFyZWFzKSB1bmljb2RlIGNoYXJhY3RlclxuICogYW5kIGxhdGVyIG9uIHJlcGxhY2VkIGJ5IGEgc3BhY2UuIFdlIGFyZSByZS1pbXBsZW1lbnRpbmcgdGhlIHNhbWUgaWRlYSBoZXJlLlxuICovXG5mdW5jdGlvbiByZXBsYWNlTmdzcCh2YWx1ZSkge1xuICAgIC8vIGxleGVyIGlzIHJlcGxhY2luZyB0aGUgJm5nc3A7IHBzZXVkby1lbnRpdHkgd2l0aCBOR1NQX1VOSUNPREVcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKE5HU1BfVU5JQ09ERSwgJ2cnKSwgJyAnKTtcbn1cbi8qKlxuICogVGhpcyB2aXNpdG9yIGNhbiB3YWxrIEhUTUwgcGFyc2UgdHJlZSBhbmQgcmVtb3ZlIC8gdHJpbSB0ZXh0IG5vZGVzIHVzaW5nIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4gKiAtIGNvbnNpZGVyIHNwYWNlcywgdGFicyBhbmQgbmV3IGxpbmVzIGFzIHdoaXRlc3BhY2UgY2hhcmFjdGVycztcbiAqIC0gZHJvcCB0ZXh0IG5vZGVzIGNvbnNpc3Rpbmcgb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIG9ubHk7XG4gKiAtIGZvciBhbGwgb3RoZXIgdGV4dCBub2RlcyByZXBsYWNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB3aXRoIG9uZSBzcGFjZTtcbiAqIC0gY29udmVydCAmbmdzcDsgcHNldWRvLWVudGl0eSB0byBhIHNpbmdsZSBzcGFjZTtcbiAqXG4gKiBSZW1vdmFsIGFuZCB0cmltbWluZyBvZiB3aGl0ZXNwYWNlcyBoYXZlIHBvc2l0aXZlIHBlcmZvcm1hbmNlIGltcGFjdCAobGVzcyBjb2RlIHRvIGdlbmVyYXRlXG4gKiB3aGlsZSBjb21waWxpbmcgdGVtcGxhdGVzLCBmYXN0ZXIgdmlldyBjcmVhdGlvbikuIEF0IHRoZSBzYW1lIHRpbWUgaXQgY2FuIGJlIFwiZGVzdHJ1Y3RpdmVcIlxuICogaW4gc29tZSBjYXNlcyAod2hpdGVzcGFjZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQpLiBCZWNhdXNlIG9mIHRoZSBwb3RlbnRpYWwgb2YgYnJlYWtpbmcgbGF5b3V0XG4gKiB0aGlzIHZpc2l0b3IgaXMgbm90IGFjdGl2YXRlZCBieSBkZWZhdWx0IGluIEFuZ3VsYXIgNSBhbmQgcGVvcGxlIG5lZWQgdG8gZXhwbGljaXRseSBvcHQtaW4gZm9yXG4gKiB3aGl0ZXNwYWNlIHJlbW92YWwuIFRoZSBkZWZhdWx0IG9wdGlvbiBmb3Igd2hpdGVzcGFjZSByZW1vdmFsIHdpbGwgYmUgcmV2aXNpdGVkIGluIEFuZ3VsYXIgNlxuICogYW5kIG1pZ2h0IGJlIGNoYW5nZWQgdG8gXCJvblwiIGJ5IGRlZmF1bHQuXG4gKi9cbnZhciBXaGl0ZXNwYWNlVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaGl0ZXNwYWNlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChTS0lQX1dTX1RSSU1fVEFHUy5oYXMoZWxlbWVudC5uYW1lKSB8fCBoYXNQcmVzZXJ2ZVdoaXRlc3BhY2VzQXR0cihlbGVtZW50LmF0dHJzKSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZGVzY2VudCBpbnRvIGVsZW1lbnRzIHdoZXJlIHdlIG5lZWQgdG8gcHJlc2VydmUgd2hpdGVzcGFjZXNcbiAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCB2aXNpdCBhbGwgYXR0cmlidXRlcyB0byBlbGltaW5hdGUgb25lIHVzZWQgYXMgYSBtYXJrZXQgdG8gcHJlc2VydmUgV1NcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKGVsZW1lbnQubmFtZSwgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LmF0dHJzKSwgZWxlbWVudC5jaGlsZHJlbiwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKGVsZW1lbnQubmFtZSwgZWxlbWVudC5hdHRycywgdmlzaXRBbGxXaXRoU2libGluZ3ModGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICB9O1xuICAgIFdoaXRlc3BhY2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lICE9PSBQUkVTRVJWRV9XU19BVFRSX05BTUUgPyBhdHRyaWJ1dGUgOiBudWxsO1xuICAgIH07XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpc05vdEJsYW5rID0gdGV4dC52YWx1ZS5tYXRjaChOT19XU19SRUdFWFApO1xuICAgICAgICB2YXIgaGFzRXhwYW5zaW9uU2libGluZyA9IGNvbnRleHQgJiZcbiAgICAgICAgICAgIChjb250ZXh0LnByZXYgaW5zdGFuY2VvZiBFeHBhbnNpb24gfHwgY29udGV4dC5uZXh0IGluc3RhbmNlb2YgRXhwYW5zaW9uKTtcbiAgICAgICAgaWYgKGlzTm90QmxhbmsgfHwgaGFzRXhwYW5zaW9uU2libGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDMocmVwbGFjZU5nc3AodGV4dC52YWx1ZSkucmVwbGFjZShXU19SRVBMQUNFX1JFR0VYUCwgJyAnKSwgdGV4dC5zb3VyY2VTcGFuLCB0ZXh0LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH07XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwYW5zaW9uO1xuICAgIH07XG4gICAgV2hpdGVzcGFjZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb25DYXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFdoaXRlc3BhY2VWaXNpdG9yO1xufSgpKTtcbmZ1bmN0aW9uIHJlbW92ZVdoaXRlc3BhY2VzKGh0bWxBc3RXaXRoRXJyb3JzKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodmlzaXRBbGwkMShuZXcgV2hpdGVzcGFjZVZpc2l0b3IoKSwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKSwgaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzKTtcbn1cbmZ1bmN0aW9uIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHZpc2l0b3IsIG5vZGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCwgaSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHsgcHJldjogbm9kZXNbaSAtIDFdLCBuZXh0OiBub2Rlc1tpICsgMV0gfTtcbiAgICAgICAgdmFyIGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbnZhciBQTFVSQUxfQ0FTRVMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gKiAgID0wIHt6ZXJvfVxuICogICA9MSB7b25lfVxuICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICpcbiAqIGBgYFxuICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPnplcm88L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj5vbmU8L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj5tb3JlIHRoYW4gb25lPC9uZy10ZW1wbGF0ZT5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZE5vZGVzKG5vZGVzKSB7XG4gICAgdmFyIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsJDEoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbn1cbnZhciBFeHBhbnNpb25SZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uUmVzdWx0KG5vZGVzLCBleHBhbmRlZCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbn0oKSk7XG52YXIgRXhwYW5zaW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbkVycm9yKHNwYW4sIGVycm9yTXNnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvbkVycm9yO1xufShQYXJzZUVycm9yKSk7XG4vKipcbiAqIEV4cGFuZCBleHBhbnNpb24gZm9ybXMgKHBsdXJhbCwgc2VsZWN0KSB0byBkaXJlY3RpdmVzXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBfRXhwYW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX0V4cGFuZGVyKCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShlbGVtZW50Lm5hbWUsIGVsZW1lbnQuYXR0cnMsIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH07XG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICBfZXhwYW5kRGVmYXVsdEZvcm0oaWN1LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBiZSByZWFjaGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gX0V4cGFuZGVyO1xufSgpKTtcbi8vIFBsdXJhbCBmb3JtcyBhcmUgZXhwYW5kZWQgdG8gYE5nUGx1cmFsYCBhbmQgYE5nUGx1cmFsQ2FzZWBzXG5mdW5jdGlvbiBfZXhwYW5kUGx1cmFsRm9ybShhc3QsIGVycm9ycykge1xuICAgIHZhciBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKFBMVVJBTF9DQVNFUy5pbmRleE9mKGMudmFsdWUpID09IC0xICYmICFjLnZhbHVlLm1hdGNoKC9ePVxcZCskLykpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKCcsICcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGFuc2lvblJlc3VsdCA9IGV4cGFuZE5vZGVzKGMuZXhwcmVzc2lvbik7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX19zcHJlYWQoZXhwYW5zaW9uUmVzdWx0LmVycm9ycykpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICB9KTtcbiAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUoJ1tuZ1BsdXJhbF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBuZXcgRWxlbWVudCQxKCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cbi8vIElDVSBtZXNzYWdlcyAoZXhjbHVkaW5nIHBsdXJhbCBmb3JtKSBhcmUgZXhwYW5kZWQgdG8gYE5nU3dpdGNoYCAgYW5kIGBOZ1N3aXRjaENhc2Vgc1xuZnVuY3Rpb24gX2V4cGFuZERlZmF1bHRGb3JtKGFzdCwgZXJyb3JzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChleHBhbnNpb25SZXN1bHQuZXJyb3JzKSk7XG4gICAgICAgIGlmIChjLnZhbHVlID09PSAnb3RoZXInKSB7XG4gICAgICAgICAgICAvLyBvdGhlciBpcyB0aGUgZGVmYXVsdCBjYXNlIHdoZW4gbm8gdmFsdWVzIG1hdGNoXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlKCduZ1N3aXRjaERlZmF1bHQnLCAnJywgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlKCduZ1N3aXRjaENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICB9KTtcbiAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUoJ1tuZ1N3aXRjaF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBuZXcgRWxlbWVudCQxKCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9hO1xuLyoqXG4gKiBBIHNlZ21lbnQgb2YgdGV4dCB3aXRoaW4gdGhlIHRlbXBsYXRlLlxuICovXG52YXIgVGV4dEFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYm91bmQgZXhwcmVzc2lvbiB3aXRoaW4gdGhlIHRleHQgb2YgYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIEJvdW5kVGV4dEFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3VuZFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIEF0dHJBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXR0ckFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIEF0dHJBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJBc3Q7XG59KCkpO1xudmFyIEJvdW5kUHJvcGVydHlNYXBwaW5nID0gKF9hID0ge30sXG4gICAgX2FbNCAvKiBBbmltYXRpb24gKi9dID0gNCAvKiBBbmltYXRpb24gKi8sXG4gICAgX2FbMSAvKiBBdHRyaWJ1dGUgKi9dID0gMSAvKiBBdHRyaWJ1dGUgKi8sXG4gICAgX2FbMiAvKiBDbGFzcyAqL10gPSAyIC8qIENsYXNzICovLFxuICAgIF9hWzAgLyogUHJvcGVydHkgKi9dID0gMCAvKiBQcm9wZXJ0eSAqLyxcbiAgICBfYVszIC8qIFN0eWxlICovXSA9IDMgLyogU3R5bGUgKi8sXG4gICAgX2EpO1xuLyoqXG4gKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgcHJvcGVydHkgKGUuZy4gYFtwcm9wZXJ0eV09XCJleHByZXNzaW9uXCJgKSBvciBhbiBhbmltYXRpb24gdHJpZ2dlciAoZS5nLlxuICogYFtAdHJpZ2dlcl09XCJzdGF0ZUV4cFwiYClcbiAqL1xudmFyIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KG5hbWUsIHR5cGUsIHNlY3VyaXR5Q29udGV4dCwgdmFsdWUsIHVuaXQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGlvbiA9IHRoaXMudHlwZSA9PT0gNCAvKiBBbmltYXRpb24gKi87XG4gICAgfVxuICAgIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LmZyb21Cb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBCb3VuZFByb3BlcnR5TWFwcGluZ1twcm9wLnR5cGVdO1xuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KHByb3AubmFtZSwgdHlwZSwgcHJvcC5zZWN1cml0eUNvbnRleHQsIHByb3AudmFsdWUsIHByb3AudW5pdCwgcHJvcC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0O1xufSgpKTtcbi8qKlxuICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IGV2ZW50IChlLmcuIGAoZXZlbnQpPVwiaGFuZGxlcigpXCJgKSBvciBhbiBhbmltYXRpb24gdHJpZ2dlciBldmVudCAoZS5nLlxuICogYChAdHJpZ2dlci5waGFzZSk9XCJjYWxsYmFjaygkZXZlbnQpXCJgKS5cbiAqL1xudmFyIEJvdW5kRXZlbnRBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm91bmRFdmVudEFzdChuYW1lLCB0YXJnZXQsIHBoYXNlLCBoYW5kbGVyLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmhhbmRsZXJTcGFuID0gaGFuZGxlclNwYW47XG4gICAgICAgIHRoaXMuZnVsbE5hbWUgPSBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSh0aGlzLm5hbWUsIHRoaXMudGFyZ2V0LCB0aGlzLnBoYXNlKTtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGlvbiA9ICEhdGhpcy5waGFzZTtcbiAgICB9XG4gICAgQm91bmRFdmVudEFzdC5jYWxjRnVsbE5hbWUgPSBmdW5jdGlvbiAobmFtZSwgdGFyZ2V0LCBwaGFzZSkge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0ICsgXCI6XCIgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQFwiICsgbmFtZSArIFwiLlwiICsgcGhhc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBCb3VuZEV2ZW50QXN0LmZyb21QYXJzZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudHlwZSA9PT0gMCAvKiBSZWd1bGFyICovID8gZXZlbnQudGFyZ2V0T3JQaGFzZSA6IG51bGw7XG4gICAgICAgIHZhciBwaGFzZSA9IGV2ZW50LnR5cGUgPT09IDEgLyogQW5pbWF0aW9uICovID8gZXZlbnQudGFyZ2V0T3JQaGFzZSA6IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFdmVudEFzdChldmVudC5uYW1lLCB0YXJnZXQsIHBoYXNlLCBldmVudC5oYW5kbGVyLCBldmVudC5zb3VyY2VTcGFuLCBldmVudC5oYW5kbGVyU3Bhbik7XG4gICAgfTtcbiAgICBCb3VuZEV2ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXZlbnQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICovXG52YXIgUmVmZXJlbmNlQXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUFzdChuYW1lLCB2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIFJlZmVyZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2VBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG9uIGEgPG5nLXRlbXBsYXRlPiAoZS5nLiBgdmFyLXNvbWVOYW1lPVwic29tZUxvY2FsTmFtZVwiYCkuXG4gKi9cbnZhciBWYXJpYWJsZUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYXJpYWJsZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIFZhcmlhYmxlQXN0LmZyb21QYXJzZWRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVBc3Qodi5uYW1lLCB2LnZhbHVlLCB2LnNvdXJjZVNwYW4sIHYudmFsdWVTcGFuKTtcbiAgICB9O1xuICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFibGVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBbiBlbGVtZW50IGRlY2xhcmF0aW9uIGluIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBFbGVtZW50QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBxdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5xdWVyeU1hdGNoZXMgPSBxdWVyeU1hdGNoZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICBFbGVtZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50QXN0O1xufSgpKTtcbi8qKlxuICogQSBgPG5nLXRlbXBsYXRlPmAgZWxlbWVudCBpbmNsdWRlZCBpbiBhbiBBbmd1bGFyIHRlbXBsYXRlLlxuICovXG52YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVtYmVkZGVkVGVtcGxhdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gKi9cbnZhciBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnQuXG4gKi9cbnZhciBEaXJlY3RpdmVBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgaW5wdXRzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgY29udGVudFF1ZXJ5U3RhcnRJZCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuaG9zdFByb3BlcnRpZXMgPSBob3N0UHJvcGVydGllcztcbiAgICAgICAgdGhpcy5ob3N0RXZlbnRzID0gaG9zdEV2ZW50cztcbiAgICAgICAgdGhpcy5jb250ZW50UXVlcnlTdGFydElkID0gY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgRGlyZWN0aXZlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZUFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcHJvdmlkZXIgZGVjbGFyZWQgb24gYW4gZWxlbWVudFxuICovXG52YXIgUHJvdmlkZXJBc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4sIGlzTW9kdWxlKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgdGhpcy5lYWdlciA9IGVhZ2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5wcm92aWRlclR5cGUgPSBwcm92aWRlclR5cGU7XG4gICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBsaWZlY3ljbGVIb29rcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pc01vZHVsZSA9IGlzTW9kdWxlO1xuICAgIH1cbiAgICBQcm92aWRlckFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAvLyBObyB2aXNpdCBtZXRob2QgaW4gdGhlIHZpc2l0b3IgZm9yIG5vdy4uLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQcm92aWRlckFzdDtcbn0oKSk7XG52YXIgUHJvdmlkZXJBc3RUeXBlO1xuKGZ1bmN0aW9uIChQcm92aWRlckFzdFR5cGUpIHtcbiAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiUHVibGljU2VydmljZVwiXSA9IDBdID0gXCJQdWJsaWNTZXJ2aWNlXCI7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlByaXZhdGVTZXJ2aWNlXCJdID0gMV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG4gICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkNvbXBvbmVudFwiXSA9IDJdID0gXCJDb21wb25lbnRcIjtcbiAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiRGlyZWN0aXZlXCJdID0gM10gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJCdWlsdGluXCJdID0gNF0gPSBcIkJ1aWx0aW5cIjtcbn0pKFByb3ZpZGVyQXN0VHlwZSB8fCAoUHJvdmlkZXJBc3RUeXBlID0ge30pKTtcbi8qKlxuICogUG9zaXRpb24gd2hlcmUgY29udGVudCBpcyB0byBiZSBwcm9qZWN0ZWQgKGluc3RhbmNlIG9mIGA8bmctY29udGVudD5gIGluIGEgdGVtcGxhdGUpLlxuICovXG52YXIgTmdDb250ZW50QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5nQ29udGVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHZpc2l0b3IgdGhhdCBhY2NlcHRzIGVhY2ggbm9kZSBidXQgZG9lc24ndCBkbyBhbnl0aGluZy4gSXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICogYXMgdGhlIGJhc2UgY2xhc3MgZm9yIGEgdmlzaXRvciB0aGF0IGlzIG9ubHkgaW50ZXJlc3RlZCBpbiBhIHN1YnNldCBvZiB0aGUgbm9kZSB0eXBlcy5cbiAqL1xudmFyIE51bGxUZW1wbGF0ZVZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTnVsbFRlbXBsYXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgTnVsbFRlbXBsYXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIE51bGxUZW1wbGF0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBOdWxsVGVtcGxhdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIHJldHVybiBOdWxsVGVtcGxhdGVWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIGEgdmlzaXRvciB0aGF0IHZpc2l0cyBlYWNoIG5vZGVcbiAqIGluIGFuIHRlbXBsYXRlIGFzdCByZWN1cnNpdmVseS5cbiAqL1xudmFyIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5vZGVzIHdpdGggY2hpbGRyZW5cbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5hdHRycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB2aXNpdChhc3QudmFyaWFibGVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5wcm92aWRlcnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCBmdW5jdGlvbiAodmlzaXQpIHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5hdHRycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuaW5wdXRzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5vdXRwdXRzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5wcm92aWRlcnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWN1cnNpdmVUZW1wbGF0ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIGZ1bmN0aW9uICh2aXNpdCkge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmlucHV0cyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0Lmhvc3RFdmVudHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBjYikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIHZpc2l0KGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZW1wbGF0ZVZpc2l0QWxsKHQsIGNoaWxkcmVuLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2IodmlzaXQpO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlVGVtcGxhdGVBc3RWaXNpdG9yO1xufShOdWxsVGVtcGxhdGVWaXNpdG9yKSk7XG4vKipcbiAqIFZpc2l0IGV2ZXJ5IG5vZGUgaW4gYSBsaXN0IG9mIHtAbGluayBUZW1wbGF0ZUFzdH1zIHdpdGggdGhlIGdpdmVuIHtAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9LlxuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIGFzdHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFByb3ZpZGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFcnJvcihtZXNzYWdlLCBzcGFuKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFByb3ZpZGVyVmlld0NvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJWaWV3Q29udGV4dChyZWZsZWN0b3IsIGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21wb25lbnQudmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbn0oKSk7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBpc1RlbXBsYXRlLCBjb250ZW50UXVlcnlTdGFydElkLCBfc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdDb250ZXh0ID0gdmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQXN0cyA9IF9kaXJlY3RpdmVBc3RzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9xdWVyaWVkVG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdHRycyA9IHt9O1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyQXN0KSB7IHJldHVybiBfdGhpcy5fYXR0cnNbYXR0ckFzdC5uYW1lXSA9IGF0dHJBc3QudmFsdWU7IH0pO1xuICAgICAgICB2YXIgZGlyZWN0aXZlc01ldGEgPSBfZGlyZWN0aXZlQXN0cy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycyA9XG4gICAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVyc0Zyb21EaXJlY3RpdmVzKGRpcmVjdGl2ZXNNZXRhLCBfc291cmNlU3Bhbiwgdmlld0NvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoY29udGVudFF1ZXJ5U3RhcnRJZCwgZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9hZGRRdWVyeVJlYWRzVG8ocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLnRva2VuLCBfdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlUmVmSWQgPSBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLCBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB0aGlzLl9hZGRRdWVyeVJlYWRzVG8odGVtcGxhdGVSZWZJZCwgdGVtcGxhdGVSZWZJZCwgdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UXVlcnlWYWx1ZSA9IHJlZkFzdC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UoX3RoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLCBJZGVudGlmaWVycy5FbGVtZW50UmVmKTtcbiAgICAgICAgICAgIF90aGlzLl9hZGRRdWVyeVJlYWRzVG8oeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSwgZGVmYXVsdFF1ZXJ5VmFsdWUsIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9xdWVyaWVkVG9rZW5zLmdldCh0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm92aWRlcnMgdGhhdCB3ZSBrbm93IGFyZSBlYWdlciBmaXJzdFxuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBlYWdlciA9IHByb3ZpZGVyLmVhZ2VyIHx8IF90aGlzLl9xdWVyaWVkVG9rZW5zLmdldCh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikpO1xuICAgICAgICAgICAgaWYgKGVhZ2VyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLnRva2VuLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29sbGVjdCBsYXp5IHByb3ZpZGVyc1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2FsbFByb3ZpZGVycy52YWx1ZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IE1hcHMga2VlcCB0aGVpciBpbnNlcnRpb24gb3JkZXIuXG4gICAgICAgICAgICB2YXIgbGF6eVByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGVhZ2VyUHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgICAgICBlYWdlclByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhenlQcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGF6eVByb3ZpZGVycy5jb25jYXQoZWFnZXJQcm92aWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29ydGVkUHJvdmlkZXJUeXBlcyA9IHRoaXMudHJhbnNmb3JtUHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXI7IH0pO1xuICAgICAgICAgICAgdmFyIHNvcnRlZERpcmVjdGl2ZXMgPSB0aGlzLl9kaXJlY3RpdmVBc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICBzb3J0ZWREaXJlY3RpdmVzLnNvcnQoZnVuY3Rpb24gKGRpcjEsIGRpcjIpIHsgcmV0dXJuIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIxLmRpcmVjdGl2ZS50eXBlKSAtXG4gICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWREaXJlY3RpdmVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwicXVlcnlNYXRjaGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcXVlcmllZFRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoLmFwcGx5KGFsbE1hdGNoZXMsIF9fc3ByZWFkKG1hdGNoZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9hZGRRdWVyeVJlYWRzVG8gPSBmdW5jdGlvbiAodG9rZW4sIGRlZmF1bHRWYWx1ZSwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgIHRoaXMuX2dldFF1ZXJpZXNGb3IodG9rZW4pLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnlWYWx1ZSA9IHF1ZXJ5Lm1ldGEucmVhZCB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgdG9rZW5SZWYgPSB0b2tlblJlZmVyZW5jZShxdWVyeVZhbHVlKTtcbiAgICAgICAgICAgIHZhciBxdWVyeU1hdGNoZXMgPSBxdWVyeVJlYWRUb2tlbnMuZ2V0KHRva2VuUmVmKTtcbiAgICAgICAgICAgIGlmICghcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzID0gW107XG4gICAgICAgICAgICAgICAgcXVlcnlSZWFkVG9rZW5zLnNldCh0b2tlblJlZiwgcXVlcnlNYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5wdXNoKHsgcXVlcnlJZDogcXVlcnkucXVlcnlJZCwgdmFsdWU6IHF1ZXJ5VmFsdWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIHF1ZXJpZXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX2NvbnRlbnRRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9fc3ByZWFkKHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlQXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXdDb250ZXh0LnZpZXdRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAocXVlcmllcykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZChxdWVyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgdG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIgfHxcbiAgICAgICAgICAgICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSwgZWFnZXIpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0RpRGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0TG9jYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZGVwLmlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBhdHRyVmFsdWUgPT0gbnVsbCA/IG51bGwgOiBhdHRyVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjY2VzcyBidWlsdGludHNcbiAgICAgICAgICAgIGlmICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5SZW5kZXJlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5FbGVtZW50UmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGN1cnJFbGVtZW50ID0gdGhpcztcbiAgICAgICAgdmFyIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXAuaXNTZWxmKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHBhcmVudCBlbGVtZW50c1xuICAgICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgY3VyckVsZW1lbnQuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWxlbWVudCA9IGN1cnJFbGVtZW50O1xuICAgICAgICAgICAgICAgIGN1cnJFbGVtZW50ID0gY3VyckVsZW1lbnQuX3BhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyckVhZ2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGRlcCwgY3VyckVhZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVwLmlzSG9zdCB8fCB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGV4dC52aWV3UHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcC5pc09wdGlvbmFsID8geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9IDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyB0b2tlbk5hbWUoZGVwLnRva2VuKSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdmlkZXJFbGVtZW50Q29udGV4dDtcbn0oKSk7XG52YXIgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihyZWZsZWN0b3IsIG5nTW9kdWxlLCBleHRyYVByb3ZpZGVycywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9hbGxQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBuZ01vZHVsZVByb3ZpZGVyID0geyB0b2tlbjogeyBpZGVudGlmaWVyOiBuZ01vZHVsZVR5cGUgfSwgdXNlQ2xhc3M6IG5nTW9kdWxlVHlwZSB9O1xuICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW25nTW9kdWxlUHJvdmlkZXJdLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgdHJ1ZSwgc291cmNlU3BhbiwgX3RoaXMuX2Vycm9ycywgX3RoaXMuX2FsbFByb3ZpZGVycywgLyogaXNNb2R1bGUgKi8gdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBlbnRyeS5wcm92aWRlcjsgfSkuY29uY2F0KGV4dHJhUHJvdmlkZXJzKSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0aGlzLl9lcnJvcnMsIHRoaXMuX2FsbFByb3ZpZGVycywgXG4gICAgICAgIC8qIGlzTW9kdWxlICovIGZhbHNlKTtcbiAgICB9XG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5lYWdlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBNYXBzIGtlZXAgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyLlxuICAgICAgICB2YXIgbGF6eVByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgZWFnZXJQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgIGVhZ2VyUHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF6eVByb3ZpZGVycy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXp5UHJvdmlkZXJzLmNvbmNhdChlYWdlclByb3ZpZGVycyk7XG4gICAgfTtcbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIgPSBmdW5jdGlvbiAodG9rZW4sIGVhZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIkNhbm5vdCBpbnN0YW50aWF0ZSBjeWNsaWMgZGVwZW5kZW5jeSEgXCIgKyB0b2tlbk5hbWUodG9rZW4pLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci51c2VFeGlzdGluZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9LCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgfTtcbiAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCwgZWFnZXIsIHJlcXVlc3RvclNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgZm91bmRMb2NhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmICYmIGRlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuSW5qZWN0b3IpIHx8XG4gICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgcHJvdmlkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIoZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXA7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xufSgpKTtcbmZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwgX2EpIHtcbiAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICB1c2VDbGFzczogcHJvdmlkZXIudXNlQ2xhc3MsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgdXNlVmFsdWU6IHVzZVZhbHVlLFxuICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICB9O1xufVxuZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgIHZhciBlYWdlciA9IF9hLmVhZ2VyLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnM7XG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGlQcm92aWRlciwgcHJvdmlkZXIuZWFnZXIgfHwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci5saWZlY3ljbGVIb29rcywgcHJvdmlkZXIuc291cmNlU3BhbiwgcHJvdmlkZXIuaXNNb2R1bGUpO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICB2YXIgcHJvdmlkZXJzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgZGlyUHJvdmlkZXIgPSB7IHRva2VuOiB7IGlkZW50aWZpZXI6IGRpcmVjdGl2ZS50eXBlIH0sIHVzZUNsYXNzOiBkaXJlY3RpdmUudHlwZSB9O1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbZGlyUHJvdmlkZXJdLCBkaXJlY3RpdmUuaXNDb21wb25lbnQgPyBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50IDogUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSwgdHJ1ZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuLCAvKiBpc01vZHVsZSAqLyBmYWxzZSk7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogZGlyZWN0aXZlcyBuZWVkIHRvIGJlIGFibGUgdG8gb3ZlcndyaXRlIHByb3ZpZGVycyBvZiBhIGNvbXBvbmVudCFcbiAgICB2YXIgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdCA9IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pc0NvbXBvbmVudDsgfSkuY29uY2F0KGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICFkaXIuaXNDb21wb25lbnQ7IH0pKTtcbiAgICBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0LmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbiwgLyogaXNNb2R1bGUgKi8gZmFsc2UpO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUudmlld1Byb3ZpZGVycywgUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuLCAvKiBpc01vZHVsZSAqLyBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3ZpZGVyc0J5VG9rZW47XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbiwgaXNNb2R1bGUpIHtcbiAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0YXJnZXRQcm92aWRlcnNCeVRva2VuLmdldCh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikpO1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAhPSBudWxsICYmICEhcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSAhIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk1peGluZyBtdWx0aSBhbmQgbm9uIG11bHRpIHByb3ZpZGVyIGlzIG5vdCBwb3NzaWJsZSBmb3IgdG9rZW4gXCIgKyB0b2tlbk5hbWUocmVzb2x2ZWRQcm92aWRlci50b2tlbiksIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgJiZcbiAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzID9cbiAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzIDpcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgICAgIHZhciBpc1VzZVZhbHVlID0gIShwcm92aWRlci51c2VDbGFzcyB8fCBwcm92aWRlci51c2VFeGlzdGluZyB8fCBwcm92aWRlci51c2VGYWN0b3J5KTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sICEhcHJvdmlkZXIubXVsdGksIGVhZ2VyIHx8IGlzVXNlVmFsdWUsIFtwcm92aWRlcl0sIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4sIGlzTW9kdWxlKTtcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgIHZhciB2aWV3UXVlcnlJZCA9IDE7XG4gICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGlmIChjb21wb25lbnQudmlld1F1ZXJpZXMpIHtcbiAgICAgICAgY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiB2aWV3UXVlcnlJZCsrIH0pOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdRdWVyaWVzO1xufVxuZnVuY3Rpb24gX2dldENvbnRlbnRRdWVyaWVzKGNvbnRlbnRRdWVyeVN0YXJ0SWQsIGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgY29udGVudFF1ZXJ5SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgIHZhciBjb250ZW50UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5kZXgpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZS5xdWVyaWVzKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgeyBtZXRhOiBxdWVyeSwgcXVlcnlJZDogY29udGVudFF1ZXJ5SWQrKyB9KTsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGVudFF1ZXJpZXM7XG59XG5mdW5jdGlvbiBfYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICBxdWVyeS5tZXRhLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlV2l0aEltcG9ydHM7XG59KCkpO1xuZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgaWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG4vKipcbiAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIEBpbXBvcnQgdXJscyB0aGF0XG4gKiBhcmUgZWl0aGVyIHJlbGF0aXZlIG9yIGRvbid0IGhhdmUgYSBgcGFja2FnZTpgIHNjaGVtZVxuICovXG5mdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgdmFyIGZvdW5kVXJscyA9IFtdO1xuICAgIHZhciBtb2RpZmllZENzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoQ1NTX1NUUklQUEFCTEVfQ09NTUVOVF9SRUdFWFAsICcnKVxuICAgICAgICAucmVwbGFjZShDU1NfSU1QT1JUX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSBtWzFdIHx8IG1bMl07XG4gICAgICAgIGlmICghaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJXG4gICAgICAgICAgICAvLyBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kVXJscy5wdXNoKHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMobW9kaWZpZWRDc3NUZXh0LCBmb3VuZFVybHMpO1xufVxudmFyIENTU19JTVBPUlRfUkVHRVhQID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xudmFyIENTU19TVFJJUFBBQkxFX0NPTU1FTlRfUkVHRVhQID0gL1xcL1xcKig/ISNcXHMqKD86c291cmNlVVJMfHNvdXJjZU1hcHBpbmdVUkwpPSlbXFxzXFxTXSs/XFwqXFwvL2c7XG52YXIgVVJMX1dJVEhfU0NIRU1BX1JFR0VYUCA9IC9eKFteOi8/I10rKTovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gJy4nO1xudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbnZhciBTVFlMRV9QUkVGSVggPSAnc3R5bGUnO1xudmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYID0gJyonO1xudmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xuLyoqXG4gKiBQYXJzZXMgYmluZGluZ3MgaW4gdGVtcGxhdGVzIGFuZCBpbiB0aGUgZGlyZWN0aXZlIGhvc3QgYXJlYS5cbiAqL1xudmFyIEJpbmRpbmdQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ1BhcnNlcihfZXhwclBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcsIF9zY2hlbWFSZWdpc3RyeSwgcGlwZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnBpcGVzQnlOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXNlZFBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGVuIHRoZSBgcGlwZXNgIHBhcmFtZXRlciBpcyBgbnVsbGAsIGRvIG5vdCBjaGVjayBmb3IgdXNlZCBwaXBlc1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgaW4gSVZZIHdoZW4gd2UgbWlnaHQgbm90IGtub3cgdGhlIGF2YWlsYWJsZSBwaXBlcyBhdCBjb21waWxlIHRpbWVcbiAgICAgICAgaWYgKHBpcGVzKSB7XG4gICAgICAgICAgICB2YXIgcGlwZXNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIHBpcGVzQnlOYW1lXzEuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5waXBlc0J5TmFtZSA9IHBpcGVzQnlOYW1lXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLCBcImludGVycG9sYXRpb25Db25maWdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5nZXRVc2VkUGlwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3VzZWRQaXBlcy52YWx1ZXMoKSk7XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRpck1ldGEsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBib3VuZFByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBkaXJNZXRhLmhvc3RQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcnNlUHJvcGVydHlCaW5kaW5nKHByb3BOYW1lLCBleHByZXNzaW9uLCB0cnVlLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCwgdW5kZWZpbmVkLCBbXSwgYm91bmRQcm9wc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlZhbHVlIG9mIHRoZSBob3N0IHByb3BlcnR5IGJpbmRpbmcgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyTWV0YSwgZWxlbWVudFNlbGVjdG9yLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZFByb3BzID0gdGhpcy5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKGRpck1ldGEsIHNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gYm91bmRQcm9wcyAmJlxuICAgICAgICAgICAgYm91bmRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnRTZWxlY3RvciwgcHJvcCk7IH0pO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRFdmVudHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0TGlzdGVuZXJzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgYSBtb3JlIGFjY3VyYXRlIGhhbmRsZXJTcGFuIGZvciB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUV2ZW50KHByb3BOYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBbXSwgdGFyZ2V0RXZlbnRzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgbGlzdGVuZXIgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEV2ZW50c18xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgYmluZGluZ3MgaW4gYSBtaWNyb3N5bnRheCBleHByZXNzaW9uLCBhbmQgY29udmVydHMgdGhlbSB0b1xuICAgICAqIGBQYXJzZWRQcm9wZXJ0eWAgb3IgYFBhcnNlZFZhcmlhYmxlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cGxLZXkgdGVtcGxhdGUgYmluZGluZyBuYW1lXG4gICAgICogQHBhcmFtIHRwbFZhbHVlIHRlbXBsYXRlIGJpbmRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhbiBzcGFuIG9mIHRlbXBsYXRlIGJpbmRpbmcgcmVsYXRpdmUgdG8gZW50aXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZVZhbHVlT2Zmc2V0IHN0YXJ0IG9mIHRoZSB0cGxWYWx1ZSByZWxhdGl2ZSB0byB0aGUgZW50aXJlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHRhcmdldE1hdGNoYWJsZUF0dHJzIHBvdGVudGlhbCBhdHRyaWJ1dGVzIHRvIG1hdGNoIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRQcm9wcyB0YXJnZXQgcHJvcGVydHkgYmluZGluZ3MgaW4gdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHRhcmdldFZhcnMgdGFyZ2V0IHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uICh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZVZhbHVlT2Zmc2V0LCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBhYnNvbHV0ZUtleU9mZnNldCA9IHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlU3BhbiwgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYmluZGluZ3NfMSA9IF9fdmFsdWVzKGJpbmRpbmdzKSwgYmluZGluZ3NfMV8xID0gYmluZGluZ3NfMS5uZXh0KCk7ICFiaW5kaW5nc18xXzEuZG9uZTsgYmluZGluZ3NfMV8xID0gYmluZGluZ3NfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBzb3VyY2VTcGFuIGlzIGZvciB0aGUgZW50aXJlIEhUTUwgYXR0cmlidXRlLiBiaW5kaW5nU3BhbiBpcyBmb3IgYSBwYXJ0aWN1bGFyXG4gICAgICAgICAgICAgICAgLy8gYmluZGluZyB3aXRoaW4gdGhlIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24gc28gaXQncyBtb3JlIG5hcnJvdyB0aGFuIHNvdXJjZVNwYW4uXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdTcGFuID0gbW92ZVBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLCBiaW5kaW5nLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBiaW5kaW5nLmtleS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGJpbmRpbmcua2V5LnNwYW4pO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nIGluc3RhbmNlb2YgVmFyaWFibGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWUgPyBiaW5kaW5nLnZhbHVlLnNvdXJjZSA6ICckaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVTcGFuID0gYmluZGluZy52YWx1ZSA/IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy52YWx1ZS5zcGFuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBQYXJzZWRWYXJpYWJsZShrZXksIHZhbHVlLCBiaW5kaW5nU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRpbmcudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlU3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy52YWx1ZS5hc3Quc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3Qoa2V5LCBiaW5kaW5nLnZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtrZXksICcnXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaXRlcmFsQXR0cihrZXksIG51bGwsIHNvdXJjZVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIHVuZGVmaW5lZCwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nc18xXzEgJiYgIWJpbmRpbmdzXzFfMS5kb25lICYmIChfYSA9IGJpbmRpbmdzXzEucmV0dXJuKSkgX2EuY2FsbChiaW5kaW5nc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBiaW5kaW5ncyBpbiBhIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24sIGUuZy5cbiAgICAgKiBgYGBcbiAgICAgKiAgICA8dGFnICp0cGxLZXk9XCJsZXQgdmFsdWUxID0gcHJvcDsgbGV0IHZhbHVlMiA9IGxvY2FsVmFyXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHBsS2V5IHRlbXBsYXRlIGJpbmRpbmcgbmFtZVxuICAgICAqIEBwYXJhbSB0cGxWYWx1ZSB0ZW1wbGF0ZSBiaW5kaW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gc3BhbiBvZiB0ZW1wbGF0ZSBiaW5kaW5nIHJlbGF0aXZlIHRvIGVudGlyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVLZXlPZmZzZXQgc3RhcnQgb2YgdGhlIGB0cGxLZXlgXG4gICAgICogQHBhcmFtIGFic29sdXRlVmFsdWVPZmZzZXQgc3RhcnQgb2YgdGhlIGB0cGxWYWx1ZWBcbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHRwbEtleSwgdHBsVmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZVZhbHVlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcudmFsdWUgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1BpcGVzKGJpbmRpbmcudmFsdWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcih3YXJuaW5nLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlTGl0ZXJhbEF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBQYXJzZWRQcm9wZXJ0eShuYW1lLCB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKHZhbHVlLCAnJywgYWJzb2x1dGVPZmZzZXQpLCBQYXJzZWRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlByb3BlcnR5IG5hbWUgaXMgbWlzc2luZyBpbiBiaW5kaW5nXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FuaW1hdGlvblByb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChBTklNQVRFX1BST1BfUFJFRklYKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhBTklNQVRFX1BST1BfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgaXNIb3N0LCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCB2YWx1ZVNwYW4gfHwgc291cmNlU3Bhbik7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGV4cHIsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5QXN0ID0gZnVuY3Rpb24gKG5hbWUsIGFzdCwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBQYXJzZWRQcm9wZXJ0eShuYW1lLCBhc3QsIFBhcnNlZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQW5pbWF0aW9uIHRyaWdnZXIgaXMgbWlzc2luZycsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBvY2N1ciB3aGVuIGEgQHRyaWdnZXIgaXMgbm90IHBhaXJlZCB3aXRoIGFuIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIEZvciBhbmltYXRpb25zIGl0IGlzIHZhbGlkIHRvIG5vdCBoYXZlIGFuIGV4cHJlc3Npb24gc2luY2UgKi92b2lkXG4gICAgICAgIC8vIHN0YXRlcyB3aWxsIGJlIGFwcGxpZWQgYnkgYW5ndWxhciB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkL2RldGFjaGVkXG4gICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiB8fCAndW5kZWZpbmVkJywgZmFsc2UsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgUGFyc2VkUHJvcGVydHkobmFtZSwgYXN0LCBQYXJzZWRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGlzSG9zdEJpbmRpbmcsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCB8fCAnKHVua25vd24pJykudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlU2ltcGxlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVCb3VuZEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcCwgc2tpcFZhbGlkYXRpb24sIG1hcFByb3BlcnR5TmFtZSkge1xuICAgICAgICBpZiAoc2tpcFZhbGlkYXRpb24gPT09IHZvaWQgMCkgeyBza2lwVmFsaWRhdGlvbiA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChtYXBQcm9wZXJ0eU5hbWUgPT09IHZvaWQgMCkgeyBtYXBQcm9wZXJ0eU5hbWUgPSB0cnVlOyB9XG4gICAgICAgIGlmIChib3VuZFByb3AuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHkoYm91bmRQcm9wLm5hbWUsIDQgLyogQW5pbWF0aW9uICovLCBTZWN1cml0eUNvbnRleHQuTk9ORSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIG51bGwsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBib3VuZFByb3AudmFsdWVTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5pdCA9IG51bGw7XG4gICAgICAgIHZhciBiaW5kaW5nVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGJvdW5kUHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHBhcnRzID0gYm91bmRQcm9wLm5hbWUuc3BsaXQoUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBzcGVjaWFsIGNhc2VzIChwcmVmaXggc3R5bGUsIGF0dHIsIGNsYXNzKVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09IEFUVFJJQlVURV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWVyZ2VOc0FuZE5hbWUobnMsIG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMSAvKiBBdHRyaWJ1dGUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMiAvKiBDbGFzcyAqLztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAzIC8qIFN0eWxlICovO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1hcHBlZFByb3BOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUoYm91bmRQcm9wLm5hbWUpO1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtYXBQcm9wZXJ0eU5hbWUgPyBtYXBwZWRQcm9wTmFtZSA6IGJvdW5kUHJvcC5uYW1lO1xuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgbWFwcGVkUHJvcE5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMCAvKiBQcm9wZXJ0eSAqLztcbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lKG1hcHBlZFByb3BOYW1lLCBib3VuZFByb3Auc291cmNlU3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHkoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBzZWN1cml0eUNvbnRleHRzWzBdLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgdW5pdCwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGJvdW5kUHJvcC52YWx1ZVNwYW4pO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgbmFtZSBpcyBtaXNzaW5nIGluIGJpbmRpbmdcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIHRhcmdldEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVJlZ3VsYXJFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgcmV0dXJuIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wLCBpc0F0dHJpYnV0ZSk7XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoZXNbMF07XG4gICAgICAgIHZhciBwaGFzZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHBoYXNlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgaGFuZGxlclNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgUGFyc2VkRXZlbnQoZXZlbnROYW1lLCBwaGFzZSwgMSAvKiBBbmltYXRpb24gKi8sIGFzdCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIG91dHB1dCBwaGFzZSB2YWx1ZSBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBmb3IgXFxcIkBcIiArIGV2ZW50TmFtZSArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkICh1c2Ugc3RhcnQgb3IgZG9uZSlcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAXCIgKyBldmVudE5hbWUgKyBcIikgaXMgbWlzc2luZyBpdHMgcGhhc2UgdmFsdWUgbmFtZSAoc3RhcnQgb3IgZG9uZSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZClcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZVJlZ3VsYXJFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc3BsaXRBdENvbG9uKG5hbWUsIFtudWxsLCBuYW1lXSksIDIpLCB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBoYW5kbGVyU3Bhbik7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IFBhcnNlZEV2ZW50KGV2ZW50TmFtZSwgdGFyZ2V0LCAwIC8qIFJlZ3VsYXIgKi8sIGFzdCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4pKTtcbiAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICB9O1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgc291cmNlSW5mbyA9IChzb3VyY2VTcGFuICYmIHNvdXJjZVNwYW4uc3RhcnQgfHwgJyh1bmtub3duJykudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGFic29sdXRlT2Zmc2V0ID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCkgPyBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCA6IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzdCB8fCBhc3QuYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJFbXB0eSBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1I7IH1cbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH07XG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZXJyb3JzXzEgPSBfX3ZhbHVlcyhlcnJvcnMpLCBlcnJvcnNfMV8xID0gZXJyb3JzXzEubmV4dCgpOyAhZXJyb3JzXzFfMS5kb25lOyBlcnJvcnNfMV8xID0gZXJyb3JzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yc18xXzEgJiYgIWVycm9yc18xXzEuZG9uZSAmJiAoX2EgPSBlcnJvcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGVycm9yc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gTWFrZSBzdXJlIGFsbCB0aGUgdXNlZCBwaXBlcyBhcmUga25vd24gaW4gYHRoaXMucGlwZXNCeU5hbWVgXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX2NoZWNrUGlwZXMgPSBmdW5jdGlvbiAoYXN0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChhc3QgJiYgdGhpcy5waXBlc0J5TmFtZSkge1xuICAgICAgICAgICAgdmFyIGNvbGxlY3RvciA9IG5ldyBQaXBlQ29sbGVjdG9yKCk7XG4gICAgICAgICAgICBhc3QudmlzaXQoY29sbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5waXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QsIHBpcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpcGVNZXRhID0gX3RoaXMucGlwZXNCeU5hbWUuZ2V0KHBpcGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwaXBlICdcIiArIHBpcGVOYW1lICsgXCInIGNvdWxkIG5vdCBiZSBmb3VuZFwiLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KGFzdC5zcGFuLnN0YXJ0KSwgc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoYXN0LnNwYW4uZW5kKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3VzZWRQaXBlcy5zZXQocGlwZU5hbWUsIHBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHByb3BOYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAvIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgIHZhciByZXBvcnQgPSBpc0F0dHIgPyB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSkgOlxuICAgICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVQcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgIGlmIChyZXBvcnQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHJlcG9ydC5tc2csIHNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5FUlJPUik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nUGFyc2VyO1xufSgpKTtcbnZhciBQaXBlQ29sbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQaXBlQ29sbGVjdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBpcGVDb2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5waXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQaXBlQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGlwZXMuc2V0KGFzdC5uYW1lLCBhc3QpO1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUGlwZUNvbGxlY3Rvcjtcbn0oUmVjdXJzaXZlQXN0VmlzaXRvciQxKSk7XG5mdW5jdGlvbiBpc0FuaW1hdGlvbkxhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZVswXSA9PSAnQCc7XG59XG5mdW5jdGlvbiBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHJlZ2lzdHJ5LCBzZWxlY3RvciwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgdmFyIGN0eHMgPSBbXTtcbiAgICBDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3RvcikuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICB2YXIgbm90RWxlbWVudE5hbWVzID0gbmV3IFNldChzZWxlY3Rvci5ub3RTZWxlY3RvcnMuZmlsdGVyKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5lbGVtZW50OyB9KSk7XG4gICAgICAgIHZhciBwb3NzaWJsZUVsZW1lbnROYW1lcyA9IGVsZW1lbnROYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnROYW1lKSB7IHJldHVybiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSk7IH0pO1xuICAgICAgICBjdHhzLnB1c2guYXBwbHkoY3R4cywgX19zcHJlYWQocG9zc2libGVFbGVtZW50TmFtZXMubWFwKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gcmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpOyB9KSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtTZWN1cml0eUNvbnRleHQuTk9ORV0gOiBBcnJheS5mcm9tKG5ldyBTZXQoY3R4cykpLnNvcnQoKTtcbn1cbi8qKlxuICogQ29tcHV0ZSBhIG5ldyBQYXJzZVNvdXJjZVNwYW4gYmFzZWQgb2ZmIGFuIG9yaWdpbmFsIGBzb3VyY2VTcGFuYCBieSB1c2luZ1xuICogYWJzb2x1dGUgb2Zmc2V0cyBmcm9tIHRoZSBzcGVjaWZpZWQgYGFic29sdXRlU3BhbmAuXG4gKlxuICogQHBhcmFtIHNvdXJjZVNwYW4gb3JpZ2luYWwgc291cmNlIHNwYW5cbiAqIEBwYXJhbSBhYnNvbHV0ZVNwYW4gYWJzb2x1dGUgc291cmNlIHNwYW4gdG8gbW92ZSB0b1xuICovXG5mdW5jdGlvbiBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGFic29sdXRlU3Bhbikge1xuICAgIC8vIFRoZSBkaWZmZXJlbmNlIG9mIHR3byBhYnNvbHV0ZSBvZmZzZXRzIHByb3ZpZGUgdGhlIHJlbGF0aXZlIG9mZnNldFxuICAgIHZhciBzdGFydERpZmYgPSBhYnNvbHV0ZVNwYW4uc3RhcnQgLSBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICB2YXIgZW5kRGlmZiA9IGFic29sdXRlU3Bhbi5lbmQgLSBzb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoc3RhcnREaWZmKSwgc291cmNlU3Bhbi5lbmQubW92ZUJ5KGVuZERpZmYpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0JztcbnZhciBMSU5LX0VMRU1FTlQgPSAnbGluayc7XG52YXIgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xudmFyIExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xudmFyIExJTktfU1RZTEVfUkVMX1ZBTFVFID0gJ3N0eWxlc2hlZXQnO1xudmFyIFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xudmFyIFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XG52YXIgTkdfTk9OX0JJTkRBQkxFX0FUVFIgPSAnbmdOb25CaW5kYWJsZSc7XG52YXIgTkdfUFJPSkVDVF9BUyA9ICduZ1Byb2plY3RBcyc7XG5mdW5jdGlvbiBwcmVwYXJzZUVsZW1lbnQoYXN0KSB7XG4gICAgdmFyIHNlbGVjdEF0dHIgPSBudWxsO1xuICAgIHZhciBocmVmQXR0ciA9IG51bGw7XG4gICAgdmFyIHJlbEF0dHIgPSBudWxsO1xuICAgIHZhciBub25CaW5kYWJsZSA9IGZhbHNlO1xuICAgIHZhciBwcm9qZWN0QXMgPSAnJztcbiAgICBhc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICB2YXIgbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobGNBdHRyTmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKSB7XG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgIHZhciBub2RlTmFtZSA9IGFzdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUjtcbiAgICBpZiAoaXNOZ0NvbnRlbnQobm9kZU5hbWUpKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcyk7XG59XG52YXIgUHJlcGFyc2VkRWxlbWVudFR5cGU7XG4oZnVuY3Rpb24gKFByZXBhcnNlZEVsZW1lbnRUeXBlKSB7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJOR19DT05URU5UXCJdID0gMF0gPSBcIk5HX0NPTlRFTlRcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFXCJdID0gMV0gPSBcIlNUWUxFXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVNIRUVUXCJdID0gMl0gPSBcIlNUWUxFU0hFRVRcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNDUklQVFwiXSA9IDNdID0gXCJTQ1JJUFRcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk9USEVSXCJdID0gNF0gPSBcIk9USEVSXCI7XG59KShQcmVwYXJzZWRFbGVtZW50VHlwZSB8fCAoUHJlcGFyc2VkRWxlbWVudFR5cGUgPSB7fSkpO1xudmFyIFByZXBhcnNlZEVsZW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgfVxuICAgIHJldHVybiBQcmVwYXJzZWRFbGVtZW50O1xufSgpKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKSB7XG4gICAgaWYgKHNlbGVjdEF0dHIgPT09IG51bGwgfHwgc2VsZWN0QXR0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcqJztcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdEF0dHI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooPzooPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKikpfFxcW1xcKChbXlxcKV0rKVxcKVxcXXxcXFsoW15cXF1dKylcXF18XFwoKFteXFwpXSspXFwpKSQvO1xuLy8gR3JvdXAgMSA9IFwiYmluZC1cIlxudmFyIEtXX0JJTkRfSURYID0gMTtcbi8vIEdyb3VwIDIgPSBcImxldC1cIlxudmFyIEtXX0xFVF9JRFggPSAyO1xuLy8gR3JvdXAgMyA9IFwicmVmLS8jXCJcbnZhciBLV19SRUZfSURYID0gMztcbi8vIEdyb3VwIDQgPSBcIm9uLVwiXG52YXIgS1dfT05fSURYID0gNDtcbi8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxudmFyIEtXX0JJTkRPTl9JRFggPSA1O1xuLy8gR3JvdXAgNiA9IFwiQFwiXG52YXIgS1dfQVRfSURYID0gNjtcbi8vIEdyb3VwIDcgPSB0aGUgaWRlbnRpZmllciBhZnRlciBcImJpbmQtXCIsIFwibGV0LVwiLCBcInJlZi0vI1wiLCBcIm9uLVwiLCBcImJpbmRvbi1cIiBvciBcIkBcIlxudmFyIElERU5UX0tXX0lEWCA9IDc7XG4vLyBHcm91cCA4ID0gaWRlbnRpZmllciBpbnNpZGUgWygpXVxudmFyIElERU5UX0JBTkFOQV9CT1hfSURYID0gODtcbi8vIEdyb3VwIDkgPSBpZGVudGlmaWVyIGluc2lkZSBbXVxudmFyIElERU5UX1BST1BFUlRZX0lEWCA9IDk7XG4vLyBHcm91cCAxMCA9IGlkZW50aWZpZXIgaW5zaWRlICgpXG52YXIgSURFTlRfRVZFTlRfSURYID0gMTA7XG52YXIgVEVNUExBVEVfQVRUUl9QUkVGSVgkMSA9ICcqJztcbnZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcbnZhciBfVEVYVF9DU1NfU0VMRUNUT1I7XG5mdW5jdGlvbiBURVhUX0NTU19TRUxFQ1RPUigpIHtcbiAgICBpZiAoIV9URVhUX0NTU19TRUxFQ1RPUikge1xuICAgICAgICBfVEVYVF9DU1NfU0VMRUNUT1IgPSBDc3NTZWxlY3Rvci5wYXJzZSgnKicpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gX1RFWFRfQ1NTX1NFTEVDVE9SO1xufVxudmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVtcGxhdGVQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VFcnJvcihtZXNzYWdlLCBzcGFuLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIHVzZWRQaXBlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbn0oKSk7XG52YXIgVGVtcGxhdGVQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2NvbmZpZywgX3JlZmxlY3RvciwgX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLCBcImV4cHJlc3Npb25QYXJzZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCwgcHJlc2VydmVXaGl0ZXNwYWNlcyk7XG4gICAgICAgIHZhciB3YXJuaW5ncyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KTtcbiAgICAgICAgdmFyIGVycm9ycyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfSk7XG4gICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJUZW1wbGF0ZSBwYXJzZSB3YXJuaW5nczpcXG5cIiArIHdhcm5pbmdzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdGVtcGxhdGU6IHJlc3VsdC50ZW1wbGF0ZUFzdCwgcGlwZXM6IHJlc3VsdC51c2VkUGlwZXMgfTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwsIHByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgdmFyIGh0bWxQYXJzZVJlc3VsdCA9IHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIHtcbiAgICAgICAgICAgICAgICB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWc6IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyhjb21wb25lbnQpXG4gICAgICAgICAgICB9KSA6XG4gICAgICAgICAgICB0ZW1wbGF0ZTtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2VzKSB7XG4gICAgICAgICAgICBodG1sUGFyc2VSZXN1bHQgPSByZW1vdmVXaGl0ZXNwYWNlcyhodG1sUGFyc2VSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyeVBhcnNlSHRtbCh0aGlzLmV4cGFuZEh0bWwoaHRtbFBhcnNlUmVzdWx0KSwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2VIdG1sID0gZnVuY3Rpb24gKGh0bWxBc3RXaXRoRXJyb3JzLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgIHZhciB1c2VkUGlwZXMgPSBbXTtcbiAgICAgICAgaWYgKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdW5pcURpcmVjdGl2ZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZhciB1bmlxUGlwZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhwaXBlcyk7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXJWaWV3Q29udGV4dCA9IG5ldyBQcm92aWRlclZpZXdDb250ZXh0KHRoaXMuX3JlZmxlY3RvciwgY29tcG9uZW50KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQ29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZSAmJiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvblsxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmluZGluZ1BhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKHRoaXMuX2V4cHJQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCB1bmlxUGlwZXMsIGVycm9ycyk7XG4gICAgICAgICAgICB2YXIgcGFyc2VWaXNpdG9yID0gbmV3IFRlbXBsYXRlUGFyc2VWaXNpdG9yKHRoaXMuX3JlZmxlY3RvciwgdGhpcy5fY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgYmluZGluZ1BhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHNjaGVtYXMsIGVycm9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSB2aXNpdEFsbCQxKHBhcnNlVmlzaXRvciwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChwcm92aWRlclZpZXdDb250ZXh0LmVycm9ycykpO1xuICAgICAgICAgICAgdXNlZFBpcGVzLnB1c2guYXBwbHkodXNlZFBpcGVzLCBfX3NwcmVhZChiaW5kaW5nUGFyc2VyLmdldFVzZWRQaXBlcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZShyZXN1bHQsIGVycm9ycyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgdXNlZFBpcGVzLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybXMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIHVzZWRQaXBlcywgZXJyb3JzKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5leHBhbmRIdG1sID0gZnVuY3Rpb24gKGh0bWxBc3RXaXRoRXJyb3JzLCBmb3JjZWQpIHtcbiAgICAgICAgaWYgKGZvcmNlZCA9PT0gdm9pZCAwKSB7IGZvcmNlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09IDAgfHwgZm9yY2VkKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSUNVIG1lc3NhZ2VzIHRvIGFuZ3VsYXIgZGlyZWN0aXZlc1xuICAgICAgICAgICAgdmFyIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF9fc3ByZWFkKGV4cGFuZGVkSHRtbEFzdC5lcnJvcnMpKTtcbiAgICAgICAgICAgIGh0bWxBc3RXaXRoRXJyb3JzID0gbmV3IFBhcnNlVHJlZVJlc3VsdChleHBhbmRlZEh0bWxBc3Qubm9kZXMsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWxBc3RXaXRoRXJyb3JzO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmdldEludGVycG9sYXRpb25Db25maWcgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlID0gZnVuY3Rpb24gKHJlc3VsdCwgZXJyb3JzKSB7XG4gICAgICAgIHZhciBleGlzdGluZ1JlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISFlbGVtZW50LnJlZmVyZW5jZXM7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSByZWZlcmVuY2UubmFtZTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1JlZmVyZW5jZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1JlZmVyZW5jZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IoXCJSZWZlcmVuY2UgXFxcIiNcIiArIG5hbWUgKyBcIlxcXCIgaXMgZGVmaW5lZCBzZXZlcmFsIHRpbWVzXCIsIHJlZmVyZW5jZS5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xufSgpKTtcbnZhciBUZW1wbGF0ZVBhcnNlVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlVmlzaXRvcihyZWZsZWN0b3IsIGNvbmZpZywgcHJvdmlkZXJWaWV3Q29udGV4dCwgZGlyZWN0aXZlcywgX2JpbmRpbmdQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX3NjaGVtYXMsIF90YXJnZXRFcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQgPSBwcm92aWRlclZpZXdDb250ZXh0O1xuICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyID0gX2JpbmRpbmdQYXJzZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9zY2hlbWFzID0gX3NjaGVtYXM7XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRDb3VudCA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHF1ZXJpZXMgc3RhcnQgd2l0aCBpZCAxIHNvIHdlIGNhbiB1c2UgdGhlIG51bWJlciBpbiBhIEJsb29tIGZpbHRlciFcbiAgICAgICAgdGhpcy5jb250ZW50UXVlcnlTdGFydElkID0gcHJvdmlkZXJWaWV3Q29udGV4dC5jb21wb25lbnQudmlld1F1ZXJpZXMubGVuZ3RoICsgMTtcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBDc3NTZWxlY3Rvci5wYXJzZShkaXJlY3RpdmUuc2VsZWN0b3IpO1xuICAgICAgICAgICAgX3RoaXMuc2VsZWN0b3JNYXRjaGVyLmFkZFNlbGVjdGFibGVzKHNlbGVjdG9yLCBkaXJlY3RpdmUpO1xuICAgICAgICAgICAgX3RoaXMuZGlyZWN0aXZlc0luZGV4LnNldChkaXJlY3RpdmUsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKCkpO1xuICAgICAgICB2YXIgdmFsdWVOb05nc3AgPSByZXBsYWNlTmdzcCh0ZXh0LnZhbHVlKTtcbiAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZU5vTmdzcCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIGV4cHIgPyBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pIDpcbiAgICAgICAgICAgIG5ldyBUZXh0QXN0KHZhbHVlTm9OZ3NwLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgIHZhciBlbE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgfHxcbiAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgIC8vIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUICYmXG4gICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgc3R5bGVzaGVldHMgd2l0aCBlaXRoZXIgcmVsYXRpdmUgdXJscyBvciBwYWNrYWdlIHNjaGVtZSBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICAgICAgLy8gdGhlbSBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoYWJsZUF0dHJzID0gW107XG4gICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgZWxlbWVudE9yRGlyZWN0aXZlUmVmcyA9IFtdO1xuICAgICAgICB2YXIgZWxlbWVudFZhcnMgPSBbXTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgdGVtcGxhdGVNYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgaGFzSW5saW5lVGVtcGxhdGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBhdHRycyA9IFtdO1xuICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc05nVGVtcGxhdGUoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgZWxlbWVudC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkVmFyaWFibGVzID0gW107XG4gICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIG1hdGNoYWJsZUF0dHJzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZXZlbnRzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50VmFycyk7XG4gICAgICAgICAgICBlbGVtZW50VmFycy5wdXNoLmFwcGx5KGVsZW1lbnRWYXJzLCBfX3NwcmVhZChwYXJzZWRWYXJpYWJsZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBWYXJpYWJsZUFzdC5mcm9tUGFyc2VkVmFyaWFibGUodik7IH0pKSk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVWYWx1ZTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUtleTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IF90aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZE5hbWUuc3RhcnRzV2l0aChURU1QTEFURV9BVFRSX1BSRUZJWCQxKSkge1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5ID0gbm9ybWFsaXplZE5hbWUuc3Vic3RyaW5nKFRFTVBMQVRFX0FUVFJfUFJFRklYJDEubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNUZW1wbGF0ZUJpbmRpbmcgPSB0ZW1wbGF0ZVZhbHVlICE9IG51bGw7XG4gICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJDYW4ndCBoYXZlIG11bHRpcGxlIHRlbXBsYXRlIGJpbmRpbmdzIG9uIG9uZSBlbGVtZW50LiBVc2Ugb25seSBvbmUgYXR0cmlidXRlIHByZWZpeGVkIHdpdGggKlwiLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNJbmxpbmVUZW1wbGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRWYXJpYWJsZXNfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IChhdHRyLnZhbHVlU3BhbiB8fCBhdHRyLnNvdXJjZVNwYW4pLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdGVtcGxhdGVNYXRjaGFibGVBdHRycywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgcGFyc2VkVmFyaWFibGVzXzEpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudFZhcnMucHVzaC5hcHBseSh0ZW1wbGF0ZUVsZW1lbnRWYXJzLCBfX3NwcmVhZChwYXJzZWRWYXJpYWJsZXNfMS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFZhcmlhYmxlQXN0LmZyb21QYXJzZWRWYXJpYWJsZSh2KTsgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSB0aGUgYmluZGluZ3MgYXMgYXR0cmlidXRlcyBhcyB3ZWxsIGluIHRoZSBBU1RcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKF90aGlzLnZpc2l0QXR0cmlidXRlKGF0dHIsIG51bGwpKTtcbiAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbGVtZW50Q3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoZWxOYW1lLCBtYXRjaGFibGVBdHRycyk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSwgZGlyZWN0aXZlTWV0YXMgPSBfYS5kaXJlY3RpdmVzLCBtYXRjaEVsZW1lbnQgPSBfYS5tYXRjaEVsZW1lbnQ7XG4gICAgICAgIHZhciByZWZlcmVuY2VzID0gW107XG4gICAgICAgIHZhciBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50Lm5hbWUsIGRpcmVjdGl2ZU1ldGFzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudC5zb3VyY2VTcGFuLCByZWZlcmVuY2VzLCBib3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgdmFyIGlzVmlld1Jvb3QgPSBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQgfHwgaGFzSW5saW5lVGVtcGxhdGVzO1xuICAgICAgICB2YXIgcHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBpc1ZpZXdSb290LCBkaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmZXJlbmNlcywgaXNUZW1wbGF0ZUVsZW1lbnQsIHF1ZXJ5U3RhcnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdmlzaXRBbGwkMShwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IgOiB0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBFbGVtZW50Q29udGV4dC5jcmVhdGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZUFzdHMsIGlzVGVtcGxhdGVFbGVtZW50ID8gcGFyZW50LnByb3ZpZGVyQ29udGV4dCA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICBwcm92aWRlckNvbnRleHQuYWZ0ZXJFbGVtZW50KCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgc2VsZWN0b3Igd2hlbiB0aGUgYG5nUHJvamVjdEFzYCBhdHRyaWJ1dGUgaXMgcHJvdmlkZWRcbiAgICAgICAgdmFyIHByb2plY3Rpb25TZWxlY3RvciA9IHByZXBhcnNlZEVsZW1lbnQucHJvamVjdEFzICE9ICcnID9cbiAgICAgICAgICAgIENzc1NlbGVjdG9yLnBhcnNlKHByZXBhcnNlZEVsZW1lbnQucHJvamVjdEFzKVswXSA6XG4gICAgICAgICAgICBlbGVtZW50Q3NzU2VsZWN0b3I7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgdmFyIHBhcnNlZEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgIC8vIGA8bmctY29udGVudD5gIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCI8bmctY29udGVudD4gZWxlbWVudCBjYW5ub3QgaGF2ZSBjb250ZW50LlwiLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMoZGlyZWN0aXZlQXN0cywgZXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUoZGlyZWN0aXZlQXN0cywgZWxlbWVudFByb3BzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBldmVudHMsIHJlZmVyZW5jZXMsIGVsZW1lbnRWYXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBwcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBvdGhlciB0aGFuIGA8bmctY29udGVudD5gIGFuZCBgPG5nLXRlbXBsYXRlPmBcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEVsZW1lbnRFeGlzdHMobWF0Y2hFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQoZGlyZWN0aXZlQXN0cywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleF8xID0gaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRWxlbWVudEFzdChlbE5hbWUsIGF0dHJzLCBlbGVtZW50UHJvcHMsIGV2ZW50cywgcmVmZXJlbmNlcywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgcHJvdmlkZXJDb250ZXh0LnF1ZXJ5TWF0Y2hlcywgY2hpbGRyZW4sIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleF8xLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhcyBhICotYXR0cmlidXRlXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVRdWVyeVN0YXJ0SW5kZXggPSB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcignbmctdGVtcGxhdGUnLCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzKTtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCB0ZW1wbGF0ZVNlbGVjdG9yKS5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyh0cnVlLCBlbE5hbWUsIGRpcmVjdGl2ZXMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCBlbGVtZW50LnNvdXJjZVNwYW4sIFtdLCB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRQcm9wcyA9IHRoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMoZWxOYW1lLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCB0ZW1wbGF0ZUJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUodGVtcGxhdGVEaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZUVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50LCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIFtdLCBbXSwgdHJ1ZSwgdGVtcGxhdGVRdWVyeVN0YXJ0SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgW10sIFtdLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIFtwYXJzZWRFbGVtZW50XSwgbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZEVsZW1lbnQ7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXR0ciA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgYXR0ciwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRFdmVudHMsIHRhcmdldFJlZnMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgIHZhciBzcmNTcGFuID0gYXR0ci5zb3VyY2VTcGFuO1xuICAgICAgICB2YXIgYWJzb2x1dGVPZmZzZXQgPSBhdHRyLnZhbHVlU3BhbiA/IGF0dHIudmFsdWVTcGFuLnN0YXJ0Lm9mZnNldCA6IHNyY1NwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgYm91bmRFdmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgIHZhciBoYXNCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChiaW5kUGFydHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFZhcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwibGV0LVxcXCIgaXMgb25seSBzdXBwb3J0ZWQgb24gbmctdGVtcGxhdGUgZWxlbWVudHMuXCIsIHNyY1NwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19SRUZfSURYXSkge1xuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX09OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyLnZhbHVlU3BhbiB8fCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0JJTkRPTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0ci52YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyLnZhbHVlU3BhbiB8fCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0FUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyLnZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyLnZhbHVlU3BhbiB8fCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyLnZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgYXR0ci52YWx1ZVNwYW4gfHwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGJvdW5kRXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhdHRyLnZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHIudmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoLmFwcGx5KHRhcmdldEV2ZW50cywgX19zcHJlYWQoYm91bmRFdmVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBCb3VuZEV2ZW50QXN0LmZyb21QYXJzZWRFdmVudChlKTsgfSkpKTtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmRpbmc7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIC9eZGF0YS0vaS50ZXN0KGF0dHJOYW1lKSA/IGF0dHJOYW1lLnN1YnN0cmluZyg1KSA6IGF0dHJOYW1lO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiB2YXJpYWJsZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZGVudGlmaWVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJWYXJpYWJsZSBkb2VzIG5vdCBoYXZlIGEgbmFtZVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRSZWZzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiByZWZlcmVuY2UgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiUmVmZXJlbmNlIGRvZXMgbm90IGhhdmUgYSBuYW1lXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFJlZnMucHVzaChuZXcgRWxlbWVudE9yRGlyZWN0aXZlUmVmKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VEaXJlY3RpdmVzID0gZnVuY3Rpb24gKHNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5lZWQgdG8gc29ydCB0aGUgZGlyZWN0aXZlcyBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgdGhyb3VnaG91dCxcbiAgICAgICAgLy8gYXMgc2VsZWN0b3JNYXRjaGVyIHVzZXMgTWFwcyBpbnNpZGUuXG4gICAgICAgIC8vIEFsc28gZGVkdXBsaWNhdGUgZGlyZWN0aXZlcyBhcyB0aGV5IG1pZ2h0IG1hdGNoIG1vcmUgdGhhbiBvbmUgdGltZSFcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBuZXdBcnJheSh0aGlzLmRpcmVjdGl2ZXNJbmRleC5zaXplKTtcbiAgICAgICAgLy8gV2hldGhlciBhbnkgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgb24gdGhlIGVsZW1lbnQgbmFtZVxuICAgICAgICB2YXIgbWF0Y2hFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHNlbGVjdG9yTWF0Y2hlci5tYXRjaChlbGVtZW50Q3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzW190aGlzLmRpcmVjdGl2ZXNJbmRleC5nZXQoZGlyZWN0aXZlKV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICBtYXRjaEVsZW1lbnQgPSBtYXRjaEVsZW1lbnQgfHwgc2VsZWN0b3IuaGFzRWxlbWVudFNlbGVjdG9yKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gISFkaXI7IH0pLFxuICAgICAgICAgICAgbWF0Y2hFbGVtZW50OiBtYXRjaEVsZW1lbnQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnROYW1lLCBkaXJlY3RpdmVzLCBwcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFNvdXJjZVNwYW4sIHRhcmdldFJlZmVyZW5jZXMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtYXRjaGVkUmVmZXJlbmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHZhciBkaXJlY3RpdmVBc3RzID0gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKGVsZW1lbnRTb3VyY2VTcGFuLnN0YXJ0LCBlbGVtZW50U291cmNlU3Bhbi5lbmQsIFwiRGlyZWN0aXZlIFwiICsgaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLnR5cGUpKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGJvdW5kUHJvcGVydGllcyA9IF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMoZGlyZWN0aXZlLCBlbGVtZW50TmFtZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSBib3VuZFByb3BlcnRpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5mcm9tQm91bmRQcm9wZXJ0eShwcm9wKTsgfSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNoZWNrIHRoZSBob3N0IHByb3BlcnRpZXMgaGVyZSBhcyB3ZWxsLFxuICAgICAgICAgICAgLy8gYXMgd2UgZG9uJ3Qga25vdyB0aGUgZWxlbWVudCBuYW1lIGluIHRoZSBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgeWV0LlxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXMgPSBfdGhpcy5fY2hlY2tQcm9wZXJ0aWVzSW5TY2hlbWEoZWxlbWVudE5hbWUsIGhvc3RQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRFdmVudHMgPSBfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzKGRpcmVjdGl2ZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlUHJvcGVydHlBc3RzKGRpcmVjdGl2ZS5pbnB1dHMsIHByb3BzLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGVsT3JEaXJSZWYuaXNSZWZlcmVuY2VUb0RpcmVjdGl2ZShkaXJlY3RpdmUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIGNyZWF0ZVRva2VuRm9yUmVmZXJlbmNlKGRpcmVjdGl2ZS50eXBlLnJlZmVyZW5jZSksIGVsT3JEaXJSZWYudmFsdWUsIGVsT3JEaXJSZWYuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUmVmZXJlbmNlcy5hZGQoZWxPckRpclJlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBob3N0RXZlbnRzID0gcGFyc2VkRXZlbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gQm91bmRFdmVudEFzdC5mcm9tUGFyc2VkRXZlbnQoZSk7IH0pO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBfdGhpcy5jb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICAgICAgX3RoaXMuY29udGVudFF1ZXJ5U3RhcnRJZCArPSBkaXJlY3RpdmUucXVlcmllcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERpcmVjdGl2ZUFzdChkaXJlY3RpdmUsIGRpcmVjdGl2ZVByb3BlcnRpZXMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBjb250ZW50UXVlcnlTdGFydElkLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgaWYgKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFJlZmVyZW5jZXMuaGFzKGVsT3JEaXJSZWYubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlcmUgaXMgbm8gZGlyZWN0aXZlIHdpdGggXFxcImV4cG9ydEFzXFxcIiBzZXQgdG8gXFxcIlwiICsgZWxPckRpclJlZi52YWx1ZSArIFwiXFxcIlwiLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWZUb2tlbiA9IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UoX3RoaXMucmVmbGVjdG9yLCBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgcmVmVG9rZW4sIGVsT3JEaXJSZWYudmFsdWUsIGVsT3JEaXJSZWYuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZUFzdHM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBib3VuZFByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lcykge1xuICAgICAgICBpZiAoZGlyZWN0aXZlUHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGJvdW5kUHJvcHNCeU5hbWVfMS5nZXQoYm91bmRQcm9wLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcHJldlZhbHVlIHx8IHByZXZWYWx1ZS5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSBbYV09XCJiXCIgYSBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIGE9XCJiXCIgb24gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBib3VuZFByb3BzQnlOYW1lXzEuc2V0KGJvdW5kUHJvcC5uYW1lLCBib3VuZFByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyZWN0aXZlUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoZGlyUHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbFByb3AgPSBkaXJlY3RpdmVQcm9wZXJ0aWVzW2RpclByb3BdO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzLmFkZChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLnB1c2gobmV3IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyUHJvcCwgYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBib3VuZFByb3Auc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcHMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZEVsZW1lbnRQcm9wcyA9IFtdO1xuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXByb3AuaXNMaXRlcmFsICYmICFib3VuZERpcmVjdGl2ZVByb3BOYW1lcy5oYXMocHJvcC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZFByb3AgPSBfdGhpcy5fYmluZGluZ1BhcnNlci5jcmVhdGVCb3VuZEVsZW1lbnRQcm9wZXJ0eShlbGVtZW50TmFtZSwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYm91bmRFbGVtZW50UHJvcHMucHVzaChCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5mcm9tQm91bmRQcm9wZXJ0eShib3VuZFByb3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYShlbGVtZW50TmFtZSwgYm91bmRFbGVtZW50UHJvcHMpO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGlkZW50aWZpZXJOYW1lKGRpcmVjdGl2ZS5kaXJlY3RpdmUudHlwZSk7IH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50ID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIk1vcmUgdGhhbiBvbmUgY29tcG9uZW50IG1hdGNoZWQgb24gdGhpcyBlbGVtZW50LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0aGF0IG9ubHkgb25lIGNvbXBvbmVudCdzIHNlbGVjdG9yIGNhbiBtYXRjaCBhIGdpdmVuIGVsZW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIChcIkNvbmZsaWN0aW5nIGNvbXBvbmVudHM6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSksIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCBub24tYW5ndWxhciB0YWdzIGNvbmZvcm0gdG8gdGhlIHNjaGVtYXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgYW4gYW5ndWxhciB0YWcgd2hlbiBhdCBsZWFzdCBvbmUgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgdGhlXG4gICAgICogdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWF0Y2hFbGVtZW50IFdoZXRoZXIgYW55IGRpcmVjdGl2ZSBoYXMgbWF0Y2hlZCBvbiB0aGUgdGFnIG5hbWVcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgaHRtbCBlbGVtZW50XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRFbGVtZW50RXhpc3RzID0gZnVuY3Rpb24gKG1hdGNoRWxlbWVudCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgZWxOYW1lID0gZWxlbWVudC5uYW1lLnJlcGxhY2UoL146eGh0bWw6LywgJycpO1xuICAgICAgICBpZiAoIW1hdGNoRWxlbWVudCAmJiAhdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzRWxlbWVudChlbE5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JNc2cgPSBcIidcIiArIGVsTmFtZSArIFwiJyBpcyBub3QgYSBrbm93biBlbGVtZW50OlxcblwiO1xuICAgICAgICAgICAgZXJyb3JNc2cgKz0gXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIjtcbiAgICAgICAgICAgIGlmIChlbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1zZyArPSBcIjIuIElmICdcIiArIGVsTmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgJ0NVU1RPTV9FTEVNRU5UU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgIFwiMi4gVG8gYWxsb3cgYW55IGVsZW1lbnQgYWRkICdOT19FUlJPUlNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZWxlbWVudFByb3BzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJDb21wb25lbnRzIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJyksIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJQcm9wZXJ0eSBiaW5kaW5nIFwiICsgcHJvcC5uYW1lICsgXCIgbm90IHVzZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnR5IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZXZlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbGxEaXJlY3RpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmUuZGlyZWN0aXZlLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZGlyZWN0aXZlLmRpcmVjdGl2ZS5vdXRwdXRzW2tdO1xuICAgICAgICAgICAgICAgIGFsbERpcmVjdGl2ZUV2ZW50cy5hZGQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9IG51bGwgfHwgIWFsbERpcmVjdGl2ZUV2ZW50cy5oYXMoZXZlbnQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJFdmVudCBiaW5kaW5nIFwiICsgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgZXZlbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgYm91bmRQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBjYW4ndCBmaWx0ZXIgb3V0IGVtcHR5IGV4cHJlc3Npb25zIGJlZm9yZSB0aGlzIG1ldGhvZCxcbiAgICAgICAgLy8gYXMgd2Ugc3RpbGwgd2FudCB0byB2YWxpZGF0ZSB0aGVtIVxuICAgICAgICByZXR1cm4gYm91bmRQcm9wcy5maWx0ZXIoZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgaWYgKGJvdW5kUHJvcC50eXBlID09PSAwIC8qIFByb3BlcnR5ICovICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNQcm9wZXJ0eShlbGVtZW50TmFtZSwgYm91bmRQcm9wLm5hbWUsIF90aGlzLl9zY2hlbWFzKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5zdGFydHNXaXRoKCduZy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4xLiBJZiAnXCIgKyBib3VuZFByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGRpcmVjdGl2ZSwgdGhlbiBhZGQgJ0NvbW1vbk1vZHVsZScgdG8gdGhlICdATmdNb2R1bGUuaW1wb3J0cycgb2YgdGhpcyBjb21wb25lbnQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMi4gVG8gYWxsb3cgYW55IHByb3BlcnR5IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjEuIElmICdcIiArIGVsZW1lbnROYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgY29tcG9uZW50IGFuZCBpdCBoYXMgJ1wiICsgYm91bmRQcm9wLm5hbWUgKyBcIicgaW5wdXQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkICdDVVNUT01fRUxFTUVOVFNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjMuIFRvIGFsbG93IGFueSBwcm9wZXJ0eSBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGJvdW5kUHJvcC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVZpc2l0b3I7XG59KCkpO1xudmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIFthdHRyLm5hbWUsIGF0dHIudmFsdWVdOyB9KTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGFzdC5uYW1lLCBhdHRyTmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCQxKHRoaXMsIGFzdC5jaGlsZHJlbiwgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50QXN0KGFzdC5uYW1lLCB2aXNpdEFsbCQxKHRoaXMsIGFzdC5hdHRycyksIFtdLCBbXSwgW10sIFtdLCBbXSwgZmFsc2UsIFtdLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuLCBhc3QuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKCkpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRBc3QodGV4dC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwYW5zaW9uO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwYW5zaW9uQ2FzZTtcbiAgICB9O1xuICAgIHJldHVybiBOb25CaW5kYWJsZVZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBBIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50IG9yIGRpcmVjdGl2ZSBpbiBhIHRlbXBsYXRlLiBFLmcuLCB0aGUgcmVmZXJlbmNlIGluIHRoaXMgdGVtcGxhdGU6XG4gKlxuICogPGRpdiAjbXlNZW51PVwiY29vbE1lbnVcIj5cbiAqXG4gKiB3b3VsZCBiZSB7bmFtZTogJ215TWVudScsIHZhbHVlOiAnY29vbE1lbnUnLCBzb3VyY2VTcGFuOiAuLi59XG4gKi9cbnZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudE9yRGlyZWN0aXZlUmVmKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqIEdldHMgd2hldGhlciB0aGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkaXJlY3RpdmUuICovXG4gICAgRWxlbWVudE9yRGlyZWN0aXZlUmVmLnByb3RvdHlwZS5pc1JlZmVyZW5jZVRvRGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICByZXR1cm4gc3BsaXRFeHBvcnRBcyhkaXJlY3RpdmUuZXhwb3J0QXMpLmluZGV4T2YodGhpcy52YWx1ZSkgIT09IC0xO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRPckRpcmVjdGl2ZVJlZjtcbn0oKSk7XG4vKiogU3BsaXRzIGEgcmF3LCBwb3RlbnRpYWxseSBjb21tYS1kZWxpbWl0ZWQgYGV4cG9ydEFzYCB2YWx1ZSBpbnRvIGFuIGFycmF5IG9mIG5hbWVzLiAqL1xuZnVuY3Rpb24gc3BsaXRFeHBvcnRBcyhleHBvcnRBcykge1xuICAgIHJldHVybiBleHBvcnRBcyA/IGV4cG9ydEFzLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRyaW0oKTsgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2xhc3NlcyhjbGFzc0F0dHJWYWx1ZSkge1xuICAgIHJldHVybiBjbGFzc0F0dHJWYWx1ZS50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG52YXIgRWxlbWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIF9uZ0NvbnRlbnRJbmRleE1hdGNoZXIsIF93aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBfbmdDb250ZW50SW5kZXhNYXRjaGVyO1xuICAgICAgICB0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ID0gX3dpbGRjYXJkTmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDb250ZXh0ID0gcHJvdmlkZXJDb250ZXh0O1xuICAgIH1cbiAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgdmFyIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gY29tcG9uZW50LmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IG5nQ29udGVudFNlbGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIG1hdGNoZXIsIHdpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCk7XG4gICAgfTtcbiAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBuZ0NvbnRlbnRJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkge1xuICAgICAgICAgICAgbmdDb250ZW50SW5kaWNlcy5wdXNoKG5nQ29udGVudEluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5nQ29udGVudEluZGljZXMuc29ydCgpO1xuICAgICAgICBpZiAodGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRDb250ZXh0O1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgIHZhciBlbE5hbWVOb05zID0gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpWzFdO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxOYW1lTm9Ocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJpYnV0ZXNbaV1bMF07XG4gICAgICAgIHZhciBhdHRyTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShhdHRyTmFtZSlbMV07XG4gICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2ldWzFdO1xuICAgICAgICBjc3NTZWxlY3Rvci5hZGRBdHRyaWJ1dGUoYXR0ck5hbWVOb05zLCBhdHRyVmFsdWUpO1xuICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PSBDTEFTU19BVFRSKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHsgcmV0dXJuIGNzc1NlbGVjdG9yLmFkZENsYXNzTmFtZShjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3NzU2VsZWN0b3I7XG59XG52YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBTZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCwgbnVsbCk7XG52YXIgTk9OX0JJTkRBQkxFX1ZJU0lUT1IgPSBuZXcgTm9uQmluZGFibGVWaXNpdG9yKCk7XG5mdW5jdGlvbiBfaXNFbXB0eVRleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQkMyAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKGl0ZW1zKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghbWFwLmdldChpdGVtLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgbWFwLnNldChpdGVtLnR5cGUucmVmZXJlbmNlLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiBpc0VtcHR5RXhwcmVzc2lvbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgQVNUV2l0aFNvdXJjZSkge1xuICAgICAgICBhc3QgPSBhc3QuYXN0O1xuICAgIH1cbiAgICByZXR1cm4gYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFBhcnNlcyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzdHlsZSBhbmQgY29udmVydHMgaXQgaW50byBvYmplY3QgbGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHN0eWxlIGFzIHVzZWQgaW4gdGhlIGBzdHlsZWAgYXR0cmlidXRlIGluIEhUTUwuXG4gKiAgIEV4YW1wbGU6IGBjb2xvcjogcmVkOyBoZWlnaHQ6IGF1dG9gLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc3R5bGUgcHJvcGVydHkgbmFtZSBhbmQgdmFsdWUgcGFpcnMsIGUuZy4gYFsnY29sb3InLCAncmVkJywgJ2hlaWdodCcsXG4gKiAnYXV0byddYFxuICovXG5mdW5jdGlvbiBwYXJzZSh2YWx1ZSkge1xuICAgIC8vIHdlIHVzZSBhIHN0cmluZyBhcnJheSBoZXJlIGluc3RlYWQgb2YgYSBzdHJpbmcgbWFwXG4gICAgLy8gYmVjYXVzZSBhIHN0cmluZy1tYXAgaXMgbm90IGd1YXJhbnRlZWQgdG8gcmV0YWluIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSBlbnRyaWVzIHdoZXJlYXMgYSBzdHJpbmcgYXJyYXkgY2FuIGJlXG4gICAgLy8gY29uc3RydWN0ZWQgaW4gYSBba2V5LCB2YWx1ZSwga2V5LCB2YWx1ZV0gZm9ybWF0LlxuICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhcmVuRGVwdGggPSAwO1xuICAgIHZhciBxdW90ZSA9IDAgLyogUXVvdGVOb25lICovO1xuICAgIHZhciB2YWx1ZVN0YXJ0ID0gMDtcbiAgICB2YXIgcHJvcFN0YXJ0ID0gMDtcbiAgICB2YXIgY3VycmVudFByb3AgPSBudWxsO1xuICAgIHZhciB2YWx1ZUhhc1F1b3RlcyA9IGZhbHNlO1xuICAgIHdoaWxlIChpIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSA0MCAvKiBPcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MSAvKiBDbG9zZVBhcmVuICovOlxuICAgICAgICAgICAgICAgIHBhcmVuRGVwdGgtLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzkgLyogUXVvdGVTaW5nbGUgKi86XG4gICAgICAgICAgICAgICAgLy8gdmFsdWVTdGFydCBuZWVkcyB0byBiZSB0aGVyZSBzaW5jZSBwcm9wIHZhbHVlcyBkb24ndFxuICAgICAgICAgICAgICAgIC8vIGhhdmUgcXVvdGVzIGluIENTU1xuICAgICAgICAgICAgICAgIHZhbHVlSGFzUXVvdGVzID0gdmFsdWVIYXNRdW90ZXMgfHwgdmFsdWVTdGFydCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlID09PSAwIC8qIFF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDM5IC8qIFF1b3RlU2luZ2xlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChxdW90ZSA9PT0gMzkgLyogUXVvdGVTaW5nbGUgKi8gJiYgdmFsdWUuY2hhckNvZGVBdChpIC0gMSkgIT09IDkyIC8qIEJhY2tTbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDAgLyogUXVvdGVOb25lICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzQgLyogUXVvdGVEb3VibGUgKi86XG4gICAgICAgICAgICAgICAgLy8gc2FtZSBsb2dpYyBhcyBhYm92ZVxuICAgICAgICAgICAgICAgIHZhbHVlSGFzUXVvdGVzID0gdmFsdWVIYXNRdW90ZXMgfHwgdmFsdWVTdGFydCA+IDA7XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlID09PSAwIC8qIFF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDM0IC8qIFF1b3RlRG91YmxlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChxdW90ZSA9PT0gMzQgLyogUXVvdGVEb3VibGUgKi8gJiYgdmFsdWUuY2hhckNvZGVBdChpIC0gMSkgIT09IDkyIC8qIEJhY2tTbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDAgLyogUXVvdGVOb25lICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTggLyogQ29sb24gKi86XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvcCAmJiBwYXJlbkRlcHRoID09PSAwICYmIHF1b3RlID09PSAwIC8qIFF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IGh5cGhlbmF0ZSh2YWx1ZS5zdWJzdHJpbmcocHJvcFN0YXJ0LCBpIC0gMSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OSAvKiBTZW1pY29sb24gKi86XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9wICYmIHZhbHVlU3RhcnQgPiAwICYmIHBhcmVuRGVwdGggPT09IDAgJiYgcXVvdGUgPT09IDAgLyogUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVZhbCA9IHZhbHVlLnN1YnN0cmluZyh2YWx1ZVN0YXJ0LCBpIC0gMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChjdXJyZW50UHJvcCwgdmFsdWVIYXNRdW90ZXMgPyBzdHJpcFVubmVjZXNzYXJ5UXVvdGVzKHN0eWxlVmFsKSA6IHN0eWxlVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQcm9wICYmIHZhbHVlU3RhcnQpIHtcbiAgICAgICAgdmFyIHN0eWxlVmFsID0gdmFsdWUuc3Vic3RyKHZhbHVlU3RhcnQpLnRyaW0oKTtcbiAgICAgICAgc3R5bGVzLnB1c2goY3VycmVudFByb3AsIHZhbHVlSGFzUXVvdGVzID8gc3RyaXBVbm5lY2Vzc2FyeVF1b3RlcyhzdHlsZVZhbCkgOiBzdHlsZVZhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG59XG5mdW5jdGlvbiBzdHJpcFVubmVjZXNzYXJ5UXVvdGVzKHZhbHVlKSB7XG4gICAgdmFyIHFTID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgcUUgPSB2YWx1ZS5jaGFyQ29kZUF0KHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIGlmIChxUyA9PSBxRSAmJiAocVMgPT0gMzkgLyogUXVvdGVTaW5nbGUgKi8gfHwgcVMgPT0gMzQgLyogUXVvdGVEb3VibGUgKi8pKSB7XG4gICAgICAgIHZhciB0ZW1wVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB1c2luZyBhIG11bHRpLXF1b3RlZCBzdHJpbmcgdGhhdCB3YXMganVzdCBjaG9tcGVkXG4gICAgICAgIC8vIChlLmcuIGBmb250LWZhbWlseTogXCJWZXJkYW5hXCIsIFwic2Fucy1zZXJpZlwiYClcbiAgICAgICAgaWYgKHRlbXBWYWx1ZS5pbmRleE9mKCdcXCcnKSA9PSAtMSAmJiB0ZW1wVmFsdWUuaW5kZXhPZignXCInKSA9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaHlwaGVuYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC9bYS16XVtBLVpdL2csIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJBdCgwKSArICctJyArIHYuY2hhckF0KDEpO1xuICAgIH0pXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG52YXIgSU1QT1JUQU5UX0ZMQUcgPSAnIWltcG9ydGFudCc7XG4vKipcbiAqIE1pbmltdW0gYW1vdW50IG9mIGJpbmRpbmcgc2xvdHMgcmVxdWlyZWQgaW4gdGhlIHJ1bnRpbWUgZm9yIHN0eWxlL2NsYXNzIGJpbmRpbmdzLlxuICpcbiAqIFN0eWxpbmcgaW4gQW5ndWxhciB1c2VzIHVwIHR3byBzbG90cyBpbiB0aGUgcnVudGltZSBMVmlldy9URGF0YSBkYXRhIHN0cnVjdHVyZXMgdG9cbiAqIHJlY29yZCBiaW5kaW5nIGRhdGEsIHByb3BlcnR5IGluZm9ybWF0aW9uIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBXaGVuIGEgYmluZGluZyBpcyByZWdpc3RlcmVkIGl0IHdpbGwgcGxhY2UgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYExWaWV3YDpcbiAqXG4gKiBzbG90IDEpIGJpbmRpbmcgdmFsdWVcbiAqIHNsb3QgMikgY2FjaGVkIHZhbHVlIChhbGwgb3RoZXIgdmFsdWVzIGNvbGxlY3RlZCBiZWZvcmUgaXQgaW4gc3RyaW5nIGZvcm0pXG4gKlxuICogV2hlbiBhIGJpbmRpbmcgaXMgcmVnaXN0ZXJlZCBpdCB3aWxsIHBsYWNlIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGBURGF0YWA6XG4gKlxuICogc2xvdCAxKSBwcm9wIG5hbWVcbiAqIHNsb3QgMikgYmluZGluZyBpbmRleCB0aGF0IHBvaW50cyB0byB0aGUgcHJldmlvdXMgc3R5bGUvY2xhc3MgYmluZGluZyAoYW5kIHNvbWUgZXh0cmEgY29uZmlnXG4gKiB2YWx1ZXMpXG4gKlxuICogTGV0J3MgaW1hZ2luZSB3ZSBoYXZlIGEgYmluZGluZyB0aGF0IGxvb2tzIGxpa2Ugc286XG4gKlxuICogYGBgXG4gKiA8ZGl2IFtzdHlsZS53aWR0aF09XCJ4XCIgW3N0eWxlLmhlaWdodF09XCJ5XCI+XG4gKiBgYGBcbiAqXG4gKiBPdXIgYExWaWV3YCBhbmQgYFREYXRhYCBkYXRhLXN0cnVjdHVyZXMgbG9vayBsaWtlIHNvOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIExWaWV3ID0gW1xuICogICAvLyAuLi5cbiAqICAgeCwgLy8gdmFsdWUgb2YgeFxuICogICBcIndpZHRoOiB4XCIsXG4gKlxuICogICB5LCAvLyB2YWx1ZSBvZiB5XG4gKiAgIFwid2lkdGg6IHg7IGhlaWdodDogeVwiLFxuICogICAvLyAuLi5cbiAqIF07XG4gKlxuICogVERhdGEgPSBbXG4gKiAgIC8vIC4uLlxuICogICBcIndpZHRoXCIsIC8vIGJpbmRpbmcgc2xvdCAyMFxuICogICAwLFxuICpcbiAqICAgXCJoZWlnaHRcIixcbiAqICAgMjAsXG4gKiAgIC8vIC4uLlxuICogXTtcbiAqIGBgYFxuICpcbiAqICovXG52YXIgTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRCA9IDI7XG4vKipcbiAqIFByb2R1Y2VzIGNyZWF0aW9uL3VwZGF0ZSBpbnN0cnVjdGlvbnMgZm9yIGFsbCBzdHlsaW5nIGJpbmRpbmdzIChjbGFzcyBhbmQgc3R5bGUpXG4gKlxuICogSXQgYWxzbyBwcm9kdWNlcyB0aGUgY3JlYXRpb24gaW5zdHJ1Y3Rpb24gdG8gcmVnaXN0ZXIgYWxsIGluaXRpYWwgc3R5bGluZyB2YWx1ZXNcbiAqICh3aGljaCBhcmUgYWxsIHRoZSBzdGF0aWMgY2xhc3M9XCIuLi5cIiBhbmQgc3R5bGU9XCIuLi5cIiBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgZXhpc3RcbiAqIG9uIGFuIGVsZW1lbnQgd2l0aGluIGEgdGVtcGxhdGUpLlxuICpcbiAqIFRoZSBidWlsZGVyIGNsYXNzIGJlbG93IGhhbmRsZXMgcHJvZHVjaW5nIGluc3RydWN0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAqXG4gKiAtIFN0YXRpYyBzdHlsZS9jbGFzcyBhdHRyaWJ1dGVzIChzdHlsZT1cIi4uLlwiIGFuZCBjbGFzcz1cIi4uLlwiKVxuICogLSBEeW5hbWljIHN0eWxlL2NsYXNzIG1hcCBiaW5kaW5ncyAoW3N0eWxlXT1cIm1hcFwiIGFuZCBbY2xhc3NdPVwibWFwfHN0cmluZ1wiKVxuICogLSBEeW5hbWljIHN0eWxlL2NsYXNzIHByb3BlcnR5IGJpbmRpbmdzIChbc3R5bGUucHJvcF09XCJleHBcIiBhbmQgW2NsYXNzLm5hbWVdPVwiZXhwXCIpXG4gKlxuICogRHVlIHRvIHRoZSBjb21wbGV4IHJlbGF0aW9uc2hpcCBvZiBhbGwgb2YgdGhlc2UgY2FzZXMsIHRoZSBpbnN0cnVjdGlvbnMgZ2VuZXJhdGVkXG4gKiBmb3IgdGhlc2UgYXR0cmlidXRlcy9wcm9wZXJ0aWVzL2JpbmRpbmdzIG11c3QgYmUgZG9uZSBzbyBpbiB0aGUgY29ycmVjdCBvcmRlci4gVGhlXG4gKiBvcmRlciB3aGljaCB0aGVzZSBtdXN0IGJlIGdlbmVyYXRlZCBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIGlmIChjcmVhdGVNb2RlKSB7XG4gKiAgIHN0eWxpbmcoLi4uKVxuICogfVxuICogaWYgKHVwZGF0ZU1vZGUpIHtcbiAqICAgc3R5bGVNYXAoLi4uKVxuICogICBjbGFzc01hcCguLi4pXG4gKiAgIHN0eWxlUHJvcCguLi4pXG4gKiAgIGNsYXNzUHJvcCguLi4pXG4gKiB9XG4gKlxuICogVGhlIGNyZWF0aW9uL3VwZGF0ZSBtZXRob2RzIHdpdGhpbiB0aGUgYnVpbGRlciBjbGFzcyBwcm9kdWNlIHRoZXNlIGluc3RydWN0aW9ucy5cbiAqL1xudmFyIFN0eWxpbmdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxpbmdCdWlsZGVyKF9kaXJlY3RpdmVFeHByKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUV4cHIgPSBfZGlyZWN0aXZlRXhwcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZXJlIGFyZSBhbnkgc3RhdGljIHN0eWxpbmcgdmFsdWVzIHByZXNlbnQgKi9cbiAgICAgICAgdGhpcy5faGFzSW5pdGlhbFZhbHVlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogIFdoZXRoZXIgb3Igbm90IHRoZXJlIGFyZSBhbnkgc3R5bGluZyBiaW5kaW5ncyBwcmVzZW50XG4gICAgICAgICAqICAoaS5lLiBgW3N0eWxlXWAsIGBbY2xhc3NdYCwgYFtzdHlsZS5wcm9wXWAgb3IgYFtjbGFzcy5uYW1lXWApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3NXaXRoUGlwZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqIHRoZSBpbnB1dCBmb3IgW2NsYXNzXSAoaWYgaXQgZXhpc3RzKSAqL1xuICAgICAgICB0aGlzLl9jbGFzc01hcElucHV0ID0gbnVsbDtcbiAgICAgICAgLyoqIHRoZSBpbnB1dCBmb3IgW3N0eWxlXSAoaWYgaXQgZXhpc3RzKSAqL1xuICAgICAgICB0aGlzLl9zdHlsZU1hcElucHV0ID0gbnVsbDtcbiAgICAgICAgLyoqIGFuIGFycmF5IG9mIGVhY2ggW3N0eWxlLnByb3BdIGlucHV0ICovXG4gICAgICAgIHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzID0gbnVsbDtcbiAgICAgICAgLyoqIGFuIGFycmF5IG9mIGVhY2ggW2NsYXNzLm5hbWVdIGlucHV0ICovXG4gICAgICAgIHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFN0eWxpbmdJbnB1dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gbnVsbDtcbiAgICAgICAgLy8gbWFwcyBhcmUgdXNlZCBpbnN0ZWFkIG9mIGhhc2ggbWFwcyBiZWNhdXNlIGEgTWFwIHdpbGxcbiAgICAgICAgLy8gcmV0YWluIHRoZSBvcmRlcmluZyBvZiB0aGUga2V5c1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgZWFjaCBzdHlsZSBiaW5kaW5nIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiAoZS5nLiBgPGRpdiBbc3R5bGUud2lkdGhdPVwid1wiIFtzdHlsZS5oZWlnaHRdPVwiaFwiPmAgaW1wbGllc1xuICAgICAgICAgKiB0aGF0IGB3aWR0aD0wYCBhbmQgYGhlaWdodD0xYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0eWxlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgZWFjaCBjbGFzcyBiaW5kaW5nIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgKiAoZS5nLiBgPGRpdiBbY2xhc3MuYmlnXT1cImJcIiBbY2xhc3MuaGlkZGVuXT1cImhcIj5gIGltcGxpZXNcbiAgICAgICAgICogdGhhdCBgYmlnPTBgIGFuZCBgaGlkZGVuPTFgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2xhc3Nlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzVmFsdWVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGdpdmVuIGlucHV0IHRvIHRoZSBzdHlsaW5nIGJ1aWxkZXIgdG8gYmUgbGF0ZXIgdXNlZCB3aGVuIHByb2R1Y2luZyBBT1QgY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBjb2RlIGJlbG93IHdpbGwgb25seSBhY2NlcHQgdGhlIGlucHV0IGlmIGl0IGlzIHNvbWVob3cgdGllZCB0byBzdHlsaW5nICh3aGV0aGVyIGl0IGJlXG4gICAgICogc3R5bGUvY2xhc3MgYmluZGluZ3Mgb3Igc3RhdGljIHN0eWxlL2NsYXNzIGF0dHJpYnV0ZXMpLlxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5yZWdpc3RlckJvdW5kSW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgLy8gW2F0dHIuc3R5bGVdIG9yIFthdHRyLmNsYXNzXSBhcmUgc2tpcHBlZCBpbiB0aGUgY29kZSBiZWxvdyxcbiAgICAgICAgLy8gdGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgc3R5bGluZy1iYXNlZCBiaW5kaW5ncyBzaW5jZVxuICAgICAgICAvLyB0aGV5IGFyZSBpbnRlbmRlZCB0byBiZSB3cml0dGVuIGRpcmVjdGx5IHRvIHRoZSBhdHRyIGFuZFxuICAgICAgICAvLyB3aWxsIHRoZXJlZm9yZSBza2lwIGFsbCBzdHlsZS9jbGFzcyByZXNvbHV0aW9uIHRoYXQgaXMgcHJlc2VudFxuICAgICAgICAvLyB3aXRoIHN0eWxlPVwiXCIsIFtzdHlsZV09XCJcIiBhbmQgW3N0eWxlLnByb3BdPVwiXCIsIGNsYXNzPVwiXCIsXG4gICAgICAgIC8vIFtjbGFzcy5wcm9wXT1cIlwiLiBbY2xhc3NdPVwiXCIgYXNzaWdubWVudHNcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIFByb3BlcnR5ICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogU3R5bGUgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJTdHlsZUlucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3BhbiwgaW5wdXQudW5pdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogQ2xhc3MgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJDbGFzc0lucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJJbnB1dEJhc2VkT25OYW1lID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBudWxsO1xuICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgNik7XG4gICAgICAgIHZhciBpc1N0eWxlID0gbmFtZSA9PT0gJ3N0eWxlJyB8fCBwcmVmaXggPT09ICdzdHlsZS4nIHx8IHByZWZpeCA9PT0gJ3N0eWxlISc7XG4gICAgICAgIHZhciBpc0NsYXNzID0gIWlzU3R5bGUgJiYgKG5hbWUgPT09ICdjbGFzcycgfHwgcHJlZml4ID09PSAnY2xhc3MuJyB8fCBwcmVmaXggPT09ICdjbGFzcyEnKTtcbiAgICAgICAgaWYgKGlzU3R5bGUgfHwgaXNDbGFzcykge1xuICAgICAgICAgICAgdmFyIGlzTWFwQmFzZWQgPSBuYW1lLmNoYXJBdCg1KSAhPT0gJy4nOyAvLyBzdHlsZS5wcm9wIG9yIGNsYXNzLnByb3AgbWFrZXMgdGhpcyBhIG5vXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lLnN1YnN0cihpc01hcEJhc2VkID8gNSA6IDYpOyAvLyB0aGUgZG90IGV4cGxhaW5zIHdoeSB0aGVyZSdzIGEgKzFcbiAgICAgICAgICAgIGlmIChpc1N0eWxlKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJTdHlsZUlucHV0KHByb3BlcnR5LCBpc01hcEJhc2VkLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyQ2xhc3NJbnB1dChwcm9wZXJ0eSwgaXNNYXBCYXNlZCwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJTdHlsZUlucHV0ID0gZnVuY3Rpb24gKG5hbWUsIGlzTWFwQmFzZWQsIHZhbHVlLCBzb3VyY2VTcGFuLCB1bml0KSB7XG4gICAgICAgIGlmIChpc0VtcHR5RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBub3JtYWxpemVQcm9wTmFtZShuYW1lKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VQcm9wZXJ0eShuYW1lKSwgcHJvcGVydHkgPSBfYS5wcm9wZXJ0eSwgaGFzT3ZlcnJpZGVGbGFnID0gX2EuaGFzT3ZlcnJpZGVGbGFnLCBiaW5kaW5nVW5pdCA9IF9hLnVuaXQ7XG4gICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LFxuICAgICAgICAgICAgc2FuaXRpemU6IHByb3BlcnR5ID8gaXNTdHlsZVNhbml0aXphYmxlKHByb3BlcnR5KSA6IHRydWUsXG4gICAgICAgICAgICB1bml0OiB1bml0IHx8IGJpbmRpbmdVbml0LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIGhhc092ZXJyaWRlRmxhZzogaGFzT3ZlcnJpZGVGbGFnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc01hcEJhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZU1hcElucHV0ID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgPSB0aGlzLl9zaW5nbGVTdHlsZUlucHV0cyB8fCBbXSkucHVzaChlbnRyeSk7XG4gICAgICAgICAgICByZWdpc3RlckludG9NYXAodGhpcy5fc3R5bGVzSW5kZXgsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gZW50cnk7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgfHwgZW50cnk7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUGlwZXModmFsdWUpO1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyQ2xhc3NJbnB1dCA9IGZ1bmN0aW9uIChuYW1lLCBpc01hcEJhc2VkLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoaXNFbXB0eUV4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBwYXJzZVByb3BlcnR5KG5hbWUpLCBwcm9wZXJ0eSA9IF9hLnByb3BlcnR5LCBoYXNPdmVycmlkZUZsYWcgPSBfYS5oYXNPdmVycmlkZUZsYWc7XG4gICAgICAgIHZhciBlbnRyeSA9IHsgbmFtZTogcHJvcGVydHksIHZhbHVlOiB2YWx1ZSwgc291cmNlU3Bhbjogc291cmNlU3Bhbiwgc2FuaXRpemU6IGZhbHNlLCBoYXNPdmVycmlkZUZsYWc6IGhhc092ZXJyaWRlRmxhZywgdW5pdDogbnVsbCB9O1xuICAgICAgICBpZiAoaXNNYXBCYXNlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NsYXNzTWFwSW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjbGFzc10gYW5kIFtjbGFzc05hbWVdIGJpbmRpbmdzIGNhbm5vdCBiZSB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgc2ltdWx0YW5lb3VzbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NsYXNzTWFwSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh0aGlzLl9zaW5nbGVDbGFzc0lucHV0cyA9IHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzIHx8IFtdKS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIHJlZ2lzdGVySW50b01hcCh0aGlzLl9jbGFzc2VzSW5kZXgsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gZW50cnk7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgfHwgZW50cnk7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUGlwZXModmFsdWUpO1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH07XG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLl9jaGVja0ZvclBpcGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSAmJiAodmFsdWUuYXN0IGluc3RhbmNlb2YgQmluZGluZ1BpcGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JpbmRpbmdzV2l0aFBpcGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBlbGVtZW50J3Mgc3RhdGljIHN0eWxlIHN0cmluZyB2YWx1ZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgc3R5bGUgc3RyaW5nIChlLmcuIGB3aWR0aDoxMDBweDsgaGVpZ2h0OjIwMHB4O2ApXG4gICAgICovXG4gICAgU3R5bGluZ0J1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyU3R5bGVBdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcyA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faGFzSW5pdGlhbFZhbHVlcyA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGVsZW1lbnQncyBzdGF0aWMgY2xhc3Mgc3RyaW5nIHZhbHVlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBjbGFzc05hbWUgc3RyaW5nIChlLmcuIGBkaXNhYmxlZCBnb2xkIHpvb21gKVxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5yZWdpc3RlckNsYXNzQXR0ciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvZyk7XG4gICAgICAgIHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhbGwgc3R5bGluZy1yZWxhdGVkIGV4cHJlc3Npb25zIHRvIHRoZSBwcm92aWRlZCBhdHRycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRycyBhbiBleGlzdGluZyBhcnJheSB3aGVyZSBlYWNoIG9mIHRoZSBzdHlsaW5nIGV4cHJlc3Npb25zXG4gICAgICogd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICAgICAqL1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5wb3B1bGF0ZUluaXRpYWxTdHlsaW5nQXR0cnMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgLy8gW0NMQVNTX01BUktFUiwgJ2ZvbycsICdiYXInLCAnYmF6JyAuLi5dXG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKGxpdGVyYWwoMSAvKiBDbGFzc2VzICovKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBbU1RZTEVfTUFSS0VSLCAnd2lkdGgnLCAnMjAwcHgnLCAnaGVpZ2h0JywgJzEwMHB4JywgLi4uXVxuICAgICAgICBpZiAodGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKDIgLyogU3R5bGVzICovKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXNbaV0pLCBsaXRlcmFsKHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlc1tpICsgMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGluc3RydWN0aW9uIHdpdGggYWxsIHRoZSBleHByZXNzaW9ucyBhbmQgcGFyYW1ldGVycyBmb3IgYGVsZW1lbnRIb3N0QXR0cnNgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGdlbmVyYXRpb24gY29kZSBiZWxvdyBpcyB1c2VkIGZvciBwcm9kdWNpbmcgdGhlIEFPVCBzdGF0ZW1lbnQgY29kZSB3aGljaCBpc1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciByZWdpc3RlcmluZyBpbml0aWFsIHN0eWxlcyAod2l0aGluIGEgZGlyZWN0aXZlIGhvc3RCaW5kaW5ncycgY3JlYXRpb24gYmxvY2spLFxuICAgICAqIGFzIHdlbGwgYXMgYW55IG9mIHRoZSBwcm92aWRlZCBhdHRyaWJ1dGUgdmFsdWVzLCB0byB0aGUgZGlyZWN0aXZlIGhvc3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYXNzaWduSG9zdEF0dHJzID0gZnVuY3Rpb24gKGF0dHJzLCBkZWZpbml0aW9uTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3RpdmVFeHByICYmIChhdHRycy5sZW5ndGggfHwgdGhpcy5faGFzSW5pdGlhbFZhbHVlcykpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdWxhdGVJbml0aWFsU3R5bGluZ0F0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdob3N0QXR0cnMnLCBsaXRlcmFsQXJyKGF0dHJzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBjbGFzc01hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgY2xhc3NNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbY2xhc3NdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYnVpbGRDbGFzc01hcEluc3RydWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc01hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCB0cnVlLCB0aGlzLl9jbGFzc01hcElucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBzdHlsZU1hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgc3R5bGVNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbc3R5bGVdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZU1hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCBmYWxzZSwgdGhpcy5fc3R5bGVNYXBJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkTWFwQmFzZWRJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZUNvbnZlcnRlciwgaXNDbGFzc0Jhc2VkLCBzdHlsaW5nSW5wdXQpIHtcbiAgICAgICAgLy8gZWFjaCBzdHlsaW5nIGJpbmRpbmcgdmFsdWUgaXMgc3RvcmVkIGluIHRoZSBMVmlld1xuICAgICAgICAvLyBtYXAtYmFzZWQgYmluZGluZ3MgYWxsb2NhdGUgdHdvIHNsb3RzOiBvbmUgZm9yIHRoZVxuICAgICAgICAvLyBwcmV2aW91cyBiaW5kaW5nIHZhbHVlIGFuZCBhbm90aGVyIGZvciB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2xhc3NOYW1lIG9yIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgdmFyIHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgPSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEO1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgbXVzdCBiZSBvdXRzaWRlIG9mIHRoZSB1cGRhdGUgYmxvY2sgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAvLyBiZSBldmFsdWF0ZWQgKHRoZSBBU1QgdmlzaXQgY2FsbCkgZHVyaW5nIGNyZWF0aW9uIHRpbWUgc28gdGhhdCBhbnlcbiAgICAgICAgLy8gcGlwZXMgY2FuIGJlIHBpY2tlZCB1cCBpbiB0aW1lIGJlZm9yZSB0aGUgdGVtcGxhdGUgaXMgYnVpbHRcbiAgICAgICAgdmFyIG1hcFZhbHVlID0gc3R5bGluZ0lucHV0LnZhbHVlLnZpc2l0KHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKG1hcFZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSBtYXBWYWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKG1hcFZhbHVlKSA6XG4gICAgICAgICAgICAgICAgZ2V0U3R5bGVNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihtYXBWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBJZGVudGlmaWVycyQxLmNsYXNzTWFwIDogSWRlbnRpZmllcnMkMS5zdHlsZU1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgICAgICBjYWxsczogW3tcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBzdHlsaW5nSW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKGNvbnZlcnRGbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRSZXN1bHQgPSBjb252ZXJ0Rm4obWFwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IEFycmF5LmlzQXJyYXkoY29udmVydFJlc3VsdCkgPyBjb252ZXJ0UmVzdWx0IDogW2NvbnZlcnRSZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkU2luZ2xlSW5wdXRzID0gZnVuY3Rpb24gKHJlZmVyZW5jZSwgaW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgZ2V0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb25GbiwgaXNDbGFzc0Jhc2VkKSB7XG4gICAgICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZS52aXNpdCh2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlRm9yQ2FsbCA9IHJlZmVyZW5jZTtcbiAgICAgICAgICAgIC8vIGVhY2ggc3R5bGluZyBiaW5kaW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgTFZpZXdcbiAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSBhcmUgdHdvIHZhbHVlcyBzdG9yZWQgZm9yIGVhY2ggYmluZGluZzpcbiAgICAgICAgICAgIC8vICAgMSkgdGhlIHZhbHVlIGl0c2VsZlxuICAgICAgICAgICAgLy8gICAyKSBhbiBpbnRlcm1lZGlhdGUgdmFsdWUgKGNvbmNhdGVuYXRpb24gb2Ygc3R5bGUgdXAgdG8gdGhpcyBwb2ludCkuXG4gICAgICAgICAgICAvLyAgICAgIFdlIG5lZWQgdG8gc3RvcmUgdGhlIGludGVybWVkaWF0ZSB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0IGFsbG9jYXRlXG4gICAgICAgICAgICAvLyAgICAgIHRoZSBzdHJpbmdzIG9uIGVhY2ggQ0QuXG4gICAgICAgICAgICB2YXIgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCA9IE1JTl9TVFlMSU5HX0JJTkRJTkdfU0xPVFNfUkVRVUlSRUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSB2YWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRm9yQ2FsbCA9IGdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYWxsID0ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiAhIWdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBmdW5jdGlvbiAoY29udmVydEZuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtcyA9PiBzdHlsaW5nUHJvcChwcm9wTmFtZSwgdmFsdWUsIHN1ZmZpeHxzYW5pdGl6ZXIpXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChpbnB1dC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0UmVzdWx0ID0gY29udmVydEZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udmVydFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoLmFwcGx5KHBhcmFtcywgX19zcHJlYWQoY29udmVydFJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goY29udmVydFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gW3N0eWxlLnByb3BdIGJpbmRpbmdzIG1heSB1c2Ugc3VmZml4IHZhbHVlcyAoZS5nLiBweCwgZW0sIGV0Yy4uLikgYW5kIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGFsc28gdXNlIGEgc2FuaXRpemVyLiBTYW5pdGl6YXRpb24gb2NjdXJzIGZvciB1cmwtYmFzZWQgZW50cmllcy4gSGF2aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzdWZmaXggdmFsdWUgYW5kIGEgc2FuaXRpemVyIHRvZ2V0aGVyIGludG8gdGhlIGluc3RydWN0aW9uIGRvZXNuJ3QgbWFrZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbnkgc2Vuc2UgKHVybC1iYXNlZCBlbnRyaWVzIGNhbm5vdCBiZSBzYW5pdGl6ZWQpLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2xhc3NCYXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChsaXRlcmFsKGlucHV0LnVuaXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0LnNhbml0aXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmF1bHRTdHlsZVNhbml0aXplcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIElmIHdlIGVuZGVkIHVwIGdlbmVyYXRpbmcgYSBjYWxsIHRvIHRoZSBzYW1lIGluc3RydWN0aW9uIGFzIHRoZSBwcmV2aW91cyBzdHlsaW5nIHByb3BlcnR5XG4gICAgICAgICAgICAvLyB3ZSBjYW4gY2hhaW4gdGhlIGNhbGxzIHRvZ2V0aGVyIHNhZmVseSB0byBzYXZlIHNvbWUgYnl0ZXMsIG90aGVyd2lzZSB3ZSBoYXZlIHRvIGdlbmVyYXRlXG4gICAgICAgICAgICAvLyBhIHNlcGFyYXRlIGluc3RydWN0aW9uIGNhbGwuIFRoaXMgaXMgcHJpbWFyaWx5IGEgY29uY2VybiB3aXRoIGludGVycG9sYXRpb24gaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAvLyB3aGVyZSB3ZSBtYXkgc3RhcnQgb2ZmIHdpdGggb25lIGByZWZlcmVuY2VgLCBidXQgZW5kIHVwIHVzaW5nIGFub3RoZXIgYmFzZWQgb24gdGhlXG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgaW50ZXJwb2xhdGlvbnMuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNJbnN0cnVjdGlvbiAmJiBwcmV2aW91c0luc3RydWN0aW9uLnJlZmVyZW5jZSA9PT0gcmVmZXJlbmNlRm9yQ2FsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5zdHJ1Y3Rpb24uY2FsbHMucHVzaChjYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHsgcmVmZXJlbmNlOiByZWZlcmVuY2VGb3JDYWxsLCBjYWxsczogW2NhbGxdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9O1xuICAgIFN0eWxpbmdCdWlsZGVyLnByb3RvdHlwZS5fYnVpbGRDbGFzc0lucHV0cyA9IGZ1bmN0aW9uICh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNpbmdsZUlucHV0cyhJZGVudGlmaWVycyQxLmNsYXNzUHJvcCwgdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMsIHZhbHVlQ29udmVydGVyLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuX2J1aWxkU3R5bGVJbnB1dHMgPSBmdW5jdGlvbiAodmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRTaW5nbGVJbnB1dHMoSWRlbnRpZmllcnMkMS5zdHlsZVByb3AsIHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgZ2V0U3R5bGVQcm9wSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFsbCBpbnN0cnVjdGlvbnMgd2hpY2ggY29udGFpbiB0aGUgZXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIHBsYWNlZFxuICAgICAqIGludG8gdGhlIHVwZGF0ZSBibG9jayBvZiBhIHRlbXBsYXRlIGZ1bmN0aW9uIG9yIGEgZGlyZWN0aXZlIGhvc3RCaW5kaW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBTdHlsaW5nQnVpbGRlci5wcm90b3R5cGUuYnVpbGRVcGRhdGVMZXZlbEluc3RydWN0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGlmICh0aGlzLmhhc0JpbmRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVNYXBJbnN0cnVjdGlvbiA9IHRoaXMuYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZU1hcEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goc3R5bGVNYXBJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xhc3NNYXBJbnN0cnVjdGlvbiA9IHRoaXMuYnVpbGRDbGFzc01hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChjbGFzc01hcEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY2xhc3NNYXBJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaC5hcHBseShpbnN0cnVjdGlvbnMsIF9fc3ByZWFkKHRoaXMuX2J1aWxkU3R5bGVJbnB1dHModmFsdWVDb252ZXJ0ZXIpKSk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaC5hcHBseShpbnN0cnVjdGlvbnMsIF9fc3ByZWFkKHRoaXMuX2J1aWxkQ2xhc3NJbnB1dHModmFsdWVDb252ZXJ0ZXIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9O1xuICAgIHJldHVybiBTdHlsaW5nQnVpbGRlcjtcbn0oKSk7XG5mdW5jdGlvbiByZWdpc3RlckludG9NYXAobWFwLCBrZXkpIHtcbiAgICBpZiAoIW1hcC5oYXMoa2V5KSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgbWFwLnNpemUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3R5bGVTYW5pdGl6YWJsZShwcm9wKSB7XG4gICAgLy8gTm90ZSB0aGF0IGJyb3dzZXJzIHN1cHBvcnQgYm90aCB0aGUgZGFzaCBjYXNlIGFuZFxuICAgIC8vIGNhbWVsIGNhc2UgcHJvcGVydHkgbmFtZXMgd2hlbiBzZXR0aW5nIHRocm91Z2ggSlMuXG4gICAgcmV0dXJuIHByb3AgPT09ICdiYWNrZ3JvdW5kLWltYWdlJyB8fCBwcm9wID09PSAnYmFja2dyb3VuZEltYWdlJyB8fCBwcm9wID09PSAnYmFja2dyb3VuZCcgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2JvcmRlci1pbWFnZScgfHwgcHJvcCA9PT0gJ2JvcmRlckltYWdlJyB8fCBwcm9wID09PSAnYm9yZGVyLWltYWdlLXNvdXJjZScgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2JvcmRlckltYWdlU291cmNlJyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbGlzdC1zdHlsZScgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2xpc3RTdHlsZScgfHwgcHJvcCA9PT0gJ2xpc3Qtc3R5bGUtaW1hZ2UnIHx8IHByb3AgPT09ICdsaXN0U3R5bGVJbWFnZScgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2NsaXAtcGF0aCcgfHwgcHJvcCA9PT0gJ2NsaXBQYXRoJztcbn1cbi8qKlxuICogU2ltcGxlIGhlbHBlciBmdW5jdGlvbiB0byBlaXRoZXIgcHJvdmlkZSB0aGUgY29uc3RhbnQgbGl0ZXJhbCB0aGF0IHdpbGwgaG91c2UgdGhlIHZhbHVlXG4gKiBoZXJlIG9yIGEgbnVsbCB2YWx1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWVzIGFyZSBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29uc3RhbnRMaXRlcmFsRnJvbUFycmF5KGNvbnN0YW50UG9vbCwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBjb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIodmFsdWVzKSwgdHJ1ZSkgOiBOVUxMX0VYUFI7XG59XG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5KG5hbWUpIHtcbiAgICB2YXIgaGFzT3ZlcnJpZGVGbGFnID0gZmFsc2U7XG4gICAgdmFyIG92ZXJyaWRlSW5kZXggPSBuYW1lLmluZGV4T2YoSU1QT1JUQU5UX0ZMQUcpO1xuICAgIGlmIChvdmVycmlkZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBuYW1lID0gb3ZlcnJpZGVJbmRleCA+IDAgPyBuYW1lLnN1YnN0cmluZygwLCBvdmVycmlkZUluZGV4KSA6ICcnO1xuICAgICAgICBoYXNPdmVycmlkZUZsYWcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIHZhciBwcm9wZXJ0eSA9IG5hbWU7XG4gICAgdmFyIHVuaXRJbmRleCA9IG5hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAodW5pdEluZGV4ID4gMCkge1xuICAgICAgICB1bml0ID0gbmFtZS5zdWJzdHIodW5pdEluZGV4ICsgMSk7XG4gICAgICAgIHByb3BlcnR5ID0gbmFtZS5zdWJzdHJpbmcoMCwgdW5pdEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJvcGVydHk6IHByb3BlcnR5LCB1bml0OiB1bml0LCBoYXNPdmVycmlkZUZsYWc6IGhhc092ZXJyaWRlRmxhZyB9O1xufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgYW4gaW50ZXJwb2xhdGVkIGNsYXNzIG1hcC5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldENsYXNzTWFwSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgc3R5bGUgbWFwLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBzdHlsZSBwcm9wLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVQcm9wSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcE5hbWUocHJvcCkge1xuICAgIHJldHVybiBoeXBoZW5hdGUocHJvcCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUkMTtcbihmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiSWRlbnRpZmllclwiXSA9IDFdID0gXCJJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAyXSA9IFwiS2V5d29yZFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk9wZXJhdG9yXCJdID0gNF0gPSBcIk9wZXJhdG9yXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDVdID0gXCJOdW1iZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRXJyb3JcIl0gPSA2XSA9IFwiRXJyb3JcIjtcbn0pKFRva2VuVHlwZSQxIHx8IChUb2tlblR5cGUkMSA9IHt9KSk7XG52YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbnZhciBMZXhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgICB9XG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbnZhciBUb2tlbiQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCBlbmQsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLk51bWJlcjtcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5TdHJpbmc7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0b3I7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLklkZW50aWZpZXI7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQ7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbGV0JztcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2FzJztcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbnVsbCc7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUcnVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZSQxLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdmYWxzZSc7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUkMS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RoaXMnO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuRXJyb3I7XG4gICAgfTtcbiAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlJDEuTnVtYmVyID8gdGhpcy5udW1WYWx1ZSA6IC0xO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLklkZW50aWZpZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLktleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLk9wZXJhdG9yOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5TdHJpbmc6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZSQxLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUkMS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUb2tlbjtcbn0oKSk7XG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgZW5kLCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbiQxKGluZGV4LCBlbmQsIFRva2VuVHlwZSQxLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59XG5mdW5jdGlvbiBuZXdJZGVudGlmaWVyVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4kMShpbmRleCwgZW5kLCBUb2tlblR5cGUkMS5JZGVudGlmaWVyLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld0tleXdvcmRUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbiQxKGluZGV4LCBlbmQsIFRva2VuVHlwZSQxLktleXdvcmQsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbiQxKGluZGV4LCBlbmQsIFRva2VuVHlwZSQxLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuJDEoaW5kZXgsIGVuZCwgVG9rZW5UeXBlJDEuU3RyaW5nLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld051bWJlclRva2VuKGluZGV4LCBlbmQsIG4pIHtcbiAgICByZXR1cm4gbmV3IFRva2VuJDEoaW5kZXgsIGVuZCwgVG9rZW5UeXBlJDEuTnVtYmVyLCBuLCAnJyk7XG59XG5mdW5jdGlvbiBuZXdFcnJvclRva2VuKGluZGV4LCBlbmQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuJDEoaW5kZXgsIGVuZCwgVG9rZW5UeXBlJDEuRXJyb3IsIDAsIG1lc3NhZ2UpO1xufVxudmFyIEVPRiA9IG5ldyBUb2tlbiQxKC0xLCAtMSwgVG9rZW5UeXBlJDEuQ2hhcmFjdGVyLCAwLCAnJyk7XG52YXIgX1NjYW5uZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1NjYW5uZXIoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGVlayA9ICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHBlZWsgPSB0aGlzLnBlZWssIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBlZWsgPSAkRU9GO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVlayA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICB2YXIgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgc3dpdGNoIChwZWVrKSB7XG4gICAgICAgICAgICBjYXNlICRQRVJJT0Q6XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGlnaXQodGhpcy5wZWVrKSA/IHRoaXMuc2Nhbk51bWJlcihzdGFydCkgOlxuICAgICAgICAgICAgICAgICAgICBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgJFBFUklPRCk7XG4gICAgICAgICAgICBjYXNlICRMUEFSRU46XG4gICAgICAgICAgICBjYXNlICRSUEFSRU46XG4gICAgICAgICAgICBjYXNlICRMQlJBQ0U6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0U6XG4gICAgICAgICAgICBjYXNlICRMQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJFJCUkFDS0VUOlxuICAgICAgICAgICAgY2FzZSAkQ09NTUE6XG4gICAgICAgICAgICBjYXNlICRDT0xPTjpcbiAgICAgICAgICAgIGNhc2UgJFNFTUlDT0xPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ2hhcmFjdGVyKHN0YXJ0LCBwZWVrKTtcbiAgICAgICAgICAgIGNhc2UgJFNROlxuICAgICAgICAgICAgY2FzZSAkRFE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAkSEFTSDpcbiAgICAgICAgICAgIGNhc2UgJFBMVVM6XG4gICAgICAgICAgICBjYXNlICRNSU5VUzpcbiAgICAgICAgICAgIGNhc2UgJFNUQVI6XG4gICAgICAgICAgICBjYXNlICRTTEFTSDpcbiAgICAgICAgICAgIGNhc2UgJFBFUkNFTlQ6XG4gICAgICAgICAgICBjYXNlICRDQVJFVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykpO1xuICAgICAgICAgICAgY2FzZSAkUVVFU1RJT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJz8nLCAkUEVSSU9ELCAnLicpO1xuICAgICAgICAgICAgY2FzZSAkTFQ6XG4gICAgICAgICAgICBjYXNlICRHVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICBjYXNlICRCQU5HOlxuICAgICAgICAgICAgY2FzZSAkRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScsICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEFNUEVSU0FORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnJicsICRBTVBFUlNBTkQsICcmJyk7XG4gICAgICAgICAgICBjYXNlICRCQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCAkQkFSLCAnfCcpO1xuICAgICAgICAgICAgY2FzZSAkTkJTUDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFtcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykgKyBcIl1cIiwgMCk7XG4gICAgfTtcbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNoYXJhY3RlciA9IGZ1bmN0aW9uIChzdGFydCwgY29kZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBjb2RlKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhbkNvbXBsZXhPcGVyYXRvciA9IGZ1bmN0aW9uIChzdGFydCwgb25lLCB0d29Db2RlLCB0d28sIHRocmVlQ29kZSwgdGhyZWUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHZhciBzdHIgPSBvbmU7XG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT0gdHdvQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdHdvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlZUNvZGUgIT0gbnVsbCAmJiB0aGlzLnBlZWsgPT0gdGhyZWVDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0aHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIEtFWVdPUkRTLmluZGV4T2Yoc3RyKSA+IC0xID8gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpIDpcbiAgICAgICAgICAgIG5ld0lkZW50aWZpZXJUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJFBFUklPRCkge1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvbmVudFN0YXJ0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFeHBvbmVudFNpZ24odGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIGV4cG9uZW50JywgLTEpO1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBzaW1wbGUgPyBwYXJzZUludEF1dG9SYWRpeChzdHIpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHZhbHVlKTtcbiAgICB9O1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIHZhciBidWZmZXIgPSAnJztcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWsgIT0gcXVvdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBpbnB1dC5zdWJzdHJpbmcobWFya2VyLCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkQ29kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBUUzIuMS1pbnRyb2R1Y2VkIHR5cGUgc3RyaWN0bmVzc1xuICAgICAgICAgICAgICAgIHRoaXMucGVlayA9IHRoaXMucGVlaztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICR1KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDQgY2hhcmFjdGVyIGhleCBjb2RlIGZvciB1bmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05YS1mXSskL2kudGVzdChoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gdW5lc2NhcGUodGhpcy5wZWVrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuZXNjYXBlZENvZGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT0gJEVPRikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIGJ1ZmZlciArIGxhc3QpO1xuICAgIH07XG4gICAgX1NjYW5uZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gbmV3RXJyb3JUb2tlbihwb3NpdGlvbiwgdGhpcy5pbmRleCwgXCJMZXhlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgYXQgY29sdW1uIFwiICsgcG9zaXRpb24gKyBcIiBpbiBleHByZXNzaW9uIFtcIiArIHRoaXMuaW5wdXQgKyBcIl1cIik7XG4gICAgfTtcbiAgICByZXR1cm4gX1NjYW5uZXI7XG59KCkpO1xuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgIHJldHVybiAoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gJCQpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIoaW5wdXQpO1xuICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoc2Nhbm5lci5wZWVrKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIHdoaWxlIChzY2FubmVyLnBlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY29kZSkge1xuICAgIHJldHVybiBpc0FzY2lpTGV0dGVyKGNvZGUpIHx8IGlzRGlnaXQoY29kZSkgfHwgKGNvZGUgPT0gJF8pIHx8XG4gICAgICAgIChjb2RlID09ICQkKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb25lbnRTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJGUgfHwgY29kZSA9PSAkRTtcbn1cbmZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkTUlOVVMgfHwgY29kZSA9PSAkUExVUztcbn1cbmZ1bmN0aW9uIGlzUXVvdGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRCVDtcbn1cbmZ1bmN0aW9uIHVuZXNjYXBlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAkbjpcbiAgICAgICAgICAgIHJldHVybiAkTEY7XG4gICAgICAgIGNhc2UgJGY6XG4gICAgICAgICAgICByZXR1cm4gJEZGO1xuICAgICAgICBjYXNlICRyOlxuICAgICAgICAgICAgcmV0dXJuICRDUjtcbiAgICAgICAgY2FzZSAkdDpcbiAgICAgICAgICAgIHJldHVybiAkVEFCO1xuICAgICAgICBjYXNlICR2OlxuICAgICAgICAgICAgcmV0dXJuICRWVEFCO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbnRBdXRvUmFkaXgodGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTcGxpdEludGVycG9sYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gb2Zmc2V0cztcbiAgICB9XG4gICAgcmV0dXJuIFNwbGl0SW50ZXJwb2xhdGlvbjtcbn0oKSk7XG52YXIgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQodGVtcGxhdGVCaW5kaW5ncywgd2FybmluZ3MsIGVycm9ycykge1xuICAgICAgICB0aGlzLnRlbXBsYXRlQmluZGluZ3MgPSB0ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG59KCkpO1xudmFyIGRlZmF1bHRJbnRlcnBvbGF0ZVJlZ0V4cCA9IF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKTtcbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SW50ZXJwb2xhdGVSZWdFeHA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGNvbmZpZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGNvbmZpZykge1xuICAgIHZhciBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKTtcbn1cbnZhciBQYXJzZXIkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCkpO1xuICAgICAgICB2YXIgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgdHJ1ZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmNoZWNrU2ltcGxlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBuZXcgdGhpcy5zaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQoY2hlY2tlcik7XG4gICAgICAgIHJldHVybiBjaGVja2VyLmVycm9ycztcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTaW1wbGVCaW5kaW5nID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5jaGVja1NpbXBsZUV4cHJlc3Npb24oYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkhvc3QgYmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIFwiICsgZXJyb3JzLmpvaW4oJyAnKSwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgIC8vIG91ciBsZXhlciBvciBwYXJzZXIgZm9yIHRoYXQsIHNvIHdlIGNoZWNrIGZvciB0aGF0IGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIHZhciBxdW90ZSA9IHRoaXMuX3BhcnNlUXVvdGUoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIGlmIChxdW90ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9wYXJzZVF1b3RlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHByZWZpeFNlcGFyYXRvckluZGV4ID0gaW5wdXQuaW5kZXhPZignOicpO1xuICAgICAgICBpZiAocHJlZml4U2VwYXJhdG9ySW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHByZWZpeCA9IGlucHV0LnN1YnN0cmluZygwLCBwcmVmaXhTZXBhcmF0b3JJbmRleCkudHJpbSgpO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGlucHV0LnN1YnN0cmluZyhwcmVmaXhTZXBhcmF0b3JJbmRleCArIDEpO1xuICAgICAgICB2YXIgc3BhbiA9IG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShzcGFuLCBzcGFuLnRvQWJzb2x1dGUoYWJzb2x1dGVPZmZzZXQpLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICogICAgICAgICBeICAgICAgXiBhYnNvbHV0ZVZhbHVlT2Zmc2V0IGZvciBgdGVtcGxhdGVWYWx1ZWBcbiAgICAgKiAgICAgICAgIGFic29sdXRlS2V5T2Zmc2V0IGZvciBgdGVtcGxhdGVLZXlgXG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgdGhyZWUgYmluZGluZ3M6XG4gICAgICogMS4gbmdGb3IgLT4gbnVsbFxuICAgICAqIDIuIGl0ZW0gLT4gTmdGb3JPZkNvbnRleHQuJGltcGxpY2l0XG4gICAgICogMy4gbmdGb3JPZiAtPiBpdGVtc1xuICAgICAqXG4gICAgICogVGhpcyBpcyBhcHBhcmVudCBmcm9tIHRoZSBkZS1zdWdhcmVkIHRlbXBsYXRlOlxuICAgICAqIGBgYFxuICAgICAqICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiBkaXJlY3RpdmUsIHdpdGhvdXQgdGhlICogcHJlZml4LiBGb3IgZXhhbXBsZTogbmdJZiwgbmdGb3JcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVWYWx1ZSBSSFMgb2YgdGhlIG1pY3Jvc3ludGF4IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZVVybCB0ZW1wbGF0ZSBmaWxlbmFtZSBpZiBpdCdzIGV4dGVybmFsLCBjb21wb25lbnQgZmlsZW5hbWUgaWYgaXQncyBpbmxpbmVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVLZXlPZmZzZXQgc3RhcnQgb2YgdGhlIGB0ZW1wbGF0ZUtleWBcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVWYWx1ZU9mZnNldCBzdGFydCBvZiB0aGUgYHRlbXBsYXRlVmFsdWVgXG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAodGVtcGxhdGVLZXksIHRlbXBsYXRlVmFsdWUsIHRlbXBsYXRlVXJsLCBhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVWYWx1ZU9mZnNldCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgX1BhcnNlQVNUKHRlbXBsYXRlVmFsdWUsIHRlbXBsYXRlVXJsLCBhYnNvbHV0ZVZhbHVlT2Zmc2V0LCB0b2tlbnMsIHRlbXBsYXRlVmFsdWUubGVuZ3RoLCBmYWxzZSAvKiBwYXJzZUFjdGlvbiAqLywgdGhpcy5lcnJvcnMsIDAgLyogcmVsYXRpdmUgb2Zmc2V0ICovKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3Moe1xuICAgICAgICAgICAgc291cmNlOiB0ZW1wbGF0ZUtleSxcbiAgICAgICAgICAgIHNwYW46IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlS2V5T2Zmc2V0ICsgdGVtcGxhdGVLZXkubGVuZ3RoKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5zcGxpdEludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKHNwbGl0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQuZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uVGV4dCA9IHNwbGl0LmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uVGV4dCk7XG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgc3BsaXQub2Zmc2V0c1tpXSArIChleHByZXNzaW9uVGV4dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNwYW4gPSBuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBJbnRlcnBvbGF0aW9uKHNwYW4sIHNwYW4udG9BYnNvbHV0ZShhYnNvbHV0ZU9mZnNldCksIHNwbGl0LnN0cmluZ3MsIGV4cHJlc3Npb25zKSwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5zcGxpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIHJlZ2V4cCA9IF9nZXRJbnRlcnBvbGF0ZVJlZ0V4cChpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aCArIGludGVycG9sYXRpb25Db25maWcuZW5kLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKCdCbGFuayBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gaW50ZXJwb2xhdGVkIHN0cmluZ3MnLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCBpLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCckaW1wbGljaXQnKTtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIHNwYW4gPSBuZXcgUGFyc2VTcGFuKDAsIGlucHV0ID09IG51bGwgPyAwIDogaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBMaXRlcmFsUHJpbWl0aXZlKHNwYW4sIHNwYW4udG9BYnNvbHV0ZShhYnNvbHV0ZU9mZnNldCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuX2NvbW1lbnRTdGFydChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpICE9IG51bGwgPyBpbnB1dC5zdWJzdHJpbmcoMCwgaSkudHJpbSgpIDogaW5wdXQ7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLl9jb21tZW50U3RhcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBvdXRlclF1b3RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICBpZiAob3V0ZXJRdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3V0ZXJRdW90ZSA9PSBudWxsICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2NoZWNrTm9JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgcmVnZXhwID0gX2dldEludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJHb3QgaW50ZXJwb2xhdGlvbiAoXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQgKyBcIikgd2hlcmUgZXhwcmVzc2lvbiB3YXMgZXhwZWN0ZWRcIiwgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgMSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4gPSBmdW5jdGlvbiAocGFydHMsIHBhcnRJbkVycklkeCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgZXJyTG9jYXRpb24gPSAnJztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgZXJyTG9jYXRpb24gKz0gaiAlIDIgPT09IDAgP1xuICAgICAgICAgICAgICAgIHBhcnRzW2pdIDpcbiAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyckxvY2F0aW9uLmxlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCkpO1xudmFyIEl2eVBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXZ5UGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEl2eVBhcnNlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gSXZ5U2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7IC8vXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEl2eVBhcnNlcjtcbn0oUGFyc2VyJDEpKTtcbnZhciBfUGFyc2VBU1QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2VucywgaW5wdXRMZW5ndGgsIHBhcnNlQWN0aW9uLCBlcnJvcnMsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZU9mZnNldCA9IGFic29sdXRlT2Zmc2V0O1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5pbnB1dExlbmd0aCA9IGlucHV0TGVuZ3RoO1xuICAgICAgICB0aGlzLnBhcnNlQWN0aW9uID0gcGFyc2VBY3Rpb247XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQgPSAwO1xuICAgICAgICAvLyBDYWNoZSBvZiBleHByZXNzaW9uIHN0YXJ0IGFuZCBpbnB1dCBpbmRlY2VzIHRvIHRoZSBhYnNvbHV0ZSBzb3VyY2Ugc3BhbiB0aGV5IG1hcCB0bywgdXNlZCB0b1xuICAgICAgICAvLyBwcmV2ZW50IGNyZWF0aW5nIHN1cGVyZmx1b3VzIHNvdXJjZSBzcGFucyBpbiBgc291cmNlU3BhbmAuXG4gICAgICAgIC8vIEEgc2VyaWFsIG9mIHRoZSBleHByZXNzaW9uIHN0YXJ0IGFuZCBpbnB1dCBpbmRleCBpcyB1c2VkIGZvciBtYXBwaW5nIGJlY2F1c2UgYm90aCBhcmUgc3RhdGVmdWxcbiAgICAgICAgLy8gYW5kIG1heSBjaGFuZ2UgZm9yIHN1YnNlcXVlbnQgZXhwcmVzc2lvbnMgdmlzaXRlZCBieSB0aGUgcGFyc2VyLlxuICAgICAgICB0aGlzLnNvdXJjZVNwYW5DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zW2ldIDogRU9GO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVlaygwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwiYXRFT0ZcIiwge1xuICAgICAgICAvKiogV2hldGhlciBhbGwgdGhlIHBhcnNlciBpbnB1dCBoYXMgYmVlbiBwcm9jZXNzZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IG9mIHRoZSBuZXh0IHRva2VuIHRvIGJlIHByb2Nlc3NlZCwgb3IgdGhlIGVuZCBvZiB0aGUgbGFzdCB0b2tlbiBpZiBhbGwgaGF2ZSBiZWVuXG4gICAgICAgICAqIHByb2Nlc3NlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFT0YgPyB0aGlzLmN1cnJlbnRFbmRJbmRleCA6IHRoaXMubmV4dC5pbmRleCArIHRoaXMub2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJjdXJyZW50RW5kSW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5kIGluZGV4IG9mIHRoZSBsYXN0IHByb2Nlc3NlZCB0b2tlbiwgb3IgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCB0b2tlbiBpZiBub25lIGhhdmUgYmVlblxuICAgICAgICAgKiBwcm9jZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJUb2tlbiA9IHRoaXMucGVlaygtMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1clRva2VuLmVuZCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gdG9rZW5zIGhhdmUgYmVlbiBwcm9jZXNzZWQgeWV0OyByZXR1cm4gdGhlIG5leHQgdG9rZW4ncyBzdGFydCBvciB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9rZW4uXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRMZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwiY3VycmVudEFic29sdXRlT2Zmc2V0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIG9mZnNldCBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFic29sdXRlT2Zmc2V0ICsgdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNwYW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNwYW4oc3RhcnQsIHRoaXMuY3VycmVudEVuZEluZGV4KTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc291cmNlU3BhbiA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgc2VyaWFsID0gc3RhcnQgKyBcIkBcIiArIHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZVNwYW5DYWNoZS5oYXMoc2VyaWFsKSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VTcGFuQ2FjaGUuc2V0KHNlcmlhbCwgdGhpcy5zcGFuKHN0YXJ0KS50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VTcGFuQ2FjaGUuZ2V0KHNlcmlhbCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3Rlcihjb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRMZXQoKTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRBcygpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNPcGVyYXRvcihvcCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIgb3Iga2V5d29yZFwiKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyLCBrZXl3b3JkLCBvciBzdHJpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBleHBycyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdGhpcy5uZXh0ICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignfCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0Nhbm5vdCBoYXZlIGEgcGlwZSBpbiBhbiBhY3Rpb24gZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lU3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lU3BhbiA9IHRoaXMuc291cmNlU3BhbihuYW1lU3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByZXN1bHQuc3Bhbi5zdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgcmVzdWx0LCBuYW1lXzEsIGFyZ3MsIG5hbWVTcGFuKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3wnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJz8nKSkge1xuICAgICAgICAgICAgdmFyIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB2YXIgbm8gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQsIHllcywgbm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxPciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJ3x8J1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSByZXN1bHQuc3Bhbi5zdGFydDtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsQW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnJiYnXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmVzdWx0LnNwYW4uc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksICcmJicsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXF1YWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICc9PScsJyE9JywnPT09JywnIT09J1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByZXN1bHQuc3Bhbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUkMS5PcGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmVzdWx0LnNwYW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcmVzdWx0LnNwYW4uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTXVsdGlwbGljYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcqJywgJyUnLCAnLydcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJlc3VsdC5zcGFuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZSQxLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbFNwYW4gPSBuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCk7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbFNvdXJjZVNwYW4gPSBsaXRlcmFsU3Bhbi50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJy0nLCByZXN1bHQsIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGxpdGVyYWxTcGFuLCBsaXRlcmFsU291cmNlU3BhbiwgMCkpO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgbmV3IExpdGVyYWxQcmltaXRpdmUobGl0ZXJhbFNwYW4sIGxpdGVyYWxTb3VyY2VTcGFuLCAwKSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxDaGFpbigpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxDaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHZhciByZXN1bHRTdGFydCA9IHJlc3VsdC5zcGFuLnN0YXJ0O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRQRVJJT0QpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFdyaXRlKHRoaXMuc3BhbihyZXN1bHRTdGFydCksIHRoaXMuc291cmNlU3BhbihyZXN1bHRTdGFydCksIHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRSZWFkKHRoaXMuc3BhbihyZXN1bHRTdGFydCksIHRoaXMuc291cmNlU3BhbihyZXN1bHRTdGFydCksIHJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uQ2FsbCh0aGlzLnNwYW4ocmVzdWx0U3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4ocmVzdWx0U3RhcnQpLCByZXN1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignIScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IE5vbk51bGxBc3NlcnQodGhpcy5zcGFuKHJlc3VsdFN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHJlc3VsdFN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkTnVsbCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVW5kZWZpbmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRydWUoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZEZhbHNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVGhpcygpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1wbGljaXRSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRMQlJBQ0UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubmV4dC50b051bWJlcigpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbFZhbHVlID0gdGhpcy5uZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBsaXRlcmFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyB0aGlzLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLm5leHQuaXNDaGFyYWN0ZXIodGVybWluYXRvcikpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRMQlJBQ0UpO1xuICAgICAgICBpZiAoIXRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRSQlJBQ0UpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZWQgPSB0aGlzLm5leHQuaXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeyBrZXk6IGtleSwgcXVvdGVkOiBxdW90ZWQgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBrZXlzLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgaXNTYWZlKSB7XG4gICAgICAgIGlmIChpc1NhZmUgPT09IHZvaWQgMCkgeyBpc1NhZmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgbmFtZVN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKTtcbiAgICAgICAgdmFyIG5hbWVTcGFuID0gdGhpcy5zb3VyY2VTcGFuKG5hbWVTdGFydCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHZhciBzcGFuID0gdGhpcy5zcGFuKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBpc1NhZmUgPyBuZXcgU2FmZU1ldGhvZENhbGwoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgIG5ldyBNZXRob2RDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgaWQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVGhlIFxcJz8uXFwnIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG5hbWVTcGFuLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5ncyBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDYWxsQXJndW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRSUEFSRU4pKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluIGJldHdlZW4sXG4gICAgICogYW5kIHJldHVybnMgdGhlIHN0cmluZyBhbG9uZyB3aXRoIGl0cyBhYnNvbHV0ZSBzb3VyY2Ugc3Bhbi5cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmN1cnJlbnRBYnNvbHV0ZU9mZnNldDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignLScpO1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yRm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChvcGVyYXRvckZvdW5kKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogcmVzdWx0LFxuICAgICAgICAgICAgc3BhbjogbmV3IEFic29sdXRlU291cmNlU3BhbihzdGFydCwgc3RhcnQgKyByZXN1bHQubGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIG1pY3Jvc3ludGF4IHRlbXBsYXRlIGV4cHJlc3Npb24gYW5kIHJldHVybiBhIGxpc3Qgb2YgYmluZGluZ3Mgb3JcbiAgICAgKiBwYXJzaW5nIGVycm9ycyBpbiBjYXNlIHRoZSBnaXZlbiBleHByZXNzaW9uIGlzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXM7IGluZGV4IGFzIGk7IHRyYWNrQnk6IGZ1bmNcIj5cbiAgICAgKiBgYGBcbiAgICAgKiBjb250YWlucyBmaXZlIGJpbmRpbmdzOlxuICAgICAqIDEuIG5nRm9yIC0+IG51bGxcbiAgICAgKiAyLiBpdGVtIC0+IE5nRm9yT2ZDb250ZXh0LiRpbXBsaWNpdFxuICAgICAqIDMuIG5nRm9yT2YgLT4gaXRlbXNcbiAgICAgKiA0LiBpIC0+IE5nRm9yT2ZDb250ZXh0LmluZGV4XG4gICAgICogNS4gbmdGb3JUcmFja0J5IC0+IGZ1bmNcbiAgICAgKlxuICAgICAqIEZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhlIG1pY3Jvc3ludGF4IGdyYW1tYXIsIHNlZVxuICAgICAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21oZXZlcnkvZDM1MzAyOTRjZmYyZTRhMWIzZmUxNWZmNzVkMDg4NTVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUtleSBuYW1lIG9mIHRoZSBtaWNyb3N5bnRheCBkaXJlY3RpdmUsIGxpa2UgbmdJZiwgbmdGb3IsXG4gICAgICogd2l0aG91dCB0aGUgKiwgYWxvbmcgd2l0aCBpdHMgYWJzb2x1dGUgc3Bhbi5cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUtleSkge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJpbmRpbmcgaXMgZm9yIHRoZSB0ZW1wbGF0ZSBrZXkgaXRzZWxmXG4gICAgICAgIC8vIEluICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCIsIGtleSA9IFwibmdGb3JcIiwgdmFsdWUgPSBudWxsXG4gICAgICAgIC8vIEluICpuZ0lmPVwiY29uZCB8IHBpcGVcIiwga2V5ID0gXCJuZ0lmXCIsIHZhbHVlID0gXCJjb25kIHwgcGlwZVwiXG4gICAgICAgIGJpbmRpbmdzLnB1c2guYXBwbHkoYmluZGluZ3MsIF9fc3ByZWFkKHRoaXMucGFyc2VEaXJlY3RpdmVLZXl3b3JkQmluZGluZ3ModGVtcGxhdGVLZXkpKSk7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBzdGFydHMgd2l0aCAnbGV0JywgdGhlbiB0aGlzIG11c3QgYmUgdmFyaWFibGUgZGVjbGFyYXRpb25cbiAgICAgICAgICAgIHZhciBsZXRCaW5kaW5nID0gdGhpcy5wYXJzZUxldEJpbmRpbmcoKTtcbiAgICAgICAgICAgIGlmIChsZXRCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaChsZXRCaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR3byBwb3NzaWJsZSBjYXNlcyBoZXJlLCBlaXRoZXIgYHZhbHVlIFwiYXNcIiBrZXlgIG9yXG4gICAgICAgICAgICAgICAgLy8gXCJkaXJlY3RpdmUta2V5d29yZCBleHByZXNzaW9uXCIuIFdlIGRvbid0IGtub3cgd2hpY2ggY2FzZSwgYnV0IGJvdGhcbiAgICAgICAgICAgICAgICAvLyBcInZhbHVlXCIgYW5kIFwiZGlyZWN0aXZlLWtleXdvcmRcIiBhcmUgdGVtcGxhdGUgYmluZGluZyBrZXksIHNvIGNvbnN1bWVcbiAgICAgICAgICAgICAgICAvLyB0aGUga2V5IGZpcnN0LlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIC8vIFBlZWsgYXQgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIFwiYXNcIiB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUFzQmluZGluZyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGtleSBtdXN0IGJlIGEgZGlyZWN0aXZlIGtleXdvcmQsIGxpa2UgXCJvZlwiLiBUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGtleSB0byBhY3R1YWwga2V5LiBFZy4gb2YgLT4gbmdGb3JPZiwgdHJhY2tCeSAtPiBuZ0ZvclRyYWNrQnlcbiAgICAgICAgICAgICAgICAgICAga2V5LnNvdXJjZSA9IHRlbXBsYXRlS2V5LnNvdXJjZSArIGtleS5zb3VyY2VbMF0udG9VcHBlckNhc2UoKSArIGtleS5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncy5wdXNoLmFwcGx5KGJpbmRpbmdzLCBfX3NwcmVhZCh0aGlzLnBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdChiaW5kaW5ncywgW10gLyogd2FybmluZ3MgKi8sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgZGlyZWN0aXZlIGtleXdvcmQsIGZvbGxvd2VkIGJ5IGEgbWFuZGF0b3J5IGV4cHJlc3Npb24uXG4gICAgICogRm9yIGV4YW1wbGUsIFwib2YgaXRlbXNcIiwgXCJ0cmFja0J5OiBmdW5jXCIuXG4gICAgICogVGhlIGJpbmRpbmdzIGFyZTogbmdGb3JPZiAtPiBpdGVtcywgbmdGb3JUcmFja0J5IC0+IGZ1bmNcbiAgICAgKiBUaGVyZSBjb3VsZCBiZSBhbiBvcHRpb25hbCBcImFzXCIgYmluZGluZyB0aGF0IGZvbGxvd3MgdGhlIGV4cHJlc3Npb24uXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtcyB8IHNsaWNlOjA6MSBhcyBjb2xsZWN0aW9uXCIuXG4gICAgICogICAgICAgICAgICAgICAgICAgIF5eIF5eXl5eXl5eXl5eXl5eXl5eIF5eXl5eXl5eXl5eXl5cbiAgICAgKiAgICAgICAgICAgICAgIGtleXdvcmQgICAgYm91bmQgdGFyZ2V0ICAgb3B0aW9uYWwgJ2FzJyBiaW5kaW5nXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IGJpbmRpbmcga2V5LCBmb3IgZXhhbXBsZSwgbmdGb3IsIG5nSWYsIG5nRm9yT2YsIGFsb25nIHdpdGggaXRzXG4gICAgICogYWJzb2x1dGUgc3Bhbi5cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKTsgLy8gdHJhY2tCeTogdHJhY2tCeUZ1bmN0aW9uXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RGlyZWN0aXZlQm91bmRUYXJnZXQoKTtcbiAgICAgICAgdmFyIHNwYW5FbmQgPSB0aGlzLmN1cnJlbnRBYnNvbHV0ZU9mZnNldDtcbiAgICAgICAgLy8gVGhlIGJpbmRpbmcgY291bGQgb3B0aW9uYWxseSBiZSBmb2xsb3dlZCBieSBcImFzXCIuIEZvciBleGFtcGxlLFxuICAgICAgICAvLyAqbmdJZj1cImNvbmQgfCBwaXBlIGFzIHhcIi4gSW4gdGhpcyBjYXNlLCB0aGUga2V5IGluIHRoZSBcImFzXCIgYmluZGluZ1xuICAgICAgICAvLyBpcyBcInhcIiBhbmQgdGhlIHZhbHVlIGlzIHRoZSB0ZW1wbGF0ZSBrZXkgaXRzZWxmIChcIm5nSWZcIikuIE5vdGUgdGhhdCB0aGVcbiAgICAgICAgLy8gJ2tleScgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBub3cgYmVjb21lcyB0aGUgXCJ2YWx1ZVwiIGluIHRoZSBuZXh0IGJpbmRpbmcuXG4gICAgICAgIHZhciBhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgIGlmICghYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgICBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleS5zcGFuLnN0YXJ0LCBzcGFuRW5kKTtcbiAgICAgICAgYmluZGluZ3MucHVzaChuZXcgRXhwcmVzc2lvbkJpbmRpbmcoc291cmNlU3Bhbiwga2V5LCB2YWx1ZSkpO1xuICAgICAgICBpZiAoYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKGFzQmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmdzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBleHByZXNzaW9uIEFTVCBmb3IgdGhlIGJvdW5kIHRhcmdldCBvZiBhIGRpcmVjdGl2ZSBrZXl3b3JkXG4gICAgICogYmluZGluZy4gRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICAqbmdJZj1cImNvbmRpdGlvbiB8IHBpcGVcIlxuICAgICAqICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXl4gYm91bmQgdGFyZ2V0IGZvciBcIm5nSWZcIlxuICAgICAqICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBeXl5eXiBib3VuZCB0YXJnZXQgZm9yIFwibmdGb3JPZlwiXG4gICAgICogYGBgXG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5nZXREaXJlY3RpdmVCb3VuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCA9PT0gRU9GIHx8IHRoaXMucGVla0tleXdvcmRBcygpIHx8IHRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7IC8vIGV4YW1wbGU6IFwiY29uZGl0aW9uIHwgYXN5bmNcIlxuICAgICAgICB2YXIgX2EgPSBhc3Quc3Bhbiwgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgdmFsdWUsIHRoaXMubG9jYXRpb24sIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyBzdGFydCwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaW5kaW5nIGZvciBhIHZhcmlhYmxlIGRlY2xhcmVkIHVzaW5nIGBhc2AuIE5vdGUgdGhhdCB0aGUgb3JkZXJcbiAgICAgKiBvZiB0aGUga2V5LXZhbHVlIHBhaXIgaW4gdGhpcyBkZWNsYXJhdGlvbiBpcyByZXZlcnNlZC4gRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtczsgaW5kZXggYXMgaVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXiAgICBeXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICBrZXlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBuYW1lIG9mIHRoZSB2YWx1ZSBpbiB0aGUgZGVjbGFyYXRpb24sIFwibmdJZlwiIGluIHRoZSBleGFtcGxlXG4gICAgICogYWJvdmUsIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNwYW4uXG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUFzQmluZGluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSB0aGUgJ2FzJyBrZXl3b3JkXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IEFic29sdXRlU291cmNlU3Bhbih2YWx1ZS5zcGFuLnN0YXJ0LCB0aGlzLmN1cnJlbnRBYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVCaW5kaW5nKHNvdXJjZVNwYW4sIGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaW5kaW5nIGZvciBhIHZhcmlhYmxlIGRlY2xhcmVkIHVzaW5nIGBsZXRgLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaT1pbmRleDtcIlxuICAgICAqICAgICAgICAgICBeXl5eXl5eXiAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICAgKiBgYGBcbiAgICAgKiBJbiB0aGUgZmlyc3QgYmluZGluZywgYGl0ZW1gIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRgLlxuICAgICAqIEluIHRoZSBzZWNvbmQgYmluZGluZywgYGlgIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC5pbmRleGAuXG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxldEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BhblN0YXJ0ID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSAnbGV0JyBrZXl3b3JkXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdW1lU3RhdGVtZW50VGVybWluYXRvcigpO1xuICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oc3BhblN0YXJ0LCB0aGlzLmN1cnJlbnRBYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVCaW5kaW5nKHNvdXJjZVNwYW4sIGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSB0aGUgb3B0aW9uYWwgc3RhdGVtZW50IHRlcm1pbmF0b3I6IHNlbWljb2xvbiBvciBjb21tYS5cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSB8fCB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09NTUEpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoaW5kZXgpLCB0aGlzLmxvY2F0aW9uKSk7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgIH07XG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5sb2NhdGlvblRleHQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKVxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICByZXR1cm4gKGluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IFwiYXQgY29sdW1uIFwiICsgKHRoaXMudG9rZW5zW2luZGV4XS5pbmRleCArIDEpICsgXCIgaW5cIiA6XG4gICAgICAgICAgICBcImF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb25cIjtcbiAgICB9O1xuICAgIC8vIEVycm9yIHJlY292ZXJ5IHNob3VsZCBza2lwIHRva2VucyB1bnRpbCBpdCBlbmNvdW50ZXJzIGEgcmVjb3ZlcnkgcG9pbnQuIHNraXAoKSB0cmVhdHNcbiAgICAvLyB0aGUgZW5kIG9mIGlucHV0IGFuZCBhICc7JyBhcyB1bmNvbmRpdGlvbmFsbHkgYSByZWNvdmVyeSBwb2ludC4gSXQgYWxzbyB0cmVhdHMgJyknLFxuICAgIC8vICd9JyBhbmQgJ10nIGFzIGNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50cyBpZiBvbmUgb2YgY2FsbGluZyBwcm9kdWN0aW9ucyBpcyBleHBlY3RpbmdcbiAgICAvLyBvbmUgb2YgdGhlc2Ugc3ltYm9scy4gVGhpcyBhbGxvd3Mgc2tpcCgpIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMgc3VjaCBhcyAnKGEuKSArIDEnIGFsbG93aW5nXG4gICAgLy8gbW9yZSBvZiB0aGUgQVNUIHRvIGJlIHJldGFpbmVkIChpdCBkb2Vzbid0IHNraXAgYW55IHRva2VucyBhcyB0aGUgJyknIGlzIHJldGFpbmVkIGJlY2F1c2VcbiAgICAvLyBvZiB0aGUgJygnIGJlZ2lucyBhbiAnKCcgPGV4cHI+ICcpJyBwcm9kdWN0aW9uKS4gVGhlIHJlY292ZXJ5IHBvaW50cyBvZiBncm91cGluZyBzeW1ib2xzXG4gICAgLy8gbXVzdCBiZSBjb25kaXRpb25hbCBhcyB0aGV5IG11c3QgYmUgc2tpcHBlZCBpZiBub25lIG9mIHRoZSBjYWxsaW5nIHByb2R1Y3Rpb25zIGFyZSBub3RcbiAgICAvLyBleHBlY3RpbmcgdGhlIGNsb3NpbmcgdG9rZW4gZWxzZSB3ZSB3aWxsIG5ldmVyIG1ha2UgcHJvZ3Jlc3MgaW4gdGhlIGNhc2Ugb2YgYW5cbiAgICAvLyBleHRyYW5lb3VzIGdyb3VwIGNsb3Npbmcgc3ltYm9sIChzdWNoIGFzIGEgc3RyYXkgJyknKS4gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yICc7JyBiZWNhdXNlXG4gICAgLy8gcGFyc2VDaGFpbigpIGlzIGFsd2F5cyB0aGUgcm9vdCBwcm9kdWN0aW9uIGFuZCBpdCBleHBlY3RzIGEgJzsnLlxuICAgIC8vIElmIGEgcHJvZHVjdGlvbiBleHBlY3RzIG9uZSBvZiB0aGVzZSB0b2tlbiBpdCBpbmNyZW1lbnRzIHRoZSBjb3JyZXNwb25kaW5nIG5lc3RpbmcgY291bnQsXG4gICAgLy8gYW5kIHRoZW4gZGVjcmVtZW50cyBpdCBqdXN0IHByaW9yIHRvIGNoZWNraW5nIGlmIHRoZSB0b2tlbiBpcyBpbiB0aGUgaW5wdXQuXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIW4uaXNDaGFyYWN0ZXIoJFNFTUlDT0xPTikgJiZcbiAgICAgICAgICAgICh0aGlzLnJwYXJlbnNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSUEFSRU4pKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNlc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDRSkpICYmXG4gICAgICAgICAgICAodGhpcy5yYnJhY2tldHNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0tFVCkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzRXJyb3IoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKHRoaXMubmV4dC50b1N0cmluZygpLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dCgpLCB0aGlzLmxvY2F0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfUGFyc2VBU1Q7XG59KCkpO1xudmFyIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgIH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTtcbiAgICB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Tm9uTnVsbEFzc2VydCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKCdwaXBlcycpO1xuICAgIH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG59KCkpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIgdXNlZCBpbiBWaWV3IEVuZ2luZSBhbmQgcGVyZm9ybXMgbW9yZSBzdHJpY3QgY2hlY2tzIHRvXG4gKiBtYWtlIHN1cmUgaG9zdCBiaW5kaW5ncyBkbyBub3QgY29udGFpbiBwaXBlcy4gSW4gVmlldyBFbmdpbmUsIGhhdmluZyBwaXBlcyBpbiBob3N0IGJpbmRpbmdzIGlzXG4gKiBub3Qgc3VwcG9ydGVkIGFzIHdlbGwsIGJ1dCBpbiBzb21lIGNhc2VzIChsaWtlIGAhKHZhbHVlIHwgYXN5bmMpYCkgdGhlIGVycm9yIGlzIG5vdCB0cmlnZ2VyZWQgYXRcbiAqIGNvbXBpbGUgdGltZS4gSW4gb3JkZXIgdG8gcHJlc2VydmUgVmlldyBFbmdpbmUgYmVoYXZpb3IsIG1vcmUgc3RyaWN0IGNoZWNrcyBhcmUgaW50cm9kdWNlZCBmb3JcbiAqIEl2eSBtb2RlIG9ubHkuXG4gKi9cbnZhciBJdnlTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSXZ5U2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSXZ5U2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSXZ5U2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGVmdC52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnJpZ2h0LnZpc2l0KHRoaXMpO1xuICAgIH07XG4gICAgSXZ5U2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBJdnlTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcjtcbn0oU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICBETyBOT1QgRURJVCBUSElTIExJU1QgT0YgU0VDVVJJVFkgU0VOU0lUSVZFIFBST1BFUlRJRVMgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWNoIG91dCB0byBtcHJvYnN0IGZvciBkZXRhaWxzLlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKiBNYXAgZnJvbSB0YWdOYW1lfHByb3BlcnR5TmFtZSBTZWN1cml0eUNvbnRleHQuIFByb3BlcnRpZXMgYXBwbHlpbmcgdG8gYWxsIHRhZ3MgdXNlICcqJy4gKi9cbnZhciBfU0VDVVJJVFlfU0NIRU1BO1xuZnVuY3Rpb24gU0VDVVJJVFlfU0NIRU1BKCkge1xuICAgIGlmICghX1NFQ1VSSVRZX1NDSEVNQSkge1xuICAgICAgICBfU0VDVVJJVFlfU0NIRU1BID0ge307XG4gICAgICAgIC8vIENhc2UgaXMgaW5zaWduaWZpY2FudCBiZWxvdywgYWxsIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBuYW1lcyBhcmUgbG93ZXItY2FzZWQgZm9yIGxvb2t1cC5cbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5IVE1MLCBbXG4gICAgICAgICAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgICAgICAgICAnKnxpbm5lckhUTUwnLFxuICAgICAgICAgICAgJyp8b3V0ZXJIVE1MJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuU1RZTEUsIFsnKnxzdHlsZSddKTtcbiAgICAgICAgLy8gTkI6IG5vIFNDUklQVCBjb250ZXh0cyBoZXJlLCB0aGV5IGFyZSBuZXZlciBhbGxvd2VkIGR1ZSB0byB0aGUgcGFyc2VyIHN0cmlwcGluZyB0aGVtLlxuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlVSTCwgW1xuICAgICAgICAgICAgJyp8Zm9ybUFjdGlvbicsICdhcmVhfGhyZWYnLCAnYXJlYXxwaW5nJywgJ2F1ZGlvfHNyYycsICdhfGhyZWYnLFxuICAgICAgICAgICAgJ2F8cGluZycsICdibG9ja3F1b3RlfGNpdGUnLCAnYm9keXxiYWNrZ3JvdW5kJywgJ2RlbHxjaXRlJywgJ2Zvcm18YWN0aW9uJyxcbiAgICAgICAgICAgICdpbWd8c3JjJywgJ2ltZ3xzcmNzZXQnLCAnaW5wdXR8c3JjJywgJ2luc3xjaXRlJywgJ3F8Y2l0ZScsXG4gICAgICAgICAgICAnc291cmNlfHNyYycsICdzb3VyY2V8c3Jjc2V0JywgJ3RyYWNrfHNyYycsICd2aWRlb3xwb3N0ZXInLCAndmlkZW98c3JjJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgICAgICAgICAnYXBwbGV0fGNvZGUnLFxuICAgICAgICAgICAgJ2FwcGxldHxjb2RlYmFzZScsXG4gICAgICAgICAgICAnYmFzZXxocmVmJyxcbiAgICAgICAgICAgICdlbWJlZHxzcmMnLFxuICAgICAgICAgICAgJ2ZyYW1lfHNyYycsXG4gICAgICAgICAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAgICAgICAgICdodG1sfG1hbmlmZXN0JyxcbiAgICAgICAgICAgICdpZnJhbWV8c3JjJyxcbiAgICAgICAgICAgICdsaW5rfGhyZWYnLFxuICAgICAgICAgICAgJ21lZGlhfHNyYycsXG4gICAgICAgICAgICAnb2JqZWN0fGNvZGViYXNlJyxcbiAgICAgICAgICAgICdvYmplY3R8ZGF0YScsXG4gICAgICAgICAgICAnc2NyaXB0fHNyYycsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gX1NFQ1VSSVRZX1NDSEVNQTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dChjdHgsIHNwZWNzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgc3BlY3NfMSA9IF9fdmFsdWVzKHNwZWNzKSwgc3BlY3NfMV8xID0gc3BlY3NfMS5uZXh0KCk7ICFzcGVjc18xXzEuZG9uZTsgc3BlY3NfMV8xID0gc3BlY3NfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBzcGVjID0gc3BlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgX1NFQ1VSSVRZX1NDSEVNQVtzcGVjLnRvTG93ZXJDYXNlKCldID0gY3R4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc3BlY3NfMV8xICYmICFzcGVjc18xXzEuZG9uZSAmJiAoX2EgPSBzcGVjc18xLnJldHVybikpIF9hLmNhbGwoc3BlY3NfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgfVxuICAgIHJldHVybiBFbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQk9PTEVBTiA9ICdib29sZWFuJztcbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcbnZhciBTVFJJTkcgPSAnc3RyaW5nJztcbnZhciBPQkpFQ1QgPSAnb2JqZWN0Jztcbi8qKlxuICogVGhpcyBhcnJheSByZXByZXNlbnRzIHRoZSBET00gc2NoZW1hLiBJdCBlbmNvZGVzIGluaGVyaXRhbmNlLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICpcbiAqICMjIE92ZXJ2aWV3XG4gKlxuICogRWFjaCBsaW5lIHJlcHJlc2VudHMgb25lIGtpbmQgb2YgZWxlbWVudC4gVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBhbmQgcHJvcGVydGllcyBhcmUgam9pbmVkXG4gKiB1c2luZyBgZWxlbWVudF9pbmhlcml0YW5jZXxwcm9wZXJ0aWVzYCBzeW50YXguXG4gKlxuICogIyMgRWxlbWVudCBJbmhlcml0YW5jZVxuICpcbiAqIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgY2FuIGJlIGZ1cnRoZXIgc3ViZGl2aWRlZCBhcyBgZWxlbWVudDEsZWxlbWVudDIsLi4uXnBhcmVudEVsZW1lbnRgLlxuICogSGVyZSB0aGUgaW5kaXZpZHVhbCBlbGVtZW50cyBhcmUgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRXZlcnkgZWxlbWVudCBpbiB0aGUgbGlzdFxuICogaGFzIGlkZW50aWNhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEFuIGBlbGVtZW50YCBtYXkgaW5oZXJpdCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZnJvbSBgcGFyZW50RWxlbWVudGAgSWYgbm8gYF5wYXJlbnRFbGVtZW50YCBpc1xuICogc3BlY2lmaWVkIHRoZW4gYFwiXCJgIChibGFuaykgZWxlbWVudCBpcyBhc3N1bWVkLlxuICpcbiAqIE5PVEU6IFRoZSBibGFuayBlbGVtZW50IGluaGVyaXRzIGZyb20gcm9vdCBgW0VsZW1lbnRdYCBlbGVtZW50LCB0aGUgc3VwZXIgZWxlbWVudCBvZiBhbGxcbiAqIGVsZW1lbnRzLlxuICpcbiAqIE5PVEUgYW4gZWxlbWVudCBwcmVmaXggc3VjaCBhcyBgOnN2ZzpgIGhhcyBubyBzcGVjaWFsIG1lYW5pbmcgdG8gdGhlIHNjaGVtYS5cbiAqXG4gKiAjIyBQcm9wZXJ0aWVzXG4gKlxuICogRWFjaCBlbGVtZW50IGhhcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEVhY2ggcHJvcGVydHkgY2FuIGJlIHByZWZpeGVkXG4gKiBieSBhIHNwZWNpYWwgY2hhcmFjdGVyIGRlc2lnbmF0aW5nIGl0cyB0eXBlOlxuICpcbiAqIC0gKG5vIHByZWZpeCk6IHByb3BlcnR5IGlzIGEgc3RyaW5nLlxuICogLSBgKmA6IHByb3BlcnR5IHJlcHJlc2VudHMgYW4gZXZlbnQuXG4gKiAtIGAhYDogcHJvcGVydHkgaXMgYSBib29sZWFuLlxuICogLSBgI2A6IHByb3BlcnR5IGlzIGEgbnVtYmVyLlxuICogLSBgJWA6IHByb3BlcnR5IGlzIGFuIG9iamVjdC5cbiAqXG4gKiAjIyBRdWVyeVxuICpcbiAqIFRoZSBjbGFzcyBjcmVhdGVzIGFuIGludGVybmFsIHNxdWFzIHJlcHJlc2VudGF0aW9uIHdoaWNoIGFsbG93cyB0byBlYXNpbHkgYW5zd2VyIHRoZSBxdWVyeSBvZlxuICogaWYgYSBnaXZlbiBwcm9wZXJ0eSBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgeWV0IHN1cHBvcnQgcXVlcnlpbmcgZm9yIHR5cGVzIG9yIGV2ZW50cy5cbiAqIE5PVEU6IFRoaXMgc2NoZW1hIGlzIGF1dG8gZXh0cmFjdGVkIGZyb20gYHNjaGVtYV9leHRyYWN0b3IudHNgIGxvY2F0ZWQgaW4gdGhlIHRlc3QgZm9sZGVyLFxuICogICAgICAgc2VlIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV9zcGVjLnRzXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBET00gU0NIRU1BIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vL1xuLy8gTmV3bHkgYWRkZWQgcHJvcGVydGllcyBtdXN0IGJlIHNlY3VyaXR5IHJldmlld2VkIGFuZCBhc3NpZ25lZCBhbiBhcHByb3ByaWF0ZSBTZWN1cml0eUNvbnRleHQgaW5cbi8vIGRvbV9zZWN1cml0eV9zY2hlbWEudHMuIFJlYWNoIG91dCB0byBtcHJvYnN0ICYgcmphbWV0IGZvciBkZXRhaWxzLlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbnZhciBTQ0hFTUEgPSBbXG4gICAgJ1tFbGVtZW50XXx0ZXh0Q29udGVudCwlY2xhc3NMaXN0LGNsYXNzTmFtZSxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmNvcHksKmN1dCwqcGFzdGUsKnNlYXJjaCwqc2VsZWN0c3RhcnQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJIVE1MLCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3Asc2xvdCcgK1xuICAgICAgICAvKiBhZGRlZCBtYW51YWxseSB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzICovXG4gICAgICAgICcsKm1lc3NhZ2UsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkJyxcbiAgICAnW0hUTUxFbGVtZW50XV5bRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICdhYmJyLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiLGJkaSxiZG8sY2l0ZSxjb2RlLGRkLGRmbixkdCxlbSxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGksa2JkLG1haW4sbWFyayxuYXYsbm9zY3JpcHQscmIscnAscnQscnRjLHJ1YnkscyxzYW1wLHNlY3Rpb24sc21hbGwsc3Ryb25nLHN1YixzdXAsdSx2YXIsd2JyXltIVE1MRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICdtZWRpYV5bSFRNTEVsZW1lbnRdfCFhdXRvcGxheSwhY29udHJvbHMsJWNvbnRyb2xzTGlzdCwlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwqd2FpdGluZ2ZvcmtleSwjcGxheWJhY2tSYXRlLHByZWxvYWQsc3JjLCVzcmNPYmplY3QsI3ZvbHVtZScsXG4gICAgJzpzdmc6XltIVE1MRWxlbWVudF18KmFib3J0LCphdXhjbGljaywqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjdWVjaGFuZ2UsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmdvdHBvaW50ZXJjYXB0dXJlLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCpsb3N0cG9pbnRlcmNhcHR1cmUsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCpwYXVzZSwqcGxheSwqcGxheWluZywqcG9pbnRlcmNhbmNlbCwqcG9pbnRlcmRvd24sKnBvaW50ZXJlbnRlciwqcG9pbnRlcmxlYXZlLCpwb2ludGVybW92ZSwqcG9pbnRlcm91dCwqcG9pbnRlcm92ZXIsKnBvaW50ZXJ1cCwqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsJXN0eWxlLCN0YWJJbmRleCcsXG4gICAgJzpzdmc6Z3JhcGhpY3NeOnN2Zzp8JyxcbiAgICAnOnN2ZzphbmltYXRpb25eOnN2Zzp8KmJlZ2luLCplbmQsKnJlcGVhdCcsXG4gICAgJzpzdmc6Z2VvbWV0cnleOnN2Zzp8JyxcbiAgICAnOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uXjpzdmc6fCcsXG4gICAgJzpzdmc6Z3JhZGllbnReOnN2Zzp8JyxcbiAgICAnOnN2Zzp0ZXh0Q29udGVudF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6dGV4dFBvc2l0aW9uaW5nXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAnYV5bSFRNTEVsZW1lbnRdfGNoYXJzZXQsY29vcmRzLGRvd25sb2FkLGhhc2gsaG9zdCxob3N0bmFtZSxocmVmLGhyZWZsYW5nLG5hbWUscGFzc3dvcmQscGF0aG5hbWUscGluZyxwb3J0LHByb3RvY29sLHJlZmVycmVyUG9saWN5LHJlbCxyZXYsc2VhcmNoLHNoYXBlLHRhcmdldCx0ZXh0LHR5cGUsdXNlcm5hbWUnLFxuICAgICdhcmVhXltIVE1MRWxlbWVudF18YWx0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZiwhbm9IcmVmLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwsc2VhcmNoLHNoYXBlLHRhcmdldCx1c2VybmFtZScsXG4gICAgJ2F1ZGlvXm1lZGlhfCcsXG4gICAgJ2JyXltIVE1MRWxlbWVudF18Y2xlYXInLFxuICAgICdiYXNlXltIVE1MRWxlbWVudF18aHJlZix0YXJnZXQnLFxuICAgICdib2R5XltIVE1MRWxlbWVudF18YUxpbmssYmFja2dyb3VuZCxiZ0NvbG9yLGxpbmssKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQsdGV4dCx2TGluaycsXG4gICAgJ2J1dHRvbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsIWRpc2FibGVkLGZvcm1BY3Rpb24sZm9ybUVuY3R5cGUsZm9ybU1ldGhvZCwhZm9ybU5vVmFsaWRhdGUsZm9ybVRhcmdldCxuYW1lLHR5cGUsdmFsdWUnLFxuICAgICdjYW52YXNeW0hUTUxFbGVtZW50XXwjaGVpZ2h0LCN3aWR0aCcsXG4gICAgJ2NvbnRlbnReW0hUTUxFbGVtZW50XXxzZWxlY3QnLFxuICAgICdkbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAnZGF0YWxpc3ReW0hUTUxFbGVtZW50XXwnLFxuICAgICdkZXRhaWxzXltIVE1MRWxlbWVudF18IW9wZW4nLFxuICAgICdkaWFsb2deW0hUTUxFbGVtZW50XXwhb3BlbixyZXR1cm5WYWx1ZScsXG4gICAgJ2Rpcl5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAnZGl2XltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdlbWJlZF5bSFRNTEVsZW1lbnRdfGFsaWduLGhlaWdodCxuYW1lLHNyYyx0eXBlLHdpZHRoJyxcbiAgICAnZmllbGRzZXReW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbmFtZScsXG4gICAgJ2ZvbnReW0hUTUxFbGVtZW50XXxjb2xvcixmYWNlLHNpemUnLFxuICAgICdmb3JtXltIVE1MRWxlbWVudF18YWNjZXB0Q2hhcnNldCxhY3Rpb24sYXV0b2NvbXBsZXRlLGVuY29kaW5nLGVuY3R5cGUsbWV0aG9kLG5hbWUsIW5vVmFsaWRhdGUsdGFyZ2V0JyxcbiAgICAnZnJhbWVeW0hUTUxFbGVtZW50XXxmcmFtZUJvcmRlcixsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSwhbm9SZXNpemUsc2Nyb2xsaW5nLHNyYycsXG4gICAgJ2ZyYW1lc2V0XltIVE1MRWxlbWVudF18Y29scywqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCpvZmZsaW5lLCpvbmxpbmUsKnBhZ2VoaWRlLCpwYWdlc2hvdywqcG9wc3RhdGUsKnJlamVjdGlvbmhhbmRsZWQsKnJlc2l6ZSwqc2Nyb2xsLCpzdG9yYWdlLCp1bmhhbmRsZWRyZWplY3Rpb24sKnVubG9hZCxyb3dzJyxcbiAgICAnaHJeW0hUTUxFbGVtZW50XXxhbGlnbixjb2xvciwhbm9TaGFkZSxzaXplLHdpZHRoJyxcbiAgICAnaGVhZF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2XltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdodG1sXltIVE1MRWxlbWVudF18dmVyc2lvbicsXG4gICAgJ2lmcmFtZV5bSFRNTEVsZW1lbnRdfGFsaWduLCFhbGxvd0Z1bGxzY3JlZW4sZnJhbWVCb3JkZXIsaGVpZ2h0LGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLHJlZmVycmVyUG9saWN5LCVzYW5kYm94LHNjcm9sbGluZyxzcmMsc3JjZG9jLHdpZHRoJyxcbiAgICAnaW1nXltIVE1MRWxlbWVudF18YWxpZ24sYWx0LGJvcmRlciwlY3Jvc3NPcmlnaW4sI2hlaWdodCwjaHNwYWNlLCFpc01hcCxsb25nRGVzYyxsb3dzcmMsbmFtZSxyZWZlcnJlclBvbGljeSxzaXplcyxzcmMsc3Jjc2V0LHVzZU1hcCwjdnNwYWNlLCN3aWR0aCcsXG4gICAgJ2lucHV0XltIVE1MRWxlbWVudF18YWNjZXB0LGFsaWduLGFsdCxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhY2hlY2tlZCwhZGVmYXVsdENoZWNrZWQsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCVmaWxlcyxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsI2hlaWdodCwhaW5jcmVtZW50YWwsIWluZGV0ZXJtaW5hdGUsbWF4LCNtYXhMZW5ndGgsbWluLCNtaW5MZW5ndGgsIW11bHRpcGxlLG5hbWUscGF0dGVybixwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCwjc2l6ZSxzcmMsc3RlcCx0eXBlLHVzZU1hcCx2YWx1ZSwldmFsdWVBc0RhdGUsI3ZhbHVlQXNOdW1iZXIsI3dpZHRoJyxcbiAgICAnbGleW0hUTUxFbGVtZW50XXx0eXBlLCN2YWx1ZScsXG4gICAgJ2xhYmVsXltIVE1MRWxlbWVudF18aHRtbEZvcicsXG4gICAgJ2xlZ2VuZF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnbGlua15bSFRNTEVsZW1lbnRdfGFzLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkaXNhYmxlZCxocmVmLGhyZWZsYW5nLGludGVncml0eSxtZWRpYSxyZWZlcnJlclBvbGljeSxyZWwsJXJlbExpc3QscmV2LCVzaXplcyx0YXJnZXQsdHlwZScsXG4gICAgJ21hcF5bSFRNTEVsZW1lbnRdfG5hbWUnLFxuICAgICdtYXJxdWVlXltIVE1MRWxlbWVudF18YmVoYXZpb3IsYmdDb2xvcixkaXJlY3Rpb24saGVpZ2h0LCNoc3BhY2UsI2xvb3AsI3Njcm9sbEFtb3VudCwjc2Nyb2xsRGVsYXksIXRydWVTcGVlZCwjdnNwYWNlLHdpZHRoJyxcbiAgICAnbWVudV5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAnbWV0YV5bSFRNTEVsZW1lbnRdfGNvbnRlbnQsaHR0cEVxdWl2LG5hbWUsc2NoZW1lJyxcbiAgICAnbWV0ZXJeW0hUTUxFbGVtZW50XXwjaGlnaCwjbG93LCNtYXgsI21pbiwjb3B0aW11bSwjdmFsdWUnLFxuICAgICdpbnMsZGVsXltIVE1MRWxlbWVudF18Y2l0ZSxkYXRlVGltZScsXG4gICAgJ29sXltIVE1MRWxlbWVudF18IWNvbXBhY3QsIXJldmVyc2VkLCNzdGFydCx0eXBlJyxcbiAgICAnb2JqZWN0XltIVE1MRWxlbWVudF18YWxpZ24sYXJjaGl2ZSxib3JkZXIsY29kZSxjb2RlQmFzZSxjb2RlVHlwZSxkYXRhLCFkZWNsYXJlLGhlaWdodCwjaHNwYWNlLG5hbWUsc3RhbmRieSx0eXBlLHVzZU1hcCwjdnNwYWNlLHdpZHRoJyxcbiAgICAnb3B0Z3JvdXBeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbGFiZWwnLFxuICAgICdvcHRpb25eW0hUTUxFbGVtZW50XXwhZGVmYXVsdFNlbGVjdGVkLCFkaXNhYmxlZCxsYWJlbCwhc2VsZWN0ZWQsdGV4dCx2YWx1ZScsXG4gICAgJ291dHB1dF5bSFRNTEVsZW1lbnRdfGRlZmF1bHRWYWx1ZSwlaHRtbEZvcixuYW1lLHZhbHVlJyxcbiAgICAncF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAncGFyYW1eW0hUTUxFbGVtZW50XXxuYW1lLHR5cGUsdmFsdWUsdmFsdWVUeXBlJyxcbiAgICAncGljdHVyZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ByZV5bSFRNTEVsZW1lbnRdfCN3aWR0aCcsXG4gICAgJ3Byb2dyZXNzXltIVE1MRWxlbWVudF18I21heCwjdmFsdWUnLFxuICAgICdxLGJsb2NrcXVvdGUsY2l0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3NjcmlwdF5bSFRNTEVsZW1lbnRdfCFhc3luYyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGVmZXIsZXZlbnQsaHRtbEZvcixpbnRlZ3JpdHksc3JjLHRleHQsdHlwZScsXG4gICAgJ3NlbGVjdF5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsIWRpc2FibGVkLCNsZW5ndGgsIW11bHRpcGxlLG5hbWUsIXJlcXVpcmVkLCNzZWxlY3RlZEluZGV4LCNzaXplLHZhbHVlJyxcbiAgICAnc2hhZG93XltIVE1MRWxlbWVudF18JyxcbiAgICAnc2xvdF5bSFRNTEVsZW1lbnRdfG5hbWUnLFxuICAgICdzb3VyY2VeW0hUTUxFbGVtZW50XXxtZWRpYSxzaXplcyxzcmMsc3Jjc2V0LHR5cGUnLFxuICAgICdzcGFuXltIVE1MRWxlbWVudF18JyxcbiAgICAnc3R5bGVeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbWVkaWEsdHlwZScsXG4gICAgJ2NhcHRpb25eW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3RoLHRkXltIVE1MRWxlbWVudF18YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICdjb2wsY29sZ3JvdXBeW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZiwjc3Bhbix2QWxpZ24sd2lkdGgnLFxuICAgICd0YWJsZV5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsYm9yZGVyLCVjYXB0aW9uLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGZyYW1lLHJ1bGVzLHN1bW1hcnksJXRGb290LCV0SGVhZCx3aWR0aCcsXG4gICAgJ3RyXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0Zm9vdCx0aGVhZCx0Ym9keV5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3RlbXBsYXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAndGV4dGFyZWFeW0hUTUxFbGVtZW50XXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGVeW0hUTUxFbGVtZW50XXx0ZXh0JyxcbiAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6YW5pbWF0ZV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6Y2lyY2xlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVmc146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAnOnN2ZzplbGxpcHNlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9uZW50VHJhbnNmZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpZmZ1c2VMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURyb3BTaGFkb3deOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNCXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUdhdXNzaWFuQmx1cl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZU5vZGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlUG9pbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUaWxlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgJzpzdmc6Zm9yZWlnbk9iamVjdF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGZvcm0sa2V5dHlwZSxuYW1lJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8Jyxcbl07XG52YXIgX0FUVFJfVE9fUFJPUCA9IHtcbiAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICdmb3JtYWN0aW9uJzogJ2Zvcm1BY3Rpb24nLFxuICAgICdpbm5lckh0bWwnOiAnaW5uZXJIVE1MJyxcbiAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG59O1xudmFyIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICBTQ0hFTUEuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RlZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0ge307XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKSwgMiksIHN0clR5cGUgPSBfYVswXSwgc3RyUHJvcGVydGllcyA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBzdHJQcm9wZXJ0aWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoc3RyVHlwZS5zcGxpdCgnXicpLCAyKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7IHJldHVybiBfdGhpcy5fc2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IHR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHN1cGVyVHlwZSA9IHN1cGVyTmFtZSAmJiBfdGhpcy5fc2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdXBlclR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wXSA9IHN1cGVyVHlwZVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB5ZXQgc3VwcG9ydCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZXZlciBhbGxvd2luZyB0byBiaW5kIHRvIGV2ZW50cywgR08gVEhST1VHSCBBIFNFQ1VSSVRZIFJFVklFVywgYWxsb3dpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbW9zdCBjZXJ0YWlubHkgaW50cm9kdWNlIGJhZCBYU1MgdnVsbmVyYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEVWRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gQk9PTEVBTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE5VTUJFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE9CSkVDVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eV0gPSBTVFJJTkc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAvLyBvbmNlIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuX3NjaGVtYVsndW5rbm93biddO1xuICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc0VsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBzZWN1cml0eUNvbnRleHQgcmV0dXJucyB0aGUgc2VjdXJpdHkgY29udGV4dCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBET00gdGFnLlxuICAgICAqXG4gICAgICogVGFnIGFuZCBwcm9wZXJ0eSBuYW1lIGFyZSBzdGF0aWNhbGx5IGtub3duIGFuZCBjYW5ub3QgY2hhbmdlIGF0IHJ1bnRpbWUsIGkuZS4gaXQgaXMgbm90XG4gICAgICogcG9zc2libGUgdG8gYmluZCBhIHZhbHVlIGludG8gYSBjaGFuZ2luZyBhdHRyaWJ1dGUgb3IgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGUgZmlsdGVyaW5nIGlzIGJhc2VkIG9uIGEgbGlzdCBvZiBhbGxvd2VkIHRhZ3N8YXR0cmlidXRlcy4gQWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHNjaGVtYVxuICAgICAqIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlICdOT05FJyBzZWN1cml0eSBjb250ZXh0LCBpLmUuIHRoYXQgdGhleSBhcmUgc2FmZSBpbmVydFxuICAgICAqIHN0cmluZyB2YWx1ZXMuIE9ubHkgc3BlY2lmaWMgd2VsbCBrbm93biBhdHRhY2sgdmVjdG9ycyBhcmUgYXNzaWduZWQgdGhlaXIgYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQSgpW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BKClbJyp8JyArIHByb3BOYW1lXTtcbiAgICAgICAgcmV0dXJuIGN0eCA/IGN0eCA6IFNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gX0FUVFJfVE9fUFJPUFtwcm9wTmFtZV0gfHwgcHJvcE5hbWU7XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICduZy1jb21wb25lbnQnO1xuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJCaW5kaW5nIHRvIGV2ZW50IHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIgK1xuICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIikgK1xuICAgICAgICAgICAgICAgIChcIlxcbklmICdcIiArIG5hbWUgKyBcIicgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZVwiKSArXG4gICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJCaW5kaW5nIHRvIGV2ZW50IGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwbGVhc2UgdXNlIChcIiArIG5hbWUuc2xpY2UoMikgKyBcIik9Li4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5hbGxLbm93bkVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVtYSk7XG4gICAgfTtcbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcE5hbWUpO1xuICAgIH07XG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVZhbHVlID0gZnVuY3Rpb24gKGNhbWVsQ2FzZVByb3AsIHVzZXJQcm92aWRlZFByb3AsIHZhbCkge1xuICAgICAgICB2YXIgdW5pdCA9ICcnO1xuICAgICAgICB2YXIgc3RyVmFsID0gdmFsLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB2YXIgZXJyb3JNc2cgPSBudWxsO1xuICAgICAgICBpZiAoX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShjYW1lbENhc2VQcm9wKSAmJiB2YWwgIT09IDAgJiYgdmFsICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsQW5kU3VmZml4TWF0Y2ggJiYgdmFsQW5kU3VmZml4TWF0Y2hbMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBcIlBsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yIFwiICsgdXNlclByb3ZpZGVkUHJvcCArIFwiOlwiICsgdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2csIHZhbHVlOiBzdHJWYWwgKyB1bml0IH07XG4gICAgfTtcbiAgICByZXR1cm4gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xufShFbGVtZW50U2NoZW1hUmVnaXN0cnkpKTtcbmZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGNhc2UgJ21pbldpZHRoJzpcbiAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICBjYXNlICdtYXhIZWlnaHQnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0xlZnQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luVG9wJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgIGNhc2UgJ21hcmdpblJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJUb3BXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJCb3R0b21XaWR0aCc6XG4gICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQklORF9OQU1FX1JFR0VYUCQxID0gL14oPzooPzooPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKikpfFxcW1xcKChbXlxcKV0rKVxcKVxcXXxcXFsoW15cXF1dKylcXF18XFwoKFteXFwpXSspXFwpKSQvO1xuLy8gR3JvdXAgMSA9IFwiYmluZC1cIlxudmFyIEtXX0JJTkRfSURYJDEgPSAxO1xuLy8gR3JvdXAgMiA9IFwibGV0LVwiXG52YXIgS1dfTEVUX0lEWCQxID0gMjtcbi8vIEdyb3VwIDMgPSBcInJlZi0vI1wiXG52YXIgS1dfUkVGX0lEWCQxID0gMztcbi8vIEdyb3VwIDQgPSBcIm9uLVwiXG52YXIgS1dfT05fSURYJDEgPSA0O1xuLy8gR3JvdXAgNSA9IFwiYmluZG9uLVwiXG52YXIgS1dfQklORE9OX0lEWCQxID0gNTtcbi8vIEdyb3VwIDYgPSBcIkBcIlxudmFyIEtXX0FUX0lEWCQxID0gNjtcbi8vIEdyb3VwIDcgPSB0aGUgaWRlbnRpZmllciBhZnRlciBcImJpbmQtXCIsIFwibGV0LVwiLCBcInJlZi0vI1wiLCBcIm9uLVwiLCBcImJpbmRvbi1cIiBvciBcIkBcIlxudmFyIElERU5UX0tXX0lEWCQxID0gNztcbi8vIEdyb3VwIDggPSBpZGVudGlmaWVyIGluc2lkZSBbKCldXG52YXIgSURFTlRfQkFOQU5BX0JPWF9JRFgkMSA9IDg7XG4vLyBHcm91cCA5ID0gaWRlbnRpZmllciBpbnNpZGUgW11cbnZhciBJREVOVF9QUk9QRVJUWV9JRFgkMSA9IDk7XG4vLyBHcm91cCAxMCA9IGlkZW50aWZpZXIgaW5zaWRlICgpXG52YXIgSURFTlRfRVZFTlRfSURYJDEgPSAxMDtcbnZhciBURU1QTEFURV9BVFRSX1BSRUZJWCQyID0gJyonO1xuZnVuY3Rpb24gaHRtbEFzdFRvUmVuZGVyM0FzdChodG1sTm9kZXMsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgSHRtbEFzdFRvSXZ5QXN0KGJpbmRpbmdQYXJzZXIpO1xuICAgIHZhciBpdnlOb2RlcyA9IHZpc2l0QWxsJDEodHJhbnNmb3JtZXIsIGh0bWxOb2Rlcyk7XG4gICAgLy8gRXJyb3JzIG1pZ2h0IG9yaWdpbmF0ZSBpbiBlaXRoZXIgdGhlIGJpbmRpbmcgcGFyc2VyIG9yIHRoZSBodG1sIHRvIGl2eSB0cmFuc2Zvcm1lclxuICAgIHZhciBhbGxFcnJvcnMgPSBiaW5kaW5nUGFyc2VyLmVycm9ycy5jb25jYXQodHJhbnNmb3JtZXIuZXJyb3JzKTtcbiAgICB2YXIgZXJyb3JzID0gYWxsRXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9KTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nLCBlcnJvcnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogaXZ5Tm9kZXMsXG4gICAgICAgIGVycm9yczogYWxsRXJyb3JzLFxuICAgICAgICBzdHlsZVVybHM6IHRyYW5zZm9ybWVyLnN0eWxlVXJscyxcbiAgICAgICAgc3R5bGVzOiB0cmFuc2Zvcm1lci5zdHlsZXMsXG4gICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdHJhbnNmb3JtZXIubmdDb250ZW50U2VsZWN0b3JzLFxuICAgIH07XG59XG52YXIgSHRtbEFzdFRvSXZ5QXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWxBc3RUb0l2eUFzdChiaW5kaW5nUGFyc2VyKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ1BhcnNlciA9IGJpbmRpbmdQYXJzZXI7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gW107XG4gICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gW107XG4gICAgICAgIHRoaXMuaW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSFRNTCB2aXNpdG9yXG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlzSTE4blJvb3RFbGVtZW50ID0gaXNJMThuUm9vdE5vZGUoZWxlbWVudC5pMThuKTtcbiAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Nhbm5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBvZiBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uLiBQbGVhc2UgcmVtb3ZlIHRoZSBuZXN0ZWQgaTE4biBtYXJrZXIuJywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50cyA9IHRleHRDb250ZW50cyhlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChjb250ZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2goY29udGVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUICYmXG4gICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMucHVzaChwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYSBgPG5nLXRlbXBsYXRlPmBcbiAgICAgICAgdmFyIGlzVGVtcGxhdGVFbGVtZW50ID0gaXNOZ1RlbXBsYXRlKGVsZW1lbnQubmFtZSk7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHZhciBib3VuZEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgdmFyaWFibGVzID0gW107XG4gICAgICAgIHZhciByZWZlcmVuY2VzID0gW107XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHZhciBpMThuQXR0cnNNZXRhID0ge307XG4gICAgICAgIHZhciB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdmFyIHRlbXBsYXRlVmFyaWFibGVzID0gW107XG4gICAgICAgIC8vIFdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIGFueSAqLWF0dHJpYnV0ZVxuICAgICAgICB2YXIgZWxlbWVudEhhc0lubGluZVRlbXBsYXRlID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGVsZW1lbnQuYXR0cnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBoYXNCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYCphdHRyYCBkZWZpbmVzIHRlbXBsYXRlIGJpbmRpbmdzXG4gICAgICAgICAgICAgICAgdmFyIGlzVGVtcGxhdGVCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pMThuKSB7XG4gICAgICAgICAgICAgICAgICAgIGkxOG5BdHRyc01ldGFbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLmkxOG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYJDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICotYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudEhhc0lubGluZVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwiQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBwcmVmaXhlZCB3aXRoICpcIiwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzVGVtcGxhdGVCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEhhc0lubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUtleSA9IG5vcm1hbGl6ZWROYW1lLnN1YnN0cmluZyhURU1QTEFURV9BVFRSX1BSRUZJWCQyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFic29sdXRlVmFsdWVPZmZzZXQgPSBhdHRyaWJ1dGUudmFsdWVTcGFuID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHZhbHVlIHNwYW4gdGhlIGF0dHJpYnV0ZSBkb2VzIG5vdCBoYXZlIGEgdmFsdWUsIGxpa2UgYGF0dHJgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2A8ZGl2IGF0dHI+PC9kaXY+YC4gSW4gdGhpcyBjYXNlLCBwb2ludCB0byBvbmUgY2hhcmFjdGVyIGJleW9uZCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCArIGF0dHJpYnV0ZS5uYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKHRlbXBsYXRlS2V5LCB0ZW1wbGF0ZVZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3BhbiwgYWJzb2x1dGVWYWx1ZU9mZnNldCwgW10sIHRlbXBsYXRlUGFyc2VkUHJvcGVydGllcywgcGFyc2VkVmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVWYXJpYWJsZXMucHVzaC5hcHBseSh0ZW1wbGF0ZVZhcmlhYmxlcywgX19zcHJlYWQocGFyc2VkVmFyaWFibGVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFZhcmlhYmxlKHYubmFtZSwgdi52YWx1ZSwgdi5zb3VyY2VTcGFuLCB2LnZhbHVlU3Bhbik7IH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdmFyaWFibGVzLCBldmVudHMsIHByb3BlcnR5IGJpbmRpbmdzLCBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXR0cmlidXRlKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyaWJ1dGUsIFtdLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNCaW5kaW5nICYmICFpc1RlbXBsYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2godGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCQxKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUgPyBOT05fQklOREFCTEVfVklTSVRPUiQxIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIHZhciBwYXJzZWRFbGVtZW50O1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAvLyBgPG5nLWNvbnRlbnQ+YFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudC5jaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gaXNFbXB0eVRleHROb2RlKG5vZGUpIHx8IGlzQ29tbWVudE5vZGUobm9kZSk7IH0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIjxuZy1jb250ZW50PiBlbGVtZW50IGNhbm5vdCBoYXZlIGNvbnRlbnQuXCIsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHI7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBlbGVtZW50LmF0dHJzLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gX3RoaXMudmlzaXRBdHRyaWJ1dGUoYXR0cik7IH0pO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBDb250ZW50KHNlbGVjdG9yLCBhdHRycywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgICAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGA8bmctdGVtcGxhdGU+YFxuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcyhlbGVtZW50Lm5hbWUsIHBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBUZW1wbGF0ZShlbGVtZW50Lm5hbWUsIGF0dHJpYnV0ZXMsIGF0dHJzLmJvdW5kLCBib3VuZEV2ZW50cywgWyAvKiBubyB0ZW1wbGF0ZSBhdHRyaWJ1dGVzICovXSwgY2hpbGRyZW4sIHJlZmVyZW5jZXMsIHZhcmlhYmxlcywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcyhlbGVtZW50Lm5hbWUsIHBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgYXR0cmlidXRlcywgYXR0cnMuYm91bmQsIGJvdW5kRXZlbnRzLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgbm9kZSBpcyBhbiBpbmxpbmUtdGVtcGxhdGUgKGUuZy4gaGFzICpuZ0ZvcikgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHRlbXBsYXRlXG4gICAgICAgICAgICAvLyBub2RlIHRoYXQgY29udGFpbnMgdGhpcyBub2RlLlxuICAgICAgICAgICAgLy8gTW9yZW92ZXIsIGlmIHRoZSBub2RlIGlzIGFuIGVsZW1lbnQsIHRoZW4gd2UgbmVlZCB0byBob2lzdCBpdHMgYXR0cmlidXRlcyB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIG5vZGUgZm9yIG1hdGNoaW5nIGFnYWluc3QgY29udGVudCBwcm9qZWN0aW9uIHNlbGVjdG9ycy5cbiAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMuZXh0cmFjdEF0dHJpYnV0ZXMoJ25nLXRlbXBsYXRlJywgdGVtcGxhdGVQYXJzZWRQcm9wZXJ0aWVzLCBpMThuQXR0cnNNZXRhKTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUF0dHJzXzEgPSBbXTtcbiAgICAgICAgICAgIGF0dHJzLmxpdGVyYWwuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gdGVtcGxhdGVBdHRyc18xLnB1c2goYXR0cik7IH0pO1xuICAgICAgICAgICAgYXR0cnMuYm91bmQuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gdGVtcGxhdGVBdHRyc18xLnB1c2goYXR0cik7IH0pO1xuICAgICAgICAgICAgdmFyIGhvaXN0ZWRBdHRycyA9IHBhcnNlZEVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50ID9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlZEVsZW1lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBwYXJzZWRFbGVtZW50LmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcGFyc2VkRWxlbWVudC5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHsgYXR0cmlidXRlczogW10sIGlucHV0czogW10sIG91dHB1dHM6IFtdIH07XG4gICAgICAgICAgICAvLyBGb3IgPG5nLXRlbXBsYXRlPnMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgb24gdGhlbSwgYXZvaWQgcGFzc2luZyBpMThuIGluZm9ybWF0aW9uIHRvXG4gICAgICAgICAgICAvLyB0aGUgd3JhcHBpbmcgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBpMThuIGluc3RydWN0aW9ucyBmcm9tIGJlaW5nIGdlbmVyYXRlZC4gVGhlXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgaTE4biBtZXRhIGluZm9ybWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkIGZyb20gY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICB2YXIgaTE4bl8xID0gaXNUZW1wbGF0ZUVsZW1lbnQgJiYgaXNJMThuUm9vdEVsZW1lbnQgPyB1bmRlZmluZWQgOiBlbGVtZW50LmkxOG47XG4gICAgICAgICAgICAvLyBUT0RPKHBrKTogdGVzdCBmb3IgdGhpcyBjYXNlXG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IFRlbXBsYXRlKHBhcnNlZEVsZW1lbnQubmFtZSwgaG9pc3RlZEF0dHJzLmF0dHJpYnV0ZXMsIGhvaXN0ZWRBdHRycy5pbnB1dHMsIGhvaXN0ZWRBdHRycy5vdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzXzEsIFtwYXJzZWRFbGVtZW50XSwgWyAvKiBubyByZWZlcmVuY2VzICovXSwgdGVtcGxhdGVWYXJpYWJsZXMsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgaTE4bl8xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJMThuUm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkRWxlbWVudDtcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0ZXh0LmkxOG4pO1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFleHBhbnNpb24uaTE4bikge1xuICAgICAgICAgICAgLy8gZG8gbm90IGdlbmVyYXRlIEljdSBpbiBjYXNlIGl0IHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBvdXRzaWRlIG9mIGkxOG4gYmxvY2sgaW4gYSB0ZW1wbGF0ZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0kxOG5Sb290Tm9kZShleHBhbnNpb24uaTE4bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSBcXFwiXCIgKyBleHBhbnNpb24uaTE4bi5jb25zdHJ1Y3RvciArIFwiXFxcIiBmb3IgXFxcImkxOG5cXFwiIHByb3BlcnR5IG9mIFwiICsgZXhwYW5zaW9uLnNvdXJjZVNwYW4udG9TdHJpbmcoKSArIFwiLiBFeHBlY3RlZCBhIFxcXCJNZXNzYWdlXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IGV4cGFuc2lvbi5pMThuO1xuICAgICAgICB2YXIgdmFycyA9IHt9O1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICAgIC8vIGV4dHJhY3QgVkFScyBmcm9tIElDVXMgLSB3ZSBwcm9jZXNzIHRoZW0gc2VwYXJhdGVseSB3aGlsZVxuICAgICAgICAvLyBhc3NlbWJsaW5nIHJlc3VsdGluZyBtZXNzYWdlIHZpYSBnb29nLmdldE1zZyBmdW5jdGlvbiwgc2luY2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwYXNzIHRoZW0gdG8gdG9wLWxldmVsIGdvb2cuZ2V0TXNnIGNhbGxcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5wbGFjZWhvbGRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbWVzc2FnZS5wbGFjZWhvbGRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChJMThOX0lDVV9WQVJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBfdGhpcy5iaW5kaW5nUGFyc2VyLmludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgICAgICAgICAgLy8gSUNVIGV4cHJlc3Npb24gaXMgYSBwbGFpbiBzdHJpbmcsIG5vdCB3cmFwcGVkIGludG8gc3RhcnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZW5kIHRhZ3MsIHNvIHdlIHdyYXAgaXQgYmVmb3JlIHBhc3NpbmcgdG8gYmluZGluZyBwYXJzZXJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IFwiXCIgKyBjb25maWcuc3RhcnQgKyB2YWx1ZSArIGNvbmZpZy5lbmQ7XG4gICAgICAgICAgICAgICAgdmFyc1trZXldID0gX3RoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHdyYXBwZWQsIGV4cGFuc2lvbi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyc1trZXldID0gX3RoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHZhbHVlLCBleHBhbnNpb24uc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdSh2YXJzLCBwbGFjZWhvbGRlcnMsIGV4cGFuc2lvbi5zb3VyY2VTcGFuLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8gY29udmVydCB2aWV3IGVuZ2luZSBgUGFyc2VkUHJvcGVydHlgIHRvIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBJVllcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLmV4dHJhY3RBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wZXJ0aWVzLCBpMThuUHJvcHNNZXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBib3VuZCA9IFtdO1xuICAgICAgICB2YXIgbGl0ZXJhbCA9IFtdO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBpMThuID0gaTE4blByb3BzTWV0YVtwcm9wLm5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3AuaXNMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbC5wdXNoKG5ldyBUZXh0QXR0cmlidXRlKHByb3AubmFtZSwgcHJvcC5leHByZXNzaW9uLnNvdXJjZSB8fCAnJywgcHJvcC5zb3VyY2VTcGFuLCB1bmRlZmluZWQsIGkxOG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB2YWxpZGF0aW9uIGlzIHNraXBwZWQgYW5kIHByb3BlcnR5IG1hcHBpbmcgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBkdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhIGdpdmVuIHByb3AgaXMgbm90IGFuXG4gICAgICAgICAgICAgICAgLy8gaW5wdXQgb2YgYSBkaXJlY3RpdmUgYW5kIGRpcmVjdGl2ZSBtYXRjaGluZyBoYXBwZW5zIGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICAgICAgdmFyIGJlcCA9IF90aGlzLmJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRFbGVtZW50UHJvcGVydHkoZWxlbWVudE5hbWUsIHByb3AsIC8qIHNraXBWYWxpZGF0aW9uICovIHRydWUsIC8qIG1hcFByb3BlcnR5TmFtZSAqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYm91bmQucHVzaChCb3VuZEF0dHJpYnV0ZS5mcm9tQm91bmRFbGVtZW50UHJvcGVydHkoYmVwLCBpMThuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBib3VuZDogYm91bmQsIGxpdGVyYWw6IGxpdGVyYWwgfTtcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUucGFyc2VBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHJpYnV0ZSwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywgYm91bmRFdmVudHMsIHZhcmlhYmxlcywgcmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgbmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgIHZhciBzcmNTcGFuID0gYXR0cmlidXRlLnNvdXJjZVNwYW47XG4gICAgICAgIHZhciBhYnNvbHV0ZU9mZnNldCA9IGF0dHJpYnV0ZS52YWx1ZVNwYW4gPyBhdHRyaWJ1dGUudmFsdWVTcGFuLnN0YXJ0Lm9mZnNldCA6IHNyY1NwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICB2YXIgYmluZFBhcnRzID0gbmFtZS5tYXRjaChCSU5EX05BTUVfUkVHRVhQJDEpO1xuICAgICAgICB2YXIgaGFzQmluZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYmluZFBhcnRzKSB7XG4gICAgICAgICAgICBoYXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChiaW5kUGFydHNbS1dfQklORF9JRFgkMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfS1dfSURYJDFdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19MRVRfSURYJDFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWCQxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBuZy10ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFgkMV07XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfT05fSURYJDFdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9LV19JRFgkMV0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IHNyY1NwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKGV2ZW50cywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0JJTkRPTl9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0tXX0lEWCQxXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYJDFdLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0FUX0lEWCQxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYJDFdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWCQxXSwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGJvdW5kRXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFgkMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWCQxXSwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYJDFdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFgkMV0sIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IHNyY1NwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGV2ZW50cyk7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKGV2ZW50cywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0JpbmRpbmc7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB2YXIgdmFsdWVOb05nc3AgPSByZXBsYWNlTmdzcCh2YWx1ZSk7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZU5vTmdzcCwgc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBleHByID8gbmV3IEJvdW5kVGV4dChleHByLCBzb3VyY2VTcGFuLCBpMThuKSA6IG5ldyBUZXh0KHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIEh0bWxBc3RUb0l2eUFzdC5wcm90b3R5cGUucGFyc2VWYXJpYWJsZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoXCJWYXJpYWJsZSBkb2VzIG5vdCBoYXZlIGEgbmFtZVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZXMucHVzaChuZXcgVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbikpO1xuICAgIH07XG4gICAgSHRtbEFzdFRvSXZ5QXN0LnByb3RvdHlwZS5wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKFwiXFxcIi1cXFwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZGVudGlmaWVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihcIlJlZmVyZW5jZSBkb2VzIG5vdCBoYXZlIGEgbmFtZVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGJvdW5kRXZlbnRzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdmFsdWVTcGFuIHx8IHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBldmVudHMpO1xuICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgfTtcbiAgICBIdG1sQXN0VG9JdnlBc3QucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlRXJyb3Ioc291cmNlU3BhbiwgbWVzc2FnZSwgbGV2ZWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sQXN0VG9JdnlBc3Q7XG59KCkpO1xudmFyIE5vbkJpbmRhYmxlVmlzaXRvciQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vbkJpbmRhYmxlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsJDEodGhpcywgYXN0LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGFzdC5uYW1lLCB2aXNpdEFsbCQxKHRoaXMsIGFzdC5hdHRycyksIFxuICAgICAgICAvKiBpbnB1dHMgKi8gW10sIC8qIG91dHB1dHMgKi8gW10sIGNoaWxkcmVuLCAvKiByZWZlcmVuY2VzICovIFtdLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0YXJ0U291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3BhbiwgdW5kZWZpbmVkLCBhdHRyaWJ1dGUuaTE4bik7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE5vbkJpbmRhYmxlVmlzaXRvcjtcbn0oKSk7XG52YXIgTk9OX0JJTkRBQkxFX1ZJU0lUT1IkMSA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IkMSgpO1xuZnVuY3Rpb24gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyTmFtZSkge1xuICAgIHJldHVybiAvXmRhdGEtL2kudGVzdChhdHRyTmFtZSkgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKSB7XG4gICAgYm91bmRFdmVudHMucHVzaC5hcHBseShib3VuZEV2ZW50cywgX19zcHJlYWQoZXZlbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gQm91bmRFdmVudC5mcm9tUGFyc2VkRXZlbnQoZSk7IH0pKSk7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCQzICYmIG5vZGUudmFsdWUudHJpbSgpLmxlbmd0aCA9PSAwO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb21tZW50O1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnRzKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIShub2RlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVGV4dCQzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuWzBdLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRhZ1R5cGU7XG4oZnVuY3Rpb24gKFRhZ1R5cGUpIHtcbiAgICBUYWdUeXBlW1RhZ1R5cGVbXCJFTEVNRU5UXCJdID0gMF0gPSBcIkVMRU1FTlRcIjtcbiAgICBUYWdUeXBlW1RhZ1R5cGVbXCJURU1QTEFURVwiXSA9IDFdID0gXCJURU1QTEFURVwiO1xuICAgIFRhZ1R5cGVbVGFnVHlwZVtcIlBST0pFQ1RJT05cIl0gPSAyXSA9IFwiUFJPSkVDVElPTlwiO1xufSkoVGFnVHlwZSB8fCAoVGFnVHlwZSA9IHt9KSk7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBvYmplY3QgdGhhdCBpcyB1c2VkIGFzIGEgc2hhcmVkIHN0YXRlIGJldHdlZW4gcGFyZW50IGFuZCBhbGwgY2hpbGQgY29udGV4dHMuXG4gKi9cbmZ1bmN0aW9uIHNldHVwUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIHsgZ2V0VW5pcXVlSWQ6IGdldFNlcU51bWJlckdlbmVyYXRvcigpLCBpY3VzOiBuZXcgTWFwKCkgfTtcbn1cbi8qKlxuICogSTE4bkNvbnRleHQgaXMgYSBoZWxwZXIgY2xhc3Mgd2hpY2gga2VlcHMgdHJhY2sgb2YgYWxsIGkxOG4tcmVsYXRlZCBhc3BlY3RzXG4gKiAoYWNjdW11bGF0ZXMgcGxhY2Vob2xkZXJzLCBiaW5kaW5ncywgZXRjKSBiZXR3ZWVuIGkxOG5TdGFydCBhbmQgaTE4bkVuZCBpbnN0cnVjdGlvbnMuXG4gKlxuICogV2hlbiB3ZSBlbnRlciBhIG5lc3RlZCB0ZW1wbGF0ZSwgdGhlIHRvcC1sZXZlbCBjb250ZXh0IGlzIGJlaW5nIHBhc3NlZCBkb3duXG4gKiB0byB0aGUgbmVzdGVkIGNvbXBvbmVudCwgd2hpY2ggdXNlcyB0aGlzIGNvbnRleHQgdG8gZ2VuZXJhdGUgYSBjaGlsZCBpbnN0YW5jZVxuICogb2YgSTE4bkNvbnRleHQgY2xhc3MgKHRvIGhhbmRsZSBuZXN0ZWQgdGVtcGxhdGUpIGFuZCBhdCB0aGUgZW5kLCByZWNvbmNpbGVzIGl0IGJhY2tcbiAqIHdpdGggdGhlIHBhcmVudCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBpbmRleCBJbnN0cnVjdGlvbiBpbmRleCBvZiBpMThuU3RhcnQsIHdoaWNoIGluaXRpYXRlcyB0aGlzIGNvbnRleHRcbiAqIEBwYXJhbSByZWYgUmVmZXJlbmNlIHRvIGEgdHJhbnNsYXRpb24gY29uc3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IGlmIHRodXMgY29udGV4dFxuICogQHBhcmFtIGxldmVsIE5lc3RuZyBsZXZlbCBkZWZpbmVkIGZvciBjaGlsZCBjb250ZXh0c1xuICogQHBhcmFtIHRlbXBsYXRlSW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgYSB0ZW1wbGF0ZSB3aGljaCB0aGlzIGNvbnRleHQgYmVsb25ncyB0b1xuICogQHBhcmFtIG1ldGEgTWV0YSBpbmZvcm1hdGlvbiAoaWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBldGMpIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRleHRcbiAqL1xudmFyIEkxOG5Db250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEkxOG5Db250ZXh0KGluZGV4LCByZWYsIGxldmVsLCB0ZW1wbGF0ZUluZGV4LCBtZXRhLCByZWdpc3RyeSkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IDA7IH1cbiAgICAgICAgaWYgKHRlbXBsYXRlSW5kZXggPT09IHZvaWQgMCkgeyB0ZW1wbGF0ZUluZGV4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXNFbWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gcmVnaXN0cnkgfHwgc2V0dXBSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5fcmVnaXN0cnkuZ2V0VW5pcXVlSWQoKTtcbiAgICB9XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZFRhZyA9IGZ1bmN0aW9uICh0eXBlLCBub2RlLCBpbmRleCwgY2xvc2VkKSB7XG4gICAgICAgIGlmIChub2RlLmlzVm9pZCAmJiBjbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gaWdub3JlIFwiY2xvc2VcIiBmb3Igdm9pZCB0YWdzXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBoID0gbm9kZS5pc1ZvaWQgfHwgIWNsb3NlZCA/IG5vZGUuc3RhcnROYW1lIDogbm9kZS5jbG9zZU5hbWU7XG4gICAgICAgIHZhciBjb250ZW50ID0geyB0eXBlOiB0eXBlLCBpbmRleDogaW5kZXgsIGN0eDogdGhpcy5pZCwgaXNWb2lkOiBub2RlLmlzVm9pZCwgY2xvc2VkOiBjbG9zZWQgfTtcbiAgICAgICAgdXBkYXRlUGxhY2Vob2xkZXJNYXAodGhpcy5wbGFjZWhvbGRlcnMsIHBoLCBjb250ZW50KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJMThuQ29udGV4dC5wcm90b3R5cGUsIFwiaWN1c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LmljdXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJMThuQ29udGV4dC5wcm90b3R5cGUsIFwiaXNSb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXZlbCA9PT0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEkxOG5Db250ZXh0LnByb3RvdHlwZSwgXCJpc1Jlc29sdmVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50ID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVzLCBrZXkpIHsgcmV0dXJuIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZXMubWFwKHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUpKTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBwdWJsaWMgQVBJIHRvIGFjY3VtdWxhdGUgaTE4bi1yZWxhdGVkIGNvbnRlbnRcbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUuYXBwZW5kQmluZGluZyA9IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuYWRkKGJpbmRpbmcpO1xuICAgIH07XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZEljdSA9IGZ1bmN0aW9uIChuYW1lLCByZWYpIHtcbiAgICAgICAgdXBkYXRlUGxhY2Vob2xkZXJNYXAodGhpcy5fcmVnaXN0cnkuaWN1cywgbmFtZSwgcmVmKTtcbiAgICB9O1xuICAgIEkxOG5Db250ZXh0LnByb3RvdHlwZS5hcHBlbmRCb3VuZFRleHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGhzID0gYXNzZW1ibGVCb3VuZFRleHRQbGFjZWhvbGRlcnMobm9kZSwgdGhpcy5iaW5kaW5ncy5zaXplLCB0aGlzLmlkKTtcbiAgICAgICAgcGhzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywga2V5KSB7IHJldHVybiB1cGRhdGVQbGFjZWhvbGRlck1hcC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFtfdGhpcy5wbGFjZWhvbGRlcnMsIGtleV0sIHZhbHVlcykpOyB9KTtcbiAgICB9O1xuICAgIEkxOG5Db250ZXh0LnByb3RvdHlwZS5hcHBlbmRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgICAvLyBhZGQgb3BlbiBhbmQgY2xvc2UgdGFncyBhdCB0aGUgc2FtZSB0aW1lLFxuICAgICAgICAvLyBzaW5jZSB3ZSBwcm9jZXNzIG5lc3RlZCB0ZW1wbGF0ZXMgc2VwYXJhdGVseVxuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLlRFTVBMQVRFLCBub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLlRFTVBMQVRFLCBub2RlLCBpbmRleCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCsrO1xuICAgIH07XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZEVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLkVMRU1FTlQsIG5vZGUsIGluZGV4LCBjbG9zZWQpO1xuICAgIH07XG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmFwcGVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgICAgLy8gYWRkIG9wZW4gYW5kIGNsb3NlIHRhZ3MgYXQgdGhlIHNhbWUgdGltZSxcbiAgICAgICAgLy8gc2luY2Ugd2UgcHJvY2VzcyBwcm9qZWN0ZWQgY29udGVudCBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuUFJPSkVDVElPTiwgbm9kZSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5QUk9KRUNUSU9OLCBub2RlLCBpbmRleCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBjaGlsZCBjb250ZXh0IGJhc2VkIG9uIHRoZSByb290IG9uZSxcbiAgICAgKiB3aGVuIHdlIGVudGVyIGEgbmVzdGVkIHRlbXBsYXRlIHdpdGhpbiBJMThuIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgY29ycmVzcG9uZGluZyBpMThuU3RhcnQsIHdoaWNoIGluaXRpYXRlcyB0aGlzIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVJbmRleCBJbnN0cnVjdGlvbiBpbmRleCBvZiBhIHRlbXBsYXRlIHdoaWNoIHRoaXMgY29udGV4dCBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIG1ldGEgTWV0YSBpbmZvcm1hdGlvbiAoaWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBldGMpIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEkxOG5Db250ZXh0IGluc3RhbmNlXG4gICAgICovXG4gICAgSTE4bkNvbnRleHQucHJvdG90eXBlLmZvcmtDaGlsZENvbnRleHQgPSBmdW5jdGlvbiAoaW5kZXgsIHRlbXBsYXRlSW5kZXgsIG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJMThuQ29udGV4dChpbmRleCwgdGhpcy5yZWYsIHRoaXMubGV2ZWwgKyAxLCB0ZW1wbGF0ZUluZGV4LCBtZXRhLCB0aGlzLl9yZWdpc3RyeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWNvbmNpbGVzIGNoaWxkIGNvbnRleHQgaW50byBwYXJlbnQgb25lIG9uY2UgdGhlIGVuZCBvZiB0aGUgaTE4biBibG9jayBpcyByZWFjaGVkIChpMThuRW5kKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IENoaWxkIEkxOG5Db250ZXh0IGluc3RhbmNlIHRvIGJlIHJlY29uY2lsZWQgd2l0aCBwYXJlbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICBJMThuQ29udGV4dC5wcm90b3R5cGUucmVjb25jaWxlQ2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gc2V0IHRoZSByaWdodCBjb250ZXh0IGlkIGZvciBvcGVuIGFuZCBjbG9zZVxuICAgICAgICAvLyB0ZW1wbGF0ZSB0YWdzLCBzbyB3ZSBjYW4gdXNlIGl0IGFzIHN1Yi1ibG9jayBpZHNcbiAgICAgICAgWydzdGFydCcsICdjbG9zZSddLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY29udGV4dC5tZXRhW29wICsgXCJOYW1lXCJdO1xuICAgICAgICAgICAgdmFyIHBocyA9IF90aGlzLnBsYWNlaG9sZGVycy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgICAgIHZhciB0YWcgPSBwaHMuZmluZChmaW5kVGVtcGxhdGVGbihfdGhpcy5pZCwgY29udGV4dC50ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgdGFnLmN0eCA9IGNvbnRleHQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWNvbmNpbGUgcGxhY2Vob2xkZXJzXG4gICAgICAgIHZhciBjaGlsZFBocyA9IGNvbnRleHQucGxhY2Vob2xkZXJzO1xuICAgICAgICBjaGlsZFBocy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIGtleSkge1xuICAgICAgICAgICAgdmFyIHBocyA9IF90aGlzLnBsYWNlaG9sZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghcGhzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnNldChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgbWF0Y2hpbmcgdGVtcGxhdGUuLi5cbiAgICAgICAgICAgIHZhciB0bXBsSWR4ID0gcGhzLmZpbmRJbmRleChmaW5kVGVtcGxhdGVGbihjb250ZXh0LmlkLCBjb250ZXh0LnRlbXBsYXRlSW5kZXgpKTtcbiAgICAgICAgICAgIGlmICh0bXBsSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gaWYgZm91bmQgLSByZXBsYWNlIGl0IHdpdGggbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICB2YXIgaXNDbG9zZVRhZyA9IGtleS5zdGFydHNXaXRoKCdDTE9TRScpO1xuICAgICAgICAgICAgICAgIHZhciBpc1RlbXBsYXRlVGFnID0ga2V5LmVuZHNXaXRoKCdORy1URU1QTEFURScpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdGVtcGxhdGUncyBjb250ZW50IGlzIHBsYWNlZCBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IHRlbXBsYXRlIHRhZywgZGVwZW5kaW5nIG9uIHRoZSBvcGVuL2Nsb3NlIGF0cnJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBwaHMuc3BsaWNlLmFwcGx5KHBocywgX19zcHJlYWQoW3RtcGxJZHggKyAoaXNDbG9zZVRhZyA/IDAgOiAxKSwgMF0sIHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGlzQ2xvc2VUYWcgPyB2YWx1ZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdLnRtcGwgPSBwaHNbdG1wbElkeF07XG4gICAgICAgICAgICAgICAgICAgIHBocy5zcGxpY2UuYXBwbHkocGhzLCBfX3NwcmVhZChbdG1wbElkeCwgMV0sIHZhbHVlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UganVzdCBhcHBlbmQgY29udGVudCB0byBwbGFjZWhvbGRlciB2YWx1ZVxuICAgICAgICAgICAgICAgIHBocy5wdXNoLmFwcGx5KHBocywgX19zcHJlYWQodmFsdWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgcGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudC0tO1xuICAgIH07XG4gICAgcmV0dXJuIEkxOG5Db250ZXh0O1xufSgpKTtcbi8vXG4vLyBIZWxwZXIgbWV0aG9kc1xuLy9cbmZ1bmN0aW9uIHdyYXAoc3ltYm9sLCBpbmRleCwgY29udGV4dElkLCBjbG9zZWQpIHtcbiAgICB2YXIgc3RhdGUgPSBjbG9zZWQgPyAnLycgOiAnJztcbiAgICByZXR1cm4gd3JhcEkxOG5QbGFjZWhvbGRlcihcIlwiICsgc3RhdGUgKyBzeW1ib2wgKyBpbmRleCwgY29udGV4dElkKTtcbn1cbmZ1bmN0aW9uIHdyYXBUYWcoc3ltYm9sLCBfYSwgY2xvc2VkKSB7XG4gICAgdmFyIGluZGV4ID0gX2EuaW5kZXgsIGN0eCA9IF9hLmN0eCwgaXNWb2lkID0gX2EuaXNWb2lkO1xuICAgIHJldHVybiBpc1ZvaWQgPyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCkgKyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgdHJ1ZSkgOlxuICAgICAgICB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgY2xvc2VkKTtcbn1cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZUZuKGN0eCwgdGVtcGxhdGVJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4udHlwZSA9PT0gVGFnVHlwZS5URU1QTEFURSAmJlxuICAgICAgICB0b2tlbi5pbmRleCA9PT0gdGVtcGxhdGVJbmRleCAmJiB0b2tlbi5jdHggPT09IGN0eDsgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBjbG9zZWQpIHsgcmV0dXJuIHdyYXBUYWcoJyMnLCBkYXRhLCBjbG9zZWQpOyB9O1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBjbG9zZWQpIHsgcmV0dXJuIHdyYXBUYWcoJyonLCBkYXRhLCBjbG9zZWQpOyB9O1xuICAgIHZhciBwcm9qZWN0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGNsb3NlZCkgeyByZXR1cm4gd3JhcFRhZygnIScsIGRhdGEsIGNsb3NlZCk7IH07XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgVGFnVHlwZS5FTEVNRU5UOlxuICAgICAgICAgICAgLy8gY2xvc2UgZWxlbWVudCB0YWdcbiAgICAgICAgICAgIGlmICh2YWx1ZS5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudCh2YWx1ZSwgdHJ1ZSkgKyAodmFsdWUudG1wbCA/IHRlbXBsYXRlKHZhbHVlLnRtcGwsIHRydWUpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3BlbiBlbGVtZW50IHRhZyB0aGF0IGFsc28gaW5pdGlhdGVzIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIGlmICh2YWx1ZS50bXBsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHZhbHVlLnRtcGwpICsgZWxlbWVudCh2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAodmFsdWUuaXNWb2lkID8gdGVtcGxhdGUodmFsdWUudG1wbCwgdHJ1ZSkgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgVGFnVHlwZS5URU1QTEFURTpcbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh2YWx1ZSwgdmFsdWUuY2xvc2VkKTtcbiAgICAgICAgY2FzZSBUYWdUeXBlLlBST0pFQ1RJT046XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbih2YWx1ZSwgdmFsdWUuY2xvc2VkKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJY3VTZXJpYWxpemVyVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJY3VTZXJpYWxpemVyVmlzaXRvcigpIHtcbiAgICB9XG4gICAgSWN1U2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnZhbHVlO1xuICAgIH07XG4gICAgSWN1U2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignJyk7XG4gICAgfTtcbiAgICBJY3VTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwie1wiICsgaWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignICcpICsgXCJ9XCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBJY3VTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGgocGguc3RhcnROYW1lKSA6XG4gICAgICAgICAgICBcIlwiICsgdGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpICsgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKSArIHRoaXMuZm9ybWF0UGgocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIEljdVNlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH07XG4gICAgSWN1U2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfTtcbiAgICBJY3VTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUuZm9ybWF0UGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZSh2YWx1ZSwgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIEljdVNlcmlhbGl6ZXJWaXNpdG9yO1xufSgpKTtcbnZhciBzZXJpYWxpemVyID0gbmV3IEljdVNlcmlhbGl6ZXJWaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVJY3VOb2RlKGljdSkge1xuICAgIHJldHVybiBpY3UudmlzaXQoc2VyaWFsaXplcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMgPSB7XG4gICAgJ0EnOiAnTElOSycsXG4gICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAnQlInOiAnTElORV9CUkVBSycsXG4gICAgJ0VNJzogJ0VNUEhBU0lTRURfVEVYVCcsXG4gICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxuICAgICdIMyc6ICdIRUFESU5HX0xFVkVMMycsXG4gICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxuICAgICdINic6ICdIRUFESU5HX0xFVkVMNicsXG4gICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgJ0knOiAnSVRBTElDX1RFWFQnLFxuICAgICdMSSc6ICdMSVNUX0lURU0nLFxuICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxuICAgICdQJzogJ1BBUkFHUkFQSCcsXG4gICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxuICAgICdTTUFMTCc6ICdTTUFMTF9URVhUJyxcbiAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXG4gICAgJ1RCT0RZJzogJ1RBQkxFX0JPRFknLFxuICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcbiAgICAnVEgnOiAnVEFCTEVfSEVBREVSX0NFTEwnLFxuICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICdUUic6ICdUQUJMRV9ST1cnLFxuICAgICdUVCc6ICdNT05PU1BBQ0VEX1RFWFQnLFxuICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcbn07XG4vKipcbiAqIENyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBwbGFjZWhvbGRlciB3aXRoIGRpZmZlcmVudCBjb250ZW50LlxuICpcbiAqIFJldHVybnMgdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZSB3aGVuIHRoZSBjb250ZW50IGlzIGlkZW50aWNhbC5cbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXJSZWdpc3RyeSgpIHtcbiAgICAgICAgLy8gQ291bnQgdGhlIG9jY3VycmVuY2Ugb2YgdGhlIGJhc2UgbmFtZSB0b3AgZ2VuZXJhdGUgYSB1bmlxdWUgbmFtZVxuICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMgPSB7fTtcbiAgICAgICAgLy8gTWFwcyBzaWduYXR1cmUgdG8gcGxhY2Vob2xkZXIgbmFtZXNcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lID0ge307XG4gICAgfVxuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFzaFRhZyh0YWcsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZShpc1ZvaWQgPyBiYXNlTmFtZSA6IFwiU1RBUlRfXCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hDbG9zaW5nVGFnKHRhZyk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKFwiQ0xPU0VfXCIgKyBiYXNlTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAobmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gXCJQSDogXCIgKyB1cHBlck5hbWUgKyBcIj1cIiArIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlxdWVOYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKHVwcGVyTmFtZSk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gdW5pcXVlTmFtZTtcbiAgICAgICAgcmV0dXJuIHVuaXF1ZU5hbWU7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBmb3IgYSB0YWcgLSBkb2VzIG5vdCB0YWtlIGF0dHJpYnV0ZSBvcmRlciBpbnRvIGFjY291bnRcbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gXCI8XCIgKyB0YWc7XG4gICAgICAgIHZhciBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBcIiBcIiArIG5hbWUgKyBcIj1cIiArIGF0dHJzW25hbWVdOyB9KS5qb2luKCcnKTtcbiAgICAgICAgdmFyIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2hhc2hDbG9zaW5nVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzaFRhZyhcIi9cIiArIHRhZywge30sIGZhbHNlKTtcbiAgICB9O1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9nZW5lcmF0ZVVuaXF1ZU5hbWUgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICB2YXIgc2VlbiA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cy5oYXNPd25Qcm9wZXJ0eShiYXNlKTtcbiAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdO1xuICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSBpZCArIDE7XG4gICAgICAgIHJldHVybiBiYXNlICsgXCJfXCIgKyBpZDtcbiAgICB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlclJlZ2lzdHJ5O1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gY29udmVydGluZyBodG1sIG5vZGVzIHRvIGFuIGkxOG4gTWVzc2FnZSBnaXZlbiBhbiBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCwgdmlzaXROb2RlRm4pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudG9JMThuTWVzc2FnZShub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vb3BWaXNpdE5vZGVGbihfaHRtbCwgaTE4bikge1xuICAgIHJldHVybiBpMThuO1xufVxudmFyIF9JMThuVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnRvSTE4bk1lc3NhZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCwgdmlzaXROb2RlRm4pIHtcbiAgICAgICAgaWYgKG1lYW5pbmcgPT09IHZvaWQgMCkgeyBtZWFuaW5nID0gJyc7IH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSB2b2lkIDApIHsgZGVzY3JpcHRpb24gPSAnJzsgfVxuICAgICAgICBpZiAoY3VzdG9tSWQgPT09IHZvaWQgMCkgeyBjdXN0b21JZCA9ICcnOyB9XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgaXNJY3U6IG5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGVzWzBdIGluc3RhbmNlb2YgRXhwYW5zaW9uLFxuICAgICAgICAgICAgaWN1RGVwdGg6IDAsXG4gICAgICAgICAgICBwbGFjZWhvbGRlclJlZ2lzdHJ5OiBuZXcgUGxhY2Vob2xkZXJSZWdpc3RyeSgpLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJUb0NvbnRlbnQ6IHt9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJUb01lc3NhZ2U6IHt9LFxuICAgICAgICAgICAgdmlzaXROb2RlRm46IHZpc2l0Tm9kZUZuIHx8IG5vb3BWaXNpdE5vZGVGbixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGkxOG5vZGVzID0gdmlzaXRBbGwkMSh0aGlzLCBub2RlcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShpMThub2RlcywgY29udGV4dC5wbGFjZWhvbGRlclRvQ29udGVudCwgY29udGV4dC5wbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkKTtcbiAgICB9O1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsJDEodGhpcywgZWwuY2hpbGRyZW4sIGNvbnRleHQpO1xuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzVm9pZCA9IGdldEh0bWxUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZDtcbiAgICAgICAgdmFyIHN0YXJ0UGhOYW1lID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9IGVsLnNvdXJjZVNwYW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgIGlmICghaXNWb2lkKSB7XG4gICAgICAgICAgICBjbG9zZVBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb0NvbnRlbnRbY2xvc2VQaE5hbWVdID0gXCI8L1wiICsgZWwubmFtZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gbmV3IFRhZ1BsYWNlaG9sZGVyKGVsLm5hbWUsIGF0dHJzLCBzdGFydFBoTmFtZSwgY2xvc2VQaE5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gY29udGV4dC52aXNpdE5vZGVGbihlbCwgbm9kZSk7XG4gICAgfTtcbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY29udGV4dC52aXNpdE5vZGVGbihhdHRyaWJ1dGUsIG5vZGUpO1xuICAgIH07XG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHRleHQudmFsdWUsIHRleHQuc291cmNlU3BhbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKHRleHQsIG5vZGUpO1xuICAgIH07XG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRleHQuaWN1RGVwdGgrKztcbiAgICAgICAgdmFyIGkxOG5JY3VDYXNlcyA9IHt9O1xuICAgICAgICB2YXIgaTE4bkljdSA9IG5ldyBJY3UkMShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBpMThuSWN1Q2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgaWN1LmNhc2VzLmZvckVhY2goZnVuY3Rpb24gKGNhemUpIHtcbiAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywgY29udGV4dCk7IH0pLCBjYXplLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5pY3VEZXB0aC0tO1xuICAgICAgICBpZiAoY29udGV4dC5pc0ljdSB8fCBjb250ZXh0LmljdURlcHRoID4gMCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBhbiBJQ1Ugbm9kZSB3aGVuOlxuICAgICAgICAgICAgLy8gLSB0aGUgbWVzc2FnZSAodnMgYSBwYXJ0IG9mIHRoZSBtZXNzYWdlKSBpcyBhbiBJQ1UgbWVzc2FnZSwgb3JcbiAgICAgICAgICAgIC8vIC0gdGhlIElDVSBtZXNzYWdlIGlzIG5lc3RlZC5cbiAgICAgICAgICAgIHZhciBleHBQaCA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRVbmlxdWVQbGFjZWhvbGRlcihcIlZBUl9cIiArIGljdS50eXBlKTtcbiAgICAgICAgICAgIGkxOG5JY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyID0gZXhwUGg7XG4gICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W2V4cFBoXSA9IGljdS5zd2l0Y2hWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGljdSwgaTE4bkljdSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBzaG91bGQgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgb3JpZ2luYWwgY29udGVudCBidXQgd2l0aCB0aGUgdGhlaXJcbiAgICAgICAgLy8gdHJhbnNsYXRpb25zLlxuICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICB2YXIgcGhOYW1lID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGhOYW1lXSA9IHRoaXMudG9JMThuTWVzc2FnZShbaWN1XSwgJycsICcnLCAnJywgdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgSWN1UGxhY2Vob2xkZXIoaTE4bkljdSwgcGhOYW1lLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGljdSwgbm9kZSk7XG4gICAgfTtcbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChfaWN1Q2FzZSwgX2NvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfTtcbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzb3VyY2VTcGFuLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBzcGxpdEludGVycG9sYXRpb24gPSB0aGlzLl9leHByZXNzaW9uUGFyc2VyLnNwbGl0SW50ZXJwb2xhdGlvbih0ZXh0LCBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCksIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoIXNwbGl0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCQxKHRleHQsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIobm9kZXMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLCBzRGVsaW1pdGVyID0gX2Euc3RhcnQsIGVEZWxpbWl0ZXIgPSBfYS5lbmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHNwbGl0SW50ZXJwb2xhdGlvbi5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBiYXNlTmFtZSA9IF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGV4cHJlc3Npb24pIHx8ICdJTlRFUlBPTEFUSU9OJztcbiAgICAgICAgICAgIHZhciBwaE5hbWUgPSBjb250ZXh0LnBsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0UGxhY2Vob2xkZXJOYW1lKGJhc2VOYW1lLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFkZCBlbXB0eSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBQbGFjZWhvbGRlcihleHByZXNzaW9uLCBwaE5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb0NvbnRlbnRbcGhOYW1lXSA9IHNEZWxpbWl0ZXIgKyBleHByZXNzaW9uICsgZURlbGltaXRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbGFzdCBpbmRleCBjb250YWlucyBubyBleHByZXNzaW9uXG4gICAgICAgIHZhciBsYXN0U3RyaW5nSWR4ID0gc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIHJldHVybiBfSTE4blZpc2l0b3I7XG59KCkpO1xudmFyIF9DVVNUT01fUEhfRVhQID0gL1xcL1xcL1tcXHNcXFNdKmkxOG5bXFxzXFxTXSpcXChbXFxzXFxTXSpwaFtcXHNcXFNdKj1bXFxzXFxTXSooXCJ8JykoW1xcc1xcU10qPylcXDFbXFxzXFxTXSpcXCkvZztcbmZ1bmN0aW9uIF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnNwbGl0KF9DVVNUT01fUEhfRVhQKVsyXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIHNldEkxOG5SZWZzID0gZnVuY3Rpb24gKGh0bWxOb2RlLCBpMThuTm9kZSkge1xuICAgIGlmIChodG1sTm9kZSBpbnN0YW5jZW9mIE5vZGVXaXRoSTE4bikge1xuICAgICAgICBpZiAoaTE4bk5vZGUgaW5zdGFuY2VvZiBJY3VQbGFjZWhvbGRlciAmJiBodG1sTm9kZS5pMThuIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBodG1sIG5vZGUgcmVwcmVzZW50cyBhbiBJQ1UgYnV0IHRoaXMgaXMgYSBzZWNvbmQgcHJvY2Vzc2luZyBwYXNzLCBhbmQgdGhlIGxlZ2FjeSBpZFxuICAgICAgICAgICAgLy8gd2FzIGNvbXB1dGVkIGluIHRoZSBwcmV2aW91cyBwYXNzIGFuZCBzdG9yZWQgaW4gdGhlIGBpMThuYCBwcm9wZXJ0eSBhcyBhIG1lc3NhZ2UuXG4gICAgICAgICAgICAvLyBXZSBhcmUgYWJvdXQgdG8gd2lwZSBvdXQgdGhhdCBwcm9wZXJ0eSBzbyBjYXB0dXJlIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHJldXNlZCB3aGVuXG4gICAgICAgICAgICAvLyBnZW5lcmF0aW5nIHRoZSBtZXNzYWdlIGZvciB0aGlzIElDVSBsYXRlci4gU2VlIGBfZ2VuZXJhdGVJMThuTWVzc2FnZSgpYC5cbiAgICAgICAgICAgIGkxOG5Ob2RlLnByZXZpb3VzTWVzc2FnZSA9IGh0bWxOb2RlLmkxOG47XG4gICAgICAgIH1cbiAgICAgICAgaHRtbE5vZGUuaTE4biA9IGkxOG5Ob2RlO1xuICAgIH1cbiAgICByZXR1cm4gaTE4bk5vZGU7XG59O1xuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBIVE1MIHBhcnNlIHRyZWUgYW5kIGNvbnZlcnRzIGluZm9ybWF0aW9uIHN0b3JlZCBpblxuICogaTE4bi1yZWxhdGVkIGF0dHJpYnV0ZXMgKFwiaTE4blwiIGFuZCBcImkxOG4tKlwiKSBpbnRvIGkxOG4gbWV0YSBvYmplY3QgdGhhdCBpc1xuICogc3RvcmVkIHdpdGggb3RoZXIgZWxlbWVudCdzIGFuZCBhdHRyaWJ1dGUncyBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIEkxOG5NZXRhVmlzaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywga2VlcEkxOG5BdHRycywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCkge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIGlmIChrZWVwSTE4bkF0dHJzID09PSB2b2lkIDApIHsga2VlcEkxOG5BdHRycyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0ID09PSB2b2lkIDApIHsgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbkNvbmZpZyA9IGludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHRoaXMua2VlcEkxOG5BdHRycyA9IGtlZXBJMThuQXR0cnM7XG4gICAgICAgIHRoaXMuZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCA9IGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQ7XG4gICAgICAgIC8vIHdoZXRoZXIgdmlzaXRlZCBub2RlcyBjb250YWluIGkxOG4gaW5mb3JtYXRpb25cbiAgICAgICAgdGhpcy5oYXNJMThuTWV0YSA9IGZhbHNlO1xuICAgICAgICAvLyBpMThuIG1lc3NhZ2UgZ2VuZXJhdGlvbiBmYWN0b3J5XG4gICAgICAgIHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlID0gY3JlYXRlSTE4bk1lc3NhZ2VGYWN0b3J5KHRoaXMuaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUuX2dlbmVyYXRlSTE4bk1lc3NhZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG1ldGEsIHZpc2l0Tm9kZUZuKSB7XG4gICAgICAgIGlmIChtZXRhID09PSB2b2lkIDApIHsgbWV0YSA9ICcnOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlTWV0YWRhdGEobWV0YSksIG1lYW5pbmcgPSBfYS5tZWFuaW5nLCBkZXNjcmlwdGlvbiA9IF9hLmRlc2NyaXB0aW9uLCBjdXN0b21JZCA9IF9hLmN1c3RvbUlkO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQsIHZpc2l0Tm9kZUZuKTtcbiAgICAgICAgdGhpcy5fc2V0TWVzc2FnZUlkKG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgICB0aGlzLl9zZXRMZWdhY3lJZHMobWVzc2FnZSwgbWV0YSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgSTE4bk1ldGFWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgaWYgKGhhc0kxOG5BdHRycyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5oYXNJMThuTWV0YSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhdHRyc01ldGEgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhlbGVtZW50LmF0dHJzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBJMThOX0FUVFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QgJ2kxOG4nIG5vZGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTE4bl8xID0gZWxlbWVudC5pMThuIHx8IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoZWxlbWVudC5jaGlsZHJlbiwgaTE4bl8xLCBzZXRJMThuUmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgYXNzaWduIGVtcHR5IGkxOG4gbWV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pMThuID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChJMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ2kxOG4tKicgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGF0dHIubmFtZS5zbGljZShJMThOX0FUVFJfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc01ldGFba2V5XSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub24taTE4biBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGkxOG4gbWV0YSBmb3IgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzTWV0YSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0cnNfMSA9IF9fdmFsdWVzKGF0dHJzKSwgYXR0cnNfMV8xID0gYXR0cnNfMS5uZXh0KCk7ICFhdHRyc18xXzEuZG9uZTsgYXR0cnNfMV8xID0gYXR0cnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBhdHRyc01ldGFbYXR0ci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgdHJhbnNsYXRpb24gZm9yIGVtcHR5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhICE9PSB1bmRlZmluZWQgJiYgYXR0ci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuaTE4biA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBhdHRyLmkxOG4gfHwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyc18xXzEgJiYgIWF0dHJzXzFfMS5kb25lICYmIChfYiA9IGF0dHJzXzEucmV0dXJuKSkgX2IuY2FsbChhdHRyc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBJMThuQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8ga2VlcGluZyBvbmx5IG5vbi1pMThuIHJlbGF0ZWQgb25lc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgSTE4bk1ldGFWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGN1cnJlbnRNZXNzYWdlKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICB2YXIgbWV0YSA9IGV4cGFuc2lvbi5pMThuO1xuICAgICAgICB0aGlzLmhhc0kxOG5NZXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1ldGEgaW5zdGFuY2VvZiBJY3VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgLy8gc2V0IElDVSBwbGFjZWhvbGRlciBuYW1lIChlLmcuIFwiSUNVXzFcIiksXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgd2hpbGUgcHJvY2Vzc2luZyByb290IGVsZW1lbnQgY29udGVudHMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gcmVmZXJlbmNlIGl0IHdoZW4gd2Ugb3V0cHV0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gbWV0YS5uYW1lO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2V4cGFuc2lvbl0sIG1ldGEpO1xuICAgICAgICAgICAgdmFyIGljdSA9IGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGljdS5uYW1lID0gbmFtZV8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSUNVIGlzIGEgdG9wIGxldmVsIG1lc3NhZ2UsIHRyeSB0byB1c2UgbWV0YWRhdGEgZnJvbSBjb250YWluZXIgZWxlbWVudCBpZiBwcm92aWRlZCB2aWFcbiAgICAgICAgICAgIC8vIGBjb250ZXh0YCBhcmd1bWVudC4gTm90ZTogY29udGV4dCBtYXkgbm90IGJlIGF2YWlsYWJsZSBmb3Igc3RhbmRhbG9uZSBJQ1VzICh3aXRob3V0XG4gICAgICAgICAgICAvLyB3cmFwcGluZyBlbGVtZW50KSwgc28gZmFsbGJhY2sgdG8gSUNVIG1ldGFkYXRhIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBjdXJyZW50TWVzc2FnZSB8fCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBleHBhbnNpb24uaTE4biA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBleHBhbnNpb247XG4gICAgfTtcbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgSTE4bk1ldGFWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9O1xuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfTtcbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb25DYXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGdlbmVyYWwgZm9ybSBgbWV0YWAgcGFzc2VkIGludG8gZXh0cmFjdCB0aGUgZXhwbGljaXQgbWV0YWRhdGEgbmVlZGVkIHRvIGNyZWF0ZSBhXG4gICAgICogYE1lc3NhZ2VgLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHRocmVlIHBvc3NpYmlsaXRpZXMgZm9yIHRoZSBgbWV0YWAgdmFyaWFibGVcbiAgICAgKiAxKSBhIHN0cmluZyBmcm9tIGFuIGBpMThuYCB0ZW1wbGF0ZSBhdHRyaWJ1dGU6IHBhcnNlIGl0IHRvIGV4dHJhY3QgdGhlIG1ldGFkYXRhIHZhbHVlcy5cbiAgICAgKiAyKSBhIGBNZXNzYWdlYCBmcm9tIGEgcHJldmlvdXMgcHJvY2Vzc2luZyBwYXNzOiByZXVzZSB0aGUgbWV0YWRhdGEgdmFsdWVzIGluIHRoZSBtZXNzYWdlLlxuICAgICAqIDQpIG90aGVyOiBpZ25vcmUgdGhpcyBhbmQganVzdCBwcm9jZXNzIHRoZSBtZXNzYWdlIG1ldGFkYXRhIGFzIG5vcm1hbFxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGEgdGhlIGJ1Y2tldCB0aGF0IGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtZXNzYWdlXG4gICAgICogQHJldHVybnMgdGhlIHBhcnNlZCBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBJMThuTWV0YVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyA/IHBhcnNlSTE4bk1ldGEobWV0YSkgOlxuICAgICAgICAgICAgbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgPyBtZXRhIDoge307XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSAob3IgcmVzdG9yZSkgbWVzc2FnZSBpZCBpZiBub3Qgc3BlY2lmaWVkIGFscmVhZHkuXG4gICAgICovXG4gICAgSTE4bk1ldGFWaXNpdG9yLnByb3RvdHlwZS5fc2V0TWVzc2FnZUlkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmlkID0gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgJiYgbWV0YS5pZCB8fCBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGBtZXNzYWdlYCB3aXRoIGEgYGxlZ2FjeUlkYCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSB3aG9zZSBsZWdhY3kgaWQgc2hvdWxkIGJlIHNldFxuICAgICAqIEBwYXJhbSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtZXNzYWdlIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqL1xuICAgIEkxOG5NZXRhVmlzaXRvci5wcm90b3R5cGUuX3NldExlZ2FjeUlkcyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBtZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubGVnYWN5SWRzID0gW2NvbXB1dGVEaWdlc3QobWVzc2FnZSksIGNvbXB1dGVEZWNpbWFsRGlnZXN0KG1lc3NhZ2UpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWV0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb2NjdXJzIGlmIHdlIGFyZSBkb2luZyB0aGUgMm5kIHBhc3MgYWZ0ZXIgd2hpdGVzcGFjZSByZW1vdmFsIChzZWUgYHBhcnNlVGVtcGxhdGUoKWAgaW5cbiAgICAgICAgICAgIC8vIGBwYWNrYWdlcy9jb21waWxlci9zcmMvcmVuZGVyMy92aWV3L3RlbXBsYXRlLnRzYCkuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2Ugd2FudCB0byByZXVzZSB0aGUgbGVnYWN5IG1lc3NhZ2UgZ2VuZXJhdGVkIGluIHRoZSAxc3QgcGFzcyAoc2VlXG4gICAgICAgICAgICAvLyBgc2V0STE4blJlZnMoKWApLlxuICAgICAgICAgICAgdmFyIHByZXZpb3VzTWVzc2FnZSA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlID9cbiAgICAgICAgICAgICAgICBtZXRhIDpcbiAgICAgICAgICAgICAgICBtZXRhIGluc3RhbmNlb2YgSWN1UGxhY2Vob2xkZXIgPyBtZXRhLnByZXZpb3VzTWVzc2FnZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG1lc3NhZ2UubGVnYWN5SWRzID0gcHJldmlvdXNNZXNzYWdlID8gcHJldmlvdXNNZXNzYWdlLmxlZ2FjeUlkcyA6IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSTE4bk1ldGFWaXNpdG9yO1xufSgpKTtcbi8qKiBJMThuIHNlcGFyYXRvcnMgZm9yIG1ldGFkYXRhICoqL1xudmFyIEkxOE5fTUVBTklOR19TRVBBUkFUT1IgPSAnfCc7XG52YXIgSTE4Tl9JRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBQYXJzZXMgaTE4biBtZXRhcyBsaWtlOlxuICogIC0gXCJAQGlkXCIsXG4gKiAgLSBcImRlc2NyaXB0aW9uW0BAaWRdXCIsXG4gKiAgLSBcIm1lYW5pbmd8ZGVzY3JpcHRpb25bQEBpZF1cIlxuICogYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFyc2VkIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbWV0YSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGkxOG4gbWV0YVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggaWQsIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uIGZpZWxkc1xuICovXG5mdW5jdGlvbiBwYXJzZUkxOG5NZXRhKG1ldGEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChtZXRhID09PSB2b2lkIDApIHsgbWV0YSA9ICcnOyB9XG4gICAgdmFyIGN1c3RvbUlkO1xuICAgIHZhciBtZWFuaW5nO1xuICAgIHZhciBkZXNjcmlwdGlvbjtcbiAgICBtZXRhID0gbWV0YS50cmltKCk7XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgdmFyIGlkSW5kZXggPSBtZXRhLmluZGV4T2YoSTE4Tl9JRF9TRVBBUkFUT1IpO1xuICAgICAgICB2YXIgZGVzY0luZGV4ID0gbWV0YS5pbmRleE9mKEkxOE5fTUVBTklOR19TRVBBUkFUT1IpO1xuICAgICAgICB2YXIgbWVhbmluZ0FuZERlc2MgPSB2b2lkIDA7XG4gICAgICAgIF9hID0gX19yZWFkKChpZEluZGV4ID4gLTEpID8gW21ldGEuc2xpY2UoMCwgaWRJbmRleCksIG1ldGEuc2xpY2UoaWRJbmRleCArIDIpXSA6IFttZXRhLCAnJ10sIDIpLCBtZWFuaW5nQW5kRGVzYyA9IF9hWzBdLCBjdXN0b21JZCA9IF9hWzFdO1xuICAgICAgICBfYiA9IF9fcmVhZCgoZGVzY0luZGV4ID4gLTEpID9cbiAgICAgICAgICAgIFttZWFuaW5nQW5kRGVzYy5zbGljZSgwLCBkZXNjSW5kZXgpLCBtZWFuaW5nQW5kRGVzYy5zbGljZShkZXNjSW5kZXggKyAxKV0gOlxuICAgICAgICAgICAgWycnLCBtZWFuaW5nQW5kRGVzY10sIDIpLCBtZWFuaW5nID0gX2JbMF0sIGRlc2NyaXB0aW9uID0gX2JbMV07XG4gICAgfVxuICAgIHJldHVybiB7IGN1c3RvbUlkOiBjdXN0b21JZCwgbWVhbmluZzogbWVhbmluZywgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH07XG59XG4vLyBDb252ZXJ0cyBpMThuIG1ldGEgaW5mb3JtYXRpb24gZm9yIGEgbWVzc2FnZSAoaWQsIGRlc2NyaXB0aW9uLCBtZWFuaW5nKVxuLy8gdG8gYSBKc0RvYyBzdGF0ZW1lbnQgZm9ybWF0dGVkIGFzIGV4cGVjdGVkIGJ5IHRoZSBDbG9zdXJlIGNvbXBpbGVyLlxuZnVuY3Rpb24gaTE4bk1ldGFUb0RvY1N0bXQobWV0YSkge1xuICAgIHZhciB0YWdzID0gW107XG4gICAgaWYgKG1ldGEuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGFncy5wdXNoKHsgdGFnTmFtZTogXCJkZXNjXCIgLyogRGVzYyAqLywgdGV4dDogbWV0YS5kZXNjcmlwdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGEubWVhbmluZykge1xuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcIm1lYW5pbmdcIiAvKiBNZWFuaW5nICovLCB0ZXh0OiBtZXRhLm1lYW5pbmcgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLmxlbmd0aCA9PSAwID8gbnVsbCA6IG5ldyBKU0RvY0NvbW1lbnRTdG10KHRhZ3MpO1xufVxuXG4vKiogQ2xvc3VyZSB1c2VzIGBnb29nLmdldE1zZyhtZXNzYWdlKWAgdG8gbG9va3VwIHRyYW5zbGF0aW9ucyAqL1xudmFyIEdPT0dfR0VUX01TRyA9ICdnb29nLmdldE1zZyc7XG5mdW5jdGlvbiBjcmVhdGVHb29nbGVHZXRNc2dTdGF0ZW1lbnRzKHZhcmlhYmxlJDEsIG1lc3NhZ2UsIGNsb3N1cmVWYXIsIHBhcmFtcykge1xuICAgIHZhciBtZXNzYWdlU3RyaW5nID0gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JHZXRNc2cobWVzc2FnZSk7XG4gICAgdmFyIGFyZ3MgPSBbbGl0ZXJhbChtZXNzYWdlU3RyaW5nKV07XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MucHVzaChtYXBMaXRlcmFsKHBhcmFtcywgdHJ1ZSkpO1xuICAgIH1cbiAgICAvLyAvKipcbiAgICAvLyAgKiBAZGVzYyBkZXNjcmlwdGlvbiBvZiBtZXNzYWdlXG4gICAgLy8gICogQG1lYW5pbmcgbWVhbmluZyBvZiBtZXNzYWdlXG4gICAgLy8gICovXG4gICAgLy8gY29uc3QgTVNHXy4uLiA9IGdvb2cuZ2V0TXNnKC4uKTtcbiAgICAvLyBJMThOX1ggPSBNU0dfLi4uO1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIGpzZG9jQ29tbWVudCA9IGkxOG5NZXRhVG9Eb2NTdG10KG1lc3NhZ2UpO1xuICAgIGlmIChqc2RvY0NvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGpzZG9jQ29tbWVudCk7XG4gICAgfVxuICAgIHN0YXRlbWVudHMucHVzaChjbG9zdXJlVmFyLnNldCh2YXJpYWJsZShHT09HX0dFVF9NU0cpLmNhbGxGbihhcmdzKSkudG9Db25zdERlY2woKSk7XG4gICAgc3RhdGVtZW50cy5wdXNoKG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlJDEuc2V0KGNsb3N1cmVWYXIpKSk7XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG4vKipcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyBvdmVyIGkxOG4gdHJlZSBhbmQgZ2VuZXJhdGVzIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGluY2x1ZGluZyBJQ1VzIGFuZFxuICogcGxhY2Vob2xkZXJzIGluIGB7JHBsYWNlaG9sZGVyfWAgKGZvciBwbGFpbiBtZXNzYWdlcykgb3IgYHtQTEFDRUhPTERFUn1gIChpbnNpZGUgSUNVcykgZm9ybWF0LlxuICovXG52YXIgR2V0TXNnU2VyaWFsaXplclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2V0TXNnU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgfVxuICAgIEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS5mb3JtYXRQaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJ7JFwiICsgZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZSh2YWx1ZSkgKyBcIn1cIjtcbiAgICB9O1xuICAgIEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9O1xuICAgIEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgR2V0TXNnU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplSWN1Tm9kZShpY3UpO1xuICAgIH07XG4gICAgR2V0TXNnU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSkgOlxuICAgICAgICAgICAgXCJcIiArIHRoaXMuZm9ybWF0UGgocGguc3RhcnROYW1lKSArIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignJykgKyB0aGlzLmZvcm1hdFBoKHBoLmNsb3NlTmFtZSk7XG4gICAgfTtcbiAgICBHZXRNc2dTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRQaChwaC5uYW1lKTtcbiAgICB9O1xuICAgIEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yO1xufSgpKTtcbnZhciBzZXJpYWxpemVyVmlzaXRvciQxID0gbmV3IEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVJMThuTWVzc2FnZUZvckdldE1zZyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yJDEsIG51bGwpOyB9KS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxpemVTdGF0ZW1lbnRzKHZhcmlhYmxlLCBtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciBfYSA9IHNlcmlhbGl6ZUkxOG5NZXNzYWdlRm9yTG9jYWxpemUobWVzc2FnZSksIG1lc3NhZ2VQYXJ0cyA9IF9hLm1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJzID0gX2EucGxhY2VIb2xkZXJzO1xuICAgIHN0YXRlbWVudHMucHVzaChuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh2YXJpYWJsZS5zZXQobG9jYWxpemVkU3RyaW5nKG1lc3NhZ2UsIG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJzLCBwbGFjZUhvbGRlcnMubWFwKGZ1bmN0aW9uIChwaCkgeyByZXR1cm4gcGFyYW1zW3BoXTsgfSkpKSkpO1xuICAgIHJldHVybiBzdGF0ZW1lbnRzO1xufVxudmFyIE1lc3NhZ2VQaWVjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlUGllY2UodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZVBpZWNlO1xufSgpKTtcbnZhciBMaXRlcmFsUGllY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQaWVjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXRlcmFsUGllY2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpdGVyYWxQaWVjZTtcbn0oTWVzc2FnZVBpZWNlKSk7XG52YXIgUGxhY2Vob2xkZXJQaWVjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGxhY2Vob2xkZXJQaWVjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQbGFjZWhvbGRlclBpZWNlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUobmFtZSwgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyUGllY2U7XG59KE1lc3NhZ2VQaWVjZSkpO1xuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBhbiBpMThuIHRyZWUsIGNhcHR1cmluZyBsaXRlcmFsIHN0cmluZ3MgYW5kIHBsYWNlaG9sZGVycy5cbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhbGl6ZVNlcmlhbGl6ZXJWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgfVxuICAgIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBMaXRlcmFsUGllY2UpIHtcbiAgICAgICAgICAgIC8vIFR3byBsaXRlcmFsIHBpZWNlcyBpbiBhIHJvdyBtZWFucyB0aGF0IHRoZXJlIHdhcyBzb21lIGNvbW1lbnQgbm9kZSBpbi1iZXR3ZWVuLlxuICAgICAgICAgICAgY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdLnRleHQgKz0gdGV4dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQucHVzaChuZXcgTGl0ZXJhbFBpZWNlKHRleHQudmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYWxpemVTZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnB1c2gobmV3IExpdGVyYWxQaWVjZShzZXJpYWxpemVJY3VOb2RlKGljdSkpKTtcbiAgICB9O1xuICAgIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29udGV4dC5wdXNoKG5ldyBQbGFjZWhvbGRlclBpZWNlKHBoLnN0YXJ0TmFtZSkpO1xuICAgICAgICBpZiAoIXBoLmlzVm9pZCkge1xuICAgICAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgICBjb250ZXh0LnB1c2gobmV3IFBsYWNlaG9sZGVyUGllY2UocGguY2xvc2VOYW1lKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5wdXNoKG5ldyBQbGFjZWhvbGRlclBpZWNlKHBoLm5hbWUpKTtcbiAgICB9O1xuICAgIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5wdXNoKG5ldyBQbGFjZWhvbGRlclBpZWNlKHBoLm5hbWUpKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbGl6ZVNlcmlhbGl6ZXJWaXNpdG9yO1xufSgpKTtcbnZhciBzZXJpYWxpemVyVmlzaXRvciQyID0gbmV3IExvY2FsaXplU2VyaWFsaXplclZpc2l0b3IoKTtcbi8qKlxuICogU2VyaWFsaXplIGFuIGkxOG4gbWVzc2FnZSBpbnRvIHR3byBhcnJheXM6IG1lc3NhZ2VQYXJ0cyBhbmQgcGxhY2Vob2xkZXJzLlxuICpcbiAqIFRoZXNlIGFycmF5cyB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYCRsb2NhbGl6ZWAgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHNlcmlhbGl6ZWQuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUkxOG5NZXNzYWdlRm9yTG9jYWxpemUobWVzc2FnZSkge1xuICAgIHZhciBwaWVjZXMgPSBbXTtcbiAgICBtZXNzYWdlLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoc2VyaWFsaXplclZpc2l0b3IkMiwgcGllY2VzKTsgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3NNZXNzYWdlUGllY2VzKHBpZWNlcyk7XG59XG4vKipcbiAqIENvbnZlcnQgdGhlIGxpc3Qgb2Ygc2VyaWFsaXplZCBNZXNzYWdlUGllY2VzIGludG8gdHdvIGFycmF5cy5cbiAqXG4gKiBPbmUgY29udGFpbnMgdGhlIGxpdGVyYWwgc3RyaW5nIHBpZWNlcyBhbmQgdGhlIG90aGVyIHRoZSBwbGFjZWhvbGRlcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5XG4gKiBleHByZXNzaW9ucyB3aGVuIHJlbmRlcmluZyBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIHBpZWNlcyBUaGUgcGllY2VzIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUGllY2VzKHBpZWNlcykge1xuICAgIHZhciBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICB2YXIgcGxhY2VIb2xkZXJzID0gW107XG4gICAgaWYgKHBpZWNlc1swXSBpbnN0YW5jZW9mIFBsYWNlaG9sZGVyUGllY2UpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBpZWNlIHdhcyBhIHBsYWNlaG9sZGVyIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGluaXRpYWwgZW1wdHkgbWVzc2FnZSBwYXJ0LlxuICAgICAgICBtZXNzYWdlUGFydHMucHVzaCgnJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGllY2VzW2ldO1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2gocGFydC50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBsYWNlSG9sZGVycy5wdXNoKHBhcnQudGV4dCk7XG4gICAgICAgICAgICBpZiAocGllY2VzW2kgLSAxXSBpbnN0YW5jZW9mIFBsYWNlaG9sZGVyUGllY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIHR3byBwbGFjZWhvbGRlcnMgaW4gYSByb3csIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBpZWNlc1twaWVjZXMubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBQbGFjZWhvbGRlclBpZWNlKSB7XG4gICAgICAgIC8vIFRoZSBsYXN0IHBpZWNlIHdhcyBhIHBsYWNlaG9sZGVyIHNvIHdlIG5lZWQgdG8gYWRkIGEgZmluYWwgZW1wdHkgbWVzc2FnZSBwYXJ0LlxuICAgICAgICBtZXNzYWdlUGFydHMucHVzaCgnJyk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VQYXJ0czogbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlcnM6IHBsYWNlSG9sZGVycyB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBTZWxlY3RvciBhdHRyaWJ1dGUgbmFtZSBvZiBgPG5nLWNvbnRlbnQ+YFxudmFyIE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIkMSA9ICdzZWxlY3QnO1xuLy8gQXR0cmlidXRlIG5hbWUgb2YgYG5nUHJvamVjdEFzYC5cbnZhciBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSA9ICduZ1Byb2plY3RBcyc7XG4vLyBMaXN0IG9mIHN1cHBvcnRlZCBnbG9iYWwgdGFyZ2V0cyBmb3IgZXZlbnQgbGlzdGVuZXJzXG52YXIgR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMgPSBuZXcgTWFwKFtbJ3dpbmRvdycsIElkZW50aWZpZXJzJDEucmVzb2x2ZVdpbmRvd10sIFsnZG9jdW1lbnQnLCBJZGVudGlmaWVycyQxLnJlc29sdmVEb2N1bWVudF0sIFsnYm9keScsIElkZW50aWZpZXJzJDEucmVzb2x2ZUJvZHldXSk7XG52YXIgTEVBRElOR19UUklWSUFfQ0hBUlMgPSBbJyAnLCAnXFxuJywgJ1xccicsICdcXHQnXTtcbi8vICBpZiAocmYgJiBmbGFncykgeyAuLiB9XG5mdW5jdGlvbiByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoZmxhZ3MsIHN0YXRlbWVudHMpIHtcbiAgICByZXR1cm4gaWZTdG10KHZhcmlhYmxlKFJFTkRFUl9GTEFHUykuYml0d2lzZUFuZChsaXRlcmFsKGZsYWdzKSwgbnVsbCwgZmFsc2UpLCBzdGF0ZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVFdmVudExpc3RlbmVyUGFyYW1ldGVycyhldmVudEFzdCwgaGFuZGxlck5hbWUsIHNjb3BlKSB7XG4gICAgaWYgKGhhbmRsZXJOYW1lID09PSB2b2lkIDApIHsgaGFuZGxlck5hbWUgPSBudWxsOyB9XG4gICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSBudWxsOyB9XG4gICAgdmFyIHR5cGUgPSBldmVudEFzdC50eXBlLCBuYW1lID0gZXZlbnRBc3QubmFtZSwgdGFyZ2V0ID0gZXZlbnRBc3QudGFyZ2V0LCBwaGFzZSA9IGV2ZW50QXN0LnBoYXNlLCBoYW5kbGVyID0gZXZlbnRBc3QuaGFuZGxlcjtcbiAgICBpZiAodGFyZ2V0ICYmICFHTE9CQUxfVEFSR0VUX1JFU09MVkVSUy5oYXModGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGdsb2JhbCB0YXJnZXQgJ1wiICsgdGFyZ2V0ICsgXCInIGRlZmluZWQgZm9yICdcIiArIG5hbWUgKyBcIicgZXZlbnQuXFxuICAgICAgICBTdXBwb3J0ZWQgbGlzdCBvZiBnbG9iYWwgdGFyZ2V0czogXCIgKyBBcnJheS5mcm9tKEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmtleXMoKSkgKyBcIi5cIik7XG4gICAgfVxuICAgIHZhciBldmVudEFyZ3VtZW50TmFtZSA9ICckZXZlbnQnO1xuICAgIHZhciBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGltcGxpY2l0UmVjZWl2ZXJFeHByID0gKHNjb3BlID09PSBudWxsIHx8IHNjb3BlLmJpbmRpbmdMZXZlbCA9PT0gMCkgP1xuICAgICAgICB2YXJpYWJsZShDT05URVhUX05BTUUpIDpcbiAgICAgICAgc2NvcGUuZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyKDApO1xuICAgIHZhciBiaW5kaW5nRXhwciA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKHNjb3BlLCBpbXBsaWNpdFJlY2VpdmVyRXhwciwgaGFuZGxlciwgJ2InLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJyk7IH0sIGV2ZW50QXN0LmhhbmRsZXJTcGFuLCBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMpO1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChzY29wZS5yZXN0b3JlVmlld1N0YXRlbWVudCgpKSk7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChzY29wZS52YXJpYWJsZURlY2xhcmF0aW9ucygpKSk7XG4gICAgfVxuICAgIHN0YXRlbWVudHMucHVzaC5hcHBseShzdGF0ZW1lbnRzLCBfX3NwcmVhZChiaW5kaW5nRXhwci5yZW5kZXIzU3RtdHMpKTtcbiAgICB2YXIgZXZlbnROYW1lID0gdHlwZSA9PT0gMSAvKiBBbmltYXRpb24gKi8gPyBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSA6IG5hbWU7XG4gICAgdmFyIGZuTmFtZSA9IGhhbmRsZXJOYW1lICYmIHNhbml0aXplSWRlbnRpZmllcihoYW5kbGVyTmFtZSk7XG4gICAgdmFyIGZuQXJncyA9IFtdO1xuICAgIGlmIChpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMuaGFzKGV2ZW50QXJndW1lbnROYW1lKSkge1xuICAgICAgICBmbkFyZ3MucHVzaChuZXcgRm5QYXJhbShldmVudEFyZ3VtZW50TmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyRm4gPSBmbihmbkFyZ3MsIHN0YXRlbWVudHMsIElORkVSUkVEX1RZUEUsIG51bGwsIGZuTmFtZSk7XG4gICAgdmFyIHBhcmFtcyA9IFtsaXRlcmFsKGV2ZW50TmFtZSksIGhhbmRsZXJGbl07XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBwYXJhbXMucHVzaChsaXRlcmFsKGZhbHNlKSwgLy8gYHVzZUNhcHR1cmVgIGZsYWcsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgaW1wb3J0RXhwcihHTE9CQUxfVEFSR0VUX1JFU09MVkVSUy5nZXQodGFyZ2V0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxudmFyIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlcihjb25zdGFudFBvb2wsIHBhcmVudEJpbmRpbmdTY29wZSwgbGV2ZWwsIGNvbnRleHROYW1lLCBpMThuQ29udGV4dCwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCBkaXJlY3RpdmVNYXRjaGVyLCBkaXJlY3RpdmVzLCBwaXBlVHlwZUJ5TmFtZSwgcGlwZXMsIF9uYW1lc3BhY2UsIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoLCBpMThuVXNlRXh0ZXJuYWxJZHMsIF9jb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGxldmVsID09PSB2b2lkIDApIHsgbGV2ZWwgPSAwOyB9XG4gICAgICAgIGlmIChfY29uc3RhbnRzID09PSB2b2lkIDApIHsgX2NvbnN0YW50cyA9IFtdOyB9XG4gICAgICAgIHRoaXMuY29uc3RhbnRQb29sID0gY29uc3RhbnRQb29sO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICAgICAgdGhpcy5pMThuQ29udGV4dCA9IGkxOG5Db250ZXh0O1xuICAgICAgICB0aGlzLnRlbXBsYXRlSW5kZXggPSB0ZW1wbGF0ZUluZGV4O1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVNYXRjaGVyID0gZGlyZWN0aXZlTWF0Y2hlcjtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5waXBlVHlwZUJ5TmFtZSA9IHBpcGVUeXBlQnlOYW1lO1xuICAgICAgICB0aGlzLnBpcGVzID0gcGlwZXM7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IF9uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuaTE4blVzZUV4dGVybmFsSWRzID0gaTE4blVzZUV4dGVybmFsSWRzO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBfY29uc3RhbnRzO1xuICAgICAgICB0aGlzLl9kYXRhSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9iaW5kaW5nQ29udGV4dCA9IDA7XG4gICAgICAgIHRoaXMuX3ByZWZpeENvZGUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGdlbmVyYXRlIGNyZWF0aW9uIG1vZGUgaW5zdHJ1Y3Rpb25zLiBXZSBzdG9yZSB0aGVtIGhlcmUgYXMgd2UgcHJvY2Vzc1xuICAgICAgICAgKiB0aGUgdGVtcGxhdGUgc28gYmluZGluZ3MgaW4gbGlzdGVuZXJzIGFyZSByZXNvbHZlZCBvbmx5IG9uY2UgYWxsIG5vZGVzIGhhdmUgYmVlbiB2aXNpdGVkLlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgYWxsIGxvY2FsIHJlZnMgYW5kIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhdmFpbGFibGUgZm9yIG1hdGNoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3JlYXRpb25Db2RlRm5zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBnZW5lcmF0ZSB1cGRhdGUgbW9kZSBpbnN0cnVjdGlvbnMuIFdlIHN0b3JlIHRoZW0gaGVyZSBhcyB3ZSBwcm9jZXNzXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBzbyBiaW5kaW5ncyBhcmUgcmVzb2x2ZWQgb25seSBvbmNlIGFsbCBub2RlcyBoYXZlIGJlZW4gdmlzaXRlZC4gVGhpcyBlbnN1cmVzXG4gICAgICAgICAqIGFsbCBsb2NhbCByZWZzIGFuZCBjb250ZXh0IHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlIGZvciBtYXRjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvZGVGbnMgPSBbXTtcbiAgICAgICAgLyoqIEluZGV4IG9mIHRoZSBjdXJyZW50bHktc2VsZWN0ZWQgbm9kZS4gKi9cbiAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgZ2VuZXJhdGVkIGZyb20gdmlzaXRpbmcgcGlwZXMsIGxpdGVyYWxzLCBldGMuICovXG4gICAgICAgIHRoaXMuX3RlbXBWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGJ1aWxkIG5lc3RlZCB0ZW1wbGF0ZXMuIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbFxuICAgICAgICAgKiBhZnRlciB0aGUgcGFyZW50IHRlbXBsYXRlIGhhcyBmaW5pc2hlZCB2aXNpdGluZyBhbGwgb2YgaXRzIG5vZGVzLiBUaGlzIGVuc3VyZXMgdGhhdCBhbGxcbiAgICAgICAgICogbG9jYWwgcmVmIGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgYXJlIGFibGUgdG8gZmluZCBsb2NhbCByZWYgdmFsdWVzIGlmIHRoZSByZWZzXG4gICAgICAgICAqIGFyZSBkZWZpbmVkIGFmdGVyIHRoZSB0ZW1wbGF0ZSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zID0gW107XG4gICAgICAgIHRoaXMuX3Vuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG4gICAgICAgIC8vIGkxOG4gY29udGV4dCBsb2NhbCB0byB0aGlzIHRlbXBsYXRlXG4gICAgICAgIHRoaXMuaTE4biA9IG51bGw7XG4gICAgICAgIC8vIE51bWJlciBvZiBzbG90cyB0byByZXNlcnZlIGZvciBwdXJlRnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzID0gMDtcbiAgICAgICAgLy8gTnVtYmVyIG9mIGJpbmRpbmcgc2xvdHNcbiAgICAgICAgdGhpcy5fYmluZGluZ1Nsb3RzID0gMDtcbiAgICAgICAgLy8gUHJvamVjdGlvbiBzbG90cyBmb3VuZCBpbiB0aGUgdGVtcGxhdGUuIFByb2plY3Rpb24gc2xvdHMgY2FuIGRpc3RyaWJ1dGUgcHJvamVjdGVkXG4gICAgICAgIC8vIG5vZGVzIGJhc2VkIG9uIGEgc2VsZWN0b3IsIG9yIGNhbiBqdXN0IHVzZSB0aGUgd2lsZGNhcmQgc2VsZWN0b3IgdG8gbWF0Y2hcbiAgICAgICAgLy8gYWxsIG5vZGVzIHdoaWNoIGFyZW4ndCBtYXRjaGluZyBhbnkgc2VsZWN0b3IuXG4gICAgICAgIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMgPSBbXTtcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vbi1kZWZhdWx0IHNlbGVjdG9ycyBmb3VuZCBpbiBhbGwgcGFyZW50IHRlbXBsYXRlcyBvZiB0aGlzIHRlbXBsYXRlLiBXZSBuZWVkIHRvXG4gICAgICAgIC8vIHRyYWNrIGl0IHRvIHByb3Blcmx5IGFkanVzdCBwcm9qZWN0aW9uIHNsb3QgaW5kZXggaW4gdGhlIGBwcm9qZWN0aW9uYCBpbnN0cnVjdGlvbi5cbiAgICAgICAgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gRXhwcmVzc2lvbiB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGltcGxpY2l0IHJlY2VpdmVyIHdoZW4gY29udmVydGluZyB0ZW1wbGF0ZVxuICAgICAgICAvLyBleHByZXNzaW9ucyB0byBvdXRwdXQgQVNULlxuICAgICAgICB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwciA9IG51bGw7XG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSB0ZW1wbGF0ZSBvciBlbGVtZW50IGRpcmVjdGx5LlxuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0VmFyaWFibGUgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRUZXh0QXR0cmlidXRlID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Qm91bmRBdHRyaWJ1dGUgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRCb3VuZEV2ZW50ID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUgPSBwYXJlbnRCaW5kaW5nU2NvcGUubmVzdGVkU2NvcGUobGV2ZWwpO1xuICAgICAgICAvLyBUdXJuIHRoZSByZWxhdGl2ZSBjb250ZXh0IGZpbGUgcGF0aCBpbnRvIGFuIGlkZW50aWZpZXIgYnkgcmVwbGFjaW5nIG5vbi1hbHBoYW51bWVyaWNcbiAgICAgICAgLy8gY2hhcmFjdGVycyB3aXRoIHVuZGVyc2NvcmVzLlxuICAgICAgICB0aGlzLmZpbGVCYXNlZEkxOG5TdWZmaXggPSByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aC5yZXBsYWNlKC9bXkEtWmEtejAtOV0vZywgJ18nKSArICdfJztcbiAgICAgICAgdGhpcy5fdmFsdWVDb252ZXJ0ZXIgPSBuZXcgVmFsdWVDb252ZXJ0ZXIoY29uc3RhbnRQb29sLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7IH0sIGZ1bmN0aW9uIChudW1TbG90cykgeyByZXR1cm4gX3RoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyhudW1TbG90cyk7IH0sIGZ1bmN0aW9uIChuYW1lLCBsb2NhbE5hbWUsIHNsb3QsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGlwZVR5cGUgPSBwaXBlVHlwZUJ5TmFtZS5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAocGlwZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5waXBlcy5hZGQocGlwZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2JpbmRpbmdTY29wZS5zZXQoX3RoaXMubGV2ZWwsIGxvY2FsTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgX3RoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycyQxLnBpcGUsIFtsaXRlcmFsKHNsb3QpLCBsaXRlcmFsKG5hbWUpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZFRlbXBsYXRlRnVuY3Rpb24gPSBmdW5jdGlvbiAobm9kZXMsIHZhcmlhYmxlcywgbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0LCBpMThuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChuZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgPT09IHZvaWQgMCkgeyBuZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgPSAwOyB9XG4gICAgICAgIHRoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCA9IG5nQ29udGVudFNlbGVjdG9yc09mZnNldDtcbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZSAhPT0gSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VIVE1MKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgdGhpcy5fbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgICAgdmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnJlZ2lzdGVyQ29udGV4dFZhcmlhYmxlcyh2KTsgfSk7XG4gICAgICAgIC8vIEluaXRpYXRlIGkxOG4gY29udGV4dCBpbiBjYXNlOlxuICAgICAgICAvLyAtIHRoaXMgdGVtcGxhdGUgaGFzIHBhcmVudCBpMThuIGNvbnRleHRcbiAgICAgICAgLy8gLSBvciB0aGUgdGVtcGxhdGUgaGFzIGkxOG4gbWV0YSBhc3NvY2lhdGVkIHdpdGggaXQsXG4gICAgICAgIC8vICAgYnV0IGl0J3Mgbm90IGluaXRpYXRlZCBieSB0aGUgRWxlbWVudCAoZS5nLiA8bmctdGVtcGxhdGUgaTE4bj4pXG4gICAgICAgIHZhciBpbml0STE4bkNvbnRleHQgPSB0aGlzLmkxOG5Db250ZXh0IHx8XG4gICAgICAgICAgICAoaXNJMThuUm9vdE5vZGUoaTE4bikgJiYgIWlzU2luZ2xlSTE4bkljdShpMThuKSAmJlxuICAgICAgICAgICAgICAgICEoaXNTaW5nbGVFbGVtZW50VGVtcGxhdGUobm9kZXMpICYmIG5vZGVzWzBdLmkxOG4gPT09IGkxOG4pKTtcbiAgICAgICAgdmFyIHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uID0gaGFzVGV4dENoaWxkcmVuT25seShub2Rlcyk7XG4gICAgICAgIGlmIChpbml0STE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blN0YXJ0KG51bGwsIGkxOG4sIHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIHBhc3MgdGhyb3VnaCB0aGUgbm9kZXMgb2YgdGhpcyB0ZW1wbGF0ZS4gSW4gdGhpcyBwYXNzLCB3ZVxuICAgICAgICAvLyBxdWV1ZSBhbGwgY3JlYXRpb24gbW9kZSBhbmQgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zIGZvciBnZW5lcmF0aW9uIGluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gcGFzcy4gSXQncyBuZWNlc3NhcnkgdG8gc2VwYXJhdGUgdGhlIHBhc3NlcyB0byBlbnN1cmUgbG9jYWwgcmVmcyBhcmUgZGVmaW5lZCBiZWZvcmVcbiAgICAgICAgLy8gcmVzb2x2aW5nIGJpbmRpbmdzLiBXZSBhbHNvIGNvdW50IGJpbmRpbmdzIGluIHRoaXMgcGFzcyBhcyB3ZSB3YWxrIGJvdW5kIGV4cHJlc3Npb25zLlxuICAgICAgICB2aXNpdEFsbCh0aGlzLCBub2Rlcyk7XG4gICAgICAgIC8vIEFkZCB0b3RhbCBiaW5kaW5nIGNvdW50IHRvIHB1cmUgZnVuY3Rpb24gY291bnQgc28gcHVyZSBmdW5jdGlvbiBpbnN0cnVjdGlvbnMgYXJlXG4gICAgICAgIC8vIGdlbmVyYXRlZCB3aXRoIHRoZSBjb3JyZWN0IHNsb3Qgb2Zmc2V0IHdoZW4gdXBkYXRlIGluc3RydWN0aW9ucyBhcmUgcHJvY2Vzc2VkLlxuICAgICAgICB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cyArPSB0aGlzLl9iaW5kaW5nU2xvdHM7XG4gICAgICAgIC8vIFBpcGVzIGFyZSB3YWxrZWQgaW4gdGhlIGZpcnN0IHBhc3MgKHRvIGVucXVldWUgYHBpcGUoKWAgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIGFuZFxuICAgICAgICAvLyBgcGlwZUJpbmRgIHVwZGF0ZSBpbnN0cnVjdGlvbnMpLCBzbyB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgc2xvdCBvZmZzZXRzIG1hbnVhbGx5XG4gICAgICAgIC8vIHRvIGFjY291bnQgZm9yIGJpbmRpbmdzLlxuICAgICAgICB0aGlzLl92YWx1ZUNvbnZlcnRlci51cGRhdGVQaXBlU2xvdE9mZnNldHModGhpcy5fYmluZGluZ1Nsb3RzKTtcbiAgICAgICAgLy8gTmVzdGVkIHRlbXBsYXRlcyBtdXN0IGJlIHByb2Nlc3NlZCBiZWZvcmUgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIHNvIHRlbXBsYXRlKClcbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zIGNhbiBiZSBnZW5lcmF0ZWQgd2l0aCB0aGUgY29ycmVjdCBpbnRlcm5hbCBjb25zdCBjb3VudC5cbiAgICAgICAgdGhpcy5fbmVzdGVkVGVtcGxhdGVGbnMuZm9yRWFjaChmdW5jdGlvbiAoYnVpbGRUZW1wbGF0ZUZuKSB7IHJldHVybiBidWlsZFRlbXBsYXRlRm4oKTsgfSk7XG4gICAgICAgIC8vIE91dHB1dCB0aGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIHdoZW4gc29tZSBgPG5nLWNvbnRlbnQ+YCB0YWdzIGFyZSBwcmVzZW50LlxuICAgICAgICAvLyBUaGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIGlzIG9ubHkgZW1pdHRlZCBmb3IgdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSBhbmRcbiAgICAgICAgLy8gaXMgc2tpcHBlZCBmb3IgbmVzdGVkIHRlbXBsYXRlcyAoPG5nLXRlbXBsYXRlPiB0YWdzKS5cbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgPT09IDAgJiYgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0IHRoZSBgcHJvamVjdGlvbkRlZmAgaW5zdHJ1Y3Rpb25zIGNyZWF0ZXMgb25lIHNsb3QgZm9yIHRoZSB3aWxkY2FyZFxuICAgICAgICAgICAgLy8gc2VsZWN0b3IgaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLiBUaGVyZWZvcmUgd2Ugb25seSB3YW50IHRvIGFsbG9jYXRlIGEgbmV3XG4gICAgICAgICAgICAvLyBhcnJheSBmb3IgdGhlIHByb2plY3Rpb24gc2xvdHMgaWYgdGhlIGRlZmF1bHQgcHJvamVjdGlvbiBzbG90IGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoID4gMSB8fCB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzWzBdICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcjNSZXNlcnZlZFNsb3RzID0gdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcqJyA/IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IocykgOiBzOyB9KTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGFzTGl0ZXJhbChyM1Jlc2VydmVkU2xvdHMpLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhY2N1bXVsYXRlIG5nQ29udGVudCBzZWxlY3RvcnMgd2hpbGUgcHJvY2Vzc2luZyB0ZW1wbGF0ZSBlbGVtZW50cyxcbiAgICAgICAgICAgIC8vIHdlICpwcmVwZW5kKiBgcHJvamVjdGlvbkRlZmAgdG8gY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIGJsb2NrLCB0byBwdXQgaXQgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgYHByb2plY3Rpb25gIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzJDEucHJvamVjdGlvbkRlZiwgcGFyYW1ldGVycywgLyogcHJlcGVuZCAqLyB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdEkxOG5Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5FbmQobnVsbCwgc2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCB0aGUgY3JlYXRpb24gbW9kZSBpbnN0cnVjdGlvbnMgKGUuZy4gcmVzb2x2ZSBiaW5kaW5ncyBpbiBsaXN0ZW5lcnMpXG4gICAgICAgIHZhciBjcmVhdGlvblN0YXRlbWVudHMgPSB0aGlzLl9jcmVhdGlvbkNvZGVGbnMubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCB0aGUgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zIChlLmcuIHJlc29sdmUgcHJvcGVydHkgb3IgdGV4dCBiaW5kaW5ncylcbiAgICAgICAgdmFyIHVwZGF0ZVN0YXRlbWVudHMgPSB0aGlzLl91cGRhdGVDb2RlRm5zLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAvLyAgVmFyaWFibGUgZGVjbGFyYXRpb24gbXVzdCBvY2N1ciBhZnRlciBiaW5kaW5nIHJlc29sdXRpb24gc28gd2UgY2FuIGdlbmVyYXRlIGNvbnRleHRcbiAgICAgICAgLy8gIGluc3RydWN0aW9ucyB0aGF0IGJ1aWxkIG9uIGVhY2ggb3RoZXIuXG4gICAgICAgIC8vIGUuZy4gY29uc3QgYiA9IG5leHRDb250ZXh0KCkuJGltcGxpY2l0KCk7IGNvbnN0IGIgPSBuZXh0Q29udGV4dCgpO1xuICAgICAgICB2YXIgY3JlYXRpb25WYXJpYWJsZXMgPSB0aGlzLl9iaW5kaW5nU2NvcGUudmlld1NuYXBzaG90U3RhdGVtZW50cygpO1xuICAgICAgICB2YXIgdXBkYXRlVmFyaWFibGVzID0gdGhpcy5fYmluZGluZ1Njb3BlLnZhcmlhYmxlRGVjbGFyYXRpb25zKCkuY29uY2F0KHRoaXMuX3RlbXBWYXJpYWJsZXMpO1xuICAgICAgICB2YXIgY3JlYXRpb25CbG9jayA9IGNyZWF0aW9uU3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIFtyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0aW9uVmFyaWFibGVzLmNvbmNhdChjcmVhdGlvblN0YXRlbWVudHMpKV0gOlxuICAgICAgICAgICAgW107XG4gICAgICAgIHZhciB1cGRhdGVCbG9jayA9IHVwZGF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICBbcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogVXBkYXRlICovLCB1cGRhdGVWYXJpYWJsZXMuY29uY2F0KHVwZGF0ZVN0YXRlbWVudHMpKV0gOlxuICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgLy8gaS5lLiAocmY6IFJlbmRlckZsYWdzLCBjdHg6IGFueSlcbiAgICAgICAgW25ldyBGblBhcmFtKFJFTkRFUl9GTEFHUywgTlVNQkVSX1RZUEUpLCBuZXcgRm5QYXJhbShDT05URVhUX05BTUUsIG51bGwpXSwgX19zcHJlYWQodGhpcy5fcHJlZml4Q29kZSwgY3JlYXRpb25CbG9jaywgdXBkYXRlQmxvY2spLCBJTkZFUlJFRF9UWVBFLCBudWxsLCB0aGlzLnRlbXBsYXRlTmFtZSk7XG4gICAgfTtcbiAgICAvLyBMb2NhbFJlc29sdmVyXG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1Njb3BlLmdldChuYW1lKTtcbiAgICB9O1xuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuaTE4blRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwYXJhbXMsIHJlZiwgdHJhbnNmb3JtRm4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgdmFyIF9yZWYgPSByZWYgfHwgdmFyaWFibGUodGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShUUkFOU0xBVElPTl9QUkVGSVgpKTtcbiAgICAgICAgLy8gQ2xvc3VyZSBDb21waWxlciByZXF1aXJlcyBjb25zdCBuYW1lcyB0byBzdGFydCB3aXRoIGBNU0dfYCBidXQgZGlzYWxsb3dzIGFueSBvdGhlciBjb25zdCB0b1xuICAgICAgICAvLyBzdGFydCB3aXRoIGBNU0dfYC4gV2UgZGVmaW5lIGEgdmFyaWFibGUgc3RhcnRpbmcgd2l0aCBgTVNHX2AganVzdCBmb3IgdGhlIGBnb29nLmdldE1zZ2AgY2FsbFxuICAgICAgICB2YXIgY2xvc3VyZVZhciA9IHRoaXMuaTE4bkdlbmVyYXRlQ2xvc3VyZVZhcihtZXNzYWdlLmlkKTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCBfcmVmLCBjbG9zdXJlVmFyLCBwYXJhbXMsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgKF9hID0gdGhpcy5jb25zdGFudFBvb2wuc3RhdGVtZW50cykucHVzaC5hcHBseShfYSwgX19zcHJlYWQoc3RhdGVtZW50cykpO1xuICAgICAgICByZXR1cm4gX3JlZjtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnJlZ2lzdGVyQ29udGV4dFZhcmlhYmxlcyA9IGZ1bmN0aW9uICh2YXJpYWJsZSQxKSB7XG4gICAgICAgIHZhciBzY29wZWROYW1lID0gdGhpcy5fYmluZGluZ1Njb3BlLmZyZXNoUmVmZXJlbmNlTmFtZSgpO1xuICAgICAgICB2YXIgcmV0cmlldmFsTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICB2YXIgbGhzID0gdmFyaWFibGUodmFyaWFibGUkMS5uYW1lICsgc2NvcGVkTmFtZSk7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5zZXQocmV0cmlldmFsTGV2ZWwsIHZhcmlhYmxlJDEubmFtZSwgbGhzLCAxIC8qIENPTlRFWFQgKi8sIGZ1bmN0aW9uIChzY29wZSwgcmVsYXRpdmVMZXZlbCkge1xuICAgICAgICAgICAgdmFyIHJocztcbiAgICAgICAgICAgIGlmIChzY29wZS5iaW5kaW5nTGV2ZWwgPT09IHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBjdHhcbiAgICAgICAgICAgICAgICByaHMgPSB2YXJpYWJsZShDT05URVhUX05BTUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXJlZEN0eFZhciA9IHNjb3BlLmdldFNoYXJlZENvbnRleHROYW1lKHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGN0eF9yMCAgIE9SICB4KDIpO1xuICAgICAgICAgICAgICAgIHJocyA9IHNoYXJlZEN0eFZhciA/IHNoYXJlZEN0eFZhciA6IGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZS5nLiBjb25zdCAkaXRlbSQgPSB4KDIpLiRpbXBsaWNpdDtcbiAgICAgICAgICAgIHJldHVybiBbbGhzLnNldChyaHMucHJvcCh2YXJpYWJsZSQxLnZhbHVlIHx8IElNUExJQ0lUX1JFRkVSRU5DRSkpLnRvQ29uc3REZWNsKCldO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5BcHBlbmRCaW5kaW5ncyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbikgeyByZXR1cm4gX3RoaXMuaTE4bi5hcHBlbmRCaW5kaW5nKGV4cHJlc3Npb24pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuaTE4bkJpbmRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYm91bmQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgYm91bmRba2V5XSA9IGxpdGVyYWwocHJvcC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLnZhbHVlLnZpc2l0KF90aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZ3MgPSB2YWx1ZS5zdHJpbmdzLCBleHByZXNzaW9ucyA9IHZhbHVlLmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5pMThuLCBpZCA9IF9hLmlkLCBiaW5kaW5ncyA9IF9hLmJpbmRpbmdzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBhc3NlbWJsZUkxOG5Cb3VuZFN0cmluZyhzdHJpbmdzLCBiaW5kaW5ncy5zaXplLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmkxOG5BcHBlbmRCaW5kaW5ncyhleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kW2tleV0gPSBsaXRlcmFsKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pMThuR2VuZXJhdGVDbG9zdXJlVmFyID0gZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KFwiRVhURVJOQUxfXCIpO1xuICAgICAgICAgICAgdmFyIHVuaXF1ZVN1ZmZpeCA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoc3VmZml4KTtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiICsgcHJlZml4ICsgc2FuaXRpemVJZGVudGlmaWVyKG1lc3NhZ2VJZCkgKyBcIiQkXCIgKyB1bmlxdWVTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZ2V0VHJhbnNsYXRpb25Db25zdFByZWZpeChzdWZmaXgpO1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUocHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFibGUobmFtZSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pMThuVXBkYXRlUmVmID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGljdXMgPSBjb250ZXh0LmljdXMsIG1ldGEgPSBjb250ZXh0Lm1ldGEsIGlzUm9vdCA9IGNvbnRleHQuaXNSb290LCBpc1Jlc29sdmVkID0gY29udGV4dC5pc1Jlc29sdmVkLCBpc0VtaXR0ZWQgPSBjb250ZXh0LmlzRW1pdHRlZDtcbiAgICAgICAgaWYgKGlzUm9vdCAmJiBpc1Jlc29sdmVkICYmICFpc0VtaXR0ZWQgJiYgIWlzU2luZ2xlSTE4bkljdShtZXRhKSkge1xuICAgICAgICAgICAgY29udGV4dC5pc0VtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IGNvbnRleHQuZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpO1xuICAgICAgICAgICAgdmFyIGljdU1hcHBpbmdfMSA9IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmFtc18xID0gcGxhY2Vob2xkZXJzLnNpemUgPyBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpIDoge307XG4gICAgICAgICAgICBpZiAoaWN1cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgaWN1cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG9uZSBJQ1UgZGVmaW5lZCBmb3IgYSBnaXZlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgLSBqdXN0IG91dHB1dCBpdHMgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNfMVtrZXldID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UgbmVlZCB0byBhY3RpdmF0ZSBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlcGxhY2UgSUNVIHBsYWNlaG9sZGVycyB3aXRoIHByb3BlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHdyYXBJMThuUGxhY2Vob2xkZXIoXCJcIiArIEkxOE5fSUNVX01BUFBJTkdfUFJFRklYICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc18xW2tleV0gPSBsaXRlcmFsKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljdU1hcHBpbmdfMVtrZXldID0gbGl0ZXJhbEFycihyZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb24gcmVxdWlyZXMgcG9zdCBwcm9jZXNzaW5nIGluIDIgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGlmIHdlIGhhdmUgcGxhY2Vob2xkZXJzIHdpdGggbXVsdGlwbGUgdmFsdWVzIChleC4gYFNUQVJUX0RJVmA6IFvvv70jMe+/vSwg77+9IzLvv70sIC4uLl0pXG4gICAgICAgICAgICAvLyAtIGlmIHdlIGhhdmUgbXVsdGlwbGUgSUNVcyB0aGF0IHJlZmVyIHRvIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWVcbiAgICAgICAgICAgIHZhciBuZWVkc1Bvc3Rwcm9jZXNzaW5nID0gQXJyYXkuZnJvbShwbGFjZWhvbGRlcnMudmFsdWVzKCkpLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5sZW5ndGggPiAxOyB9KSB8fFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGljdU1hcHBpbmdfMSkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUZuID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG5lZWRzUG9zdHByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1GbiA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbcmF3XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGljdU1hcHBpbmdfMSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWFwTGl0ZXJhbChpY3VNYXBwaW5nXzEsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5pMThuUG9zdHByb2Nlc3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmkxOG5UcmFuc2xhdGUobWV0YSwgcGFyYW1zXzEsIGNvbnRleHQucmVmLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5TdGFydCA9IGZ1bmN0aW9uIChzcGFuLCBtZXRhLCBzZWxmQ2xvc2luZykge1xuICAgICAgICBpZiAoc3BhbiA9PT0gdm9pZCAwKSB7IHNwYW4gPSBudWxsOyB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBpZiAodGhpcy5pMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuID0gdGhpcy5pMThuQ29udGV4dC5mb3JrQ2hpbGRDb250ZXh0KGluZGV4LCB0aGlzLnRlbXBsYXRlSW5kZXgsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlZl8xID0gdmFyaWFibGUodGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShUUkFOU0xBVElPTl9QUkVGSVgpKTtcbiAgICAgICAgICAgIHRoaXMuaTE4biA9IG5ldyBJMThuQ29udGV4dChpbmRleCwgcmVmXzEsIDAsIHRoaXMudGVtcGxhdGVJbmRleCwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2VuZXJhdGUgaTE4blN0YXJ0IGluc3RydWN0aW9uXG4gICAgICAgIHZhciBfYSA9IHRoaXMuaTE4biwgaWQgPSBfYS5pZCwgcmVmID0gX2EucmVmO1xuICAgICAgICB2YXIgcGFyYW1zID0gW2xpdGVyYWwoaW5kZXgpLCByZWZdO1xuICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgICAvLyBkbyBub3QgcHVzaCAzcmQgYXJndW1lbnQgKHN1Yi1ibG9jayBpZClcbiAgICAgICAgICAgIC8vIGludG8gaTE4blN0YXJ0IGNhbGwgZm9yIHRvcCBsZXZlbCBpMThuIGNvbnRleHRcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3Bhbiwgc2VsZkNsb3NpbmcgPyBJZGVudGlmaWVycyQxLmkxOG4gOiBJZGVudGlmaWVycyQxLmkxOG5TdGFydCwgcGFyYW1zKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5FbmQgPSBmdW5jdGlvbiAoc3Bhbiwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNwYW4gPT09IHZvaWQgMCkgeyBzcGFuID0gbnVsbDsgfVxuICAgICAgICBpZiAoIXRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpMThuRW5kIGlzIGV4ZWN1dGVkIHdpdGggbm8gaTE4biBjb250ZXh0IHByZXNlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuQ29udGV4dC5yZWNvbmNpbGVDaGlsZENvbnRleHQodGhpcy5pMThuKTtcbiAgICAgICAgICAgIHRoaXMuaTE4blVwZGF0ZVJlZih0aGlzLmkxOG5Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blVwZGF0ZVJlZih0aGlzLmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIGFjY3VtdWxhdGVkIGJpbmRpbmdzXG4gICAgICAgIHZhciBfYSA9IHRoaXMuaTE4biwgaW5kZXggPSBfYS5pbmRleCwgYmluZGluZ3MgPSBfYS5iaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzLnNpemUpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkJpbmRpbmdzXzEgPSBbXTtcbiAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBjaGFpbkJpbmRpbmdzXzEucHVzaCh7IHNvdXJjZVNwYW46IHNwYW4sIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJpbmRpbmcpOyB9IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBmb3IgaTE4biBibG9jaywgYWR2YW5jZSB0byB0aGUgbW9zdCByZWNlbnQgZWxlbWVudCBpbmRleCAoYnkgdGFraW5nIHRoZSBjdXJyZW50IG51bWJlciBvZlxuICAgICAgICAgICAgLy8gZWxlbWVudHMgYW5kIHN1YnRyYWN0aW5nIG9uZSkgYmVmb3JlIGludm9raW5nIGBpMThuRXhwYCBpbnN0cnVjdGlvbnMsIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBsaWZlY3ljbGUgaG9va3Mgb2YgY29tcG9uZW50cy9kaXJlY3RpdmVzIGFyZSBwcm9wZXJseSBmbHVzaGVkLlxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbkNoYWluV2l0aEFkdmFuY2UodGhpcy5nZXRDb25zdENvdW50KCkgLSAxLCBJZGVudGlmaWVycyQxLmkxOG5FeHAsIGNoYWluQmluZGluZ3NfMSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIElkZW50aWZpZXJzJDEuaTE4bkFwcGx5LCBbbGl0ZXJhbChpbmRleCldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgSWRlbnRpZmllcnMkMS5pMThuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkxOG4gPSBudWxsOyAvLyByZXNldCBsb2NhbCBpMThuIGNvbnRleHRcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmkxOG5BdHRyaWJ1dGVzSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobm9kZUluZGV4LCBhdHRycywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFzQmluZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGkxOG5BdHRyQXJncyA9IFtdO1xuICAgICAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhdHRyLmkxOG47XG4gICAgICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFRleHRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBpMThuQXR0ckFyZ3MucHVzaChsaXRlcmFsKGF0dHIubmFtZSksIF90aGlzLmkxOG5UcmFuc2xhdGUobWVzc2FnZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGF0dHIudmFsdWUudmlzaXQoX3RoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyhjb252ZXJ0ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0ZWQgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHBsYWNlaG9sZGVyc1RvUGFyYW1zKHBsYWNlaG9sZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGkxOG5BdHRyQXJncy5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgX3RoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydGVkLmV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoZXhwcmVzc2lvbik7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKG5vZGVJbmRleCwgSWRlbnRpZmllcnMkMS5pMThuRXhwLCBiaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkxOG5BdHRyQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXRlcmFsKHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpKTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIoaTE4bkF0dHJBcmdzKSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5pMThuQXR0cmlidXRlcywgW2luZGV4LCBhcmdzXSk7XG4gICAgICAgICAgICBpZiAoaGFzQmluZGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEuaTE4bkFwcGx5LCBbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobmFtZXNwYWNlS2V5KSB7XG4gICAgICAgIHN3aXRjaCAobmFtZXNwYWNlS2V5KSB7XG4gICAgICAgICAgICBjYXNlICdtYXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VNYXRoTUw7XG4gICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLm5hbWVzcGFjZVNWRztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEubmFtZXNwYWNlSFRNTDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkTmFtZXNwYWNlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAobnNJbnN0cnVjdGlvbiwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuc0luc3RydWN0aW9uO1xuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zb3VyY2VTcGFuLCBuc0luc3RydWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gdXBkYXRlIGluc3RydWN0aW9uIGZvciBhbiBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgb3IgYXR0cmlidXRlLCBzdWNoIGFzXG4gICAgICogYHByb3A9XCJ7e3ZhbHVlfX1cImAgb3IgYGF0dHIudGl0bGU9XCJ7e3ZhbHVlfX1cImBcbiAgICAgKi9cbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbiwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgaW5zdHJ1Y3Rpb24sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fc3ByZWFkKFtsaXRlcmFsKGF0dHJOYW1lKV0sIF90aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSwgcGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdENvbnRlbnQgPSBmdW5jdGlvbiAobmdDb250ZW50KSB7XG4gICAgICAgIHZhciBzbG90ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uU2xvdElkeCA9IHRoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCArIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtsaXRlcmFsKHNsb3QpXTtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5wdXNoKG5nQ29udGVudC5zZWxlY3Rvcik7XG4gICAgICAgIHZhciBub25Db250ZW50U2VsZWN0QXR0cmlidXRlcyA9IG5nQ29udGVudC5hdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkgIT09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIkMTsgfSk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhub25Db250ZW50U2VsZWN0QXR0cmlidXRlcywgW10sIFtdKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpLCBsaXRlcmFsQXJyKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0aW9uU2xvdElkeCAhPT0gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obmdDb250ZW50LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEucHJvamVjdGlvbiwgcGFyYW1ldGVycyk7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRQcm9qZWN0aW9uKG5nQ29udGVudC5pMThuLCBzbG90KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50SW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdmFyIHN0eWxpbmdCdWlsZGVyID0gbmV3IFN0eWxpbmdCdWlsZGVyKG51bGwpO1xuICAgICAgICB2YXIgaXNOb25CaW5kYWJsZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzSTE4blJvb3RFbGVtZW50ID0gaXNJMThuUm9vdE5vZGUoZWxlbWVudC5pMThuKSAmJiAhaXNTaW5nbGVJMThuSWN1KGVsZW1lbnQuaTE4bik7XG4gICAgICAgIHZhciBpMThuQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dEF0dHJzID0gW107XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChzcGxpdE5zTmFtZShlbGVtZW50Lm5hbWUpLCAyKSwgbmFtZXNwYWNlS2V5ID0gX2JbMF0sIGVsZW1lbnROYW1lID0gX2JbMV07XG4gICAgICAgIHZhciBpc05nQ29udGFpbmVyJDEgPSBpc05nQ29udGFpbmVyKGVsZW1lbnQubmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc3R5bGluZywgaTE4biwgbmdOb25CaW5kYWJsZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKGVsZW1lbnQuYXR0cmlidXRlcyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBhdHRyLm5hbWUsIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xID09PSBOT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgICAgICAgICBpc05vbkJpbmRhYmxlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlclN0eWxlQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoYXR0ci5pMThuID8gaTE4bkF0dHJzIDogb3V0cHV0QXR0cnMpLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF0Y2ggZGlyZWN0aXZlcyBvbiBub24gaTE4biBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMubWF0Y2hEaXJlY3RpdmVzKGVsZW1lbnQubmFtZSwgZWxlbWVudCk7XG4gICAgICAgIC8vIFJlZ3VsYXIgZWxlbWVudCBvciBuZy1jb250YWluZXIgY3JlYXRpb24gbW9kZVxuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFtsaXRlcmFsKGVsZW1lbnRJbmRleCldO1xuICAgICAgICBpZiAoIWlzTmdDb250YWluZXIkMSkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwoZWxlbWVudE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgdmFyIGFsbE90aGVySW5wdXRzID0gW107XG4gICAgICAgIGVsZW1lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGluZ0lucHV0V2FzU2V0ID0gc3R5bGluZ0J1aWxkZXIucmVnaXN0ZXJCb3VuZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIGlmICghc3R5bGluZ0lucHV0V2FzU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IDAgLyogUHJvcGVydHkgKi8gJiYgaW5wdXQuaTE4bikge1xuICAgICAgICAgICAgICAgICAgICBpMThuQXR0cnMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGxPdGhlcklucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgYXR0cmlidXRlcyBmb3IgZGlyZWN0aXZlIGFuZCBwcm9qZWN0aW9uIG1hdGNoaW5nIHB1cnBvc2VzXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhvdXRwdXRBdHRycywgYWxsT3RoZXJJbnB1dHMsIGVsZW1lbnQub3V0cHV0cywgc3R5bGluZ0J1aWxkZXIsIFtdLCBpMThuQXR0cnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRBdHRyc1RvQ29uc3RzKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgLy8gbG9jYWwgcmVmcyAoZXguOiA8ZGl2ICNmb28gI2Jhcj1cImJhelwiPilcbiAgICAgICAgdmFyIHJlZnMgPSB0aGlzLnByZXBhcmVSZWZzQXJyYXkoZWxlbWVudC5yZWZlcmVuY2VzKTtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHRoaXMuYWRkVG9Db25zdHMocmVmcykpO1xuICAgICAgICB2YXIgd2FzSW5OYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIHZhciBjdXJyZW50TmFtZXNwYWNlID0gdGhpcy5nZXROYW1lc3BhY2VJbnN0cnVjdGlvbihuYW1lc3BhY2VLZXkpO1xuICAgICAgICAvLyBJZiB0aGUgbmFtZXNwYWNlIGlzIGNoYW5naW5nIG5vdywgaW5jbHVkZSBhbiBpbnN0cnVjdGlvbiB0byBjaGFuZ2UgaXRcbiAgICAgICAgLy8gZHVyaW5nIGVsZW1lbnQgY3JlYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50TmFtZXNwYWNlICE9PSB3YXNJbk5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROYW1lc3BhY2VJbnN0cnVjdGlvbihjdXJyZW50TmFtZXNwYWNlLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBhcHBlbmQgdGV4dCBub2RlIGluc3RydWN0aW9ucyBhbmQgSUNVcyBpbnNpZGUgaTE4biBzZWN0aW9uLFxuICAgICAgICAvLyBzbyB3ZSBleGNsdWRlIHRoZW0gd2hpbGUgY2FsY3VsYXRpbmcgd2hldGhlciBjdXJyZW50IGVsZW1lbnQgaGFzIGNoaWxkcmVuXG4gICAgICAgIHZhciBoYXNDaGlsZHJlbiA9ICghaXNJMThuUm9vdEVsZW1lbnQgJiYgdGhpcy5pMThuKSA/ICFoYXNUZXh0Q2hpbGRyZW5Pbmx5KGVsZW1lbnQuY2hpbGRyZW4pIDpcbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgdmFyIGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24gPSAhc3R5bGluZ0J1aWxkZXIuaGFzQmluZGluZ3NXaXRoUGlwZXMgJiZcbiAgICAgICAgICAgIGVsZW1lbnQub3V0cHV0cy5sZW5ndGggPT09IDAgJiYgaTE4bkF0dHJzLmxlbmd0aCA9PT0gMCAmJiAhaGFzQ2hpbGRyZW47XG4gICAgICAgIHZhciBjcmVhdGVTZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbiA9ICFjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uICYmIGhhc1RleHRDaGlsZHJlbk9ubHkoZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmIChjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zb3VyY2VTcGFuLCBpc05nQ29udGFpbmVyJDEgPyBJZGVudGlmaWVycyQxLmVsZW1lbnRDb250YWluZXIgOiBJZGVudGlmaWVycyQxLmVsZW1lbnQsIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnNvdXJjZVNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lclN0YXJ0IDogSWRlbnRpZmllcnMkMS5lbGVtZW50U3RhcnQsIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpKTtcbiAgICAgICAgICAgIGlmIChpc05vbkJpbmRhYmxlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEuZGlzYWJsZUJpbmRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpMThuQXR0cnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkF0dHJpYnV0ZXNJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGkxOG5BdHRycywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIExpc3RlbmVycyAob3V0cHV0cylcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBlbGVtZW50Lm91dHB1dHMubWFwKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG91dHB1dEFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IF90aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcihlbGVtZW50Lm5hbWUsIG91dHB1dEFzdCwgZWxlbWVudEluZGV4KVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb25DaGFpbihJZGVudGlmaWVycyQxLmxpc3RlbmVyLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8ga2VlcCBpMThuL2kxOG5TdGFydCBpbnN0cnVjdGlvbnMgYWZ0ZXIgaTE4bkF0dHJpYnV0ZXMgYW5kXG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRvIG1ha2Ugc3VyZSBpMThuQXR0cmlidXRlcyBpbnN0cnVjdGlvbiB0YXJnZXRzIGN1cnJlbnQgZWxlbWVudCBhdCBydW50aW1lLlxuICAgICAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQoZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4sIGNyZWF0ZVNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgY29kZSBoZXJlIHdpbGwgY29sbGVjdCBhbGwgdXBkYXRlLWxldmVsIHN0eWxpbmcgaW5zdHJ1Y3Rpb25zIGFuZCBhZGQgdGhlbSB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIGJsb2NrIG9mIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiBBT1QgY29kZS4gSW5zdHJ1Y3Rpb25zIGxpa2UgYHN0eWxlUHJvcGAsXG4gICAgICAgIC8vIGBzdHlsZU1hcGAsIGBjbGFzc01hcGAsIGBjbGFzc1Byb3BgXG4gICAgICAgIC8vIGFyZSBhbGwgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBpbiB0aGUgY29kZSBiZWxvdy5cbiAgICAgICAgdmFyIHN0eWxpbmdJbnN0cnVjdGlvbnMgPSBzdHlsaW5nQnVpbGRlci5idWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgdmFyIGxpbWl0ID0gc3R5bGluZ0luc3RydWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25fMSA9IHN0eWxpbmdJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdGhpcy5wcm9jZXNzU3R5bGluZ1VwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5zdHJ1Y3Rpb25fMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgYHVuZGVmaW5lZGAgaXMgdXNlZCBpcyBiZWNhdXNlIHRoZSByZW5kZXJlciB1bmRlcnN0YW5kcyB0aGlzIGFzIGFcbiAgICAgICAgLy8gc3BlY2lhbCB2YWx1ZSB0byBzeW1ib2xpemUgdGhhdCB0aGVyZSBpcyBubyBSSFMgdG8gdGhpcyBiaW5kaW5nXG4gICAgICAgIC8vIFRPRE8gKG1hdHNrbyk6IHJldmlzaXQgdGhpcyBvbmNlIEZXLTk1OSBpcyBhcHByb2FjaGVkXG4gICAgICAgIHZhciBlbXB0eVZhbHVlQmluZEluc3RydWN0aW9uID0gbGl0ZXJhbCh1bmRlZmluZWQpO1xuICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgICAgICB2YXIgYXR0cmlidXRlQmluZGluZ3MgPSBbXTtcbiAgICAgICAgLy8gR2VuZXJhdGUgZWxlbWVudCBpbnB1dCBiaW5kaW5nc1xuICAgICAgICBhbGxPdGhlcklucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IGlucHV0LnR5cGU7XG4gICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSA0IC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gaW5wdXQudmFsdWUudmlzaXQoX3RoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gYmluZGluZ3MgY2FuIGJlIHByZXNlbnRlZCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAgICAgICAgICAgICAgLy8gMS4gW0BiaW5kaW5nXT1cImZvb0V4cFwiXG4gICAgICAgICAgICAgICAgLy8gMi4gW0BiaW5kaW5nXT1cInt2YWx1ZTpmb29FeHAsIHBhcmFtczp7Li4ufX1cIlxuICAgICAgICAgICAgICAgIC8vIDMuIFtAYmluZGluZ11cbiAgICAgICAgICAgICAgICAvLyA0LiBAYmluZGluZ1xuICAgICAgICAgICAgICAgIC8vIEFsbCBmb3JtYXRzIHdpbGwgYmUgdmFsaWQgZm9yIHdoZW4gYSBzeW50aGV0aWMgYmluZGluZyBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb25pbmcgZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgc2hvdWxkIGdldCBlYWNoXG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIGJpbmRpbmcgdmFsdWUgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSB0aGF0IHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbi4uLlxuICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZV8xID0gdmFsdWVfMSBpbnN0YW5jZW9mIExpdGVyYWxQcmltaXRpdmUgPyAhIXZhbHVlXzEudmFsdWUgOiB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlXzEpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUoaW5wdXQubmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNWYWx1ZV8xID8gX3RoaXMuY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZV8xKSA6IGVtcHR5VmFsdWVCaW5kSW5zdHJ1Y3Rpb247IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIG11c3Qgc2tpcCBhdHRyaWJ1dGVzIHdpdGggYXNzb2NpYXRlZCBpMThuIGNvbnRleHQsIHNpbmNlIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIGhhbmRsZWRcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWx5IGFuZCBjb3JyZXNwb25kaW5nIGBpMThuRXhwYCBhbmQgYGkxOG5BcHBseWAgaW5zdHJ1Y3Rpb25zIHdpbGwgYmUgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmkxOG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMiA9IGlucHV0LnZhbHVlLnZpc2l0KF90aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlXzIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zXzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHNwbGl0TnNOYW1lKGlucHV0Lm5hbWUpLCAyKSwgYXR0ck5hbWVzcGFjZSA9IF9hWzBdLCBhdHRyTmFtZV8xID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0F0dHJpYnV0ZUJpbmRpbmcgPSBpbnB1dFR5cGUgPT09IDEgLyogQXR0cmlidXRlICovO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemF0aW9uUmVmID0gcmVzb2x2ZVNhbml0aXphdGlvbkZuKGlucHV0LnNlY3VyaXR5Q29udGV4dCwgaXNBdHRyaWJ1dGVCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbml0aXphdGlvblJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc18yLnB1c2goc2FuaXRpemF0aW9uUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2VMaXRlcmFsID0gbGl0ZXJhbChhdHRyTmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW5pdGl6YXRpb25SZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNfMi5wdXNoKG5hbWVzcGFjZUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2Fzbid0IGEgc2FuaXRpemF0aW9uIHJlZiwgd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBleHRyYSBwYXJhbSBzbyB0aGF0IHdlIGNhbiBwYXNzIGluIHRoZSBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXzIucHVzaChsaXRlcmFsKG51bGwpLCBuYW1lc3BhY2VMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gMCAvKiBQcm9wZXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzIgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcD1cInt7dmFsdWV9fVwiIGFuZCBmcmllbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJwb2xhdGVkVXBkYXRlSW5zdHJ1Y3Rpb24oZ2V0UHJvcGVydHlJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZV8yKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZV8xLCBpbnB1dCwgdmFsdWVfMiwgcGFyYW1zXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3Byb3BdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIGNoYWluIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZV8yKTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNfMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gMSAvKiBBdHRyaWJ1dGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8yIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiAmJiBnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aCh2YWx1ZV8yKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRyLm5hbWU9XCJ0ZXh0e3t2YWx1ZX19XCIgYW5kIGZyaWVuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZV8yKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZV8xLCBpbnB1dCwgdmFsdWVfMiwgcGFyYW1zXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kVmFsdWVfMSA9IHZhbHVlXzIgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uID8gdmFsdWVfMi5leHByZXNzaW9uc1swXSA6IHZhbHVlXzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2F0dHIubmFtZV09XCJ2YWx1ZVwiIG9yIGF0dHIubmFtZT1cInt7dmFsdWV9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCB0aGUgYXR0cmlidXRlIGJpbmRpbmdzIHNvIHRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhdHRyTmFtZV8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udmVydFByb3BlcnR5QmluZGluZyhib3VuZFZhbHVlXzEpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtc18yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGFzcyBwcm9wXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5jbGFzc1Byb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGVsZW1lbnRJbmRleCksIGxpdGVyYWwoYXR0ck5hbWVfMSksIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWVfMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBwYXJhbXNfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgSWRlbnRpZmllcnMkMS5wcm9wZXJ0eSwgcHJvcGVydHlCaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGUsIGF0dHJpYnV0ZUJpbmRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmF2ZXJzZSBlbGVtZW50IGNoaWxkIG5vZGVzXG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWlzSTE4blJvb3RFbGVtZW50ICYmIHRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZEVsZW1lbnQoZWxlbWVudC5pMThuLCBlbGVtZW50SW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3JlYXRlU2VsZkNsb3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgLy8gRmluaXNoIGVsZW1lbnQgY29uc3RydWN0aW9uIG1vZGUuXG4gICAgICAgICAgICB2YXIgc3BhbiA9IGVsZW1lbnQuZW5kU291cmNlU3BhbiB8fCBlbGVtZW50LnNvdXJjZVNwYW47XG4gICAgICAgICAgICBpZiAoaXNJMThuUm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5FbmQoc3BhbiwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTm9uQmluZGFibGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIElkZW50aWZpZXJzJDEuZW5hYmxlQmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lckVuZCA6IElkZW50aWZpZXJzJDEuZWxlbWVudEVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0VGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIE5HX1RFTVBMQVRFX1RBR19OQU1FID0gJ25nLXRlbXBsYXRlJztcbiAgICAgICAgdmFyIHRlbXBsYXRlSW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgaWYgKHRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZFRlbXBsYXRlKHRlbXBsYXRlLmkxOG4sIHRlbXBsYXRlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWdOYW1lID0gc2FuaXRpemVJZGVudGlmaWVyKHRlbXBsYXRlLnRhZ05hbWUgfHwgJycpO1xuICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBcIlwiICsgdGhpcy5jb250ZXh0TmFtZSArICh0YWdOYW1lID8gJ18nICsgdGFnTmFtZSA6ICcnKSArIFwiX1wiICsgdGVtcGxhdGVJbmRleDtcbiAgICAgICAgdmFyIHRlbXBsYXRlTmFtZSA9IGNvbnRleHROYW1lICsgXCJfVGVtcGxhdGVcIjtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICBsaXRlcmFsKHRlbXBsYXRlSW5kZXgpLFxuICAgICAgICAgICAgdmFyaWFibGUodGVtcGxhdGVOYW1lKSxcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIHRhZydzIG5hbWVzcGFjZSBoZXJlLCBiZWNhdXNlIHdlIGluZmVyXG4gICAgICAgICAgICAvLyBpdCBiYXNlZCBvbiB0aGUgcGFyZW50IG5vZGVzIGluc2lkZSB0aGUgdGVtcGxhdGUgaW5zdHJ1Y3Rpb24uXG4gICAgICAgICAgICBsaXRlcmFsKHRlbXBsYXRlLnRhZ05hbWUgPyBzcGxpdE5zTmFtZSh0ZW1wbGF0ZS50YWdOYW1lKVsxXSA6IHRlbXBsYXRlLnRhZ05hbWUpLFxuICAgICAgICBdO1xuICAgICAgICAvLyBmaW5kIGRpcmVjdGl2ZXMgbWF0Y2hpbmcgb24gYSBnaXZlbiA8bmctdGVtcGxhdGU+IG5vZGVcbiAgICAgICAgdGhpcy5tYXRjaERpcmVjdGl2ZXMoTkdfVEVNUExBVEVfVEFHX05BTUUsIHRlbXBsYXRlKTtcbiAgICAgICAgLy8gcHJlcGFyZSBhdHRyaWJ1dGVzIHBhcmFtZXRlciAoaW5jbHVkaW5nIGF0dHJpYnV0ZXMgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nKVxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocGFydGl0aW9uQXJyYXkodGVtcGxhdGUuYXR0cmlidXRlcywgaGFzSTE4bk1ldGEpLCAyKSwgaTE4blN0YXRpY0F0dHJzID0gX2FbMF0sIHN0YXRpY0F0dHJzID0gX2FbMV07XG4gICAgICAgIHZhciBhdHRyc0V4cHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhzdGF0aWNBdHRycywgdGVtcGxhdGUuaW5wdXRzLCB0ZW1wbGF0ZS5vdXRwdXRzLCB1bmRlZmluZWQgLyogc3R5bGVzICovLCB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzLCBpMThuU3RhdGljQXR0cnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRBdHRyc1RvQ29uc3RzKGF0dHJzRXhwcnMpKTtcbiAgICAgICAgLy8gbG9jYWwgcmVmcyAoZXguOiA8bmctdGVtcGxhdGUgI2Zvbz4pXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5yZWZlcmVuY2VzICYmIHRlbXBsYXRlLnJlZmVyZW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVmcyA9IHRoaXMucHJlcGFyZVJlZnNBcnJheSh0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZFRvQ29uc3RzKHJlZnMpKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEudGVtcGxhdGVSZWZFeHRyYWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB0ZW1wbGF0ZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlcih0aGlzLmNvbnN0YW50UG9vbCwgdGhpcy5fYmluZGluZ1Njb3BlLCB0aGlzLmxldmVsICsgMSwgY29udGV4dE5hbWUsIHRoaXMuaTE4biwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIsIHRoaXMuZGlyZWN0aXZlcywgdGhpcy5waXBlVHlwZUJ5TmFtZSwgdGhpcy5waXBlcywgdGhpcy5fbmFtZXNwYWNlLCB0aGlzLmZpbGVCYXNlZEkxOG5TdWZmaXgsIHRoaXMuaTE4blVzZUV4dGVybmFsSWRzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICAvLyBOZXN0ZWQgdGVtcGxhdGVzIG11c3Qgbm90IGJlIHZpc2l0ZWQgdW50aWwgYWZ0ZXIgdGhlaXIgcGFyZW50IHRlbXBsYXRlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAgICAvLyBwcm9jZXNzaW5nLCBzbyB0aGV5IGFyZSBxdWV1ZWQgaGVyZSB1bnRpbCBhZnRlciB0aGUgaW5pdGlhbCBwYXNzLiBPdGhlcndpc2UsIHdlIHdvdWxkbid0XG4gICAgICAgIC8vIGJlIGFibGUgdG8gc3VwcG9ydCBiaW5kaW5ncyBpbiBuZXN0ZWQgdGVtcGxhdGVzIHRvIGxvY2FsIHJlZnMgdGhhdCBvY2N1ciBhZnRlciB0aGVcbiAgICAgICAgLy8gdGVtcGxhdGUgZGVmaW5pdGlvbi4gZS5nLiA8ZGl2ICpuZ0lmPVwic2hvd2luZ1wiPnt7IGZvbyB9fTwvZGl2PiAgPGRpdiAjZm9vPjwvZGl2PlxuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uRXhwciA9IHRlbXBsYXRlVmlzaXRvci5idWlsZFRlbXBsYXRlRnVuY3Rpb24odGVtcGxhdGUuY2hpbGRyZW4sIHRlbXBsYXRlLnZhcmlhYmxlcywgX3RoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoICsgX3RoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCwgdGVtcGxhdGUuaTE4bik7XG4gICAgICAgICAgICBfdGhpcy5jb25zdGFudFBvb2wuc3RhdGVtZW50cy5wdXNoKHRlbXBsYXRlRnVuY3Rpb25FeHByLnRvRGVjbFN0bXQodGVtcGxhdGVOYW1lLCBudWxsKSk7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVWaXNpdG9yLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZCh0ZW1wbGF0ZVZpc2l0b3IuX25nQ29udGVudFJlc2VydmVkU2xvdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGUuZy4gdGVtcGxhdGUoMSwgTXlDb21wX1RlbXBsYXRlXzEpXG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZW1wbGF0ZS5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLnRlbXBsYXRlQ3JlYXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnNwbGljZSgyLCAwLCBsaXRlcmFsKHRlbXBsYXRlVmlzaXRvci5nZXRDb25zdENvdW50KCkpLCBsaXRlcmFsKHRlbXBsYXRlVmlzaXRvci5nZXRWYXJDb3VudCgpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBoYW5kbGUgcHJvcGVydHkgYmluZGluZ3MgZS5nLiDJtcm1cHJvcGVydHkoJ25nRm9yT2YnLCBjdHguaXRlbXMpLCBldCBhbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVByb3BlcnR5QmluZGluZ3ModGVtcGxhdGVJbmRleCwgdGVtcGxhdGUudGVtcGxhdGVBdHRycyk7XG4gICAgICAgIC8vIE9ubHkgYWRkIG5vcm1hbCBpbnB1dC9vdXRwdXQgYmluZGluZyBpbnN0cnVjdGlvbnMgb24gZXhwbGljaXQgPG5nLXRlbXBsYXRlPiBlbGVtZW50cy5cbiAgICAgICAgaWYgKHRlbXBsYXRlLnRhZ05hbWUgPT09IE5HX1RFTVBMQVRFX1RBR19OQU1FKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQocGFydGl0aW9uQXJyYXkodGVtcGxhdGUuaW5wdXRzLCBoYXNJMThuTWV0YSksIDIpLCBpMThuSW5wdXRzID0gX2JbMF0sIGlucHV0cyA9IF9iWzFdO1xuICAgICAgICAgICAgdmFyIGkxOG5BdHRycyA9IF9fc3ByZWFkKGkxOG5TdGF0aWNBdHRycywgaTE4bklucHV0cyk7XG4gICAgICAgICAgICAvLyBBZGQgaTE4biBhdHRyaWJ1dGVzIHRoYXQgbWF5IGFjdCBhcyBpbnB1dHMgdG8gZGlyZWN0aXZlcy4gSWYgc3VjaCBhdHRyaWJ1dGVzIGFyZSBwcmVzZW50LFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYGkxOG5BdHRyaWJ1dGVzYCBpbnN0cnVjdGlvbi4gTm90ZTogd2UgZ2VuZXJhdGUgaXQgb25seSBmb3IgZXhwbGljaXQgPG5nLXRlbXBsYXRlPlxuICAgICAgICAgICAgLy8gZWxlbWVudHMsIGluIGNhc2Ugb2YgaW5saW5lIHRlbXBsYXRlcywgY29ycmVzcG9uZGluZyBpbnN0cnVjdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBuZXN0ZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAoaTE4bkF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5BdHRyaWJ1dGVzSW5zdHJ1Y3Rpb24odGVtcGxhdGVJbmRleCwgaTE4bkF0dHJzLCB0ZW1wbGF0ZS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIGlucHV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBsaXN0ZW5lcnMgZm9yIGRpcmVjdGl2ZSBvdXRwdXRcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5vdXRwdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGVtcGxhdGUub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3Bhbjogb3V0cHV0QXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogX3RoaXMucHJlcGFyZUxpc3RlbmVyUGFyYW1ldGVyKCduZ190ZW1wbGF0ZScsIG91dHB1dEFzdCwgdGVtcGxhdGVJbmRleClcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uQ2hhaW4oSWRlbnRpZmllcnMkMS5saXN0ZW5lciwgbGlzdGVuZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMyA9IHRleHQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZV8zKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV8zIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRCb3VuZFRleHQodGV4dC5pMThuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5BcHBlbmRCaW5kaW5ncyh2YWx1ZV8zLmV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZXh0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEudGV4dCwgW2xpdGVyYWwobm9kZUluZGV4KV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSB0ZXh0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZShub2RlSW5kZXgsIHRleHQuc291cmNlU3BhbiwgZ2V0VGV4dEludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdUZXh0IG5vZGVzIHNob3VsZCBiZSBpbnRlcnBvbGF0ZWQgYW5kIG5ldmVyIGJvdW5kIGRpcmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAvLyB3aGVuIGEgdGV4dCBlbGVtZW50IGlzIGxvY2F0ZWQgd2l0aGluIGEgdHJhbnNsYXRhYmxlXG4gICAgICAgIC8vIGJsb2NrLCB3ZSBleGNsdWRlIHRoaXMgdGV4dCBlbGVtZW50IGZyb20gaW5zdHJ1Y3Rpb25zIHNldCxcbiAgICAgICAgLy8gc2luY2UgaXQgd2lsbCBiZSBjYXB0dXJlZCBpbiBpMThuIGNvbnRlbnQgYW5kIHByb2Nlc3NlZCBhdCBydW50aW1lXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24odGV4dC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLnRleHQsIFtsaXRlcmFsKHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpKSwgbGl0ZXJhbCh0ZXh0LnZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHtcbiAgICAgICAgdmFyIGluaXRXYXNJbnZva2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIGFuIElDVSB3YXMgY3JlYXRlZCBvdXRzaWRlIG9mIGkxOG4gYmxvY2ssIHdlIHN0aWxsIHRyZWF0XG4gICAgICAgIC8vIGl0IGFzIGEgdHJhbnNsYXRhYmxlIGVudGl0eSBhbmQgaW52b2tlIGkxOG5TdGFydCBhbmQgaTE4bkVuZFxuICAgICAgICAvLyB0byBnZW5lcmF0ZSBpMThuIGNvbnRleHQgYW5kIHRoZSBuZWNlc3NhcnkgaW5zdHJ1Y3Rpb25zXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICBpbml0V2FzSW52b2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmkxOG5TdGFydChudWxsLCBpY3UuaTE4biwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkxOG4gPSB0aGlzLmkxOG47XG4gICAgICAgIHZhciB2YXJzID0gdGhpcy5pMThuQmluZFByb3BzKGljdS52YXJzKTtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVycyA9IHRoaXMuaTE4bkJpbmRQcm9wcyhpY3UucGxhY2Vob2xkZXJzKTtcbiAgICAgICAgLy8gb3V0cHV0IElDVSBkaXJlY3RseSBhbmQga2VlcCBJQ1UgcmVmZXJlbmNlIGluIGNvbnRleHRcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBpY3UuaTE4bjtcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uIGZvciBJQ1VzLCB0byBtYWtlIHN1cmUgdGhhdDpcbiAgICAgICAgLy8gLSBhbGwgcGxhY2Vob2xkZXJzIGluIGEgZm9ybSBvZiB7UExBQ0VIT0xERVJ9IGFyZSByZXBsYWNlZCB3aXRoIGFjdHVhbCB2YWx1ZXMgKG5vdGU6XG4gICAgICAgIC8vIGBnb29nLmdldE1zZ2AgZG9lcyBub3QgcHJvY2VzcyBJQ1VzIGFuZCB1c2VzIHRoZSBge1BMQUNFSE9MREVSfWAgZm9ybWF0IGZvciBwbGFjZWhvbGRlcnNcbiAgICAgICAgLy8gaW5zaWRlIElDVXMpXG4gICAgICAgIC8vIC0gYWxsIElDVSB2YXJzIChzdWNoIGFzIGBWQVJfU0VMRUNUYCBvciBgVkFSX1BMVVJBTGApIGFyZSByZXBsYWNlZCB3aXRoIGNvcnJlY3QgdmFsdWVzXG4gICAgICAgIHZhciB0cmFuc2Zvcm1GbiA9IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmFycyksIHBsYWNlaG9sZGVycyk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gaTE4bkZvcm1hdFBsYWNlaG9sZGVyTmFtZXMocGFyYW1zLCAvKiB1c2VDYW1lbENhc2UgKi8gZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzJDEuaTE4blBvc3Rwcm9jZXNzLCBbcmF3LCBtYXBMaXRlcmFsKGZvcm1hdHRlZCwgdHJ1ZSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgd2hvbGUgaTE4biBtZXNzYWdlIGlzIGEgc2luZ2xlIElDVSAtIHdlIGRvIG5vdCBuZWVkIHRvXG4gICAgICAgIC8vIGNyZWF0ZSBhIHNlcGFyYXRlIHRvcC1sZXZlbCB0cmFuc2xhdGlvbiwgd2UgY2FuIHVzZSB0aGUgcm9vdCByZWYgaW5zdGVhZFxuICAgICAgICAvLyBhbmQgbWFrZSB0aGlzIElDVSBhIHRvcC1sZXZlbCB0cmFuc2xhdGlvblxuICAgICAgICAvLyBub3RlOiBJQ1UgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIGFjdHVhbCB2YWx1ZXMgaW4gYGkxOG5Qb3N0cHJvY2Vzc2AgZnVuY3Rpb25cbiAgICAgICAgLy8gc2VwYXJhdGVseSwgc28gd2UgZG8gbm90IHBhc3MgcGxhY2Vob2xkZXJzIGludG8gYGkxOG5UcmFuc2xhdGVgIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoaXNTaW5nbGVJMThuSWN1KGkxOG4ubWV0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCAvKiBwbGFjZWhvbGRlcnMgKi8ge30sIGkxOG4ucmVmLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdXRwdXQgSUNVIGRpcmVjdGx5IGFuZCBrZWVwIElDVSByZWZlcmVuY2UgaW4gY29udGV4dFxuICAgICAgICAgICAgdmFyIHJlZiA9IHRoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCAvKiBwbGFjZWhvbGRlcnMgKi8ge30sIC8qIHJlZiAqLyB1bmRlZmluZWQsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgICAgIGkxOG4uYXBwZW5kSWN1KGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKS5uYW1lLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0V2FzSW52b2tlZCkge1xuICAgICAgICAgICAgdGhpcy5pMThuRW5kKG51bGwsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWxsb2NhdGVEYXRhU2xvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFJbmRleCsrO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0Q29uc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFJbmRleDtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldFZhckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXRDb25zdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdGFudHM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXROZ0NvbnRlbnRTZWxlY3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLmxlbmd0aCA/XG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwoYXNMaXRlcmFsKHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMpLCB0cnVlKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYmluZGluZ0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5fYmluZGluZ0NvbnRleHQrKztcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLnRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUluZGV4LCBhdHRycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQm91bmRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfNCA9IGlucHV0LnZhbHVlLnZpc2l0KF90aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlXzQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZV80KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzQgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJhbXMgdHlwaWNhbGx5IGNvbnRhaW4gYXR0cmlidXRlIG5hbWVzcGFjZSBhbmQgdmFsdWUgc2FuaXRpemVyLCB3aGljaCBpcyBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmVndWxhciBIVE1MIGVsZW1lbnRzLCBidXQgbm90IGFwcGxpY2FibGUgZm9yIDxuZy10ZW1wbGF0ZT4gKHNpbmNlIHByb3BzIGFjdCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5wdXRzIHRvIGRpcmVjdGl2ZXMpLCBzbyBrZWVwIHBhcmFtcyBhcnJheSBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3A9XCJ7e3ZhbHVlfX1cIiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlXzQpLCB0ZW1wbGF0ZUluZGV4LCBpbnB1dC5uYW1lLCBpbnB1dCwgdmFsdWVfNCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFtwcm9wXT1cInZhbHVlXCIgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWVfNCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BlcnR5QmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbkNoYWluV2l0aEFkdmFuY2UodGVtcGxhdGVJbmRleCwgSWRlbnRpZmllcnMkMS5wcm9wZXJ0eSwgcHJvcGVydHlCaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpbmRpbmdzIG11c3Qgb25seSBiZSByZXNvbHZlZCBhZnRlciBhbGwgbG9jYWwgcmVmcyBoYXZlIGJlZW4gdmlzaXRlZCwgc28gYWxsXG4gICAgLy8gaW5zdHJ1Y3Rpb25zIGFyZSBxdWV1ZWQgaW4gY2FsbGJhY2tzIHRoYXQgZXhlY3V0ZSBvbmNlIHRoZSBpbml0aWFsIHBhc3MgaGFzIGNvbXBsZXRlZC5cbiAgICAvLyBPdGhlcndpc2UsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gc3VwcG9ydCBsb2NhbCByZWZzIHRoYXQgYXJlIGRlZmluZWQgYWZ0ZXIgdGhlaXJcbiAgICAvLyBiaW5kaW5ncy4gZS5nLiB7eyBmb28gfX0gPGRpdiAjZm9vPjwvZGl2PlxuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmluc3RydWN0aW9uRm4gPSBmdW5jdGlvbiAoZm5zLCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4sIHByZXBlbmQpIHtcbiAgICAgICAgaWYgKHByZXBlbmQgPT09IHZvaWQgMCkgeyBwcmVwZW5kID0gZmFsc2U7IH1cbiAgICAgICAgZm5zW3ByZXBlbmQgPyAndW5zaGlmdCcgOiAncHVzaCddKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5pc0FycmF5KHBhcmFtc09yRm4pID8gcGFyYW1zT3JGbiA6IHBhcmFtc09yRm4oKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtcykudG9TdG10KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc1N0eWxpbmdVcGRhdGVJbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbGxvY2F0ZUJpbmRpbmdTbG90cyA9IDA7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGNhbGxzXzEgPSBbXTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxzLmZvckVhY2goZnVuY3Rpb24gKGNhbGwpIHtcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90cyArPSBjYWxsLmFsbG9jYXRlQmluZGluZ1Nsb3RzO1xuICAgICAgICAgICAgICAgIGNhbGxzXzEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGNhbGwuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsLnBhcmFtcyhmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIChjYWxsLnN1cHBvcnRzSW50ZXJwb2xhdGlvbiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRVcGRhdGVJbnN0cnVjdGlvbkFyZ3VtZW50cyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW5XaXRoQWR2YW5jZShlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uLnJlZmVyZW5jZSwgY2FsbHNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbG9jYXRlQmluZGluZ1Nsb3RzO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuY3JlYXRpb25JbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4sIHByZXBlbmQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbkZuKHRoaXMuX2NyZWF0aW9uQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdLCBwcmVwZW5kKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0aW9uSW5zdHJ1Y3Rpb25DaGFpbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2UsIGNhbGxzKSB7XG4gICAgICAgIHZhciBzcGFuID0gY2FsbHMubGVuZ3RoID8gY2FsbHNbMF0uc291cmNlU3BhbiA6IG51bGw7XG4gICAgICAgIHRoaXMuX2NyZWF0aW9uQ29kZUZucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbmVkSW5zdHJ1Y3Rpb24ocmVmZXJlbmNlLCBjYWxscy5tYXAoZnVuY3Rpb24gKGNhbGwpIHsgcmV0dXJuIGNhbGwucGFyYW1zKCk7IH0pLCBzcGFuKS50b1N0bXQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuKSB7XG4gICAgICAgIHRoaXMuYWRkQWR2YW5jZUluc3RydWN0aW9uSWZOZWNlc3Nhcnkobm9kZUluZGV4LCBzcGFuKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUudXBkYXRlSW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Gbih0aGlzLl91cGRhdGVDb2RlRm5zLCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4gfHwgW10pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2UsIGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBzcGFuID0gYmluZGluZ3MubGVuZ3RoID8gYmluZGluZ3NbMF0uc291cmNlU3BhbiA6IG51bGw7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvZGVGbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FsbHMgPSBiaW5kaW5ncy5tYXAoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcGVydHkudmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgZm5QYXJhbXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuUGFyYW1zLnB1c2guYXBwbHkoZm5QYXJhbXMsIF9fc3ByZWFkKHByb3BlcnR5LnBhcmFtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRoZSBwcm9wZXJ0eSBuYW1lIHRvIGFsd2F5cyBiZSB0aGUgZmlyc3QgZnVuY3Rpb24gcGFyYW1ldGVyLlxuICAgICAgICAgICAgICAgICAgICBmblBhcmFtcy51bnNoaWZ0KGxpdGVyYWwocHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm5QYXJhbXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbmVkSW5zdHJ1Y3Rpb24ocmVmZXJlbmNlLCBjYWxscywgc3BhbikudG9TdG10KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcmVmZXJlbmNlLCBiaW5kaW5ncykge1xuICAgICAgICB0aGlzLmFkZEFkdmFuY2VJbnN0cnVjdGlvbklmTmVjZXNzYXJ5KG5vZGVJbmRleCwgYmluZGluZ3MubGVuZ3RoID8gYmluZGluZ3NbMF0uc291cmNlU3BhbiA6IG51bGwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW4ocmVmZXJlbmNlLCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRBZHZhbmNlSW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIHNwYW4pIHtcbiAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gdGhpcy5fY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBub2RlSW5kZXggLSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZHZhbmNlIGluc3RydWN0aW9uIGNhbiBvbmx5IGdvIGZvcndhcmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgSWRlbnRpZmllcnMkMS5hZHZhbmNlLCBbbGl0ZXJhbChkZWx0YSldKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyA9IGZ1bmN0aW9uIChudW1TbG90cykge1xuICAgICAgICB2YXIgb3JpZ2luYWxTbG90cyA9IHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzO1xuICAgICAgICB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cyArPSBudW1TbG90cztcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsU2xvdHM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5hbGxvY2F0ZUJpbmRpbmdTbG90cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uID8gdmFsdWUuZXhwcmVzc2lvbnMubGVuZ3RoIDogMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gZXhwcmVzc2lvbiB0aGF0IHJlZmVycyB0byB0aGUgaW1wbGljaXQgcmVjZWl2ZXIuIFRoZSBpbXBsaWNpdFxuICAgICAqIHJlY2VpdmVyIGlzIGFsd2F5cyB0aGUgcm9vdCBsZXZlbCBjb250ZXh0LlxuICAgICAqL1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldEltcGxpY2l0UmVjZWl2ZXJFeHByID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIgPSB0aGlzLmxldmVsID09PSAwID9cbiAgICAgICAgICAgIHZhcmlhYmxlKENPTlRFWFRfTkFNRSkgOlxuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhcigwKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY29udmVydGVkUHJvcGVydHlCaW5kaW5nID0gY29udmVydFByb3BlcnR5QmluZGluZyh0aGlzLCB0aGlzLmdldEltcGxpY2l0UmVjZWl2ZXJFeHByKCksIHZhbHVlLCB0aGlzLmJpbmRpbmdDb250ZXh0KCksIEJpbmRpbmdGb3JtLlRyeVNpbXBsZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoJ1VuZXhwZWN0ZWQgaW50ZXJwb2xhdGlvbicpOyB9KTtcbiAgICAgICAgdmFyIHZhbEV4cHIgPSBjb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcuY3VyclZhbEV4cHI7XG4gICAgICAgIChfYSA9IHRoaXMuX3RlbXBWYXJpYWJsZXMpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkKGNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5zdG10cykpO1xuICAgICAgICByZXR1cm4gdmFsRXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGFyZ3VtZW50IGV4cHJlc3Npb25zIHRvIHBhc3MgdG8gYW4gdXBkYXRlIGluc3RydWN0aW9uIGV4cHJlc3Npb24uIEFsc28gdXBkYXRlc1xuICAgICAqIHRoZSB0ZW1wIHZhcmlhYmxlcyBzdGF0ZSB3aXRoIHRlbXAgdmFyaWFibGVzIHRoYXQgd2VyZSBpZGVudGlmaWVkIGFzIG5lZWRpbmcgdG8gYmUgY3JlYXRlZFxuICAgICAqIHdoaWxlIHZpc2l0aW5nIHRoZSBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBvcmlnaW5hbCBleHByZXNzaW9uIHdlIHdpbGwgYmUgcmVzb2x2aW5nIGFuIGFyZ3VtZW50cyBsaXN0IGZyb20uXG4gICAgICovXG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSBjb252ZXJ0VXBkYXRlQXJndW1lbnRzKHRoaXMsIHRoaXMuZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSwgdmFsdWUsIHRoaXMuYmluZGluZ0NvbnRleHQoKSksIGFyZ3MgPSBfYi5hcmdzLCBzdG10cyA9IF9iLnN0bXRzO1xuICAgICAgICAoX2EgPSB0aGlzLl90ZW1wVmFyaWFibGVzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChzdG10cykpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9O1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLm1hdGNoRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgZWxPclRwbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVNYXRjaGVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgZ2V0QXR0cnNGb3JEaXJlY3RpdmVNYXRjaGluZyhlbE9yVHBsKSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChjc3NTZWxlY3Rvciwgc3RhdGljVHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZXMuYWRkKHN0YXRpY1R5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGFsbCBhdHRyaWJ1dGUgZXhwcmVzc2lvbiB2YWx1ZXMgZm9yIHRoZSBgVEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBwcm9wZXJseSBjb25zdHJ1Y3QgYW4gYXR0cmlidXRlcyBhcnJheSB0aGF0XG4gICAgICogaXMgcGFzc2VkIGludG8gdGhlIGBlbGVtZW50U3RhcnRgIChvciBqdXN0IGBlbGVtZW50YCkgZnVuY3Rpb25zLiBCZWNhdXNlIHRoZXJlXG4gICAgICogYXJlIG1hbnkgZGlmZmVyZW50IHR5cGVzIG9mIGF0dHJpYnV0ZXMsIHRoZSBhcnJheSBuZWVkcyB0byBiZSBjb25zdHJ1Y3RlZCBpbiBhXG4gICAgICogc3BlY2lhbCB3YXkgc28gdGhhdCBgZWxlbWVudFN0YXJ0YCBjYW4gcHJvcGVybHkgZXZhbHVhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogYXR0cnMgPSBbcHJvcCwgdmFsdWUsIHByb3AyLCB2YWx1ZTIsXG4gICAgICogICBQUk9KRUNUX0FTLCBzZWxlY3RvcixcbiAgICAgKiAgIENMQVNTRVMsIGNsYXNzMSwgY2xhc3MyLFxuICAgICAqICAgU1RZTEVTLCBzdHlsZTEsIHZhbHVlMSwgc3R5bGUyLCB2YWx1ZTIsXG4gICAgICogICBCSU5ESU5HUywgbmFtZTEsIG5hbWUyLCBuYW1lMyxcbiAgICAgKiAgIFRFTVBMQVRFLCBuYW1lNCwgbmFtZTUsIG5hbWU2LFxuICAgICAqICAgSTE4TiwgbmFtZTcsIG5hbWU4LCAuLi5dXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGZ1bGx5IGlnbm9yZSBhbGwgc3ludGhldGljIChAZm9vKSBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICogYmVjYXVzZSB0aG9zZSB2YWx1ZXMgYXJlIGludGVuZGVkIHRvIGFsd2F5cyBiZSBnZW5lcmF0ZWQgYXMgcHJvcGVydHkgaW5zdHJ1Y3Rpb25zLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKHJlbmRlckF0dHJpYnV0ZXMsIGlucHV0cywgb3V0cHV0cywgc3R5bGVzLCB0ZW1wbGF0ZUF0dHJzLCBpMThuQXR0cnMpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlQXR0cnMgPT09IHZvaWQgMCkgeyB0ZW1wbGF0ZUF0dHJzID0gW107IH1cbiAgICAgICAgaWYgKGkxOG5BdHRycyA9PT0gdm9pZCAwKSB7IGkxOG5BdHRycyA9IFtdOyB9XG4gICAgICAgIHZhciBhbHJlYWR5U2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGF0dHJFeHBycyA9IFtdO1xuICAgICAgICB2YXIgbmdQcm9qZWN0QXNBdHRyO1xuICAgICAgICByZW5kZXJBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IE5HX1BST0pFQ1RfQVNfQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgbmdQcm9qZWN0QXNBdHRyID0gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoLmFwcGx5KGF0dHJFeHBycywgX19zcHJlYWQoZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKGF0dHIubmFtZSksIFthc0xpdGVyYWwoYXR0ci52YWx1ZSldKSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBLZWVwIG5nUHJvamVjdEFzIG5leHQgdG8gdGhlIG90aGVyIG5hbWUsIHZhbHVlIHBhaXJzIHNvIHdlIGNhbiB2ZXJpZnkgdGhhdCB3ZSBtYXRjaFxuICAgICAgICAvLyBuZ1Byb2plY3RBcyBtYXJrZXIgaW4gdGhlIGF0dHJpYnV0ZSBuYW1lIHNsb3QuXG4gICAgICAgIGlmIChuZ1Byb2plY3RBc0F0dHIpIHtcbiAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoLmFwcGx5KGF0dHJFeHBycywgX19zcHJlYWQoZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKG5nUHJvamVjdEFzQXR0cikpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRBdHRyRXhwcihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlTZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoLmFwcGx5KGF0dHJFeHBycywgX19zcHJlYWQoZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKGtleSkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhdHRyRXhwcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlTZWVuLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIG9jY3VycyBiZWZvcmUgQklORElOR1MgYW5kIFRFTVBMQVRFIGJlY2F1c2Ugb25jZSBgZWxlbWVudFN0YXJ0YFxuICAgICAgICAvLyBjb21lcyBhY3Jvc3MgdGhlIEJJTkRJTkdTIG9yIFRFTVBMQVRFIG1hcmtlcnMgdGhlbiBpdCB3aWxsIGNvbnRpbnVlIHJlYWRpbmcgZWFjaCB2YWx1ZSBhc1xuICAgICAgICAvLyBhcyBzaW5nbGUgcHJvcGVydHkgdmFsdWUgY2VsbCBieSBjZWxsLlxuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICBzdHlsZXMucG9wdWxhdGVJbml0aWFsU3R5bGluZ0F0dHJzKGF0dHJFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggfHwgb3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhdHRyc0xlbmd0aEJlZm9yZUlucHV0cyA9IGF0dHJFeHBycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoZSBhbmltYXRpb24gYW5kIGF0dHJpYnV0ZSBiaW5kaW5ncyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFycmF5IHNpbmNlIHRoZXkgYXJlbid0IHVzZWQgZm9yIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudHlwZSAhPT0gNCAvKiBBbmltYXRpb24gKi8gJiYgaW5wdXQudHlwZSAhPT0gMSAvKiBBdHRyaWJ1dGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0ckV4cHIoaW5wdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IG91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dC50eXBlICE9PSAxIC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBhZGRBdHRyRXhwcihvdXRwdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNoZWFwIHdheSBvZiBhZGRpbmcgdGhlIG1hcmtlciBvbmx5IGFmdGVyIGFsbCB0aGUgaW5wdXQvb3V0cHV0XG4gICAgICAgICAgICAvLyB2YWx1ZXMgaGF2ZSBiZWVuIGZpbHRlcmVkIChieSBub3QgaW5jbHVkaW5nIHRoZSBhbmltYXRpb24gb25lcykgYW5kIGFkZGVkXG4gICAgICAgICAgICAvLyB0byB0aGUgZXhwcmVzc2lvbnMuIFRoZSBtYXJrZXIgaXMgaW1wb3J0YW50IGJlY2F1c2UgaXQgdGVsbHMgdGhlIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIGNvZGUgdGhhdCB0aGlzIGlzIHdoZXJlIGF0dHJpYnV0ZXMgd2l0aG91dCB2YWx1ZXMgc3RhcnQuLi5cbiAgICAgICAgICAgIGlmIChhdHRyRXhwcnMubGVuZ3RoICE9PSBhdHRyc0xlbmd0aEJlZm9yZUlucHV0cykge1xuICAgICAgICAgICAgICAgIGF0dHJFeHBycy5zcGxpY2UoYXR0cnNMZW5ndGhCZWZvcmVJbnB1dHMsIDAsIGxpdGVyYWwoMyAvKiBCaW5kaW5ncyAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2gobGl0ZXJhbCg0IC8qIFRlbXBsYXRlICovKSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGFkZEF0dHJFeHByKGF0dHIubmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMThuQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKDYgLyogSTE4biAqLykpO1xuICAgICAgICAgICAgaTE4bkF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGFkZEF0dHJFeHByKGF0dHIubmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyRXhwcnM7XG4gICAgfTtcbiAgICBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyLnByb3RvdHlwZS5hZGRUb0NvbnN0cyA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChpc051bGwoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBUWVBFRF9OVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIHJldXNlIGEgbGl0ZXJhbCB0aGF0J3MgYWxyZWFkeSBpbiB0aGUgYXJyYXksIGlmIHBvc3NpYmxlLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbnN0YW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN0YW50c1tpXS5pc0VxdWl2YWxlbnQoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0aGlzLl9jb25zdGFudHMucHVzaChleHByZXNzaW9uKSAtIDEpO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUuYWRkQXR0cnNUb0NvbnN0cyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMubGVuZ3RoID4gMCA/IHRoaXMuYWRkVG9Db25zdHMobGl0ZXJhbEFycihhdHRycykpIDogVFlQRURfTlVMTF9FWFBSO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUucHJlcGFyZVJlZnNBcnJheSA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghcmVmZXJlbmNlcyB8fCByZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRZUEVEX05VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmc1BhcmFtID0gZmxhdHRlbihyZWZlcmVuY2VzLm1hcChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IF90aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB1cGRhdGUgdGVtcG9yYXJ5LlxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IF90aGlzLl9iaW5kaW5nU2NvcGUuZnJlc2hSZWZlcmVuY2VOYW1lKCk7XG4gICAgICAgICAgICB2YXIgcmV0cmlldmFsTGV2ZWwgPSBfdGhpcy5sZXZlbDtcbiAgICAgICAgICAgIHZhciBsaHMgPSB2YXJpYWJsZSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuX2JpbmRpbmdTY29wZS5zZXQocmV0cmlldmFsTGV2ZWwsIHJlZmVyZW5jZS5uYW1lLCBsaHMsIDAgLyogREVGQVVMVCAqLywgZnVuY3Rpb24gKHNjb3BlLCByZWxhdGl2ZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBuZXh0Q29udGV4dCgyKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENvbnRleHRTdG10ID0gcmVsYXRpdmVMZXZlbCA+IDAgPyBbZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCkudG9TdG10KCldIDogW107XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBjb25zdCAkZm9vJCA9IHJlZmVyZW5jZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmRXhwciA9IGxocy5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnJlZmVyZW5jZSkuY2FsbEZuKFtsaXRlcmFsKHNsb3QpXSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q29udGV4dFN0bXQuY29uY2F0KHJlZkV4cHIudG9Db25zdERlY2woKSk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBbcmVmZXJlbmNlLm5hbWUsIHJlZmVyZW5jZS52YWx1ZV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGFzTGl0ZXJhbChyZWZzUGFyYW0pO1xuICAgIH07XG4gICAgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlci5wcm90b3R5cGUucHJlcGFyZUxpc3RlbmVyUGFyYW1ldGVyID0gZnVuY3Rpb24gKHRhZ05hbWUsIG91dHB1dEFzdCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBvdXRwdXRBc3QubmFtZTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nRm5OYW1lID0gb3V0cHV0QXN0LnR5cGUgPT09IDEgLyogQW5pbWF0aW9uICovID9cbiAgICAgICAgICAgICAgICAvLyBzeW50aGV0aWMgQGxpc3RlbmVyLmZvbyB2YWx1ZXMgYXJlIHRyZWF0ZWQgdGhlIGV4YWN0IHNhbWUgYXMgYXJlIHN0YW5kYXJkIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lckZ1bmN0aW9uTmFtZShldmVudE5hbWUsIG91dHB1dEFzdC5waGFzZSkgOlxuICAgICAgICAgICAgICAgIHNhbml0aXplSWRlbnRpZmllcihldmVudE5hbWUpO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJOYW1lID0gX3RoaXMudGVtcGxhdGVOYW1lICsgXCJfXCIgKyB0YWdOYW1lICsgXCJfXCIgKyBiaW5kaW5nRm5OYW1lICsgXCJfXCIgKyBpbmRleCArIFwiX2xpc3RlbmVyXCI7XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBfdGhpcy5fYmluZGluZ1Njb3BlLm5lc3RlZFNjb3BlKF90aGlzLl9iaW5kaW5nU2NvcGUuYmluZGluZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVwYXJlRXZlbnRMaXN0ZW5lclBhcmFtZXRlcnMob3V0cHV0QXN0LCBoYW5kbGVyTmFtZSwgc2NvcGUpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXI7XG59KCkpO1xudmFyIFZhbHVlQ29udmVydGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWx1ZUNvbnZlcnRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWYWx1ZUNvbnZlcnRlcihjb25zdGFudFBvb2wsIGFsbG9jYXRlU2xvdCwgYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cywgZGVmaW5lUGlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIF90aGlzLmFsbG9jYXRlU2xvdCA9IGFsbG9jYXRlU2xvdDtcbiAgICAgICAgX3RoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyA9IGFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHM7XG4gICAgICAgIF90aGlzLmRlZmluZVBpcGUgPSBkZWZpbmVQaXBlO1xuICAgICAgICBfdGhpcy5fcGlwZUJpbmRFeHBycyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyXG4gICAgVmFsdWVDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChwaXBlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEFsbG9jYXRlIGEgc2xvdCB0byBjcmVhdGUgdGhlIHBpcGVcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmFsbG9jYXRlU2xvdCgpO1xuICAgICAgICB2YXIgc2xvdFBzZXVkb0xvY2FsID0gXCJQSVBFOlwiICsgc2xvdDtcbiAgICAgICAgLy8gQWxsb2NhdGUgb25lIHNsb3QgZm9yIHRoZSByZXN1bHQgcGx1cyBvbmUgc2xvdCBwZXIgcGlwZSBhcmd1bWVudFxuICAgICAgICB2YXIgcHVyZUZ1bmN0aW9uU2xvdCA9IHRoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cygyICsgcGlwZS5hcmdzLmxlbmd0aCk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXcgUHJvcGVydHlSZWFkKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuLCBwaXBlLm5hbWVTcGFuLCBuZXcgSW1wbGljaXRSZWNlaXZlcihwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiksIHNsb3RQc2V1ZG9Mb2NhbCk7XG4gICAgICAgIHZhciBfYSA9IHBpcGVCaW5kaW5nQ2FsbEluZm8ocGlwZS5hcmdzKSwgaWRlbnRpZmllciA9IF9hLmlkZW50aWZpZXIsIGlzVmFyTGVuZ3RoID0gX2EuaXNWYXJMZW5ndGg7XG4gICAgICAgIHRoaXMuZGVmaW5lUGlwZShwaXBlLm5hbWUsIHNsb3RQc2V1ZG9Mb2NhbCwgc2xvdCwgaW1wb3J0RXhwcihpZGVudGlmaWVyKSk7XG4gICAgICAgIHZhciBhcmdzID0gX19zcHJlYWQoW3BpcGUuZXhwXSwgcGlwZS5hcmdzKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZEFyZ3MgPSBpc1Zhckxlbmd0aCA/XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsKFtuZXcgTGl0ZXJhbEFycmF5KHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuLCBhcmdzKV0pIDpcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGwoYXJncyk7XG4gICAgICAgIHZhciBwaXBlQmluZEV4cHIgPSBuZXcgRnVuY3Rpb25DYWxsKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuLCB0YXJnZXQsIF9fc3ByZWFkKFtcbiAgICAgICAgICAgIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuLCBzbG90KSxcbiAgICAgICAgICAgIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuLCBwdXJlRnVuY3Rpb25TbG90KVxuICAgICAgICBdLCBjb252ZXJ0ZWRBcmdzKSk7XG4gICAgICAgIHRoaXMuX3BpcGVCaW5kRXhwcnMucHVzaChwaXBlQmluZEV4cHIpO1xuICAgICAgICByZXR1cm4gcGlwZUJpbmRFeHByO1xuICAgIH07XG4gICAgVmFsdWVDb252ZXJ0ZXIucHJvdG90eXBlLnVwZGF0ZVBpcGVTbG90T2Zmc2V0cyA9IGZ1bmN0aW9uIChiaW5kaW5nU2xvdHMpIHtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsb3Qgb2Zmc2V0IGFyZyAoaW5kZXggMSkgdG8gYWNjb3VudCBmb3IgYmluZGluZyBzbG90c1xuICAgICAgICAgICAgdmFyIHNsb3RPZmZzZXQgPSBwaXBlLmFyZ3NbMV07XG4gICAgICAgICAgICBzbG90T2Zmc2V0LnZhbHVlICs9IGJpbmRpbmdTbG90cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFycmF5LnNwYW4sIGFycmF5LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXJyYXkuZXhwcmVzc2lvbnMpLCBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGl0ZXJhbCBoYXMgY2FsY3VsYXRlZCAobm9uLWxpdGVyYWwpIGVsZW1lbnRzIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgICAgICAgICAvLyBjYWxscyB0byBsaXRlcmFsIGZhY3RvcmllcyB0aGF0IGNvbXBvc2UgdGhlIGxpdGVyYWwgYW5kIHdpbGwgY2FjaGUgaW50ZXJtZWRpYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxBcnIodmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRMaXRlcmFsRmFjdG9yeShfdGhpcy5jb25zdGFudFBvb2wsIGxpdGVyYWwsIF90aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZhbHVlQ29udmVydGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChtYXAuc3BhbiwgbWFwLnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwobWFwLnZhbHVlcyksIGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXRlcmFsIGhhcyBjYWxjdWxhdGVkIChub24tbGl0ZXJhbCkgZWxlbWVudHMgIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgICAgICAgICAvLyBjYWxscyB0byBsaXRlcmFsIGZhY3RvcmllcyB0aGF0IGNvbXBvc2UgdGhlIGxpdGVyYWwgYW5kIHdpbGwgY2FjaGUgaW50ZXJtZWRpYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxNYXAodmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7IHJldHVybiAoeyBrZXk6IG1hcC5rZXlzW2luZGV4XS5rZXksIHZhbHVlOiB2YWx1ZSwgcXVvdGVkOiBtYXAua2V5c1tpbmRleF0ucXVvdGVkIH0pOyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TGl0ZXJhbEZhY3RvcnkoX3RoaXMuY29uc3RhbnRQb29sLCBsaXRlcmFsLCBfdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFsdWVDb252ZXJ0ZXI7XG59KEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyKSk7XG4vLyBQaXBlcyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyLCB0aGUgdmFsdWUgdGhleSBvcGVyYXRlIG9uXG52YXIgcGlwZUJpbmRpbmdJZGVudGlmaWVycyA9IFtJZGVudGlmaWVycyQxLnBpcGVCaW5kMSwgSWRlbnRpZmllcnMkMS5waXBlQmluZDIsIElkZW50aWZpZXJzJDEucGlwZUJpbmQzLCBJZGVudGlmaWVycyQxLnBpcGVCaW5kNF07XG5mdW5jdGlvbiBwaXBlQmluZGluZ0NhbGxJbmZvKGFyZ3MpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHBpcGVCaW5kaW5nSWRlbnRpZmllcnNbYXJncy5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfHwgSWRlbnRpZmllcnMkMS5waXBlQmluZFYsXG4gICAgICAgIGlzVmFyTGVuZ3RoOiAhaWRlbnRpZmllcixcbiAgICB9O1xufVxudmFyIHB1cmVGdW5jdGlvbklkZW50aWZpZXJzID0gW1xuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMCwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb24xLCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjIsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMywgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb240LFxuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uNSwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb242LCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjcsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uOFxuXTtcbmZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNhbGxJbmZvKGFyZ3MpIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHB1cmVGdW5jdGlvbklkZW50aWZpZXJzW2FyZ3MubGVuZ3RoXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyIHx8IElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uVixcbiAgICAgICAgaXNWYXJMZW5ndGg6ICFpZGVudGlmaWVyLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtcykge1xuICAgIHJldHVybiBpbXBvcnRFeHByKHJlZmVyZW5jZSwgbnVsbCwgc3BhbikuY2FsbEZuKHBhcmFtcywgc3Bhbik7XG59XG4vLyBlLmcuIHgoMik7XG5mdW5jdGlvbiBnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsRGlmZikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEubmV4dENvbnRleHQpXG4gICAgICAgIC5jYWxsRm4ocmVsYXRpdmVMZXZlbERpZmYgPiAxID8gW2xpdGVyYWwocmVsYXRpdmVMZXZlbERpZmYpXSA6IFtdKTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxGYWN0b3J5KGNvbnN0YW50UG9vbCwgbGl0ZXJhbCQxLCBhbGxvY2F0ZVNsb3RzKSB7XG4gICAgdmFyIF9hID0gY29uc3RhbnRQb29sLmdldExpdGVyYWxGYWN0b3J5KGxpdGVyYWwkMSksIGxpdGVyYWxGYWN0b3J5ID0gX2EubGl0ZXJhbEZhY3RvcnksIGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzID0gX2EubGl0ZXJhbEZhY3RvcnlBcmd1bWVudHM7XG4gICAgLy8gQWxsb2NhdGUgMSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgMSBwZXIgYXJndW1lbnRcbiAgICB2YXIgc3RhcnRTbG90ID0gYWxsb2NhdGVTbG90cygxICsgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YXIgX2IgPSBwdXJlRnVuY3Rpb25DYWxsSW5mbyhsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyksIGlkZW50aWZpZXIgPSBfYi5pZGVudGlmaWVyLCBpc1Zhckxlbmd0aCA9IF9iLmlzVmFyTGVuZ3RoO1xuICAgIC8vIExpdGVyYWwgZmFjdG9yaWVzIGFyZSBwdXJlIGZ1bmN0aW9ucyB0aGF0IG9ubHkgbmVlZCB0byBiZSByZS1pbnZva2VkIHdoZW4gdGhlIHBhcmFtZXRlcnNcbiAgICAvLyBjaGFuZ2UuXG4gICAgdmFyIGFyZ3MgPSBbbGl0ZXJhbChzdGFydFNsb3QpLCBsaXRlcmFsRmFjdG9yeV07XG4gICAgaWYgKGlzVmFyTGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsQXJyKGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgX19zcHJlYWQobGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoaWRlbnRpZmllcikuY2FsbEZuKGFyZ3MpO1xufVxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIGxpdGVyYWxzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGV4cHJlc3Npb25cbiAqIHRvIHJlcHJlc2VudCB0aGUgbmFtZSBhbmQgbmFtZXNwYWNlIG9mIGFuIGF0dHJpYnV0ZS4gRS5nLlxuICogYDp4bGluazpocmVmYCB0dXJucyBpbnRvIGBbQXR0cmlidXRlTWFya2VyLk5hbWVzcGFjZVVSSSwgJ3hsaW5rJywgJ2hyZWYnXWAuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlLCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKG5hbWUpIHtcbiAgICB2YXIgX2EgPSBfX3JlYWQoc3BsaXROc05hbWUobmFtZSksIDIpLCBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBfYVswXSwgYXR0cmlidXRlTmFtZSA9IF9hWzFdO1xuICAgIHZhciBuYW1lTGl0ZXJhbCA9IGxpdGVyYWwoYXR0cmlidXRlTmFtZSk7XG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGl0ZXJhbCgwIC8qIE5hbWVzcGFjZVVSSSAqLyksIGxpdGVyYWwoYXR0cmlidXRlTmFtZXNwYWNlKSwgbmFtZUxpdGVyYWxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtuYW1lTGl0ZXJhbF07XG59XG4vKiogVGhlIHByZWZpeCB1c2VkIHRvIGdldCBhIHNoYXJlZCBjb250ZXh0IGluIEJpbmRpbmdTY29wZSdzIG1hcC4gKi9cbnZhciBTSEFSRURfQ09OVEVYVF9LRVkgPSAnJCRzaGFyZWRfY3R4JCQnO1xudmFyIEJpbmRpbmdTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nU2NvcGUoYmluZGluZ0xldmVsLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKGJpbmRpbmdMZXZlbCA9PT0gdm9pZCAwKSB7IGJpbmRpbmdMZXZlbCA9IDA7IH1cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5iaW5kaW5nTGV2ZWwgPSBiaW5kaW5nTGV2ZWw7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAvKiogS2VlcHMgYSBtYXAgZnJvbSBsb2NhbCB2YXJpYWJsZXMgdG8gdGhlaXIgQmluZGluZ0RhdGEuICovXG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZU5hbWVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZSA9IG51bGw7XG4gICAgfVxuICAgIEJpbmRpbmdTY29wZS5jcmVhdGVSb290U2NvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1Njb3BlKCkuc2V0KDAsICckZXZlbnQnLCB2YXJpYWJsZSgnJGV2ZW50JykpO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjdXJyZW50Lm1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBsb2NhbCBjb3B5IGFuZCByZXNldCB0aGUgYGRlY2xhcmVgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHZhbHVlLnJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiB2YWx1ZS5saHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogdmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB2YWx1ZS5wcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsUmVmOiB2YWx1ZS5sb2NhbFJlZlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdmFsdWUgbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libHkgZ2VuZXJhdGUgYSBzaGFyZWQgY29udGV4dCB2YXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXN0b3JlVmlldyh2YWx1ZS5yZXRyaWV2YWxMZXZlbCwgdmFsdWUubG9jYWxSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2sgJiYgIXZhbHVlLmRlY2xhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5saHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIHdlIGFyZSBsb29raW5nIGZvciBhIHByb3BlcnR5IG9uIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50XG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBvbiB0aGUgdG9wIGFuZCBkb24ndCBuZWVkIHRvIHJlLWRlY2xhcmUgYGN0eGAuXG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPiAwLCB3ZSBhcmUgaW4gYW4gZW1iZWRkZWQgdmlldy4gV2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGVcbiAgICAgICAgLy8gbG9jYWwgdmFyIHdlIHVzZWQgdG8gc3RvcmUgdGhlIGNvbXBvbmVudCBjb250ZXh0LCBlLmcuIGNvbnN0ICRjb21wJCA9IHgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ0xldmVsID09PSAwID8gbnVsbCA6IHRoaXMuZ2V0Q29tcG9uZW50UHJvcGVydHkobmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBsb2NhbCB2YXJpYWJsZSBmb3IgbGF0ZXIgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJldHJpZXZhbExldmVsIFRoZSBsZXZlbCBmcm9tIHdoaWNoIHRoaXMgdmFsdWUgY2FuIGJlIHJldHJpZXZlZFxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICAgICAqIEBwYXJhbSBsaHMgQVNUIHJlcHJlc2VudGluZyB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGBsZXQgbGhzID0gcmhzO2AuXG4gICAgICogQHBhcmFtIHByaW9yaXR5IFRoZSBzb3J0aW5nIHByaW9yaXR5IG9mIHRoaXMgdmFyXG4gICAgICogQHBhcmFtIGRlY2xhcmVMb2NhbENhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBkZWNsYXJpbmcgdGhpcyBsb2NhbCB2YXJcbiAgICAgKiBAcGFyYW0gbG9jYWxSZWYgV2hldGhlciBvciBub3QgdGhpcyBpcyBhIGxvY2FsIHJlZlxuICAgICAqL1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJldHJpZXZhbExldmVsLCBuYW1lLCBsaHMsIHByaW9yaXR5LCBkZWNsYXJlTG9jYWxDYWxsYmFjaywgbG9jYWxSZWYpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSAwIC8qIERFRkFVTFQgKi87IH1cbiAgICAgICAgaWYgKHRoaXMubWFwLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaWYgKGxvY2FsUmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHRocm93IGFuIGVycm9yIGlmIGl0J3MgYSBsb2NhbCByZWYgYW5kIGRvIG5vdCB1cGRhdGUgZXhpc3RpbmcgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhlIGZpcnN0IGRlZmluZWQgcmVmIGlzIGFsd2F5cyByZXR1cm5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKFwiVGhlIG5hbWUgXCIgKyBuYW1lICsgXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIHNjb3BlIHRvIGJlIFwiICsgdGhpcy5tYXAuZ2V0KG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcC5zZXQobmFtZSwge1xuICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgbGhzOiBsaHMsXG4gICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGRlY2xhcmVMb2NhbENhbGxiYWNrOiBkZWNsYXJlTG9jYWxDYWxsYmFjayxcbiAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgIGxvY2FsUmVmOiBsb2NhbFJlZiB8fCBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIExvY2FsUmVzb2x2ZXIuXG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICB9O1xuICAgIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgTG9jYWxSZXNvbHZlci5cbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdMZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGltcGxpY2l0IHJlY2VpdmVyIGlzIGFjY2Vzc2VkIGluIGFuIGVtYmVkZGVkIHZpZXcsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRlY2xhcmUgYSBzaGFyZWQgY29udGV4dCB2YXJpYWJsZSBmb3IgdGhlIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGluIHRoZSB1cGRhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLm5lc3RlZFNjb3BlID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgIHZhciBuZXdTY29wZSA9IG5ldyBCaW5kaW5nU2NvcGUobGV2ZWwsIHRoaXMpO1xuICAgICAgICBpZiAobGV2ZWwgPiAwKVxuICAgICAgICAgICAgbmV3U2NvcGUuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKDApO1xuICAgICAgICByZXR1cm4gbmV3U2NvcGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIGNyZWF0ZXMgYSBzaGFyZWQgY29udGV4dCB2YXJpYWJsZSBhbmQgcmV0dXJucyBpdHMgZXhwcmVzc2lvbi4gTm90ZSB0aGF0XG4gICAgICogdGhpcyBkb2VzIG5vdCBtZWFuIHRoYXQgdGhlIHNoYXJlZCB2YXJpYWJsZSB3aWxsIGJlIGRlY2xhcmVkLiBWYXJpYWJsZXMgaW4gdGhlXG4gICAgICogYmluZGluZyBzY29wZSB3aWxsIGJlIG9ubHkgZGVjbGFyZWQgaWYgdGhleSBhcmUgdXNlZC5cbiAgICAgKi9cbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhciA9IGZ1bmN0aW9uIChyZXRyaWV2YWxMZXZlbCkge1xuICAgICAgICB2YXIgYmluZGluZ0tleSA9IFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsO1xuICAgICAgICBpZiAoIXRoaXMubWFwLmhhcyhiaW5kaW5nS2V5KSkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIocmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYXJlZCBjb250ZXh0IHZhcmlhYmxlcyBhcmUgYWx3YXlzIGdlbmVyYXRlZCBhcyBcIlJlYWRWYXJFeHByXCIuXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQoYmluZGluZ0tleSkubGhzO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5nZXRTaGFyZWRDb250ZXh0TmFtZSA9IGZ1bmN0aW9uIChyZXRyaWV2YWxMZXZlbCkge1xuICAgICAgICB2YXIgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgLy8gU2hhcmVkIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhbHdheXMgZ2VuZXJhdGVkIGFzIFwiUmVhZFZhckV4cHJcIi5cbiAgICAgICAgcmV0dXJuIHNoYXJlZEN0eE9iaiAmJiBzaGFyZWRDdHhPYmouZGVjbGFyZSA/IHNoYXJlZEN0eE9iai5saHMgOiBudWxsO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5tYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUucHJpb3JpdHkgPT09IDEgLyogQ09OVEVYVCAqLyAmJlxuICAgICAgICAgICAgdmFsdWUucmV0cmlldmFsTGV2ZWwgPCB0aGlzLmJpbmRpbmdMZXZlbCkge1xuICAgICAgICAgICAgdmFyIHNoYXJlZEN0eE9iaiA9IHRoaXMubWFwLmdldChTSEFSRURfQ09OVEVYVF9LRVkgKyB2YWx1ZS5yZXRyaWV2YWxMZXZlbCk7XG4gICAgICAgICAgICBpZiAoc2hhcmVkQ3R4T2JqKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQ3R4T2JqLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIodmFsdWUucmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmdlbmVyYXRlU2hhcmVkQ29udGV4dFZhciA9IGZ1bmN0aW9uIChyZXRyaWV2YWxMZXZlbCkge1xuICAgICAgICB2YXIgbGhzID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FICsgdGhpcy5mcmVzaFJlZmVyZW5jZU5hbWUoKSk7XG4gICAgICAgIHRoaXMubWFwLnNldChTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbCwge1xuICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgbGhzOiBsaHMsXG4gICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogZnVuY3Rpb24gKHNjb3BlLCByZWxhdGl2ZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgY3R4X3IwID0gbmV4dENvbnRleHQoMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWwpKS50b0NvbnN0RGVjbCgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiAyIC8qIFNIQVJFRF9DT05URVhUICovLFxuICAgICAgICAgICAgbG9jYWxSZWY6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS5nZXRDb21wb25lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRWYWx1ZSA9IHRoaXMubWFwLmdldChTSEFSRURfQ09OVEVYVF9LRVkgKyAwKTtcbiAgICAgICAgY29tcG9uZW50VmFsdWUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWF5YmVSZXN0b3JlVmlldygwLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRWYWx1ZS5saHMucHJvcChuYW1lKTtcbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUubWF5YmVSZXN0b3JlVmlldyA9IGZ1bmN0aW9uIChyZXRyaWV2YWxMZXZlbCwgbG9jYWxSZWZMb29rdXApIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXN0b3JlIHRoZSBjdXJyZW50IHZpZXcgaW4gbGlzdGVuZXIgZm5zIGlmOlxuICAgICAgICAvLyAxIC0gd2UgYXJlIGFjY2Vzc2luZyBhIHZhbHVlIGluIGEgcGFyZW50IHZpZXcsIHdoaWNoIHJlcXVpcmVzIHdhbGtpbmcgdGhlIHZpZXcgdHJlZSByYXRoZXJcbiAgICAgICAgLy8gdGhhbiB1c2luZyB0aGUgY3R4IGFyZy4gSW4gdGhpcyBjYXNlLCB0aGUgcmV0cmlldmFsIGFuZCBiaW5kaW5nIGxldmVsIHdpbGwgYmUgZGlmZmVyZW50LlxuICAgICAgICAvLyAyIC0gd2UgYXJlIGxvb2tpbmcgdXAgYSBsb2NhbCByZWYsIHdoaWNoIHJlcXVpcmVzIHJlc3RvcmluZyB0aGUgdmlldyB3aGVyZSB0aGUgbG9jYWxcbiAgICAgICAgLy8gcmVmIGlzIHN0b3JlZFxuICAgICAgICBpZiAodGhpcy5pc0xpc3RlbmVyU2NvcGUoKSAmJiAocmV0cmlldmFsTGV2ZWwgPCB0aGlzLmJpbmRpbmdMZXZlbCB8fCBsb2NhbFJlZkxvb2t1cCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQucmVzdG9yZVZpZXdWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBzYXZlcyB2YXJpYWJsZSB0byBnZW5lcmF0ZSBhIHNoYXJlZCBgY29uc3QgJHMkID0gZ2V0Q3VycmVudFZpZXcoKTtgIGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVzdG9yZVZpZXdWYXJpYWJsZSA9IHZhcmlhYmxlKHRoaXMucGFyZW50LmZyZXNoUmVmZXJlbmNlTmFtZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZSA9IHRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpbmRpbmdTY29wZS5wcm90b3R5cGUucmVzdG9yZVZpZXdTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc3RvcmVWaWV3KCRzdGF0ZSQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlID9cbiAgICAgICAgICAgIFtpbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycyQxLnJlc3RvcmVWaWV3LCBbdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlXSkudG9TdG10KCldIDpcbiAgICAgICAgICAgIFtdO1xuICAgIH07XG4gICAgQmluZGluZ1Njb3BlLnByb3RvdHlwZS52aWV3U25hcHNob3RTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zdCAkc3RhdGUkID0gZ2V0Q3VycmVudFZpZXcoKTtcbiAgICAgICAgdmFyIGdldEN1cnJlbnRWaWV3SW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycyQxLmdldEN1cnJlbnRWaWV3LCBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgP1xuICAgICAgICAgICAgW3RoaXMucmVzdG9yZVZpZXdWYXJpYWJsZS5zZXQoZ2V0Q3VycmVudFZpZXdJbnN0cnVjdGlvbikudG9Db25zdERlY2woKV0gOlxuICAgICAgICAgICAgW107XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmlzTGlzdGVuZXJTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmJpbmRpbmdMZXZlbCA9PT0gdGhpcy5iaW5kaW5nTGV2ZWw7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnZhcmlhYmxlRGVjbGFyYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHRMZXZlbCA9IDA7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLmRlY2xhcmU7IH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi5yZXRyaWV2YWxMZXZlbCAtIGEucmV0cmlldmFsTGV2ZWwgfHwgYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChzdG10cywgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbERpZmYgPSBfdGhpcy5iaW5kaW5nTGV2ZWwgLSB2YWx1ZS5yZXRyaWV2YWxMZXZlbDtcbiAgICAgICAgICAgIHZhciBjdXJyU3RtdHMgPSB2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayhfdGhpcywgbGV2ZWxEaWZmIC0gY3VycmVudENvbnRleHRMZXZlbCk7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dExldmVsID0gbGV2ZWxEaWZmO1xuICAgICAgICAgICAgcmV0dXJuIHN0bXRzLmNvbmNhdChjdXJyU3RtdHMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLmZyZXNoUmVmZXJlbmNlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAvLyBGaW5kIHRoZSB0b3Agc2NvcGUgYXMgaXQgbWFpbnRhaW5zIHRoZSBnbG9iYWwgcmVmZXJlbmNlIGNvdW50XG4gICAgICAgIHdoaWxlIChjdXJyZW50LnBhcmVudClcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgdmFyIHJlZiA9IFwiXCIgKyBSRUZFUkVOQ0VfUFJFRklYICsgY3VycmVudC5yZWZlcmVuY2VOYW1lSW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nU2NvcGU7XG59KCkpO1xuLyoqXG4gKiBDcmVhdGVzIGEgYENzc1NlbGVjdG9yYCBnaXZlbiBhIHRhZyBuYW1lIGFuZCBhIG1hcCBvZiBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgdmFyIGVsZW1lbnROYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKVsxXTtcbiAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KGVsZW1lbnROYW1lTm9Ocyk7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgbmFtZU5vTnMgPSBzcGxpdE5zTmFtZShuYW1lKVsxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKG5hbWVOb05zLCB2YWx1ZSk7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGV4cHJlc3Npb25zIG91dCBvZiBhbiBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZXNcbiAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKGF0dHJpYnV0ZSkge1xuICAgIC8vIFBhcnNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW50byBhIENzc1NlbGVjdG9yTGlzdC4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGVcbiAgICAvLyBmaXJzdCBzZWxlY3RvciwgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdG9ycyBpbiBuZ1Byb2plY3RBcy5cbiAgICB2YXIgcGFyc2VkUjNTZWxlY3RvciA9IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IoYXR0cmlidXRlLnZhbHVlKVswXTtcbiAgICByZXR1cm4gW2xpdGVyYWwoNSAvKiBQcm9qZWN0QXMgKi8pLCBhc0xpdGVyYWwocGFyc2VkUjNTZWxlY3RvcildO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgYW4gaW50ZXJwb2xhdGVkIHByb3BlcnR5XG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgaW50ZXJwb2xhdGVkIHRleHQuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIGludG8gcmVuZGVyMyBgTm9kZWBzIGFuZCBhZGRpdGlvbmFsIG1ldGFkYXRhLCB3aXRoIG5vIG90aGVyIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGUgdGV4dCBvZiB0aGUgdGVtcGxhdGUgdG8gcGFyc2VcbiAqIEBwYXJhbSB0ZW1wbGF0ZVVybCBVUkwgdG8gdXNlIGZvciBzb3VyY2UgbWFwcGluZyBvZiB0aGUgcGFyc2VkIHRlbXBsYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIG1vZGlmeSBob3cgdGhlIHRlbXBsYXRlIGlzIHBhcnNlZFxuICovXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcsIHByZXNlcnZlV2hpdGVzcGFjZXMgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZXMsIGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQgPSBvcHRpb25zLmVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQ7XG4gICAgdmFyIGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB2YXIgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgdmFyIHBhcnNlUmVzdWx0ID0gaHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIF9fYXNzaWduKF9fYXNzaWduKHsgbGVhZGluZ1RyaXZpYUNoYXJzOiBMRUFESU5HX1RSSVZJQV9DSEFSUyB9LCBvcHRpb25zKSwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pKTtcbiAgICBpZiAocGFyc2VSZXN1bHQuZXJyb3JzICYmIHBhcnNlUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHBhcnNlUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlVXJsczogW10sXG4gICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgcm9vdE5vZGVzID0gcGFyc2VSZXN1bHQucm9vdE5vZGVzO1xuICAgIC8vIHByb2Nlc3MgaTE4biBtZXRhIGluZm9ybWF0aW9uIChzY2FuIGF0dHJpYnV0ZXMsIGdlbmVyYXRlIGlkcylcbiAgICAvLyBiZWZvcmUgd2UgcnVuIHdoaXRlc3BhY2UgcmVtb3ZhbCBwcm9jZXNzLCBiZWNhdXNlIGV4aXN0aW5nIGkxOG5cbiAgICAvLyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIHhpMThuKSByZWxpZXMgb24gYSByYXcgY29udGVudCB0byBnZW5lcmF0ZVxuICAgIC8vIG1lc3NhZ2UgaWRzXG4gICAgdmFyIGkxOG5NZXRhVmlzaXRvciA9IG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyAhcHJlc2VydmVXaGl0ZXNwYWNlcywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCk7XG4gICAgcm9vdE5vZGVzID0gdmlzaXRBbGwkMShpMThuTWV0YVZpc2l0b3IsIHJvb3ROb2Rlcyk7XG4gICAgaWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2VzKSB7XG4gICAgICAgIHJvb3ROb2RlcyA9IHZpc2l0QWxsJDEobmV3IFdoaXRlc3BhY2VWaXNpdG9yKCksIHJvb3ROb2Rlcyk7XG4gICAgICAgIC8vIHJ1biBpMThuIG1ldGEgdmlzaXRvciBhZ2FpbiBpbiBjYXNlIHdoaXRlc3BhY2VzIGFyZSByZW1vdmVkIChiZWNhdXNlIHRoYXQgbWlnaHQgYWZmZWN0XG4gICAgICAgIC8vIGdlbmVyYXRlZCBpMThuIG1lc3NhZ2UgY29udGVudCkgYW5kIGZpcnN0IHBhc3MgaW5kaWNhdGVkIHRoYXQgaTE4biBjb250ZW50IGlzIHByZXNlbnQgaW4gYVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gRHVyaW5nIHRoaXMgcGFzcyBpMThuIElEcyBnZW5lcmF0ZWQgYXQgdGhlIGZpcnN0IHBhc3Mgd2lsbCBiZSBwcmVzZXJ2ZWQsIHNvIHdlIGNhblxuICAgICAgICAvLyBtaW1pYyBleGlzdGluZyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIHhpMThuKVxuICAgICAgICBpZiAoaTE4bk1ldGFWaXNpdG9yLmhhc0kxOG5NZXRhKSB7XG4gICAgICAgICAgICByb290Tm9kZXMgPSB2aXNpdEFsbCQxKG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyBmYWxzZSksIHJvb3ROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9hID0gaHRtbEFzdFRvUmVuZGVyM0FzdChyb290Tm9kZXMsIGJpbmRpbmdQYXJzZXIpLCBub2RlcyA9IF9hLm5vZGVzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHN0eWxlVXJscyA9IF9hLnN0eWxlVXJscywgc3R5bGVzID0gX2Euc3R5bGVzLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9ycywgbm9kZXM6IFtdLCBzdHlsZVVybHM6IFtdLCBzdHlsZXM6IFtdLCBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdIH07XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVzOiBub2Rlcywgc3R5bGVVcmxzOiBzdHlsZVVybHMsIHN0eWxlczogc3R5bGVzLCBuZ0NvbnRlbnRTZWxlY3RvcnM6IG5nQ29udGVudFNlbGVjdG9ycyB9O1xufVxudmFyIGVsZW1lbnRSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbi8qKlxuICogQ29uc3RydWN0IGEgYEJpbmRpbmdQYXJzZXJgIHdpdGggYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VCaW5kaW5nUGFyc2VyKGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgcmV0dXJuIG5ldyBCaW5kaW5nUGFyc2VyKG5ldyBJdnlQYXJzZXIobmV3IExleGVyKCkpLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBlbGVtZW50UmVnaXN0cnksIG51bGwsIFtdKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTYW5pdGl6YXRpb25Gbihjb250ZXh0LCBpc0F0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZUh0bWwpO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5TQ1JJUFQ6XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplU2NyaXB0KTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAvLyB0aGUgY29tcGlsZXIgZG9lcyBub3QgZmlsbCBpbiBhbiBpbnN0cnVjdGlvbiBmb3IgW3N0eWxlLnByb3A/XSBiaW5kaW5nXG4gICAgICAgICAgICAvLyB2YWx1ZXMgYmVjYXVzZSB0aGUgc3R5bGUgYWxnb3JpdGhtIGtub3dzIGludGVybmFsbHkgd2hhdCBwcm9wcyBhcmUgc3ViamVjdFxuICAgICAgICAgICAgLy8gdG8gc2FuaXRpemF0aW9uIChvbmx5IFthdHRyLnN0eWxlXSB2YWx1ZXMgYXJlIGV4cGxpY2l0bHkgc2FuaXRpemVkKVxuICAgICAgICAgICAgcmV0dXJuIGlzQXR0cmlidXRlID8gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplU3R5bGUpIDogbnVsbDtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZVVybCk7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVSZXNvdXJjZVVybCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NpbmdsZUVsZW1lbnRUZW1wbGF0ZShjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBCb3VuZFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEljdTtcbn1cbmZ1bmN0aW9uIGhhc1RleHRDaGlsZHJlbk9ubHkoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4uZXZlcnkoaXNUZXh0Tm9kZSk7XG59XG4vKiogTmFtZSBvZiB0aGUgZ2xvYmFsIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgdXNlIENsb3N1cmUgdHJhbnNsYXRpb25zIG9yIG5vdCAqL1xudmFyIE5HX0kxOE5fQ0xPU1VSRV9NT0RFID0gJ25nSTE4bkNsb3N1cmVNb2RlJztcbi8qKlxuICogR2VuZXJhdGUgc3RhdGVtZW50cyB0aGF0IGRlZmluZSBhIGdpdmVuIHRyYW5zbGF0aW9uIG1lc3NhZ2UuXG4gKlxuICogYGBgXG4gKiB2YXIgSTE4Tl8xO1xuICogaWYgKHR5cGVvZiBuZ0kxOG5DbG9zdXJlTW9kZSAhPT0gdW5kZWZpbmVkICYmIG5nSTE4bkNsb3N1cmVNb2RlKSB7XG4gKiAgICAgdmFyIE1TR19FWFRFUk5BTF9YWFggPSBnb29nLmdldE1zZyhcbiAqICAgICAgICAgIFwiU29tZSBtZXNzYWdlIHdpdGggeyRpbnRlcnBvbGF0aW9ufSFcIixcbiAqICAgICAgICAgIHsgXCJpbnRlcnBvbGF0aW9uXCI6IFwiXFx1RkZGRDBcXHVGRkZEXCIgfVxuICogICAgICk7XG4gKiAgICAgSTE4Tl8xID0gTVNHX0VYVEVSTkFMX1hYWDtcbiAqIH1cbiAqIGVsc2Uge1xuICogICAgIEkxOE5fMSA9ICRsb2NhbGl6ZWBTb21lIG1lc3NhZ2Ugd2l0aCAkeydcXHVGRkZEMFxcdUZGRkQnfSFgO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG9yaWdpbmFsIGkxOG4gQVNUIG1lc3NhZ2Ugbm9kZVxuICogQHBhcmFtIHZhcmlhYmxlIFRoZSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdGhlIHRyYW5zbGF0aW9uLCBlLmcuIGBJMThOXzFgLlxuICogQHBhcmFtIGNsb3N1cmVWYXIgVGhlIHZhcmlhYmxlIGZvciBDbG9zdXJlIGBnb29nLmdldE1zZ2AgY2FsbHMsIGUuZy4gYE1TR19FWFRFUk5BTF9YWFhgLlxuICogQHBhcmFtIHBhcmFtcyBPYmplY3QgbWFwcGluZyBwbGFjZWhvbGRlciBuYW1lcyB0byB0aGVpciB2YWx1ZXMgKGUuZy5cbiAqIGB7IFwiaW50ZXJwb2xhdGlvblwiOiBcIlxcdUZGRkQwXFx1RkZGRFwiIH1gKS5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1GbiBPcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdHJhbnNsYXRpb24gKGUuZy5cbiAqIHBvc3QtcHJvY2Vzc2luZykuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHRoYXQgZGVmaW5lZCBhIGdpdmVuIHRyYW5zbGF0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCB2YXJpYWJsZSwgY2xvc3VyZVZhciwgcGFyYW1zLCB0cmFuc2Zvcm1Gbikge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHZhciBzdGF0ZW1lbnRzID0gW1xuICAgICAgICBkZWNsYXJlSTE4blZhcmlhYmxlKHZhcmlhYmxlKSxcbiAgICAgICAgaWZTdG10KGNyZWF0ZUNsb3N1cmVNb2RlR3VhcmQoKSwgY3JlYXRlR29vZ2xlR2V0TXNnU3RhdGVtZW50cyh2YXJpYWJsZSwgbWVzc2FnZSwgY2xvc3VyZVZhciwgaTE4bkZvcm1hdFBsYWNlaG9sZGVyTmFtZXMocGFyYW1zLCAvKiB1c2VDYW1lbENhc2UgKi8gdHJ1ZSkpLCBjcmVhdGVMb2NhbGl6ZVN0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIGkxOG5Gb3JtYXRQbGFjZWhvbGRlck5hbWVzKHBhcmFtcywgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKSkpLFxuICAgIF07XG4gICAgaWYgKHRyYW5zZm9ybUZuKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh2YXJpYWJsZS5zZXQodHJhbnNmb3JtRm4odmFyaWFibGUpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGd1YXJkIHRoZSBjbG9zdXJlIG1vZGUgYmxvY2tcbiAqIEl0IGlzIGVxdWl2YWxlbnQgdG86XG4gKlxuICogYGBgXG4gKiB0eXBlb2YgbmdJMThuQ2xvc3VyZU1vZGUgIT09IHVuZGVmaW5lZCAmJiBuZ0kxOG5DbG9zdXJlTW9kZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsb3N1cmVNb2RlR3VhcmQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZkV4cHIodmFyaWFibGUoTkdfSTE4Tl9DTE9TVVJFX01PREUpKVxuICAgICAgICAubm90SWRlbnRpY2FsKGxpdGVyYWwoJ3VuZGVmaW5lZCcsIFNUUklOR19UWVBFKSlcbiAgICAgICAgLmFuZCh2YXJpYWJsZShOR19JMThOX0NMT1NVUkVfTU9ERSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcbi8vIFRoaXMgcmVnZXggbWF0Y2hlcyBhbnkgYmluZGluZyBuYW1lcyB0aGF0IGNvbnRhaW4gdGhlIFwiYXR0ci5cIiBwcmVmaXgsIGUuZy4gXCJhdHRyLnJlcXVpcmVkXCJcbi8vIElmIHRoZXJlIGlzIGEgbWF0Y2gsIHRoZSBmaXJzdCBtYXRjaGluZyBncm91cCB3aWxsIGNvbnRhaW4gdGhlIGF0dHJpYnV0ZSBuYW1lIHRvIGJpbmQuXG52YXIgQVRUUl9SRUdFWCA9IC9hdHRyXFwuKFteXFxdXSspLztcbmZ1bmN0aW9uIGJhc2VEaXJlY3RpdmVGaWVsZHMobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKSB7XG4gICAgdmFyIGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIHZhciBzZWxlY3RvcnMgPSBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yKG1ldGEuc2VsZWN0b3IpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15RGlyZWN0aXZlYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIC8vIGUuZy4gYHNlbGVjdG9yczogW1snJywgJ3NvbWVEaXInLCAnJ11dYFxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2VsZWN0b3JzJywgYXNMaXRlcmFsKHNlbGVjdG9ycykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZS5nLiBgY29udGVudFF1ZXJpZXM6IChyZiwgY3R4LCBkaXJJbmRleCkgPT4geyAuLi4gfVxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY29udGVudFF1ZXJpZXMnLCBjcmVhdGVDb250ZW50UXVlcmllc0Z1bmN0aW9uKG1ldGEucXVlcmllcywgY29uc3RhbnRQb29sLCBtZXRhLm5hbWUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcnknLCBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKG1ldGEudmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbWV0YS5uYW1lKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGhvc3RCaW5kaW5nczogKHJmLCBjdHgpID0+IHsgLi4uIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEJpbmRpbmdzJywgY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24obWV0YS5ob3N0LCBtZXRhLnR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIG1ldGEuc2VsZWN0b3IgfHwgJycsIG1ldGEubmFtZSwgZGVmaW5pdGlvbk1hcCkpO1xuICAgIC8vIGUuZyAnaW5wdXRzOiB7YTogJ2EnfWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5pbnB1dHMsIHRydWUpKTtcbiAgICAvLyBlLmcgJ291dHB1dHM6IHthOiAnYSd9YFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdvdXRwdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5vdXRwdXRzKSk7XG4gICAgaWYgKG1ldGEuZXhwb3J0QXMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydEFzJywgbGl0ZXJhbEFycihtZXRhLmV4cG9ydEFzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gbGl0ZXJhbChlKTsgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG4vKipcbiAqIEFkZCBmZWF0dXJlcyB0byB0aGUgZGVmaW5pdGlvbiBtYXAuXG4gKi9cbmZ1bmN0aW9uIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpIHtcbiAgICAvLyBlLmcuIGBmZWF0dXJlczogW05nT25DaGFuZ2VzRmVhdHVyZV1gXG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmFyIHByb3ZpZGVycyA9IG1ldGEucHJvdmlkZXJzO1xuICAgIHZhciB2aWV3UHJvdmlkZXJzID0gbWV0YS52aWV3UHJvdmlkZXJzO1xuICAgIGlmIChwcm92aWRlcnMgfHwgdmlld1Byb3ZpZGVycykge1xuICAgICAgICB2YXIgYXJncyA9IFtwcm92aWRlcnMgfHwgbmV3IExpdGVyYWxBcnJheUV4cHIoW10pXTtcbiAgICAgICAgaWYgKHZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh2aWV3UHJvdmlkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5Qcm92aWRlcnNGZWF0dXJlKS5jYWxsRm4oYXJncykpO1xuICAgIH1cbiAgICBpZiAobWV0YS51c2VzSW5oZXJpdGFuY2UpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuSW5oZXJpdERlZmluaXRpb25GZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmZ1bGxJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5Db3B5RGVmaW5pdGlvbkZlYXR1cmUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEubGlmZWN5Y2xlLnVzZXNPbkNoYW5nZXMpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuTmdPbkNoYW5nZXNGZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ZlYXR1cmVzJywgbGl0ZXJhbEFycihmZWF0dXJlcykpO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcGlsZSBhIGRpcmVjdGl2ZSBmb3IgdGhlIHJlbmRlcjMgcnVudGltZSBhcyBkZWZpbmVkIGJ5IHRoZSBgUjNEaXJlY3RpdmVNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKSB7XG4gICAgdmFyIGRlZmluaXRpb25NYXAgPSBiYXNlRGlyZWN0aXZlRmllbGRzKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lRGlyZWN0aXZlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICB2YXIgdHlwZVBhcmFtcyA9IGNyZWF0ZURpcmVjdGl2ZVR5cGVQYXJhbXMobWV0YSk7XG4gICAgdmFyIHR5cGUgPSBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuRGlyZWN0aXZlRGVmV2l0aE1ldGEsIHR5cGVQYXJhbXMpKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uOiBleHByZXNzaW9uLCB0eXBlOiB0eXBlIH07XG59XG4vKipcbiAqIENvbXBpbGUgYSBjb21wb25lbnQgZm9yIHRoZSByZW5kZXIzIHJ1bnRpbWUgYXMgZGVmaW5lZCBieSB0aGUgYFIzQ29tcG9uZW50TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIHZhciBzZWxlY3RvciA9IG1ldGEuc2VsZWN0b3IgJiYgQ3NzU2VsZWN0b3IucGFyc2UobWV0YS5zZWxlY3Rvcik7XG4gICAgdmFyIGZpcnN0U2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3RvclswXTtcbiAgICAvLyBlLmcuIGBhdHRyOiBbXCJjbGFzc1wiLCBcIi5teS5hcHBcIl1gXG4gICAgLy8gVGhpcyBpcyBvcHRpb25hbCBhbiBvbmx5IGluY2x1ZGVkIGlmIHRoZSBmaXJzdCBzZWxlY3RvciBvZiBhIGNvbXBvbmVudCBzcGVjaWZpZXMgYXR0cmlidXRlcy5cbiAgICBpZiAoZmlyc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgc2VsZWN0b3JBdHRyaWJ1dGVzID0gZmlyc3RTZWxlY3Rvci5nZXRBdHRycygpO1xuICAgICAgICBpZiAoc2VsZWN0b3JBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2F0dHJzJywgY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHNlbGVjdG9yQXR0cmlidXRlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPSBudWxsID8gbGl0ZXJhbCh2YWx1ZSkgOiBsaXRlcmFsKHVuZGVmaW5lZCk7IH0pKSwgXG4gICAgICAgICAgICAvKiBmb3JjZVNoYXJlZCAqLyB0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgdGhlIENTUyBtYXRjaGVyIHRoYXQgcmVjb2duaXplIGRpcmVjdGl2ZVxuICAgIHZhciBkaXJlY3RpdmVNYXRjaGVyID0gbnVsbDtcbiAgICBpZiAobWV0YS5kaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG1ldGEuZGlyZWN0aXZlcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2QgPSBfYy52YWx1ZSwgc2VsZWN0b3JfMSA9IF9kLnNlbGVjdG9yLCBleHByZXNzaW9uXzEgPSBfZC5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3JfMSksIGV4cHJlc3Npb25fMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmVNYXRjaGVyID0gbWF0Y2hlcjtcbiAgICB9XG4gICAgLy8gZS5nLiBgdGVtcGxhdGU6IGZ1bmN0aW9uIE15Q29tcG9uZW50X1RlbXBsYXRlKF9jdHgsIF9jbSkgey4uLn1gXG4gICAgdmFyIHRlbXBsYXRlVHlwZU5hbWUgPSBtZXRhLm5hbWU7XG4gICAgdmFyIHRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlVHlwZU5hbWUgPyB0ZW1wbGF0ZVR5cGVOYW1lICsgXCJfVGVtcGxhdGVcIiA6IG51bGw7XG4gICAgdmFyIGRpcmVjdGl2ZXNVc2VkID0gbmV3IFNldCgpO1xuICAgIHZhciBwaXBlc1VzZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNoYW5nZURldGVjdGlvbiA9IG1ldGEuY2hhbmdlRGV0ZWN0aW9uO1xuICAgIHZhciB0ZW1wbGF0ZSA9IG1ldGEudGVtcGxhdGU7XG4gICAgdmFyIHRlbXBsYXRlQnVpbGRlciA9IG5ldyBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyKGNvbnN0YW50UG9vbCwgQmluZGluZ1Njb3BlLmNyZWF0ZVJvb3RTY29wZSgpLCAwLCB0ZW1wbGF0ZVR5cGVOYW1lLCBudWxsLCBudWxsLCB0ZW1wbGF0ZU5hbWUsIGRpcmVjdGl2ZU1hdGNoZXIsIGRpcmVjdGl2ZXNVc2VkLCBtZXRhLnBpcGVzLCBwaXBlc1VzZWQsIElkZW50aWZpZXJzJDEubmFtZXNwYWNlSFRNTCwgbWV0YS5yZWxhdGl2ZUNvbnRleHRGaWxlUGF0aCwgbWV0YS5pMThuVXNlRXh0ZXJuYWxJZHMpO1xuICAgIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHRlbXBsYXRlQnVpbGRlci5idWlsZFRlbXBsYXRlRnVuY3Rpb24odGVtcGxhdGUubm9kZXMsIFtdKTtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBzbyB0aGF0IGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBjb21wb25lbnRzIGtub3cgd2hhdFxuICAgIC8vIHByb2plY3RlZCBjb250ZW50IGJsb2NrcyB0byBwYXNzIHRocm91Z2ggdG8gdGhlIGNvbXBvbmVudCB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZC5cbiAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gdGVtcGxhdGVCdWlsZGVyLmdldE5nQ29udGVudFNlbGVjdG9ycygpO1xuICAgIGlmIChuZ0NvbnRlbnRTZWxlY3RvcnMpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nQ29udGVudFNlbGVjdG9ycycsIG5nQ29udGVudFNlbGVjdG9ycyk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGRlY2xzOiAyYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNscycsIGxpdGVyYWwodGVtcGxhdGVCdWlsZGVyLmdldENvbnN0Q291bnQoKSkpO1xuICAgIC8vIGUuZy4gYHZhcnM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZhcnMnLCBsaXRlcmFsKHRlbXBsYXRlQnVpbGRlci5nZXRWYXJDb3VudCgpKSk7XG4gICAgLy8gZS5nLiBgY29uc3RzOiBbWydvbmUnLCAndHdvJ10sIFsndGhyZWUnLCAnZm91ciddXVxuICAgIHZhciBjb25zdHMgPSB0ZW1wbGF0ZUJ1aWxkZXIuZ2V0Q29uc3RzKCk7XG4gICAgaWYgKGNvbnN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdjb25zdHMnLCBsaXRlcmFsQXJyKGNvbnN0cykpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgndGVtcGxhdGUnLCB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgLy8gZS5nLiBgZGlyZWN0aXZlczogW015RGlyZWN0aXZlXWBcbiAgICBpZiAoZGlyZWN0aXZlc1VzZWQuc2l6ZSkge1xuICAgICAgICB2YXIgZGlyZWN0aXZlc0V4cHIgPSBsaXRlcmFsQXJyKEFycmF5LmZyb20oZGlyZWN0aXZlc1VzZWQpKTtcbiAgICAgICAgaWYgKG1ldGEud3JhcERpcmVjdGl2ZXNBbmRQaXBlc0luQ2xvc3VyZSkge1xuICAgICAgICAgICAgZGlyZWN0aXZlc0V4cHIgPSBmbihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQoZGlyZWN0aXZlc0V4cHIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RpcmVjdGl2ZXMnLCBkaXJlY3RpdmVzRXhwcik7XG4gICAgfVxuICAgIC8vIGUuZy4gYHBpcGVzOiBbTXlQaXBlXWBcbiAgICBpZiAocGlwZXNVc2VkLnNpemUpIHtcbiAgICAgICAgdmFyIHBpcGVzRXhwciA9IGxpdGVyYWxBcnIoQXJyYXkuZnJvbShwaXBlc1VzZWQpKTtcbiAgICAgICAgaWYgKG1ldGEud3JhcERpcmVjdGl2ZXNBbmRQaXBlc0luQ2xvc3VyZSkge1xuICAgICAgICAgICAgcGlwZXNFeHByID0gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KHBpcGVzRXhwcildKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncGlwZXMnLCBwaXBlc0V4cHIpO1xuICAgIH1cbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIG1ldGEuZW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xuICAgIH1cbiAgICAvLyBlLmcuIGBzdHlsZXM6IFtzdHIxLCBzdHIyXWBcbiAgICBpZiAobWV0YS5zdHlsZXMgJiYgbWV0YS5zdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzdHlsZVZhbHVlcyA9IG1ldGEuZW5jYXBzdWxhdGlvbiA9PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA/XG4gICAgICAgICAgICBjb21waWxlU3R5bGVzKG1ldGEuc3R5bGVzLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOlxuICAgICAgICAgICAgbWV0YS5zdHlsZXM7XG4gICAgICAgIHZhciBzdHJpbmdzID0gc3R5bGVWYWx1ZXMubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGxpdGVyYWwoc3RyKTsgfSk7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdzdHlsZXMnLCBsaXRlcmFsQXJyKHN0cmluZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdHlsZSwgZG9uJ3QgZ2VuZXJhdGUgY3NzIHNlbGVjdG9ycyBvbiBlbGVtZW50c1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB2aWV3IGVuY2Fwc3VsYXRpb24gaWYgaXQncyBub3QgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uICE9PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZW5jYXBzdWxhdGlvbicsIGxpdGVyYWwobWV0YS5lbmNhcHN1bGF0aW9uKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGFuaW1hdGlvbjogW3RyaWdnZXIoJzEyMycsIFtdKV1gXG4gICAgaWYgKG1ldGEuYW5pbWF0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZGF0YScsIGxpdGVyYWxNYXAoW3sga2V5OiAnYW5pbWF0aW9uJywgdmFsdWU6IG1ldGEuYW5pbWF0aW9ucywgcXVvdGVkOiBmYWxzZSB9XSkpO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB0aGUgY2hhbmdlIGRldGVjdGlvbiBmbGFnIGlmIGl0J3MgZGVmaW5lZCBhbmQgaXQncyBub3QgdGhlIGRlZmF1bHQuXG4gICAgaWYgKGNoYW5nZURldGVjdGlvbiAhPSBudWxsICYmIGNoYW5nZURldGVjdGlvbiAhPT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY2hhbmdlRGV0ZWN0aW9uJywgbGl0ZXJhbChjaGFuZ2VEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgdmFyIGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lQ29tcG9uZW50KS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICB2YXIgdHlwZVBhcmFtcyA9IGNyZWF0ZURpcmVjdGl2ZVR5cGVQYXJhbXMobWV0YSk7XG4gICAgdHlwZVBhcmFtcy5wdXNoKHN0cmluZ0FycmF5QXNUeXBlKG1ldGEudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzKSk7XG4gICAgdmFyIHR5cGUgPSBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuQ29tcG9uZW50RGVmV2l0aE1ldGEsIHR5cGVQYXJhbXMpKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uOiBleHByZXNzaW9uLCB0eXBlOiB0eXBlIH07XG59XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYGNvbXBpbGVEaXJlY3RpdmVgIHdoaWNoIGRlcGVuZHMgb24gcmVuZGVyMiBnbG9iYWwgYW5hbHlzaXMgZGF0YSBhcyBpdHMgaW5wdXRcbiAqIGluc3RlYWQgb2YgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqXG4gKiBgUjNEaXJlY3RpdmVNZXRhZGF0YWAgaXMgY29tcHV0ZWQgZnJvbSBgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhYCBhbmQgb3RoZXIgc3RhdGljYWxseSByZWZsZWN0ZWRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGlyZWN0aXZlRnJvbVJlbmRlcjIob3V0cHV0Q3R4LCBkaXJlY3RpdmUsIHJlZmxlY3RvciwgYmluZGluZ1BhcnNlcikge1xuICAgIHZhciBuYW1lID0gaWRlbnRpZmllck5hbWUoZGlyZWN0aXZlLnR5cGUpO1xuICAgIG5hbWUgfHwgZXJyb3IoXCJDYW5ub3QgcmVzb2x2ZXIgdGhlIG5hbWUgb2YgXCIgKyBkaXJlY3RpdmUudHlwZSk7XG4gICAgdmFyIGRlZmluaXRpb25GaWVsZCA9IG91dHB1dEN0eC5jb25zdGFudFBvb2wucHJvcGVydHlOYW1lT2YoMSAvKiBEaXJlY3RpdmUgKi8pO1xuICAgIHZhciBtZXRhID0gZGlyZWN0aXZlTWV0YWRhdGFGcm9tR2xvYmFsTWV0YWRhdGEoZGlyZWN0aXZlLCBvdXRwdXRDdHgsIHJlZmxlY3Rvcik7XG4gICAgdmFyIHJlcyA9IGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSwgb3V0cHV0Q3R4LmNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgdmFyIGZhY3RvcnlSZXMgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKF9fYXNzaWduKF9fYXNzaWduKHt9LCBtZXRhKSwgeyBpbmplY3RGbjogSWRlbnRpZmllcnMkMS5kaXJlY3RpdmVJbmplY3QsIHRhcmdldDogUjNGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KSk7XG4gICAgdmFyIG5nRmFjdG9yeURlZlN0YXRlbWVudCA9IG5ldyBDbGFzc1N0bXQobmFtZSwgbnVsbCwgW25ldyBDbGFzc0ZpZWxkKCfJtWZhYycsIElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuU3RhdGljXSwgZmFjdG9yeVJlcy5mYWN0b3J5KV0sIFtdLCBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgW10pO1xuICAgIHZhciBkaXJlY3RpdmVEZWZTdGF0ZW1lbnQgPSBuZXcgQ2xhc3NTdG10KG5hbWUsIG51bGwsIFtuZXcgQ2xhc3NGaWVsZChkZWZpbml0aW9uRmllbGQsIElORkVSUkVEX1RZUEUsIFtTdG10TW9kaWZpZXIuU3RhdGljXSwgcmVzLmV4cHJlc3Npb24pXSwgW10sIG5ldyBDbGFzc01ldGhvZChudWxsLCBbXSwgW10pLCBbXSk7XG4gICAgLy8gQ3JlYXRlIHRoZSBwYXJ0aWFsIGNsYXNzIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBhY3R1YWwgY2xhc3MuXG4gICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaChuZ0ZhY3RvcnlEZWZTdGF0ZW1lbnQsIGRpcmVjdGl2ZURlZlN0YXRlbWVudCk7XG59XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYGNvbXBpbGVDb21wb25lbnRgIHdoaWNoIGRlcGVuZHMgb24gcmVuZGVyMiBnbG9iYWwgYW5hbHlzaXMgZGF0YSBhcyBpdHMgaW5wdXRcbiAqIGluc3RlYWQgb2YgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqXG4gKiBgUjNDb21wb25lbnRNZXRhZGF0YWAgaXMgY29tcHV0ZWQgZnJvbSBgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhYCBhbmQgb3RoZXIgc3RhdGljYWxseSByZWZsZWN0ZWRcbiAqIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcG9uZW50RnJvbVJlbmRlcjIob3V0cHV0Q3R4LCBjb21wb25lbnQsIHJlbmRlcjNBc3QsIHJlZmxlY3RvciwgYmluZGluZ1BhcnNlciwgZGlyZWN0aXZlVHlwZUJ5U2VsLCBwaXBlVHlwZUJ5TmFtZSkge1xuICAgIHZhciBuYW1lID0gaWRlbnRpZmllck5hbWUoY29tcG9uZW50LnR5cGUpO1xuICAgIG5hbWUgfHwgZXJyb3IoXCJDYW5ub3QgcmVzb2x2ZXIgdGhlIG5hbWUgb2YgXCIgKyBjb21wb25lbnQudHlwZSk7XG4gICAgdmFyIGRlZmluaXRpb25GaWVsZCA9IG91dHB1dEN0eC5jb25zdGFudFBvb2wucHJvcGVydHlOYW1lT2YoMiAvKiBDb21wb25lbnQgKi8pO1xuICAgIHZhciBzdW1tYXJ5ID0gY29tcG9uZW50LnRvU3VtbWFyeSgpO1xuICAgIC8vIENvbXB1dGUgdGhlIFIzQ29tcG9uZW50TWV0YWRhdGEgZnJvbSB0aGUgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhXG4gICAgdmFyIG1ldGEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGlyZWN0aXZlTWV0YWRhdGFGcm9tR2xvYmFsTWV0YWRhdGEoY29tcG9uZW50LCBvdXRwdXRDdHgsIHJlZmxlY3RvcikpLCB7IHNlbGVjdG9yOiBjb21wb25lbnQuc2VsZWN0b3IsIHRlbXBsYXRlOiB7IG5vZGVzOiByZW5kZXIzQXN0Lm5vZGVzLCBuZ0NvbnRlbnRTZWxlY3RvcnM6IHJlbmRlcjNBc3QubmdDb250ZW50U2VsZWN0b3JzIH0sIGRpcmVjdGl2ZXM6IFtdLCBwaXBlczogdHlwZU1hcFRvRXhwcmVzc2lvbk1hcChwaXBlVHlwZUJ5TmFtZSwgb3V0cHV0Q3R4KSwgdmlld1F1ZXJpZXM6IHF1ZXJpZXNGcm9tR2xvYmFsTWV0YWRhdGEoY29tcG9uZW50LnZpZXdRdWVyaWVzLCBvdXRwdXRDdHgpLCB3cmFwRGlyZWN0aXZlc0FuZFBpcGVzSW5DbG9zdXJlOiBmYWxzZSwgc3R5bGVzOiAoc3VtbWFyeS50ZW1wbGF0ZSAmJiBzdW1tYXJ5LnRlbXBsYXRlLnN0eWxlcykgfHwgRU1QVFlfQVJSQVksIGVuY2Fwc3VsYXRpb246IChzdW1tYXJ5LnRlbXBsYXRlICYmIHN1bW1hcnkudGVtcGxhdGUuZW5jYXBzdWxhdGlvbikgfHwgVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsIGludGVycG9sYXRpb246IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcsIGFuaW1hdGlvbnM6IG51bGwsIHZpZXdQcm92aWRlcnM6IGNvbXBvbmVudC52aWV3UHJvdmlkZXJzLmxlbmd0aCA+IDAgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGNvbXBvbmVudC52aWV3UHJvdmlkZXJzKSA6IG51bGwsIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoOiAnJywgaTE4blVzZUV4dGVybmFsSWRzOiB0cnVlIH0pO1xuICAgIHZhciByZXMgPSBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhKG1ldGEsIG91dHB1dEN0eC5jb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIHZhciBmYWN0b3J5UmVzID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbWV0YSksIHsgaW5qZWN0Rm46IElkZW50aWZpZXJzJDEuZGlyZWN0aXZlSW5qZWN0LCB0YXJnZXQ6IFIzRmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSkpO1xuICAgIHZhciBuZ0ZhY3RvcnlEZWZTdGF0ZW1lbnQgPSBuZXcgQ2xhc3NTdG10KG5hbWUsIG51bGwsIFtuZXcgQ2xhc3NGaWVsZCgnybVmYWMnLCBJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIGZhY3RvcnlSZXMuZmFjdG9yeSldLCBbXSwgbmV3IENsYXNzTWV0aG9kKG51bGwsIFtdLCBbXSksIFtdKTtcbiAgICB2YXIgY29tcG9uZW50RGVmU3RhdGVtZW50ID0gbmV3IENsYXNzU3RtdChuYW1lLCBudWxsLCBbbmV3IENsYXNzRmllbGQoZGVmaW5pdGlvbkZpZWxkLCBJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIHJlcy5leHByZXNzaW9uKV0sIFtdLCBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgW10pO1xuICAgIC8vIENyZWF0ZSB0aGUgcGFydGlhbCBjbGFzcyB0byBiZSBtZXJnZWQgd2l0aCB0aGUgYWN0dWFsIGNsYXNzLlxuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2gobmdGYWN0b3J5RGVmU3RhdGVtZW50LCBjb21wb25lbnREZWZTdGF0ZW1lbnQpO1xufVxuLyoqXG4gKiBDb21wdXRlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYCBnaXZlbiBgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhYCBhbmQgYSBgQ29tcGlsZVJlZmxlY3RvcmAuXG4gKi9cbmZ1bmN0aW9uIGRpcmVjdGl2ZU1ldGFkYXRhRnJvbUdsb2JhbE1ldGFkYXRhKGRpcmVjdGl2ZSwgb3V0cHV0Q3R4LCByZWZsZWN0b3IpIHtcbiAgICAvLyBUaGUgZ2xvYmFsLWFuYWx5c2lzIGJhc2VkIEl2eSBtb2RlIGluIG5nYyBpcyBubyBsb25nZXIgdXRpbGl6ZWQvc3VwcG9ydGVkLlxuICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQnKTtcbn1cbi8qKlxuICogQ29udmVydCBgQ29tcGlsZVF1ZXJ5TWV0YWRhdGFgIGludG8gYFIzUXVlcnlNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJpZXNGcm9tR2xvYmFsTWV0YWRhdGEocXVlcmllcywgb3V0cHV0Q3R4KSB7XG4gICAgcmV0dXJuIHF1ZXJpZXMubWFwKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcmVhZCA9IG51bGw7XG4gICAgICAgIGlmIChxdWVyeS5yZWFkICYmIHF1ZXJ5LnJlYWQuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVhZCA9IG91dHB1dEN0eC5pbXBvcnRFeHByKHF1ZXJ5LnJlYWQuaWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IHF1ZXJ5LnByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIGZpcnN0OiBxdWVyeS5maXJzdCxcbiAgICAgICAgICAgIHByZWRpY2F0ZTogc2VsZWN0b3JzRnJvbUdsb2JhbE1ldGFkYXRhKHF1ZXJ5LnNlbGVjdG9ycywgb3V0cHV0Q3R4KSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxdWVyeS5kZXNjZW5kYW50cyxcbiAgICAgICAgICAgIHJlYWQ6IHJlYWQsXG4gICAgICAgICAgICBzdGF0aWM6ICEhcXVlcnkuc3RhdGljXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnQgYENvbXBpbGVUb2tlbk1ldGFkYXRhYCBmb3IgcXVlcnkgc2VsZWN0b3JzIGludG8gZWl0aGVyIGFuIGV4cHJlc3Npb24gZm9yIGEgcHJlZGljYXRlXG4gKiB0eXBlLCBvciBhIGxpc3Qgb2Ygc3RyaW5nIHByZWRpY2F0ZXMuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdG9yc0Zyb21HbG9iYWxNZXRhZGF0YShzZWxlY3RvcnMsIG91dHB1dEN0eCkge1xuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMSB8fCAoc2VsZWN0b3JzLmxlbmd0aCA9PSAxICYmIHNlbGVjdG9yc1swXS52YWx1ZSkpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yU3RyaW5ncyA9IHNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS52YWx1ZTsgfSk7XG4gICAgICAgIHNlbGVjdG9yU3RyaW5ncy5zb21lKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIXZhbHVlOyB9KSAmJlxuICAgICAgICAgICAgZXJyb3IoJ0ZvdW5kIGEgdHlwZSBhbW9uZyB0aGUgc3RyaW5nIHNlbGVjdG9ycyBleHBlY3RlZCcpO1xuICAgICAgICByZXR1cm4gb3V0cHV0Q3R4LmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbEFycihzZWxlY3RvclN0cmluZ3MubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGl0ZXJhbCh2YWx1ZSk7IH0pKSk7XG4gICAgfVxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gc2VsZWN0b3JzWzBdO1xuICAgICAgICBpZiAoZmlyc3QuaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEN0eC5pbXBvcnRFeHByKGZpcnN0LmlkZW50aWZpZXIucmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcnJvcignVW5leHBlY3RlZCBxdWVyeSBmb3JtJyk7XG4gICAgcmV0dXJuIE5VTExfRVhQUjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVRdWVyeVBhcmFtcyhxdWVyeSwgY29uc3RhbnRQb29sKSB7XG4gICAgdmFyIHBhcmFtZXRlcnMgPSBbZ2V0UXVlcnlQcmVkaWNhdGUocXVlcnksIGNvbnN0YW50UG9vbCksIGxpdGVyYWwocXVlcnkuZGVzY2VuZGFudHMpXTtcbiAgICBpZiAocXVlcnkucmVhZCkge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocXVlcnkucmVhZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZnVuY3Rpb24gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGxpdGVyYWwoa2V5KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLy8gRGVmaW5lIGFuZCB1cGRhdGUgYW55IGNvbnRlbnQgcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlQ29udGVudFF1ZXJpZXNGdW5jdGlvbihxdWVyaWVzLCBjb25zdGFudFBvb2wsIG5hbWUpIHtcbiAgICB2YXIgZV8zLCBfYTtcbiAgICB2YXIgY3JlYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIHRlbXBBbGxvY2F0b3IgPSB0ZW1wb3JhcnlBbGxvY2F0b3IodXBkYXRlU3RhdGVtZW50cywgVEVNUE9SQVJZX05BTUUpO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHF1ZXJpZXNfMSA9IF9fdmFsdWVzKHF1ZXJpZXMpLCBxdWVyaWVzXzFfMSA9IHF1ZXJpZXNfMS5uZXh0KCk7ICFxdWVyaWVzXzFfMS5kb25lOyBxdWVyaWVzXzFfMSA9IHF1ZXJpZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHF1ZXJpZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5SW5zdHJ1Y3Rpb24gPSBxdWVyeS5zdGF0aWMgPyBJZGVudGlmaWVycyQxLnN0YXRpY0NvbnRlbnRRdWVyeSA6IElkZW50aWZpZXJzJDEuY29udGVudFF1ZXJ5O1xuICAgICAgICAgICAgLy8gY3JlYXRpb24sIGUuZy4gcjMuY29udGVudFF1ZXJ5KGRpckluZGV4LCBzb21lUHJlZGljYXRlLCB0cnVlLCBudWxsKTtcbiAgICAgICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKHF1ZXJ5SW5zdHJ1Y3Rpb24pXG4gICAgICAgICAgICAgICAgLmNhbGxGbihfX3NwcmVhZChbdmFyaWFibGUoJ2RpckluZGV4JyldLCBwcmVwYXJlUXVlcnlQYXJhbXMocXVlcnksIGNvbnN0YW50UG9vbCkpKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAvLyB1cGRhdGUsIGUuZy4gKHIzLnF1ZXJ5UmVmcmVzaCh0bXAgPSByMy5sb2FkUXVlcnkoKSkgJiYgKGN0eC5zb21lRGlyID0gdG1wKSk7XG4gICAgICAgICAgICB2YXIgdGVtcG9yYXJ5ID0gdGVtcEFsbG9jYXRvcigpO1xuICAgICAgICAgICAgdmFyIGdldFF1ZXJ5TGlzdCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5sb2FkUXVlcnkpLmNhbGxGbihbXSk7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlRGlyZWN0aXZlID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKVxuICAgICAgICAgICAgICAgIC5wcm9wKHF1ZXJ5LnByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKHJlZnJlc2guYW5kKHVwZGF0ZURpcmVjdGl2ZSkudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocXVlcmllc18xXzEgJiYgIXF1ZXJpZXNfMV8xLmRvbmUgJiYgKF9hID0gcXVlcmllc18xLnJldHVybikpIF9hLmNhbGwocXVlcmllc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIHZhciBjb250ZW50UXVlcmllc0ZuTmFtZSA9IG5hbWUgPyBuYW1lICsgXCJfQ29udGVudFF1ZXJpZXNcIiA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtcbiAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCksXG4gICAgICAgIG5ldyBGblBhcmFtKCdkaXJJbmRleCcsIG51bGwpXG4gICAgXSwgW1xuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0ZVN0YXRlbWVudHMpLFxuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMiAvKiBVcGRhdGUgKi8sIHVwZGF0ZVN0YXRlbWVudHMpXG4gICAgXSwgSU5GRVJSRURfVFlQRSwgbnVsbCwgY29udGVudFF1ZXJpZXNGbk5hbWUpO1xufVxuZnVuY3Rpb24gc3RyaW5nQXNUeXBlKHN0cikge1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShsaXRlcmFsKHN0cikpO1xufVxuZnVuY3Rpb24gc3RyaW5nTWFwQXNUeXBlKG1hcCkge1xuICAgIHZhciBtYXBWYWx1ZXMgPSBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IEFycmF5LmlzQXJyYXkobWFwW2tleV0pID8gbWFwW2tleV1bMF0gOiBtYXBba2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwodmFsdWUpLFxuICAgICAgICAgICAgcXVvdGVkOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShsaXRlcmFsTWFwKG1hcFZhbHVlcykpO1xufVxuZnVuY3Rpb24gc3RyaW5nQXJyYXlBc1R5cGUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5sZW5ndGggPiAwID8gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycihhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbGl0ZXJhbCh2YWx1ZSk7IH0pKSkgOlxuICAgICAgICBOT05FX1RZUEU7XG59XG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpIHtcbiAgICAvLyBPbiB0aGUgdHlwZSBzaWRlLCByZW1vdmUgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0b3IgYXMgaXQgd2lsbCBuZWVkIHRvIGZpdCBpbnRvIGEgVHlwZVNjcmlwdFxuICAgIC8vIHN0cmluZyBsaXRlcmFsLCB3aGljaCBtdXN0IGJlIG9uIG9uZSBsaW5lLlxuICAgIHZhciBzZWxlY3RvckZvclR5cGUgPSBtZXRhLnNlbGVjdG9yICE9PSBudWxsID8gbWV0YS5zZWxlY3Rvci5yZXBsYWNlKC9cXG4vZywgJycpIDogbnVsbDtcbiAgICByZXR1cm4gW1xuICAgICAgICB0eXBlV2l0aFBhcmFtZXRlcnMobWV0YS50eXBlLnR5cGUsIG1ldGEudHlwZUFyZ3VtZW50Q291bnQpLFxuICAgICAgICBzZWxlY3RvckZvclR5cGUgIT09IG51bGwgPyBzdHJpbmdBc1R5cGUoc2VsZWN0b3JGb3JUeXBlKSA6IE5PTkVfVFlQRSxcbiAgICAgICAgbWV0YS5leHBvcnRBcyAhPT0gbnVsbCA/IHN0cmluZ0FycmF5QXNUeXBlKG1ldGEuZXhwb3J0QXMpIDogTk9ORV9UWVBFLFxuICAgICAgICBzdHJpbmdNYXBBc1R5cGUobWV0YS5pbnB1dHMpLFxuICAgICAgICBzdHJpbmdNYXBBc1R5cGUobWV0YS5vdXRwdXRzKSxcbiAgICAgICAgc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5xdWVyaWVzLm1hcChmdW5jdGlvbiAocSkgeyByZXR1cm4gcS5wcm9wZXJ0eU5hbWU7IH0pKSxcbiAgICBdO1xufVxuLy8gRGVmaW5lIGFuZCB1cGRhdGUgYW55IHZpZXcgcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlVmlld1F1ZXJpZXNGdW5jdGlvbih2aWV3UXVlcmllcywgY29uc3RhbnRQb29sLCBuYW1lKSB7XG4gICAgdmFyIGNyZWF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICB2YXIgdXBkYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciB0ZW1wQWxsb2NhdG9yID0gdGVtcG9yYXJ5QWxsb2NhdG9yKHVwZGF0ZVN0YXRlbWVudHMsIFRFTVBPUkFSWV9OQU1FKTtcbiAgICB2aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICB2YXIgcXVlcnlJbnN0cnVjdGlvbiA9IHF1ZXJ5LnN0YXRpYyA/IElkZW50aWZpZXJzJDEuc3RhdGljVmlld1F1ZXJ5IDogSWRlbnRpZmllcnMkMS52aWV3UXVlcnk7XG4gICAgICAgIC8vIGNyZWF0aW9uLCBlLmcuIHIzLnZpZXdRdWVyeShzb21lUHJlZGljYXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIHF1ZXJ5RGVmaW5pdGlvbiA9IGltcG9ydEV4cHIocXVlcnlJbnN0cnVjdGlvbikuY2FsbEZuKHByZXBhcmVRdWVyeVBhcmFtcyhxdWVyeSwgY29uc3RhbnRQb29sKSk7XG4gICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaChxdWVyeURlZmluaXRpb24udG9TdG10KCkpO1xuICAgICAgICAvLyB1cGRhdGUsIGUuZy4gKHIzLnF1ZXJ5UmVmcmVzaCh0bXAgPSByMy5sb2FkUXVlcnkoKSkgJiYgKGN0eC5zb21lRGlyID0gdG1wKSk7XG4gICAgICAgIHZhciB0ZW1wb3JhcnkgPSB0ZW1wQWxsb2NhdG9yKCk7XG4gICAgICAgIHZhciBnZXRRdWVyeUxpc3QgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEubG9hZFF1ZXJ5KS5jYWxsRm4oW10pO1xuICAgICAgICB2YXIgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmUgPSB2YXJpYWJsZShDT05URVhUX05BTUUpXG4gICAgICAgICAgICAucHJvcChxdWVyeS5wcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2gocmVmcmVzaC5hbmQodXBkYXRlRGlyZWN0aXZlKS50b1N0bXQoKSk7XG4gICAgfSk7XG4gICAgdmFyIHZpZXdRdWVyeUZuTmFtZSA9IG5hbWUgPyBuYW1lICsgXCJfUXVlcnlcIiA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtuZXcgRm5QYXJhbShSRU5ERVJfRkxBR1MsIE5VTUJFUl9UWVBFKSwgbmV3IEZuUGFyYW0oQ09OVEVYVF9OQU1FLCBudWxsKV0sIFtcbiAgICAgICAgcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDEgLyogQ3JlYXRlICovLCBjcmVhdGVTdGF0ZW1lbnRzKSxcbiAgICAgICAgcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKVxuICAgIF0sIElORkVSUkVEX1RZUEUsIG51bGwsIHZpZXdRdWVyeUZuTmFtZSk7XG59XG4vLyBSZXR1cm4gYSBob3N0IGJpbmRpbmcgZnVuY3Rpb24gb3IgbnVsbCBpZiBvbmUgaXMgbm90IG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RCaW5kaW5nc0Z1bmN0aW9uKGhvc3RCaW5kaW5nc01ldGFkYXRhLCB0eXBlU291cmNlU3BhbiwgYmluZGluZ1BhcnNlciwgY29uc3RhbnRQb29sLCBzZWxlY3RvciwgbmFtZSwgZGVmaW5pdGlvbk1hcCkge1xuICAgIHZhciBiaW5kaW5nQ29udGV4dCA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSk7XG4gICAgdmFyIHN0eWxlQnVpbGRlciA9IG5ldyBTdHlsaW5nQnVpbGRlcihiaW5kaW5nQ29udGV4dCk7XG4gICAgdmFyIF9hID0gaG9zdEJpbmRpbmdzTWV0YWRhdGEuc3BlY2lhbEF0dHJpYnV0ZXMsIHN0eWxlQXR0ciA9IF9hLnN0eWxlQXR0ciwgY2xhc3NBdHRyID0gX2EuY2xhc3NBdHRyO1xuICAgIGlmIChzdHlsZUF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJTdHlsZUF0dHIoc3R5bGVBdHRyKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzQXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cihjbGFzc0F0dHIpO1xuICAgIH1cbiAgICB2YXIgY3JlYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIHZhciB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgdmFyIGhvc3RCaW5kaW5nU291cmNlU3BhbiA9IHR5cGVTb3VyY2VTcGFuO1xuICAgIHZhciBkaXJlY3RpdmVTdW1tYXJ5ID0gbWV0YWRhdGFBc1N1bW1hcnkoaG9zdEJpbmRpbmdzTWV0YWRhdGEpO1xuICAgIC8vIENhbGN1bGF0ZSBob3N0IGV2ZW50IGJpbmRpbmdzXG4gICAgdmFyIGV2ZW50QmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlU3VtbWFyeSwgaG9zdEJpbmRpbmdTb3VyY2VTcGFuKTtcbiAgICBpZiAoZXZlbnRCaW5kaW5ncyAmJiBldmVudEJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gY3JlYXRlSG9zdExpc3RlbmVycyhldmVudEJpbmRpbmdzLCBuYW1lKTtcbiAgICAgICAgY3JlYXRlU3RhdGVtZW50cy5wdXNoLmFwcGx5KGNyZWF0ZVN0YXRlbWVudHMsIF9fc3ByZWFkKGxpc3RlbmVycykpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZ3NcbiAgICB2YXIgYmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kSG9zdFByb3BlcnRpZXMoZGlyZWN0aXZlU3VtbWFyeSwgaG9zdEJpbmRpbmdTb3VyY2VTcGFuKTtcbiAgICB2YXIgYWxsT3RoZXJCaW5kaW5ncyA9IFtdO1xuICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSB0b3RhbCBhbW91bnQgb2YgYmluZGluZyBzbG90cyByZXF1aXJlZCBieVxuICAgIC8vIGFsbCB0aGUgaW5zdHJ1Y3Rpb25zIHRvZ2V0aGVyIGJlZm9yZSBhbnkgdmFsdWUgY29udmVyc2lvbnMgaGFwcGVuLlxuICAgIC8vIFZhbHVlIGNvbnZlcnNpb25zIG1heSByZXF1aXJlIGFkZGl0aW9uYWwgc2xvdHMgZm9yIGludGVycG9sYXRpb24gYW5kXG4gICAgLy8gYmluZGluZ3Mgd2l0aCBwaXBlcy4gVGhlc2UgY2FsY3VsYXRlcyBoYXBwZW4gYWZ0ZXIgdGhpcyBibG9jay5cbiAgICB2YXIgdG90YWxIb3N0VmFyc0NvdW50ID0gMDtcbiAgICBiaW5kaW5ncyAmJiBiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lO1xuICAgICAgICB2YXIgc3R5bGluZ0lucHV0V2FzU2V0ID0gc3R5bGVCdWlsZGVyLnJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBiaW5kaW5nLmV4cHJlc3Npb24sIGJpbmRpbmcuc291cmNlU3Bhbik7XG4gICAgICAgIGlmIChzdHlsaW5nSW5wdXRXYXNTZXQpIHtcbiAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCArPSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsT3RoZXJCaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAgICAgICAgICAgdG90YWxIb3N0VmFyc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgdmFsdWVDb252ZXJ0ZXI7XG4gICAgdmFyIGdldFZhbHVlQ29udmVydGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgICAgICB2YXIgaG9zdFZhcnNDb3VudEZuID0gZnVuY3Rpb24gKG51bVNsb3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsVmFyc0NvdW50ID0gdG90YWxIb3N0VmFyc0NvdW50O1xuICAgICAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCArPSBudW1TbG90cztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxWYXJzQ291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVDb252ZXJ0ZXIgPSBuZXcgVmFsdWVDb252ZXJ0ZXIoY29uc3RhbnRQb29sLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcignVW5leHBlY3RlZCBub2RlJyk7IH0sIC8vIG5ldyBub2RlcyBhcmUgaWxsZWdhbCBoZXJlXG4gICAgICAgICAgICBob3N0VmFyc0NvdW50Rm4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKCdVbmV4cGVjdGVkIHBpcGUnKTsgfSk7IC8vIHBpcGVzIGFyZSBpbGxlZ2FsIGhlcmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVDb252ZXJ0ZXI7XG4gICAgfTtcbiAgICB2YXIgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IFtdO1xuICAgIHZhciBzeW50aGV0aWNIb3N0QmluZGluZ3MgPSBbXTtcbiAgICBhbGxPdGhlckJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSBsaXRlcmFsIGFycmF5cyBhbmQgbGl0ZXJhbCBvYmplY3RzXG4gICAgICAgIHZhciB2YWx1ZSA9IGJpbmRpbmcuZXhwcmVzc2lvbi52aXNpdChnZXRWYWx1ZUNvbnZlcnRlcigpKTtcbiAgICAgICAgdmFyIGJpbmRpbmdFeHByID0gYmluZGluZ0ZuKGJpbmRpbmdDb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHZhciBfYSA9IGdldEJpbmRpbmdOYW1lQW5kSW5zdHJ1Y3Rpb24oYmluZGluZyksIGJpbmRpbmdOYW1lID0gX2EuYmluZGluZ05hbWUsIGluc3RydWN0aW9uID0gX2EuaW5zdHJ1Y3Rpb24sIGlzQXR0cmlidXRlID0gX2EuaXNBdHRyaWJ1dGU7XG4gICAgICAgIHZhciBzZWN1cml0eUNvbnRleHRzID0gYmluZGluZ1BhcnNlci5jYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHNlbGVjdG9yLCBiaW5kaW5nTmFtZSwgaXNBdHRyaWJ1dGUpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiBjb250ZXh0ICE9PSBTZWN1cml0eUNvbnRleHQuTk9ORTsgfSk7XG4gICAgICAgIHZhciBzYW5pdGl6ZXJGbiA9IG51bGw7XG4gICAgICAgIGlmIChzZWN1cml0eUNvbnRleHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNlY3VyaXR5Q29udGV4dHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cy5pbmRleE9mKFNlY3VyaXR5Q29udGV4dC5VUkwpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzLmluZGV4T2YoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc29tZSBVUkwgYXR0cmlidXRlcyAoc3VjaCBhcyBcInNyY1wiIGFuZCBcImhyZWZcIikgdGhhdCBtYXkgYmUgYSBwYXJ0XG4gICAgICAgICAgICAgICAgLy8gb2YgZGlmZmVyZW50IHNlY3VyaXR5IGNvbnRleHRzLiBJbiB0aGlzIGNhc2Ugd2UgdXNlIHNwZWNpYWwgc2FudGl0aXphdGlvbiBmdW5jdGlvbiBhbmRcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgdGhlIGFjdHVhbCBzYW5pdGl6ZXIgYXQgcnVudGltZSBiYXNlZCBvbiBhIHRhZyBuYW1lIHRoYXQgaXMgcHJvdmlkZWQgd2hpbGVcbiAgICAgICAgICAgICAgICAvLyBpbnZva2luZyBzYW5pdGl6YXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgc2FuaXRpemVyRm4gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVVcmxPclJlc291cmNlVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbml0aXplckZuID0gcmVzb2x2ZVNhbml0aXphdGlvbkZuKHNlY3VyaXR5Q29udGV4dHNbMF0sIGlzQXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25QYXJhbXMgPSBbbGl0ZXJhbChiaW5kaW5nTmFtZSksIGJpbmRpbmdFeHByLmN1cnJWYWxFeHByXTtcbiAgICAgICAgaWYgKHNhbml0aXplckZuKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvblBhcmFtcy5wdXNoKHNhbml0aXplckZuKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2guYXBwbHkodXBkYXRlU3RhdGVtZW50cywgX19zcHJlYWQoYmluZGluZ0V4cHIuc3RtdHMpKTtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uID09PSBJZGVudGlmaWVycyQxLmhvc3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZUJpbmRpbmdzLnB1c2goaW5zdHJ1Y3Rpb25QYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RydWN0aW9uID09PSBJZGVudGlmaWVycyQxLnVwZGF0ZVN5bnRoZXRpY0hvc3RCaW5kaW5nKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNIb3N0QmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihpbnN0cnVjdGlvbikuY2FsbEZuKGluc3RydWN0aW9uUGFyYW1zKS50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocHJvcGVydHlCaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChjaGFpbmVkSW5zdHJ1Y3Rpb24oSWRlbnRpZmllcnMkMS5ob3N0UHJvcGVydHksIHByb3BlcnR5QmluZGluZ3MpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLmF0dHJpYnV0ZSwgYXR0cmlidXRlQmluZGluZ3MpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgaWYgKHN5bnRoZXRpY0hvc3RCaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChjaGFpbmVkSW5zdHJ1Y3Rpb24oSWRlbnRpZmllcnMkMS51cGRhdGVTeW50aGV0aWNIb3N0QmluZGluZywgc3ludGhldGljSG9zdEJpbmRpbmdzKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIC8vIHNpbmNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBkaXJlY3RpdmVzL2NvbXBvbmVudHMgYW5kIGJvdGggaGF2ZSBob3N0QmluZGluZ1xuICAgIC8vIGZ1bmN0aW9ucywgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIHNwZWNpYWwgaG9zdEF0dHJzIGluc3RydWN0aW9uIHRoYXQgZGVhbHNcbiAgICAvLyB3aXRoIGJvdGggdGhlIGFzc2lnbm1lbnQgb2Ygc3R5bGluZyBhcyB3ZWxsIGFzIHN0YXRpYyBhdHRyaWJ1dGVzIHRvIHRoZSBob3N0XG4gICAgLy8gZWxlbWVudC4gVGhlIGluc3RydWN0aW9uIGJlbG93IHdpbGwgaW5zdHJ1Y3QgYWxsIGluaXRpYWwgc3R5bGluZyAoc3R5bGluZ1xuICAgIC8vIHRoYXQgaXMgaW5zaWRlIG9mIGEgaG9zdCBiaW5kaW5nIHdpdGhpbiBhIGRpcmVjdGl2ZS9jb21wb25lbnQpIHRvIGJlIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIGhvc3QgZWxlbWVudCBhbG9uZ3NpZGUgYW55IG9mIHRoZSBwcm92aWRlZCBob3N0IGF0dHJpYnV0ZXMgdGhhdCB3ZXJlXG4gICAgLy8gY29sbGVjdGVkIGVhcmxpZXIuXG4gICAgdmFyIGhvc3RBdHRycyA9IGNvbnZlcnRBdHRyaWJ1dGVzVG9FeHByZXNzaW9ucyhob3N0QmluZGluZ3NNZXRhZGF0YS5hdHRyaWJ1dGVzKTtcbiAgICBzdHlsZUJ1aWxkZXIuYXNzaWduSG9zdEF0dHJzKGhvc3RBdHRycywgZGVmaW5pdGlvbk1hcCk7XG4gICAgaWYgKHN0eWxlQnVpbGRlci5oYXNCaW5kaW5ncykge1xuICAgICAgICAvLyBmaW5hbGx5IGVhY2ggYmluZGluZyB0aGF0IHdhcyByZWdpc3RlcmVkIGluIHRoZSBzdGF0ZW1lbnQgYWJvdmUgd2lsbCBuZWVkIHRvIGJlIGFkZGVkIHRvXG4gICAgICAgIC8vIHRoZSB1cGRhdGUgYmxvY2sgb2YgYSBjb21wb25lbnQvZGlyZWN0aXZlIHRlbXBsYXRlRm4vaG9zdEJpbmRpbmdzRm4gc28gdGhhdCB0aGUgYmluZGluZ3NcbiAgICAgICAgLy8gYXJlIGV2YWx1YXRlZCBhbmQgdXBkYXRlZCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgIHN0eWxlQnVpbGRlci5idWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKGdldFZhbHVlQ29udmVydGVyKCkpLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsc18xID0gW107XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY2FsbHMuZm9yRWFjaChmdW5jdGlvbiAoY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzdWJ0cmFjdCBhIHZhbHVlIG9mIGAxYCBoZXJlIGJlY2F1c2UgdGhlIGJpbmRpbmcgc2xvdCB3YXMgYWxyZWFkeSBhbGxvY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgdGhlIHRvcCBvZiB0aGlzIG1ldGhvZCB3aGVuIGFsbCB0aGUgaW5wdXQgYmluZGluZ3Mgd2VyZSBjb3VudGVkLlxuICAgICAgICAgICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNhbGwuYWxsb2NhdGVCaW5kaW5nU2xvdHMgLSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVELCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbHNfMS5wdXNoKGNvbnZlcnRTdHlsaW5nQ2FsbChjYWxsLCBiaW5kaW5nQ29udGV4dCwgYmluZGluZ0ZuKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihpbnN0cnVjdGlvbi5yZWZlcmVuY2UsIGNhbGxzXzEpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b3RhbEhvc3RWYXJzQ291bnQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2hvc3RWYXJzJywgbGl0ZXJhbCh0b3RhbEhvc3RWYXJzQ291bnQpKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCB8fCB1cGRhdGVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGhvc3RCaW5kaW5nc0ZuTmFtZSA9IG5hbWUgPyBuYW1lICsgXCJfSG9zdEJpbmRpbmdzXCIgOiBudWxsO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBpZiAoY3JlYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyRmxhZ0NoZWNrSWZTdG10KDEgLyogQ3JlYXRlICovLCBjcmVhdGVTdGF0ZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIFVwZGF0ZSAqLywgdXBkYXRlU3RhdGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbihbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBzdGF0ZW1lbnRzLCBJTkZFUlJFRF9UWVBFLCBudWxsLCBob3N0QmluZGluZ3NGbk5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJpbmRpbmdGbihpbXBsaWNpdCwgdmFsdWUpIHtcbiAgICByZXR1cm4gY29udmVydFByb3BlcnR5QmluZGluZyhudWxsLCBpbXBsaWNpdCwgdmFsdWUsICdiJywgQmluZGluZ0Zvcm0uVHJ5U2ltcGxlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJyk7IH0pO1xufVxuZnVuY3Rpb24gY29udmVydFN0eWxpbmdDYWxsKGNhbGwsIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pIHtcbiAgICByZXR1cm4gY2FsbC5wYXJhbXMoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBiaW5kaW5nRm4oYmluZGluZ0NvbnRleHQsIHZhbHVlKS5jdXJyVmFsRXhwcjsgfSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nTmFtZUFuZEluc3RydWN0aW9uKGJpbmRpbmcpIHtcbiAgICB2YXIgYmluZGluZ05hbWUgPSBiaW5kaW5nLm5hbWU7XG4gICAgdmFyIGluc3RydWN0aW9uO1xuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFuIGF0dHIgYmluZGluZyBvciBhIHByb3BlcnR5IGJpbmRpbmdcbiAgICB2YXIgYXR0ck1hdGNoZXMgPSBiaW5kaW5nTmFtZS5tYXRjaChBVFRSX1JFR0VYKTtcbiAgICBpZiAoYXR0ck1hdGNoZXMpIHtcbiAgICAgICAgYmluZGluZ05hbWUgPSBhdHRyTWF0Y2hlc1sxXTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaW5kaW5nLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBiaW5kaW5nTmFtZSA9IHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUoYmluZGluZ05hbWUpO1xuICAgICAgICAgICAgLy8gaG9zdCBiaW5kaW5ncyB0aGF0IGhhdmUgYSBzeW50aGV0aWMgcHJvcGVydHkgKGUuZy4gQGZvbykgc2hvdWxkIGFsd2F5cyBiZSByZW5kZXJlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNvbXBvbmVudCBhbmQgbm90IHRoZSBwYXJlbnQuIFRoZXJlZm9yZSB0aGVyZSBpcyBhIHNwZWNpYWxcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHkgaW5zdHJ1Y3Rpb24gYXZhaWxhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IElkZW50aWZpZXJzJDEudXBkYXRlU3ludGhldGljSG9zdEJpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IElkZW50aWZpZXJzJDEuaG9zdFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGJpbmRpbmdOYW1lOiBiaW5kaW5nTmFtZSwgaW5zdHJ1Y3Rpb246IGluc3RydWN0aW9uLCBpc0F0dHJpYnV0ZTogISFhdHRyTWF0Y2hlcyB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdExpc3RlbmVycyhldmVudEJpbmRpbmdzLCBuYW1lKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgIHZhciBzeW50aGV0aWNMaXN0ZW5lcnMgPSBbXTtcbiAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZXZlbnRCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgIHZhciBiaW5kaW5nTmFtZSA9IGJpbmRpbmcubmFtZSAmJiBzYW5pdGl6ZUlkZW50aWZpZXIoYmluZGluZy5uYW1lKTtcbiAgICAgICAgdmFyIGJpbmRpbmdGbk5hbWUgPSBiaW5kaW5nLnR5cGUgPT09IDEgLyogQW5pbWF0aW9uICovID9cbiAgICAgICAgICAgIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lckZ1bmN0aW9uTmFtZShiaW5kaW5nTmFtZSwgYmluZGluZy50YXJnZXRPclBoYXNlKSA6XG4gICAgICAgICAgICBiaW5kaW5nTmFtZTtcbiAgICAgICAgdmFyIGhhbmRsZXJOYW1lID0gbmFtZSAmJiBiaW5kaW5nTmFtZSA/IG5hbWUgKyBcIl9cIiArIGJpbmRpbmdGbk5hbWUgKyBcIl9Ib3N0QmluZGluZ0hhbmRsZXJcIiA6IG51bGw7XG4gICAgICAgIHZhciBwYXJhbXMgPSBwcmVwYXJlRXZlbnRMaXN0ZW5lclBhcmFtZXRlcnMoQm91bmRFdmVudC5mcm9tUGFyc2VkRXZlbnQoYmluZGluZyksIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGJpbmRpbmcudHlwZSA9PSAxIC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgICAgICAgc3ludGhldGljTGlzdGVuZXJzLnB1c2gocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3ludGhldGljTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY2hhaW5lZEluc3RydWN0aW9uKElkZW50aWZpZXJzJDEuY29tcG9uZW50SG9zdFN5bnRoZXRpY0xpc3RlbmVyLCBzeW50aGV0aWNMaXN0ZW5lcnMpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLmxpc3RlbmVyLCBsaXN0ZW5lcnMpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbn1cbmZ1bmN0aW9uIG1ldGFkYXRhQXNTdW1tYXJ5KG1ldGEpIHtcbiAgICAvLyBjbGFuZy1mb3JtYXQgb2ZmXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IHRoZSBCaW5kaW5nUGFyc2VyLCB3aGljaCBvbmx5IGRlYWxzIHdpdGggbGlzdGVuZXJzIGFuZCBwcm9wZXJ0aWVzLiBUaGVyZSdzIG5vXG4gICAgICAgIC8vIG5lZWQgdG8gcGFzcyBhdHRyaWJ1dGVzIHRvIGl0LlxuICAgICAgICBob3N0QXR0cmlidXRlczoge30sXG4gICAgICAgIGhvc3RMaXN0ZW5lcnM6IG1ldGEubGlzdGVuZXJzLFxuICAgICAgICBob3N0UHJvcGVydGllczogbWV0YS5wcm9wZXJ0aWVzLFxuICAgIH07XG4gICAgLy8gY2xhbmctZm9ybWF0IG9uXG59XG5mdW5jdGlvbiB0eXBlTWFwVG9FeHByZXNzaW9uTWFwKG1hcCwgb3V0cHV0Q3R4KSB7XG4gICAgLy8gQ29udmVydCBlYWNoIG1hcCBlbnRyeSBpbnRvIGFub3RoZXIgZW50cnkgd2hlcmUgdGhlIHZhbHVlIGlzIGFuIGV4cHJlc3Npb24gaW1wb3J0aW5nIHRoZSB0eXBlLlxuICAgIHZhciBlbnRyaWVzID0gQXJyYXkuZnJvbShtYXApLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHR5cGUgPSBfYlsxXTtcbiAgICAgICAgcmV0dXJuIFtrZXksIG91dHB1dEN0eC5pbXBvcnRFeHByKHR5cGUpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1hcChlbnRyaWVzKTtcbn1cbnZhciBIT1NUX1JFR19FWFAkMSA9IC9eKD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpJC87XG5mdW5jdGlvbiBwYXJzZUhvc3RCaW5kaW5ncyhob3N0KSB7XG4gICAgdmFyIGVfNCwgX2E7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgbGlzdGVuZXJzID0ge307XG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICB2YXIgc3BlY2lhbEF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGhvc3QpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBrZXkubWF0Y2goSE9TVF9SRUdfRVhQJDEpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzcyBiaW5kaW5nIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEF0dHJpYnV0ZXMuY2xhc3NBdHRyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3R5bGUgYmluZGluZyBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpYWxBdHRyaWJ1dGVzLnN0eWxlQXR0ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGxpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1sxIC8qIEJpbmRpbmcgKi9dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5IGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN5bnRoZXRpYyBwcm9wZXJ0aWVzICh0aGUgb25lcyB0aGF0IGhhdmUgYSBgQGAgYXMgYSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgLy8gYXJlIHN0aWxsIHRyZWF0ZWQgdGhlIHNhbWUgYXMgcmVndWxhciBwcm9wZXJ0aWVzLiBUaGVyZWZvcmVcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBpbiBzdG9yaW5nIHRoZW0gaW4gYSBzZXBhcmF0ZSBtYXAuXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1ttYXRjaGVzWzEgLyogQmluZGluZyAqL11dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzIgLyogRXZlbnQgKi9dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1ttYXRjaGVzWzIgLyogRXZlbnQgKi9dXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4geyBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgcHJvcGVydGllczogcHJvcGVydGllcywgc3BlY2lhbEF0dHJpYnV0ZXM6IHNwZWNpYWxBdHRyaWJ1dGVzIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGhvc3QgYmluZGluZ3MgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgZXJyb3JzIChpZiBhbnkpLiBFbXB0eSBhcnJheSBpbmRpY2F0ZXMgdGhhdCBhXG4gKiBnaXZlbiBzZXQgb2YgaG9zdCBiaW5kaW5ncyBoYXMgbm8gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSBiaW5kaW5ncyBzZXQgb2YgaG9zdCBiaW5kaW5ncyB0byB2ZXJpZnkuXG4gKiBAcGFyYW0gc291cmNlU3BhbiBzb3VyY2Ugc3BhbiB3aGVyZSBob3N0IGJpbmRpbmdzIHdlcmUgZGVmaW5lZC5cbiAqIEByZXR1cm5zIGFycmF5IG9mIGVycm9ycyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBzZXQgb2YgaG9zdCBiaW5kaW5ncy5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5SG9zdEJpbmRpbmdzKGJpbmRpbmdzLCBzb3VyY2VTcGFuKSB7XG4gICAgdmFyIHN1bW1hcnkgPSBtZXRhZGF0YUFzU3VtbWFyeShiaW5kaW5ncyk7XG4gICAgLy8gVE9ETzogYWJzdHJhY3Qgb3V0IGhvc3QgYmluZGluZ3MgdmVyaWZpY2F0aW9uIGxvZ2ljIGFuZCB1c2UgaXQgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIGV2ZW50cyBhbmQgcHJvcGVydGllcyBBU1RzIHRvIGRldGVjdCBlcnJvcnMgKEZXLTk5NilcbiAgICB2YXIgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKCk7XG4gICAgYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzKHN1bW1hcnksIHNvdXJjZVNwYW4pO1xuICAgIGJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhzdW1tYXJ5LCBzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gYmluZGluZ1BhcnNlci5lcnJvcnM7XG59XG5mdW5jdGlvbiBjb21waWxlU3R5bGVzKHN0eWxlcywgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgIHZhciBzaGFkb3dDc3MgPSBuZXcgU2hhZG93Q3NzKCk7XG4gICAgcmV0dXJuIHN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBzaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgcmV0cmlldmluZyBkb2N1bWVudHMgYnkgVVJMIHRoYXQgdGhlIGNvbXBpbGVyIHVzZXNcbiAqIHRvIGxvYWQgdGVtcGxhdGVzLlxuICovXG52YXIgUmVzb3VyY2VMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgfVxuICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZUxvYWRlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDb21waWxlckZhY2FkZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZXJGYWNhZGVJbXBsKGppdEV2YWx1YXRvcikge1xuICAgICAgICBpZiAoaml0RXZhbHVhdG9yID09PSB2b2lkIDApIHsgaml0RXZhbHVhdG9yID0gbmV3IEppdEV2YWx1YXRvcigpOyB9XG4gICAgICAgIHRoaXMuaml0RXZhbHVhdG9yID0gaml0RXZhbHVhdG9yO1xuICAgICAgICB0aGlzLlIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZSA9IFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZTtcbiAgICAgICAgdGhpcy5SM0ZhY3RvcnlUYXJnZXQgPSBSM0ZhY3RvcnlUYXJnZXQ7XG4gICAgICAgIHRoaXMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgfVxuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZVBpcGUgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZSQxKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogZmFjYWRlLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgZGVwczogY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhQXJyYXkoZmFjYWRlLmRlcHMpLFxuICAgICAgICAgICAgcGlwZU5hbWU6IGZhY2FkZS5waXBlTmFtZSxcbiAgICAgICAgICAgIHB1cmU6IGZhY2FkZS5wdXJlLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfTtcbiAgICBDb21waWxlckZhY2FkZUltcGwucHJvdG90eXBlLmNvbXBpbGVJbmplY3RhYmxlID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICB2YXIgX2EgPSBjb21waWxlSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UkMShmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IGZhY2FkZS50eXBlQXJndW1lbnRDb3VudCxcbiAgICAgICAgICAgIHByb3ZpZGVkSW46IGNvbXB1dGVQcm92aWRlZEluKGZhY2FkZS5wcm92aWRlZEluKSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiB3cmFwRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9DTEFTUyksXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiB3cmFwRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9GQUNUT1JZKSxcbiAgICAgICAgICAgIHVzZVZhbHVlOiB3cmFwRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9WQUxVRSksXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogd3JhcEV4cHJlc3Npb24oZmFjYWRlLCBVU0VfRVhJU1RJTkcpLFxuICAgICAgICAgICAgdXNlckRlcHM6IGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZS51c2VyRGVwcykgfHwgdW5kZWZpbmVkLFxuICAgICAgICB9KSwgZXhwcmVzc2lvbiA9IF9hLmV4cHJlc3Npb24sIHN0YXRlbWVudHMgPSBfYS5zdGF0ZW1lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jb21waWxlSW5qZWN0b3IgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogZmFjYWRlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlJDEoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGRlcHM6IGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZS5kZXBzKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbmV3IFdyYXBwZWROb2RlRXhwcihpKTsgfSksXG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXMgPSBjb21waWxlSW5qZWN0b3IobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHJlcy5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZU5nTW9kdWxlID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICB2YXIgbWV0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UkMShmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgYWRqYWNlbnRUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGJvb3RzdHJhcDogZmFjYWRlLmJvb3RzdHJhcC5tYXAod3JhcFJlZmVyZW5jZSQxKSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZmFjYWRlLmRlY2xhcmF0aW9ucy5tYXAod3JhcFJlZmVyZW5jZSQxKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcCh3cmFwUmVmZXJlbmNlJDEpLFxuICAgICAgICAgICAgZXhwb3J0czogZmFjYWRlLmV4cG9ydHMubWFwKHdyYXBSZWZlcmVuY2UkMSksXG4gICAgICAgICAgICBlbWl0SW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgY29udGFpbnNGb3J3YXJkRGVjbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2NoZW1hczogZmFjYWRlLnNjaGVtYXMgPyBmYWNhZGUuc2NoZW1hcy5tYXAod3JhcFJlZmVyZW5jZSQxKSA6IG51bGwsXG4gICAgICAgICAgICBpZDogZmFjYWRlLmlkID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuaWQpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGNvbXBpbGVOZ01vZHVsZShtZXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgW10pO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jb21waWxlRGlyZWN0aXZlID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICB2YXIgY29uc3RhbnRQb29sID0gbmV3IENvbnN0YW50UG9vbCgpO1xuICAgICAgICB2YXIgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKCk7XG4gICAgICAgIHZhciBtZXRhID0gY29udmVydERpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZmFjYWRlKTtcbiAgICAgICAgdmFyIHJlcyA9IGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgY29uc3RhbnRQb29sLnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICAvLyBUaGUgQ29uc3RhbnRQb29sIGlzIGEgcmVxdWlyZW1lbnQgb2YgdGhlIEpJVCdlci5cbiAgICAgICAgdmFyIGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBmYWNhZGUuaW50ZXJwb2xhdGlvbiA/XG4gICAgICAgICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShmYWNhZGUuaW50ZXJwb2xhdGlvbikgOlxuICAgICAgICAgICAgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgLy8gUGFyc2UgdGhlIHRlbXBsYXRlIGFuZCBjaGVjayBmb3IgZXJyb3JzLlxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGZhY2FkZS50ZW1wbGF0ZSwgc291cmNlTWFwVXJsLCB7IHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhY2FkZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzLCBpbnRlcnBvbGF0aW9uQ29uZmlnOiBpbnRlcnBvbGF0aW9uQ29uZmlnIH0pO1xuICAgICAgICBpZiAodGVtcGxhdGUuZXJyb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0ZW1wbGF0ZS5lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGVyci50b1N0cmluZygpOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGR1cmluZyBKSVQgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgZm9yIFwiICsgZmFjYWRlLm5hbWUgKyBcIjogXCIgKyBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBpbGUgdGhlIGNvbXBvbmVudCBtZXRhZGF0YSwgaW5jbHVkaW5nIHRlbXBsYXRlLCBpbnRvIGFuIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogaW1wbGVtZW50IGlucHV0cywgb3V0cHV0cywgcXVlcmllcywgZXRjLlxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmFjYWRlKSwgY29udmVydERpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZmFjYWRlKSksIHsgc2VsZWN0b3I6IGZhY2FkZS5zZWxlY3RvciB8fCB0aGlzLmVsZW1lbnRTY2hlbWFSZWdpc3RyeS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUoKSwgdGVtcGxhdGU6IHRlbXBsYXRlLCB3cmFwRGlyZWN0aXZlc0FuZFBpcGVzSW5DbG9zdXJlOiBmYWxzZSwgc3R5bGVzOiBfX3NwcmVhZChmYWNhZGUuc3R5bGVzLCB0ZW1wbGF0ZS5zdHlsZXMpLCBlbmNhcHN1bGF0aW9uOiBmYWNhZGUuZW5jYXBzdWxhdGlvbiwgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvbkNvbmZpZywgY2hhbmdlRGV0ZWN0aW9uOiBmYWNhZGUuY2hhbmdlRGV0ZWN0aW9uLCBhbmltYXRpb25zOiBmYWNhZGUuYW5pbWF0aW9ucyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuYW5pbWF0aW9ucykgOiBudWxsLCB2aWV3UHJvdmlkZXJzOiBmYWNhZGUudmlld1Byb3ZpZGVycyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudmlld1Byb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG51bGwsIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoOiAnJywgaTE4blVzZUV4dGVybmFsSWRzOiB0cnVlIH0pO1xuICAgICAgICB2YXIgcmVzID0gY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YShtZXRhZGF0YSwgY29uc3RhbnRQb29sLCBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnKSk7XG4gICAgICAgIHZhciBqaXRFeHByZXNzaW9uU291cmNlTWFwID0gXCJuZzovLy9cIiArIGZhY2FkZS5uYW1lICsgXCIuanNcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIGppdEV4cHJlc3Npb25Tb3VyY2VNYXAsIGNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIENvbXBpbGVyRmFjYWRlSW1wbC5wcm90b3R5cGUuY29tcGlsZUZhY3RvcnkgPSBmdW5jdGlvbiAoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSkge1xuICAgICAgICB2YXIgZmFjdG9yeVJlcyA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZSQxKG1ldGEudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS50eXBlKSxcbiAgICAgICAgICAgIHR5cGVBcmd1bWVudENvdW50OiBtZXRhLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgZGVwczogY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhQXJyYXkobWV0YS5kZXBzKSxcbiAgICAgICAgICAgIGluamVjdEZuOiBtZXRhLmluamVjdEZuID09PSAnZGlyZWN0aXZlSW5qZWN0JyA/IElkZW50aWZpZXJzLmRpcmVjdGl2ZUluamVjdCA6XG4gICAgICAgICAgICAgICAgSWRlbnRpZmllcnMuaW5qZWN0LFxuICAgICAgICAgICAgdGFyZ2V0OiBtZXRhLnRhcmdldCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24oZmFjdG9yeVJlcy5mYWN0b3J5LCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWN0b3J5UmVzLnN0YXRlbWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXJGYWNhZGVJbXBsLnByb3RvdHlwZS5jcmVhdGVQYXJzZVNvdXJjZVNwYW4gPSBmdW5jdGlvbiAoa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgICAgICByZXR1cm4gcjNKaXRUeXBlU291cmNlU3BhbihraW5kLCB0eXBlTmFtZSwgc291cmNlVXJsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEpJVCBjb21waWxlcyBhbiBleHByZXNzaW9uIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoYXQgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWYgdGhlIGRlZmluaXRpb24gd2hpY2ggd2lsbCBiZSBjb21waWxlZCBhbmQgZXhlY3V0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBwYXRjaFxuICAgICAqIEBwYXJhbSBjb250ZXh0IGFuIG9iamVjdCBtYXAgb2YgQGFuZ3VsYXIvY29yZSBzeW1ib2wgbmFtZXMgdG8gc3ltYm9scyB3aGljaCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAqIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBhIFVSTCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgbWFwIG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHByZVN0YXRlbWVudHMgYSBjb2xsZWN0aW9uIG9mIHN0YXRlbWVudHMgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBDb21waWxlckZhY2FkZUltcGwucHJvdG90eXBlLmppdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZGVmLCBjb250ZXh0LCBzb3VyY2VVcmwsIHByZVN0YXRlbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIENvbnN0YW50UG9vbCBtYXkgY29udGFpbiBTdGF0ZW1lbnRzIHdoaWNoIGRlY2xhcmUgdmFyaWFibGVzIHVzZWQgaW4gdGhlIGZpbmFsIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgaXRzIHN0YXRlbWVudHMgbmVlZCB0byBwcmVjZWRlIHRoZSBhY3R1YWwgSklUIG9wZXJhdGlvbi4gVGhlIGZpbmFsIHN0YXRlbWVudCBpcyBhXG4gICAgICAgIC8vIGRlY2xhcmF0aW9uIG9mICRkZWYgd2hpY2ggaXMgc2V0IHRvIHRoZSBleHByZXNzaW9uIGJlaW5nIGNvbXBpbGVkLlxuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IF9fc3ByZWFkKHByZVN0YXRlbWVudHMsIFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJlVmFyU3RtdCgnJGRlZicsIGRlZiwgdW5kZWZpbmVkLCBbU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSksXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5qaXRFdmFsdWF0b3IuZXZhbHVhdGVTdGF0ZW1lbnRzKHNvdXJjZVVybCwgc3RhdGVtZW50cywgbmV3IFIzSml0UmVmbGVjdG9yKGNvbnRleHQpLCAvKiBlbmFibGVTb3VyY2VNYXBzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzWyckZGVmJ107XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZXJGYWNhZGVJbXBsO1xufSgpKTtcbnZhciBVU0VfQ0xBU1MgPSBPYmplY3Qua2V5cyh7IHVzZUNsYXNzOiBudWxsIH0pWzBdO1xudmFyIFVTRV9GQUNUT1JZID0gT2JqZWN0LmtleXMoeyB1c2VGYWN0b3J5OiBudWxsIH0pWzBdO1xudmFyIFVTRV9WQUxVRSA9IE9iamVjdC5rZXlzKHsgdXNlVmFsdWU6IG51bGwgfSlbMF07XG52YXIgVVNFX0VYSVNUSU5HID0gT2JqZWN0LmtleXMoeyB1c2VFeGlzdGluZzogbnVsbCB9KVswXTtcbnZhciB3cmFwUmVmZXJlbmNlJDEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgd3JhcHBlZCA9IG5ldyBXcmFwcGVkTm9kZUV4cHIodmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlOiB3cmFwcGVkLCB0eXBlOiB3cmFwcGVkIH07XG59O1xuZnVuY3Rpb24gY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKGZhY2FkZSkge1xuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmFjYWRlKSwgeyBwcmVkaWNhdGU6IEFycmF5LmlzQXJyYXkoZmFjYWRlLnByZWRpY2F0ZSkgPyBmYWNhZGUucHJlZGljYXRlIDpcbiAgICAgICAgICAgIG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnByZWRpY2F0ZSksIHJlYWQ6IGZhY2FkZS5yZWFkID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucmVhZCkgOiBudWxsLCBzdGF0aWM6IGZhY2FkZS5zdGF0aWMgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpIHtcbiAgICB2YXIgaW5wdXRzRnJvbU1ldGFkYXRhID0gcGFyc2VJbnB1dE91dHB1dHMoZmFjYWRlLmlucHV0cyB8fCBbXSk7XG4gICAgdmFyIG91dHB1dHNGcm9tTWV0YWRhdGEgPSBwYXJzZUlucHV0T3V0cHV0cyhmYWNhZGUub3V0cHV0cyB8fCBbXSk7XG4gICAgdmFyIHByb3BNZXRhZGF0YSA9IGZhY2FkZS5wcm9wTWV0YWRhdGE7XG4gICAgdmFyIGlucHV0c0Zyb21UeXBlID0ge307XG4gICAgdmFyIG91dHB1dHNGcm9tVHlwZSA9IHt9O1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChwcm9wTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGFbZmllbGRdLmZvckVhY2goZnVuY3Rpb24gKGFubikge1xuICAgICAgICAgICAgICAgIGlmIChpc0lucHV0KGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzRnJvbVR5cGVbZmllbGRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubi5iaW5kaW5nUHJvcGVydHlOYW1lID8gW2Fubi5iaW5kaW5nUHJvcGVydHlOYW1lLCBmaWVsZF0gOiBmaWVsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPdXRwdXQoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzRnJvbVR5cGVbZmllbGRdID0gYW5uLmJpbmRpbmdQcm9wZXJ0eU5hbWUgfHwgZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGZpZWxkIGluIHByb3BNZXRhZGF0YSkge1xuICAgICAgICBfbG9vcF8xKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBmYWNhZGUpLCB7IHR5cGVTb3VyY2VTcGFuOiBmYWNhZGUudHlwZVNvdXJjZVNwYW4sIHR5cGU6IHdyYXBSZWZlcmVuY2UkMShmYWNhZGUudHlwZSksIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksIGRlcHM6IGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZS5kZXBzKSwgaG9zdDogZXh0cmFjdEhvc3RCaW5kaW5ncyhmYWNhZGUucHJvcE1ldGFkYXRhLCBmYWNhZGUudHlwZVNvdXJjZVNwYW4sIGZhY2FkZS5ob3N0KSwgaW5wdXRzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5wdXRzRnJvbU1ldGFkYXRhKSwgaW5wdXRzRnJvbVR5cGUpLCBvdXRwdXRzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3V0cHV0c0Zyb21NZXRhZGF0YSksIG91dHB1dHNGcm9tVHlwZSksIHF1ZXJpZXM6IGZhY2FkZS5xdWVyaWVzLm1hcChjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEpLCBwcm92aWRlcnM6IGZhY2FkZS5wcm92aWRlcnMgIT0gbnVsbCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnByb3ZpZGVycykgOiBudWxsLCB2aWV3UXVlcmllczogZmFjYWRlLnZpZXdRdWVyaWVzLm1hcChjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEpLCBmdWxsSW5oZXJpdGFuY2U6IGZhbHNlIH0pO1xufVxuZnVuY3Rpb24gd3JhcEV4cHJlc3Npb24ob2JqLCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JhcHBlZE5vZGVFeHByKG9ialtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlUHJvdmlkZWRJbihwcm92aWRlZEluKSB7XG4gICAgaWYgKHByb3ZpZGVkSW4gPT0gbnVsbCB8fCB0eXBlb2YgcHJvdmlkZWRJbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcihwcm92aWRlZEluKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JhcHBlZE5vZGVFeHByKHByb3ZpZGVkSW4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YShmYWNhZGUpIHtcbiAgICB2YXIgdG9rZW5FeHByO1xuICAgIGlmIChmYWNhZGUudG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgdG9rZW5FeHByID0gbmV3IExpdGVyYWxFeHByKG51bGwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmYWNhZGUucmVzb2x2ZWQgPT09IFIzUmVzb2x2ZWREZXBlbmRlbmN5VHlwZS5BdHRyaWJ1dGUpIHtcbiAgICAgICAgdG9rZW5FeHByID0gbmV3IExpdGVyYWxFeHByKGZhY2FkZS50b2tlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0b2tlbkV4cHIgPSBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50b2tlbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiB0b2tlbkV4cHIsXG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgcmVzb2x2ZWQ6IGZhY2FkZS5yZXNvbHZlZCxcbiAgICAgICAgaG9zdDogZmFjYWRlLmhvc3QsXG4gICAgICAgIG9wdGlvbmFsOiBmYWNhZGUub3B0aW9uYWwsXG4gICAgICAgIHNlbGY6IGZhY2FkZS5zZWxmLFxuICAgICAgICBza2lwU2VsZjogZmFjYWRlLnNraXBTZWxmLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShmYWNhZGVzKSB7XG4gICAgcmV0dXJuIGZhY2FkZXMgPT0gbnVsbCA/IG51bGwgOiBmYWNhZGVzLm1hcChjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEhvc3RCaW5kaW5ncyhwcm9wTWV0YWRhdGEsIHNvdXJjZVNwYW4sIGhvc3QpIHtcbiAgICAvLyBGaXJzdCBwYXJzZSB0aGUgZGVjbGFyYXRpb25zIGZyb20gdGhlIG1ldGFkYXRhLlxuICAgIHZhciBiaW5kaW5ncyA9IHBhcnNlSG9zdEJpbmRpbmdzKGhvc3QgfHwge30pO1xuICAgIC8vIEFmdGVyIHRoYXQgY2hlY2sgaG9zdCBiaW5kaW5ncyBmb3IgZXJyb3JzXG4gICAgdmFyIGVycm9ycyA9IHZlcmlmeUhvc3RCaW5kaW5ncyhiaW5kaW5ncywgc291cmNlU3Bhbik7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5tc2c7IH0pLmpvaW4oJ1xcbicpKTtcbiAgICB9XG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKHByb3BNZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YVtmaWVsZF0uZm9yRWFjaChmdW5jdGlvbiAoYW5uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSG9zdEJpbmRpbmcoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncy5wcm9wZXJ0aWVzW2Fubi5ob3N0UHJvcGVydHlOYW1lIHx8IGZpZWxkXSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0hvc3RMaXN0ZW5lcihhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLmxpc3RlbmVyc1thbm4uZXZlbnROYW1lIHx8IGZpZWxkXSA9IGZpZWxkICsgXCIoXCIgKyAoYW5uLmFyZ3MgfHwgW10pLmpvaW4oJywnKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBOZXh0LCBsb29wIG92ZXIgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCwgbG9va2luZyBmb3IgQEhvc3RCaW5kaW5nIGFuZCBASG9zdExpc3RlbmVyLlxuICAgIGZvciAodmFyIGZpZWxkIGluIHByb3BNZXRhZGF0YSkge1xuICAgICAgICBfbG9vcF8yKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdzO1xufVxuZnVuY3Rpb24gaXNIb3N0QmluZGluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ0hvc3RCaW5kaW5nJztcbn1cbmZ1bmN0aW9uIGlzSG9zdExpc3RlbmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnSG9zdExpc3RlbmVyJztcbn1cbmZ1bmN0aW9uIGlzSW5wdXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdJbnB1dCc7XG59XG5mdW5jdGlvbiBpc091dHB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ091dHB1dCc7XG59XG5mdW5jdGlvbiBwYXJzZUlucHV0T3V0cHV0cyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAobWFwLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodmFsdWUuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHBpZWNlKSB7IHJldHVybiBwaWVjZS50cmltKCk7IH0pLCAyKSwgZmllbGQgPSBfYVswXSwgcHJvcGVydHkgPSBfYVsxXTtcbiAgICAgICAgbWFwW2ZpZWxkXSA9IHByb3BlcnR5IHx8IGZpZWxkO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHB1Ymxpc2hGYWNhZGUoZ2xvYmFsKSB7XG4gICAgdmFyIG5nID0gZ2xvYmFsLm5nIHx8IChnbG9iYWwubmcgPSB7fSk7XG4gICAgbmcuybVjb21waWxlckZhY2FkZSA9IG5ldyBDb21waWxlckZhY2FkZUltcGwoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFZFUlNJT04kMSA9IG5ldyBWZXJzaW9uKCc5LjEuMTInKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENvbXBpbGVyQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyQ29uZmlnKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmRlZmF1bHRFbmNhcHN1bGF0aW9uLCBkZWZhdWx0RW5jYXBzdWxhdGlvbiA9IF9jID09PSB2b2lkIDAgPyBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA6IF9jLCBfZCA9IF9iLnVzZUppdCwgdXNlSml0ID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgX2UgPSBfYi5qaXREZXZNb2RlLCBqaXREZXZNb2RlID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIF9mID0gX2IubWlzc2luZ1RyYW5zbGF0aW9uLCBtaXNzaW5nVHJhbnNsYXRpb24gPSBfZiA9PT0gdm9pZCAwID8gbnVsbCA6IF9mLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzID0gX2IucHJlc2VydmVXaGl0ZXNwYWNlcywgc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyA9IF9iLnN0cmljdEluamVjdGlvblBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy51c2VKaXQgPSAhIXVzZUppdDtcbiAgICAgICAgdGhpcy5qaXREZXZNb2RlID0gISFqaXREZXZNb2RlO1xuICAgICAgICB0aGlzLm1pc3NpbmdUcmFuc2xhdGlvbiA9IG1pc3NpbmdUcmFuc2xhdGlvbjtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2VzID0gcHJlc2VydmVXaGl0ZXNwYWNlc0RlZmF1bHQobm9VbmRlZmluZWQocHJlc2VydmVXaGl0ZXNwYWNlcykpO1xuICAgICAgICB0aGlzLnN0cmljdEluamVjdGlvblBhcmFtZXRlcnMgPSBzdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzID09PSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZXJDb25maWc7XG59KCkpO1xuZnVuY3Rpb24gcHJlc2VydmVXaGl0ZXNwYWNlc0RlZmF1bHQocHJlc2VydmVXaGl0ZXNwYWNlc09wdGlvbiwgZGVmYXVsdFNldHRpbmcpIHtcbiAgICBpZiAoZGVmYXVsdFNldHRpbmcgPT09IHZvaWQgMCkgeyBkZWZhdWx0U2V0dGluZyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb24gPT09IG51bGwgPyBkZWZhdWx0U2V0dGluZyA6IHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBEaXJlY3RpdmVOb3JtYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZU5vcm1hbGl6ZXIoX3Jlc291cmNlTG9hZGVyLCBfdXJsUmVzb2x2ZXIsIF9odG1sUGFyc2VyLCBfY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyID0gX3Jlc291cmNlTG9hZGVyO1xuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gbm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUodGVtcGxhdGUudGVtcGxhdGVVcmwpO1xuICAgICAgICB0ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmRlbGV0ZShzdHlsZXNoZWV0Lm1vZHVsZVVybCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5nZXQodXJsKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3Jlc291cmNlTG9hZGVyLmdldCh1cmwpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5zZXQodXJsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHByZW5vcm1EYXRhLnRlbXBsYXRlKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIidcIiArIHN0cmluZ2lmeShwcmVub3JtRGF0YVxuICAgICAgICAgICAgICAgICAgICAuY29tcG9uZW50VHlwZSkgKyBcIicgY29tcG9uZW50IGNhbm5vdCBkZWZpbmUgYm90aCB0ZW1wbGF0ZSBhbmQgdGVtcGxhdGVVcmxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZW5vcm1EYXRhLnRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGhlIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCIgaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGVmaW5lZChwcmVub3JtRGF0YS50ZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlbm9ybURhdGEudGVtcGxhdGVVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUaGUgdGVtcGxhdGVVcmwgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyBzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIk5vIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHByZW5vcm1EYXRhLnByZXNlcnZlV2hpdGVzcGFjZXMpICYmXG4gICAgICAgICAgICB0eXBlb2YgcHJlbm9ybURhdGEucHJlc2VydmVXaGl0ZXNwYWNlcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIlRoZSBwcmVzZXJ2ZVdoaXRlc3BhY2VzIG9wdGlvbiBmb3IgY29tcG9uZW50IFwiICsgc3RyaW5naWZ5KHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUpICsgXCIgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRoaXMuX3ByZVBhcnNlVGVtcGxhdGUocHJlbm9ybURhdGEpLCBmdW5jdGlvbiAocHJlcGFyc2VkVGVtcGxhdGUpIHsgcmV0dXJuIF90aGlzLl9ub3JtYWxpemVUZW1wbGF0ZU1ldGFkYXRhKHByZW5vcm1EYXRhLCBwcmVwYXJzZWRUZW1wbGF0ZSk7IH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX3ByZVBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAocHJlbm9tRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGVtcGxhdGU7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVVybDtcbiAgICAgICAgaWYgKHByZW5vbURhdGEudGVtcGxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBwcmVub21EYXRhLnRlbXBsYXRlO1xuICAgICAgICAgICAgdGVtcGxhdGVVcmwgPSBwcmVub21EYXRhLm1vZHVsZVVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShwcmVub21EYXRhLm1vZHVsZVVybCwgcHJlbm9tRGF0YS50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMuX2ZldGNoKHRlbXBsYXRlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3luY0FzeW5jLnRoZW4odGVtcGxhdGUsIGZ1bmN0aW9uICh0ZW1wbGF0ZSkgeyByZXR1cm4gX3RoaXMuX3ByZXBhcnNlTG9hZGVkVGVtcGxhdGUocHJlbm9tRGF0YSwgdGVtcGxhdGUsIHRlbXBsYXRlVXJsKTsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fcHJlcGFyc2VMb2FkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgIHZhciBpc0lubGluZSA9ICEhcHJlbm9ybURhdGEudGVtcGxhdGU7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQ29uZmlnID0gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkocHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9IHRlbXBsYXRlU291cmNlVXJsKHsgcmVmZXJlbmNlOiBwcmVub3JtRGF0YS5uZ01vZHVsZVR5cGUgfSwgeyB0eXBlOiB7IHJlZmVyZW5jZTogcHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSB9IH0sIHsgaXNJbmxpbmU6IGlzSW5saW5lLCB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwgfSk7XG4gICAgICAgIHZhciByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnOiBpbnRlcnBvbGF0aW9uQ29uZmlnIH0pO1xuICAgICAgICBpZiAocm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSByb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMgPSB0aGlzLl9ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBwcmVub3JtRGF0YS5zdHlsZXMsIG1vZHVsZVVybDogcHJlbm9ybURhdGEubW9kdWxlVXJsIH0pKTtcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKTtcbiAgICAgICAgdmlzaXRBbGwkMSh2aXNpdG9yLCByb290Tm9kZXNBbmRFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlU3R5bGVzID0gdGhpcy5fbm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogdmlzaXRvci5zdHlsZXMsIHN0eWxlVXJsczogdmlzaXRvci5zdHlsZVVybHMsIG1vZHVsZVVybDogdGVtcGxhdGVBYnNVcmwgfSkpO1xuICAgICAgICB2YXIgc3R5bGVzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZXMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciBpbmxpbmVTdHlsZVVybHMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlVXJscy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVVcmxzKTtcbiAgICAgICAgdmFyIHN0eWxlVXJscyA9IHRoaXNcbiAgICAgICAgICAgIC5fbm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlVXJsczogcHJlbm9ybURhdGEuc3R5bGVVcmxzLCBtb2R1bGVVcmw6IHByZW5vcm1EYXRhLm1vZHVsZVVybCB9KSlcbiAgICAgICAgICAgIC5zdHlsZVVybHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwsXG4gICAgICAgICAgICBpc0lubGluZTogaXNJbmxpbmUsXG4gICAgICAgICAgICBodG1sQXN0OiByb290Tm9kZXNBbmRFcnJvcnMsXG4gICAgICAgICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgICAgICAgIGlubGluZVN0eWxlVXJsczogaW5saW5lU3R5bGVVcmxzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiBzdHlsZVVybHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHZpc2l0b3IubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX25vcm1hbGl6ZVRlbXBsYXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHByZXBhcnNlZFRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMocHJlcGFyc2VkVGVtcGxhdGUuc3R5bGVVcmxzLmNvbmNhdChwcmVwYXJzZWRUZW1wbGF0ZS5pbmxpbmVTdHlsZVVybHMpKSwgZnVuY3Rpb24gKGV4dGVybmFsU3R5bGVzaGVldHMpIHsgcmV0dXJuIF90aGlzLl9ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZU1ldGFkYXRhKHByZW5vcm1EYXRhLCBwcmVwYXJzZWRUZW1wbGF0ZSwgZXh0ZXJuYWxTdHlsZXNoZWV0cyk7IH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX25vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJlbm9ybURhdGEsIHByZXBhcnNlZFRlbXBsYXRlLCBzdHlsZXNoZWV0cykge1xuICAgICAgICAvLyBBbGdvcml0aG06XG4gICAgICAgIC8vIC0gcHJvZHVjZSBleGFjdGx5IDEgZW50cnkgcGVyIG9yaWdpbmFsIHN0eWxlVXJsIGluXG4gICAgICAgIC8vIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLmV4dGVybmFsU3R5bGVzaGVldHMgd2l0aCBhbGwgc3R5bGVzIGlubGluZWRcbiAgICAgICAgLy8gLSBpbmxpbmUgYWxsIHN0eWxlcyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IHRoZSB0ZW1wbGF0ZSBpbnRvIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLnN0eWxlcy5cbiAgICAgICAgLy8gUmVhc29uOiBiZSBhYmxlIHRvIGRldGVybWluZSBob3cgbWFueSBzdHlsZXNoZWV0cyB0aGVyZSBhcmUgZXZlbiB3aXRob3V0IGxvYWRpbmdcbiAgICAgICAgLy8gdGhlIHRlbXBsYXRlIG5vciB0aGUgc3R5bGVzaGVldHMsIHNvIHdlIGNhbiBjcmVhdGUgYSBzdHViIGZvciBUeXBlU2NyaXB0IGFsd2F5cyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIChhcyByZXNvdXJjZSBsb2FkaW5nIG1heSBiZSBhc3luYylcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0eWxlcyA9IF9fc3ByZWFkKHByZXBhcnNlZFRlbXBsYXRlLnN0eWxlcyk7XG4gICAgICAgIHRoaXMuX2lubGluZVN0eWxlcyhwcmVwYXJzZWRUZW1wbGF0ZS5pbmxpbmVTdHlsZVVybHMsIHN0eWxlc2hlZXRzLCBzdHlsZXMpO1xuICAgICAgICB2YXIgc3R5bGVVcmxzID0gcHJlcGFyc2VkVGVtcGxhdGUuc3R5bGVVcmxzO1xuICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IHN0eWxlVXJscy5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzaGVldCA9IHN0eWxlc2hlZXRzLmdldChzdHlsZVVybCk7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gX19zcHJlYWQoc3R5bGVzaGVldC5zdHlsZXMpO1xuICAgICAgICAgICAgX3RoaXMuX2lubGluZVN0eWxlcyhzdHlsZXNoZWV0LnN0eWxlVXJscywgc3R5bGVzaGVldHMsIHN0eWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBtb2R1bGVVcmw6IHN0eWxlVXJsLCBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gcHJlbm9ybURhdGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgJiYgc3R5bGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgc3R5bGVVcmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBlbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHByZXBhcnNlZFRlbXBsYXRlLnRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHByZXBhcnNlZFRlbXBsYXRlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgaHRtbEFzdDogcHJlcGFyc2VkVGVtcGxhdGUuaHRtbEFzdCxcbiAgICAgICAgICAgIHN0eWxlczogc3R5bGVzLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiBzdHlsZVVybHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHByZXBhcnNlZFRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHByZW5vcm1EYXRhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBwcmVub3JtRGF0YS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHByZXBhcnNlZFRlbXBsYXRlLmlzSW5saW5lLFxuICAgICAgICAgICAgZXh0ZXJuYWxTdHlsZXNoZWV0czogZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0KHByZW5vcm1EYXRhLnByZXNlcnZlV2hpdGVzcGFjZXMsIHRoaXMuX2NvbmZpZy5wcmVzZXJ2ZVdoaXRlc3BhY2VzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5faW5saW5lU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlVXJscywgc3R5bGVzaGVldHMsIHRhcmdldFN0eWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdHlsZVVybHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVVcmwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gc3R5bGVzaGVldHMuZ2V0KHN0eWxlVXJsKTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7IHJldHVybiB0YXJnZXRTdHlsZXMucHVzaChzdHlsZSk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2lubGluZVN0eWxlcyhzdHlsZXNoZWV0LnN0eWxlVXJscywgc3R5bGVzaGVldHMsIHRhcmdldFN0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChzdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsb2FkZWRTdHlsZXNoZWV0cyA9PT0gdm9pZCAwKSB7IGxvYWRlZFN0eWxlc2hlZXRzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbihTeW5jQXN5bmMuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiBTeW5jQXN5bmMudGhlbihfdGhpcy5fZmV0Y2goc3R5bGVVcmwpLCBmdW5jdGlvbiAobG9hZGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gX3RoaXMuX25vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IFtsb2FkZWRTdHlsZV0sIG1vZHVsZVVybDogc3R5bGVVcmwgfSkpO1xuICAgICAgICAgICAgbG9hZGVkU3R5bGVzaGVldHMuc2V0KHN0eWxlVXJsLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHN0eWxlc2hlZXQuc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cyk7XG4gICAgICAgIH0pOyB9KSksIGZ1bmN0aW9uIChfKSB7IHJldHVybiBsb2FkZWRTdHlsZXNoZWV0czsgfSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fbm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2R1bGVVcmwgPSBzdHlsZXNoZWV0Lm1vZHVsZVVybDtcbiAgICAgICAgdmFyIGFsbFN0eWxlVXJscyA9IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmZpbHRlcihpc1N0eWxlVXJsUmVzb2x2YWJsZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUobW9kdWxlVXJsLCB1cmwpOyB9KTtcbiAgICAgICAgdmFyIGFsbFN0eWxlcyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZVdpdGhJbXBvcnRzID0gZXh0cmFjdFN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIG1vZHVsZVVybCwgc3R5bGUpO1xuICAgICAgICAgICAgYWxsU3R5bGVVcmxzLnB1c2guYXBwbHkoYWxsU3R5bGVVcmxzLCBfX3NwcmVhZChzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscykpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlV2l0aEltcG9ydHMuc3R5bGU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IGFsbFN0eWxlcywgc3R5bGVVcmxzOiBhbGxTdHlsZVVybHMsIG1vZHVsZVVybDogbW9kdWxlVXJsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG59KCkpO1xudmFyIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICB9XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnRfMSA9ICcnO1xuICAgICAgICAgICAgICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0JDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50XzEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGFzdC5jYXNlcyk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFFVRVJZX01FVEFEQVRBX0lERU5USUZJRVJTID0gW1xuICAgIGNyZWF0ZVZpZXdDaGlsZCxcbiAgICBjcmVhdGVWaWV3Q2hpbGRyZW4sXG4gICAgY3JlYXRlQ29udGVudENoaWxkLFxuICAgIGNyZWF0ZUNvbnRlbnRDaGlsZHJlbixcbl07XG4vKlxuICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige0BsaW5rIERpcmVjdGl2ZX0uXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gKi9cbnZhciBEaXJlY3RpdmVSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5pc0RpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICByZXR1cm4gdHlwZU1ldGFkYXRhICYmIHR5cGVNZXRhZGF0YS5zb21lKGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgIH07XG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICBpZiAodHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBmaW5kTGFzdCh0eXBlTWV0YWRhdGEsIGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IucHJvcE1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBndWFyZHMgPSB0aGlzLl9yZWZsZWN0b3IuZ3VhcmRzKHR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhKG1ldGFkYXRhLCBwcm9wZXJ0eU1ldGFkYXRhLCBndWFyZHMsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIERpcmVjdGl2ZSBhbm5vdGF0aW9uIGZvdW5kIG9uIFwiICsgc3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YSA9IGZ1bmN0aW9uIChkbSwgcHJvcGVydHlNZXRhZGF0YSwgZ3VhcmRzLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICAgICAgdmFyIGhvc3QgPSB7fTtcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydHlNZXRhZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gY3JlYXRlSW5wdXQuaXNUeXBlT2YoYSk7IH0pO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBpbnB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBjcmVhdGVPdXRwdXQuaXNUeXBlT2YoYSk7IH0pO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob3N0QmluZGluZ3MgPSBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGNyZWF0ZUhvc3RCaW5kaW5nLmlzVHlwZU9mKGEpOyB9KTtcbiAgICAgICAgICAgIGhvc3RCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmIChob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFdpdGggPSBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRXaXRoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBjYW4gbm90IGJpbmQgdG8gZXZlbnRzLiBVc2UgQEhvc3RMaXN0ZW5lciBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydFdpdGggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBwcm9wZXJ0eSBuYW1lLCAnY2xhc3MuPG5hbWU+Jywgb3IgJ2F0dHIuPG5hbWU+Jy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaG9zdFtcIltcIiArIGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIl0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RbXCJbXCIgKyBwcm9wTmFtZSArIFwiXVwiXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGhvc3RMaXN0ZW5lcnMgPSBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGNyZWF0ZUhvc3RMaXN0ZW5lci5pc1R5cGVPZihhKTsgfSk7XG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaG9zdExpc3RlbmVyLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgaG9zdFtcIihcIiArIGhvc3RMaXN0ZW5lci5ldmVudE5hbWUgKyBcIilcIl0gPSBwcm9wTmFtZSArIFwiKFwiICsgYXJncy5qb2luKCcsJykgKyBcIilcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBRVUVSWV9NRVRBREFUQV9JREVOVElGSUVSUy5zb21lKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlzVHlwZU9mKGEpOyB9KTsgfSk7XG4gICAgICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlKGRtLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGd1YXJkcywgZGlyZWN0aXZlVHlwZSk7XG4gICAgfTtcbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX2V4dHJhY3RQdWJsaWNOYW1lID0gZnVuY3Rpb24gKGRlZikge1xuICAgICAgICByZXR1cm4gc3BsaXRBdENvbG9uKGRlZiwgW251bGwsIGRlZl0pWzFdLnRyaW0oKTtcbiAgICB9O1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fZGVkdXBlQmluZGluZ3MgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgcHVibGljTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciByZXZlcnNlZFJlc3VsdCA9IFtdO1xuICAgICAgICAvLyBnbyBsYXN0IHRvIGZpcnN0IHRvIGFsbG93IGxhdGVyIGVudHJpZXMgdG8gb3ZlcndyaXRlIHByZXZpb3VzIGVudHJpZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IGJpbmRpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKGJpbmRpbmcpO1xuICAgICAgICAgICAgcHVibGljTmFtZXMuYWRkKG5hbWVfMSk7XG4gICAgICAgICAgICBpZiAoIW5hbWVzLmhhcyhuYW1lXzEpKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMuYWRkKG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRSZXN1bHQucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZWRSZXN1bHQucmV2ZXJzZSgpO1xuICAgIH07XG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUsIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZ3VhcmRzLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBtZXJnZWRJbnB1dHMgPSB0aGlzLl9kZWR1cGVCaW5kaW5ncyhkaXJlY3RpdmUuaW5wdXRzID8gZGlyZWN0aXZlLmlucHV0cy5jb25jYXQoaW5wdXRzKSA6IGlucHV0cyk7XG4gICAgICAgIHZhciBtZXJnZWRPdXRwdXRzID0gdGhpcy5fZGVkdXBlQmluZGluZ3MoZGlyZWN0aXZlLm91dHB1dHMgPyBkaXJlY3RpdmUub3V0cHV0cy5jb25jYXQob3V0cHV0cykgOiBvdXRwdXRzKTtcbiAgICAgICAgdmFyIG1lcmdlZEhvc3QgPSBkaXJlY3RpdmUuaG9zdCA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkaXJlY3RpdmUuaG9zdCksIGhvc3QpIDogaG9zdDtcbiAgICAgICAgdmFyIG1lcmdlZFF1ZXJpZXMgPSBkaXJlY3RpdmUucXVlcmllcyA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkaXJlY3RpdmUucXVlcmllcyksIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudC5pc1R5cGVPZihkaXJlY3RpdmUpKSB7XG4gICAgICAgICAgICB2YXIgY29tcCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBjb21wLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogY29tcC5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogY29tcC5tb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY29tcC5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBjb21wLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBjb21wLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBjb21wLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogY29tcC50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogY29tcC50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IGNvbXAuc3R5bGVzLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogY29tcC5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogY29tcC5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGNvbXAuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBjb21wLmludGVycG9sYXRpb24sXG4gICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZGlyZWN0aXZlLnByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEaXJlY3RpdmUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgZ3VhcmRzOiBndWFyZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZWN0aXZlUmVzb2x2ZXI7XG59KCkpO1xuZnVuY3Rpb24gaXNEaXJlY3RpdmVNZXRhZGF0YSh0eXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURpcmVjdGl2ZS5pc1R5cGVPZih0eXBlKSB8fCBjcmVhdGVDb21wb25lbnQuaXNUeXBlT2YodHlwZSk7XG59XG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNvbmRpdGlvbikge1xuICAgIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGkxOG4gZXJyb3IuXG4gKi9cbnZhciBJMThuRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJMThuRXJyb3Ioc3BhbiwgbXNnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBJMThuRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG52YXIgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xudmFyIF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCA9IC9eaTE4bjo/LztcbnZhciBNRUFOSU5HX1NFUEFSQVRPUiA9ICd8JztcbnZhciBJRF9TRVBBUkFUT1IgPSAnQEAnO1xudmFyIGkxOG5Db21tZW50c1dhcm5lZCA9IGZhbHNlO1xuLyoqXG4gKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2xhdGlvbnMobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxudmFyIEV4dHJhY3Rpb25SZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0cmFjdGlvblJlc3VsdChtZXNzYWdlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xufSgpKTtcbnZhciBfVmlzaXRvck1vZGU7XG4oZnVuY3Rpb24gKF9WaXNpdG9yTW9kZSkge1xuICAgIF9WaXNpdG9yTW9kZVtfVmlzaXRvck1vZGVbXCJFeHRyYWN0XCJdID0gMF0gPSBcIkV4dHJhY3RcIjtcbiAgICBfVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlW1wiTWVyZ2VcIl0gPSAxXSA9IFwiTWVyZ2VcIjtcbn0pKF9WaXNpdG9yTW9kZSB8fCAoX1Zpc2l0b3JNb2RlID0ge30pKTtcbi8qKlxuICogVGhpcyBWaXNpdG9yIGlzIHVzZWQ6XG4gKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBfVmlzaXRvciQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WaXNpdG9yKF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzKSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5FeHRyYWN0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywgbnVsbCk7IH0pO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuTWVyZ2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSB0cmFuc2xhdGlvbnM7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHNpbmdsZSBmYWtlIHJvb3QgZWxlbWVudFxuICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBFbGVtZW50JDEoJ3dyYXBwZXInLCBbXSwgbm9kZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAvLyBQYXJzZSBjYXNlcyBmb3IgdHJhbnNsYXRhYmxlIGh0bWwgYXR0cmlidXRlc1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHZpc2l0QWxsJDEodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgIHZhciB3YXNJbkljdSA9IHRoaXMuX2luSWN1O1xuICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgZXh0cmFjdGVkIGJ1dCB0b3AtbGV2ZWwgdHJhbnNsYXRlZCBhcyBhIHdob2xlXG4gICAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luSWN1ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FzZXMgPSB2aXNpdEFsbCQxKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGljdSA9IG5ldyBFeHBhbnNpb24oaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuLCBpY3Uuc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbkljdSA9IHdhc0luSWN1O1xuICAgICAgICByZXR1cm4gaWN1O1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpc09wZW5pbmcgPSBfaXNPcGVuaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQ2xvc2luZyA9IF9pc0Nsb3NpbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICBpZiAoaXNDbG9zaW5nICYmICF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgZnJvbSB2NSB5b3Ugc2hvdWxkIHVzZSA8bmctY29udGFpbmVyIGkxOG4+IGluc3RlYWQgb2YgaTE4biBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWkxOG5Db21tZW50c1dhcm5lZCAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bkNvbW1lbnRzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXRhaWxzID0gY29tbWVudC5zb3VyY2VTcGFuLmRldGFpbHMgPyBcIiwgXCIgKyBjb21tZW50LnNvdXJjZVNwYW4uZGV0YWlscyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhvY29tYmUpOiB1c2UgYSBsb2cgc2VydmljZSBvbmNlIHRoZXJlIGlzIGEgcHVibGljIG9uZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkkxOG4gY29tbWVudHMgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhbiA8bmctY29udGFpbmVyPiBlbGVtZW50IGluc3RlYWQgKFwiICsgY29tbWVudC5zb3VyY2VTcGFuLnN0YXJ0ICsgZGV0YWlscyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrU3RhcnREZXB0aCA9IHRoaXMuX2RlcHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC52YWx1ZS5yZXBsYWNlKF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKHRoaXMuX2Jsb2NrQ2hpbGRyZW4sIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShjb21tZW50LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdEFsbCQxKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdJMThOIGJsb2NrcyBzaG91bGQgbm90IGNyb3NzIGVsZW1lbnQgYm91bmRhcmllcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4odGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihlbCk7XG4gICAgICAgIHRoaXMuX2RlcHRoKys7XG4gICAgICAgIHZhciB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgdmFyIHdhc0luSW1wbGljaXROb2RlID0gdGhpcy5faW5JbXBsaWNpdE5vZGU7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIHZhciB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRXh0cmFjdDpcbiAgICAgICAgLy8gLSB0b3AgbGV2ZWwgbm9kZXMgd2l0aCB0aGUgKGltcGxpY2l0KSBcImkxOG5cIiBhdHRyaWJ1dGUgaWYgbm90IGFscmVhZHkgaW4gYSBzZWN0aW9uXG4gICAgICAgIC8vIC0gSUNVIG1lc3NhZ2VzXG4gICAgICAgIHZhciBpMThuQXR0ciA9IF9nZXRJMThuQXR0cihlbCk7XG4gICAgICAgIHZhciBpMThuTWV0YSA9IGkxOG5BdHRyID8gaTE4bkF0dHIudmFsdWUgOiAnJztcbiAgICAgICAgdmFyIGlzSW1wbGljaXQgPSB0aGlzLl9pbXBsaWNpdFRhZ3Muc29tZShmdW5jdGlvbiAodGFnKSB7IHJldHVybiBlbC5uYW1lID09PSB0YWc7IH0pICYmICF0aGlzLl9pbkljdSAmJlxuICAgICAgICAgICAgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICB2YXIgaXNUb3BMZXZlbEltcGxpY2l0ID0gIXdhc0luSW1wbGljaXROb2RlICYmIGlzSW1wbGljaXQ7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGUgfHwgaXNJbXBsaWNpdDtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5NZXRhKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoZWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUcmFuc2xhdGFibGUgPSBpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oZWwsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgJ0NvdWxkIG5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgaW50byBjaGlsZCBub2RlcyBmb3IgZXh0cmFjdGlvblxuICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHZhciB2aXNpdE5vZGVzID0gdHJhbnNsYXRlZENoaWxkTm9kZXMgfHwgZWwuY2hpbGRyZW47XG4gICAgICAgICAgICB2aXNpdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhpcyBsb29wIHdoZW4gdGhlIGJsb2NrIGNsb3NlcyAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aC0tO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gd2FzSW5JMThuTm9kZTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChtb2RlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gMDtcbiAgICAgICAgdGhpcy5faW5JY3UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlID0gY3JlYXRlSTE4bk1lc3NhZ2VGYWN0b3J5KGludGVycG9sYXRpb25Db25maWcpO1xuICAgIH07XG4gICAgLy8gbG9va3MgZm9yIHRyYW5zbGF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl92aXNpdEF0dHJpYnV0ZXNPZiA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUgPSB7fTtcbiAgICAgICAgdmFyIGltcGxpY2l0QXR0ck5hbWVzID0gdGhpcy5faW1wbGljaXRBdHRyc1tlbC5uYW1lXSB8fCBbXTtcbiAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgIGF0dHIudmFsdWU7IH0pO1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdLCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFkZCBhIHRyYW5zbGF0YWJsZSBtZXNzYWdlXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRNZXNzYWdlID0gZnVuY3Rpb24gKGFzdCwgbXNnTWV0YSkge1xuICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgQXR0cmlidXRlICYmICFhc3RbMF0udmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IF9wYXJzZU1lc3NhZ2VNZXRhKG1zZ01ldGEpLCBtZWFuaW5nID0gX2EubWVhbmluZywgZGVzY3JpcHRpb24gPSBfYS5kZXNjcmlwdGlvbiwgaWQgPSBfYS5pZDtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShhc3QsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLy8gVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gbWVzc2FnZSBnaXZlbiB0aGUgYFRyYW5zbGF0aW9uQnVuZGxlYFxuICAgIC8vIFRoaXMgaXMgdXNlZCBmb3IgdHJhbnNsYXRpbmcgZWxlbWVudHMgLyBibG9ja3MgLSBzZWUgYF90cmFuc2xhdGVBdHRyaWJ1dGVzYCBmb3IgYXR0cmlidXRlc1xuICAgIC8vIG5vLW9wIHdoZW4gY2FsbGVkIGluIGV4dHJhY3Rpb24gbW9kZSAocmV0dXJucyBbXSlcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIG1lc3NhZ2UgaWQ9XFxcIlwiICsgdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvLyB0cmFuc2xhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudCBhbmQgcmVtb3ZlIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGVsLmF0dHJzO1xuICAgICAgICB2YXIgaTE4blBhcnNlZE1lc3NhZ2VNZXRhID0ge307XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICBfcGFyc2VNZXNzYWdlTWV0YShhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUgJiYgYXR0ci52YWx1ZSAhPSAnJyAmJiBpMThuUGFyc2VkTWVzc2FnZU1ldGEuaGFzT3duUHJvcGVydHkoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWVdLCBtZWFuaW5nID0gX2EubWVhbmluZywgZGVzY3JpcHRpb24gPSBfYS5kZXNjcmlwdGlvbiwgaWQgPSBfYS5pZDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF90aGlzLl9jcmVhdGVJMThuTWVzc2FnZShbYXR0cl0sIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMuX3RyYW5zbGF0aW9ucy5nZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlKGF0dHIubmFtZSwgJycsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCQzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2Rlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZShhdHRyLm5hbWUsIHZhbHVlLCBhdHRyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJVbmV4cGVjdGVkIHRyYW5zbGF0aW9uIGZvciBhdHRyaWJ1dGUgXFxcIlwiICsgYXR0ci5uYW1lICsgXCJcXFwiIChpZD1cXFwiXCIgKyAoaWQgfHwgX3RoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkpICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBhdHRyaWJ1dGUgXFxcIlwiICsgYXR0ci5uYW1lICsgXCJcXFwiIChpZD1cXFwiXCIgKyAoaWQgfHwgX3RoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSkpICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGFzIGEgY2hpbGQgb2YgdGhlIGJsb2NrIHdoZW46XG4gICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgKiAtIHdlIGFyZSBub3QgaW5zaWRlIGEgSUNVIG1lc3NhZ2UgKHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpLFxuICAgICAqIC0gdGhlIG5vZGUgaXMgYSBcImRpcmVjdCBjaGlsZFwiIG9mIHRoZSBibG9ja1xuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrICYmICF0aGlzLl9pbkljdSAmJiB0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHN0YXJ0IG9mIGEgc2VjdGlvbiwgc2VlIGBfY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uYFxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfVmlzaXRvci5wcm90b3R5cGUsIFwiX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICAgICAqIC0gdGhlIGNvbnRlbnQgb2YgdHJhbnNsYXRhYmxlIGVsZW1lbnQsXG4gICAgICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHNlY3Rpb24gaGFzIG9ubHkgb25lIHNpZ25pZmljYW50IGNoaWxkcmVuIChjb21tZW50cyBub3Qgc2lnbmlmaWNhbnQpIHRoZW4gd2Ugc2hvdWxkIG5vdFxuICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAqXG4gICAgICogYDxwIGkxOG49XCJtZWFuaW5nfGRlc2NyaXB0aW9uXCI+e0lDVSBtZXNzYWdlfTwvcD5gIHdvdWxkIHByb2R1Y2UgdHdvIG1lc3NhZ2VzOlxuICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgKiAtIGFub3RoZXIgb25lIGZvciB0aGUgSUNVIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAqIG90aGVyd2lzZSBpZGVudGljYWwpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgKiBJQ1UgbWVzc2FnZSBoZXJlKVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gZW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50Q2hpbGRyZW4gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnRJbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghKGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBUZXh0JDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1Zpc2l0b3I7XG59KCkpO1xuZnVuY3Rpb24gX2lzT3BlbmluZ0NvbW1lbnQobikge1xuICAgIHJldHVybiAhIShuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpKTtcbn1cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nKTtcbn1cbmZ1bmN0aW9uIF9nZXRJMThuQXR0cihwKSB7XG4gICAgcmV0dXJuIHAuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSOyB9KSB8fCBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlTWVzc2FnZU1ldGEoaTE4bikge1xuICAgIGlmICghaTE4bilcbiAgICAgICAgcmV0dXJuIHsgbWVhbmluZzogJycsIGRlc2NyaXB0aW9uOiAnJywgaWQ6ICcnIH07XG4gICAgdmFyIGlkSW5kZXggPSBpMThuLmluZGV4T2YoSURfU0VQQVJBVE9SKTtcbiAgICB2YXIgZGVzY0luZGV4ID0gaTE4bi5pbmRleE9mKE1FQU5JTkdfU0VQQVJBVE9SKTtcbiAgICB2YXIgX2EgPSBfX3JlYWQoKGlkSW5kZXggPiAtMSkgPyBbaTE4bi5zbGljZSgwLCBpZEluZGV4KSwgaTE4bi5zbGljZShpZEluZGV4ICsgMildIDogW2kxOG4sICcnXSwgMiksIG1lYW5pbmdBbmREZXNjID0gX2FbMF0sIGlkID0gX2FbMV07XG4gICAgdmFyIF9iID0gX19yZWFkKChkZXNjSW5kZXggPiAtMSkgP1xuICAgICAgICBbbWVhbmluZ0FuZERlc2Muc2xpY2UoMCwgZGVzY0luZGV4KSwgbWVhbmluZ0FuZERlc2Muc2xpY2UoZGVzY0luZGV4ICsgMSldIDpcbiAgICAgICAgWycnLCBtZWFuaW5nQW5kRGVzY10sIDIpLCBtZWFuaW5nID0gX2JbMF0sIGRlc2NyaXB0aW9uID0gX2JbMV07XG4gICAgcmV0dXJuIHsgbWVhbmluZzogbWVhbmluZywgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBpZDogaWQudHJpbSgpIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxUYWdEZWZpbml0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRhZ0RlZmluaXRpb24oKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgICAgIHRoaXMuaXNWb2lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgfVxuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUYWdEZWZpbml0aW9uO1xufSgpKTtcbnZhciBfVEFHX0RFRklOSVRJT04gPSBuZXcgWG1sVGFnRGVmaW5pdGlvbigpO1xuZnVuY3Rpb24gZ2V0WG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIF9UQUdfREVGSU5JVElPTjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFhtbFBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhtbFBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdldFhtbFRhZ0RlZmluaXRpb24pIHx8IHRoaXM7XG4gICAgfVxuICAgIFhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sUGFyc2VyO1xufShQYXJzZXIpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9WRVJTSU9OID0gJzEuMic7XG52YXIgX1hNTE5TID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbnZhciBfREVGQVVMVF9TT1VSQ0VfTEFORyA9ICdlbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3gnO1xudmFyIF9NQVJLRVJfVEFHID0gJ21yayc7XG52YXIgX0ZJTEVfVEFHID0gJ2ZpbGUnO1xudmFyIF9TT1VSQ0VfVEFHJDEgPSAnc291cmNlJztcbnZhciBfU0VHTUVOVF9TT1VSQ0VfVEFHID0gJ3NlZy1zb3VyY2UnO1xudmFyIF9BTFRfVFJBTlNfVEFHID0gJ2FsdC10cmFucyc7XG52YXIgX1RBUkdFVF9UQUcgPSAndGFyZ2V0JztcbnZhciBfVU5JVF9UQUcgPSAndHJhbnMtdW5pdCc7XG52YXIgX0NPTlRFWFRfR1JPVVBfVEFHID0gJ2NvbnRleHQtZ3JvdXAnO1xudmFyIF9DT05URVhUX1RBRyA9ICdjb250ZXh0Jztcbi8vIGh0dHA6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIvb3MveGxpZmYtY29yZS5odG1sXG4vLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL3hsaWZmLXByb2ZpbGUtaHRtbC94bGlmZi1wcm9maWxlLWh0bWwtMS4yLmh0bWxcbnZhciBYbGlmZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWGxpZmYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGxpZmYoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvcigpO1xuICAgICAgICB2YXIgdHJhbnNVbml0cyA9IFtdO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY29udGV4dFRhZ3MgPSBbXTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dEdyb3VwVGFnID0gbmV3IFRhZyhfQ09OVEVYVF9HUk9VUF9UQUcsIHsgcHVycG9zZTogJ2xvY2F0aW9uJyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0R3JvdXBUYWcuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ3NvdXJjZWZpbGUnIH0sIFtuZXcgVGV4dCQyKHNvdXJjZS5maWxlUGF0aCldKSwgbmV3IENSKDEwKSwgbmV3IFRhZyhfQ09OVEVYVF9UQUcsIHsgJ2NvbnRleHQtdHlwZSc6ICdsaW5lbnVtYmVyJyB9LCBbbmV3IFRleHQkMihcIlwiICsgc291cmNlLnN0YXJ0TGluZSldKSwgbmV3IENSKDgpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0VGFncy5wdXNoKG5ldyBDUig4KSwgY29udGV4dEdyb3VwVGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRyYW5zVW5pdCA9IG5ldyBUYWcoX1VOSVRfVEFHLCB7IGlkOiBtZXNzYWdlLmlkLCBkYXRhdHlwZTogJ2h0bWwnIH0pO1xuICAgICAgICAgICAgKF9hID0gdHJhbnNVbml0LmNoaWxkcmVuKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChbbmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHJDEsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSldLCBjb250ZXh0VGFncykpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJvZHkgPSBuZXcgVGFnKCdib2R5Jywge30sIF9fc3ByZWFkKHRyYW5zVW5pdHMsIFtuZXcgQ1IoNCldKSk7XG4gICAgICAgIHZhciBmaWxlID0gbmV3IFRhZygnZmlsZScsIHtcbiAgICAgICAgICAgICdzb3VyY2UtbGFuZ3VhZ2UnOiBsb2NhbGUgfHwgX0RFRkFVTFRfU09VUkNFX0xBTkcsXG4gICAgICAgICAgICBkYXRhdHlwZTogJ3BsYWludGV4dCcsXG4gICAgICAgICAgICBvcmlnaW5hbDogJ25nMi50ZW1wbGF0ZScsXG4gICAgICAgIH0sIFtuZXcgQ1IoNCksIGJvZHksIG5ldyBDUigyKV0pO1xuICAgICAgICB2YXIgeGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBYbGlmZi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciB4bGlmZlBhcnNlciA9IG5ldyBYbGlmZlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIG1zZ0lkVG9IdG1sID0gX2EubXNnSWRUb0h0bWwsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgdmFyIGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4oKTtcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCksIGkxOG5Ob2RlcyA9IF9hLmkxOG5Ob2RlcywgZSA9IF9hLmVycm9ycztcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX19zcHJlYWQoZSkpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieGxpZmYgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgWGxpZmYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBkaWdlc3QobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gWGxpZmY7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfV3JpdGVWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9Xcml0ZVZpc2l0b3IoKSB7XG4gICAgfVxuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZChub2RlLnZpc2l0KF90aGlzKSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgX19zcHJlYWQoW25ldyBUZXh0JDIoYyArIFwiIHtcIildLCBpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGN0eXBlID0gZ2V0Q3R5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBpZDogcGguc3RhcnROYW1lLCBjdHlwZTogY3R5cGUsICdlcXVpdi10ZXh0JzogXCI8XCIgKyBwaC50YWcgKyBcIi8+XCIgfSldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IHBoLnN0YXJ0TmFtZSwgY3R5cGU6IGN0eXBlLCAnZXF1aXYtdGV4dCc6IFwiPFwiICsgcGgudGFnICsgXCI+XCIgfSk7XG4gICAgICAgIHZhciBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IHBoLmNsb3NlTmFtZSwgY3R5cGU6IGN0eXBlLCAnZXF1aXYtdGV4dCc6IFwiPC9cIiArIHBoLnRhZyArIFwiPlwiIH0pO1xuICAgICAgICByZXR1cm4gX19zcHJlYWQoW3N0YXJ0VGFnUGhdLCB0aGlzLnNlcmlhbGl6ZShwaC5jaGlsZHJlbiksIFtjbG9zZVRhZ1BoXSk7XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgaWQ6IHBoLm5hbWUsICdlcXVpdi10ZXh0JzogXCJ7e1wiICsgcGgudmFsdWUgKyBcIn19XCIgfSldO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXF1aXZUZXh0ID0gXCJ7XCIgKyBwaC52YWx1ZS5leHByZXNzaW9uICsgXCIsIFwiICsgcGgudmFsdWUudHlwZSArIFwiLCBcIiArIE9iamVjdC5rZXlzKHBoLnZhbHVlLmNhc2VzKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSArICcgey4uLn0nOyB9KS5qb2luKCcgJykgKyBcIn1cIjtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBpZDogcGgubmFtZSwgJ2VxdWl2LXRleHQnOiBlcXVpdlRleHQgfSldO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX1dyaXRlVmlzaXRvcjtcbn0oKSk7XG4vLyBUT0RPKHZpY2IpOiBhZGQgZXJyb3IgbWFuYWdlbWVudCAoc3RydWN0dXJlKVxuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeGxpZmYgZmlsZVxudmFyIFhsaWZmUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhsaWZmUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeGxpZmYsIHVybCkge1xuICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICB2YXIgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHhtbC5yb290Tm9kZXMsIG51bGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnSWRUb0h0bWw6IHRoaXMuX21zZ0lkVG9IdG1sLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3VuaXRNbFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSB0aGlzLl91bml0TWxTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIk1lc3NhZ2UgXCIgKyBpZCArIFwiIG1pc3NlcyBhIHRyYW5zbGF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gaWdub3JlIHRob3NlIHRhZ3NcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUckMTpcbiAgICAgICAgICAgIGNhc2UgX1NFR01FTlRfU09VUkNFX1RBRzpcbiAgICAgICAgICAgIGNhc2UgX0FMVF9UUkFOU19UQUc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHRTdGFydCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dEVuZCA9IGVsZW1lbnQuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfRklMRV9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsZUF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3RhcmdldC1sYW5ndWFnZSc7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCBmaWxlIHN0cnVjdHVyZSwgeGxpZmYgdmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgb25seSByZWN1cnNlIG9uIHVuaGFuZGxlZCBub2Rlc1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWGxpZmZQYXJzZXI7XG59KCkpO1xuLy8gQ29udmVydCBtbCBub2RlcyAoeGxpZmYgc3ludGF4KSB0byBpMThuIG5vZGVzXG52YXIgWG1sVG9JMThuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRvSTE4bigpIHtcbiAgICB9XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCkge1xuICAgICAgICB2YXIgeG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICB2YXIgaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6IFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQodmlzaXRBbGwkMSh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfTUFSS0VSX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQodmlzaXRBbGwkMSh0aGlzLCBlbC5jaGlsZHJlbikpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCJVbmV4cGVjdGVkIHRhZ1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UkMShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaWN1Q2FzZS52YWx1ZSxcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpdEFsbCQxKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sVG9JMThuO1xufSgpKTtcbmZ1bmN0aW9uIGdldEN0eXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgICAgcmV0dXJuICdsYic7XG4gICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIngtXCIgKyB0YWc7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1ZFUlNJT04kMSA9ICcyLjAnO1xudmFyIF9YTUxOUyQxID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoyLjAnO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbnZhciBfREVGQVVMVF9TT1VSQ0VfTEFORyQxID0gJ2VuJztcbnZhciBfUExBQ0VIT0xERVJfVEFHJDIgPSAncGgnO1xudmFyIF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcgPSAncGMnO1xudmFyIF9NQVJLRVJfVEFHJDEgPSAnbXJrJztcbnZhciBfWExJRkZfVEFHID0gJ3hsaWZmJztcbnZhciBfU09VUkNFX1RBRyQyID0gJ3NvdXJjZSc7XG52YXIgX1RBUkdFVF9UQUckMSA9ICd0YXJnZXQnO1xudmFyIF9VTklUX1RBRyQxID0gJ3VuaXQnO1xuLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYveGxpZmYtY29yZS92Mi4wL29zL3hsaWZmLWNvcmUtdjIuMC1vcy5odG1sXG52YXIgWGxpZmYyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbGlmZjIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGxpZmYyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFhsaWZmMi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yJDEoKTtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciB1bml0ID0gbmV3IFRhZyhfVU5JVF9UQUckMSwgeyBpZDogbWVzc2FnZS5pZCB9KTtcbiAgICAgICAgICAgIHZhciBub3RlcyA9IG5ldyBUYWcoJ25vdGVzJyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbiB8fCBtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBub3Rlcy5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgY2F0ZWdvcnk6ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnbG9jYXRpb24nIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRleHQkMihzb3VyY2UuZmlsZVBhdGggKyBcIjpcIiArIHNvdXJjZS5zdGFydExpbmUgKyAoc291cmNlLmVuZExpbmUgIT09IHNvdXJjZS5zdGFydExpbmUgPyAnLCcgKyBzb3VyY2UuZW5kTGluZSA6ICcnKSlcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHVuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNiksIG5vdGVzKTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gbmV3IFRhZygnc2VnbWVudCcpO1xuICAgICAgICAgICAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRyQyLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmaWxlID0gbmV3IFRhZygnZmlsZScsIHsgJ29yaWdpbmFsJzogJ25nLnRlbXBsYXRlJywgaWQ6ICduZ2kxOG4nIH0sIF9fc3ByZWFkKHVuaXRzLCBbbmV3IENSKDIpXSkpO1xuICAgICAgICB2YXIgeGxpZmYgPSBuZXcgVGFnKF9YTElGRl9UQUcsIHsgdmVyc2lvbjogX1ZFUlNJT04kMSwgeG1sbnM6IF9YTUxOUyQxLCBzcmNMYW5nOiBsb2NhbGUgfHwgX0RFRkFVTFRfU09VUkNFX0xBTkckMSB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIFhsaWZmMi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciB4bGlmZjJQYXJzZXIgPSBuZXcgWGxpZmYyUGFyc2VyKCk7XG4gICAgICAgIHZhciBfYSA9IHhsaWZmMlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIG1zZ0lkVG9IdG1sID0gX2EubXNnSWRUb0h0bWwsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgdmFyIGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChlKSk7XG4gICAgICAgICAgICBpMThuTm9kZXNCeU1zZ0lkW21zZ0lkXSA9IGkxOG5Ob2RlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4bGlmZjIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgWGxpZmYyLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZjI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfV3JpdGVWaXNpdG9yJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTtcbiAgICB9O1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIF9fc3ByZWFkKG5vZGUudmlzaXQoX3RoaXMpKSk7IH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBfX3NwcmVhZChbbmV3IFRleHQkMihjICsgXCIge1wiKV0sIGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgdmFyIHRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHtcbiAgICAgICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZXF1aXY6IHBoLnN0YXJ0TmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGRpc3A6IFwiPFwiICsgcGgudGFnICsgXCIvPlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gW3RhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnUGMgPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcsIHtcbiAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGVxdWl2U3RhcnQ6IHBoLnN0YXJ0TmFtZSxcbiAgICAgICAgICAgIGVxdWl2RW5kOiBwaC5jbG9zZU5hbWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGlzcFN0YXJ0OiBcIjxcIiArIHBoLnRhZyArIFwiPlwiLFxuICAgICAgICAgICAgZGlzcEVuZDogXCI8L1wiICsgcGgudGFnICsgXCI+XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm9kZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKSk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRhZ1BjLmNoaWxkcmVuLnB1c2gobm9kZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnUGMuY2hpbGRyZW4ucHVzaChuZXcgVGV4dCQyKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0YWdQY107XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpZFN0ciA9ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkU3RyLFxuICAgICAgICAgICAgICAgIGVxdWl2OiBwaC5uYW1lLFxuICAgICAgICAgICAgICAgIGRpc3A6IFwie3tcIiArIHBoLnZhbHVlICsgXCJ9fVwiLFxuICAgICAgICAgICAgfSldO1xuICAgIH07XG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgY2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgKyAnIHsuLi59JzsgfSkuam9pbignICcpO1xuICAgICAgICB2YXIgaWRTdHIgPSAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogaWRTdHIsIGVxdWl2OiBwaC5uYW1lLCBkaXNwOiBcIntcIiArIHBoLnZhbHVlLmV4cHJlc3Npb24gKyBcIiwgXCIgKyBwaC52YWx1ZS50eXBlICsgXCIsIFwiICsgY2FzZXMgKyBcIn1cIiB9KV07XG4gICAgfTtcbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbmV4dFBsYWNlaG9sZGVySWQgPSAwO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBfX3NwcmVhZChub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG59KCkpO1xuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeGxpZmYgZmlsZVxudmFyIFhsaWZmMlBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbGlmZjJQYXJzZXIoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeGxpZmYsIHVybCkge1xuICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICB2YXIgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHhtbC5yb290Tm9kZXMsIG51bGwpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnSWRUb0h0bWw6IHRoaXMuX21zZ0lkVG9IdG1sLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHJDEgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5pdE1sU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IHRoaXMuX3VuaXRNbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiTWVzc2FnZSBcIiArIGlkICsgXCIgbWlzc2VzIGEgdHJhbnNsYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHJDI6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJUZXh0RW5kID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9YTElGRl9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsZUF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3RyZ0xhbmcnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbkF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ3ZlcnNpb24nOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSB2ZXJzaW9uQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09ICcyLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIlRoZSBYTElGRiBmaWxlIHZlcnNpb24gXCIgKyB2ZXJzaW9uICsgXCIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBYTElGRiAyLjAgc2VyaWFsaXplclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWGxpZmYyUGFyc2VyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyB9O1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIFhsaWZmMlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICBYbGlmZjJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWGxpZmYyUGFyc2VyO1xufSgpKTtcbi8vIENvbnZlcnQgbWwgbm9kZXMgKHhsaWZmIHN5bnRheCkgdG8gaTE4biBub2Rlc1xudmFyIFhtbFRvSTE4biQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbFRvSTE4bigpIHtcbiAgICB9XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHVybCkge1xuICAgICAgICB2YXIgeG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICB2YXIgaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6IFtdLmNvbmNhdC5hcHBseShbXSwgX19zcHJlYWQodmlzaXRBbGwkMSh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAoZWwubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfVEFHJDI6XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnZXF1aXYnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCBlbC5zb3VyY2VTcGFuKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMiArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdlxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIHZhciBzdGFydEF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdlcXVpdlN0YXJ0JzsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdlcXVpdkVuZCc7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMiArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdlN0YXJ0XFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlbmRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUckMiArIFwiPiBtaXNzZXMgdGhlIFxcXCJlcXVpdkVuZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SWQgPSBzdGFydEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRJZCA9IGVuZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXMuY29uY2F0LmFwcGx5KG5vZGVzLCBfX3NwcmVhZChbbmV3IFBsYWNlaG9sZGVyKCcnLCBzdGFydElkLCBlbC5zb3VyY2VTcGFuKV0sIGVsLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywgbnVsbCk7IH0pLCBbbmV3IFBsYWNlaG9sZGVyKCcnLCBlbmRJZCwgZWwuc291cmNlU3BhbildKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfTUFSS0VSX1RBRyQxOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIF9fc3ByZWFkKHZpc2l0QWxsJDEodGhpcywgZWwuY2hpbGRyZW4pKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNhc2VNYXAgPSB7fTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1JDEoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGljdUNhc2UudmFsdWUsXG4gICAgICAgICAgICBub2RlczogW10uY29uY2F0LmFwcGx5KFtdLCBfX3NwcmVhZCh2aXNpdEFsbCQxKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbikpKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG47XG59KCkpO1xuZnVuY3Rpb24gZ2V0VHlwZUZvclRhZyh0YWcpIHtcbiAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgIGNhc2UgJ2knOlxuICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJldHVybiAnZm10JztcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldHVybiAnbGluayc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG52YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbnZhciBYdGIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFh0YiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYdGIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICB9O1xuICAgIFh0Yi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geHRiIHRvIHhtbCBub2Rlc1xuICAgICAgICB2YXIgeHRiUGFyc2VyID0gbmV3IFh0YlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4dGJQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBtc2dJZFRvSHRtbCA9IF9hLm1zZ0lkVG9IdG1sLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIHZhciBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuJDIoKTtcbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIHh0YiBmaWxlcyB0aGF0IHJlbHkgb24gZmVhdHVyZXMgbm90IHN1cHBvcnRlZCBieSBhbmd1bGFyLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IHRoZSBjb252ZXJzaW9uIG9mIGh0bWwgdG8gaTE4biBub2RlcyBzbyB0aGF0IG5vbiBhbmd1bGFyIG1lc3NhZ2VzIGFyZSBub3RcbiAgICAgICAgLy8gY29udmVydGVkXG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpLCBpMThuTm9kZXMgPSBfYS5pMThuTm9kZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkxOG5Ob2RlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjcmVhdGVMYXp5UHJvcGVydHkoaTE4bk5vZGVzQnlNc2dJZCwgbXNnSWQsIHZhbHVlRm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkOiBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfTtcbiAgICBYdGIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTtcbiAgICB9O1xuICAgIFh0Yi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYdGI7XG59KFNlcmlhbGl6ZXIpKTtcbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHZhbHVlRm4pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgb3ZlcndyaXRlIGFuIFhUQiB0cmFuc2xhdGlvbicpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeHRiIGZpbGVcbnZhciBYdGJQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWHRiUGFyc2VyKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHh0YiwgdXJsKSB7XG4gICAgICAgIHRoaXMuX2J1bmRsZURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgLy8gV2UgY2FuIG5vdCBwYXJzZSB0aGUgSUNVIG1lc3NhZ2VzIGF0IHRoaXMgcG9pbnQgYXMgc29tZSBtZXNzYWdlcyBtaWdodCBub3Qgb3JpZ2luYXRlXG4gICAgICAgIC8vIGZyb20gQW5ndWxhciB0aGF0IGNvdWxkIG5vdCBiZSBsZXgnZC5cbiAgICAgICAgdmFyIHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4dGIsIHVybCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbC5lcnJvcnM7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgeG1sLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05TX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9idW5kbGVEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05TX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhbmdBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdsYW5nJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxhbmdBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoLS07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTl9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgJ1VuZXhwZWN0ZWQgdGFnJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgWHRiUGFyc2VyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgfTtcbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiUGFyc2VyO1xufSgpKTtcbi8vIENvbnZlcnQgbWwgbm9kZXMgKHh0YiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbnZhciBYbWxUb0kxOG4kMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgdmFyIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQxKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UkMShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaWN1Q2FzZS52YWx1ZSxcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpdEFsbCQxKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQzKSB7XG4gICAgICAgICAgICB2YXIgbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICduYW1lJzsgfSk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDMgKyBcIj4gbWlzc2VzIHRoZSBcXFwibmFtZVxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfTtcbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sVG9JMThuO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgdHJhbnNsYXRlZCBtZXNzYWdlc1xuICovXG52YXIgVHJhbnNsYXRpb25CdW5kbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNsYXRpb25CdW5kbGUoX2kxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICBpZiAoX2kxOG5Ob2Rlc0J5TXNnSWQgPT09IHZvaWQgMCkgeyBfaTE4bk5vZGVzQnlNc2dJZCA9IHt9OyB9XG4gICAgICAgIGlmIChtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gdm9pZCAwKSB7IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZzsgfVxuICAgICAgICB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkID0gX2kxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgICAgICB0aGlzLm1hcHBlckZhY3RvcnkgPSBtYXBwZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLl9pMThuVG9IdG1sID0gbmV3IEkxOG5Ub0h0bWxWaXNpdG9yKF9pMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIGEgYFRyYW5zbGF0aW9uQnVuZGxlYCBieSBwYXJzaW5nIHRoZSBnaXZlbiBgY29udGVudGAgd2l0aCB0aGUgYHNlcmlhbGl6ZXJgLlxuICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICB2YXIgX2EgPSBzZXJpYWxpemVyLmxvYWQoY29udGVudCwgdXJsKSwgbG9jYWxlID0gX2EubG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkID0gX2EuaTE4bk5vZGVzQnlNc2dJZDtcbiAgICAgICAgdmFyIGRpZ2VzdEZuID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIHNlcmlhbGl6ZXIuZGlnZXN0KG0pOyB9O1xuICAgICAgICB2YXIgbWFwcGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobSk7IH07XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3RGbiwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gYXMgSFRNTCBub2RlcyBmcm9tIHRoZSBnaXZlbiBzb3VyY2UgbWVzc2FnZS5cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB2YXIgaHRtbCA9IHRoaXMuX2kxOG5Ub0h0bWwuY29udmVydChzcmNNc2cpO1xuICAgICAgICBpZiAoaHRtbC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaHRtbC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sLm5vZGVzO1xuICAgIH07XG4gICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChzcmNNc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0KHNyY01zZykgaW4gdGhpcy5faTE4bk5vZGVzQnlNc2dJZDtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbn0oKSk7XG52YXIgSTE4blRvSHRtbFZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIF9sb2NhbGUsIF9kaWdlc3QsIF9tYXBwZXJGYWN0b3J5LCBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIF9jb25zb2xlKSB7XG4gICAgICAgIGlmIChfaTE4bk5vZGVzQnlNc2dJZCA9PT0gdm9pZCAwKSB7IF9pMThuTm9kZXNCeU1zZ0lkID0ge307IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9lcnJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gaTE4biB0byB0ZXh0XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fY29udmVydFRvVGV4dChzcmNNc2cpO1xuICAgICAgICAvLyB0ZXh0IHRvIGh0bWxcbiAgICAgICAgdmFyIHVybCA9IHNyY01zZy5ub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsO1xuICAgICAgICB2YXIgaHRtbCA9IG5ldyBIdG1sUGFyc2VyKCkucGFyc2UodGV4dCwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogaHRtbC5yb290Tm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IF9fc3ByZWFkKHRoaXMuX2Vycm9ycywgaHRtbC5lcnJvcnMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIGBjb252ZXJ0KClgIHVzZXMgYW4gYEh0bWxQYXJzZXJgIHRvIHJldHVybiBgaHRtbC5Ob2RlYHNcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHRoZW4gbWFrZSBzdXJlIHRoYXQgYW55IHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgZXNjYXBlZFxuICAgICAgICByZXR1cm4gZXNjYXBlWG1sKHRleHQudmFsdWUpO1xuICAgIH07XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIjsgfSk7XG4gICAgICAgIC8vIFRPRE8odmljYik6IE9uY2UgYWxsIGZvcm1hdCBzd2l0Y2ggdG8gdXNpbmcgZXhwcmVzc2lvbiBwbGFjZWhvbGRlcnNcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHRocm93IHdoZW4gdGhlIHBsYWNlaG9sZGVyIGlzIG5vdCBpbiB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgdmFyIGV4cCA9IHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkoaWN1LmV4cHJlc3Npb24pID9cbiAgICAgICAgICAgIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbaWN1LmV4cHJlc3Npb25dIDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHAgKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIGNhc2VzLmpvaW4oJyAnKSArIFwifVwiO1xuICAgIH07XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHBoTmFtZSA9IHRoaXMuX21hcHBlcihwaC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbcGhOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgXCJVbmtub3duIHBsYWNlaG9sZGVyIFxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIC8vIExvYWRlZCBtZXNzYWdlIGNvbnRhaW5zIG9ubHkgcGxhY2Vob2xkZXJzICh2cyB0YWcgYW5kIGljdSBwbGFjZWhvbGRlcnMpLlxuICAgIC8vIEhvd2V2ZXIgd2hlbiBhIHRyYW5zbGF0aW9uIGNhbiBub3QgYmUgZm91bmQsIHdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgIC8vIHdoaWNoIGNhbiBjb250YWluIHRhZyBwbGFjZWhvbGRlcnNcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGFnID0gXCJcIiArIHBoLnRhZztcbiAgICAgICAgdmFyIGF0dHJzID0gT2JqZWN0LmtleXMocGguYXR0cnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSArIFwiPVxcXCJcIiArIHBoLmF0dHJzW25hbWVdICsgXCJcXFwiXCI7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiLz5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiPlwiICsgY2hpbGRyZW4gKyBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8vIExvYWRlZCBtZXNzYWdlIGNvbnRhaW5zIG9ubHkgcGxhY2Vob2xkZXJzICh2cyB0YWcgYW5kIGljdSBwbGFjZWhvbGRlcnMpLlxuICAgIC8vIEhvd2V2ZXIgd2hlbiBhIHRyYW5zbGF0aW9uIGNhbiBub3QgYmUgZm91bmQsIHdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgIC8vIHdoaWNoIGNhbiBjb250YWluIHRhZyBwbGFjZWhvbGRlcnNcbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHNvdXJjZSBtZXNzYWdlIHRvIGEgdHJhbnNsYXRlZCB0ZXh0IHN0cmluZzpcbiAgICAgKiAtIHRleHQgbm9kZXMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgdHJhbnNsYXRpb24sXG4gICAgICogLSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgY29udGVudCxcbiAgICAgKiAtIElDVSBub2RlcyBhcmUgY29udmVydGVkIHRvIElDVSBleHByZXNzaW9ucy5cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuX2NvbnZlcnRUb1RleHQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICB2YXIgbWFwcGVyID0gdGhpcy5fbWFwcGVyRmFjdG9yeSA/IHRoaXMuX21hcHBlckZhY3Rvcnkoc3JjTXNnKSA6IG51bGw7XG4gICAgICAgIHZhciBub2RlcztcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrLnB1c2goeyBtc2c6IHRoaXMuX3NyY01zZywgbWFwcGVyOiB0aGlzLl9tYXBwZXIgfSk7XG4gICAgICAgIHRoaXMuX3NyY01zZyA9IHNyY01zZztcbiAgICAgICAgaWYgKHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgdHJhbnNsYXRpb24gdXNlIGl0cyBub2RlcyBhcyB0aGUgc291cmNlXG4gICAgICAgICAgICAvLyBBbmQgY3JlYXRlIGEgbWFwcGVyIHRvIGNvbnZlcnQgc2VyaWFsaXplZCBwbGFjZWhvbGRlciBuYW1lcyB0byBpbnRlcm5hbCBuYW1lc1xuICAgICAgICAgICAgbm9kZXMgPSB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkW2lkXTtcbiAgICAgICAgICAgIHRoaXMuX21hcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXBwZXIgPyBtYXBwZXIudG9JbnRlcm5hbE5hbWUobmFtZSkgOiBuYW1lOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBubyB0cmFuc2xhdGlvbiBoYXMgYmVlbiBmb3VuZFxuICAgICAgICAgICAgLy8gLSByZXBvcnQgYW4gZXJyb3IgLyBhIHdhcm5pbmcgLyBub3RoaW5nLFxuICAgICAgICAgICAgLy8gLSB1c2UgdGhlIG5vZGVzIGZyb20gdGhlIG9yaWdpbmFsIG1lc3NhZ2VcbiAgICAgICAgICAgIC8vIC0gcGxhY2Vob2xkZXJzIGFyZSBhbHJlYWR5IGludGVybmFsIGFuZCBuZWVkIG5vIG1hcHBlclxuICAgICAgICAgICAgaWYgKHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID09PSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5FcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb25zb2xlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fbG9jYWxlID8gXCIgZm9yIGxvY2FsZSBcXFwiXCIgKyB0aGlzLl9sb2NhbGUgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IHNyY01zZy5ub2RlcztcbiAgICAgICAgICAgIHRoaXMuX21hcHBlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuYW1lOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkuam9pbignJyk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBjb250ZXh0Lm1zZztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gY29udGV4dC5tYXBwZXI7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChlbCwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoZWwuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4blRvSHRtbFZpc2l0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSTE4Tkh0bWxQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4Tkh0bWxQYXJzZXIoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKG1pc3NpbmdUcmFuc2xhdGlvbiA9PT0gdm9pZCAwKSB7IG1pc3NpbmdUcmFuc2xhdGlvbiA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZSh7fSwgbnVsbCwgZGlnZXN0LCB1bmRlZmluZWQsIG1pc3NpbmdUcmFuc2xhdGlvbiwgY29uc29sZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSTE4Tkh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQ29uZmlnID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uQ29uZmlnIHx8IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2Uoc291cmNlLCB1cmwsIF9fYXNzaWduKHsgaW50ZXJwb2xhdGlvbkNvbmZpZzogaW50ZXJwb2xhdGlvbkNvbmZpZyB9LCBvcHRpb25zKSk7XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4Tkh0bWxQYXJzZXI7XG59KCkpO1xuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYyJzpcbiAgICAgICAgY2FzZSAneGxmMic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMigpO1xuICAgICAgICBjYXNlICd4bGlmZic6XG4gICAgICAgIGNhc2UgJ3hsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUVVPVEVEX0tFWVMgPSAnJHF1b3RlZCQnO1xuZnVuY3Rpb24gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCB2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKGN0eCksIHR5cGUpO1xufVxudmFyIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKGN0eCkge1xuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB9XG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gTm90ZSBBcnJheS5tYXAoKSBtdXN0IG5vdCBiZSB1c2VkIHRvIGNvbnZlcnQgdGhlIHZhbHVlcyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgICAgLy8gc2tpcCBvdmVyIGVtcHR5IGVsZW1lbnRzIGluIGFycmF5cyBjb25zdHJ1Y3RlZCB1c2luZyBgbmV3IEFycmF5KGxlbmd0aClgLFxuICAgICAgICAvLyByZXN1bHRpbmcgaW4gYHVuZGVmaW5lZGAgZWxlbWVudHMuIFRoaXMgYnJlYWtzIHRoZSB0eXBlIGd1YXJhbnRlZSB0aGF0XG4gICAgICAgIC8vIGFsbCB2YWx1ZXMgaW4gYG8uTGl0ZXJhbEFycmF5RXhwcmAgYXJlIG9mIHR5cGUgYG8uRXhwcmVzc2lvbmAuXG4gICAgICAgIC8vIFNlZSB0ZXN0IGNhc2UgaW4gYHZhbHVlX3V0aWxfc3BlYy50c2AuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2aXNpdFZhbHVlKGFycltpXSwgdGhpcywgbnVsbCAvKiBjb250ZXh0ICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIodmFsdWVzLCB0eXBlKTtcbiAgICB9O1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIHF1b3RlZFNldCA9IG5ldyBTZXQobWFwICYmIG1hcFtRVU9URURfS0VZU10pO1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZW50cmllcy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkoa2V5LCB2aXNpdFZhbHVlKG1hcFtrZXldLCBfdGhpcywgbnVsbCksIHF1b3RlZFNldC5oYXMoa2V5KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCB0eXBlKTtcbiAgICB9O1xuICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh2YWx1ZSwgdHlwZSk7XG4gICAgfTtcbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1hcEVudHJ5JDEoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsIHF1b3RlZDogZmFsc2UgfTtcbn1cbnZhciBJbmplY3RhYmxlQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0YWJsZUNvbXBpbGVyKHJlZmxlY3RvciwgYWx3YXlzR2VuZXJhdGVEZWYpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuYWx3YXlzR2VuZXJhdGVEZWYgPSBhbHdheXNHZW5lcmF0ZURlZjtcbiAgICAgICAgdGhpcy50b2tlbkluamVjdG9yID0gcmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5JbmplY3Rvcik7XG4gICAgfVxuICAgIEluamVjdGFibGVDb21waWxlci5wcm90b3R5cGUuZGVwc0FycmF5ID0gZnVuY3Rpb24gKGRlcHMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZGVwO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdG9rZW5dO1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gMCAvKiBEZWZhdWx0ICovO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVwKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZGVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubmdNZXRhZGF0YU5hbWUgPT09ICdPcHRpb25hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSA4IC8qIE9wdGlvbmFsICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodi5uZ01ldGFkYXRhTmFtZSA9PT0gJ1NraXBTZWxmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzIHw9IDQgLyogU2tpcFNlbGYgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2Lm5nTWV0YWRhdGFOYW1lID09PSAnU2VsZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGFncyB8PSAyIC8qIFNlbGYgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2Lm5nTWV0YWRhdGFOYW1lID09PSAnSW5qZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdi50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b2tlbkV4cHI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRva2VuRXhwciA9IGxpdGVyYWwodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09IF90aGlzLnRva2VuSW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0b2tlbkV4cHIgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLklOSkVDVE9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuRXhwciA9IGN0eC5pbXBvcnRFeHByKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFncyAhPT0gMCAvKiBEZWZhdWx0ICovKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b2tlbkV4cHIsIGxpdGVyYWwoZmxhZ3MpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9rZW5FeHByXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluamVjdGFibGVDb21waWxlci5wcm90b3R5cGUuZmFjdG9yeUZvciA9IGZ1bmN0aW9uIChpbmplY3RhYmxlLCBjdHgpIHtcbiAgICAgICAgdmFyIHJldFZhbHVlO1xuICAgICAgICBpZiAoaW5qZWN0YWJsZS51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgcmV0VmFsdWUgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKFtjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUV4aXN0aW5nKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluamVjdGFibGUudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBpbmplY3RhYmxlLmRlcHMgfHwgW107XG4gICAgICAgICAgICBpZiAoZGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0VmFsdWUgPSBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUZhY3RvcnkpLmNhbGxGbih0aGlzLmRlcHNBcnJheShkZXBzLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnVzZUZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluamVjdGFibGUudXNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldFZhbHVlID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCBpbmplY3RhYmxlLnVzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbGF6eiA9IGluamVjdGFibGUudXNlQ2xhc3MgfHwgaW5qZWN0YWJsZS5zeW1ib2w7XG4gICAgICAgICAgICB2YXIgZGVwQXJncyA9IHRoaXMuZGVwc0FycmF5KHRoaXMucmVmbGVjdG9yLnBhcmFtZXRlcnMoY2xhenopLCBjdHgpO1xuICAgICAgICAgICAgcmV0VmFsdWUgPSBuZXcgSW5zdGFudGlhdGVFeHByKGN0eC5pbXBvcnRFeHByKGNsYXp6KSwgZGVwQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXRWYWx1ZSldLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5qZWN0YWJsZS5zeW1ib2wubmFtZSArICdfRmFjdG9yeScpO1xuICAgIH07XG4gICAgSW5qZWN0YWJsZUNvbXBpbGVyLnByb3RvdHlwZS5pbmplY3RhYmxlRGVmID0gZnVuY3Rpb24gKGluamVjdGFibGUsIGN0eCkge1xuICAgICAgICB2YXIgcHJvdmlkZWRJbiA9IE5VTExfRVhQUjtcbiAgICAgICAgaWYgKGluamVjdGFibGUucHJvdmlkZWRJbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaW5qZWN0YWJsZS5wcm92aWRlZEluID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbiA9IE5VTExfRVhQUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbmplY3RhYmxlLnByb3ZpZGVkSW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZWRJbiA9IGxpdGVyYWwoaW5qZWN0YWJsZS5wcm92aWRlZEluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVkSW4gPSBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnByb3ZpZGVkSW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWYgPSBbXG4gICAgICAgICAgICBtYXBFbnRyeSQxKCdmYWN0b3J5JywgdGhpcy5mYWN0b3J5Rm9yKGluamVjdGFibGUsIGN0eCkpLFxuICAgICAgICAgICAgbWFwRW50cnkkMSgndG9rZW4nLCBjdHguaW1wb3J0RXhwcihpbmplY3RhYmxlLnR5cGUucmVmZXJlbmNlKSksXG4gICAgICAgICAgICBtYXBFbnRyeSQxKCdwcm92aWRlZEluJywgcHJvdmlkZWRJbiksXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlKS5jYWxsRm4oW2xpdGVyYWxNYXAoZGVmKV0pO1xuICAgIH07XG4gICAgSW5qZWN0YWJsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGluamVjdGFibGUsIGN0eCkge1xuICAgICAgICBpZiAodGhpcy5hbHdheXNHZW5lcmF0ZURlZiB8fCBpbmplY3RhYmxlLnByb3ZpZGVkSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlkZW50aWZpZXJOYW1lKGluamVjdGFibGUudHlwZSk7XG4gICAgICAgICAgICB2YXIgY2xhenogPSBuZXcgQ2xhc3NTdG10KGNsYXNzTmFtZSwgbnVsbCwgW1xuICAgICAgICAgICAgICAgIG5ldyBDbGFzc0ZpZWxkKCfJtXByb3YnLCBJTkZFUlJFRF9UWVBFLCBbU3RtdE1vZGlmaWVyLlN0YXRpY10sIHRoaXMuaW5qZWN0YWJsZURlZihpbmplY3RhYmxlLCBjdHgpKSxcbiAgICAgICAgICAgIF0sIFtdLCBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW10sIFtdKSwgW10pO1xuICAgICAgICAgICAgY3R4LnN0YXRlbWVudHMucHVzaChjbGF6eik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbmplY3RhYmxlQ29tcGlsZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMgPSAvKFxcLnRzfFxcLmRcXC50c3xcXC5qc3xcXC5qc3h8XFwudHN4KSQvO1xudmFyIEdFTkVSQVRFRF9GSUxFID0gL1xcLm5nZmFjdG9yeVxcLnxcXC5uZ3N1bW1hcnlcXC4vO1xudmFyIEpJVF9TVU1NQVJZX0ZJTEUgPSAvXFwubmdzdW1tYXJ5XFwuLztcbnZhciBKSVRfU1VNTUFSWV9OQU1FID0gL05nU3VtbWFyeSQvO1xuZnVuY3Rpb24gbmdmYWN0b3J5RmlsZVBhdGgoZmlsZVBhdGgsIGZvcmNlU291cmNlRmlsZSkge1xuICAgIGlmIChmb3JjZVNvdXJjZUZpbGUgPT09IHZvaWQgMCkgeyBmb3JjZVNvdXJjZUZpbGUgPSBmYWxzZTsgfVxuICAgIHZhciB1cmxXaXRoU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KGZpbGVQYXRoLCBmb3JjZVNvdXJjZUZpbGUpO1xuICAgIHJldHVybiB1cmxXaXRoU3VmZml4WzBdICsgXCIubmdmYWN0b3J5XCIgKyBub3JtYWxpemVHZW5GaWxlU3VmZml4KHVybFdpdGhTdWZmaXhbMV0pO1xufVxuZnVuY3Rpb24gc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoR0VORVJBVEVEX0ZJTEUsICcuJyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZEZpbGUoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gR0VORVJBVEVEX0ZJTEUudGVzdChmaWxlUGF0aCk7XG59XG5mdW5jdGlvbiBzcGxpdFR5cGVzY3JpcHRTdWZmaXgocGF0aCwgZm9yY2VTb3VyY2VGaWxlKSB7XG4gICAgaWYgKGZvcmNlU291cmNlRmlsZSA9PT0gdm9pZCAwKSB7IGZvcmNlU291cmNlRmlsZSA9IGZhbHNlOyB9XG4gICAgaWYgKHBhdGguZW5kc1dpdGgoJy5kLnRzJykpIHtcbiAgICAgICAgcmV0dXJuIFtwYXRoLnNsaWNlKDAsIC01KSwgZm9yY2VTb3VyY2VGaWxlID8gJy50cycgOiAnLmQudHMnXTtcbiAgICB9XG4gICAgdmFyIGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGxhc3REb3QgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgbGFzdERvdCksIHBhdGguc3Vic3RyaW5nKGxhc3REb3QpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtwYXRoLCAnJ107XG59XG5mdW5jdGlvbiBub3JtYWxpemVHZW5GaWxlU3VmZml4KHNyY0ZpbGVTdWZmaXgpIHtcbiAgICByZXR1cm4gc3JjRmlsZVN1ZmZpeCA9PT0gJy50c3gnID8gJy50cycgOiBzcmNGaWxlU3VmZml4O1xufVxuZnVuY3Rpb24gc3VtbWFyeUZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGVOYW1lV2l0aG91dFN1ZmZpeCA9IGZpbGVOYW1lLnJlcGxhY2UoU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMsICcnKTtcbiAgICByZXR1cm4gZmlsZU5hbWVXaXRob3V0U3VmZml4ICsgXCIubmdzdW1tYXJ5Lmpzb25cIjtcbn1cbmZ1bmN0aW9uIHN1bW1hcnlGb3JKaXRGaWxlTmFtZShmaWxlTmFtZSwgZm9yY2VTb3VyY2VGaWxlKSB7XG4gICAgaWYgKGZvcmNlU291cmNlRmlsZSA9PT0gdm9pZCAwKSB7IGZvcmNlU291cmNlRmlsZSA9IGZhbHNlOyB9XG4gICAgdmFyIHVybFdpdGhTdWZmaXggPSBzcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVOYW1lKSwgZm9yY2VTb3VyY2VGaWxlKTtcbiAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nc3VtbWFyeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbn1cbmZ1bmN0aW9uIHN0cmlwU3VtbWFyeUZvckppdEZpbGVTdWZmaXgoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZShKSVRfU1VNTUFSWV9GSUxFLCAnLicpO1xufVxuZnVuY3Rpb24gc3VtbWFyeUZvckppdE5hbWUoc3ltYm9sTmFtZSkge1xuICAgIHJldHVybiBzeW1ib2xOYW1lICsgXCJOZ1N1bW1hcnlcIjtcbn1cbmZ1bmN0aW9uIHN0cmlwU3VtbWFyeUZvckppdE5hbWVTdWZmaXgoc3ltYm9sTmFtZSkge1xuICAgIHJldHVybiBzeW1ib2xOYW1lLnJlcGxhY2UoSklUX1NVTU1BUllfTkFNRSwgJycpO1xufVxudmFyIExPV0VSRURfU1lNQk9MID0gL1xcdTAyNzVcXGQrLztcbmZ1bmN0aW9uIGlzTG93ZXJlZFN5bWJvbChuYW1lKSB7XG4gICAgcmV0dXJuIExPV0VSRURfU1lNQk9MLnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVMb3dlcmVkU3ltYm9sKGlkKSB7XG4gICAgcmV0dXJuIFwiXFx1MDI3NVwiICsgaWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBMaWZlY3ljbGVIb29rcztcbihmdW5jdGlvbiAoTGlmZWN5Y2xlSG9va3MpIHtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uSW5pdFwiXSA9IDBdID0gXCJPbkluaXRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uRGVzdHJveVwiXSA9IDFdID0gXCJPbkRlc3Ryb3lcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkRvQ2hlY2tcIl0gPSAyXSA9IFwiRG9DaGVja1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25DaGFuZ2VzXCJdID0gM10gPSBcIk9uQ2hhbmdlc1wiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50SW5pdFwiXSA9IDRdID0gXCJBZnRlckNvbnRlbnRJbml0XCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRDaGVja2VkXCJdID0gNV0gPSBcIkFmdGVyQ29udGVudENoZWNrZWRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkFmdGVyVmlld0luaXRcIl0gPSA2XSA9IFwiQWZ0ZXJWaWV3SW5pdFwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3Q2hlY2tlZFwiXSA9IDddID0gXCJBZnRlclZpZXdDaGVja2VkXCI7XG59KShMaWZlY3ljbGVIb29rcyB8fCAoTGlmZWN5Y2xlSG9va3MgPSB7fSkpO1xudmFyIExJRkVDWUNMRV9IT09LU19WQUxVRVMgPSBbXG4gICAgTGlmZWN5Y2xlSG9va3MuT25Jbml0LCBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2ssIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcyxcbiAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0LCBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0LFxuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWRcbl07XG5mdW5jdGlvbiBoYXNMaWZlY3ljbGVIb29rKHJlZmxlY3RvciwgaG9vaywgdG9rZW4pIHtcbiAgICByZXR1cm4gcmVmbGVjdG9yLmhhc0xpZmVjeWNsZUhvb2sodG9rZW4sIGdldEhvb2tOYW1lKGhvb2spKTtcbn1cbmZ1bmN0aW9uIGdldEFsbExpZmVjeWNsZUhvb2tzKHJlZmxlY3RvciwgdG9rZW4pIHtcbiAgICByZXR1cm4gTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhhc0xpZmVjeWNsZUhvb2socmVmbGVjdG9yLCBob29rLCB0b2tlbik7IH0pO1xufVxuZnVuY3Rpb24gZ2V0SG9va05hbWUoaG9vaykge1xuICAgIHN3aXRjaCAoaG9vaykge1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uSW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkluaXQnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkRlc3Ryb3knO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICByZXR1cm4gJ25nRG9DaGVjayc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgcmV0dXJuICduZ09uQ2hhbmdlcyc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRJbml0JztcbiAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkOlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudENoZWNrZWQnO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3SW5pdCc7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlclZpZXdDaGVja2VkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRoaXMgZGVmYXVsdCBjYXNlIGlzIG5vdCBuZWVkZWQgYnkgVHlwZVNjcmlwdCBjb21waWxlciwgYXMgdGhlIHN3aXRjaCBpcyBleGhhdXN0aXZlLlxuICAgICAgICAgICAgLy8gSG93ZXZlciBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhhdCBhbmQgcmVwb3J0cyBhbiBlcnJvciBpbiB0eXBlZCBtb2RlLlxuICAgICAgICAgICAgLy8gVGhlIGB0aHJvdyBuZXcgRXJyb3JgIGJlbG93IHdvcmtzIGFyb3VuZCB0aGUgcHJvYmxlbSwgYW5kIHRoZSB1bmV4cGVjdGVkOiBuZXZlciB2YXJpYWJsZVxuICAgICAgICAgICAgLy8gbWFrZXMgc3VyZSB0c2Mgc3RpbGwgY2hlY2tzIHRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cbiAgICAgICAgICAgIHZhciB1bmV4cGVjdGVkID0gaG9vaztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgXCIgKyB1bmV4cGVjdGVkKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBFUlJPUl9DT01QT05FTlRfVFlQRSA9ICduZ0NvbXBvbmVudFR5cGUnO1xuLy8gRGVzaWduIG5vdGVzOlxuLy8gLSBkb24ndCBsYXppbHkgY3JlYXRlIG1ldGFkYXRhOlxuLy8gICBGb3Igc29tZSBtZXRhZGF0YSwgd2UgbmVlZCB0byBkbyBhc3luYyB3b3JrIHNvbWV0aW1lcyxcbi8vICAgc28gdGhlIHVzZXIgaGFzIHRvIGtpY2sgb2ZmIHRoaXMgbG9hZGluZy5cbi8vICAgQnV0IHdlIHdhbnQgdG8gcmVwb3J0IGVycm9ycyBldmVuIHdoZW4gdGhlIGFzeW5jIHdvcmsgaXNcbi8vICAgbm90IHJlcXVpcmVkIHRvIGNoZWNrIHRoYXQgdGhlIHVzZXIgd291bGQgaGF2ZSBiZWVuIGFibGVcbi8vICAgdG8gd2FpdCBjb3JyZWN0bHkuXG52YXIgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX2NvbmZpZywgX2h0bWxQYXJzZXIsIF9uZ01vZHVsZVJlc29sdmVyLCBfZGlyZWN0aXZlUmVzb2x2ZXIsIF9waXBlUmVzb2x2ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2RpcmVjdGl2ZU5vcm1hbGl6ZXIsIF9jb25zb2xlLCBfc3RhdGljU3ltYm9sQ2FjaGUsIF9yZWZsZWN0b3IsIF9lcnJvckNvbGxlY3Rvcikge1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIgPSBfbmdNb2R1bGVSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlSZXNvbHZlciA9IF9zdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyID0gX2RpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUgPSBfc3RhdGljU3ltYm9sQ2FjaGU7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yID0gX2Vycm9yQ29sbGVjdG9yO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaGFsbG93TW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRSZWZsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZsZWN0b3I7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5kZWxldGUodHlwZSk7XG4gICAgICAgIC8vIENsZWFyIGFsbCBvZiB0aGUgTmdNb2R1bGUgYXMgdGhleSBjb250YWluIHRyYW5zaXRpdmUgaW5mb3JtYXRpb24hXG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgaWYgKGRpck1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZUZvcihkaXJNZXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9jcmVhdGVQcm94eUNsYXNzID0gZnVuY3Rpb24gKGJhc2VUeXBlLCBuYW1lKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHZhciBwcm94eUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENsYXNzIFwiICsgbmFtZSArIFwiIGZvciB0eXBlIFwiICsgc3RyaW5naWZ5KGJhc2VUeXBlKSArIFwiIGlzIG5vdCBjb21waWxlZCB5ZXQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHByb3h5Q2xhc3Muc2V0RGVsZWdhdGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZGVsZWdhdGUgPSBkO1xuICAgICAgICAgICAgcHJveHlDbGFzcy5wcm90b3R5cGUgPSBkLnByb3RvdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTWFrZSBzdHJpbmdpZnkgd29yayBjb3JyZWN0bHlcbiAgICAgICAgcHJveHlDbGFzcy5vdmVycmlkZGVuTmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBwcm94eUNsYXNzO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEdlbmVyYXRlZENsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb3h5Q2xhc3MoZGlyVHlwZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRWaWV3Q2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmF0ZWRDbGFzcyhkaXJUeXBlLCB2aWV3Q2xhc3NOYW1lKGRpclR5cGUsIDApKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2VuZXJhdGVkQ2xhc3MoZGlyVHlwZSwgaG9zdFZpZXdDbGFzc05hbWUoZGlyVHlwZSkpO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEhvc3RDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogZGlyVHlwZSB9KSArIFwiX0hvc3RcIjtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQoZGlyVHlwZS5maWxlUGF0aCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb3h5Q2xhc3MoZGlyVHlwZSwgbmFtZSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UmVuZGVyZXJUeXBlID0gZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZGlyVHlwZS5maWxlUGF0aCksIHJlbmRlcmVyVHlwZU5hbWUoZGlyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGFuIG9iamVjdCBhcyBwcm94eSxcbiAgICAgICAgICAgIC8vIHRoYXQgd2UgZmlsbCBsYXRlciBkdXJpbmcgcnVudGltZSBjb21waWxhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpclR5cGUsIGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgY29tcG9uZW50RmFjdG9yeU5hbWUoZGlyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhvc3RWaWV3ID0gdGhpcy5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzKGRpclR5cGUpO1xuICAgICAgICAgICAgLy8gTm90ZTogbmdDb250ZW50U2VsZWN0b3JzIHdpbGwgYmUgZmlsbGVkIGxhdGVyIG9uY2UgdGhlIHRlbXBsYXRlIGlzXG4gICAgICAgICAgICAvLyBsb2FkZWQuXG4gICAgICAgICAgICB2YXIgY3JlYXRlQ29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX3JlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgZGlyVHlwZSwgaG9zdFZpZXcsIGlucHV0cywgb3V0cHV0cywgW10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaW5pdENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbmdDb250ZW50U2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoZmFjdG9yeSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIChfYSA9IGZhY3RvcnkubmdDb250ZW50U2VsZWN0b3JzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChuZ0NvbnRlbnRTZWxlY3RvcnMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9sb2FkU3VtbWFyeSA9IGZ1bmN0aW9uICh0eXBlLCBraW5kKSB7XG4gICAgICAgIHZhciB0eXBlU3VtbWFyeSA9IHRoaXMuX3N1bW1hcnlDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghdHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5fc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHR5cGUpO1xuICAgICAgICAgICAgdHlwZVN1bW1hcnkgPSBzdW1tYXJ5ID8gc3VtbWFyeS50eXBlIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N1bW1hcnlDYWNoZS5zZXQodHlwZSwgdHlwZVN1bW1hcnkgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVTdW1tYXJ5ICYmIHR5cGVTdW1tYXJ5LnN1bW1hcnlLaW5kID09PSBraW5kID8gdHlwZVN1bW1hcnkgOiBudWxsO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEhvc3RDb21wb25lbnRNZXRhZGF0YSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgaG9zdFZpZXdUeXBlKSB7XG4gICAgICAgIHZhciBob3N0VHlwZSA9IHRoaXMuZ2V0SG9zdENvbXBvbmVudFR5cGUoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICBpZiAoIWhvc3RWaWV3VHlwZSkge1xuICAgICAgICAgICAgaG9zdFZpZXdUeXBlID0gdGhpcy5nZXRIb3N0Q29tcG9uZW50Vmlld0NsYXNzKGhvc3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiAhIGlzIG9rIGhlcmUgYXMgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdpdGggbm9ybWFsaXplZCBkaXJlY3RpdmVcbiAgICAgICAgLy8gbWV0YWRhdGEsIHdoaWNoIGFsd2F5cyBmaWxscyBpbiB0aGUgc2VsZWN0b3IuXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IENzc1NlbGVjdG9yLnBhcnNlKGNvbXBNZXRhLnNlbGVjdG9yKVswXS5nZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSgpO1xuICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSAnJztcbiAgICAgICAgdmFyIGh0bWxBc3QgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICAgIGlzSG9zdDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IHsgcmVmZXJlbmNlOiBob3N0VHlwZSwgZGlEZXBzOiBbXSwgbGlmZWN5Y2xlSG9va3M6IFtdIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgaHRtbEFzdDogaHRtbEFzdCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgICAgIHN0eWxlVXJsczogW10sXG4gICAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBpc0lubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiBbXSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBleHBvcnRBczogbnVsbCxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgICAgIGhvc3Q6IHt9LFxuICAgICAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgICAgICBzZWxlY3RvcjogJyonLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXSxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICAgICAgcXVlcmllczogW10sXG4gICAgICAgICAgICBndWFyZHM6IHt9LFxuICAgICAgICAgICAgdmlld1F1ZXJpZXM6IFtdLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IGhvc3RWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogeyBpZDogJ19fSG9zdF9fJywgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSwgc3R5bGVzOiBbXSwgZGF0YToge30gfSxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW10sXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBudWxsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmxvYWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUsIGRpcmVjdGl2ZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlQ2FjaGUuaGFzKGRpcmVjdGl2ZVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Tm9uTm9ybWFsaXplZERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpLCBhbm5vdGF0aW9uID0gX2EuYW5ub3RhdGlvbiwgbWV0YWRhdGEgPSBfYS5tZXRhZGF0YTtcbiAgICAgICAgdmFyIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKHRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkRGlyTWV0YSA9IG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgIGlzSG9zdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0YWRhdGEudHlwZSxcbiAgICAgICAgICAgICAgICBpc0NvbXBvbmVudDogbWV0YWRhdGEuaXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IG1ldGFkYXRhLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBtZXRhZGF0YS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IG1ldGFkYXRhLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1ldGFkYXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXRhZGF0YS5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IG1ldGFkYXRhLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IG1ldGFkYXRhLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBtZXRhZGF0YS5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IG1ldGFkYXRhLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBtZXRhZGF0YS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1ldGFkYXRhLnF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgZ3VhcmRzOiBtZXRhZGF0YS5ndWFyZHMsXG4gICAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IG1ldGFkYXRhLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogbWV0YWRhdGEuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBtZXRhZGF0YS5jb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGU6IG1ldGFkYXRhLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGFkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdENvbXBvbmVudEZhY3RvcnkobWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSwgdGVtcGxhdGVNZXRhZGF0YS5uZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2RpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YSk7XG4gICAgICAgICAgICBfdGhpcy5fc3VtbWFyeUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBtZXRhZGF0YS50ZW1wbGF0ZTtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGEgPSB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLm5vcm1hbGl6ZVRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZVR5cGU6IG5nTW9kdWxlVHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRUeXBlOiBkaXJlY3RpdmVUeXBlLFxuICAgICAgICAgICAgICAgIG1vZHVsZVVybDogdGhpcy5fcmVmbGVjdG9yLmNvbXBvbmVudE1vZHVsZVVybChkaXJlY3RpdmVUeXBlLCBhbm5vdGF0aW9uKSxcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGUudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGVtcGxhdGUuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB0ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IHRlbXBsYXRlLnByZXNlcnZlV2hpdGVzcGFjZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSh0ZW1wbGF0ZU1ldGEpICYmIGlzU3luYykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yKGRpcmVjdGl2ZVR5cGUpLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0ZW1wbGF0ZU1ldGEsIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZVxuICAgICAgICAgICAgY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGRpcmVjdGl2ZVR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZihkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgaWYgKCFkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FjaGVFbnRyeSA9IHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWRpck1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudC5pc1R5cGVPZihkaXJNZXRhKSkge1xuICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBkaXJNZXRhO1xuICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlcycsIGNvbXBNZXRhLnN0eWxlcyk7XG4gICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVVcmxzJywgY29tcE1ldGEuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgY29tcE1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IGNvbXBNZXRhLmFuaW1hdGlvbnM7XG4gICAgICAgICAgICBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSA9IG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogbm9VbmRlZmluZWQoY29tcE1ldGEuZW5jYXBzdWxhdGlvbiksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IG5vVW5kZWZpbmVkKGNvbXBNZXRhLnRlbXBsYXRlKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogbm9VbmRlZmluZWQoY29tcE1ldGEudGVtcGxhdGVVcmwpLFxuICAgICAgICAgICAgICAgIGh0bWxBc3Q6IG51bGwsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBjb21wTWV0YS5zdHlsZXMgfHwgW10sXG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBjb21wTWV0YS5zdHlsZVVybHMgfHwgW10sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyB8fCBbXSxcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBub1VuZGVmaW5lZChjb21wTWV0YS5pbnRlcnBvbGF0aW9uKSxcbiAgICAgICAgICAgICAgICBpc0lubGluZTogISFjb21wTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiBbXSxcbiAgICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IG5vVW5kZWZpbmVkKGRpck1ldGEucHJlc2VydmVXaGl0ZXNwYWNlcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICB2YXIgdmlld1Byb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IFtdO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBkaXJNZXRhLnNlbGVjdG9yO1xuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50LmlzVHlwZU9mKGRpck1ldGEpKSB7XG4gICAgICAgICAgICAvLyBDb21wb25lbnRcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IGRpck1ldGE7XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IGNvbXBNZXRhLmNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChjb21wTWV0YS52aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKGNvbXBNZXRhLnZpZXdQcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwidmlld1Byb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcE1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IGZsYXR0ZW5BbmREZWR1cGVBcnJheShjb21wTWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGVudHJ5Q29tcG9uZW50TWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXJlY3RpdmVcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICBpZiAoZGlyTWV0YS5wcm92aWRlcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwicHJvdmlkZXJzIGZvciBcXFwiXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCJcXFwiXCIsIFtdLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcmllcyA9IFtdO1xuICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBbXTtcbiAgICAgICAgaWYgKGRpck1ldGEucXVlcmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBxdWVyaWVzID0gdGhpcy5fZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgZmFsc2UsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgdmlld1F1ZXJpZXMgPSB0aGlzLl9nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCB0cnVlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICAgIGlzSG9zdDogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogbm9VbmRlZmluZWQoZGlyTWV0YS5leHBvcnRBcyksXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogISFub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBub25Ob3JtYWxpemVkVGVtcGxhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICBpbnB1dHM6IGRpck1ldGEuaW5wdXRzIHx8IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogZGlyTWV0YS5vdXRwdXRzIHx8IFtdLFxuICAgICAgICAgICAgaG9zdDogZGlyTWV0YS5ob3N0IHx8IHt9LFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMgfHwgW10sXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB2aWV3UHJvdmlkZXJzIHx8IFtdLFxuICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyB8fCBbXSxcbiAgICAgICAgICAgIGd1YXJkczogZGlyTWV0YS5ndWFyZHMgfHwge30sXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMgfHwgW10sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsXG4gICAgICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldENvbXBvbmVudFZpZXdDbGFzcyhkaXJlY3RpdmVUeXBlKSA6XG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldFJlbmRlcmVyVHlwZShkaXJlY3RpdmVUeXBlKSA6IG51bGwsXG4gICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhLmNvbXBvbmVudEZhY3RvcnkgPVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgZGlyZWN0aXZlVHlwZSwgbWV0YWRhdGEuaW5wdXRzLCBtZXRhZGF0YS5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZUVudHJ5ID0geyBtZXRhZGF0YTogbWV0YWRhdGEsIGFubm90YXRpb246IGRpck1ldGEgfTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBjYWNoZUVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIGRpcmVjdGl2ZS5cbiAgICAgKiBUaGlzIGFzc3VtZXMgYGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YWAgaGFzIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICBpZiAoIWRpck1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogZ2V0RGlyZWN0aXZlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSBmb3IgYSBtb2R1bGUgdGhhdCBkZWNsYXJlcyBpdC4gRGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiLlwiKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpck1ldGE7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlU3VtbWFyeSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHZhciBkaXJTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkoZGlyVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSk7XG4gICAgICAgIGlmICghZGlyU3VtbWFyeSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb3VsZCBub3QgbG9hZCB0aGUgc3VtbWFyeSBmb3IgZGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJUeXBlKSArIFwiLlwiKSwgZGlyVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpclN1bW1hcnk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlKSB8fFxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIuaXNEaXJlY3RpdmUodHlwZSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNBYnN0cmFjdERpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSk7XG4gICAgICAgIGlmIChzdW1tYXJ5ICYmICFzdW1tYXJ5LmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gIXN1bW1hcnkuc2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKHR5cGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG1ldGEgJiYgIWNyZWF0ZUNvbXBvbmVudC5pc1R5cGVPZihtZXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuICFtZXRhLnNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuUGlwZSkgfHxcbiAgICAgICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlci5pc1BpcGUodHlwZSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuaXNOZ01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2xvYWRTdW1tYXJ5KHR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkgfHxcbiAgICAgICAgICAgIHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIuaXNOZ01vZHVsZSh0eXBlKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROZ01vZHVsZVN1bW1hcnkgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgYWxyZWFkeUNvbGxlY3RpbmcpIHtcbiAgICAgICAgaWYgKGFscmVhZHlDb2xsZWN0aW5nID09PSB2b2lkIDApIHsgYWxyZWFkeUNvbGxlY3RpbmcgPSBudWxsOyB9XG4gICAgICAgIHZhciBtb2R1bGVTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkobW9kdWxlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlKTtcbiAgICAgICAgaWYgKCFtb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTWV0YSA9IHRoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCBmYWxzZSwgYWxyZWFkeUNvbGxlY3RpbmcpO1xuICAgICAgICAgICAgbW9kdWxlU3VtbWFyeSA9IG1vZHVsZU1ldGEgPyBtb2R1bGVNZXRhLnRvU3VtbWFyeSgpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChtb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLnNldChtb2R1bGVUeXBlLCBtb2R1bGVTdW1tYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlU3VtbWFyeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBkZWNsYXJlZCBkaXJlY3RpdmVzIGFuZCBwaXBlcyBvZiBhbiBOZ01vZHVsZS5cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYywgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBuZ01vZHVsZSA9IHRoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICB2YXIgbG9hZGluZyA9IFtdO1xuICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gX3RoaXMubG9hZERpcmVjdGl2ZU1ldGFkYXRhKG1vZHVsZVR5cGUsIGlkLnJlZmVyZW5jZSwgaXNTeW5jKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZ01vZHVsZS5kZWNsYXJlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiBfdGhpcy5fbG9hZFBpcGVNZXRhZGF0YShpZC5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZyk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0U2hhbGxvd01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdmFyIGNvbXBpbGVNZXRhID0gdGhpcy5fc2hhbGxvd01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgaWYgKGNvbXBpbGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5nTW9kdWxlTWV0YSA9IGZpbmRMYXN0KHRoaXMuX3JlZmxlY3Rvci5zaGFsbG93QW5ub3RhdGlvbnMobW9kdWxlVHlwZSksIGNyZWF0ZU5nTW9kdWxlLmlzVHlwZU9mKTtcbiAgICAgICAgY29tcGlsZU1ldGEgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEobW9kdWxlVHlwZSksXG4gICAgICAgICAgICByYXdFeHBvcnRzOiBuZ01vZHVsZU1ldGEuZXhwb3J0cyxcbiAgICAgICAgICAgIHJhd0ltcG9ydHM6IG5nTW9kdWxlTWV0YS5pbXBvcnRzLFxuICAgICAgICAgICAgcmF3UHJvdmlkZXJzOiBuZ01vZHVsZU1ldGEucHJvdmlkZXJzLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zaGFsbG93TW9kdWxlQ2FjaGUuc2V0KG1vZHVsZVR5cGUsIGNvbXBpbGVNZXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kLCBhbHJlYWR5Q29sbGVjdGluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoYWxyZWFkeUNvbGxlY3RpbmcgPT09IHZvaWQgMCkgeyBhbHJlYWR5Q29sbGVjdGluZyA9IG51bGw7IH1cbiAgICAgICAgbW9kdWxlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgY29tcGlsZU1ldGEgPSB0aGlzLl9uZ01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgaWYgKGNvbXBpbGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9uZ01vZHVsZVJlc29sdmVyLnJlc29sdmUobW9kdWxlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVjbGFyZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciBleHBvcnRlZE5vbk1vZHVsZUlkZW50aWZpZXJzID0gW107XG4gICAgICAgIHZhciBkZWNsYXJlZFBpcGVzID0gW107XG4gICAgICAgIHZhciBpbXBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdmFyIGV4cG9ydGVkTW9kdWxlcyA9IFtdO1xuICAgICAgICB2YXIgcHJvdmlkZXJzID0gW107XG4gICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGJvb3RzdHJhcENvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtYXMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGEuaW1wb3J0cykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuaW1wb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltcG9ydGVkTW9kdWxlVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFR5cGUoaW1wb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltcG9ydGVkVHlwZSAmJiBpbXBvcnRlZFR5cGUubmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZVdpdGhQcm92aWRlcnMgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IG1vZHVsZVdpdGhQcm92aWRlcnMubmdNb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2guYXBwbHkocHJvdmlkZXJzLCBfX3NwcmVhZChfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRNb2R1bGVUeXBlKSArIFwiJ1wiLCBbXSwgaW1wb3J0ZWRUeXBlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jaGVja1NlbGZJbXBvcnQobW9kdWxlVHlwZSwgaW1wb3J0ZWRNb2R1bGVUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5Q29sbGVjdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscmVhZHlDb2xsZWN0aW5nID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeUNvbGxlY3RpbmcuaGFzKGltcG9ydGVkTW9kdWxlVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoaW1wb3J0ZWRNb2R1bGVUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeVR5cGUoaW1wb3J0ZWRUeXBlKSArIFwiJyBpcyBpbXBvcnRlZCByZWN1cnNpdmVseSBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIicuXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5Q29sbGVjdGluZy5hZGQoaW1wb3J0ZWRNb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltcG9ydGVkTW9kdWxlU3VtbWFyeSA9IF90aGlzLmdldE5nTW9kdWxlU3VtbWFyeShpbXBvcnRlZE1vZHVsZVR5cGUsIGFscmVhZHlDb2xsZWN0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RpbmcuZGVsZXRlKGltcG9ydGVkTW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGltcG9ydGVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnlUeXBlKGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInLiBQbGVhc2UgYWRkIGEgQE5nTW9kdWxlIGFubm90YXRpb24uXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZXMucHVzaChpbXBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmV4cG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZXhwb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeVR5cGUoZXhwb3J0ZWRUeXBlKSArIFwiJyBleHBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeUNvbGxlY3RpbmcpXG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlDb2xsZWN0aW5nID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5Q29sbGVjdGluZy5oYXMoZXhwb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnkoZXhwb3J0ZWRUeXBlKSArIFwiJyBpcyBleHBvcnRlZCByZWN1cnNpdmVseSBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFscmVhZHlDb2xsZWN0aW5nLmFkZChleHBvcnRlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvcnRlZE1vZHVsZVN1bW1hcnkgPSBfdGhpcy5nZXROZ01vZHVsZVN1bW1hcnkoZXhwb3J0ZWRUeXBlLCBhbHJlYWR5Q29sbGVjdGluZyk7XG4gICAgICAgICAgICAgICAgYWxyZWFkeUNvbGxlY3RpbmcuZGVsZXRlKGV4cG9ydGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVkTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXMucHVzaChleHBvcnRlZE1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5wdXNoKF90aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEoZXhwb3J0ZWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGxhdGVyLCBzbyB3ZSByZWx5IG9uXG4gICAgICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSFcbiAgICAgICAgdmFyIHRyYW5zaXRpdmVNb2R1bGUgPSB0aGlzLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YShpbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcyk7XG4gICAgICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZGVjbGFyYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyZWRJZGVudGlmaWVyID0gX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YShkZWNsYXJlZFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0RpcmVjdGl2ZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0Fic3RyYWN0RGlyZWN0aXZlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeVR5cGUoZGVjbGFyZWRUeXBlKSArIFwiIGhhcyBubyBzZWxlY3RvciwgcGxlYXNlIGFkZCBpdCFcIiksIGRlY2xhcmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGREaXJlY3RpdmUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFR5cGVUb01vZHVsZShkZWNsYXJlZFR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5pc1BpcGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZFBpcGUoZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5wdXNoKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmVkUGlwZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRlY2xhcmVkVHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGRlY2xhcmVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnlUeXBlKGRlY2xhcmVkVHlwZSkgKyBcIicgZGVjbGFyZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInLiBQbGVhc2UgYWRkIGEgQFBpcGUvQERpcmVjdGl2ZS9AQ29tcG9uZW50IGFubm90YXRpb24uXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdmFyIGV4cG9ydGVkUGlwZXMgPSBbXTtcbiAgICAgICAgZXhwb3J0ZWROb25Nb2R1bGVJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZElkKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXMucHVzaChleHBvcnRlZElkKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZEV4cG9ydGVkRGlyZWN0aXZlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRXhwb3J0ZWRQaXBlKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgZXhwb3J0IFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIFwiICsgc3RyaW5naWZ5VHlwZShleHBvcnRlZElkLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBwcm92aWRlcnMgb2YgdGhlIG1vZHVsZSBoYXZlIHRvIGdvIGxhc3RcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IG92ZXJ3cml0ZSBhbnkgb3RoZXIgcHJvdmlkZXIgd2UgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIF9fc3ByZWFkKHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKG1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBtb2R1bGVUeXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzLnB1c2guYXBwbHkoZW50cnlDb21wb25lbnRzLCBfX3NwcmVhZChmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEodHlwZSk7IH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuYm9vdHN0cmFwKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5ib290c3RyYXApLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiJyB1c2VkIGluIHRoZSBib290c3RyYXAgcHJvcGVydHkgb2YgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHMucHVzaChfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKHR5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50cywgX19zcHJlYWQoYm9vdHN0cmFwQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUucmVmZXJlbmNlKTsgfSkpKTtcbiAgICAgICAgaWYgKG1ldGEuc2NoZW1hcykge1xuICAgICAgICAgICAgc2NoZW1hcy5wdXNoLmFwcGx5KHNjaGVtYXMsIF9fc3ByZWFkKGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLnNjaGVtYXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGlsZU1ldGEgPSBuZXcgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKG1vZHVsZVR5cGUpLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHM6IGJvb3RzdHJhcENvbXBvbmVudHMsXG4gICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzOiBkZWNsYXJlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IGV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGRlY2xhcmVkUGlwZXM6IGRlY2xhcmVkUGlwZXMsXG4gICAgICAgICAgICBleHBvcnRlZFBpcGVzOiBleHBvcnRlZFBpcGVzLFxuICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzOiBpbXBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICBleHBvcnRlZE1vZHVsZXM6IGV4cG9ydGVkTW9kdWxlcyxcbiAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGU6IHRyYW5zaXRpdmVNb2R1bGUsXG4gICAgICAgICAgICBpZDogbWV0YS5pZCB8fCBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiB0cmFuc2l0aXZlTW9kdWxlLmFkZEVudHJ5Q29tcG9uZW50KGlkKTsgfSk7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gdHJhbnNpdGl2ZU1vZHVsZS5hZGRQcm92aWRlcihwcm92aWRlciwgY29tcGlsZU1ldGEudHlwZSk7IH0pO1xuICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZE1vZHVsZShjb21waWxlTWV0YS50eXBlKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlVHlwZSwgY29tcGlsZU1ldGEpO1xuICAgICAgICByZXR1cm4gY29tcGlsZU1ldGE7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2NoZWNrU2VsZkltcG9ydCA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZVR5cGUgPT09IGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCInXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInIG1vZHVsZSBjYW4ndCBpbXBvcnQgaXRzZWxmXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlyZWN0aXZlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNQaXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwaXBlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmdNb2R1bGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21vZHVsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUucHJvdmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcm92aWRlcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2FkZFR5cGVUb01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlLCBtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAob2xkTW9kdWxlICYmIG9sZE1vZHVsZSAhPT0gbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUeXBlIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiIGlzIHBhcnQgb2YgdGhlIGRlY2xhcmF0aW9ucyBvZiAyIG1vZHVsZXM6IFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiISBcIiArXG4gICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0byBhIGhpZ2hlciBtb2R1bGUgdGhhdCBpbXBvcnRzIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgIChcIllvdSBjYW4gYWxzbyBjcmVhdGUgYSBuZXcgTmdNb2R1bGUgdGhhdCBleHBvcnRzIGFuZCBpbmNsdWRlcyBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5VHlwZShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiLlwiKSksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5zZXQodHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgYHByb3ZpZGVyc2AgLyBgZW50cnlDb21wb25lbnRzYCBmcm9tIGFsbCBpbXBvcnRlZCBhbmQgYWxsIGV4cG9ydGVkIG1vZHVsZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoKTtcbiAgICAgICAgdmFyIG1vZHVsZXNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgICAgICBpbXBvcnRlZE1vZHVsZXMuY29uY2F0KGV4cG9ydGVkTW9kdWxlcykuZm9yRWFjaChmdW5jdGlvbiAobW9kU3VtbWFyeSkge1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZCkgeyByZXR1cm4gcmVzdWx0LmFkZE1vZHVsZShtb2QpOyB9KTtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIHJlc3VsdC5hZGRFbnRyeUNvbXBvbmVudChjb21wKTsgfSk7XG4gICAgICAgICAgICB2YXIgYWRkZWRUb2tlbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlblJlZiA9IHRva2VuUmVmZXJlbmNlKGVudHJ5LnByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldk1vZHVsZXMgPSBtb2R1bGVzQnlUb2tlbi5nZXQodG9rZW5SZWYpO1xuICAgICAgICAgICAgICAgIGlmICghcHJldk1vZHVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXNCeVRva2VuLnNldCh0b2tlblJlZiwgcHJldk1vZHVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUmVmID0gZW50cnkubW9kdWxlLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcHJvdmlkZXJzIG9mIG9uZSBtb2R1bGUgbWF5IHN0aWxsIGNvbnRhaW4gbXVsdGlwbGUgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgLy8gcGVyIHRva2VuIChlLmcuIGZvciBtdWx0aSBwcm92aWRlcnMpLCBhbmQgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGVzZS5cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWRUb2tlbnMuaGFzKHRva2VuUmVmKSB8fCAhcHJldk1vZHVsZXMuaGFzKG1vZHVsZVJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldk1vZHVsZXMuYWRkKG1vZHVsZVJlZik7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkVG9rZW5zLmFkZCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRQcm92aWRlcihlbnRyeS5wcm92aWRlciwgZW50cnkubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZEV4cG9ydGVkRGlyZWN0aXZlKGlkKTsgfSk7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5LmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkUGlwZShpZCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0SWRlbnRpZmllck1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpO1xuICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IHR5cGUgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pc0luamVjdGFibGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0b3IudHJ5QW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucy5zb21lKGZ1bmN0aW9uIChhbm4pIHsgcmV0dXJuIGNyZWF0ZUluamVjdGFibGUuaXNUeXBlT2YoYW5uKTsgfSk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW5qZWN0YWJsZVN1bW1hcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIG51bGwsIGZhbHNlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEluamVjdGFibGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzID09PSB2b2lkIDApIHsgdGhyb3dPblVua25vd25EZXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgdHlwZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeSh0eXBlLCBDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSk7XG4gICAgICAgIHZhciB0eXBlTWV0YWRhdGEgPSB0eXBlU3VtbWFyeSA/XG4gICAgICAgICAgICB0eXBlU3VtbWFyeS50eXBlIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFR5cGVNZXRhZGF0YSh0eXBlLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcyk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKS5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gY3JlYXRlSW5qZWN0YWJsZS5pc1R5cGVPZihhbm4pOyB9KTtcbiAgICAgICAgaWYgKGFubm90YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGEgPSBhbm5vdGF0aW9uc1thbm5vdGF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN5bWJvbDogdHlwZSxcbiAgICAgICAgICAgIHR5cGU6IHR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgIHByb3ZpZGVkSW46IG1ldGEucHJvdmlkZWRJbixcbiAgICAgICAgICAgIHVzZVZhbHVlOiBtZXRhLnVzZVZhbHVlLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IG1ldGEudXNlQ2xhc3MsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogbWV0YS51c2VFeGlzdGluZyxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IG1ldGEudXNlRmFjdG9yeSxcbiAgICAgICAgICAgIGRlcHM6IG1ldGEuZGVwcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aHJvd09uVW5rbm93bkRlcHMgPT09IHZvaWQgMCkgeyB0aHJvd09uVW5rbm93bkRlcHMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKHR5cGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBpZGVudGlmaWVyLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIGRpRGVwczogdGhpcy5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSxcbiAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBnZXRBbGxMaWZlY3ljbGVIb29rcyh0aGlzLl9yZWZsZWN0b3IsIGlkZW50aWZpZXIucmVmZXJlbmNlKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RmFjdG9yeU1ldGFkYXRhID0gZnVuY3Rpb24gKGZhY3RvcnksIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICBmYWN0b3J5ID0gcmVzb2x2ZUZvcndhcmRSZWYoZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiB7IHJlZmVyZW5jZTogZmFjdG9yeSwgZGlEZXBzOiB0aGlzLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShmYWN0b3J5LCBkZXBlbmRlbmNpZXMpIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBmb3IgdGhlIGdpdmVuIHBpcGUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IGdldFBpcGVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBQaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZU1ldGEgfHwgbnVsbDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlU3VtbWFyeSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICB2YXIgcGlwZVN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeShwaXBlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUpO1xuICAgICAgICBpZiAoIXBpcGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBwaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVN1bW1hcnk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0T3JMb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciBwaXBlTWV0YSA9IHRoaXMuX3BpcGVDYWNoZS5nZXQocGlwZVR5cGUpO1xuICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICBwaXBlTWV0YSA9IHRoaXMuX2xvYWRQaXBlTWV0YWRhdGEocGlwZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fbG9hZFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSkge1xuICAgICAgICBwaXBlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHBpcGVUeXBlKTtcbiAgICAgICAgdmFyIHBpcGVBbm5vdGF0aW9uID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUpO1xuICAgICAgICB2YXIgcGlwZU1ldGEgPSBuZXcgQ29tcGlsZVBpcGVNZXRhZGF0YSh7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUpLFxuICAgICAgICAgICAgbmFtZTogcGlwZUFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICAgIHB1cmU6ICEhcGlwZUFubm90YXRpb24ucHVyZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLnNldChwaXBlVHlwZSwgcGlwZU1ldGEpO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHBpcGVUeXBlLCBwaXBlTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyA9PT0gdm9pZCAwKSB7IHRocm93T25Vbmtub3duRGVwcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIGhhc1Vua25vd25EZXBzID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBkZXBlbmRlbmNpZXMgfHwgdGhpcy5fcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYykgfHwgW107XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXNNZXRhZGF0YSA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgaXNBdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc1NraXBTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUhvc3QuaXNUeXBlT2YocGFyYW1FbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlU2VsZi5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjcmVhdGVTa2lwU2VsZi5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlT3B0aW9uYWwuaXNUeXBlT2YocGFyYW1FbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZUF0dHJpYnV0ZS5pc1R5cGVPZihwYXJhbUVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSW5qZWN0LmlzVHlwZU9mKHBhcmFtRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlSW5qZWN0aW9uVG9rZW4uaXNUeXBlT2YocGFyYW1FbnRyeSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtRW50cnkgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwYXJhbUVudHJ5KSAmJiB0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgICAgICBpc1NlbGY6IGlzU2VsZixcbiAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgdG9rZW46IF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHRva2VuKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNVbmtub3duRGVwcykge1xuICAgICAgICAgICAgdmFyIGRlcHNUb2tlbnMgPSBkZXBlbmRlbmNpZXNNZXRhZGF0YS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwLnRva2VuID8gc3RyaW5naWZ5VHlwZShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkNhbid0IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiOiAoXCIgKyBkZXBzVG9rZW5zICsgXCIpLlwiO1xuICAgICAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcyB8fCB0aGlzLl9jb25maWcuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKG1lc3NhZ2UpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIldhcm5pbmc6IFwiICsgbWVzc2FnZSArIFwiIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gQW5ndWxhciB2Ni54XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNNZXRhZGF0YTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VG9rZW5NZXRhZGF0YSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgdmFyIGNvbXBpbGVUb2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUb2tlbiA9IHsgdmFsdWU6IHRva2VuIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlVG9rZW4gPSB7IGlkZW50aWZpZXI6IHsgcmVmZXJlbmNlOiB0b2tlbiB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVUb2tlbjtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbywgY29tcGlsZVByb3ZpZGVycywgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVQcm92aWRlcnMgPSBbXTsgfVxuICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIsIHByb3ZpZGVySWR4KSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvLCBjb21waWxlUHJvdmlkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcmVzb2x2ZUZvcndhcmRSZWYocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlck1ldGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXIuaGFzT3duUHJvcGVydHkoJ3Byb3ZpZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YSA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlciwgeyB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRW5jb3VudGVyZWQgdW5kZWZpbmVkIHByb3ZpZGVyISBVc3VhbGx5IHRoaXMgbWVhbnMgeW91IGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFRoaXMgbWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nICdiYXJyZWwnIGluZGV4LnRzIGZpbGVzLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlcnNJbmZvID0gcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChzb0Zhciwgc2VlblByb3ZpZGVyLCBzZWVuUHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCJcIiArIHN0cmluZ2lmeVR5cGUoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWVuUHJvdmlkZXJJZHggPT0gcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5VHlwZShzZWVuUHJvdmlkZXIpICsgXCI/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbnZhbGlkIFwiICsgKGRlYnVnSW5mbyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z0luZm8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3ZpZGVyJykgKyBcIiAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFtcIiArIHByb3ZpZGVyc0luZm8gKyBcIl1cIiksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlck1ldGEudG9rZW4gPT09XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KHRhcmdldEVudHJ5Q29tcG9uZW50cywgX19zcHJlYWQoX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlcihwcm92aWRlck1ldGEsIHR5cGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXJzLnB1c2goX3RoaXMuZ2V0UHJvdmlkZXJNZXRhZGF0YShwcm92aWRlck1ldGEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcGlsZVByb3ZpZGVycztcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fdmFsaWRhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICBpZiAocHJvdmlkZXIuaGFzT3duUHJvcGVydHkoJ3VzZUNsYXNzJykgJiYgcHJvdmlkZXIudXNlQ2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIGZvciBcIiArIHN0cmluZ2lmeVR5cGUocHJvdmlkZXIucHJvdmlkZSkgKyBcIi4gdXNlQ2xhc3MgY2Fubm90IGJlIFwiICsgcHJvdmlkZXIudXNlQ2xhc3MgKyBcIi5cXG4gICAgICAgICAgIFVzdWFsbHkgaXQgaGFwcGVucyB3aGVuOlxcbiAgICAgICAgICAgMS4gVGhlcmUncyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgKG1pZ2h0IGJlIGNhdXNlZCBieSB1c2luZyBpbmRleC50cyAoYmFycmVsKSBmaWxlcykuXFxuICAgICAgICAgICAyLiBDbGFzcyB3YXMgdXNlZCBiZWZvcmUgaXQgd2FzIGRlY2xhcmVkLiBVc2UgZm9yd2FyZFJlZiBpbiB0aGlzIGNhc2UuXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbGxlY3RlZElkZW50aWZpZXJzID0gW107XG4gICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgY29sbGVjdGVkSWRlbnRpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RW50cnlDb21wb25lbnRNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIGRpck1ldGEgPSB0aGlzLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJUeXBlKTtcbiAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5tZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50VHlwZTogZGlyVHlwZSwgY29tcG9uZW50RmFjdG9yeTogZGlyTWV0YS5tZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpclN1bW1hcnkgPSB0aGlzLl9sb2FkU3VtbWFyeShkaXJUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlKTtcbiAgICAgICAgaWYgKGRpclN1bW1hcnkgJiYgZGlyU3VtbWFyeS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50VHlwZTogZGlyVHlwZSwgY29tcG9uZW50RmFjdG9yeTogZGlyU3VtbWFyeS5jb21wb25lbnRGYWN0b3J5IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoZGlyVHlwZS5uYW1lICsgXCIgY2Fubm90IGJlIHVzZWQgYXMgYW4gZW50cnkgY29tcG9uZW50LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0SW5qZWN0YWJsZVR5cGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7IGRlcGVuZGVuY2llcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIHR5cGVTdW1tYXJ5ID0gdGhpcy5fbG9hZFN1bW1hcnkodHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUpO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU3VtbWFyeS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9O1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQcm92aWRlck1ldGFkYXRhID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBjb21waWxlRGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB2YXIgY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUeXBlTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgIHRoaXMuX2dldEluamVjdGFibGVUeXBlTWV0YWRhdGEocHJvdmlkZXIudXNlQ2xhc3MsIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVUeXBlTWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnRva2VuID09PSBwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY29tcGlsZVR5cGVNZXRhZGF0YSBhcyBpdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBsaWZlY3ljbGVIb29rcy4uLlxuICAgICAgICAgICAgICAgIHRva2VuID0geyBpZGVudGlmaWVyOiBjb21waWxlVHlwZU1ldGFkYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IHRoaXMuX2dldEZhY3RvcnlNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlRmFjdG9yeU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbXBpbGVUeXBlTWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VWYWx1ZTogcHJvdmlkZXIudXNlVmFsdWUsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBjb21waWxlRmFjdG9yeU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHByb3ZpZGVyLnVzZUV4aXN0aW5nID8gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci51c2VFeGlzdGluZykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZXBzOiBjb21waWxlRGVwcyxcbiAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnksIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhxdWVyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHF1ZXJpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5pc1ZpZXdRdWVyeSA9PT0gaXNWaWV3UXVlcnkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChfdGhpcy5fZ2V0UXVlcnlNZXRhZGF0YShxdWVyeSwgcHJvcGVydHlOYW1lLCBkaXJlY3RpdmVUeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9xdWVyeVZhckJpbmRpbmdzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgfTtcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFF1ZXJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAocSwgcHJvcGVydHlOYW1lLCB0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgIGlmICh0eXBlb2YgcS5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlWYXJCaW5kaW5ncyhxLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHEuc2VsZWN0b3IpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICBmaXJzdDogcS5maXJzdCxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxLmRlc2NlbmRhbnRzLFxuICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICByZWFkOiBxLnJlYWQgPyB0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHEucmVhZCkgOiBudWxsLFxuICAgICAgICAgICAgc3RhdGljOiBxLnN0YXRpY1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgdHlwZSwgb3RoZXJUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvckNvbGxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IoZXJyb3IsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKG90aGVyVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yQ29sbGVjdG9yKGVycm9yLCBvdGhlclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcjtcbn0oKSk7XG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkodHJlZSwgb3V0KSB7XG4gICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IFtdOyB9XG4gICAgaWYgKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHJlc29sdmVGb3J3YXJkUmVmKHRyZWVbaV0pO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkoaXRlbSwgb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBkZWR1cGVBcnJheShhcnJheSkge1xuICAgIGlmIChhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5BbmREZWR1cGVBcnJheSh0cmVlKSB7XG4gICAgcmV0dXJuIGRlZHVwZUFycmF5KGZsYXR0ZW5BcnJheSh0cmVlKSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIFR5cGUpO1xufVxuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHZhbHVlLCB0YXJnZXRJZGVudGlmaWVycykge1xuICAgIHZpc2l0VmFsdWUodmFsdWUsIG5ldyBfQ29tcGlsZVZhbHVlQ29udmVydGVyKCksIHRhcmdldElkZW50aWZpZXJzKTtcbn1cbnZhciBfQ29tcGlsZVZhbHVlQ29udmVydGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfQ29tcGlsZVZhbHVlQ29udmVydGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgICAgdGFyZ2V0SWRlbnRpZmllcnMucHVzaCh7IHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuZnVuY3Rpb24gc3RyaW5naWZ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSArIFwiIGluIFwiICsgdHlwZS5maWxlUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodHlwZSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyBsb2FkZWQgaW4gYSBzeW5jaHJvbm91cyBjb21waWxlLlxuICovXG5mdW5jdGlvbiBjb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihjb21wVHlwZSkge1xuICAgIHZhciBlcnJvciA9IEVycm9yKFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIHN0aWxsIGJlaW5nIGxvYWRlZCFcIik7XG4gICAgZXJyb3JbRVJST1JfQ09NUE9ORU5UX1RZUEVdID0gY29tcFR5cGU7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBwcm92aWRlckRlZihjdHgsIHByb3ZpZGVyQXN0KSB7XG4gICAgdmFyIGZsYWdzID0gMCAvKiBOb25lICovO1xuICAgIGlmICghcHJvdmlkZXJBc3QuZWFnZXIpIHtcbiAgICAgICAgZmxhZ3MgfD0gNDA5NiAvKiBMYXp5UHJvdmlkZXIgKi87XG4gICAgfVxuICAgIGlmIChwcm92aWRlckFzdC5wcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSkge1xuICAgICAgICBmbGFncyB8PSA4MTkyIC8qIFByaXZhdGVQcm92aWRlciAqLztcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyQXN0LmlzTW9kdWxlKSB7XG4gICAgICAgIGZsYWdzIHw9IDEwNzM3NDE4MjQgLyogVHlwZU1vZHVsZVByb3ZpZGVyICovO1xuICAgIH1cbiAgICBwcm92aWRlckFzdC5saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgIC8vIGZvciByZWd1bGFyIHByb3ZpZGVycywgd2Ugb25seSBzdXBwb3J0IG5nT25EZXN0cm95XG4gICAgICAgIGlmIChsaWZlY3ljbGVIb29rID09PSBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kgfHxcbiAgICAgICAgICAgIHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBmbGFncyB8PSBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBfYSA9IHByb3ZpZGVyQXN0Lm11bHRpUHJvdmlkZXIgP1xuICAgICAgICBtdWx0aVByb3ZpZGVyRGVmKGN0eCwgZmxhZ3MsIHByb3ZpZGVyQXN0LnByb3ZpZGVycykgOlxuICAgICAgICBzaW5nbGVQcm92aWRlckRlZihjdHgsIGZsYWdzLCBwcm92aWRlckFzdC5wcm92aWRlclR5cGUsIHByb3ZpZGVyQXN0LnByb3ZpZGVyc1swXSksIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgcHJvdmlkZXJGbGFncyA9IF9hLmZsYWdzLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLFxuICAgICAgICBmbGFnczogcHJvdmlkZXJGbGFncyxcbiAgICAgICAgZGVwc0V4cHI6IGRlcHNFeHByLFxuICAgICAgICB0b2tlbkV4cHI6IHRva2VuRXhwcihjdHgsIHByb3ZpZGVyQXN0LnRva2VuKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbXVsdGlQcm92aWRlckRlZihjdHgsIGZsYWdzLCBwcm92aWRlcnMpIHtcbiAgICB2YXIgYWxsRGVwRGVmcyA9IFtdO1xuICAgIHZhciBhbGxQYXJhbXMgPSBbXTtcbiAgICB2YXIgZXhwcnMgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICB2YXIgZXhwcjtcbiAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcyk7XG4gICAgICAgICAgICBleHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MucmVmZXJlbmNlKS5pbnN0YW50aWF0ZShkZXBFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGRlcEV4cHJzID0gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcyk7XG4gICAgICAgICAgICBleHByID0gY3R4LmltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeS5yZWZlcmVuY2UpLmNhbGxGbihkZXBFeHBycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHZhciBkZXBFeHBycyA9IGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIFt7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9XSk7XG4gICAgICAgICAgICBleHByID0gZGVwRXhwcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHByID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCBwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfSk7XG4gICAgdmFyIHByb3ZpZGVyRXhwciA9IGZuKGFsbFBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihleHBycykpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdmlkZXJFeHByOiBwcm92aWRlckV4cHIsXG4gICAgICAgIGZsYWdzOiBmbGFncyB8IDEwMjQgLyogVHlwZUZhY3RvcnlQcm92aWRlciAqLyxcbiAgICAgICAgZGVwc0V4cHI6IGxpdGVyYWxBcnIoYWxsRGVwRGVmcylcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIGRlcHMpIHtcbiAgICAgICAgcmV0dXJuIGRlcHMubWFwKGZ1bmN0aW9uIChkZXAsIGRlcEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1OYW1lID0gXCJwXCIgKyBwcm92aWRlckluZGV4ICsgXCJfXCIgKyBkZXBJbmRleDtcbiAgICAgICAgICAgIGFsbFBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHBhcmFtTmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICBhbGxEZXBEZWZzLnB1c2goZGVwRGVmKGN0eCwgZGVwKSk7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGUocGFyYW1OYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2luZ2xlUHJvdmlkZXJEZWYoY3R4LCBmbGFncywgcHJvdmlkZXJUeXBlLCBwcm92aWRlck1ldGEpIHtcbiAgICB2YXIgcHJvdmlkZXJFeHByO1xuICAgIHZhciBkZXBzO1xuICAgIGlmIChwcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgfHwgcHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgIHByb3ZpZGVyRXhwciA9IGN0eC5pbXBvcnRFeHByKHByb3ZpZGVyTWV0YS51c2VDbGFzcy5yZWZlcmVuY2UpO1xuICAgICAgICBmbGFncyB8PSAxNjM4NCAvKiBUeXBlRGlyZWN0aXZlICovO1xuICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUNsYXNzLmRpRGVwcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwcm92aWRlck1ldGEudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyRXhwciA9IGN0eC5pbXBvcnRFeHByKHByb3ZpZGVyTWV0YS51c2VDbGFzcy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gNTEyIC8qIFR5cGVDbGFzc1Byb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IHByb3ZpZGVyTWV0YS5kZXBzIHx8IHByb3ZpZGVyTWV0YS51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXJNZXRhLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyRXhwciA9IGN0eC5pbXBvcnRFeHByKHByb3ZpZGVyTWV0YS51c2VGYWN0b3J5LnJlZmVyZW5jZSk7XG4gICAgICAgICAgICBmbGFncyB8PSAxMDI0IC8qIFR5cGVGYWN0b3J5UHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyTWV0YS51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gTlVMTF9FWFBSO1xuICAgICAgICAgICAgZmxhZ3MgfD0gMjA0OCAvKiBUeXBlVXNlRXhpc3RpbmdQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBbeyB0b2tlbjogcHJvdmlkZXJNZXRhLnVzZUV4aXN0aW5nIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoY3R4LCBwcm92aWRlck1ldGEudXNlVmFsdWUpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gMjU2IC8qIFR5cGVWYWx1ZVByb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkZXBzRXhwciA9IGxpdGVyYWxBcnIoZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwRGVmKGN0eCwgZGVwKTsgfSkpO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogZmxhZ3MsIGRlcHNFeHByOiBkZXBzRXhwciB9O1xufVxuZnVuY3Rpb24gdG9rZW5FeHByKGN0eCwgdG9rZW5NZXRhKSB7XG4gICAgcmV0dXJuIHRva2VuTWV0YS5pZGVudGlmaWVyID8gY3R4LmltcG9ydEV4cHIodG9rZW5NZXRhLmlkZW50aWZpZXIucmVmZXJlbmNlKSA6XG4gICAgICAgIGxpdGVyYWwodG9rZW5NZXRhLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIGRlcERlZihjdHgsIGRlcCkge1xuICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgZmllbGRzIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgb3V0IGJ5IHByb3ZpZGVyX2FuYWx5emVyOlxuICAgIC8vIC0gaXNBdHRyaWJ1dGUsIGlzSG9zdFxuICAgIHZhciBleHByID0gZGVwLmlzVmFsdWUgPyBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjdHgsIGRlcC52YWx1ZSkgOiB0b2tlbkV4cHIoY3R4LCBkZXAudG9rZW4pO1xuICAgIHZhciBmbGFncyA9IDAgLyogTm9uZSAqLztcbiAgICBpZiAoZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgZmxhZ3MgfD0gMSAvKiBTa2lwU2VsZiAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgIGZsYWdzIHw9IDIgLyogT3B0aW9uYWwgKi87XG4gICAgfVxuICAgIGlmIChkZXAuaXNTZWxmKSB7XG4gICAgICAgIGZsYWdzIHw9IDQgLyogU2VsZiAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgIGZsYWdzIHw9IDggLyogVmFsdWUgKi87XG4gICAgfVxuICAgIHJldHVybiBmbGFncyA9PT0gMCAvKiBOb25lICovID8gZXhwciA6IGxpdGVyYWxBcnIoW2xpdGVyYWwoZmxhZ3MpLCBleHByXSk7XG59XG5mdW5jdGlvbiBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKSB7XG4gICAgdmFyIG5vZGVGbGFnID0gMCAvKiBOb25lICovO1xuICAgIHN3aXRjaCAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDIwOTcxNTIgLyogQWZ0ZXJDb250ZW50Q2hlY2tlZCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDEwNDg1NzYgLyogQWZ0ZXJDb250ZW50SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDgzODg2MDggLyogQWZ0ZXJWaWV3Q2hlY2tlZCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDQxOTQzMDQgLyogQWZ0ZXJWaWV3SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDI2MjE0NCAvKiBEb0NoZWNrICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA1MjQyODggLyogT25DaGFuZ2VzICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSAxMzEwNzIgLyogT25EZXN0cm95ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25Jbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA2NTUzNiAvKiBPbkluaXQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVGbGFnO1xufVxuZnVuY3Rpb24gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyUHJvdmlkZXJEZWYocmVmbGVjdG9yLCBjdHgsIGZsYWdzLCBlbnRyeUNvbXBvbmVudHMpIHtcbiAgICB2YXIgZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBlbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkgeyByZXR1cm4gY3R4LmltcG9ydEV4cHIoZW50cnlDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeSk7IH0pO1xuICAgIHZhciB0b2tlbiA9IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UocmVmbGVjdG9yLCBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgIHZhciBjbGFzc01ldGEgPSB7XG4gICAgICAgIGRpRGVwczogW1xuICAgICAgICAgICAgeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbGl0ZXJhbEFycihlbnRyeUNvbXBvbmVudEZhY3RvcmllcykgfSxcbiAgICAgICAgICAgIHsgdG9rZW46IHRva2VuLCBpc1NraXBTZWxmOiB0cnVlLCBpc09wdGlvbmFsOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHRva2VuOiBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHJlZmxlY3RvciwgSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYpIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxpZmVjeWNsZUhvb2tzOiBbXSxcbiAgICAgICAgcmVmZXJlbmNlOiByZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpXG4gICAgfTtcbiAgICB2YXIgX2EgPSBzaW5nbGVQcm92aWRlckRlZihjdHgsIGZsYWdzLCBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIHtcbiAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICBtdWx0aTogZmFsc2UsXG4gICAgICAgIHVzZUNsYXNzOiBjbGFzc01ldGEsXG4gICAgfSksIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgcHJvdmlkZXJGbGFncyA9IF9hLmZsYWdzLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogcHJvdmlkZXJGbGFncywgZGVwc0V4cHI6IGRlcHNFeHByLCB0b2tlbkV4cHI6IHRva2VuRXhwcihjdHgsIHRva2VuKSB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTmdNb2R1bGVDb21waWxlUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZVJlc3VsdChuZ01vZHVsZUZhY3RvcnlWYXIpIHtcbiAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgfVxuICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIExPR19WQVIgPSB2YXJpYWJsZSgnX2wnKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5nTW9kdWxlQ29tcGlsZXIocmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgIH1cbiAgICBOZ01vZHVsZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGN0eCwgbmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycykge1xuICAgICAgICB2YXIgc291cmNlU3BhbiA9IHR5cGVTb3VyY2VTcGFuKCdOZ01vZHVsZScsIG5nTW9kdWxlTWV0YS50eXBlKTtcbiAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gbmdNb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZW50cnlDb21wb25lbnRzO1xuICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50cyA9IG5nTW9kdWxlTWV0YS5ib290c3RyYXBDb21wb25lbnRzO1xuICAgICAgICB2YXIgcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKHRoaXMucmVmbGVjdG9yLCBuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyRGVmcyA9IFtjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlckRlZih0aGlzLnJlZmxlY3RvciwgY3R4LCAwIC8qIE5vbmUgKi8sIGVudHJ5Q29tcG9uZW50RmFjdG9yaWVzKV1cbiAgICAgICAgICAgIC5jb25jYXQocHJvdmlkZXJQYXJzZXIucGFyc2UoKS5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBwcm92aWRlckRlZihjdHgsIHByb3ZpZGVyKTsgfSkpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwciwgZmxhZ3MgPSBfYS5mbGFncywgdG9rZW5FeHByID0gX2EudG9rZW5FeHByO1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMubW9kdWxlUHJvdmlkZXJEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIHRva2VuRXhwciwgcHJvdmlkZXJFeHByLCBkZXBzRXhwclxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmdNb2R1bGVEZWYgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLm1vZHVsZURlZikuY2FsbEZuKFtsaXRlcmFsQXJyKHByb3ZpZGVyRGVmcyldKTtcbiAgICAgICAgdmFyIG5nTW9kdWxlRGVmRmFjdG9yeSA9IGZuKFtuZXcgRm5QYXJhbShMT0dfVkFSLm5hbWUpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobmdNb2R1bGVEZWYpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnlWYXIgPSBpZGVudGlmaWVyTmFtZShuZ01vZHVsZU1ldGEudHlwZSkgKyBcIk5nRmFjdG9yeVwiO1xuICAgICAgICB0aGlzLl9jcmVhdGVOZ01vZHVsZUZhY3RvcnkoY3R4LCBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY3JlYXRlTW9kdWxlRmFjdG9yeSkuY2FsbEZuKFtcbiAgICAgICAgICAgIGN0eC5pbXBvcnRFeHByKG5nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKGJvb3RzdHJhcENvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gY3R4LmltcG9ydEV4cHIoaWQucmVmZXJlbmNlKTsgfSkpLFxuICAgICAgICAgICAgbmdNb2R1bGVEZWZGYWN0b3J5XG4gICAgICAgIF0pKTtcbiAgICAgICAgaWYgKG5nTW9kdWxlTWV0YS5pZCkge1xuICAgICAgICAgICAgdmFyIGlkID0gdHlwZW9mIG5nTW9kdWxlTWV0YS5pZCA9PT0gJ3N0cmluZycgPyBsaXRlcmFsKG5nTW9kdWxlTWV0YS5pZCkgOlxuICAgICAgICAgICAgICAgIGN0eC5pbXBvcnRFeHByKG5nTW9kdWxlTWV0YS5pZCk7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJGYWN0b3J5U3RtdCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4pXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbaWQsIHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcildKVxuICAgICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICAgIGN0eC5zdGF0ZW1lbnRzLnB1c2gocmVnaXN0ZXJGYWN0b3J5U3RtdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOZ01vZHVsZUNvbXBpbGVSZXN1bHQobmdNb2R1bGVGYWN0b3J5VmFyKTtcbiAgICB9O1xuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNyZWF0ZVN0dWIgPSBmdW5jdGlvbiAoY3R4LCBuZ01vZHVsZVJlZmVyZW5jZSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVOZ01vZHVsZUZhY3RvcnkoY3R4LCBuZ01vZHVsZVJlZmVyZW5jZSwgTlVMTF9FWFBSKTtcbiAgICB9O1xuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVOZ01vZHVsZUZhY3RvcnkgPSBmdW5jdGlvbiAoY3R4LCByZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnlWYXIgPSBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0pICsgXCJOZ0ZhY3RvcnlcIjtcbiAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVN0bXQgPSB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXG4gICAgICAgICAgICAuc2V0KHZhbHVlKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnksIFtleHByZXNzaW9uVHlwZShjdHguaW1wb3J0RXhwcihyZWZlcmVuY2UpKV0sIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSwgW1N0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSk7XG4gICAgICAgIGN0eC5zdGF0ZW1lbnRzLnB1c2gobmdNb2R1bGVGYWN0b3J5U3RtdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUmVzb2x2ZXMgdHlwZXMgdG8ge0BsaW5rIE5nTW9kdWxlfS5cbiAqL1xudmFyIE5nTW9kdWxlUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmdNb2R1bGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIE5nTW9kdWxlUmVzb2x2ZXIucHJvdG90eXBlLmlzTmdNb2R1bGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpLnNvbWUoY3JlYXRlTmdNb2R1bGUuaXNUeXBlT2YpO1xuICAgIH07XG4gICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIG5nTW9kdWxlTWV0YSA9IGZpbmRMYXN0KHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKSwgY3JlYXRlTmdNb2R1bGUuaXNUeXBlT2YpO1xuICAgICAgICBpZiAobmdNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5nTW9kdWxlIG1ldGFkYXRhIGZvdW5kIGZvciAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIicuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZVJlc29sdmVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9kZWJ1Z0ZpbGVQYXRoID0gJy9kZWJ1Zy9saWInO1xuZnVuY3Rpb24gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcigpO1xuICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCgpO1xuICAgIHZhciBhc3RzID0gQXJyYXkuaXNBcnJheShhc3QpID8gYXN0IDogW2FzdF07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0YXRlbWVudCkge1xuICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBhc3QudmlzaXRFeHByZXNzaW9uKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBUeXBlJDEpIHtcbiAgICAgICAgICAgIGFzdC52aXNpdFR5cGUoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3Qga25vdyBob3cgdG8gcHJpbnQgZGVidWcgaW5mbyBmb3IgXCIgKyBhc3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eC50b1NvdXJjZSgpO1xufVxudmFyIFR5cGVTY3JpcHRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKCkge1xuICAgIH1cbiAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHNBbmRDb250ZXh0ID0gZnVuY3Rpb24gKGdlbkZpbGVQYXRoLCBzdG10cywgcHJlYW1ibGUsIGVtaXRTb3VyY2VNYXBzLCByZWZlcmVuY2VGaWx0ZXIsIGltcG9ydEZpbHRlcikge1xuICAgICAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgICAgIGlmIChlbWl0U291cmNlTWFwcyA9PT0gdm9pZCAwKSB7IGVtaXRTb3VyY2VNYXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKHJlZmVyZW5jZUZpbHRlciwgaW1wb3J0RmlsdGVyKTtcbiAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KCk7XG4gICAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIGN0eCk7XG4gICAgICAgIHZhciBwcmVhbWJsZUxpbmVzID0gcHJlYW1ibGUgPyBwcmVhbWJsZS5zcGxpdCgnXFxuJykgOiBbXTtcbiAgICAgICAgY29udmVydGVyLnJlZXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWV4cG9ydHMsIGV4cG9ydGVkTW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlZXhwb3J0c0NvZGUgPSByZWV4cG9ydHMubWFwKGZ1bmN0aW9uIChyZWV4cG9ydCkgeyByZXR1cm4gcmVleHBvcnQubmFtZSArIFwiIGFzIFwiICsgcmVleHBvcnQuYXM7IH0pLmpvaW4oJywnKTtcbiAgICAgICAgICAgIHByZWFtYmxlTGluZXMucHVzaChcImV4cG9ydCB7XCIgKyByZWV4cG9ydHNDb2RlICsgXCJ9IGZyb20gJ1wiICsgZXhwb3J0ZWRNb2R1bGVOYW1lICsgXCInO1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYW4ndCB3cml0ZSB0aGUgcmVhbCB3b3JkIGZvciBpbXBvcnQgYXMgaXQgc2NyZXdzIHVwIHN5c3RlbS5qcyBhdXRvIGRldGVjdGlvbi4uLlxuICAgICAgICAgICAgcHJlYW1ibGVMaW5lcy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBpbXBvcnRlZE1vZHVsZU5hbWUgKyBcIic7XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbSA9IGVtaXRTb3VyY2VNYXBzID9cbiAgICAgICAgICAgIGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCwgcHJlYW1ibGVMaW5lcy5sZW5ndGgpLnRvSnNDb21tZW50KCkgOlxuICAgICAgICAgICAgJyc7XG4gICAgICAgIHZhciBsaW5lcyA9IF9fc3ByZWFkKHByZWFtYmxlTGluZXMsIFtjdHgudG9Tb3VyY2UoKSwgc21dKTtcbiAgICAgICAgaWYgKHNtKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgYWRkIGEgbmV3bGluZSBhdCB0aGUgZW5kLCBhcyBzb21lIHRvb2xzIGhhdmUgYnVncyB3aXRob3V0IGl0LlxuICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFByZWFtYmxlTGluZUNvdW50KHByZWFtYmxlTGluZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHsgc291cmNlVGV4dDogbGluZXMuam9pbignXFxuJyksIGNvbnRleHQ6IGN0eCB9O1xuICAgIH07XG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKGdlbkZpbGVQYXRoLCBzdG10cywgcHJlYW1ibGUpIHtcbiAgICAgICAgaWYgKHByZWFtYmxlID09PSB2b2lkIDApIHsgcHJlYW1ibGUgPSAnJzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0U3RhdGVtZW50c0FuZENvbnRleHQoZ2VuRmlsZVBhdGgsIHN0bXRzLCBwcmVhbWJsZSkuc291cmNlVGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlU2NyaXB0RW1pdHRlcjtcbn0oKSk7XG52YXIgX1RzRW1pdHRlclZpc2l0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Uc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKHJlZmVyZW5jZUZpbHRlciwgaW1wb3J0RmlsdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWZlcmVuY2VGaWx0ZXIgPSByZWZlcmVuY2VGaWx0ZXI7XG4gICAgICAgIF90aGlzLmltcG9ydEZpbHRlciA9IGltcG9ydEZpbHRlcjtcbiAgICAgICAgX3RoaXMudHlwZUV4cHJlc3Npb24gPSAwO1xuICAgICAgICBfdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5yZWV4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh0LCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmIChkZWZhdWx0VHlwZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUeXBlID0gJ2FueSc7IH1cbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHQudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIGFzdC50eXBlICE9IElORkVSUkVEX1RZUEUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiICsgdmFsdWUgKyBcIiBhcyBhbnkpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICB9O1xuICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgc3RyaWN0TnVsbENoZWNrIGVuYWJsZWQgY29uc3VtZXJzIG9mIG5nYyBlbWl0LlxuICAgIC8vIEluIFNOQyBtb2RlLCBbXSBoYXZlIHRoZSB0eXBlIG5ldmVyW10sIHNvIHdlIGNhc3QgaGVyZSB0byBhbnlbXS5cbiAgICAvLyBUT0RPOiBuYXJyb3cgdGhlIGNhc3QgdG8gYSBtb3JlIGV4cGxpY2l0IHR5cGUsIG9yIHVzZSBhIHBhdHRlcm4gdGhhdCBkb2VzIG5vdFxuICAgIC8vIHN0YXJ0IHdpdGggW10uY29uY2F0LiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzExODQ2XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyBhcyBhbnlbXSknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFzc2VydE5vdE51bGxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBfc3VwZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSAmJiBzdG10LnZhbHVlIGluc3RhbmNlb2YgRXh0ZXJuYWxFeHByICYmXG4gICAgICAgICAgICAhc3RtdC50eXBlKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSByZWV4cG9ydFxuICAgICAgICAgICAgdmFyIF9hID0gc3RtdC52YWx1ZS52YWx1ZSwgbmFtZV8xID0gX2EubmFtZSwgbW9kdWxlTmFtZSA9IF9hLm1vZHVsZU5hbWU7XG4gICAgICAgICAgICBpZiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZWV4cG9ydHMgPSB0aGlzLnJlZXhwb3J0cy5nZXQobW9kdWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVleHBvcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVleHBvcnRzLnNldChtb2R1bGVOYW1lLCByZWV4cG9ydHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWV4cG9ydHMucHVzaCh7IG5hbWU6IG5hbWVfMSwgYXM6IHN0bXQubmFtZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5GaW5hbCkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcImNvbnN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwidmFyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIiBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKHN0bXQudHlwZSwgY3R4KTtcbiAgICAgICAgaWYgKHN0bXQudmFsdWUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcIiA9IFwiKTtcbiAgICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCI7XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyYXBwZWROb2RlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB2aXNpdCBhIFdyYXBwZWROb2RlRXhwciB3aGVuIG91dHB1dHRpbmcgVHlwZXNjcmlwdC4nKTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKDxcIik7XG4gICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIj5cIik7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdGhpcy50eXBlRXhwcmVzc2lvbi0tO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjbGFzcyBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHN0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0ZpZWxkKGZpZWxkLCBjdHgpOyB9KTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2QobWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0ZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCBjdHgpIHtcbiAgICAgICAgaWYgKGZpZWxkLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgLy8gY29tbWVudCBvdXQgYXMgYSB3b3JrYXJvdW5kIGZvciAjMTA5NjdcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIi8qcHJpdmF0ZSovIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlN0YXRpYykpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnc3RhdGljICcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZmllbGQudHlwZSwgY3R4KTtcbiAgICAgICAgaWYgKGZpZWxkLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJyA9ICcpO1xuICAgICAgICAgICAgZmllbGQuaW5pdGlhbGl6ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCI7XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKGdldHRlciwgY3R4KSB7XG4gICAgICAgIGlmIChnZXR0ZXIuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiKClcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKGdldHRlci50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwifVwiKTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjb25zdHJ1Y3RvcihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgIGlmIChtZXRob2QuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgbWV0aG9kLm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIilcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCJ9XCIpO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGlmIChhc3QubmFtZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJ2Z1bmN0aW9uICcpO1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBpZiAoIWFzdC5uYW1lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIiA9PiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oYXN0LCAneycpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoc3RtdC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgY2F0Y2hTdG10cyA9IFtDQVRDSF9TVEFDS19WQVIkMS5zZXQoQ0FUQ0hfRVJST1JfVkFSJDEucHJvcCgnc3RhY2snLCBudWxsKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICBdKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJ1aWx0aW5UeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICB2YXIgdHlwZVN0cjtcbiAgICAgICAgc3dpdGNoICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdib29sZWFuJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdhbnknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdGdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5Ob25lOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbmV2ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBidWlsdGluIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCB0eXBlU3RyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uVHlwZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChhc3QudHlwZVBhcmFtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICc8Jyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCk7IH0sIGFzdC50eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJz4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS5vZiwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwiW11cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLnZhbHVlVHlwZSwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5fcHJpbnRDb2xvblR5cGUocGFyYW0udHlwZSwgY3R4KTtcbiAgICAgICAgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgfTtcbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0SWRlbnRpZmllciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZVBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSwgbW9kdWxlTmFtZSA9IHZhbHVlLm1vZHVsZU5hbWU7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZUZpbHRlciAmJiB0aGlzLnJlZmVyZW5jZUZpbHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCAnKG51bGwgYXMgYW55KScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVOYW1lICYmICghdGhpcy5pbXBvcnRGaWx0ZXIgfHwgIXRoaXMuaW1wb3J0RmlsdGVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gXCJpXCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2V0KG1vZHVsZU5hbWUsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgcHJlZml4ICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZUV4cHJlc3Npb24gPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSB0eXBlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYSBnZW5lcmljIHR5cGUgdGhlbiBzdXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlIHBhcmFtZXRlcnMuIElmIHRoZXJlIHdlcmUgbm90IGVub3VnaCB0eXBlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkLCBzdXBwbHkgYW55IGFzIHRoZSB0eXBlLiBPdXRzaWRlIGEgdHlwZSBleHByZXNzaW9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3VwcGx5IHR5cGUgcGFyYW1ldGVycyBhbmQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICAgICAgICB2YXIgc3VwcGxpZWRQYXJhbWV0ZXJzID0gdHlwZVBhcmFtcyB8fCBbXTtcbiAgICAgICAgICAgIGlmIChzdXBwbGllZFBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIjxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUudmlzaXRUeXBlKF90aGlzLCBjdHgpOyB9LCB0eXBlUGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9wcmludENvbG9uVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSBJTkZFUlJFRF9UWVBFKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJzonKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUsIGN0eCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG59KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXNvbHZlIGEgYFR5cGVgIGZvciB7QGxpbmsgUGlwZX0uXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gKi9cbnZhciBQaXBlUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGlwZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgUGlwZVJlc29sdmVyLnByb3RvdHlwZS5pc1BpcGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShjcmVhdGVQaXBlLmlzVHlwZU9mKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB7QGxpbmsgUGlwZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqL1xuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIG1ldGFzID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgaWYgKG1ldGFzKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGZpbmRMYXN0KG1ldGFzLCBjcmVhdGVQaXBlLmlzVHlwZU9mKTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUGlwZSBkZWNvcmF0b3IgZm91bmQgb24gXCIgKyBzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFBpcGVSZXNvbHZlcjtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogR2VuZXJhdGVzIGNvZGUgdGhhdCBpcyB1c2VkIHRvIHR5cGUgY2hlY2sgdGVtcGxhdGVzLlxuICovXG52YXIgVHlwZUNoZWNrQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHlwZUNoZWNrQ29tcGlsZXIob3B0aW9ucywgcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBvcnRhbnQgbm90ZXM6XG4gICAgICogLSBUaGlzIG11c3Qgbm90IHByb2R1Y2UgbmV3IGBpbXBvcnRgIHN0YXRlbWVudHMsIGJ1dCBvbmx5IHJlZmVyIHRvIHR5cGVzIG91dHNpZGVcbiAgICAgKiAgIG9mIHRoZSBmaWxlIHZpYSB0aGUgdmFyaWFibGVzIHByb3ZpZGVkIHZpYSBleHRlcm5hbFJlZmVyZW5jZVZhcnMuXG4gICAgICogICBUaGlzIGFsbG93cyBUeXBlc2NyaXB0IHRvIHJldXNlIHRoZSBvbGQgcHJvZ3JhbSdzIHN0cnVjdHVyZSBhcyBubyBpbXBvcnRzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiAtIFRoaXMgbXVzdCBub3QgcHJvZHVjZSBhbnkgZXhwb3J0cywgYXMgdGhpcyB3b3VsZCBwb2xsdXRlIHRoZSAuZC50cyBmaWxlXG4gICAgICogICBhbmQgYWxzbyB2aW9sYXRlIHRoZSBwb2ludCBhYm92ZS5cbiAgICAgKi9cbiAgICBUeXBlQ2hlY2tDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRJZCwgY29tcG9uZW50LCB0ZW1wbGF0ZSwgdXNlZFBpcGVzLCBleHRlcm5hbFJlZmVyZW5jZVZhcnMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHVzZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwaXBlcy5zZXQocC5uYW1lLCBwLnR5cGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBlbWJlZGRlZFZpZXdDb3VudCA9IDA7XG4gICAgICAgIHZhciB2aWV3QnVpbGRlckZhY3RvcnkgPSBmdW5jdGlvbiAocGFyZW50LCBndWFyZHMpIHtcbiAgICAgICAgICAgIHZhciBlbWJlZGRlZFZpZXdJbmRleCA9IGVtYmVkZGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdCdWlsZGVyKF90aGlzLm9wdGlvbnMsIF90aGlzLnJlZmxlY3RvciwgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLCBwYXJlbnQsIGNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgY29tcG9uZW50LmlzSG9zdCwgZW1iZWRkZWRWaWV3SW5kZXgsIHBpcGVzLCBndWFyZHMsIGN0eCwgdmlld0J1aWxkZXJGYWN0b3J5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHZpc2l0b3IgPSB2aWV3QnVpbGRlckZhY3RvcnkobnVsbCwgW10pO1xuICAgICAgICB2aXNpdG9yLnZpc2l0QWxsKFtdLCB0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLmJ1aWxkKGNvbXBvbmVudElkKTtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlQ2hlY2tDb21waWxlcjtcbn0oKSk7XG52YXIgRFlOQU1JQ19WQVJfTkFNRSA9ICdfYW55JztcbnZhciBUeXBlQ2hlY2tMb2NhbFJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVDaGVja0xvY2FsUmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIFR5cGVDaGVja0xvY2FsUmVzb2x2ZXIucHJvdG90eXBlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVHlwZUNoZWNrTG9jYWxSZXNvbHZlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICAvLyBSZWZlcmVuY2VzIHRvIHRoZSBldmVudCBzaG91bGQgbm90IGJlIHR5cGUtY2hlY2tlZC5cbiAgICAgICAgICAgIC8vIFRPRE8oY2h1Y2tqKTogZGV0ZXJtaW5lIGEgYmV0dGVyIHR5cGUgZm9yIHRoZSBldmVudC5cbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZShEWU5BTUlDX1ZBUl9OQU1FKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBUeXBlQ2hlY2tMb2NhbFJlc29sdmVyO1xufSgpKTtcbnZhciBkZWZhdWx0UmVzb2x2ZXIgPSBuZXcgVHlwZUNoZWNrTG9jYWxSZXNvbHZlcigpO1xudmFyIFZpZXdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyKG9wdGlvbnMsIHJlZmxlY3RvciwgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLCBwYXJlbnQsIGNvbXBvbmVudCwgaXNIb3N0Q29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgcGlwZXMsIGd1YXJkcywgY3R4LCB2aWV3QnVpbGRlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZWZlcmVuY2VWYXJzID0gZXh0ZXJuYWxSZWZlcmVuY2VWYXJzO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuaXNIb3N0Q29tcG9uZW50ID0gaXNIb3N0Q29tcG9uZW50O1xuICAgICAgICB0aGlzLmVtYmVkZGVkVmlld0luZGV4ID0gZW1iZWRkZWRWaWV3SW5kZXg7XG4gICAgICAgIHRoaXMucGlwZXMgPSBwaXBlcztcbiAgICAgICAgdGhpcy5ndWFyZHMgPSBndWFyZHM7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgICB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSA9IHZpZXdCdWlsZGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5yZWZPdXRwdXRWYXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldE91dHB1dFZhciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciB2YXJOYW1lO1xuICAgICAgICBpZiAodHlwZSA9PT0gdGhpcy5jb21wb25lbnQgJiYgdGhpcy5pc0hvc3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhck5hbWUgPSBEWU5BTUlDX1ZBUl9OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhck5hbWUgPSB0aGlzLmV4dGVybmFsUmVmZXJlbmNlVmFycy5nZXQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJOYW1lID0gRFlOQU1JQ19WQVJfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhck5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IHJlZmVycmluZyB0byBhIHR5cGUgd2l0aG91dCBhIHZhcmlhYmxlIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJOYW1lO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldFR5cGVHdWFyZEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIHJlc3VsdCA9IF9fc3ByZWFkKHRoaXMuZ3VhcmRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoYXN0LmRpcmVjdGl2ZXMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXMoZGlyZWN0aXZlLmlucHV0cykpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBndWFyZCA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUuZ3VhcmRzW2lucHV0LmRpcmVjdGl2ZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGd1YXJkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZUlmID0gZ3VhcmQgPT09ICdVc2VJZic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBndWFyZDogZ3VhcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUlmOiB1c2VJZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAodmFyaWFibGVzLCBhc3ROb2Rlcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoY29tcG9uZW50SWQsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZW1lbnRzID09PSB2b2lkIDApIHsgdGFyZ2V0U3RhdGVtZW50cyA9IFtdOyB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmJ1aWxkKGNvbXBvbmVudElkLCB0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciB2aWV3U3RtdHMgPSBbdmFyaWFibGUoRFlOQU1JQ19WQVJfTkFNRSkuc2V0KE5VTExfRVhQUikudG9EZWNsU3RtdChEWU5BTUlDX1RZUEUpXTtcbiAgICAgICAgdmFyIGJpbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSwgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW4sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBiaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgIHZhciBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBfdGhpcy5jb21wb25lbnQgPyBfdGhpcyA6IGRlZmF1bHRSZXNvbHZlcjtcbiAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCB2YXJpYWJsZShfdGhpcy5nZXRPdXRwdXRWYXIoY29udGV4dCkpLCB2YWx1ZSwgYmluZGluZ0lkLCBCaW5kaW5nRm9ybS5HZW5lcmFsKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgIHN0bXRzLnB1c2gobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQoY3VyclZhbEV4cHIpKTtcbiAgICAgICAgICAgIHZpZXdTdG10cy5wdXNoLmFwcGx5KHZpZXdTdG10cywgX19zcHJlYWQoc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBhcHBseVNvdXJjZVNwYW5Ub1N0YXRlbWVudElmTmVlZGVkKHN0bXQsIHNvdXJjZVNwYW4pOyB9KSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW4sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBiaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgIHZhciBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBfdGhpcy5jb21wb25lbnQgPyBfdGhpcyA6IGRlZmF1bHRSZXNvbHZlcjtcbiAgICAgICAgICAgIHZhciBzdG10cyA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKG5hbWVSZXNvbHZlciwgdmFyaWFibGUoX3RoaXMuZ2V0T3V0cHV0VmFyKGNvbnRleHQpKSwgdmFsdWUsIGJpbmRpbmdJZCkuc3RtdHM7XG4gICAgICAgICAgICB2aWV3U3RtdHMucHVzaC5hcHBseSh2aWV3U3RtdHMsIF9fc3ByZWFkKHN0bXRzLm1hcChmdW5jdGlvbiAoc3RtdCkgeyByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChzdG10LCBzb3VyY2VTcGFuKTsgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBndWFyZEV4cHJlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5ndWFyZHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2QgPSB0aGlzLnByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKGd1YXJkLmV4cHJlc3Npb24pLCBjb250ZXh0ID0gX2QuY29udGV4dCwgdmFsdWUgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBiaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IHRoaXMuY29tcG9uZW50ID8gdGhpcyA6IGRlZmF1bHRSZXNvbHZlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHN1cHBvcnQgc2ltcGxlIGV4cHJlc3Npb25zIGFuZCBpZ25vcmUgb3RoZXJzIGFzIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJlIHVubGlrZWx5IHRvIGFmZmVjdCB0eXBlIG5hcnJvd2luZy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lID0gY29udmVydFByb3BlcnR5QmluZGluZyhuYW1lUmVzb2x2ZXIsIHZhcmlhYmxlKHRoaXMuZ2V0T3V0cHV0VmFyKGNvbnRleHQpKSwgdmFsdWUsIGJpbmRpbmdJZCwgQmluZGluZ0Zvcm0uVHJ5U2ltcGxlKSwgc3RtdHMgPSBfZS5zdG10cywgY3VyclZhbEV4cHIgPSBfZS5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3VhcmRDbGF1c2UgPSBndWFyZC51c2VJZiA/IGN1cnJWYWxFeHByIDogdGhpcy5jdHguaW1wb3J0RXhwcihndWFyZC5ndWFyZCkuY2FsbEZuKFtjdXJyVmFsRXhwcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3VhcmRFeHByZXNzaW9uID0gZ3VhcmRFeHByZXNzaW9uID8gZ3VhcmRFeHByZXNzaW9uLmFuZChndWFyZENsYXVzZSkgOiBndWFyZENsYXVzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChndWFyZEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB2aWV3U3RtdHMgPSBbbmV3IElmU3RtdChndWFyZEV4cHJlc3Npb24sIHZpZXdTdG10cyldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3TmFtZSA9IFwiX1ZpZXdfXCIgKyBjb21wb25lbnRJZCArIFwiX1wiICsgdGhpcy5lbWJlZGRlZFZpZXdJbmRleDtcbiAgICAgICAgdmFyIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodmlld05hbWUsIFtdLCB2aWV3U3RtdHMpO1xuICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmlld0ZhY3RvcnkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGVtZW50cztcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFzdFdpdGhTb3VyY2UgPSBhc3QudmFsdWU7XG4gICAgICAgIHZhciBpbnRlciA9IGFzdFdpdGhTb3VyY2UuYXN0O1xuICAgICAgICBpbnRlci5leHByZXNzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlcy5wdXNoKHsgY29udGV4dDogX3RoaXMuY29tcG9uZW50LCB2YWx1ZTogZXhwciwgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4gfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEVsZW1lbnRPclRlbXBsYXRlKGFzdCk7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBvbGQgdmlldyBjb21waWxlciB1c2VkIHRvIHVzZSBhbiBgYW55YCB0eXBlXG4gICAgICAgIC8vIGZvciB0aGUgY29udGV4dCBpbiBhbnkgZW1iZWRkZWQgdmlldy5cbiAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGJlaGluZCBhIGZsYWcgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2spIHtcbiAgICAgICAgICAgIC8vIEZpbmQgYW55IGFwcGxpY2FibGUgdHlwZSBndWFyZHMuIEZvciBleGFtcGxlLCBOZ0lmIGhhcyBhIHR5cGUgZ3VhcmQgb24gbmdJZlxuICAgICAgICAgICAgLy8gKHNlZSBOZ0lmLm5nSWZUeXBlR3VhcmQpIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBhIHRlbXBsYXRlIGlzIG9ubHlcbiAgICAgICAgICAgIC8vIHN0YW1wZWQgb3V0IGlmIG5nSWYgaXMgdHJ1dGh5IHNvIGFueSBiaW5kaW5ncyBpbiB0aGUgdGVtcGxhdGUgY2FuIGFzc3VtZSB0aGF0LFxuICAgICAgICAgICAgLy8gaWYgYSBudWxsYWJsZSB0eXBlIGlzIHVzZWQgZm9yIG5nSWYsIHRoYXQgZXhwcmVzc2lvbiBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAgICB2YXIgZ3VhcmRzID0gdGhpcy5nZXRUeXBlR3VhcmRFeHByZXNzaW9ucyhhc3QpO1xuICAgICAgICAgICAgdmFyIGNoaWxkVmlzaXRvciA9IHRoaXMudmlld0J1aWxkZXJGYWN0b3J5KHRoaXMsIGd1YXJkcyk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGRWaXNpdG9yKTtcbiAgICAgICAgICAgIGNoaWxkVmlzaXRvci52aXNpdEFsbChhc3QudmFyaWFibGVzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoYXN0KTtcbiAgICAgICAgdmFyIGlucHV0RGVmcyA9IFtdO1xuICAgICAgICB2YXIgdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB2YXIgb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICBhc3QuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0QXN0KSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVzLnB1c2goeyBjb250ZXh0OiBfdGhpcy5jb21wb25lbnQsIHZhbHVlOiBpbnB1dEFzdC52YWx1ZSwgc291cmNlU3BhbjogaW5wdXRBc3Quc291cmNlU3BhbiB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnRPclRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJBc3QpIHtcbiAgICAgICAgICAgIF90aGlzLnZpc2l0RGlyZWN0aXZlKGRpckFzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRWYXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBvbGQgdmlldyBjb21waWxlciB1c2VkIHRvIHVzZSBhbiBgYW55YCB0eXBlXG4gICAgICAgICAgICAvLyBmb3IgZGlyZWN0aXZlcyBleHBvc2VkIHZpYSBgZXhwb3J0QXNgLlxuICAgICAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGJlaGluZCBhIGZsYWcgZm9yIG5vdy5cbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgcmVmLnZhbHVlLmlkZW50aWZpZXIgJiYgX3RoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRWYXJUeXBlID0gcmVmLnZhbHVlLmlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VmFyVHlwZSA9IEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVmT3V0cHV0VmFycy5zZXQocmVmLm5hbWUsIG91dHB1dFZhclR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0Lm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0QXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zLnB1c2goeyBjb250ZXh0OiBfdGhpcy5jb21wb25lbnQsIHZhbHVlOiBvdXRwdXRBc3QuaGFuZGxlciwgc291cmNlU3Bhbjogb3V0cHV0QXN0LnNvdXJjZVNwYW4gfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGlyVHlwZSA9IGRpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2U7XG4gICAgICAgIGRpckFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZXMucHVzaCh7IGNvbnRleHQ6IF90aGlzLmNvbXBvbmVudCwgdmFsdWU6IGlucHV0LnZhbHVlLCBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuIH0pOyB9KTtcbiAgICAgICAgLy8gTm90ZTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgLy8gZm9yIGV4cHJlc3Npb25zIGluIGhvc3QgcHJvcGVydGllcyAvIGV2ZW50cy5cbiAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGJlaGFpdm9yIGJlaGluZCBhIGZsYWcgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2spIHtcbiAgICAgICAgICAgIGRpckFzdC5ob3N0UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dEFzdCkgeyByZXR1cm4gX3RoaXMudXBkYXRlcy5wdXNoKHsgY29udGV4dDogZGlyVHlwZSwgdmFsdWU6IGlucHV0QXN0LnZhbHVlLCBzb3VyY2VTcGFuOiBpbnB1dEFzdC5zb3VyY2VTcGFuIH0pOyB9KTtcbiAgICAgICAgICAgIGRpckFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gX3RoaXMuYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBkaXJUeXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBob3N0RXZlbnRBc3QuaGFuZGxlcixcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBob3N0RXZlbnRBc3Quc291cmNlU3BhblxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZSh0aGlzLmdldE91dHB1dFZhcihCdWlsdGluVHlwZU5hbWUuRHluYW1pYykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGN1cnJCdWlsZGVyID0gdGhpczsgY3VyckJ1aWxkZXI7IGN1cnJCdWlsZGVyID0gY3VyckJ1aWxkZXIucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0VmFyVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIGNoZWNrIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIG91dHB1dFZhclR5cGUgPSBjdXJyQnVpbGRlci5yZWZPdXRwdXRWYXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRWYXJUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICB2YXIgdmFyQXN0ID0gY3VyckJ1aWxkZXIudmFyaWFibGVzLmZpbmQoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICAgICAgICAgIGlmICh2YXJBc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0VmFyVHlwZSA9IEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXRWYXJUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGUodGhpcy5nZXRPdXRwdXRWYXIob3V0cHV0VmFyVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnBpcGVPdXRwdXRWYXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGlwZSA9IHRoaXMucGlwZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXBpcGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IENvdWxkIG5vdCBmaW5kIHBpcGUgXCIgKyBuYW1lICsgXCIgaW4gdGVtcGxhdGUgb2YgXCIgKyB0aGlzLmNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0VmFyKHBpcGUpO1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGV4cHJlc3Npb24uc291cmNlU3BhbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGV4cHJlc3Npb24uY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcjogZnVuY3Rpb24gKGFyZ0NvdW50KSB7IHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gbGl0ZXJhbEFycihhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlIG9sZCB2aWV3IGNvbXBpbGVyIHVzZWQgdG8gdXNlIGFuIGBhbnlgIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wdGlvbnMuZnVsbFRlbXBsYXRlVHlwZUNoZWNrID8gYXJyIDogYXJyLmNhc3QoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgICAgICAgICB9OyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrLCBpKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogay5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZWQ6IGsucXVvdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IGxpdGVyYWxNYXAoZW50cmllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG1hcHMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5mdWxsVGVtcGxhdGVUeXBlQ2hlY2sgPyBtYXAgOiBtYXAuY2FzdChEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ0NvdW50KSB7IHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcGlwZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXBlRXhwciA9IF90aGlzLm9wdGlvbnMuZnVsbFRlbXBsYXRlVHlwZUNoZWNrID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlKF90aGlzLnBpcGVPdXRwdXRWYXIobmFtZSkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlKF90aGlzLmdldE91dHB1dFZhcihCdWlsdGluVHlwZU5hbWUuRHluYW1pYykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGlwZUV4cHIuY2FsbE1ldGhvZCgndHJhbnNmb3JtJywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTsgfSxcbiAgICAgICAgICAgIH0sIGV4cHJlc3Npb24udmFsdWUpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXROZ0NvbnRlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIENMQVNTX0FUVFIkMSA9ICdjbGFzcyc7XG52YXIgU1RZTEVfQVRUUiA9ICdzdHlsZSc7XG52YXIgSU1QTElDSVRfVEVNUExBVEVfVkFSID0gJ1xcJGltcGxpY2l0JztcbnZhciBWaWV3Q29tcGlsZVJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdCh2aWV3Q2xhc3NWYXIsIHJlbmRlcmVyVHlwZVZhcikge1xuICAgICAgICB0aGlzLnZpZXdDbGFzc1ZhciA9IHZpZXdDbGFzc1ZhcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGVWYXIgPSByZW5kZXJlclR5cGVWYXI7XG4gICAgfVxuICAgIHJldHVybiBWaWV3Q29tcGlsZVJlc3VsdDtcbn0oKSk7XG52YXIgVmlld0NvbXBpbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdDb21waWxlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIFZpZXdDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvdXRwdXRDdHgsIGNvbXBvbmVudCwgdGVtcGxhdGUsIHN0eWxlcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVtYmVkZGVkVmlld0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHJlbmRlckNvbXBvbmVudFZhck5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY29tcG9uZW50LmlzSG9zdCkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlXzEgPSBjb21wb25lbnQudGVtcGxhdGU7XG4gICAgICAgICAgICB2YXIgY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlXzEuYW5pbWF0aW9ucyAmJiB0ZW1wbGF0ZV8xLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVuZGVyRGF0YS5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkoJ2FuaW1hdGlvbicsIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KG91dHB1dEN0eCwgdGVtcGxhdGVfMS5hbmltYXRpb25zKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlbmRlckNvbXBvbmVudFZhciA9IHZhcmlhYmxlKHJlbmRlcmVyVHlwZU5hbWUoY29tcG9uZW50LnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnRWYXJOYW1lID0gcmVuZGVyQ29tcG9uZW50VmFyLm5hbWU7XG4gICAgICAgICAgICBvdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBvbmVudFZhclxuICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVSZW5kZXJlclR5cGUyKS5jYWxsRm4oW25ldyBMaXRlcmFsTWFwRXhwcihbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKHRlbXBsYXRlXzEuZW5jYXBzdWxhdGlvbiksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnc3R5bGVzJywgc3R5bGVzLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRW50cnkoJ2RhdGEnLCBuZXcgTGl0ZXJhbE1hcEV4cHIoY3VzdG9tUmVuZGVyRGF0YSksIGZhbHNlKVxuICAgICAgICAgICAgICAgIF0pXSkpXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyKSwgW1N0bXRNb2RpZmllci5GaW5hbCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3QnVpbGRlckZhY3RvcnkgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3QnVpbGRlciQxKF90aGlzLl9yZWZsZWN0b3IsIG91dHB1dEN0eCwgcGFyZW50LCBjb21wb25lbnQsIGVtYmVkZGVkVmlld0luZGV4LCB1c2VkUGlwZXMsIHZpZXdCdWlsZGVyRmFjdG9yeSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2aXNpdG9yID0gdmlld0J1aWxkZXJGYWN0b3J5KG51bGwpO1xuICAgICAgICB2aXNpdG9yLnZpc2l0QWxsKFtdLCB0ZW1wbGF0ZSk7XG4gICAgICAgIChfYSA9IG91dHB1dEN0eC5zdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZCh2aXNpdG9yLmJ1aWxkKCkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q29tcGlsZVJlc3VsdCh2aXNpdG9yLnZpZXdOYW1lLCByZW5kZXJDb21wb25lbnRWYXJOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3Q29tcGlsZXI7XG59KCkpO1xudmFyIExPR19WQVIkMSA9IHZhcmlhYmxlKCdfbCcpO1xudmFyIFZJRVdfVkFSID0gdmFyaWFibGUoJ192Jyk7XG52YXIgQ0hFQ0tfVkFSID0gdmFyaWFibGUoJ19jaycpO1xudmFyIENPTVBfVkFSID0gdmFyaWFibGUoJ19jbycpO1xudmFyIEVWRU5UX05BTUVfVkFSID0gdmFyaWFibGUoJ2VuJyk7XG52YXIgQUxMT1dfREVGQVVMVF9WQVIgPSB2YXJpYWJsZShcImFkXCIpO1xudmFyIFZpZXdCdWlsZGVyJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0J1aWxkZXIocmVmbGVjdG9yLCBvdXRwdXRDdHgsIHBhcmVudCwgY29tcG9uZW50LCBlbWJlZGRlZFZpZXdJbmRleCwgdXNlZFBpcGVzLCB2aWV3QnVpbGRlckZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0b3IgPSByZWZsZWN0b3I7XG4gICAgICAgIHRoaXMub3V0cHV0Q3R4ID0gb3V0cHV0Q3R4O1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdJbmRleDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMudmlld0J1aWxkZXJGYWN0b3J5ID0gdmlld0J1aWxkZXJGYWN0b3J5O1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMucHVyZVBpcGVOb2RlSW5kaWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vIE5lZWQgT2JqZWN0LmNyZWF0ZSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgYnVpbHRpbiB2YWx1ZXMuLi5cbiAgICAgICAgdGhpcy5yZWZOb2RlSW5kaWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gW107XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAvLyBmb3IgdGhlIGNvbnRleHQgaW4gYW55IGVtYmVkZGVkIHZpZXcuIFdlIGtlZXAgdGhpcyBiZWhhaXZvciBmb3Igbm93XG4gICAgICAgIC8vIHRvIGJlIGFibGUgdG8gaW50cm9kdWNlIHRoZSBuZXcgdmlldyBjb21waWxlciB3aXRob3V0IHRvbyBtYW55IGVycm9ycy5cbiAgICAgICAgdGhpcy5jb21wVHlwZSA9IHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPiAwID9cbiAgICAgICAgICAgIERZTkFNSUNfVFlQRSA6XG4gICAgICAgICAgICBleHByZXNzaW9uVHlwZShvdXRwdXRDdHguaW1wb3J0RXhwcih0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSkpO1xuICAgICAgICB0aGlzLnZpZXdOYW1lID0gdmlld0NsYXNzTmFtZSh0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCk7XG4gICAgfVxuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uICh2YXJpYWJsZXMsIGFzdE5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgICAgICAvLyBjcmVhdGUgdGhlIHBpcGVzIGZvciB0aGUgcHVyZSBwaXBlcyBpbW1lZGlhdGVseSwgc28gdGhhdCB3ZSBrbm93IHRoZWlyIGluZGljZXMuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXNlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocGlwZS5wdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnB1cmVQaXBlTm9kZUluZGljZXNbcGlwZS5uYW1lXSA9IF90aGlzLl9jcmVhdGVQaXBlKG51bGwsIHBpcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciBxdWVyeUlkID0gcXVlcnlJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdUeXBlID0gcXVlcnkuZmlyc3QgPyAwIC8qIEZpcnN0ICovIDogMSAvKiBBbGwgKi87XG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gMTM0MjE3NzI4IC8qIFR5cGVWaWV3UXVlcnkgKi8gfCBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnkpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5xdWVyeURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBsaXRlcmFsKHF1ZXJ5SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKFtuZXcgTGl0ZXJhbE1hcEVudHJ5KHF1ZXJ5LnByb3BlcnR5TmFtZSwgbGl0ZXJhbChiaW5kaW5nVHlwZSksIGZhbHNlKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAoYXN0Tm9kZXMubGVuZ3RoID09PSAwIHx8IG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGlzIGFuIGVtYmVkZGVkIHZpZXcsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCByb290IG5vZGUgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5hbmNob3JEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOb25lICovKSwgTlVMTF9FWFBSLCBOVUxMX0VYUFIsIGxpdGVyYWwoMClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZCh0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2NyZWF0ZU5vZGVFeHByZXNzaW9ucygpLCB1cGRhdGVSZW5kZXJlclN0bXRzID0gX2EudXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzID0gX2EudXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnMgPSBfYS5ub2RlRGVmRXhwcnM7XG4gICAgICAgIHZhciB1cGRhdGVSZW5kZXJlckZuID0gdGhpcy5fY3JlYXRlVXBkYXRlRm4odXBkYXRlUmVuZGVyZXJTdG10cyk7XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmVzRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVEaXJlY3RpdmVzU3RtdHMpO1xuICAgICAgICB2YXIgdmlld0ZsYWdzID0gMCAvKiBOb25lICovO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmIHRoaXMuY29tcG9uZW50LmNoYW5nZURldGVjdGlvbiA9PT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoKSB7XG4gICAgICAgICAgICB2aWV3RmxhZ3MgfD0gMiAvKiBPblB1c2ggKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodGhpcy52aWV3TmFtZSwgW25ldyBGblBhcmFtKExPR19WQVIkMS5uYW1lKV0sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGltcG9ydEV4cHIoSWRlbnRpZmllcnMudmlld0RlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKHZpZXdGbGFncyksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbEFycihub2RlRGVmRXhwcnMpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNGbixcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlckZuLFxuICAgICAgICAgICAgXSkpXSwgaW1wb3J0VHlwZShJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiksIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPT09IDAgPyBbU3RtdE1vZGlmaWVyLkV4cG9ydGVkXSA6IFtdKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVVwZGF0ZUZuID0gZnVuY3Rpb24gKHVwZGF0ZVN0bXRzKSB7XG4gICAgICAgIHZhciB1cGRhdGVGbjtcbiAgICAgICAgaWYgKHVwZGF0ZVN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVTdG10cyA9IFtdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pc0hvc3QgJiYgZmluZFJlYWRWYXJOYW1lcyh1cGRhdGVTdG10cykuaGFzKENPTVBfVkFSLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJlU3RtdHMucHVzaChDT01QX1ZBUi5zZXQoVklFV19WQVIucHJvcCgnY29tcG9uZW50JykpLnRvRGVjbFN0bXQodGhpcy5jb21wVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlRm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oQ0hFQ0tfVkFSLm5hbWUsIElORkVSUkVEX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKFZJRVdfVkFSLm5hbWUsIElORkVSUkVEX1RZUEUpXG4gICAgICAgICAgICBdLCBfX3NwcmVhZChwcmVTdG10cywgdXBkYXRlU3RtdHMpLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZUZuID0gTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cGRhdGVGbjtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gbmdDb250ZW50RGVmKG5nQ29udGVudEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiA4IC8qIFR5cGVOZ0NvbnRlbnQgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLm5nQ29udGVudERlZilcbiAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksIGxpdGVyYWwoYXN0LmluZGV4KV0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFN0YXRpYyB0ZXh0IG5vZGVzIGhhdmUgbm8gY2hlY2sgZnVuY3Rpb25cbiAgICAgICAgdmFyIGNoZWNrSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMudGV4dERlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKFtsaXRlcmFsKGFzdC52YWx1ZSldKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB2YXIgYXN0V2l0aFNvdXJjZSA9IGFzdC52YWx1ZTtcbiAgICAgICAgdmFyIGludGVyID0gYXN0V2l0aFNvdXJjZS5hc3Q7XG4gICAgICAgIHZhciB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zID0gaW50ZXIuZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByLCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7IG5vZGVJbmRleDogbm9kZUluZGV4LCBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCwgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sIGNvbnRleHQ6IENPTVBfVkFSLCB2YWx1ZTogZXhwciB9KTsgfSk7XG4gICAgICAgIC8vIENoZWNrIGluZGV4IGlzIHRoZSBzYW1lIGFzIHRoZSBub2RlIGluZGV4IGR1cmluZyBjb21waWxhdGlvblxuICAgICAgICAvLyBUaGV5IG1pZ2h0IG9ubHkgZGlmZmVyIGF0IHJ1bnRpbWVcbiAgICAgICAgdmFyIGNoZWNrSW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMudGV4dERlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKGludGVyLnN0cmluZ3MubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBsaXRlcmFsKHMpOyB9KSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyOiB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl92aXNpdEVsZW1lbnRPclRlbXBsYXRlKG5vZGVJbmRleCwgYXN0KSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICB2YXIgY2hpbGRWaXNpdG9yID0gdGhpcy52aWV3QnVpbGRlckZhY3RvcnkodGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZFZpc2l0b3IpO1xuICAgICAgICBjaGlsZFZpc2l0b3IudmlzaXRBbGwoYXN0LnZhcmlhYmxlcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIC8vIGFuY2hvckRlZihcbiAgICAgICAgLy8gICBmbGFnczogTm9kZUZsYWdzLCBtYXRjaGVkUXVlcmllczogW3N0cmluZywgUXVlcnlWYWx1ZVR5cGVdW10sIG5nQ29udGVudEluZGV4OiBudW1iZXIsXG4gICAgICAgIC8vICAgY2hpbGRDb3VudDogbnVtYmVyLCBoYW5kbGVFdmVudEZuPzogRWxlbWVudEhhbmRsZUV2ZW50Rm4sIHRlbXBsYXRlRmFjdG9yeT86XG4gICAgICAgIC8vICAgVmlld0RlZmluaXRpb25GYWN0b3J5KTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAxIC8qIFR5cGVFbGVtZW50ICovIHwgZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmFuY2hvckRlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSxcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoZXNFeHByLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoaWxkQ291bnQpLFxuICAgICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbihub2RlSW5kZXgsIGhvc3RFdmVudHMpLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlKGNoaWxkVmlzaXRvci52aWV3TmFtZSksXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5IHNvIHdlIGNhbiBhZGQgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAvLyBVc2luZyBhIG51bGwgZWxlbWVudCBuYW1lIGNyZWF0ZXMgYW4gYW5jaG9yLlxuICAgICAgICB2YXIgZWxOYW1lID0gaXNOZ0NvbnRhaW5lcihhc3QubmFtZSkgPyBudWxsIDogYXN0Lm5hbWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUobm9kZUluZGV4LCBhc3QpLCBmbGFncyA9IF9hLmZsYWdzLCB1c2VkRXZlbnRzID0gX2EudXNlZEV2ZW50cywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGRpckhvc3RCaW5kaW5ncyA9IF9hLmhvc3RCaW5kaW5ncywgaG9zdEV2ZW50cyA9IF9hLmhvc3RFdmVudHM7XG4gICAgICAgIHZhciBpbnB1dERlZnMgPSBbXTtcbiAgICAgICAgdmFyIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIG91dHB1dERlZnMgPSBbXTtcbiAgICAgICAgaWYgKGVsTmFtZSkge1xuICAgICAgICAgICAgdmFyIGhvc3RCaW5kaW5ncyA9IGFzdC5pbnB1dHNcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbnB1dEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBDT01QX1ZBUixcbiAgICAgICAgICAgICAgICBpbnB1dEFzdDogaW5wdXRBc3QsXG4gICAgICAgICAgICAgICAgZGlyQXN0OiBudWxsLFxuICAgICAgICAgICAgfSk7IH0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkaXJIb3N0QmluZGluZ3MpO1xuICAgICAgICAgICAgaWYgKGhvc3RCaW5kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zID1cbiAgICAgICAgICAgICAgICAgICAgaG9zdEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoaG9zdEJpbmRpbmcsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGhvc3RCaW5kaW5nLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaG9zdEJpbmRpbmcuaW5wdXRBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBob3N0QmluZGluZy5pbnB1dEFzdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgaW5wdXREZWZzID0gaG9zdEJpbmRpbmdzLm1hcChmdW5jdGlvbiAoaG9zdEJpbmRpbmcpIHsgcmV0dXJuIGVsZW1lbnRCaW5kaW5nRGVmKGhvc3RCaW5kaW5nLmlucHV0QXN0LCBob3N0QmluZGluZy5kaXJBc3QpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dERlZnMgPSB1c2VkRXZlbnRzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCB0YXJnZXQgPSBfYlswXSwgZXZlbnROYW1lID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwodGFyZ2V0KSwgbGl0ZXJhbChldmVudE5hbWUpXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XG4gICAgICAgIHZhciBjaGlsZENvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSBub2RlSW5kZXggLSAxO1xuICAgICAgICB2YXIgY29tcEFzdCA9IGFzdC5kaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpckFzdCkgeyByZXR1cm4gZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgIHZhciBjb21wUmVuZGVyZXJUeXBlID0gTlVMTF9FWFBSO1xuICAgICAgICB2YXIgY29tcFZpZXcgPSBOVUxMX0VYUFI7XG4gICAgICAgIGlmIChjb21wQXN0KSB7XG4gICAgICAgICAgICBjb21wVmlldyA9IHRoaXMub3V0cHV0Q3R4LmltcG9ydEV4cHIoY29tcEFzdC5kaXJlY3RpdmUuY29tcG9uZW50Vmlld1R5cGUpO1xuICAgICAgICAgICAgY29tcFJlbmRlcmVyVHlwZSA9IHRoaXMub3V0cHV0Q3R4LmltcG9ydEV4cHIoY29tcEFzdC5kaXJlY3RpdmUucmVuZGVyZXJUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpbmRleCBpcyB0aGUgc2FtZSBhcyB0aGUgbm9kZSBpbmRleCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAgICAgLy8gVGhleSBtaWdodCBvbmx5IGRpZmZlciBhdCBydW50aW1lXG4gICAgICAgIHZhciBjaGVja0luZGV4ID0gbm9kZUluZGV4O1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZWxlbWVudERlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChhc3QubmdDb250ZW50SW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hpbGRDb3VudCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChlbE5hbWUpLFxuICAgICAgICAgICAgICAgIGVsTmFtZSA/IGZpeGVkQXR0cnNEZWYoYXN0KSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihpbnB1dERlZnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMubGVuZ3RoID8gbGl0ZXJhbEFycihvdXRwdXREZWZzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICBjb21wVmlldyxcbiAgICAgICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICB1cGRhdGVSZW5kZXJlcjogdXBkYXRlUmVuZGVyZXJFeHByZXNzaW9uc1xuICAgICAgICB9KTsgfTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZSA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIGlmIChhc3QuaGFzVmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMTY3NzcyMTYgLyogRW1iZWRkZWRWaWV3cyAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlZEV2ZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgYXN0Lm91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnQsIG51bGwpLCBuYW1lID0gX2EubmFtZSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgdXNlZEV2ZW50cy5zZXQoZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyQXN0KSB7XG4gICAgICAgICAgICBkaXJBc3QuaG9zdEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnQsIGRpckFzdCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdXNlZEV2ZW50cy5zZXQoZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaG9zdEJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciBob3N0RXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX3Zpc2l0Q29tcG9uZW50RmFjdG9yeVJlc29sdmVyUHJvdmlkZXIoYXN0LmRpcmVjdGl2ZXMpO1xuICAgICAgICBhc3QucHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICB2YXIgZGlyQXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXN0LmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxEaXJBc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxEaXJBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyQXN0ID0gbG9jYWxEaXJBc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGlyQXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuX3Zpc2l0RGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBkaXJBc3QsIGFzdC5yZWZlcmVuY2VzLCBhc3QucXVlcnlNYXRjaGVzLCB1c2VkRXZlbnRzKSwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBkaXJIb3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MucHVzaC5hcHBseShob3N0QmluZGluZ3MsIF9fc3ByZWFkKGRpckhvc3RCaW5kaW5ncykpO1xuICAgICAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaC5hcHBseShob3N0RXZlbnRzLCBfX3NwcmVhZChkaXJIb3N0RXZlbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlzaXRQcm92aWRlcihwcm92aWRlckFzdCwgYXN0LnF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcXVlcnlNYXRjaEV4cHJzID0gW107XG4gICAgICAgIGFzdC5xdWVyeU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PVxuICAgICAgICAgICAgICAgIF90aGlzLnJlZmxlY3Rvci5yZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UoSWRlbnRpZmllcnMuRWxlbWVudFJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAwIC8qIEVsZW1lbnRSZWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDMgLyogVmlld0NvbnRhaW5lclJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDIgLyogVGVtcGxhdGVSZWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKG1hdGNoLnF1ZXJ5SWQpLCBsaXRlcmFsKHZhbHVlVHlwZSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3QucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXJlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDEgLyogUmVuZGVyRWxlbWVudCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKHJlZi52YWx1ZSkgPT09XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmbGVjdG9yLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAyIC8qIFRlbXBsYXRlUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKHZhbHVlVHlwZSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHtcbiAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaCh7IGNvbnRleHQ6IENPTVBfVkFSLCBldmVudEFzdDogb3V0cHV0QXN0LCBkaXJBc3Q6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgdXNlZEV2ZW50czogQXJyYXkuZnJvbSh1c2VkRXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHI6IHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncyxcbiAgICAgICAgICAgIGhvc3RFdmVudHM6IGhvc3RFdmVudHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJBc3QsIGRpckFzdCwgcmVmcywgcXVlcnlNYXRjaGVzLCB1c2VkRXZlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5IHNvIHdlIGNhbiBhZGQgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICBkaXJBc3QuZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnksIHF1ZXJ5SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeUlkID0gZGlyQXN0LmNvbnRlbnRRdWVyeVN0YXJ0SWQgKyBxdWVyeUluZGV4O1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gNjcxMDg4NjQgLyogVHlwZUNvbnRlbnRRdWVyeSAqLyB8IGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeSk7XG4gICAgICAgICAgICB2YXIgYmluZGluZ1R5cGUgPSBxdWVyeS5maXJzdCA/IDAgLyogRmlyc3QgKi8gOiAxIC8qIEFsbCAqLztcbiAgICAgICAgICAgIF90aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBkaXJBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucXVlcnlEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBsaXRlcmFsKHF1ZXJ5SWQpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIoW25ldyBMaXRlcmFsTWFwRW50cnkocXVlcnkucHJvcGVydHlOYW1lLCBsaXRlcmFsKGJpbmRpbmdUeXBlKSwgZmFsc2UpXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBvcGVyYXRpb24gYmVsb3cgbWlnaHQgYWxzbyBjcmVhdGUgbmV3IG5vZGVEZWZzLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGJlIGEgY2hpbGQgb2YgYSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIGFzIHRoZXkgbWlnaHQgYmUgYSBwcm92aWRlci9waXBlIG9uIHRoZWlyIG93bi5cbiAgICAgICAgLy8gSS5lLiB3ZSBvbmx5IGFsbG93IHF1ZXJpZXMgYXMgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcyBub2Rlcy5cbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZShwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaEV4cHJzID0gX2EucXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICBpZiAocmVmLnZhbHVlICYmIHRva2VuUmVmZXJlbmNlKHJlZi52YWx1ZSkgPT09IHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyQXN0LnRva2VuKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlZk5vZGVJbmRpY2VzW3JlZi5uYW1lXSA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKHJlZi5uYW1lKSwgbGl0ZXJhbCg0IC8qIFByb3ZpZGVyICovKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBmbGFncyB8PSAzMjc2OCAvKiBDb21wb25lbnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0RGVmcyA9IGRpckFzdC5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dEFzdCwgaW5wdXRJbmRleCkge1xuICAgICAgICAgICAgdmFyIG1hcFZhbHVlID0gbGl0ZXJhbEFycihbbGl0ZXJhbChpbnB1dEluZGV4KSwgbGl0ZXJhbChpbnB1dEFzdC5kaXJlY3RpdmVOYW1lKV0pO1xuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8gbm90IHF1b3RlIHRoZSBrZXkgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSByZW5hbWVzIGJ5IG1pbmlmaWVycyFcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUsIG1hcFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICB2YXIgZGlyTWV0YSA9IGRpckFzdC5kaXJlY3RpdmU7XG4gICAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBkaXJNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHVzZWRFdmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKGV2ZW50TmFtZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdXBkYXRlRGlyZWN0aXZlRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgaWYgKGRpckFzdC5pbnB1dHMubGVuZ3RoIHx8IChmbGFncyAmICgyNjIxNDQgLyogRG9DaGVjayAqLyB8IDY1NTM2IC8qIE9uSW5pdCAqLykpID4gMCkge1xuICAgICAgICAgICAgdXBkYXRlRGlyZWN0aXZlRXhwcmVzc2lvbnMgPVxuICAgICAgICAgICAgICAgIGRpckFzdC5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCwgYmluZGluZ0luZGV4KSB7IHJldHVybiBfdGhpcy5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXg6IG5vZGVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ0luZGV4OiBiaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IENPTVBfVkFSLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpckNvbnRleHRFeHByID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5ub2RlVmFsdWUpLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KV0pO1xuICAgICAgICB2YXIgaG9zdEJpbmRpbmdzID0gZGlyQXN0Lmhvc3RQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGRpckFzdDogZGlyQXN0LFxuICAgICAgICAgICAgaW5wdXRBc3Q6IGlucHV0QXN0LFxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciBob3N0RXZlbnRzID0gZGlyQXN0Lmhvc3RFdmVudHMubWFwKGZ1bmN0aW9uIChob3N0RXZlbnRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGV2ZW50QXN0OiBob3N0RXZlbnRBc3QsXG4gICAgICAgICAgICBkaXJBc3Q6IGRpckFzdCxcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICAvLyBDaGVjayBpbmRleCBpcyB0aGUgc2FtZSBhcyB0aGUgbm9kZSBpbmRleCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAgICAgLy8gVGhleSBtaWdodCBvbmx5IGRpZmZlciBhdCBydW50aW1lXG4gICAgICAgIHZhciBjaGVja0luZGV4ID0gbm9kZUluZGV4O1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDE2Mzg0IC8qIFR5cGVEaXJlY3RpdmUgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLmxlbmd0aCA/IGxpdGVyYWxBcnIocXVlcnlNYXRjaEV4cHJzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoaWxkQ291bnQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhwcixcbiAgICAgICAgICAgICAgICBkZXBzRXhwcixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKGlucHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5sZW5ndGggPyBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXM6IHVwZGF0ZURpcmVjdGl2ZUV4cHJlc3Npb25zLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBkaXJBc3QuZGlyZWN0aXZlLnR5cGUsXG4gICAgICAgIH0pOyB9O1xuICAgICAgICByZXR1cm4geyBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncywgaG9zdEV2ZW50czogaG9zdEV2ZW50cyB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl92aXNpdFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvdmlkZXJOb2RlKHRoaXMuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZShwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSk7XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0Q29tcG9uZW50RmFjdG9yeVJlc29sdmVyUHJvdmlkZXIgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICB2YXIgY29tcG9uZW50RGlyTWV0YSA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyQXN0KSB7IHJldHVybiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudERpck1ldGEgJiYgY29tcG9uZW50RGlyTWV0YS5kaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyUHJvdmlkZXJEZWYodGhpcy5yZWZsZWN0b3IsIHRoaXMub3V0cHV0Q3R4LCA4MTkyIC8qIFByaXZhdGVQcm92aWRlciAqLywgY29tcG9uZW50RGlyTWV0YS5kaXJlY3RpdmUuZW50cnlDb21wb25lbnRzKSwgcHJvdmlkZXJFeHByID0gX2EucHJvdmlkZXJFeHByLCBkZXBzRXhwciA9IF9hLmRlcHNFeHByLCBmbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHIgPSBfYS50b2tlbkV4cHI7XG4gICAgICAgICAgICB0aGlzLl9hZGRQcm92aWRlck5vZGUoe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLFxuICAgICAgICAgICAgICAgIGRlcHNFeHByOiBkZXBzRXhwcixcbiAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgdG9rZW5FeHByOiB0b2tlbkV4cHIsXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzOiBbXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBjb21wb25lbnREaXJNZXRhLnNvdXJjZVNwYW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2FkZFByb3ZpZGVyTm9kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIHByb3ZpZGVyRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgdG9rZW46YW55LFxuICAgICAgICAvLyAgIHZhbHVlOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGRhdGEuc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogZGF0YS5mbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucHJvdmlkZXJEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChkYXRhLmZsYWdzKSxcbiAgICAgICAgICAgICAgICBkYXRhLnF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKGRhdGEucXVlcnlNYXRjaEV4cHJzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBkYXRhLnRva2VuRXhwciwgZGF0YS5wcm92aWRlckV4cHIsIGRhdGEuZGVwc0V4cHJcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlID0gZnVuY3Rpb24gKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gMCAvKiBOb25lICovO1xuICAgICAgICB2YXIgcXVlcnlNYXRjaEV4cHJzID0gW107XG4gICAgICAgIHF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzLnB1c2gobGl0ZXJhbEFycihbbGl0ZXJhbChtYXRjaC5xdWVyeUlkKSwgbGl0ZXJhbCg0IC8qIFByb3ZpZGVyICovKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYSA9IHByb3ZpZGVyRGVmKHRoaXMub3V0cHV0Q3R4LCBwcm92aWRlckFzdCksIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwciwgcHJvdmlkZXJGbGFncyA9IF9hLmZsYWdzLCB0b2tlbkV4cHIgPSBfYS50b2tlbkV4cHI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmbGFnczogZmxhZ3MgfCBwcm92aWRlckZsYWdzLFxuICAgICAgICAgICAgcXVlcnlNYXRjaEV4cHJzOiBxdWVyeU1hdGNoRXhwcnMsXG4gICAgICAgICAgICBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwcixcbiAgICAgICAgICAgIGRlcHNFeHByOiBkZXBzRXhwcixcbiAgICAgICAgICAgIHRva2VuRXhwcjogdG9rZW5FeHByLFxuICAgICAgICAgICAgc291cmNlU3BhbjogcHJvdmlkZXJBc3Quc291cmNlU3BhblxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIGN1cnJCdWlsZGVyID0gdGhpczsgY3VyckJ1aWxkZXI7IGN1cnJCdWlsZGVyID0gY3VyckJ1aWxkZXIucGFyZW50LFxuICAgICAgICAgICAgY3VyclZpZXdFeHByID0gY3VyclZpZXdFeHByLnByb3AoJ3BhcmVudCcpLmNhc3QoRFlOQU1JQ19UWVBFKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgcmVmZXJlbmNlc1xuICAgICAgICAgICAgdmFyIHJlZk5vZGVJbmRleCA9IGN1cnJCdWlsZGVyLnJlZk5vZGVJbmRpY2VzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHJlZk5vZGVJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMubm9kZVZhbHVlKS5jYWxsRm4oW2N1cnJWaWV3RXhwciwgbGl0ZXJhbChyZWZOb2RlSW5kZXgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB2YXJpYWJsZXNcbiAgICAgICAgICAgIHZhciB2YXJBc3QgPSBjdXJyQnVpbGRlci52YXJpYWJsZXMuZmluZChmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiB2YXJBc3QubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgICAgICAgICBpZiAodmFyQXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlID0gdmFyQXN0LnZhbHVlIHx8IElNUExJQ0lUX1RFTVBMQVRFX1ZBUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclZpZXdFeHByLnByb3AoJ2NvbnRleHQnKS5wcm9wKHZhclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb3QgbmVlZGVkIGluIFZpZXcgRW5naW5lIGFzIFZpZXcgRW5naW5lIHdhbGtzIHRocm91Z2ggdGhlIGdlbmVyYXRlZFxuICAgICAgICAvLyBleHByZXNzaW9ucyB0byBmaWd1cmUgb3V0IGlmIHRoZSBpbXBsaWNpdCByZWNlaXZlciBpcyB1c2VkIGFuZCBuZWVkc1xuICAgICAgICAvLyB0byBiZSBnZW5lcmF0ZWQgYXMgcGFydCBvZiB0aGUgcHJlLXVwZGF0ZSBzdGF0ZW1lbnRzLlxuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgYXJnQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLkVNUFRZX0FSUkFZKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZUV4cHJfMTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hlY2tJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDMyIC8qIFR5cGVQdXJlQXJyYXkgKi8sXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnB1cmVBcnJheURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXJnQ291bnQpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQoY2hlY2tJbmRleCwgYXJncyk7IH07XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3Bhbiwga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUV4cHJfMiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuRU1QVFlfTUFQKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZUV4cHJfMjsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gbGl0ZXJhbE1hcChrZXlzLm1hcChmdW5jdGlvbiAoZSwgaSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBlKSwgeyB2YWx1ZTogbGl0ZXJhbChpKSB9KSk7IH0pKTtcbiAgICAgICAgdmFyIGNoZWNrSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiA2NCAvKiBUeXBlUHVyZU9iamVjdCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucHVyZU9iamVjdERlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoZWNrSW5kZXgpLFxuICAgICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBjYWxsQ2hlY2tTdG10KGNoZWNrSW5kZXgsIGFyZ3MpOyB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQaXBlQ29udmVydGVyID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KSB7XG4gICAgICAgIHZhciBwaXBlID0gdGhpcy51c2VkUGlwZXMuZmluZChmdW5jdGlvbiAocGlwZVN1bW1hcnkpIHsgcmV0dXJuIHBpcGVTdW1tYXJ5Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICBpZiAocGlwZS5wdXJlKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tJbmRleF8xID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBleHByZXNzaW9uLnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgbm9kZUZsYWdzOiAxMjggLyogVHlwZVB1cmVQaXBlICovLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucHVyZVBpcGVEZWYpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoY2hlY2tJbmRleF8xKSxcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChhcmdDb3VudCksXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgIC8vIGZpbmQgdW5kZXJseWluZyBwaXBlIGluIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgdmFyIGNvbXBWaWV3RXhwciA9IFZJRVdfVkFSO1xuICAgICAgICAgICAgdmFyIGNvbXBCdWlsZGVyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChjb21wQnVpbGRlci5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wQnVpbGRlciA9IGNvbXBCdWlsZGVyLnBhcmVudDtcbiAgICAgICAgICAgICAgICBjb21wVmlld0V4cHIgPSBjb21wVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBpcGVOb2RlSW5kZXggPSBjb21wQnVpbGRlci5wdXJlUGlwZU5vZGVJbmRpY2VzW25hbWVdO1xuICAgICAgICAgICAgdmFyIHBpcGVWYWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMubm9kZVZhbHVlKS5jYWxsRm4oW2NvbXBWaWV3RXhwciwgbGl0ZXJhbChwaXBlTm9kZUluZGV4KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7IHJldHVybiBjYWxsVW53cmFwVmFsdWUoZXhwcmVzc2lvbi5ub2RlSW5kZXgsIGV4cHJlc3Npb24uYmluZGluZ0luZGV4LCBjYWxsQ2hlY2tTdG10KGNoZWNrSW5kZXhfMSwgW3BpcGVWYWx1ZUV4cHJfMV0uY29uY2F0KGFyZ3MpKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy5fY3JlYXRlUGlwZShleHByZXNzaW9uLnNvdXJjZVNwYW4sIHBpcGUpO1xuICAgICAgICAgICAgdmFyIG5vZGVWYWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMubm9kZVZhbHVlKS5jYWxsRm4oW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCldKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgbm9kZVZhbHVlRXhwcl8xLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpKTsgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVQaXBlID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4sIHBpcGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgICAgIHBpcGUudHlwZS5saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgICAgICAvLyBmb3IgcGlwZXMsIHdlIG9ubHkgc3VwcG9ydCBuZ09uRGVzdHJveVxuICAgICAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2sgPT09IExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRlcEV4cHJzID0gcGlwZS50eXBlLmRpRGVwcy5tYXAoZnVuY3Rpb24gKGRpRGVwKSB7IHJldHVybiBkZXBEZWYoX3RoaXMub3V0cHV0Q3R4LCBkaURlcCk7IH0pO1xuICAgICAgICAvLyBmdW5jdGlvbiBwaXBlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIGN0b3I6IGFueSwgZGVwczogKFtEZXBGbGFncywgYW55XSB8IGFueSlbXSk6IE5vZGVEZWZcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAxNiAvKiBUeXBlUGlwZSAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucGlwZURlZikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgX3RoaXMub3V0cHV0Q3R4LmltcG9ydEV4cHIocGlwZS50eXBlLnJlZmVyZW5jZSksIGxpdGVyYWxBcnIoZGVwRXhwcnMpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlSW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIEFTVCBpbiBgVXBkYXRlRXhwcmVzc2lvbi52YWx1ZWA6XG4gICAgICogLSBjcmVhdGUgbm9kZXMgZm9yIHBpcGVzLCBsaXRlcmFsIGFycmF5cyBhbmQsIGxpdGVyYWwgbWFwcyxcbiAgICAgKiAtIHVwZGF0ZSB0aGUgQVNUIHRvIHJlcGxhY2UgcGlwZXMsIGxpdGVyYWwgYXJyYXlzIGFuZCwgbGl0ZXJhbCBtYXBzIHdpdGggY2FsbHMgdG8gY2hlY2sgZm4uXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBUaGlzIG1pZ2h0IGNyZWF0ZSBuZXcgbm9kZURlZnMgKGZvciBwaXBlcyBhbmQgbGl0ZXJhbCBhcnJheXMgYW5kIGxpdGVyYWwgbWFwcykhXG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlSW5kZXg6IGV4cHJlc3Npb24ubm9kZUluZGV4LFxuICAgICAgICAgICAgYmluZGluZ0luZGV4OiBleHByZXNzaW9uLmJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGV4cHJlc3Npb24uc291cmNlU3BhbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGV4cHJlc3Npb24uY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcjogZnVuY3Rpb24gKGFyZ0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3BhbiwgYXJnQ291bnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3Bhbiwga2V5cyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVQaXBlQ29udmVydGVyOiBmdW5jdGlvbiAobmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVQaXBlQ29udmVydGVyKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBleHByZXNzaW9uLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVOb2RlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHVwZGF0ZUJpbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHZhciB1cGRhdGVSZW5kZXJlclN0bXRzID0gW107XG4gICAgICAgIHZhciB1cGRhdGVEaXJlY3RpdmVzU3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVEZWZFeHBycyA9IHRoaXMubm9kZXMubWFwKGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGZhY3RvcnkoKSwgbm9kZURlZiA9IF9hLm5vZGVEZWYsIG5vZGVGbGFncyA9IF9hLm5vZGVGbGFncywgdXBkYXRlRGlyZWN0aXZlcyA9IF9hLnVwZGF0ZURpcmVjdGl2ZXMsIHVwZGF0ZVJlbmRlcmVyID0gX2EudXBkYXRlUmVuZGVyZXIsIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVJlbmRlcmVyU3RtdHMsIF9fc3ByZWFkKGNyZWF0ZVVwZGF0ZVN0YXRlbWVudHMobm9kZUluZGV4LCBzb3VyY2VTcGFuLCB1cGRhdGVSZW5kZXJlciwgZmFsc2UpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZURpcmVjdGl2ZXNTdG10cywgX19zcHJlYWQoY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZURpcmVjdGl2ZXMsIChub2RlRmxhZ3MgJiAoMjYyMTQ0IC8qIERvQ2hlY2sgKi8gfCA2NTUzNiAvKiBPbkluaXQgKi8pKSA+IDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSB1c2UgYSBjb21tYSBleHByZXNzaW9uIHRvIGNhbGwgdGhlIGxvZyBmdW5jdGlvbiBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZSBub2RlRGVmIGZ1bmN0aW9uLCBidXQgc3RpbGwgdXNlIHRoZSByZXN1bHQgb2YgdGhlIG5vZGVEZWYgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGFzIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgYWRkIHRoZSBsb2dnZXIgdG8gZWxlbWVudHMgLyB0ZXh0IG5vZGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgZ2VuZXJhdGUgdG9vIG11Y2ggY29kZS5cbiAgICAgICAgICAgIHZhciBsb2dXaXRoTm9kZURlZiA9IG5vZGVGbGFncyAmIDMgLyogQ2F0UmVuZGVyTm9kZSAqLyA/XG4gICAgICAgICAgICAgICAgbmV3IENvbW1hRXhwcihbTE9HX1ZBUiQxLmNhbGxGbihbXSkuY2FsbEZuKFtdKSwgbm9kZURlZl0pIDpcbiAgICAgICAgICAgICAgICBub2RlRGVmO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGxvZ1dpdGhOb2RlRGVmLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IHVwZGF0ZVJlbmRlcmVyU3RtdHM6IHVwZGF0ZVJlbmRlcmVyU3RtdHMsIHVwZGF0ZURpcmVjdGl2ZXNTdG10czogdXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnM6IG5vZGVEZWZFeHBycyB9O1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGVTdGF0ZW1lbnRzKG5vZGVJbmRleCwgc291cmNlU3BhbiwgZXhwcmVzc2lvbnMsIGFsbG93RW1wdHlFeHBycykge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgICB2YXIgZXhwcnMgPSBleHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBfYS5zb3VyY2VTcGFuLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZ0lkID0gXCJcIiArIHVwZGF0ZUJpbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IHNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCB2YWx1ZSwgYmluZGluZ0lkLCBCaW5kaW5nRm9ybS5HZW5lcmFsKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCBfX3NwcmVhZChzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvRXhwcmVzc2lvbklmTmVlZGVkKGN1cnJWYWxFeHByLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCB8fCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGV4cHJzKS50b1N0bXQoKSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN0bXRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRIYW5kbGVFdmVudEZuID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50U3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50QmluZGluZ0NvdW50ID0gMDtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX2EuY29udGV4dCwgZXZlbnRBc3QgPSBfYS5ldmVudEFzdCwgZGlyQXN0ID0gX2EuZGlyQXN0O1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IFwiXCIgKyBoYW5kbGVFdmVudEJpbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgdmFyIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IENPTVBfVkFSID8gX3RoaXMgOiBudWxsO1xuICAgICAgICAgICAgdmFyIF9iID0gY29udmVydEFjdGlvbkJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCBldmVudEFzdC5oYW5kbGVyLCBiaW5kaW5nSWQpLCBzdG10cyA9IF9iLnN0bXRzLCBhbGxvd0RlZmF1bHQgPSBfYi5hbGxvd0RlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgdHJ1ZVN0bXRzID0gc3RtdHM7XG4gICAgICAgICAgICBpZiAoYWxsb3dEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJ1ZVN0bXRzLnB1c2goQUxMT1dfREVGQVVMVF9WQVIuc2V0KGFsbG93RGVmYXVsdC5hbmQoQUxMT1dfREVGQVVMVF9WQVIpKS50b1N0bXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50QXN0LCBkaXJBc3QpLCBldmVudFRhcmdldCA9IF9jLnRhcmdldCwgZXZlbnROYW1lID0gX2MubmFtZTtcbiAgICAgICAgICAgIHZhciBmdWxsRXZlbnROYW1lID0gZWxlbWVudEV2ZW50RnVsbE5hbWUoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChuZXcgSWZTdG10KGxpdGVyYWwoZnVsbEV2ZW50TmFtZSkuaWRlbnRpY2FsKEVWRU5UX05BTUVfVkFSKSwgdHJ1ZVN0bXRzKSwgZXZlbnRBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGhhbmRsZUV2ZW50Rm47XG4gICAgICAgIGlmIChoYW5kbGVFdmVudFN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwcmVTdG10cyA9IFtBTExPV19ERUZBVUxUX1ZBUi5zZXQobGl0ZXJhbCh0cnVlKSkudG9EZWNsU3RtdChCT09MX1RZUEUpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaXNIb3N0ICYmIGZpbmRSZWFkVmFyTmFtZXMoaGFuZGxlRXZlbnRTdG10cykuaGFzKENPTVBfVkFSLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcHJlU3RtdHMucHVzaChDT01QX1ZBUi5zZXQoVklFV19WQVIucHJvcCgnY29tcG9uZW50JykpLnRvRGVjbFN0bXQodGhpcy5jb21wVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlRXZlbnRGbiA9IGZuKFtcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShFVkVOVF9OQU1FX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShFdmVudEhhbmRsZXJWYXJzLmV2ZW50Lm5hbWUsIElORkVSUkVEX1RZUEUpXG4gICAgICAgICAgICBdLCBfX3NwcmVhZChwcmVTdG10cywgaGFuZGxlRXZlbnRTdG10cywgW25ldyBSZXR1cm5TdGF0ZW1lbnQoQUxMT1dfREVGQVVMVF9WQVIpXSksIElORkVSUkVEX1RZUEUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlRXZlbnRGbiA9IE5VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlRXZlbnRGbjtcbiAgICB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEF0dHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgcmV0dXJuIFZpZXdCdWlsZGVyO1xufSgpKTtcbmZ1bmN0aW9uIG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSB7XG4gICAgdmFyIGxhc3RBc3ROb2RlID0gYXN0Tm9kZXNbYXN0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRWxlbWVudEFzdCkge1xuICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcihsYXN0QXN0Tm9kZS5uYW1lKSAmJiBsYXN0QXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShsYXN0QXN0Tm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RBc3ROb2RlLmhhc1ZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBsYXN0QXN0Tm9kZSBpbnN0YW5jZW9mIE5nQ29udGVudEFzdDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRCaW5kaW5nRGVmKGlucHV0QXN0LCBkaXJBc3QpIHtcbiAgICB2YXIgaW5wdXRUeXBlID0gaW5wdXRBc3QudHlwZTtcbiAgICBzd2l0Y2ggKGlucHV0VHlwZSkge1xuICAgICAgICBjYXNlIDEgLyogQXR0cmlidXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoMSAvKiBUeXBlRWxlbWVudEF0dHJpYnV0ZSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSAwIC8qIFByb3BlcnR5ICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoOCAvKiBUeXBlUHJvcGVydHkgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoaW5wdXRBc3Quc2VjdXJpdHlDb250ZXh0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGNhc2UgNCAvKiBBbmltYXRpb24gKi86XG4gICAgICAgICAgICB2YXIgYmluZGluZ1R5cGUgPSA4IC8qIFR5cGVQcm9wZXJ0eSAqLyB8XG4gICAgICAgICAgICAgICAgKGRpckFzdCAmJiBkaXJBc3QuZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gMzIgLyogU3ludGhldGljSG9zdFByb3BlcnR5ICovIDpcbiAgICAgICAgICAgICAgICAgICAgMTYgLyogU3ludGhldGljUHJvcGVydHkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYmluZGluZ1R5cGUpLCBsaXRlcmFsKCdAJyArIGlucHV0QXN0Lm5hbWUpLCBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIDIgLyogQ2xhc3MgKi86XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbCgyIC8qIFR5cGVFbGVtZW50Q2xhc3MgKi8pLCBsaXRlcmFsKGlucHV0QXN0Lm5hbWUpLCBOVUxMX0VYUFJdKTtcbiAgICAgICAgY2FzZSAzIC8qIFN0eWxlICovOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoNCAvKiBUeXBlRWxlbWVudFN0eWxlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC51bml0KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBUaGlzIGRlZmF1bHQgY2FzZSBpcyBub3QgbmVlZGVkIGJ5IFR5cGVTY3JpcHQgY29tcGlsZXIsIGFzIHRoZSBzd2l0Y2ggaXMgZXhoYXVzdGl2ZS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgQ2xvc3VyZSBDb21waWxlciBkb2VzIG5vdCB1bmRlcnN0YW5kIHRoYXQgYW5kIHJlcG9ydHMgYW4gZXJyb3IgaW4gdHlwZWQgbW9kZS5cbiAgICAgICAgICAgIC8vIFRoZSBgdGhyb3cgbmV3IEVycm9yYCBiZWxvdyB3b3JrcyBhcm91bmQgdGhlIHByb2JsZW0sIGFuZCB0aGUgdW5leHBlY3RlZDogbmV2ZXIgdmFyaWFibGVcbiAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgdHNjIHN0aWxsIGNoZWNrcyB0aGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB2YXIgdW5leHBlY3RlZCA9IGlucHV0VHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgXCIgKyB1bmV4cGVjdGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhlZEF0dHJzRGVmKGVsZW1lbnRBc3QpIHtcbiAgICB2YXIgbWFwUmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBlbGVtZW50QXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHtcbiAgICAgICAgbWFwUmVzdWx0W2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlO1xuICAgIH0pO1xuICAgIGVsZW1lbnRBc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJBc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGlyQXN0LmRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGlyQXN0LmRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBtYXBSZXN1bHRbbmFtZV07XG4gICAgICAgICAgICBtYXBSZXN1bHRbbmFtZV0gPSBwcmV2VmFsdWUgIT0gbnVsbCA/IG1lcmdlQXR0cmlidXRlVmFsdWUobmFtZSwgcHJldlZhbHVlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gTm90ZTogV2UgbmVlZCB0byBzb3J0IHRvIGdldCBhIGRlZmluZWQgb3V0cHV0IG9yZGVyXG4gICAgLy8gZm9yIHRlc3RzIGFuZCBmb3IgY2FjaGluZyBnZW5lcmF0ZWQgYXJ0aWZhY3RzLi4uXG4gICAgcmV0dXJuIGxpdGVyYWxBcnIoT2JqZWN0LmtleXMobWFwUmVzdWx0KS5zb3J0KCkubWFwKGZ1bmN0aW9uIChhdHRyTmFtZSkgeyByZXR1cm4gbGl0ZXJhbEFycihbbGl0ZXJhbChhdHRyTmFtZSksIGxpdGVyYWwobWFwUmVzdWx0W2F0dHJOYW1lXSldKTsgfSkpO1xufVxuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVWYWx1ZShhdHRyTmFtZSwgYXR0clZhbHVlMSwgYXR0clZhbHVlMikge1xuICAgIGlmIChhdHRyTmFtZSA9PSBDTEFTU19BVFRSJDEgfHwgYXR0ck5hbWUgPT0gU1RZTEVfQVRUUikge1xuICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBleHBycykge1xuICAgIGlmIChleHBycy5sZW5ndGggPiAxMCkge1xuICAgICAgICByZXR1cm4gQ0hFQ0tfVkFSLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KSwgbGl0ZXJhbCgxIC8qIER5bmFtaWMgKi8pLCBsaXRlcmFsQXJyKGV4cHJzKV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIENIRUNLX1ZBUi5jYWxsRm4oX19zcHJlYWQoW1ZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoMCAvKiBJbmxpbmUgKi8pXSwgZXhwcnMpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsVW53cmFwVmFsdWUobm9kZUluZGV4LCBiaW5kaW5nSWR4LCBleHByKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMudW53cmFwVmFsdWUpLmNhbGxGbihbXG4gICAgICAgIFZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoYmluZGluZ0lkeCksIGV4cHJcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnRBc3QsIGRpckFzdCkge1xuICAgIGlmIChldmVudEFzdC5pc0FuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogXCJAXCIgKyBldmVudEFzdC5uYW1lICsgXCIuXCIgKyBldmVudEFzdC5waGFzZSxcbiAgICAgICAgICAgIHRhcmdldDogZGlyQXN0ICYmIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgPyAnY29tcG9uZW50JyA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBldmVudEFzdDtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjU3RhdGljRHluYW1pY1F1ZXJ5RmxhZ3MocXVlcnkpIHtcbiAgICB2YXIgZmxhZ3MgPSAwIC8qIE5vbmUgKi87XG4gICAgLy8gTm90ZTogV2Ugb25seSBtYWtlIHF1ZXJpZXMgc3RhdGljIHRoYXQgcXVlcnkgZm9yIGEgc2luZ2xlIGl0ZW0gYW5kIHRoZSB1c2VyIHNwZWNpZmljYWxseVxuICAgIC8vIHNldCB0aGUgdG8gYmUgc3RhdGljLiBUaGlzIGlzIGJlY2F1c2Ugb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkIHZpZXcgY29tcGlsZXIuLi5cbiAgICBpZiAocXVlcnkuZmlyc3QgJiYgcXVlcnkuc3RhdGljKSB7XG4gICAgICAgIGZsYWdzIHw9IDI2ODQzNTQ1NiAvKiBTdGF0aWNRdWVyeSAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZsYWdzIHw9IDUzNjg3MDkxMiAvKiBEeW5hbWljUXVlcnkgKi87XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRFdmVudEZ1bGxOYW1lKHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiB0YXJnZXQgPyB0YXJnZXQgKyBcIjpcIiArIG5hbWUgOiBuYW1lO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBtZXNzYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBNZXNzYWdlQnVuZGxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VCdW5kbGUoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzLCBfbG9jYWxlKSB7XG4gICAgICAgIGlmIChfbG9jYWxlID09PSB2b2lkIDApIHsgX2xvY2FsZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgfVxuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLnVwZGF0ZUZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgaHRtbFBhcnNlclJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UoaHRtbCwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUsIGludGVycG9sYXRpb25Db25maWc6IGludGVycG9sYXRpb25Db25maWcgfSk7XG4gICAgICAgIGlmIChodG1sUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaTE4blBhcnNlclJlc3VsdCA9IGV4dHJhY3RNZXNzYWdlcyhodG1sUGFyc2VyUmVzdWx0LnJvb3ROb2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5faW1wbGljaXRUYWdzLCB0aGlzLl9pbXBsaWNpdEF0dHJzKTtcbiAgICAgICAgaWYgKGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX21lc3NhZ2VzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzKSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIC8vIFJldHVybiB0aGUgbWVzc2FnZSBpbiB0aGUgaW50ZXJuYWwgZm9ybWF0XG4gICAgLy8gVGhlIHB1YmxpYyAoc2VyaWFsaXplZCkgZm9ybWF0IG1pZ2h0IGJlIGRpZmZlcmVudCwgc2VlIHRoZSBgd3JpdGVgIG1ldGhvZC5cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VzO1xuICAgIH07XG4gICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc2VyaWFsaXplciwgZmlsdGVyU291cmNlcykge1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSB7fTtcbiAgICAgICAgdmFyIG1hcHBlclZpc2l0b3IgPSBuZXcgTWFwUGxhY2Vob2xkZXJOYW1lcygpO1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBJRFxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgaWQgPSBzZXJpYWxpemVyLmRpZ2VzdChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChfYSA9IG1lc3NhZ2VzW2lkXS5zb3VyY2VzKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZChtZXNzYWdlLnNvdXJjZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBwbGFjZWhvbGRlciBuYW1lcyB1c2luZyB0aGUgc2VyaWFsaXplciBtYXBwaW5nXG4gICAgICAgIHZhciBtc2dMaXN0ID0gT2JqZWN0LmtleXMobWVzc2FnZXMpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBtYXBwZXIgPSBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobWVzc2FnZXNbaWRdKTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBtZXNzYWdlc1tpZF07XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBtYXBwZXIgPyBtYXBwZXJWaXNpdG9yLmNvbnZlcnQoc3JjLm5vZGVzLCBtYXBwZXIpIDogc3JjLm5vZGVzO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkTWVzc2FnZSA9IG5ldyBNZXNzYWdlKG5vZGVzLCB7fSwge30sIHNyYy5tZWFuaW5nLCBzcmMuZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzID0gc3JjLnNvdXJjZXM7XG4gICAgICAgICAgICBpZiAoZmlsdGVyU291cmNlcykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gc291cmNlLmZpbGVQYXRoID0gZmlsdGVyU291cmNlcyhzb3VyY2UuZmlsZVBhdGgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplci53cml0ZShtc2dMaXN0LCB0aGlzLl9sb2NhbGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VCdW5kbGU7XG59KCkpO1xuLy8gVHJhbnNmb3JtIGFuIGkxOG4gQVNUIGJ5IHJlbmFtaW5nIHRoZSBwbGFjZWhvbGRlciBub2RlcyB3aXRoIHRoZSBnaXZlbiBtYXBwZXJcbnZhciBNYXBQbGFjZWhvbGRlck5hbWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBQbGFjZWhvbGRlck5hbWVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFBsYWNlaG9sZGVyTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChub2RlcywgbWFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXBwZXIgPyBub2Rlcy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4udmlzaXQoX3RoaXMsIG1hcHBlcik7IH0pIDogbm9kZXM7XG4gICAgfTtcbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0TmFtZSA9IG1hcHBlci50b1B1YmxpY05hbWUocGguc3RhcnROYW1lKTtcbiAgICAgICAgdmFyIGNsb3NlTmFtZSA9IHBoLmNsb3NlTmFtZSA/IG1hcHBlci50b1B1YmxpY05hbWUocGguY2xvc2VOYW1lKSA6IHBoLmNsb3NlTmFtZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBtYXBwZXIpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihwaC50YWcsIHBoLmF0dHJzLCBzdGFydE5hbWUsIGNsb3NlTmFtZSwgY2hpbGRyZW4sIHBoLmlzVm9pZCwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgbWFwcGVyLnRvUHVibGljTmFtZShwaC5uYW1lKSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihwaC52YWx1ZSwgbWFwcGVyLnRvUHVibGljTmFtZShwaC5uYW1lKSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwUGxhY2Vob2xkZXJOYW1lcztcbn0oQ2xvbmVWaXNpdG9yKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBHZW5lcmF0ZWRGaWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRlZEZpbGUoc3JjRmlsZVVybCwgZ2VuRmlsZVVybCwgc291cmNlT3JTdG10cykge1xuICAgICAgICB0aGlzLnNyY0ZpbGVVcmwgPSBzcmNGaWxlVXJsO1xuICAgICAgICB0aGlzLmdlbkZpbGVVcmwgPSBnZW5GaWxlVXJsO1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU9yU3RtdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZU9yU3RtdHM7XG4gICAgICAgICAgICB0aGlzLnN0bXRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc3RtdHMgPSBzb3VyY2VPclN0bXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdlbmVyYXRlZEZpbGUucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5nZW5GaWxlVXJsICE9PSBvdGhlci5nZW5GaWxlVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UgPT09IG90aGVyLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuc3RtdHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHRoZSBjb25zdHJ1Y3RvciBndWFyYW50ZWVzIHRoYXQgaWYgdGhpcy5zb3VyY2UgaXMgbm90IGZpbGxlZCxcbiAgICAgICAgLy8gdGhlbiB0aGlzLnN0bXRzIGlzLlxuICAgICAgICByZXR1cm4gYXJlQWxsRXF1aXZhbGVudCh0aGlzLnN0bXRzLCBvdGhlci5zdG10cyk7XG4gICAgfTtcbiAgICByZXR1cm4gR2VuZXJhdGVkRmlsZTtcbn0oKSk7XG5mdW5jdGlvbiB0b1R5cGVTY3JpcHQoZmlsZSwgcHJlYW1ibGUpIHtcbiAgICBpZiAocHJlYW1ibGUgPT09IHZvaWQgMCkgeyBwcmVhbWJsZSA9ICcnOyB9XG4gICAgaWYgKCFmaWxlLnN0bXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IE5vIHN0bXRzIHByZXNlbnQgb24gR2VuZXJhdGVkRmlsZSBcIiArIGZpbGUuZ2VuRmlsZVVybCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHlwZVNjcmlwdEVtaXR0ZXIoKS5lbWl0U3RhdGVtZW50cyhmaWxlLmdlbkZpbGVVcmwsIGZpbGUuc3RtdHMsIHByZWFtYmxlKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbGlzdExhenlSb3V0ZXMobW9kdWxlTWV0YSwgcmVmbGVjdG9yKSB7XG4gICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgdmFyIGFsbExhenlSb3V0ZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKG1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgX2UgPSBfZC52YWx1ZSwgcHJvdmlkZXIgPSBfZS5wcm92aWRlciwgbW9kdWxlID0gX2UubW9kdWxlO1xuICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSA9PT0gcmVmbGVjdG9yLlJPVVRFUykge1xuICAgICAgICAgICAgICAgIHZhciBsb2FkQ2hpbGRyZW4gPSBfY29sbGVjdExvYWRDaGlsZHJlbihwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbG9hZENoaWxkcmVuXzEgPSAoZV8yID0gdm9pZCAwLCBfX3ZhbHVlcyhsb2FkQ2hpbGRyZW4pKSwgbG9hZENoaWxkcmVuXzFfMSA9IGxvYWRDaGlsZHJlbl8xLm5leHQoKTsgIWxvYWRDaGlsZHJlbl8xXzEuZG9uZTsgbG9hZENoaWxkcmVuXzFfMSA9IGxvYWRDaGlsZHJlbl8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlID0gbG9hZENoaWxkcmVuXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbExhenlSb3V0ZXMucHVzaChwYXJzZUxhenlSb3V0ZShyb3V0ZSwgcmVmbGVjdG9yLCBtb2R1bGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkQ2hpbGRyZW5fMV8xICYmICFsb2FkQ2hpbGRyZW5fMV8xLmRvbmUgJiYgKF9iID0gbG9hZENoaWxkcmVuXzEucmV0dXJuKSkgX2IuY2FsbChsb2FkQ2hpbGRyZW5fMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbExhenlSb3V0ZXM7XG59XG5mdW5jdGlvbiBfY29sbGVjdExvYWRDaGlsZHJlbihyb3V0ZXMsIHRhcmdldCkge1xuICAgIHZhciBlXzMsIF9hO1xuICAgIGlmICh0YXJnZXQgPT09IHZvaWQgMCkgeyB0YXJnZXQgPSBbXTsgfVxuICAgIGlmICh0eXBlb2Ygcm91dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0YXJnZXQucHVzaChyb3V0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdXRlc18xID0gX192YWx1ZXMocm91dGVzKSwgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKTsgIXJvdXRlc18xXzEuZG9uZTsgcm91dGVzXzFfMSA9IHJvdXRlc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgX2NvbGxlY3RMb2FkQ2hpbGRyZW4ocm91dGUsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXNfMV8xICYmICFyb3V0ZXNfMV8xLmRvbmUgJiYgKF9hID0gcm91dGVzXzEucmV0dXJuKSkgX2EuY2FsbChyb3V0ZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocm91dGVzLmxvYWRDaGlsZHJlbikge1xuICAgICAgICBfY29sbGVjdExvYWRDaGlsZHJlbihyb3V0ZXMubG9hZENoaWxkcmVuLCB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyb3V0ZXMuY2hpbGRyZW4pIHtcbiAgICAgICAgX2NvbGxlY3RMb2FkQ2hpbGRyZW4ocm91dGVzLmNoaWxkcmVuLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcGFyc2VMYXp5Um91dGUocm91dGUsIHJlZmxlY3RvciwgbW9kdWxlKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHJvdXRlLnNwbGl0KCcjJyksIDIpLCByb3V0ZVBhdGggPSBfYVswXSwgcm91dGVOYW1lID0gX2FbMV07XG4gICAgdmFyIHJlZmVyZW5jZWRNb2R1bGUgPSByZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKHtcbiAgICAgICAgbW9kdWxlTmFtZTogcm91dGVQYXRoLFxuICAgICAgICBuYW1lOiByb3V0ZU5hbWUsXG4gICAgfSwgbW9kdWxlID8gbW9kdWxlLmZpbGVQYXRoIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyByb3V0ZTogcm91dGUsIG1vZHVsZTogbW9kdWxlIHx8IHJlZmVyZW5jZWRNb2R1bGUsIHJlZmVyZW5jZWRNb2R1bGU6IHJlZmVyZW5jZWRNb2R1bGUgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRTID0gL14oPyEuKlxcLmRcXC50cyQpLipcXC50cyQvO1xudmFyIFJlc29sdmVkU3RhdGljU3ltYm9sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVkU3RhdGljU3ltYm9sKHN5bWJvbCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc29sdmVkU3RhdGljU3ltYm9sO1xufSgpKTtcbnZhciBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT04gPSA0O1xuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIG1ldGFkYXRhIHBlciBzeW1ib2wsXG4gKiBhbmQgbm9ybWFsaXppbmcgcmVmZXJlbmNlcyBiZXR3ZWVuIHN5bWJvbHMuXG4gKlxuICogSW50ZXJuYWxseSwgaXQgb25seSB1c2VzIHN5bWJvbHMgd2l0aG91dCBtZW1iZXJzLFxuICogYW5kIGRlZHVjZXMgdGhlIHZhbHVlcyBmb3Igc3ltYm9scyB3aXRoIG1lbWJlcnMgYmFzZWRcbiAqIG9uIHRoZXNlIHN5bWJvbHMuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2xSZXNvbHZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzdGF0aWNTeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IGVycm9yUmVjb3JkZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIG9ubHkgY29udGFpbiBTdGF0aWNTeW1ib2xzIHdpdGhvdXQgbWVtYmVycyFcbiAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5vdGU6IHRoaXMgd2lsbCBvbmx5IGNvbnRhaW4gU3RhdGljU3ltYm9scyB3aXRob3V0IG1lbWJlcnMhXG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTeW1ib2wgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIGlmIChzdGF0aWNTeW1ib2wubWVtYmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVN5bWJvbE1lbWJlcnMoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBhbHdheXMgYXNrIGZvciBhIHN1bW1hcnkgZmlyc3QsXG4gICAgICAgIC8vIGFzIHdlIG1pZ2h0IGhhdmUgcmVhZCBzaGFsbG93IG1ldGFkYXRhIHZpYSBhIC5kLnRzIGZpbGVcbiAgICAgICAgLy8gZm9yIHRoZSBzeW1ib2wuXG4gICAgICAgIHZhciByZXN1bHRGcm9tU3VtbWFyeSA9IHRoaXMuX3Jlc29sdmVTeW1ib2xGcm9tU3VtbWFyeShzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAocmVzdWx0RnJvbVN1bW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRGcm9tU3VtbWFyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0RnJvbUNhY2hlID0gdGhpcy5yZXNvbHZlZFN5bWJvbHMuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmIChyZXN1bHRGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRGcm9tQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogU29tZSB1c2VycyB1c2UgbGlicmFyaWVzIHRoYXQgd2VyZSBub3QgY29tcGlsZWQgd2l0aCBuZ2MsIGkuZS4gdGhleSBkb24ndFxuICAgICAgICAvLyBoYXZlIHN1bW1hcmllcywgb25seSAuZC50cyBmaWxlcy4gU28gd2UgYWx3YXlzIG5lZWQgdG8gY2hlY2sgYm90aCwgdGhlIHN1bW1hcnlcbiAgICAgICAgLy8gYW5kIG1ldGFkYXRhLlxuICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2xzT2Yoc3RhdGljU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRTeW1ib2xzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0SW1wb3J0QXMgcHJvZHVjZXMgYSBzeW1ib2wgdGhhdCBjYW4gYmUgdXNlZCB0byBpbXBvcnQgdGhlIGdpdmVuIHN5bWJvbC5cbiAgICAgKiBUaGUgaW1wb3J0IG1pZ2h0IGJlIGRpZmZlcmVudCB0aGFuIHRoZSBzeW1ib2wgaWYgdGhlIHN5bWJvbCBpcyBleHBvcnRlZCBmcm9tXG4gICAgICogYSBsaWJyYXJ5IHdpdGggYSBzdW1tYXJ5OyBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gaW1wb3J0IHRoZSBzeW1ib2wgZnJvbSB0aGVcbiAgICAgKiBuZ2ZhY3RvcnkgcmUtZXhwb3J0IGluc3RlYWQgb2YgZGlyZWN0bHkgdG8gYXZvaWQgaW50cm9kdWNpbmcgYSBkaXJlY3QgZGVwZW5kZW5jeVxuICAgICAqIG9uIGFuIG90aGVyd2lzZSBpbmRpcmVjdCBkZXBlbmRlbmN5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRpY1N5bWJvbCB0aGUgc3ltYm9sIGZvciB3aGljaCB0byBnZW5lcmF0ZSBhIGltcG9ydCBzeW1ib2xcbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW1wb3J0QXMgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sLCB1c2VTdW1tYXJpZXMpIHtcbiAgICAgICAgaWYgKHVzZVN1bW1hcmllcyA9PT0gdm9pZCAwKSB7IHVzZVN1bW1hcmllcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKHN0YXRpY1N5bWJvbC5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJhc2VTeW1ib2wgPSB0aGlzLmdldFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wuZmlsZVBhdGgsIHN0YXRpY1N5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgIHZhciBiYXNlSW1wb3J0QXMgPSB0aGlzLmdldEltcG9ydEFzKGJhc2VTeW1ib2wsIHVzZVN1bW1hcmllcyk7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUltcG9ydEFzID9cbiAgICAgICAgICAgICAgICB0aGlzLmdldFN0YXRpY1N5bWJvbChiYXNlSW1wb3J0QXMuZmlsZVBhdGgsIGJhc2VJbXBvcnRBcy5uYW1lLCBzdGF0aWNTeW1ib2wubWVtYmVycykgOlxuICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1bW1hcml6ZWRGaWxlTmFtZSA9IHN0cmlwU3VtbWFyeUZvckppdEZpbGVTdWZmaXgoc3RhdGljU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgaWYgKHN1bW1hcml6ZWRGaWxlTmFtZSAhPT0gc3RhdGljU3ltYm9sLmZpbGVQYXRoKSB7XG4gICAgICAgICAgICB2YXIgc3VtbWFyaXplZE5hbWUgPSBzdHJpcFN1bW1hcnlGb3JKaXROYW1lU3VmZml4KHN0YXRpY1N5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgIHZhciBiYXNlU3ltYm9sID0gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3VtbWFyaXplZEZpbGVOYW1lLCBzdW1tYXJpemVkTmFtZSwgc3RhdGljU3ltYm9sLm1lbWJlcnMpO1xuICAgICAgICAgICAgdmFyIGJhc2VJbXBvcnRBcyA9IHRoaXMuZ2V0SW1wb3J0QXMoYmFzZVN5bWJvbCwgdXNlU3VtbWFyaWVzKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW1wb3J0QXMgPyB0aGlzLmdldFN0YXRpY1N5bWJvbChzdW1tYXJ5Rm9ySml0RmlsZU5hbWUoYmFzZUltcG9ydEFzLmZpbGVQYXRoKSwgc3VtbWFyeUZvckppdE5hbWUoYmFzZUltcG9ydEFzLm5hbWUpLCBiYXNlU3ltYm9sLm1lbWJlcnMpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAodXNlU3VtbWFyaWVzICYmIHRoaXMuc3VtbWFyeVJlc29sdmVyLmdldEltcG9ydEFzKHN0YXRpY1N5bWJvbCkpIHx8IG51bGw7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmltcG9ydEFzLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRSZXNvdXJjZVBhdGggcHJvZHVjZXMgdGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wgYW5kIHNob3VsZFxuICAgICAqIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSByZWxhdGl2ZSBsb2NhdGlvbiBvZiByZXNvdXJjZSByZWZlcmVuY2VzIHJlY29yZGVkIGluXG4gICAgICogc3ltYm9sIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRSZXNvdXJjZVBhdGggPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZ2V0KHN0YXRpY1N5bWJvbCkgfHwgc3RhdGljU3ltYm9sLmZpbGVQYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0VHlwZUFyaXR5IHJldHVybnMgdGhlIG51bWJlciBvZiBnZW5lcmljIHR5cGUgcGFyYW1ldGVycyB0aGUgZ2l2ZW4gc3ltYm9sXG4gICAgICogaGFzLiBJZiB0aGUgc3ltYm9sIGlzIG5vdCBhIHR5cGUgdGhlIHJlc3VsdCBpcyBudWxsLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRUeXBlQXJpdHkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIGEgZmFjdG9yeS9uZ3N1bW1hcnkgZmlsZSwgZG9uJ3QgcmVzb2x2ZSB0aGUgc3ltYm9sIGFzIGRvaW5nIHNvIHdvdWxkXG4gICAgICAgIC8vIGNhdXNlIHRoZSBtZXRhZGF0YSBmb3IgYW4gZmFjdG9yeS9uZ3N1bW1hcnkgZmlsZSB0byBiZSBsb2FkZWQgd2hpY2ggZG9lc24ndCBleGlzdC5cbiAgICAgICAgLy8gQWxsIHJlZmVyZW5jZXMgdG8gZ2VuZXJhdGVkIGNsYXNzZXMgbXVzdCBpbmNsdWRlIHRoZSBjb3JyZWN0IGFyaXR5IHdoZW5ldmVyXG4gICAgICAgIC8vIGdlbmVyYXRpbmcgY29kZS5cbiAgICAgICAgaWYgKGlzR2VuZXJhdGVkRmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKHRoaXMucmVzb2x2ZVN5bWJvbChzdGF0aWNTeW1ib2wpKTtcbiAgICAgICAgd2hpbGUgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXNvbHZlZFN5bWJvbCA9IHVud3JhcFJlc29sdmVkTWV0YWRhdGEodGhpcy5yZXNvbHZlU3ltYm9sKHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YS5hcml0eSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRLbm93bk1vZHVsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuZ2V0KGZpbGVQYXRoKSB8fCBudWxsO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLnJlY29yZEltcG9ydEFzID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICB0aGlzLmltcG9ydEFzLnNldChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCk7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUucmVjb3JkTW9kdWxlTmFtZUZvckZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lLCBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuc2V0KGZpbGVOYW1lLCBtb2R1bGVOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGUgYWxsIGluZm9ybWF0aW9uIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gZmlsZSBhbmQgcmV0dXJuIHRoZVxuICAgICAqIHN0YXRpYyBzeW1ib2xzIGNvbnRhaW5lZCBpbiB0aGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSB0aGUgZmlsZSB0byBpbnZhbGlkYXRlXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmludmFsaWRhdGVGaWxlID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSB0aGlzLnN5bWJvbEZyb21GaWxlLmdldChmaWxlTmFtZSk7XG4gICAgICAgIGlmICghc3ltYm9scykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHN5bWJvbHNfMSA9IF9fdmFsdWVzKHN5bWJvbHMpLCBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCk7ICFzeW1ib2xzXzFfMS5kb25lOyBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRBcy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xzXzFfMSAmJiAhc3ltYm9sc18xXzEuZG9uZSAmJiAoX2EgPSBzeW1ib2xzXzEucmV0dXJuKSkgX2EuY2FsbChzeW1ib2xzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW1ib2xzO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5pZ25vcmVFcnJvcnNGb3IgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIHJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IHJlY29yZGVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVTeW1ib2xNZW1iZXJzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHN0YXRpY1N5bWJvbC5tZW1iZXJzO1xuICAgICAgICB2YXIgYmFzZVJlc29sdmVkU3ltYm9sID0gdGhpcy5yZXNvbHZlU3ltYm9sKHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbC5maWxlUGF0aCwgc3RhdGljU3ltYm9sLm5hbWUpKTtcbiAgICAgICAgaWYgKCFiYXNlUmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlTWV0YWRhdGEgPSB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKGJhc2VSZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSk7XG4gICAgICAgIGlmIChiYXNlTWV0YWRhdGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCB0aGlzLmdldFN0YXRpY1N5bWJvbChiYXNlTWV0YWRhdGEuZmlsZVBhdGgsIGJhc2VNZXRhZGF0YS5uYW1lLCBtZW1iZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFzZU1ldGFkYXRhICYmIGJhc2VNZXRhZGF0YS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBpZiAoYmFzZU1ldGFkYXRhLnN0YXRpY3MgJiYgbWVtYmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgYmFzZU1ldGFkYXRhLnN0YXRpY3NbbWVtYmVyc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYmFzZU1ldGFkYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aCAmJiB2YWx1ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVttZW1iZXJzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVTeW1ib2xGcm9tU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzdGF0aWNTeW1ib2wpO1xuICAgICAgICByZXR1cm4gc3VtbWFyeSA/IG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wsIHN1bW1hcnkubWV0YWRhdGEpIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWNsYXJhdGlvbkZpbGUgdGhlIGFic29sdXRlIHBhdGggb2YgdGhlIGZpbGUgd2hlcmUgdGhlIHN5bWJvbCBpcyBkZWNsYXJlZFxuICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgICAqIEBwYXJhbSBtZW1iZXJzIGEgc3ltYm9sIGZvciBhIHN0YXRpYyBtZW1iZXIgb2YgdGhlIG5hbWVkIHR5cGVcbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNTeW1ib2xDYWNoZS5nZXQoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGhhc0RlY29yYXRvcnMgY2hlY2tzIGEgZmlsZSdzIG1ldGFkYXRhIGZvciB0aGUgcHJlc2VuY2Ugb2YgZGVjb3JhdG9ycyB3aXRob3V0IGV2YWx1YXRpbmcgdGhlXG4gICAgICogbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggdGhlIGFic29sdXRlIHBhdGggdG8gZXhhbWluZSBmb3IgZGVjb3JhdG9ycy5cbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGFueSBjbGFzcyBpbiB0aGUgZmlsZSBoYXMgYSBkZWNvcmF0b3IuXG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmhhc0RlY29yYXRvcnMgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRNb2R1bGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVsnbWV0YWRhdGEnXSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1ldGFkYXRhWydtZXRhZGF0YSddKS5zb21lKGZ1bmN0aW9uIChtZXRhZGF0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG1ldGFkYXRhWydtZXRhZGF0YSddW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJyAmJiBlbnRyeS5kZWNvcmF0b3JzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgc3VtbWFyeVN5bWJvbHMgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRTeW1ib2xzT2YoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoc3VtbWFyeVN5bWJvbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdW1tYXJ5U3ltYm9scztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBTb21lIHVzZXJzIHVzZSBsaWJyYXJpZXMgdGhhdCB3ZXJlIG5vdCBjb21waWxlZCB3aXRoIG5nYywgaS5lLiB0aGV5IGRvbid0XG4gICAgICAgIC8vIGhhdmUgc3VtbWFyaWVzLCBvbmx5IC5kLnRzIGZpbGVzLCBidXQgYHN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlYCByZXR1cm5zIHRydWUuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbHNPZihmaWxlUGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbEZyb21GaWxlLmdldChmaWxlUGF0aCkgfHwgW107XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX2NyZWF0ZVN5bWJvbHNPZiA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9sRnJvbUZpbGUuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlZFN5bWJvbHMgPSBbXTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5nZXRNb2R1bGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgIGlmIChtZXRhZGF0YVsnaW1wb3J0QXMnXSkge1xuICAgICAgICAgICAgLy8gSW5kZXggYnVuZGxlIGluZGljZXMgc2hvdWxkIHVzZSB0aGUgaW1wb3J0QXMgbW9kdWxlIG5hbWUgZGVmaW5lZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGJ1bmRsZS5cbiAgICAgICAgICAgIHRoaXMua25vd25GaWxlTmFtZVRvTW9kdWxlTmFtZXMuc2V0KGZpbGVQYXRoLCBtZXRhZGF0YVsnaW1wb3J0QXMnXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIGluIG9uZSBvZiB0aGUgcmUtZXhwb3J0IGxvY2F0aW9uXG4gICAgICAgIGlmIChtZXRhZGF0YVsnZXhwb3J0cyddKSB7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChtb2R1bGVFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgaW4gdGhlIGxpc3Qgb2YgZXhwbGljaXRseSByZS1leHBvcnRlZCBzeW1ib2xzLlxuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVFeHBvcnQuZXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUV4cG9ydC5leHBvcnQuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSBleHBvcnRTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gZXhwb3J0U3ltYm9sLmFzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihzeW1ib2xOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1OYW1lID0gc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bU5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIoZXhwb3J0U3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkTW9kdWxlID0gX3RoaXMucmVzb2x2ZU1vZHVsZShtb2R1bGVFeHBvcnQuZnJvbSwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChyZXNvbHZlZE1vZHVsZSwgc3ltTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgc3ltYm9sTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlRXhwb3J0KHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBzeW1ib2xzIGxvYWRlZCBieSAnZXhwb3J0IConIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZE1vZHVsZSA9IHRoaXNfMS5yZXNvbHZlTW9kdWxlKG1vZHVsZUV4cG9ydC5mcm9tLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZE1vZHVsZSAmJiByZXNvbHZlZE1vZHVsZSAhPT0gZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXN0ZWRFeHBvcnRzID0gdGhpc18xLmdldFN5bWJvbHNPZihyZXNvbHZlZE1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHRhcmdldFN5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKG1ldGFkYXRhWydleHBvcnRzJ10pLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVFeHBvcnQgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShtb2R1bGVFeHBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgdGhlIGFjdHVhbCBtZXRhZGF0YS4gSGFzIHRvIGJlIGFmdGVyIHRoZSBleHBvcnRzXG4gICAgICAgIC8vIGFzIHRoZXJlIG1pZ2h0IGJlIGNvbGxpc2lvbnMgaW4gdGhlIG5hbWVzLCBhbmQgd2Ugd2FudCB0aGUgc3ltYm9sc1xuICAgICAgICAvLyBvZiB0aGUgY3VycmVudCBtb2R1bGUgdG8gd2luIG9mdGVyIHJlZXhwb3J0cy5cbiAgICAgICAgaWYgKG1ldGFkYXRhWydtZXRhZGF0YSddKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGlyZWN0IGRlY2xhcmF0aW9ucyBvZiB0aGUgc3ltYm9sXG4gICAgICAgICAgICB2YXIgdG9wTGV2ZWxTeW1ib2xOYW1lc18xID0gbmV3IFNldChPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkubWFwKHVuZXNjYXBlSWRlbnRpZmllcikpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbnNfMSA9IG1ldGFkYXRhWydvcmlnaW5zJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkuZm9yRWFjaChmdW5jdGlvbiAobWV0YWRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sTWV0YSA9IG1ldGFkYXRhWydtZXRhZGF0YSddW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHVuZXNjYXBlSWRlbnRpZmllcihtZXRhZGF0YUtleSk7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG9yaWdpbnNfMS5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUtleSkgJiYgb3JpZ2luc18xW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgaXMgZnJvbSBhIGJ1bmRsZWQgaW5kZXgsIHVzZSB0aGUgZGVjbGFyYXRpb24gbG9jYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbCBzbyByZWxhdGl2ZSByZWZlcmVuY2VzIChzdWNoIGFzICcuL215Lmh0bWwnKSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luRmlsZVBhdGggPSBfdGhpcy5yZXNvbHZlTW9kdWxlKG9yaWdpbiwgZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJDb3VsZG4ndCByZXNvbHZlIG9yaWdpbmFsIHN5bWJvbCBmb3IgXCIgKyBvcmlnaW4gKyBcIiBmcm9tIFwiICsgX3RoaXMuaG9zdC5nZXRPdXRwdXROYW1lKGZpbGVQYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5zZXQoc3ltYm9sLCBvcmlnaW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlUmVzb2x2ZWRTeW1ib2woc3ltYm9sLCBmaWxlUGF0aCwgdG9wTGV2ZWxTeW1ib2xOYW1lc18xLCBzeW1ib2xNZXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5pcXVlU3ltYm9scyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHJlc29sdmVkU3ltYm9sc18xID0gX192YWx1ZXMocmVzb2x2ZWRTeW1ib2xzKSwgcmVzb2x2ZWRTeW1ib2xzXzFfMSA9IHJlc29sdmVkU3ltYm9sc18xLm5leHQoKTsgIXJlc29sdmVkU3ltYm9sc18xXzEuZG9uZTsgcmVzb2x2ZWRTeW1ib2xzXzFfMSA9IHJlc29sdmVkU3ltYm9sc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZFN5bWJvbCA9IHJlc29sdmVkU3ltYm9sc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMuc2V0KHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgcmVzb2x2ZWRTeW1ib2wpO1xuICAgICAgICAgICAgICAgIHVuaXF1ZVN5bWJvbHMuYWRkKHJlc29sdmVkU3ltYm9sLnN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbHNfMV8xICYmICFyZXNvbHZlZFN5bWJvbHNfMV8xLmRvbmUgJiYgKF9iID0gcmVzb2x2ZWRTeW1ib2xzXzEucmV0dXJuKSkgX2IuY2FsbChyZXNvbHZlZFN5bWJvbHNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZS5zZXQoZmlsZVBhdGgsIEFycmF5LmZyb20odW5pcXVlU3ltYm9scykpO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmNyZWF0ZVJlc29sdmVkU3ltYm9sID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdG9wTGV2ZWxQYXRoLCB0b3BMZXZlbFN5bWJvbE5hbWVzLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgQW5ndWxhciBzdW1tYXJpZXMgLyBtZXRhZGF0YSxcbiAgICAgICAgLy8gd2Ugb25seSBrZWVwIHRoZWlyIGFyaXR5LCBidXQgbm90aGluZyBlbHNlXG4gICAgICAgIC8vIChlLmcuIHRoZWlyIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMpLlxuICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIHByZXZlbnQgaW50cm9kdWNpbmcgZGVlcCBpbXBvcnRzXG4gICAgICAgIC8vIGFzIHdlIGRpZG4ndCBnZW5lcmF0ZSAubmdmYWN0b3J5LnRzIGZpbGVzIHdpdGggcHJvcGVyIHJlZXhwb3J0cy5cbiAgICAgICAgdmFyIGlzVHNGaWxlID0gVFMudGVzdChzb3VyY2VTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpICYmICFpc1RzRmlsZSAmJiBtZXRhZGF0YSAmJlxuICAgICAgICAgICAgbWV0YWRhdGFbJ19fc3ltYm9saWMnXSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkTWV0YV8xID0geyBfX3N5bWJvbGljOiAnY2xhc3MnLCBhcml0eTogbWV0YWRhdGEuYXJpdHkgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0cmFuc2Zvcm1lZE1ldGFfMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9vcmlnaW5hbEZpbGVNZW1vO1xuICAgICAgICB2YXIgZ2V0T3JpZ2luYWxOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfb3JpZ2luYWxGaWxlTWVtbykge1xuICAgICAgICAgICAgICAgIC8vIEd1ZXNzIHdoYXQgdGhlIG9yaWdpbmFsIGZpbGUgbmFtZSBpcyBmcm9tIHRoZSByZWZlcmVuY2UuIElmIGl0IGhhcyBhIGAuZC50c2AgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBpdCB3aXRoIGAudHNgLiBJZiBpdCBhbHJlYWR5IGhhcyBgLnRzYCBqdXN0IGxlYXZlIGl0IGluIHBsYWNlLiBJZiBpdCBkb2Vzbid0IGhhdmVcbiAgICAgICAgICAgICAgICAvLyAudHMgb3IgLmQudHMsIGFwcGVuZCBgLnRzJy4gQWxzbywgaWYgaXQgaXMgaW4gYG5vZGVfbW9kdWxlc2AsIHRyaW0gdGhlIGBub2RlX21vZHVsZWBcbiAgICAgICAgICAgICAgICAvLyBsb2NhdGlvbiBhcyBpdCBpcyBub3QgaW1wb3J0YW50IHRvIGZpbmRpbmcgdGhlIGZpbGUuXG4gICAgICAgICAgICAgICAgX29yaWdpbmFsRmlsZU1lbW8gPVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ob3N0LmdldE91dHB1dE5hbWUodG9wTGV2ZWxQYXRoLnJlcGxhY2UoLygoXFwudHMpfChcXC5kXFwudHMpfCkkLywgJy50cycpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXi4qbm9kZV9tb2R1bGVzWy9cXFxcXS8sICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX29yaWdpbmFsRmlsZU1lbW87XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIFJlZmVyZW5jZVRyYW5zZm9ybWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKFJlZmVyZW5jZVRyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmZXJlbmNlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9saWMgPSBtYXBbJ19fc3ltYm9saWMnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9saWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZExlbiA9IGZ1bmN0aW9uUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMucHVzaC5hcHBseShmdW5jdGlvblBhcmFtcywgX19zcHJlYWQoKG1hcFsncGFyYW1ldGVycyddIHx8IFtdKSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblBhcmFtcy5sZW5ndGggPSBvbGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbGljID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlID0gbWFwWydtb2R1bGUnXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG1hcFsnbmFtZSddID8gdW5lc2NhcGVJZGVudGlmaWVyKG1hcFsnbmFtZSddKSA6IG1hcFsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVQYXRoID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aCA9IHNlbGYucmVzb2x2ZU1vZHVsZShtb2R1bGUsIHNvdXJjZVN5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zeW1ib2xpYzogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDb3VsZCBub3QgcmVzb2x2ZSBcIiArIG1vZHVsZSArIFwiIHJlbGF0aXZlIHRvIFwiICsgc2VsZi5ob3N0LmdldE1ldGFkYXRhRm9yKHNvdXJjZVN5bWJvbC5maWxlUGF0aCkgKyBcIi5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbWFwWydsaW5lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbWFwWydjaGFyYWN0ZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGdldE9yaWdpbmFsTmFtZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zeW1ib2xpYzogJ3Jlc29sdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHNlbGYuZ2V0U3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lXzEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IG1hcFsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbWFwWydjaGFyYWN0ZXInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZ2V0T3JpZ2luYWxOYW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25QYXJhbXMuaW5kZXhPZihuYW1lXzEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgX19zeW1ib2xpYzogJ3JlZmVyZW5jZScsIG5hbWU6IG5hbWVfMSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcExldmVsU3ltYm9sTmFtZXMuaGFzKG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2wodG9wTGV2ZWxQYXRoLCBuYW1lXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW1iaWVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xpYyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIG1hcCksIHsgZmlsZU5hbWU6IGdldE9yaWdpbmFsTmFtZSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAuY2FsbCh0aGlzLCBtYXAsIGZ1bmN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFJlZmVyZW5jZVRyYW5zZm9ybWVyO1xuICAgICAgICB9KFZhbHVlVHJhbnNmb3JtZXIpKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkTWV0YSA9IHZpc2l0VmFsdWUobWV0YWRhdGEsIG5ldyBSZWZlcmVuY2VUcmFuc2Zvcm1lcigpLCBbXSk7XG4gICAgICAgIHZhciB1bndyYXBwZWRUcmFuc2Zvcm1lZE1ldGEgPSB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgICAgIGlmICh1bndyYXBwZWRUcmFuc2Zvcm1lZE1ldGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4cG9ydChzb3VyY2VTeW1ib2wsIHVud3JhcHBlZFRyYW5zZm9ybWVkTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFN0YXRpY1N5bWJvbChzb3VyY2VTeW1ib2wsIHRyYW5zZm9ybWVkTWV0YSk7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlRXhwb3J0ID0gZnVuY3Rpb24gKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSB7XG4gICAgICAgIHNvdXJjZVN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGFyZ2V0U3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICBpZiAodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShzb3VyY2VTeW1ib2wuZmlsZVBhdGgpICYmXG4gICAgICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHRhcmdldFN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FzZSBpcyBmb3IgYW4gbmcgbGlicmFyeSBpbXBvcnRpbmcgc3ltYm9scyBmcm9tIGEgcGxhaW4gdHMgbGlicmFyeVxuICAgICAgICAgICAgLy8gdHJhbnNpdGl2ZWx5LlxuICAgICAgICAgICAgLy8gTm90ZTogV2UgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHdlIGRpc2NvdmVyIHN5bWJvbHMgaW4gdGhlIGRpcmVjdGlvblxuICAgICAgICAgICAgLy8gZnJvbSBzb3VyY2UgZmlsZXMgdG8gbGlicmFyeSBmaWxlc1xuICAgICAgICAgICAgdGhpcy5pbXBvcnRBcy5zZXQodGFyZ2V0U3ltYm9sLCB0aGlzLmdldEltcG9ydEFzKHNvdXJjZVN5bWJvbCkgfHwgc291cmNlU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKTtcbiAgICB9O1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIoZXJyb3IsIChjb250ZXh0ICYmIGNvbnRleHQuZmlsZVBhdGgpIHx8IHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtb2R1bGUgYW4gYWJzb2x1dGUgcGF0aCB0byBhIG1vZHVsZSBmaWxlLlxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgdmFyIG1vZHVsZU1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YUNhY2hlLmdldChtb2R1bGUpO1xuICAgICAgICBpZiAoIW1vZHVsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTWV0YWRhdGFzID0gdGhpcy5ob3N0LmdldE1ldGFkYXRhRm9yKG1vZHVsZSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlTWV0YWRhdGFzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWQgJiYgbWRbJ3ZlcnNpb24nXSA+IG1heFZlcnNpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmVyc2lvbl8xID0gbWRbJ3ZlcnNpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID0gbWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ21vZHVsZScsIHZlcnNpb246IFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTiwgbW9kdWxlOiBtb2R1bGUsIG1ldGFkYXRhOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gIT0gU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gPT0gMiA/XG4gICAgICAgICAgICAgICAgICAgIFwiVW5zdXBwb3J0ZWQgbWV0YWRhdGEgdmVyc2lvbiBcIiArIG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gKyBcIiBmb3IgbW9kdWxlIFwiICsgbW9kdWxlICsgXCIuIFRoaXMgbW9kdWxlIHNob3VsZCBiZSBjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBuZ2NcIiA6XG4gICAgICAgICAgICAgICAgICAgIFwiTWV0YWRhdGEgdmVyc2lvbiBtaXNtYXRjaCBmb3IgbW9kdWxlIFwiICsgdGhpcy5ob3N0LmdldE91dHB1dE5hbWUobW9kdWxlKSArIFwiLCBmb3VuZCB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiLCBleHBlY3RlZCBcIiArIFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5zZXQobW9kdWxlLCBtb2R1bGVNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZU1ldGFkYXRhO1xuICAgIH07XG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN5bWJvbEJ5TW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgc3ltYm9sTmFtZSwgY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgdmFyIGZpbGVQYXRoID0gdGhpcy5yZXNvbHZlTW9kdWxlKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBcIiArIG1vZHVsZSArIChjb250YWluaW5nRmlsZSA/ICcgcmVsYXRpdmUgdG8gJyArIHRoaXMuaG9zdC5nZXRPdXRwdXROYW1lKGNvbnRhaW5pbmdGaWxlKSA6ICcnKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljU3ltYm9sKFwiRVJST1I6XCIgKyBtb2R1bGUsIHN5bWJvbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgc3ltYm9sTmFtZSk7XG4gICAgfTtcbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm1vZHVsZU5hbWVUb0ZpbGVOYW1lKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgbW9kdWxlICdcIiArIG1vZHVsZSArIFwiJyByZWxhdGl2ZSB0byBmaWxlIFwiICsgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihlLCB1bmRlZmluZWQsIGNvbnRhaW5pbmdGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2xSZXNvbHZlcjtcbn0oKSk7XG4vLyBSZW1vdmUgZXh0cmEgdW5kZXJzY29yZSBmcm9tIGVzY2FwZWQgaWRlbnRpZmllci5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvYmxvYi9tYXN0ZXIvc3JjL2NvbXBpbGVyL3V0aWxpdGllcy50c1xuZnVuY3Rpb24gdW5lc2NhcGVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllci5zdGFydHNXaXRoKCdfX18nKSA/IGlkZW50aWZpZXIuc3Vic3RyKDEpIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIHVud3JhcFJlc29sdmVkTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ3Jlc29sdmVkJykge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEuc3ltYm9sO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN1bW1hcmllcyhzcmNGaWxlTmFtZSwgZm9ySml0Q3R4LCBzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyLCBzeW1ib2xzLCB0eXBlcywgY3JlYXRlRXh0ZXJuYWxTeW1ib2xSZWV4cG9ydHMpIHtcbiAgICBpZiAoY3JlYXRlRXh0ZXJuYWxTeW1ib2xSZWV4cG9ydHMgPT09IHZvaWQgMCkgeyBjcmVhdGVFeHRlcm5hbFN5bWJvbFJlZXhwb3J0cyA9IGZhbHNlOyB9XG4gICAgdmFyIHRvSnNvblNlcmlhbGl6ZXIgPSBuZXcgVG9Kc29uU2VyaWFsaXplcihzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyLCBzcmNGaWxlTmFtZSk7XG4gICAgLy8gZm9yIHN5bWJvbHMsIHdlIHVzZSBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIGNsYXNzIG1ldGFkYXRhIGl0c2VsZlxuICAgIC8vICh3ZSBrZWVwIHRoZSBzdGF0aWNzIHRob3VnaCksIGFzIHRoZSBjbGFzcyBtZXRhZGF0YSBpcyBjb250YWluZWQgaW4gdGhlXG4gICAgLy8gQ29tcGlsZVR5cGVTdW1tYXJ5LlxuICAgIHN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIHRvSnNvblNlcmlhbGl6ZXIuYWRkU3VtbWFyeSh7IHN5bWJvbDogcmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCBtZXRhZGF0YTogcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgfSk7IH0pO1xuICAgIC8vIEFkZCB0eXBlIHN1bW1hcmllcy5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgc3VtbWFyeSA9IF9hLnN1bW1hcnksIG1ldGFkYXRhID0gX2EubWV0YWRhdGE7XG4gICAgICAgIHRvSnNvblNlcmlhbGl6ZXIuYWRkU3VtbWFyeSh7IHN5bWJvbDogc3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgbWV0YWRhdGE6IHVuZGVmaW5lZCwgdHlwZTogc3VtbWFyeSB9KTtcbiAgICB9KTtcbiAgICB2YXIgX2EgPSB0b0pzb25TZXJpYWxpemVyLnNlcmlhbGl6ZShjcmVhdGVFeHRlcm5hbFN5bWJvbFJlZXhwb3J0cyksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgIGlmIChmb3JKaXRDdHgpIHtcbiAgICAgICAgdmFyIGZvckppdFNlcmlhbGl6ZXJfMSA9IG5ldyBGb3JKaXRTZXJpYWxpemVyKGZvckppdEN0eCwgc3ltYm9sUmVzb2x2ZXIsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3VtbWFyeSA9IF9hLnN1bW1hcnksIG1ldGFkYXRhID0gX2EubWV0YWRhdGE7XG4gICAgICAgICAgICBmb3JKaXRTZXJpYWxpemVyXzEuYWRkU291cmNlVHlwZShzdW1tYXJ5LCBtZXRhZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b0pzb25TZXJpYWxpemVyLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuZm9yRWFjaChmdW5jdGlvbiAoc3VtbWFyeSkge1xuICAgICAgICAgICAgaWYgKHN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN1bW1hcnkuc3ltYm9sLmZpbGVQYXRoKSAmJiBzdW1tYXJ5LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3JKaXRTZXJpYWxpemVyXzEuYWRkTGliVHlwZShzdW1tYXJ5LnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9ySml0U2VyaWFsaXplcl8xLnNlcmlhbGl6ZShleHBvcnRBcyk7XG4gICAgfVxuICAgIHJldHVybiB7IGpzb246IGpzb24sIGV4cG9ydEFzOiBleHBvcnRBcyB9O1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdW1tYXJpZXMoc3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlciwgbGlicmFyeUZpbGVOYW1lLCBqc29uKSB7XG4gICAgdmFyIGRlc2VyaWFsaXplciA9IG5ldyBGcm9tSnNvbkRlc2VyaWFsaXplcihzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVyLmRlc2VyaWFsaXplKGxpYnJhcnlGaWxlTmFtZSwganNvbik7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JKaXRTdHViKG91dHB1dEN0eCwgcmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN1bW1hcnlGb3JKaXRGdW5jdGlvbihvdXRwdXRDdHgsIHJlZmVyZW5jZSwgTlVMTF9FWFBSKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1bW1hcnlGb3JKaXRGdW5jdGlvbihvdXRwdXRDdHgsIHJlZmVyZW5jZSwgdmFsdWUpIHtcbiAgICB2YXIgZm5OYW1lID0gc3VtbWFyeUZvckppdE5hbWUocmVmZXJlbmNlLm5hbWUpO1xuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2goZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhbHVlKV0sIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKSkudG9EZWNsU3RtdChmbk5hbWUsIFtcbiAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsLCBTdG10TW9kaWZpZXIuRXhwb3J0ZWRcbiAgICBdKSk7XG59XG52YXIgVG9Kc29uU2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9Kc29uU2VyaWFsaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb0pzb25TZXJpYWxpemVyKHN5bWJvbFJlc29sdmVyLCBzdW1tYXJ5UmVzb2x2ZXIsIHNyY0ZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bWJvbFJlc29sdmVyID0gc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnN1bW1hcnlSZXNvbHZlciA9IHN1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgX3RoaXMuc3JjRmlsZU5hbWUgPSBzcmNGaWxlTmFtZTtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGNvbnRhaW5zIHN5bWJvbHMgd2l0aG91dCBtZW1iZXJzLlxuICAgICAgICBfdGhpcy5zeW1ib2xzID0gW107XG4gICAgICAgIF90aGlzLmluZGV4QnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnJlZXhwb3J0ZWRCeSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gVGhpcyBub3cgY29udGFpbnMgYSBgX19zeW1ib2w6IG51bWJlcmAgaW4gdGhlIHBsYWNlIG9mXG4gICAgICAgIC8vIFN0YXRpY1N5bWJvbHMsIGJ1dCBvdGhlcndpc2UgaGFzIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBvcmlnaW5hbCBvYmplY3RzLlxuICAgICAgICBfdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NlZFN1bW1hcmllcyA9IFtdO1xuICAgICAgICBfdGhpcy51bnByb2Nlc3NlZFN5bWJvbFN1bW1hcmllc0J5U3ltYm9sID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5tb2R1bGVOYW1lID0gc3ltYm9sUmVzb2x2ZXIuZ2V0S25vd25Nb2R1bGVOYW1lKHNyY0ZpbGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUb0pzb25TZXJpYWxpemVyLnByb3RvdHlwZS5hZGRTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVucHJvY2Vzc2VkU3VtbWFyeSA9IHRoaXMudW5wcm9jZXNzZWRTeW1ib2xTdW1tYXJpZXNCeVN5bWJvbC5nZXQoc3VtbWFyeS5zeW1ib2wpO1xuICAgICAgICB2YXIgcHJvY2Vzc2VkU3VtbWFyeSA9IHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLmdldChzdW1tYXJ5LnN5bWJvbCk7XG4gICAgICAgIGlmICghdW5wcm9jZXNzZWRTdW1tYXJ5KSB7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFN1bW1hcnkgPSB7IHN5bWJvbDogc3VtbWFyeS5zeW1ib2wsIG1ldGFkYXRhOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHRoaXMudW5wcm9jZXNzZWRTeW1ib2xTdW1tYXJpZXNCeVN5bWJvbC5zZXQoc3VtbWFyeS5zeW1ib2wsIHVucHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5ID0geyBzeW1ib2w6IHRoaXMucHJvY2Vzc1ZhbHVlKHN1bW1hcnkuc3ltYm9sLCAwIC8qIE5vbmUgKi8pIH07XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZFN1bW1hcmllcy5wdXNoKHByb2Nlc3NlZFN1bW1hcnkpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wuc2V0KHN1bW1hcnkuc3ltYm9sLCBwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVucHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSAmJiBzdW1tYXJ5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFfMSA9IHN1bW1hcnkubWV0YWRhdGEgfHwge307XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFfMS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNsYXNzZXMsIHdlIGtlZXAgZXZlcnl0aGluZyBleGNlcHQgdGhlaXIgY2xhc3MgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtlZXAgZS5nLiB0aGUgY3RvciBhcmdzLCBtZXRob2QgbmFtZXMsIG1ldGhvZCBkZWNvcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgY2xhc3MgY2FuIGJlIGV4dGVuZGVkIGluIGFub3RoZXIgY29tcGlsYXRpb24gdW5pdC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBrZWVwIHRoZSBjbGFzcyBkZWNvcmF0b3JzIGFzXG4gICAgICAgICAgICAgICAgLy8gMSkgdGhleSByZWZlciB0byBkYXRhXG4gICAgICAgICAgICAgICAgLy8gICB0aGF0IHNob3VsZCBub3QgY2F1c2UgYSByZWJ1aWxkIG9mIGRvd25zdHJlYW0gY29tcGlsYXRpb24gdW5pdHNcbiAgICAgICAgICAgICAgICAvLyAgIChlLmcuIGlubGluZSB0ZW1wbGF0ZXMgb2YgQENvbXBvbmVudCwgb3IgQE5nTW9kdWxlLmRlY2xhcmF0aW9ucylcbiAgICAgICAgICAgICAgICAvLyAyKSB0aGVpciBkYXRhIGlzIGFscmVhZHkgY2FwdHVyZWQgaW4gVHlwZVN1bW1hcmllcywgZS5nLiBEaXJlY3RpdmVTdW1tYXJ5LlxuICAgICAgICAgICAgICAgIHZhciBjbG9uZV8xID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMobWV0YWRhdGFfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lICE9PSAnZGVjb3JhdG9ycycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lXzFbcHJvcE5hbWVdID0gbWV0YWRhdGFfMVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YV8xID0gY2xvbmVfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2FsbChtZXRhZGF0YV8xKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbkNhbGwobWV0YWRhdGFfMSkgJiYgIWlzTWV0aG9kQ2FsbE9uVmFyaWFibGUobWV0YWRhdGFfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3RvcmUgY29tcGxleCBjYWxscyBhcyB3ZSB3b24ndCBiZSBhYmxlIHRvIHNpbXBsaWZ5IHRoZW0gYW55d2F5cyBsYXRlciBvbi5cbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFfMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fc3ltYm9saWM6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29tcGxleCBmdW5jdGlvbiBjYWxscyBhcmUgbm90IHN1cHBvcnRlZC4nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8ga2VlcCBzdG9yaW5nIGN0b3IgY2FsbHMgZm9yIGUuZy5cbiAgICAgICAgICAgIC8vIGBleHBvcnQgY29uc3QgeCA9IG5ldyBJbmplY3Rpb25Ub2tlbiguLi4pYFxuICAgICAgICAgICAgdW5wcm9jZXNzZWRTdW1tYXJ5Lm1ldGFkYXRhID0gbWV0YWRhdGFfMTtcbiAgICAgICAgICAgIHByb2Nlc3NlZFN1bW1hcnkubWV0YWRhdGEgPSB0aGlzLnByb2Nlc3NWYWx1ZShtZXRhZGF0YV8xLCAxIC8qIFJlc29sdmVWYWx1ZSAqLyk7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFfMSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUobWV0YWRhdGFfMS5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25TeW1ib2wgPSB0aGlzLnN5bWJvbHNbdGhpcy5pbmRleEJ5U3ltYm9sLmdldChtZXRhZGF0YV8xKV07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0xvd2VyZWRTeW1ib2woZGVjbGFyYXRpb25TeW1ib2wubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogc3ltYm9scyB0aGF0IHdlcmUgaW50cm9kdWNlZCBkdXJpbmcgY29kZWdlbiBpbiB0aGUgdXNlciBmaWxlIGNhbiBoYXZlIGEgcmVleHBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYSB1c2VyIHVzZWQgYGV4cG9ydCAqYC4gSG93ZXZlciwgd2UgY2FuJ3QgcmVseSBvbiB0aGlzIGFzIHRzaWNrbGUgd2lsbCBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGV4cG9ydCAqYCBpbnRvIG5hbWVkIGV4cG9ydHMsIHVzaW5nIG9ubHkgdGhlIGluZm9ybWF0aW9uIGZyb20gdGhlIHR5cGVjaGVja2VyLlxuICAgICAgICAgICAgICAgICAgICAvLyBBcyB3ZSBpbnRyb2R1Y2UgdGhlIG5ldyBzeW1ib2xzIGFmdGVyIHR5cGVjaGVjaywgVHNpY2tsZSBkb2VzIG5vdCBrbm93IGFib3V0IHRoZW0sXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBvbWl0cyB0aGVtIHdoZW4gZXhwYW5kaW5nIGBleHBvcnQgKmAuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvIHdlIGhhdmUgdG8ga2VlcCByZWV4cG9ydGluZyB0aGVzZSBzeW1ib2xzIG1hbnVhbGx5IHZpYSAubmdmYWN0b3J5IGZpbGVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZXhwb3J0ZWRCeS5zZXQoZGVjbGFyYXRpb25TeW1ib2wsIHN1bW1hcnkuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bnByb2Nlc3NlZFN1bW1hcnkudHlwZSAmJiBzdW1tYXJ5LnR5cGUpIHtcbiAgICAgICAgICAgIHVucHJvY2Vzc2VkU3VtbWFyeS50eXBlID0gc3VtbWFyeS50eXBlO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgYWRkIHRoZSBzdW1tYXJpZXMgb2YgYWxsIHJlZmVyZW5jZWQgc3ltYm9scyBhcyBmb3IgdGhlIFJlc29sdmVkU3ltYm9scyxcbiAgICAgICAgICAgIC8vIGFzIHRoZSB0eXBlIHN1bW1hcmllcyBhbHJlYWR5IGNvbnRhaW4gdGhlIHRyYW5zaXRpdmUgZGF0YSB0aGF0IHRoZXkgcmVxdWlyZVxuICAgICAgICAgICAgLy8gKGluIGEgbWluaW1hbCB3YXkpLlxuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeS50eXBlID0gdGhpcy5wcm9jZXNzVmFsdWUoc3VtbWFyeS50eXBlLCAwIC8qIE5vbmUgKi8pO1xuICAgICAgICAgICAgLy8gZXhjZXB0IGZvciByZWV4cG9ydGVkIGRpcmVjdGl2ZXMgLyBwaXBlcywgc28gd2UgbmVlZCB0byBzdG9yZVxuICAgICAgICAgICAgLy8gdGhlaXIgc3VtbWFyaWVzIGV4cGxpY2l0bHkuXG4gICAgICAgICAgICBpZiAoc3VtbWFyeS50eXBlLnN1bW1hcnlLaW5kID09PSBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVTdW1tYXJ5ID0gc3VtbWFyeS50eXBlO1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZERpcmVjdGl2ZXMuY29uY2F0KG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZFBpcGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gaWQucmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLnVucHJvY2Vzc2VkU3ltYm9sU3VtbWFyaWVzQnlTeW1ib2wuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5XzEgPSBfdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRTdW1tYXJ5KHN1bW1hcnlfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNyZWF0ZUV4dGVybmFsU3ltYm9sUmVleHBvcnRzIFdoZXRoZXIgZXh0ZXJuYWwgc3RhdGljIHN5bWJvbHMgc2hvdWxkIGJlIHJlLWV4cG9ydGVkLlxuICAgICAqIFRoaXMgY2FuIGJlIGVuYWJsZWQgaWYgZXh0ZXJuYWwgc3ltYm9scyBzaG91bGQgYmUgcmUtZXhwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbW9kdWxlIGluXG4gICAgICogb3JkZXIgdG8gYXZvaWQgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG1vZHVsZSBkZXBlbmRlbmNpZXMgd2hpY2ggY2FuIGJyZWFrIHN0cmljdCBkZXBlbmRlbmN5XG4gICAgICogZW5mb3JjZW1lbnRzIChhcyBpbiBHb29nbGUzKS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI1NjQ0XG4gICAgICovXG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGNyZWF0ZUV4dGVybmFsU3ltYm9sUmVleHBvcnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHBvcnRBcyA9IFtdO1xuICAgICAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IHRoaXMubW9kdWxlTmFtZSxcbiAgICAgICAgICAgIHN1bW1hcmllczogdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMsXG4gICAgICAgICAgICBzeW1ib2xzOiB0aGlzLnN5bWJvbHMubWFwKGZ1bmN0aW9uIChzeW1ib2wsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRBcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVleHBvcnRTeW1ib2wgPSBfdGhpcy5yZWV4cG9ydGVkQnkuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWV4cG9ydFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGUgZ2l2ZW4gZXh0ZXJuYWwgc3RhdGljIHN5bWJvbCBpcyBhbHJlYWR5IG1hbnVhbGx5IGV4cG9ydGVkIGJ5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlciwgd2UganVzdCBwcm94eSB0aGUgZXh0ZXJuYWwgc3RhdGljIHN5bWJvbCByZWZlcmVuY2UgdG8gdGhlIG1hbnVhbCBleHBvcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgQU9UIGNvbXBpbGVyIGltcG9ydHMgdGhlIGV4dGVybmFsIHN5bWJvbCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlciBleHBvcnQgYW5kIGRvZXMgbm90IGludHJvZHVjZSBhbm90aGVyIGRlcGVuZGVuY3kgd2hpY2ggaXMgbm90IG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEFzID0gX3RoaXMuaW5kZXhCeVN5bWJvbC5nZXQocmVleHBvcnRTeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZUV4dGVybmFsU3ltYm9sUmVleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSBnaXZlbiBleHRlcm5hbCBzdGF0aWMgc3ltYm9sIGlzICpub3QqIG1hbnVhbGx5IGV4cG9ydGVkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciwgYW5kIHdlIG1hbnVhbGx5IGNyZWF0ZSBhIHJlLWV4cG9ydCBpbiB0aGUgZmFjdG9yeSBmaWxlIHNvIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGludHJvZHVjZSBhbm90aGVyIG1vZHVsZSBkZXBlbmRlbmN5LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJ1bm5pbmcgd2l0aGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXplbCBzbyB0aGF0IHRoZSBBT1QgY29tcGlsZXIgZG9lcyBub3QgaW50cm9kdWNlIGFueSBtb2R1bGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjYW4gYnJlYWsgdGhlIHN0cmljdCBkZXBlbmRlbmN5IGVuZm9yY2VtZW50LiAoZS5nLiBhcyBpbiBHb29nbGUzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBtb3JlIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjU2NDRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW1tYXJ5ID0gX3RoaXMudW5wcm9jZXNzZWRTeW1ib2xTdW1tYXJpZXNCeVN5bWJvbC5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VtbWFyeSB8fCAhc3VtbWFyeS5tZXRhZGF0YSB8fCBzdW1tYXJ5Lm1ldGFkYXRhLl9fc3ltYm9saWMgIT09ICdpbnRlcmZhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXMgPSBzeW1ib2wubmFtZSArIFwiX1wiICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXMucHVzaCh7IHN5bWJvbDogc3ltYm9sLCBleHBvcnRBczogaW1wb3J0QXMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX19zeW1ib2w6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IF90aGlzLnN1bW1hcnlSZXNvbHZlci50b1N1bW1hcnlGaWxlTmFtZShzeW1ib2wuZmlsZVBhdGgsIF90aGlzLnNyY0ZpbGVOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXM6IGltcG9ydEFzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBqc29uOiBqc29uLCBleHBvcnRBczogZXhwb3J0QXMgfTtcbiAgICB9O1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnByb2Nlc3NWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIHRoaXMsIGZsYWdzKTtcbiAgICB9O1xuICAgIFRvSnNvblNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIuZ2V0U3RhdGljU3ltYm9sKHZhbHVlLmZpbGVQYXRoLCB2YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMudmlzaXRTdGF0aWNTeW1ib2woYmFzZVN5bWJvbCwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4geyBfX3N5bWJvbDogaW5kZXgsIG1lbWJlcnM6IHZhbHVlLm1lbWJlcnMgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyaXAgbGluZSBhbmQgY2hhcmFjdGVyIG51bWJlcnMgZnJvbSBuZ3N1bW1hcmllcy5cbiAgICAgKiBFbWl0dGluZyB0aGVtIGNhdXNlcyB3aGl0ZSBzcGFjZXMgY2hhbmdlcyB0byByZXRyaWdnZXIgdXBzdHJlYW1cbiAgICAgKiByZWNvbXBpbGF0aW9ucyBpbiBiYXplbC5cbiAgICAgKiBUT0RPOiBmaW5kIG91dCBhIHdheSB0byBoYXZlIGxpbmUgYW5kIGNoYXJhY3RlciBudW1iZXJzIGluIGVycm9ycyB3aXRob3V0XG4gICAgICogZXhjZXNzaXZlIHJlY29tcGlsYXRpb24gaW4gYmF6ZWwuXG4gICAgICovXG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChtYXBbJ19fc3ltYm9saWMnXSA9PT0gJ3Jlc29sdmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0VmFsdWUobWFwWydzeW1ib2wnXSwgdGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcFsnX19zeW1ib2xpYyddID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBkZWxldGUgbWFwWydsaW5lJ107XG4gICAgICAgICAgICBkZWxldGUgbWFwWydjaGFyYWN0ZXInXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIG9wdGlvbnMucmVzb2x2ZVZhbHVlIGlzIHRydWUsIGFuZCB0aGUgc3VtbWFyeSBmb3IgdGhlIHN5bWJvbFxuICAgICAqIHJlc29sdmVkIHRvIGEgdHlwZSBvciBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgVG9Kc29uU2VyaWFsaXplci5wcm90b3R5cGUudmlzaXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoYmFzZVN5bWJvbCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleEJ5U3ltYm9sLmdldChiYXNlU3ltYm9sKTtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSBudWxsO1xuICAgICAgICBpZiAoZmxhZ3MgJiAxIC8qIFJlc29sdmVWYWx1ZSAqLyAmJlxuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZShiYXNlU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5wcm9jZXNzZWRTeW1ib2xTdW1tYXJpZXNCeVN5bWJvbC5oYXMoYmFzZVN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3VtbWFyeSBmb3IgdGhpcyBzeW1ib2wgd2FzIGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgICAgICAvLyAtPiBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1bW1hcnkgPSB0aGlzLmxvYWRTdW1tYXJ5KGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5tZXRhZGF0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzdW1tYXJ5IGlzIGEgcmVleHBvcnRcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMudmlzaXRTdGF0aWNTeW1ib2woc3VtbWFyeS5tZXRhZGF0YSwgZmxhZ3MpO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzdW1tYXJ5IGFzIGl0IGlzIGp1c3QgYSByZWV4cG9ydCwgc28gd2UgZG9uJ3Qgd2FudCB0byBzdG9yZSBpdC5cbiAgICAgICAgICAgICAgICBzdW1tYXJ5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiA9PSBvbiBwdXJwb3NlIHRvIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQhXG4gICAgICAgICAgICAvLyBObyBzdW1tYXJ5IGFuZCB0aGUgc3ltYm9sIGlzIGFscmVhZHkgYWRkZWQgLT4gbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiA9PSBvbiBwdXJwb3NlIHRvIGNvbXBhcmUgd2l0aCB1bmRlZmluZWQhXG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc3ltYm9scy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHMucHVzaChiYXNlU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4QnlTeW1ib2wuc2V0KGJhc2VTeW1ib2wsIGluZGV4KTtcbiAgICAgICAgaWYgKHN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3VtbWFyeShzdW1tYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBUb0pzb25TZXJpYWxpemVyLnByb3RvdHlwZS5sb2FkU3VtbWFyeSA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzeW1ib2wpO1xuICAgICAgICBpZiAoIXN1bW1hcnkpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgc3ltYm9scyBtaWdodCBvcmlnaW5hdGUgZnJvbSBhIHBsYWluIHR5cGVzY3JpcHQgbGlicmFyeVxuICAgICAgICAgICAgLy8gdGhhdCBqdXN0IGV4cG9ydGVkIC5kLnRzIGFuZCAubWV0YWRhdGEuanNvbiBmaWxlcywgaS5lLiB3aGVyZSBubyBzdW1tYXJ5XG4gICAgICAgICAgICAvLyBmaWxlcyB3ZXJlIGNyZWF0ZWQuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHN1bW1hcnkgPSB7IHN5bWJvbDogcmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCBtZXRhZGF0YTogcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtbWFyeTtcbiAgICB9O1xuICAgIHJldHVybiBUb0pzb25TZXJpYWxpemVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG52YXIgRm9ySml0U2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JKaXRTZXJpYWxpemVyKG91dHB1dEN0eCwgc3ltYm9sUmVzb2x2ZXIsIHN1bW1hcnlSZXNvbHZlcikge1xuICAgICAgICB0aGlzLm91dHB1dEN0eCA9IG91dHB1dEN0eDtcbiAgICAgICAgdGhpcy5zeW1ib2xSZXNvbHZlciA9IHN5bWJvbFJlc29sdmVyO1xuICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlciA9IHN1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIEZvckppdFNlcmlhbGl6ZXIucHJvdG90eXBlLmFkZFNvdXJjZVR5cGUgPSBmdW5jdGlvbiAoc3VtbWFyeSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goeyBzdW1tYXJ5OiBzdW1tYXJ5LCBtZXRhZGF0YTogbWV0YWRhdGEsIGlzTGlicmFyeTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5hZGRMaWJUeXBlID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goeyBzdW1tYXJ5OiBzdW1tYXJ5LCBtZXRhZGF0YTogbnVsbCwgaXNMaWJyYXJ5OiB0cnVlIH0pO1xuICAgIH07XG4gICAgRm9ySml0U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGV4cG9ydEFzQXJyKSB7XG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iLCBlXzMsIF9jO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwb3J0QXNCeVN5bWJvbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGV4cG9ydEFzQXJyXzEgPSBfX3ZhbHVlcyhleHBvcnRBc0FyciksIGV4cG9ydEFzQXJyXzFfMSA9IGV4cG9ydEFzQXJyXzEubmV4dCgpOyAhZXhwb3J0QXNBcnJfMV8xLmRvbmU7IGV4cG9ydEFzQXJyXzFfMSA9IGV4cG9ydEFzQXJyXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kID0gZXhwb3J0QXNBcnJfMV8xLnZhbHVlLCBzeW1ib2wgPSBfZC5zeW1ib2wsIGV4cG9ydEFzID0gX2QuZXhwb3J0QXM7XG4gICAgICAgICAgICAgICAgZXhwb3J0QXNCeVN5bWJvbC5zZXQoc3ltYm9sLCBleHBvcnRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRBc0Fycl8xXzEgJiYgIWV4cG9ydEFzQXJyXzFfMS5kb25lICYmIChfYSA9IGV4cG9ydEFzQXJyXzEucmV0dXJuKSkgX2EuY2FsbChleHBvcnRBc0Fycl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmdNb2R1bGVTeW1ib2xzID0gbmV3IFNldCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyh0aGlzLmRhdGEpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nID0gX2YudmFsdWUsIHN1bW1hcnkgPSBfZy5zdW1tYXJ5LCBtZXRhZGF0YSA9IF9nLm1ldGFkYXRhLCBpc0xpYnJhcnkgPSBfZy5pc0xpYnJhcnk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBzeW1ib2xzIHRoYXQgcmVmZXIgdG8gTmdNb2R1bGUgY2xhc3Nlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogd2UgY2FuJ3QganVzdCByZWx5IG9uIGBzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmRgIHRvIGRldGVybWluZSB0aGlzIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGFkZCB0aGUgc3VtbWFyaWVzIG9mIGFsbCByZWZlcmVuY2VkIHN5bWJvbHMgd2hlbiB3ZSBzZXJpYWxpemUgdHlwZSBzdW1tYXJpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBzZXJpYWxpemVTdW1tYXJpZXMgZm9yIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgICAgIG5nTW9kdWxlU3ltYm9scy5hZGQoc3VtbWFyeS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RTdW1tYXJ5ID0gc3VtbWFyeTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9oID0gKGVfMyA9IHZvaWQgMCwgX192YWx1ZXMobW9kU3VtbWFyeS5tb2R1bGVzKSksIF9qID0gX2gubmV4dCgpOyAhX2ouZG9uZTsgX2ogPSBfaC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gX2oudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmdNb2R1bGVTeW1ib2xzLmFkZChtb2QucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9qICYmICFfai5kb25lICYmIChfYyA9IF9oLnJldHVybikpIF9jLmNhbGwoX2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNMaWJyYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbk5hbWUgPSBzdW1tYXJ5Rm9ySml0TmFtZShzdW1tYXJ5LnR5cGUucmVmZXJlbmNlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTdW1tYXJ5Rm9ySml0RnVuY3Rpb24odGhpcy5vdXRwdXRDdHgsIHN1bW1hcnkudHlwZS5yZWZlcmVuY2UsIHRoaXMuc2VyaWFsaXplU3VtbWFyeVdpdGhEZXBzKHN1bW1hcnksIG1ldGFkYXRhKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgbmdNb2R1bGVTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlU3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUobmdNb2R1bGVTeW1ib2wuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9ydEFzID0gZXhwb3J0QXNCeVN5bWJvbC5nZXQobmdNb2R1bGVTeW1ib2wpIHx8IG5nTW9kdWxlU3ltYm9sLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGppdEV4cG9ydEFzTmFtZSA9IHN1bW1hcnlGb3JKaXROYW1lKGV4cG9ydEFzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vdXRwdXRDdHguc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGppdEV4cG9ydEFzTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldChfdGhpcy5zZXJpYWxpemVTdW1tYXJ5UmVmKG5nTW9kdWxlU3ltYm9sKSlcbiAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5FeHBvcnRlZF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVTdW1tYXJ5V2l0aERlcHMgPSBmdW5jdGlvbiAoc3VtbWFyeSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW3RoaXMuc2VyaWFsaXplU3VtbWFyeShzdW1tYXJ5KV07XG4gICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGFkYXRhIGluc3RhbmNlb2YgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2guYXBwbHkoZXhwcmVzc2lvbnMsIF9fc3ByZWFkKFxuICAgICAgICAgICAgLy8gRm9yIGRpcmVjdGl2ZXMgLyBwaXBlcywgd2Ugb25seSBhZGQgdGhlIGRlY2xhcmVkIG9uZXMsXG4gICAgICAgICAgICAvLyBhbmQgcmVseSBvbiB0cmFuc2l0aXZlbHkgaW1wb3J0aW5nIE5nTW9kdWxlcyB0byBnZXQgdGhlIHRyYW5zaXRpdmVcbiAgICAgICAgICAgIC8vIHN1bW1hcmllcy5cbiAgICAgICAgICAgIG1ldGFkYXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5jb25jYXQobWV0YWRhdGEuZGVjbGFyZWRQaXBlcylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLnJlZmVyZW5jZTsgfSlcbiAgICAgICAgICAgICAgICAvLyBGb3IgbW9kdWxlcyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBhbHNvIGFkZCB0aGUgc3VtbWFyaWVzIGZvciBtb2R1bGVzXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBsaWJyYXJpZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvayBhcyB3ZSBwcm9kdWNlIHJlZXhwb3J0cyBmb3IgYWxsIHRyYW5zaXRpdmUgbW9kdWxlcy5cbiAgICAgICAgICAgICAgICAuY29uY2F0KG1ldGFkYXRhLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUucmVmZXJlbmNlOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmICE9PSBtZXRhZGF0YS50eXBlLnJlZmVyZW5jZTsgfSkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5zZXJpYWxpemVTdW1tYXJ5UmVmKHJlZik7IH0pKSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCB1c2UgYE5nTW9kdWxlU3VtbWFyeS5wcm92aWRlcnNgLCBhcyB0aGF0IG9uZSBpcyB0cmFuc2l0aXZlLFxuICAgICAgICAgICAgLy8gYW5kIHdlIGFscmVhZHkgaGF2ZSB0cmFuc2l0aXZlIG1vZHVsZXMuXG4gICAgICAgICAgICBwcm92aWRlcnMgPSBtZXRhZGF0YS5wcm92aWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VtbWFyeS5zdW1tYXJ5S2luZCA9PT0gQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGRpclN1bW1hcnkgPSBzdW1tYXJ5O1xuICAgICAgICAgICAgcHJvdmlkZXJzID0gZGlyU3VtbWFyeS5wcm92aWRlcnMuY29uY2F0KGRpclN1bW1hcnkudmlld1Byb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QganVzdCByZWZlciB0byB0aGUgYG5nc3VtbWFyeS50c2AgZmlsZXMgZm9yIGB1c2VDbGFzc2AgcHJvdmlkZXJzIChhcyB3ZSBkbyBmb3JcbiAgICAgICAgLy8gZGVjbGFyZWREaXJlY3RpdmVzIC8gZGVjbGFyZWRQaXBlcyksIGFzIHdlIGFsbG93XG4gICAgICAgIC8vIHByb3ZpZGVycyB3aXRob3V0IGN0b3IgYXJndW1lbnRzIHRvIHNraXAgdGhlIGBASW5qZWN0YWJsZWAgZGVjb3JhdG9yLFxuICAgICAgICAvLyBpLmUuIHdlIGRpZG4ndCBnZW5lcmF0ZSAubmdzdW1tYXJ5LnRzIGZpbGVzIGZvciB0aGVzZS5cbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaC5hcHBseShleHByZXNzaW9ucywgX19zcHJlYWQocHJvdmlkZXJzLmZpbHRlcihmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuICEhcHJvdmlkZXIudXNlQ2xhc3M7IH0pLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLnNlcmlhbGl6ZVN1bW1hcnkoe1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlLFxuICAgICAgICAgICAgdHlwZTogcHJvdmlkZXIudXNlQ2xhc3NcbiAgICAgICAgfSk7IH0pKSk7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGV4cHJlc3Npb25zKTtcbiAgICB9O1xuICAgIEZvckppdFNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVN1bW1hcnlSZWYgPSBmdW5jdGlvbiAodHlwZVN5bWJvbCkge1xuICAgICAgICB2YXIgaml0SW1wb3J0ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChzdW1tYXJ5Rm9ySml0RmlsZU5hbWUodHlwZVN5bWJvbC5maWxlUGF0aCksIHN1bW1hcnlGb3JKaXROYW1lKHR5cGVTeW1ib2wubmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRDdHguaW1wb3J0RXhwcihqaXRJbXBvcnRlZFN5bWJvbCk7XG4gICAgfTtcbiAgICBGb3JKaXRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVTdW1tYXJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG91dHB1dEN0eCA9IHRoaXMub3V0cHV0Q3R4O1xuICAgICAgICB2YXIgVHJhbnNmb3JtZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFuc2Zvcm1lcigpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHZpc2l0VmFsdWUoZW50cnksIF90aGlzLCBjb250ZXh0KTsgfSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIoT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KSwgZmFsc2UpOyB9KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXRDdHguaW1wb3J0RXhwcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBFbmNvdW50ZXJlZCB2YWx1ZSBcIiArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybWVyO1xuICAgICAgICB9KCkpO1xuICAgICAgICByZXR1cm4gdmlzaXRWYWx1ZShkYXRhLCBuZXcgVHJhbnNmb3JtZXIoKSwgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRm9ySml0U2VyaWFsaXplcjtcbn0oKSk7XG52YXIgRnJvbUpzb25EZXNlcmlhbGl6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb21Kc29uRGVzZXJpYWxpemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21Kc29uRGVzZXJpYWxpemVyKHN5bWJvbENhY2hlLCBzdW1tYXJ5UmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ltYm9sQ2FjaGUgPSBzeW1ib2xDYWNoZTtcbiAgICAgICAgX3RoaXMuc3VtbWFyeVJlc29sdmVyID0gc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZyb21Kc29uRGVzZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChsaWJyYXJ5RmlsZU5hbWUsIGpzb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB2YXIgYWxsSW1wb3J0QXMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gZGF0YS5zeW1ib2xzLm1hcChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCkgeyByZXR1cm4gX3RoaXMuc3ltYm9sQ2FjaGUuZ2V0KF90aGlzLnN1bW1hcnlSZXNvbHZlci5mcm9tU3VtbWFyeUZpbGVOYW1lKHNlcmlhbGl6ZWRTeW1ib2wuZmlsZVBhdGgsIGxpYnJhcnlGaWxlTmFtZSksIHNlcmlhbGl6ZWRTeW1ib2wubmFtZSk7IH0pO1xuICAgICAgICBkYXRhLnN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWFsaXplZFN5bWJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBfdGhpcy5zeW1ib2xzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBpbXBvcnRBcyA9IHNlcmlhbGl6ZWRTeW1ib2wuaW1wb3J0QXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGltcG9ydEFzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGFsbEltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IF90aGlzLnN5bWJvbHNbaW1wb3J0QXNdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGltcG9ydEFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGFsbEltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IF90aGlzLnN5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChsaWJyYXJ5RmlsZU5hbWUpLCBpbXBvcnRBcykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VtbWFyaWVzID0gdmlzaXRWYWx1ZShkYXRhLnN1bW1hcmllcywgdGhpcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7IG1vZHVsZU5hbWU6IGRhdGEubW9kdWxlTmFtZSwgc3VtbWFyaWVzOiBzdW1tYXJpZXMsIGltcG9ydEFzOiBhbGxJbXBvcnRBcyB9O1xuICAgIH07XG4gICAgRnJvbUpzb25EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICBpZiAoJ19fc3ltYm9sJyBpbiBtYXApIHtcbiAgICAgICAgICAgIHZhciBiYXNlU3ltYm9sID0gdGhpcy5zeW1ib2xzW21hcFsnX19zeW1ib2wnXV07XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IG1hcFsnbWVtYmVycyddO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnMubGVuZ3RoID8gdGhpcy5zeW1ib2xDYWNoZS5nZXQoYmFzZVN5bWJvbC5maWxlUGF0aCwgYmFzZVN5bWJvbC5uYW1lLCBtZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgYmFzZVN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZyb21Kc29uRGVzZXJpYWxpemVyO1xufShWYWx1ZVRyYW5zZm9ybWVyKSk7XG5mdW5jdGlvbiBpc0NhbGwobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGEgJiYgbWV0YWRhdGEuX19zeW1ib2xpYyA9PT0gJ2NhbGwnO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkNhbGwobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gaXNDYWxsKG1ldGFkYXRhKSAmJiB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKG1ldGFkYXRhLmV4cHJlc3Npb24pIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sO1xufVxuZnVuY3Rpb24gaXNNZXRob2RDYWxsT25WYXJpYWJsZShtZXRhZGF0YSkge1xuICAgIHJldHVybiBpc0NhbGwobWV0YWRhdGEpICYmIG1ldGFkYXRhLmV4cHJlc3Npb24gJiYgbWV0YWRhdGEuZXhwcmVzc2lvbi5fX3N5bWJvbGljID09PSAnc2VsZWN0JyAmJlxuICAgICAgICB1bndyYXBSZXNvbHZlZE1ldGFkYXRhKG1ldGFkYXRhLmV4cHJlc3Npb24uZXhwcmVzc2lvbikgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2w7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBb3RDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBb3RDb21waWxlcihfY29uZmlnLCBfb3B0aW9ucywgX2hvc3QsIHJlZmxlY3RvciwgX21ldGFkYXRhUmVzb2x2ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF90eXBlQ2hlY2tDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9pbmplY3RhYmxlQ29tcGlsZXIsIF9vdXRwdXRFbWl0dGVyLCBfc3VtbWFyeVJlc29sdmVyLCBfc3ltYm9sUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgICAgICB0aGlzLl9ob3N0ID0gX2hvc3Q7XG4gICAgICAgIHRoaXMucmVmbGVjdG9yID0gcmVmbGVjdG9yO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3R5cGVDaGVja0NvbXBpbGVyID0gX3R5cGVDaGVja0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX2luamVjdGFibGVDb21waWxlciA9IF9pbmplY3RhYmxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX291dHB1dEVtaXR0ZXIgPSBfb3V0cHV0RW1pdHRlcjtcbiAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyID0gX3N1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc3ltYm9sUmVzb2x2ZXIgPSBfc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQXN0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuYWx5emVkRmlsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FuYWx5emVkRmlsZXNGb3JJbmplY3RhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmFuYWx5emVNb2R1bGVzU3luYyA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFuYWx5emVSZXN1bHQgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocm9vdEZpbGVzLCB0aGlzLl9ob3N0LCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgICAgIGFuYWx5emVSZXN1bHQubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIHRydWUpOyB9KTtcbiAgICAgICAgcmV0dXJuIGFuYWx5emVSZXN1bHQ7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuYW5hbHl6ZU1vZHVsZXNBc3luYyA9IGZ1bmN0aW9uIChyb290RmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFuYWx5emVSZXN1bHQgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocm9vdEZpbGVzLCB0aGlzLl9ob3N0LCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKGFuYWx5emVSZXN1bHQubmdNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YShuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgZmFsc2UpOyB9KSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuYWx5emVSZXN1bHQ7IH0pO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9hbmFseXplRmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICB2YXIgYW5hbHl6ZWRGaWxlID0gdGhpcy5fYW5hbHl6ZWRGaWxlcy5nZXQoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIWFuYWx5emVkRmlsZSkge1xuICAgICAgICAgICAgYW5hbHl6ZWRGaWxlID1cbiAgICAgICAgICAgICAgICBhbmFseXplRmlsZSh0aGlzLl9ob3N0LCB0aGlzLl9zeW1ib2xSZXNvbHZlciwgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciwgZmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fYW5hbHl6ZWRGaWxlcy5zZXQoZmlsZU5hbWUsIGFuYWx5emVkRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuYWx5emVkRmlsZTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fYW5hbHl6ZUZpbGVGb3JJbmplY3RhYmxlcyA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICB2YXIgYW5hbHl6ZWRGaWxlID0gdGhpcy5fYW5hbHl6ZWRGaWxlc0ZvckluamVjdGFibGVzLmdldChmaWxlTmFtZSk7XG4gICAgICAgIGlmICghYW5hbHl6ZWRGaWxlKSB7XG4gICAgICAgICAgICBhbmFseXplZEZpbGUgPSBhbmFseXplRmlsZUZvckluamVjdGFibGVzKHRoaXMuX2hvc3QsIHRoaXMuX3N5bWJvbFJlc29sdmVyLCB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLCBmaWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9hbmFseXplZEZpbGVzRm9ySW5qZWN0YWJsZXMuc2V0KGZpbGVOYW1lLCBhbmFseXplZEZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmFseXplZEZpbGU7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZmluZEdlbmVyYXRlZEZpbGVOYW1lcyA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2VuRmlsZU5hbWVzID0gW107XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5fYW5hbHl6ZUZpbGUoZmlsZU5hbWUpO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY3JlYXRlIGEgLm5nZmFjdG9yeSBpZiB3ZSBoYXZlIGEgaW5qZWN0YWJsZS9kaXJlY3RpdmUvcGlwZS9OZ01vZHVsZVxuICAgICAgICAvLyBvciBhIHJlZmVyZW5jZSB0byBhIG5vbiBzb3VyY2UgZmlsZS5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBvdmVyZXN0aW1hdGluZyB0aGUgcmVxdWlyZWQgLm5nZmFjdG9yeSBmaWxlcyBhcyB0aGUgcmVhbCBjYWxjdWxhdGlvbiBpcyBoYXJkZXIuXG4gICAgICAgIC8vIE9ubHkgZG8gdGhpcyBmb3IgU3R1YkVtaXRGbGFncy5CYXNpYywgYXMgYWRkaW5nIGEgdHlwZSBjaGVjayBibG9ja1xuICAgICAgICAvLyBkb2VzIG5vdCBjaGFuZ2UgdGhpcyBmaWxlIChhcyB3ZSBnZW5lcmF0ZSB0eXBlIGNoZWNrIGJsb2NrcyBiYXNlZCBvbiBOZ01vZHVsZXMpLlxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5hbGxvd0VtcHR5Q29kZWdlbkZpbGVzIHx8IGZpbGUuZGlyZWN0aXZlcy5sZW5ndGggfHwgZmlsZS5waXBlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIGZpbGUuaW5qZWN0YWJsZXMubGVuZ3RoIHx8IGZpbGUubmdNb2R1bGVzLmxlbmd0aCB8fCBmaWxlLmV4cG9ydHNOb25Tb3VyY2VGaWxlcykge1xuICAgICAgICAgICAgZ2VuRmlsZU5hbWVzLnB1c2gobmdmYWN0b3J5RmlsZVBhdGgoZmlsZS5maWxlTmFtZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZW5hYmxlU3VtbWFyaWVzRm9ySml0KSB7XG4gICAgICAgICAgICAgICAgZ2VuRmlsZU5hbWVzLnB1c2goc3VtbWFyeUZvckppdEZpbGVOYW1lKGZpbGUuZmlsZU5hbWUsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsZVN1ZmZpeCA9IG5vcm1hbGl6ZUdlbkZpbGVTdWZmaXgoc3BsaXRUeXBlc2NyaXB0U3VmZml4KGZpbGUuZmlsZU5hbWUsIHRydWUpWzFdKTtcbiAgICAgICAgZmlsZS5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpclN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0Tm9uTm9ybWFsaXplZERpcmVjdGl2ZU1ldGFkYXRhKGRpclN5bWJvbCkubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogY29tcE1ldGEgaXMgYSBjb21wb25lbnQgYW5kIHRoZXJlZm9yZSB0ZW1wbGF0ZSBpcyBub24gbnVsbC5cbiAgICAgICAgICAgIGNvbXBNZXRhLnRlbXBsYXRlLnN0eWxlVXJscy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVVybCkge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkVXJsID0gX3RoaXMuX2hvc3QucmVzb3VyY2VOYW1lVG9GaWxlTmFtZShzdHlsZVVybCwgZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFub3JtYWxpemVkVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiQ291bGRuJ3QgcmVzb2x2ZSByZXNvdXJjZSBcIiArIHN0eWxlVXJsICsgXCIgcmVsYXRpdmUgdG8gXCIgKyBmaWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRzU2hpbSA9IChjb21wTWV0YS50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb25maWcuZGVmYXVsdEVuY2Fwc3VsYXRpb24pID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICAgICAgICAgICAgICBnZW5GaWxlTmFtZXMucHVzaChfc3R5bGVzTW9kdWxlVXJsKG5vcm1hbGl6ZWRVcmwsIG5lZWRzU2hpbSwgZmlsZVN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb3B0aW9ucy5hbGxvd0VtcHR5Q29kZWdlbkZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkZpbGVOYW1lcy5wdXNoKF9zdHlsZXNNb2R1bGVVcmwobm9ybWFsaXplZFVybCwgIW5lZWRzU2hpbSwgZmlsZVN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdlbkZpbGVOYW1lcztcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5lbWl0QmFzaWNTdHViID0gZnVuY3Rpb24gKGdlbkZpbGVOYW1lLCBvcmlnaW5hbEZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBvdXRwdXRDdHggPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KGdlbkZpbGVOYW1lKTtcbiAgICAgICAgaWYgKGdlbkZpbGVOYW1lLmVuZHNXaXRoKCcubmdmYWN0b3J5LnRzJykpIHtcbiAgICAgICAgICAgIGlmICghb3JpZ2luYWxGaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogcmVxdWlyZSB0aGUgb3JpZ2luYWwgZmlsZSBmb3IgLm5nZmFjdG9yeS50cyBzdHVicy4gRmlsZTogXCIgKyBnZW5GaWxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxGaWxlID0gdGhpcy5fYW5hbHl6ZUZpbGUob3JpZ2luYWxGaWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVOZ0ZhY3RvcnlTdHViKG91dHB1dEN0eCwgb3JpZ2luYWxGaWxlLCAxIC8qIEJhc2ljICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW5GaWxlTmFtZS5lbmRzV2l0aCgnLm5nc3VtbWFyeS50cycpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVTdW1tYXJpZXNGb3JKaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbmFsRmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yOiByZXF1aXJlIHRoZSBvcmlnaW5hbCBmaWxlIGZvciAubmdzdW1tYXJ5LnRzIHN0dWJzLiBGaWxlOiBcIiArIGdlbkZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRmlsZSA9IHRoaXMuX2FuYWx5emVGaWxlKG9yaWdpbmFsRmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIF9jcmVhdGVFbXB0eVN0dWIob3V0cHV0Q3R4KTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBleHBvcnRzIHRoYXQgdXNlciBjb2RlIGNhbiByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRm9ySml0U3R1YihvdXRwdXRDdHgsIG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChnZW5GaWxlTmFtZS5lbmRzV2l0aCgnLm5nc3R5bGUudHMnKSkge1xuICAgICAgICAgICAgX2NyZWF0ZUVtcHR5U3R1YihvdXRwdXRDdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGZvciB0aGUgc3R1YnMsIHdlIGRvbid0IG5lZWQgYSBwcm9wZXJ0eSBzcmNGaWxlVXJsLFxuICAgICAgICAvLyBhcyBsYXRlciBvbiBpbiBlbWl0QWxsSW1wbHMgd2Ugd2lsbCBjcmVhdGUgdGhlIHByb3BlciBHZW5lcmF0ZWRGaWxlcyB3aXRoIHRoZVxuICAgICAgICAvLyBjb3JyZWN0IHNyY0ZpbGVVcmwuXG4gICAgICAgIC8vIFRoaXMgaXMgZ29vZCBhcyBlLmcuIGZvciAubmdzdHlsZS50cyBmaWxlcyB3ZSBjYW4ndCBkZXJpdmVcbiAgICAgICAgLy8gdGhlIHVybCBvZiBjb21wb25lbnRzIGJhc2VkIG9uIHRoZSBnZW5GaWxlVXJsLlxuICAgICAgICByZXR1cm4gdGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZSgndW5rbm93bicsIG91dHB1dEN0eCk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdFR5cGVDaGVja1N0dWIgPSBmdW5jdGlvbiAoZ2VuRmlsZU5hbWUsIG9yaWdpbmFsRmlsZU5hbWUpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRmlsZSA9IHRoaXMuX2FuYWx5emVGaWxlKG9yaWdpbmFsRmlsZU5hbWUpO1xuICAgICAgICB2YXIgb3V0cHV0Q3R4ID0gdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChnZW5GaWxlTmFtZSk7XG4gICAgICAgIGlmIChnZW5GaWxlTmFtZS5lbmRzV2l0aCgnLm5nZmFjdG9yeS50cycpKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVOZ0ZhY3RvcnlTdHViKG91dHB1dEN0eCwgb3JpZ2luYWxGaWxlLCAyIC8qIFR5cGVDaGVjayAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dEN0eC5zdGF0ZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgdGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZShvcmlnaW5hbEZpbGUuZmlsZU5hbWUsIG91dHB1dEN0eCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5sb2FkRmlsZXNBc3luYyA9IGZ1bmN0aW9uIChmaWxlTmFtZXMsIHRzRmlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVzID0gZmlsZU5hbWVzLm1hcChmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIF90aGlzLl9hbmFseXplRmlsZShmaWxlTmFtZSk7IH0pO1xuICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2VzID0gW107XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIGZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGluZ1Byb21pc2VzLnB1c2goX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBmYWxzZSkpO1xuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciBhbmFseXplZEluamVjdGFibGVzID0gdHNGaWxlcy5tYXAoZnVuY3Rpb24gKHRzRmlsZSkgeyByZXR1cm4gX3RoaXMuX2FuYWx5emVGaWxlRm9ySW5qZWN0YWJsZXModHNGaWxlKTsgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBhbmFseXplZE1vZHVsZXM6IG1lcmdlQW5kVmFsaWRhdGVOZ0ZpbGVzKGZpbGVzKSxcbiAgICAgICAgICAgIGFuYWx5emVkSW5qZWN0YWJsZXM6IGFuYWx5emVkSW5qZWN0YWJsZXMsXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5sb2FkRmlsZXNTeW5jID0gZnVuY3Rpb24gKGZpbGVOYW1lcywgdHNGaWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsZXMgPSBmaWxlTmFtZXMubWFwKGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gX3RoaXMuX2FuYWx5emVGaWxlKGZpbGVOYW1lKTsgfSk7XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIGZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIHRydWUpOyB9KTsgfSk7XG4gICAgICAgIHZhciBhbmFseXplZEluamVjdGFibGVzID0gdHNGaWxlcy5tYXAoZnVuY3Rpb24gKHRzRmlsZSkgeyByZXR1cm4gX3RoaXMuX2FuYWx5emVGaWxlRm9ySW5qZWN0YWJsZXModHNGaWxlKTsgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmFseXplZE1vZHVsZXM6IG1lcmdlQW5kVmFsaWRhdGVOZ0ZpbGVzKGZpbGVzKSxcbiAgICAgICAgICAgIGFuYWx5emVkSW5qZWN0YWJsZXM6IGFuYWx5emVkSW5qZWN0YWJsZXMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZU5nRmFjdG9yeVN0dWIgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBmaWxlLCBlbWl0RmxhZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbXBvbmVudElkID0gMDtcbiAgICAgICAgZmlsZS5uZ01vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVNZXRhLCBuZ01vZHVsZUluZGV4KSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUgY29kZSBiZWxvdyBuZWVkcyB0byBleGVjdXRlZCBmb3IgU3R1YkVtaXRGbGFncy5CYXNpYyBhbmQgU3R1YkVtaXRGbGFncy5UeXBlQ2hlY2ssXG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIC5uZ2ZhY3RvcnkgZmlsZSB0b28gbXVjaCB3aGVuIGFkZGluZyB0aGUgdHlwZS1jaGVjayBibG9jay5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBleHBvcnRzIHRoYXQgdXNlciBjb2RlIGNhbiByZWZlcmVuY2VcbiAgICAgICAgICAgIF90aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNyZWF0ZVN0dWIob3V0cHV0Q3R4LCBuZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgLy8gYWRkIHJlZmVyZW5jZXMgdG8gdGhlIHN5bWJvbHMgZnJvbSB0aGUgbWV0YWRhdGEuXG4gICAgICAgICAgICAvLyBUaGVzZSBjYW4gYmUgdXNlZCBieSB0aGUgdHlwZSBjaGVjayBibG9jayBmb3IgY29tcG9uZW50cyxcbiAgICAgICAgICAgIC8vIGFuZCB0aGV5IGFsc28gY2F1c2UgVHlwZVNjcmlwdCB0byBpbmNsdWRlIHRoZXNlIGZpbGVzIGludG8gdGhlIHByb2dyYW0gdG9vLFxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBtYWtlIHRoZW0gcGFydCBvZiB0aGUgYW5hbHl6ZWRGaWxlcy5cbiAgICAgICAgICAgIHZhciBleHRlcm5hbFJlZmVyZW5jZXMgPSBfX3NwcmVhZChuZ01vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5yZWZlcmVuY2U7IH0pLCBuZ01vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQucmVmZXJlbmNlOyB9KSwgbmdNb2R1bGVNZXRhLmltcG9ydGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0udHlwZS5yZWZlcmVuY2U7IH0pLCBuZ01vZHVsZU1ldGEuZXhwb3J0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50eXBlLnJlZmVyZW5jZTsgfSksIF90aGlzLl9leHRlcm5hbElkZW50aWZpZXJSZWZlcmVuY2VzKFtJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiwgSWRlbnRpZmllcnMuRWxlbWVudFJlZl0pKTtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFJlZmVyZW5jZVZhcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBleHRlcm5hbFJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmLCB0eXBlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZmVyZW5jZVZhcnMuc2V0KHJlZiwgXCJfZGVjbFwiICsgbmdNb2R1bGVJbmRleCArIFwiX1wiICsgdHlwZUluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUsIHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2godmFyaWFibGUodmFyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgLnNldChOVUxMX0VYUFIuY2FzdChEWU5BTUlDX1RZUEUpKVxuICAgICAgICAgICAgICAgICAgICAudG9EZWNsU3RtdChleHByZXNzaW9uVHlwZShvdXRwdXRDdHguaW1wb3J0RXhwcihyZWZlcmVuY2UsIC8qIHR5cGVQYXJhbXMgKi8gbnVsbCwgLyogdXNlU3VtbWFyaWVzICovIGZhbHNlKSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVtaXRGbGFncyAmIDIgLyogVHlwZUNoZWNrICovKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0eXBlLWNoZWNrIGJsb2NrIGZvciBhbGwgY29tcG9uZW50cyBvZiB0aGUgTmdNb2R1bGVcbiAgICAgICAgICAgICAgICBuZ01vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcklkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcE1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRJZCsrO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlVHlwZUNoZWNrQmxvY2sob3V0cHV0Q3R4LCBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5uYW1lICsgXCJfSG9zdF9cIiArIGNvbXBvbmVudElkLCBuZ01vZHVsZU1ldGEsIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRNZXRhZGF0YShjb21wTWV0YSksIFtjb21wTWV0YS50eXBlXSwgZXh0ZXJuYWxSZWZlcmVuY2VWYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZVR5cGVDaGVja0Jsb2NrKG91dHB1dEN0eCwgY29tcE1ldGEudHlwZS5yZWZlcmVuY2UubmFtZSArIFwiX1wiICsgY29tcG9uZW50SWQsIG5nTW9kdWxlTWV0YSwgY29tcE1ldGEsIG5nTW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIGV4dGVybmFsUmVmZXJlbmNlVmFycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0cHV0Q3R4LnN0YXRlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBfY3JlYXRlRW1wdHlTdHViKG91dHB1dEN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fZXh0ZXJuYWxJZGVudGlmaWVyUmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChyZWZlcmVuY2VzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciByZWZlcmVuY2VzXzEgPSBfX3ZhbHVlcyhyZWZlcmVuY2VzKSwgcmVmZXJlbmNlc18xXzEgPSByZWZlcmVuY2VzXzEubmV4dCgpOyAhcmVmZXJlbmNlc18xXzEuZG9uZTsgcmVmZXJlbmNlc18xXzEgPSByZWZlcmVuY2VzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHJlZmVyZW5jZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGNyZWF0ZVRva2VuRm9yRXh0ZXJuYWxSZWZlcmVuY2UodGhpcy5yZWZsZWN0b3IsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9rZW4uaWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZXNfMV8xICYmICFyZWZlcmVuY2VzXzFfMS5kb25lICYmIChfYSA9IHJlZmVyZW5jZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHJlZmVyZW5jZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlVHlwZUNoZWNrQmxvY2sgPSBmdW5jdGlvbiAoY3R4LCBjb21wb25lbnRJZCwgbW9kdWxlTWV0YSwgY29tcE1ldGEsIGRpcmVjdGl2ZXMsIGV4dGVybmFsUmVmZXJlbmNlVmFycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuX3BhcnNlVGVtcGxhdGUoY29tcE1ldGEsIG1vZHVsZU1ldGEsIGRpcmVjdGl2ZXMpLCBwYXJzZWRUZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB1c2VkUGlwZXMgPSBfYi5waXBlcztcbiAgICAgICAgKF9hID0gY3R4LnN0YXRlbWVudHMpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkKHRoaXMuX3R5cGVDaGVja0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcG9uZW50SWQsIGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgdXNlZFBpcGVzLCBleHRlcm5hbFJlZmVyZW5jZVZhcnMsIGN0eCkpKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5lbWl0TWVzc2FnZUJ1bmRsZSA9IGZ1bmN0aW9uIChhbmFseXplUmVzdWx0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgICAgIC8vIFRPRE8odmljYik6IGltcGxpY2l0IHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciBtZXNzYWdlQnVuZGxlID0gbmV3IE1lc3NhZ2VCdW5kbGUoaHRtbFBhcnNlciwgW10sIHt9LCBsb2NhbGUpO1xuICAgICAgICBhbmFseXplUmVzdWx0LmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wTWV0YXMgPSBbXTtcbiAgICAgICAgICAgIGZpbGUuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YSAmJiBkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBNZXRhcy5wdXNoKGRpck1ldGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcE1ldGFzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBNZXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAvLyBUZW1wbGF0ZSBVUkwgcG9pbnRzIHRvIGVpdGhlciBhbiBIVE1MIG9yIFRTIGZpbGUgZGVwZW5kaW5nIG9uIHdoZXRoZXJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZmlsZSBpcyB1c2VkIHdpdGggYHRlbXBsYXRlVXJsOmAgb3IgYHRlbXBsYXRlOmAsIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZVVybDtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBNZXRhLnRlbXBsYXRlLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX19zcHJlYWQobWVzc2FnZUJ1bmRsZS51cGRhdGVGcm9tVGVtcGxhdGUoaHRtbCwgdGVtcGxhdGVVcmwsIGludGVycG9sYXRpb25Db25maWcpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50b1N0cmluZygpOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdW5kbGU7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdEFsbFBhcnRpYWxNb2R1bGVzID0gZnVuY3Rpb24gKF9hLCByM0ZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gX2EubmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZmlsZXMgPSBfYS5maWxlcztcbiAgICAgICAgdmFyIGNvbnRleHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHRNYXAuaGFzKGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRNYXAuc2V0KGZpbGVOYW1lLCBfdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChmaWxlTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRNYXAuZ2V0KGZpbGVOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVQYXJ0aWFsTW9kdWxlKGZpbGUuZmlsZU5hbWUsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGUuZGlyZWN0aXZlcywgZmlsZS5waXBlcywgZmlsZS5uZ01vZHVsZXMsIGZpbGUuaW5qZWN0YWJsZXMsIGdldENvbnRleHQoZmlsZS5maWxlTmFtZSkpOyB9KTtcbiAgICAgICAgcjNGaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVNoYWxsb3dNb2R1bGVzKGZpbGUuZmlsZU5hbWUsIGZpbGUuc2hhbGxvd01vZHVsZXMsIGdldENvbnRleHQoZmlsZS5maWxlTmFtZSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY29udGV4dE1hcC52YWx1ZXMoKSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBmaWxlTmFtZTogY29udGV4dC5nZW5GaWxlUGF0aCxcbiAgICAgICAgICAgIHN0YXRlbWVudHM6IF9fc3ByZWFkKGNvbnRleHQuY29uc3RhbnRQb29sLnN0YXRlbWVudHMsIGNvbnRleHQuc3RhdGVtZW50cyksXG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVNoYWxsb3dNb2R1bGVzID0gZnVuY3Rpb24gKGZpbGVOYW1lLCBzaGFsbG93TW9kdWxlcywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzaGFsbG93TW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIGNvbXBpbGVOZ01vZHVsZUZyb21SZW5kZXIyKGNvbnRleHQsIG1vZHVsZSwgX3RoaXMuX2luamVjdGFibGVDb21waWxlcik7IH0pO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlUGFydGlhbE1vZHVsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSwgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZGlyZWN0aXZlcywgcGlwZXMsIG5nTW9kdWxlcywgaW5qZWN0YWJsZXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgICAgIHZhciBob3N0QmluZGluZ1BhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKHRoaXMuX3RlbXBsYXRlUGFyc2VyLmV4cHJlc3Npb25QYXJzZXIsIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcsIHNjaGVtYVJlZ2lzdHJ5LCBbXSwgZXJyb3JzKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhbGwgY29tcG9uZW50cyBhbmQgZGlyZWN0aXZlc1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVNZXRhZGF0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZU1ldGFkYXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgIG1vZHVsZSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY29tcG9uZW50ICdcIiArIGlkZW50aWZpZXJOYW1lKGRpcmVjdGl2ZU1ldGFkYXRhLnR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIHZhciBodG1sQXN0ID0gZGlyZWN0aXZlTWV0YWRhdGEudGVtcGxhdGUuaHRtbEFzdDtcbiAgICAgICAgICAgICAgICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlcyA9IGRpcmVjdGl2ZU1ldGFkYXRhLnRlbXBsYXRlLnByZXNlcnZlV2hpdGVzcGFjZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxBc3QgPSByZW1vdmVXaGl0ZXNwYWNlcyhodG1sQXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcjNBc3QgPSBodG1sQXN0VG9SZW5kZXIzQXN0KGh0bWxBc3Qucm9vdE5vZGVzLCBob3N0QmluZGluZ1BhcnNlcik7XG4gICAgICAgICAgICAgICAgLy8gTWFwIG9mIFN0YXRpY1R5cGUgYnkgZGlyZWN0aXZlIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVUeXBlQnlTZWxfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlc18xID0gbW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlc18xLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUeXBlQnlTZWxfMS5zZXQoZGlyZWN0aXZlLnNlbGVjdG9yLCBkaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTWFwIG9mIFN0YXRpY1R5cGUgYnkgcGlwZSBuYW1lc1xuICAgICAgICAgICAgICAgIHZhciBwaXBlVHlwZUJ5TmFtZV8xID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIHZhciBwaXBlc18xID0gbW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICAgICAgICAgIHBpcGVzXzEuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkge1xuICAgICAgICAgICAgICAgICAgICBwaXBlVHlwZUJ5TmFtZV8xLnNldChwaXBlLm5hbWUsIHBpcGUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBpbGVDb21wb25lbnRGcm9tUmVuZGVyMihjb250ZXh0LCBkaXJlY3RpdmVNZXRhZGF0YSwgcmVuZGVyM0FzdCwgX3RoaXMucmVmbGVjdG9yLCBob3N0QmluZGluZ1BhcnNlciwgZGlyZWN0aXZlVHlwZUJ5U2VsXzEsIHBpcGVUeXBlQnlOYW1lXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGlsZURpcmVjdGl2ZUZyb21SZW5kZXIyKGNvbnRleHQsIGRpcmVjdGl2ZU1ldGFkYXRhLCBfdGhpcy5yZWZsZWN0b3IsIGhvc3RCaW5kaW5nUGFyc2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgcGlwZU1ldGFkYXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZU1ldGFkYXRhKHBpcGVUeXBlKTtcbiAgICAgICAgICAgIGlmIChwaXBlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb21waWxlUGlwZUZyb21SZW5kZXIyKGNvbnRleHQsIHBpcGVNZXRhZGF0YSwgX3RoaXMucmVmbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGluamVjdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGluamVjdGFibGUpIHsgcmV0dXJuIF90aGlzLl9pbmplY3RhYmxlQ29tcGlsZXIuY29tcGlsZShpbmplY3RhYmxlLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuZW1pdEFsbFBhcnRpYWxNb2R1bGVzMiA9IGZ1bmN0aW9uIChmaWxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBVc2luZyByZWR1Y2UgbGlrZSB0aGlzIGlzIGEgc2VsZWN0IG1hbnkgcGF0dGVybiAod2hlcmUgbWFwIGlzIGEgc2VsZWN0IHBhdHRlcm4pXG4gICAgICAgIHJldHVybiBmaWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHIsIGZpbGUpIHtcbiAgICAgICAgICAgIHIucHVzaC5hcHBseShyLCBfX3NwcmVhZChfdGhpcy5fZW1pdFBhcnRpYWxNb2R1bGUyKGZpbGUuZmlsZU5hbWUsIGZpbGUuaW5qZWN0YWJsZXMpKSk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9lbWl0UGFydGlhbE1vZHVsZTIgPSBmdW5jdGlvbiAoZmlsZU5hbWUsIGluamVjdGFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY3JlYXRlT3V0cHV0Q29udGV4dChmaWxlTmFtZSk7XG4gICAgICAgIGluamVjdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKGluamVjdGFibGUpIHsgcmV0dXJuIF90aGlzLl9pbmplY3RhYmxlQ29tcGlsZXIuY29tcGlsZShpbmplY3RhYmxlLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIGlmIChjb250ZXh0LnN0YXRlbWVudHMgJiYgY29udGV4dC5zdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbeyBmaWxlTmFtZTogZmlsZU5hbWUsIHN0YXRlbWVudHM6IF9fc3ByZWFkKGNvbnRleHQuY29uc3RhbnRQb29sLnN0YXRlbWVudHMsIGNvbnRleHQuc3RhdGVtZW50cykgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmVtaXRBbGxJbXBscyA9IGZ1bmN0aW9uIChhbmFseXplUmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gYW5hbHl6ZVJlc3VsdC5uZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlcyA9IGFuYWx5emVSZXN1bHQuZmlsZXM7XG4gICAgICAgIHZhciBzb3VyY2VNb2R1bGVzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZUltcGxGaWxlKGZpbGUuZmlsZU5hbWUsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGZpbGUuZGlyZWN0aXZlcywgZmlsZS5waXBlcywgZmlsZS5uZ01vZHVsZXMsIGZpbGUuaW5qZWN0YWJsZXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oc291cmNlTW9kdWxlcyk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVJbXBsRmlsZSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsZVN1ZmZpeCA9IG5vcm1hbGl6ZUdlbkZpbGVTdWZmaXgoc3BsaXRUeXBlc2NyaXB0U3VmZml4KHNyY0ZpbGVVcmwsIHRydWUpWzFdKTtcbiAgICAgICAgdmFyIGdlbmVyYXRlZEZpbGVzID0gW107XG4gICAgICAgIHZhciBvdXRwdXRDdHggPSB0aGlzLl9jcmVhdGVPdXRwdXRDb250ZXh0KG5nZmFjdG9yeUZpbGVQYXRoKHNyY0ZpbGVVcmwsIHRydWUpKTtcbiAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaC5hcHBseShnZW5lcmF0ZWRGaWxlcywgX19zcHJlYWQodGhpcy5fY3JlYXRlU3VtbWFyeShzcmNGaWxlVXJsLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgb3V0cHV0Q3R4KSkpO1xuICAgICAgICAvLyBjb21waWxlIGFsbCBuZyBtb2R1bGVzXG4gICAgICAgIG5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZU1ldGEpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG91dHB1dEN0eCwgbmdNb2R1bGVNZXRhKTsgfSk7XG4gICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpclR5cGUpO1xuICAgICAgICAgICAgaWYgKCFjb21wTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZ01vZHVsZSA9IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuZ2V0KGRpclR5cGUpO1xuICAgICAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNvbXBvbmVudCBcIiArIGlkZW50aWZpZXJOYW1lKGNvbXBNZXRhLnR5cGUpICsgXCIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcGlsZSBzdHlsZXNcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRTdHlsZXNoZWV0ID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDdHgsIGNvbXBNZXRhKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGNvbXBNZXRhIGlzIGEgY29tcG9uZW50IGFuZCB0aGVyZWZvcmUgdGVtcGxhdGUgaXMgbm9uIG51bGwuXG4gICAgICAgICAgICBjb21wTWV0YS50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXRNZXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogZmlsbCBub24gc2hpbSBhbmQgc2hpbSBzdHlsZSBmaWxlcyBhcyB0aGV5IG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gYmUgc2hhcmVkIGJ5IGNvbXBvbmVudCB3aXRoIGFuZCB3aXRob3V0IFZpZXdFbmNhcHN1bGF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBzaGltID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIubmVlZHNTdHlsZVNoaW0oY29tcE1ldGEpO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZEZpbGVzLnB1c2goX3RoaXMuX2NvZGVnZW5TdHlsZXMoc3JjRmlsZVVybCwgY29tcE1ldGEsIHN0eWxlc2hlZXRNZXRhLCBzaGltLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vcHRpb25zLmFsbG93RW1wdHlDb2RlZ2VuRmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMucHVzaChfdGhpcy5fY29kZWdlblN0eWxlcyhzcmNGaWxlVXJsLCBjb21wTWV0YSwgc3R5bGVzaGVldE1ldGEsICFzaGltLCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjb21waWxlIGNvbXBvbmVudHNcbiAgICAgICAgICAgIHZhciBjb21wVmlld1ZhcnMgPSBfdGhpcy5fY29tcGlsZUNvbXBvbmVudChvdXRwdXRDdHgsIGNvbXBNZXRhLCBuZ01vZHVsZSwgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzLCBjb21wb25lbnRTdHlsZXNoZWV0LCBmaWxlU3VmZml4KTtcbiAgICAgICAgICAgIF90aGlzLl9jb21waWxlQ29tcG9uZW50RmFjdG9yeShvdXRwdXRDdHgsIGNvbXBNZXRhLCBuZ01vZHVsZSwgZmlsZVN1ZmZpeCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0cHV0Q3R4LnN0YXRlbWVudHMubGVuZ3RoID4gMCB8fCB0aGlzLl9vcHRpb25zLmFsbG93RW1wdHlDb2RlZ2VuRmlsZXMpIHtcbiAgICAgICAgICAgIHZhciBzcmNNb2R1bGUgPSB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIG91dHB1dEN0eCk7XG4gICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy51bnNoaWZ0KHNyY01vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEZpbGVzO1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHNyY0ZpbGVOYW1lLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgbmdGYWN0b3J5Q3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzeW1ib2xTdW1tYXJpZXMgPSB0aGlzLl9zeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2Yoc3JjRmlsZU5hbWUpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIF90aGlzLl9zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7IH0pO1xuICAgICAgICB2YXIgdHlwZURhdGEgPSBfX3NwcmVhZChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChtZXRhKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc3VtbWFyeTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVTdW1tYXJ5KG1ldGEudHlwZS5yZWZlcmVuY2UpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWV0YS50eXBlLnJlZmVyZW5jZSlcbiAgICAgICAgfSk7IH0pLCBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc3VtbWFyeTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShyZWYpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKHJlZilcbiAgICAgICAgfSk7IH0pLCBwaXBlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHN1bW1hcnk6IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHJlZiksXG4gICAgICAgICAgICBtZXRhZGF0YTogX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZU1ldGFkYXRhKHJlZilcbiAgICAgICAgfSk7IH0pLCBpbmplY3RhYmxlcy5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHN1bW1hcnk6IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVTdW1tYXJ5KHJlZi5zeW1ib2wpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVTdW1tYXJ5KHJlZi5zeW1ib2wpLnR5cGVcbiAgICAgICAgfSk7IH0pKTtcbiAgICAgICAgdmFyIGZvckppdE91dHB1dEN0eCA9IHRoaXMuX29wdGlvbnMuZW5hYmxlU3VtbWFyaWVzRm9ySml0ID9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoc3VtbWFyeUZvckppdEZpbGVOYW1lKHNyY0ZpbGVOYW1lLCB0cnVlKSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplU3VtbWFyaWVzKHNyY0ZpbGVOYW1lLCBmb3JKaXRPdXRwdXRDdHgsIHRoaXMuX3N1bW1hcnlSZXNvbHZlciwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHN5bWJvbFN1bW1hcmllcywgdHlwZURhdGEsIHRoaXMuX29wdGlvbnMuY3JlYXRlRXh0ZXJuYWxTeW1ib2xGYWN0b3J5UmVleHBvcnRzKSwganNvbiA9IF9hLmpzb24sIGV4cG9ydEFzID0gX2EuZXhwb3J0QXM7XG4gICAgICAgIGV4cG9ydEFzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBuZ0ZhY3RvcnlDdHguc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGVudHJ5LmV4cG9ydEFzKS5zZXQobmdGYWN0b3J5Q3R4LmltcG9ydEV4cHIoZW50cnkuc3ltYm9sKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkV4cG9ydGVkXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VtbWFyeUpzb24gPSBuZXcgR2VuZXJhdGVkRmlsZShzcmNGaWxlTmFtZSwgc3VtbWFyeUZpbGVOYW1lKHNyY0ZpbGVOYW1lKSwganNvbik7XG4gICAgICAgIHZhciByZXN1bHQgPSBbc3VtbWFyeUpzb25dO1xuICAgICAgICBpZiAoZm9ySml0T3V0cHV0Q3R4KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVOYW1lLCBmb3JKaXRPdXRwdXRDdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG91dHB1dEN0eCwgbmdNb2R1bGUpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5sb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkTG9jYWxlID0gdGhpcy5fb3B0aW9ucy5sb2NhbGUucmVwbGFjZSgvXy9nLCAnLScpO1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMucmVmbGVjdG9yLCBJZGVudGlmaWVycy5MT0NBTEVfSUQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBub3JtYWxpemVkTG9jYWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaTE4bkZvcm1hdCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbkZvckV4dGVybmFsUmVmZXJlbmNlKHRoaXMucmVmbGVjdG9yLCBJZGVudGlmaWVycy5UUkFOU0xBVElPTlNfRk9STUFUKSxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdGhpcy5fb3B0aW9ucy5pMThuRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUob3V0cHV0Q3R4LCBuZ01vZHVsZSwgcHJvdmlkZXJzKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBjb21wTWV0YSwgbmdNb2R1bGUsIGZpbGVTdWZmaXgpIHtcbiAgICAgICAgdmFyIGhvc3RNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50TWV0YWRhdGEoY29tcE1ldGEpO1xuICAgICAgICB2YXIgaG9zdFZpZXdGYWN0b3J5VmFyID0gdGhpcy5fY29tcGlsZUNvbXBvbmVudChvdXRwdXRDdHgsIGhvc3RNZXRhLCBuZ01vZHVsZSwgW2NvbXBNZXRhLnR5cGVdLCBudWxsLCBmaWxlU3VmZml4KVxuICAgICAgICAgICAgLnZpZXdDbGFzc1ZhcjtcbiAgICAgICAgdmFyIGNvbXBGYWN0b3J5VmFyID0gY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICB2YXIgaW5wdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29tcE1ldGEuaW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVOYW1lID0gY29tcE1ldGEuaW5wdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBpbnB1dHNFeHBycy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkocHJvcE5hbWUsIGxpdGVyYWwodGVtcGxhdGVOYW1lKSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0c0V4cHJzID0gW107XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbXBNZXRhLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZU5hbWUgPSBjb21wTWV0YS5vdXRwdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBvdXRwdXRzRXhwcnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKHRlbXBsYXRlTmFtZSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0Q3R4LnN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShjb21wRmFjdG9yeVZhcilcbiAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycy5jcmVhdGVDb21wb25lbnRGYWN0b3J5KS5jYWxsRm4oW1xuICAgICAgICAgICAgbGl0ZXJhbChjb21wTWV0YS5zZWxlY3RvciksIG91dHB1dEN0eC5pbXBvcnRFeHByKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKSxcbiAgICAgICAgICAgIHZhcmlhYmxlKGhvc3RWaWV3RmFjdG9yeVZhciksIG5ldyBMaXRlcmFsTWFwRXhwcihpbnB1dHNFeHBycyksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0c0V4cHJzKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIoY29tcE1ldGEudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIGxpdGVyYWwoc2VsZWN0b3IpOyB9KSlcbiAgICAgICAgXSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChpbXBvcnRUeXBlKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnksIFtleHByZXNzaW9uVHlwZShvdXRwdXRDdHguaW1wb3J0RXhwcihjb21wTWV0YS50eXBlLnJlZmVyZW5jZSkpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pLCBbU3RtdE1vZGlmaWVyLkZpbmFsLCBTdG10TW9kaWZpZXIuRXhwb3J0ZWRdKSk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAob3V0cHV0Q3R4LCBjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZUlkZW50aWZpZXJzLCBjb21wb25lbnRTdHlsZXMsIGZpbGVTdWZmaXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZUlkZW50aWZpZXJzKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciBzdHlsZXNFeHByID0gY29tcG9uZW50U3R5bGVzID8gdmFyaWFibGUoY29tcG9uZW50U3R5bGVzLnN0eWxlc1ZhcikgOiBsaXRlcmFsQXJyKFtdKTtcbiAgICAgICAgdmFyIHZpZXdSZXN1bHQgPSB0aGlzLl92aWV3Q29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChvdXRwdXRDdHgsIGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgc3R5bGVzRXhwciwgdXNlZFBpcGVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFN0eWxlcykge1xuICAgICAgICAgICAgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIGNvbXBvbmVudFN0eWxlcywgdGhpcy5fc3R5bGVDb21waWxlci5uZWVkc1N0eWxlU2hpbShjb21wTWV0YSksIGZpbGVTdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3UmVzdWx0O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlQXN0Q2FjaGUuaGFzKGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlQXN0Q2FjaGUuZ2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlcyA9IGNvbXBNZXRhLnRlbXBsYXRlLnByZXNlcnZlV2hpdGVzcGFjZXM7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gZGlyZWN0aXZlSWRlbnRpZmllcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgcGlwZXMgPSBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLm1hcChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0UGlwZVN1bW1hcnkocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RlbXBsYXRlUGFyc2VyLnBhcnNlKGNvbXBNZXRhLCBjb21wTWV0YS50ZW1wbGF0ZS5odG1sQXN0LCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGUuc2NoZW1hcywgdGVtcGxhdGVTb3VyY2VVcmwobmdNb2R1bGUudHlwZSwgY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlKSwgcHJlc2VydmVXaGl0ZXNwYWNlcyk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlQXN0Q2FjaGUuc2V0KGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVPdXRwdXRDb250ZXh0ID0gZnVuY3Rpb24gKGdlbkZpbGVQYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbXBvcnRFeHByJDEgPSBmdW5jdGlvbiAoc3ltYm9sLCB0eXBlUGFyYW1zLCB1c2VTdW1tYXJpZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmICh1c2VTdW1tYXJpZXMgPT09IHZvaWQgMCkgeyB1c2VTdW1tYXJpZXMgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoIShzeW1ib2wgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IHVua25vd24gaWRlbnRpZmllciBcIiArIEpTT04uc3RyaW5naWZ5KHN5bWJvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyaXR5ID0gX3RoaXMuX3N5bWJvbFJlc29sdmVyLmdldFR5cGVBcml0eShzeW1ib2wpIHx8IDA7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZ2V0SW1wb3J0QXMoc3ltYm9sLCB1c2VTdW1tYXJpZXMpIHx8IHN5bWJvbCwgZmlsZVBhdGggPSBfYS5maWxlUGF0aCwgbmFtZSA9IF9hLm5hbWUsIG1lbWJlcnMgPSBfYS5tZW1iZXJzO1xuICAgICAgICAgICAgdmFyIGltcG9ydE1vZHVsZSA9IF90aGlzLl9maWxlTmFtZVRvTW9kdWxlTmFtZShmaWxlUGF0aCwgZ2VuRmlsZVBhdGgpO1xuICAgICAgICAgICAgLy8gSXQgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIHRvIGNvbXBhcmUgZmlsZVBhdGggdG8gZ2VuRmlsZVBhdGggYW5kIGlmIHRoZXkgYXJlIGVxdWFsXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIHNlbGYgcmVmZXJlbmNlLiBIb3dldmVyLCBuZ2ZhY3RvcnkgZmlsZXMgZ2VuZXJhdGUgdG8gLnRzIGJ1dCB0aGVpclxuICAgICAgICAgICAgLy8gc3ltYm9scyBoYXZlIC5kLnRzIHNvIGEgc2ltcGxlIGNvbXBhcmUgaXMgaW5zdWZmaWNpZW50LiBUaGV5IHNob3VsZCBiZSBjYW5vbmljYWxcbiAgICAgICAgICAgIC8vIGFuZCBpcyB0cmFja2VkIGJ5ICMxNzcwNS5cbiAgICAgICAgICAgIHZhciBzZWxmUmVmZXJlbmNlID0gX3RoaXMuX2ZpbGVOYW1lVG9Nb2R1bGVOYW1lKGdlbkZpbGVQYXRoLCBnZW5GaWxlUGF0aCk7XG4gICAgICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IGltcG9ydE1vZHVsZSA9PT0gc2VsZlJlZmVyZW5jZSA/IG51bGwgOiBpbXBvcnRNb2R1bGU7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSB0eXBlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYSBnZW5lcmljIHR5cGUgdGhlbiBzdXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlIHBhcmFtZXRlcnMuIElmIHRoZXJlIHdlcmUgbm90IGVub3VnaCB0eXBlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkLCBzdXBwbHkgYW55IGFzIHRoZSB0eXBlLiBPdXRzaWRlIGEgdHlwZSBleHByZXNzaW9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3VwcGx5IHR5cGUgcGFyYW1ldGVycyBhbmQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICAgICAgICB2YXIgc3VwcGxpZWRUeXBlUGFyYW1zID0gdHlwZVBhcmFtcyB8fCBbXTtcbiAgICAgICAgICAgIHZhciBtaXNzaW5nVHlwZVBhcmFtc0NvdW50ID0gYXJpdHkgLSBzdXBwbGllZFR5cGVQYXJhbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGFsbFR5cGVQYXJhbXMgPSBzdXBwbGllZFR5cGVQYXJhbXMuY29uY2F0KG5ld0FycmF5KG1pc3NpbmdUeXBlUGFyYW1zQ291bnQsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKGZ1bmN0aW9uIChleHByLCBtZW1iZXJOYW1lKSB7IHJldHVybiBleHByLnByb3AobWVtYmVyTmFtZSk7IH0sIGltcG9ydEV4cHIobmV3IEV4dGVybmFsUmVmZXJlbmNlKG1vZHVsZU5hbWUsIG5hbWUsIG51bGwpLCBhbGxUeXBlUGFyYW1zKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHN0YXRlbWVudHM6IFtdLCBnZW5GaWxlUGF0aDogZ2VuRmlsZVBhdGgsIGltcG9ydEV4cHI6IGltcG9ydEV4cHIkMSwgY29uc3RhbnRQb29sOiBuZXcgQ29uc3RhbnRQb29sKCkgfTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fZmlsZU5hbWVUb01vZHVsZU5hbWUgPSBmdW5jdGlvbiAoaW1wb3J0ZWRGaWxlUGF0aCwgY29udGFpbmluZ0ZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIuZ2V0S25vd25Nb2R1bGVOYW1lKGltcG9ydGVkRmlsZVBhdGgpIHx8XG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xSZXNvbHZlci5nZXRLbm93bk1vZHVsZU5hbWUoaW1wb3J0ZWRGaWxlUGF0aCkgfHxcbiAgICAgICAgICAgIHRoaXMuX2hvc3QuZmlsZU5hbWVUb01vZHVsZU5hbWUoaW1wb3J0ZWRGaWxlUGF0aCwgY29udGFpbmluZ0ZpbGVQYXRoKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblN0eWxlcyA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBjb21wTWV0YSwgc3R5bGVzaGVldE1ldGFkYXRhLCBpc1NoaW1tZWQsIGZpbGVTdWZmaXgpIHtcbiAgICAgICAgdmFyIG91dHB1dEN0eCA9IHRoaXMuX2NyZWF0ZU91dHB1dENvbnRleHQoX3N0eWxlc01vZHVsZVVybChzdHlsZXNoZWV0TWV0YWRhdGEubW9kdWxlVXJsLCBpc1NoaW1tZWQsIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgdmFyIGNvbXBpbGVkU3R5bGVzaGVldCA9IHRoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZVN0eWxlcyhvdXRwdXRDdHgsIGNvbXBNZXRhLCBzdHlsZXNoZWV0TWV0YWRhdGEsIGlzU2hpbW1lZCk7XG4gICAgICAgIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCBjb21waWxlZFN0eWxlc2hlZXQsIGlzU2hpbW1lZCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIG91dHB1dEN0eCk7XG4gICAgfTtcbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvZGVnZW5Tb3VyY2VNb2R1bGUgPSBmdW5jdGlvbiAoc3JjRmlsZVVybCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVkRmlsZShzcmNGaWxlVXJsLCBjdHguZ2VuRmlsZVBhdGgsIGN0eC5zdGF0ZW1lbnRzKTtcbiAgICB9O1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5saXN0TGF6eVJvdXRlcyA9IGZ1bmN0aW9uIChlbnRyeVJvdXRlLCBhbmFseXplZE1vZHVsZXMpIHtcbiAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2I7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGVudHJ5Um91dGUpIHtcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBwYXJzZUxhenlSb3V0ZShlbnRyeVJvdXRlLCB0aGlzLnJlZmxlY3RvcikucmVmZXJlbmNlZE1vZHVsZTtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdExhenlSb3V0ZShzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFuYWx5emVkTW9kdWxlcykge1xuICAgICAgICAgICAgdmFyIGFsbExhenlSb3V0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhhbmFseXplZE1vZHVsZXMubmdNb2R1bGVzKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmdNb2R1bGUgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhenlSb3V0ZXMgPSBsaXN0TGF6eVJvdXRlcyhuZ01vZHVsZSwgdGhpcy5yZWZsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbGF6eVJvdXRlc18xID0gKGVfMyA9IHZvaWQgMCwgX192YWx1ZXMobGF6eVJvdXRlcykpLCBsYXp5Um91dGVzXzFfMSA9IGxhenlSb3V0ZXNfMS5uZXh0KCk7ICFsYXp5Um91dGVzXzFfMS5kb25lOyBsYXp5Um91dGVzXzFfMSA9IGxhenlSb3V0ZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF6eVJvdXRlID0gbGF6eVJvdXRlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsTGF6eVJvdXRlcy5wdXNoKGxhenlSb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXp5Um91dGVzXzFfMSAmJiAhbGF6eVJvdXRlc18xXzEuZG9uZSAmJiAoX2IgPSBsYXp5Um91dGVzXzEucmV0dXJuKSkgX2IuY2FsbChsYXp5Um91dGVzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbExhenlSb3V0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgcm91dGUgb3IgYW5hbHl6ZWRNb2R1bGVzIGhhcyB0byBiZSBzcGVjaWZpZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZpc2l0TGF6eVJvdXRlKHN5bWJvbCwgc2VlblJvdXRlcywgYWxsTGF6eVJvdXRlcykge1xuICAgICAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgICAgICBpZiAoc2VlblJvdXRlcyA9PT0gdm9pZCAwKSB7IHNlZW5Sb3V0ZXMgPSBuZXcgU2V0KCk7IH1cbiAgICAgICAgICAgIGlmIChhbGxMYXp5Um91dGVzID09PSB2b2lkIDApIHsgYWxsTGF6eVJvdXRlcyA9IFtdOyB9XG4gICAgICAgICAgICAvLyBTdXBwb3J0IHBvaW50aW5nIHRvIGRlZmF1bHQgZXhwb3J0cywgYnV0IHN0b3AgcmVjdXJzaW5nIHRoZXJlLFxuICAgICAgICAgICAgLy8gYXMgdGhlIFN0YXRpY1JlZmxlY3RvciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBkZWZhdWx0IGV4cG9ydHMuXG4gICAgICAgICAgICBpZiAoc2VlblJvdXRlcy5oYXMoc3ltYm9sKSB8fCAhc3ltYm9sLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsTGF6eVJvdXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5Sb3V0ZXMuYWRkKHN5bWJvbCk7XG4gICAgICAgICAgICB2YXIgbGF6eVJvdXRlcyA9IGxpc3RMYXp5Um91dGVzKHNlbGYuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShzeW1ib2wsIHRydWUpLCBzZWxmLnJlZmxlY3Rvcik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhenlSb3V0ZXNfMiA9IF9fdmFsdWVzKGxhenlSb3V0ZXMpLCBsYXp5Um91dGVzXzJfMSA9IGxhenlSb3V0ZXNfMi5uZXh0KCk7ICFsYXp5Um91dGVzXzJfMS5kb25lOyBsYXp5Um91dGVzXzJfMSA9IGxhenlSb3V0ZXNfMi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhenlSb3V0ZSA9IGxhenlSb3V0ZXNfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhbGxMYXp5Um91dGVzLnB1c2gobGF6eVJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRMYXp5Um91dGUobGF6eVJvdXRlLnJlZmVyZW5jZWRNb2R1bGUsIHNlZW5Sb3V0ZXMsIGFsbExhenlSb3V0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGF6eVJvdXRlc18yXzEgJiYgIWxhenlSb3V0ZXNfMl8xLmRvbmUgJiYgKF9hID0gbGF6eVJvdXRlc18yLnJldHVybikpIF9hLmNhbGwobGF6eVJvdXRlc18yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbExhenlSb3V0ZXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBb3RDb21waWxlcjtcbn0oKSk7XG5mdW5jdGlvbiBfY3JlYXRlRW1wdHlTdHViKG91dHB1dEN0eCkge1xuICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gcHJvZHVjZSBhdCBsZWFzdCBvbmUgaW1wb3J0IHN0YXRlbWVudCBzbyB0aGF0XG4gICAgLy8gVHlwZVNjcmlwdCBrbm93cyB0aGF0IHRoZSBmaWxlIGlzIGFuIGVzNiBtb2R1bGUuIE90aGVyd2lzZSBvdXIgZ2VuZXJhdGVkXG4gICAgLy8gZXhwb3J0cyAvIGltcG9ydHMgd29uJ3QgYmUgZW1pdHRlZCBwcm9wZXJseSBieSBUeXBlU2NyaXB0LlxuICAgIG91dHB1dEN0eC5zdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5KS50b1N0bXQoKSk7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyhzeW1ib2xSZXNvbHZlciwgY29tcGlsZVJlc3VsdCwgbmVlZHNTaGltLCBmaWxlU3VmZml4KSB7XG4gICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgIGRlcC5zZXRWYWx1ZShzeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2woX3N0eWxlc01vZHVsZVVybChkZXAubW9kdWxlVXJsLCBuZWVkc1NoaW0sIGZpbGVTdWZmaXgpLCBkZXAubmFtZSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gX3N0eWxlc01vZHVsZVVybChzdHlsZXNoZWV0VXJsLCBzaGltLCBzdWZmaXgpIHtcbiAgICByZXR1cm4gXCJcIiArIHN0eWxlc2hlZXRVcmwgKyAoc2hpbSA/ICcuc2hpbScgOiAnJykgKyBcIi5uZ3N0eWxlXCIgKyBzdWZmaXg7XG59XG5mdW5jdGlvbiBhbmFseXplTmdNb2R1bGVzKGZpbGVOYW1lcywgaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICB2YXIgZmlsZXMgPSBfYW5hbHl6ZUZpbGVzSW5jbHVkaW5nTm9uUHJvZ3JhbUZpbGVzKGZpbGVOYW1lcywgaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIpO1xuICAgIHJldHVybiBtZXJnZUFuYWx5emVkRmlsZXMoZmlsZXMpO1xufVxuZnVuY3Rpb24gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKGZpbGVOYW1lcywgaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVBbmFseXplZE1vZHVsZXMoYW5hbHl6ZU5nTW9kdWxlcyhmaWxlTmFtZXMsIGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXRhZGF0YVJlc29sdmVyKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuYWx5emVkTW9kdWxlcyhhbmFseXplZE1vZHVsZXMpIHtcbiAgICBpZiAoYW5hbHl6ZWRNb2R1bGVzLnN5bWJvbHNNaXNzaW5nTW9kdWxlICYmIGFuYWx5emVkTW9kdWxlcy5zeW1ib2xzTWlzc2luZ01vZHVsZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gYW5hbHl6ZWRNb2R1bGVzLnN5bWJvbHNNaXNzaW5nTW9kdWxlLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNsYXNzIFwiICsgcy5uYW1lICsgXCIgaW4gXCIgKyBzLmZpbGVQYXRoICsgXCIhIEFkZCBcIiArIHMubmFtZSArIFwiIHRvIHRoZSBOZ01vZHVsZSB0byBmaXggaXQuXCI7IH0pO1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihtZXNzYWdlcy5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIHJldHVybiBhbmFseXplZE1vZHVsZXM7XG59XG4vLyBBbmFseXplcyBhbGwgb2YgdGhlIHByb2dyYW0gZmlsZXMsXG4vLyBpbmNsdWRpbmcgZmlsZXMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIHByb2dyYW1cbi8vIGJ1dCBhcmUgcmVmZXJlbmNlZCBieSBhbiBOZ01vZHVsZS5cbmZ1bmN0aW9uIF9hbmFseXplRmlsZXNJbmNsdWRpbmdOb25Qcm9ncmFtRmlsZXMoZmlsZU5hbWVzLCBob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciBzZWVuRmlsZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgdmFyIHZpc2l0RmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICBpZiAoc2VlbkZpbGVzLmhhcyhmaWxlTmFtZSkgfHwgIWhvc3QuaXNTb3VyY2VGaWxlKGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW5GaWxlcy5hZGQoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgYW5hbHl6ZWRGaWxlID0gYW5hbHl6ZUZpbGUoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1ldGFkYXRhUmVzb2x2ZXIsIGZpbGVOYW1lKTtcbiAgICAgICAgZmlsZXMucHVzaChhbmFseXplZEZpbGUpO1xuICAgICAgICBhbmFseXplZEZpbGUubmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kTWV0YSkgeyByZXR1cm4gdmlzaXRGaWxlKG1vZE1ldGEucmVmZXJlbmNlLmZpbGVQYXRoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZmlsZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiB2aXNpdEZpbGUoZmlsZU5hbWUpOyB9KTtcbiAgICByZXR1cm4gZmlsZXM7XG59XG5mdW5jdGlvbiBhbmFseXplRmlsZShob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWV0YWRhdGFSZXNvbHZlciwgZmlsZU5hbWUpIHtcbiAgICB2YXIgYWJzdHJhY3REaXJlY3RpdmVzID0gW107XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBbXTtcbiAgICB2YXIgcGlwZXMgPSBbXTtcbiAgICB2YXIgaW5qZWN0YWJsZXMgPSBbXTtcbiAgICB2YXIgbmdNb2R1bGVzID0gW107XG4gICAgdmFyIGhhc0RlY29yYXRvcnMgPSBzdGF0aWNTeW1ib2xSZXNvbHZlci5oYXNEZWNvcmF0b3JzKGZpbGVOYW1lKTtcbiAgICB2YXIgZXhwb3J0c05vblNvdXJjZUZpbGVzID0gZmFsc2U7XG4gICAgdmFyIGlzRGVjbGFyYXRpb25GaWxlID0gZmlsZU5hbWUuZW5kc1dpdGgoJy5kLnRzJyk7XG4gICAgLy8gRG9uJ3QgYW5hbHl6ZSAuZC50cyBmaWxlcyB0aGF0IGhhdmUgbm8gZGVjb3JhdG9ycyBhcyBhIHNob3J0Y3V0XG4gICAgLy8gdG8gc3BlZWQgdXAgdGhlIGFuYWx5c2lzLiBUaGlzIHByZXZlbnRzIHVzIGZyb21cbiAgICAvLyByZXNvbHZpbmcgdGhlIHJlZmVyZW5jZXMgaW4gdGhlc2UgZmlsZXMuXG4gICAgLy8gTm90ZTogZXhwb3J0c05vblNvdXJjZUZpbGVzIGlzIG9ubHkgbmVlZGVkIHdoZW4gY29tcGlsaW5nIHdpdGggc3VtbWFyaWVzLFxuICAgIC8vIHdoaWNoIGlzIG5vdCB0aGUgY2FzZSB3aGVuIC5kLnRzIGZpbGVzIGFyZSB0cmVhdGVkIGFzIGlucHV0IGZpbGVzLlxuICAgIGlmICghaXNEZWNsYXJhdGlvbkZpbGUgfHwgaGFzRGVjb3JhdG9ycykge1xuICAgICAgICBzdGF0aWNTeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2YoZmlsZU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gc3RhdGljU3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgdmFyIHN5bWJvbE1ldGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICghc3ltYm9sTWV0YSB8fCBzeW1ib2xNZXRhLl9fc3ltYm9saWMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNOZ1N5bWJvbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN5bWJvbE1ldGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVJlc29sdmVyLmlzRGlyZWN0aXZlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNOZ1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZGlyZWN0aXZlIGVpdGhlciBoYXMgYSBzZWxlY3RvciBvciBkb2Vzbid0LiBTZWxlY3Rvci1sZXNzIGRpcmVjdGl2ZXMgZ2V0IHRyYWNrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYWJzdHJhY3REaXJlY3RpdmVzLCBub3QgZGlyZWN0aXZlcy4gVGhlIGNvbXBpbGVyIGRvZXNuJ3QgZGVhbCB3aXRoIHNlbGVjdG9yLWxlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlyZWN0aXZlcyBhdCBhbGwsIHJlYWxseSwgb3RoZXIgdGhhbiB0byBwZXJzaXN0IHRoZWlyIG1ldGFkYXRhLiBUaGlzIGlzIGRvbmUgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBzIHdpbGwgaGF2ZSBhbiBlYXNpZXIgdGltZSBtaWdyYXRpbmcgdG8gSXZ5LCB3aGljaCByZXF1aXJlcyB0aGUgc2VsZWN0b3ItbGVzc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbm5vdGF0aW9ucyB0byBiZSBhcHBsaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhUmVzb2x2ZXIuaXNBYnN0cmFjdERpcmVjdGl2ZShzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGlyZWN0aXZlIGlzIGFuIG9yZGluYXJ5IGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRpcmVjdGl2ZSBoYXMgbm8gc2VsZWN0b3IgYW5kIGlzIGFuIFwiYWJzdHJhY3RcIiBkaXJlY3RpdmUsIHNvIHRyYWNrIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFic3RyYWN0RGlyZWN0aXZlcy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFSZXNvbHZlci5pc1BpcGUoc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBpc05nU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGlwZXMucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXRhZGF0YVJlc29sdmVyLmlzTmdNb2R1bGUoc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmdNb2R1bGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEoc3ltYm9sLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZ1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZ01vZHVsZXMucHVzaChuZ01vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFSZXNvbHZlci5pc0luamVjdGFibGUoc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICBpc05nU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluamVjdGFibGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVNZXRhZGF0YShzeW1ib2wsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGFibGVzLnB1c2goaW5qZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmdTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzTm9uU291cmNlRmlsZXMgPVxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzTm9uU291cmNlRmlsZXMgfHwgaXNWYWx1ZUV4cG9ydGluZ05vblNvdXJjZUZpbGUoaG9zdCwgc3ltYm9sTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsXG4gICAgICAgIGFic3RyYWN0RGlyZWN0aXZlczogYWJzdHJhY3REaXJlY3RpdmVzLFxuICAgICAgICBwaXBlczogcGlwZXMsXG4gICAgICAgIG5nTW9kdWxlczogbmdNb2R1bGVzLFxuICAgICAgICBpbmplY3RhYmxlczogaW5qZWN0YWJsZXMsXG4gICAgICAgIGV4cG9ydHNOb25Tb3VyY2VGaWxlczogZXhwb3J0c05vblNvdXJjZUZpbGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiBhbmFseXplRmlsZUZvckluamVjdGFibGVzKGhvc3QsIHN0YXRpY1N5bWJvbFJlc29sdmVyLCBtZXRhZGF0YVJlc29sdmVyLCBmaWxlTmFtZSkge1xuICAgIHZhciBpbmplY3RhYmxlcyA9IFtdO1xuICAgIHZhciBzaGFsbG93TW9kdWxlcyA9IFtdO1xuICAgIGlmIChzdGF0aWNTeW1ib2xSZXNvbHZlci5oYXNEZWNvcmF0b3JzKGZpbGVOYW1lKSkge1xuICAgICAgICBzdGF0aWNTeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2YoZmlsZU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gc3RhdGljU3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgdmFyIHN5bWJvbE1ldGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICghc3ltYm9sTWV0YSB8fCBzeW1ib2xNZXRhLl9fc3ltYm9saWMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sTWV0YS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhUmVzb2x2ZXIuaXNJbmplY3RhYmxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluamVjdGFibGUgPSBtZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVNZXRhZGF0YShzeW1ib2wsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGFibGVzLnB1c2goaW5qZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0YWRhdGFSZXNvbHZlci5pc05nTW9kdWxlKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZSA9IG1ldGFkYXRhUmVzb2x2ZXIuZ2V0U2hhbGxvd01vZHVsZU1ldGFkYXRhKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3dNb2R1bGVzLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGZpbGVOYW1lOiBmaWxlTmFtZSwgaW5qZWN0YWJsZXM6IGluamVjdGFibGVzLCBzaGFsbG93TW9kdWxlczogc2hhbGxvd01vZHVsZXMgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsdWVFeHBvcnRpbmdOb25Tb3VyY2VGaWxlKGhvc3QsIG1ldGFkYXRhKSB7XG4gICAgdmFyIGV4cG9ydHNOb25Tb3VyY2VGaWxlcyA9IGZhbHNlO1xuICAgIHZhciBWaXNpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaXNpdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZpc2l0VmFsdWUodiwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IH07XG4gICAgICAgIFZpc2l0b3IucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCAmJiAhaG9zdC5pc1NvdXJjZUZpbGUodmFsdWUuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c05vblNvdXJjZUZpbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpc2l0b3I7XG4gICAgfSgpKTtcbiAgICB2aXNpdFZhbHVlKG1ldGFkYXRhLCBuZXcgVmlzaXRvcigpLCBudWxsKTtcbiAgICByZXR1cm4gZXhwb3J0c05vblNvdXJjZUZpbGVzO1xufVxuZnVuY3Rpb24gbWVyZ2VBbmFseXplZEZpbGVzKGFuYWx5emVkRmlsZXMpIHtcbiAgICB2YXIgYWxsTmdNb2R1bGVzID0gW107XG4gICAgdmFyIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGFsbFBpcGVzQW5kRGlyZWN0aXZlcyA9IG5ldyBTZXQoKTtcbiAgICBhbmFseXplZEZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGFmKSB7XG4gICAgICAgIGFmLm5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgYWxsTmdNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuc2V0KGQucmVmZXJlbmNlLCBuZ01vZHVsZSk7IH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLnNldChwLnJlZmVyZW5jZSwgbmdNb2R1bGUpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFmLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYWxsUGlwZXNBbmREaXJlY3RpdmVzLmFkZChkKTsgfSk7XG4gICAgICAgIGFmLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIGFsbFBpcGVzQW5kRGlyZWN0aXZlcy5hZGQocCk7IH0pO1xuICAgIH0pO1xuICAgIHZhciBzeW1ib2xzTWlzc2luZ01vZHVsZSA9IFtdO1xuICAgIGFsbFBpcGVzQW5kRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgaWYgKCFuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICBzeW1ib2xzTWlzc2luZ01vZHVsZS5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZ01vZHVsZXM6IGFsbE5nTW9kdWxlcyxcbiAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZTogbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSxcbiAgICAgICAgc3ltYm9sc01pc3NpbmdNb2R1bGU6IHN5bWJvbHNNaXNzaW5nTW9kdWxlLFxuICAgICAgICBmaWxlczogYW5hbHl6ZWRGaWxlc1xuICAgIH07XG59XG5mdW5jdGlvbiBtZXJnZUFuZFZhbGlkYXRlTmdGaWxlcyhmaWxlcykge1xuICAgIHJldHVybiB2YWxpZGF0ZUFuYWx5emVkTW9kdWxlcyhtZXJnZUFuYWx5emVkRmlsZXMoZmlsZXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEZPUk1BVFRFRF9NRVNTQUdFID0gJ25nRm9ybWF0dGVkTWVzc2FnZSc7XG5mdW5jdGlvbiBpbmRlbnRTdHIobGV2ZWwpIHtcbiAgICBpZiAobGV2ZWwgPD0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmIChsZXZlbCA8IDYpXG4gICAgICAgIHJldHVybiBbJycsICcgJywgJyAgJywgJyAgICcsICcgICAgJywgJyAgICAgJ11bbGV2ZWxdO1xuICAgIHZhciBoYWxmID0gaW5kZW50U3RyKE1hdGguZmxvb3IobGV2ZWwgLyAyKSk7XG4gICAgcmV0dXJuIGhhbGYgKyBoYWxmICsgKGxldmVsICUgMiA9PT0gMSA/ICcgJyA6ICcnKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdENoYWluKGNoYWluLCBpbmRlbnQpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICBpZiAoaW5kZW50ID09PSB2b2lkIDApIHsgaW5kZW50ID0gMDsgfVxuICAgIGlmICghY2hhaW4pXG4gICAgICAgIHJldHVybiAnJztcbiAgICB2YXIgcG9zaXRpb24gPSBjaGFpbi5wb3NpdGlvbiA/XG4gICAgICAgIGNoYWluLnBvc2l0aW9uLmZpbGVOYW1lICsgXCIoXCIgKyAoY2hhaW4ucG9zaXRpb24ubGluZSArIDEpICsgXCIsXCIgKyAoY2hhaW4ucG9zaXRpb24uY29sdW1uICsgMSkgKyBcIilcIiA6XG4gICAgICAgICcnO1xuICAgIHZhciBwcmVmaXggPSBwb3NpdGlvbiAmJiBpbmRlbnQgPT09IDAgPyBwb3NpdGlvbiArIFwiOiBcIiA6ICcnO1xuICAgIHZhciBwb3N0Zml4ID0gcG9zaXRpb24gJiYgaW5kZW50ICE9PSAwID8gXCIgYXQgXCIgKyBwb3NpdGlvbiA6ICcnO1xuICAgIHZhciBtZXNzYWdlID0gXCJcIiArIHByZWZpeCArIGNoYWluLm1lc3NhZ2UgKyBwb3N0Zml4O1xuICAgIGlmIChjaGFpbi5uZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGNoYWluLm5leHQpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJ1xcbicgKyBmb3JtYXRDaGFpbihraWQsIGluZGVudCArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBpbmRlbnRTdHIoaW5kZW50KSArIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBmb3JtYXR0ZWRFcnJvcihjaGFpbikge1xuICAgIHZhciBtZXNzYWdlID0gZm9ybWF0Q2hhaW4oY2hhaW4pICsgJy4nO1xuICAgIHZhciBlcnJvciA9IHN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yW0ZPUk1BVFRFRF9NRVNTQUdFXSA9IHRydWU7XG4gICAgZXJyb3IuY2hhaW4gPSBjaGFpbjtcbiAgICBlcnJvci5wb3NpdGlvbiA9IGNoYWluLnBvc2l0aW9uO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzRm9ybWF0dGVkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gISFlcnJvcltGT1JNQVRURURfTUVTU0FHRV07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBTkdVTEFSX0NPUkUgPSAnQGFuZ3VsYXIvY29yZSc7XG52YXIgQU5HVUxBUl9ST1VURVIgPSAnQGFuZ3VsYXIvcm91dGVyJztcbnZhciBISURERU5fS0VZID0gL15cXCQuKlxcJCQvO1xudmFyIElHTk9SRSA9IHtcbiAgICBfX3N5bWJvbGljOiAnaWdub3JlJ1xufTtcbnZhciBVU0VfVkFMVUUkMSA9ICd1c2VWYWx1ZSc7XG52YXIgUFJPVklERSA9ICdwcm92aWRlJztcbnZhciBSRUZFUkVOQ0VfU0VUID0gbmV3IFNldChbVVNFX1ZBTFVFJDEsICd1c2VGYWN0b3J5JywgJ2RhdGEnLCAnaWQnLCAnbG9hZENoaWxkcmVuJ10pO1xudmFyIFRZUEVHVUFSRF9QT1NURklYID0gJ1R5cGVHdWFyZCc7XG52YXIgVVNFX0lGID0gJ1VzZUlmJztcbmZ1bmN0aW9uIHNob3VsZElnbm9yZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5fX3N5bWJvbGljID09ICdpZ25vcmUnO1xufVxuLyoqXG4gKiBBIHN0YXRpYyByZWZsZWN0b3IgaW1wbGVtZW50cyBlbm91Z2ggb2YgdGhlIFJlZmxlY3RvciBBUEkgdGhhdCBpcyBuZWNlc3NhcnkgdG8gY29tcGlsZVxuICogdGVtcGxhdGVzIHN0YXRpY2FsbHkuXG4gKi9cbnZhciBTdGF0aWNSZWZsZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIGtub3duTWV0YWRhdGFDbGFzc2VzLCBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhQ2xhc3NlcyA9PT0gdm9pZCAwKSB7IGtub3duTWV0YWRhdGFDbGFzc2VzID0gW107IH1cbiAgICAgICAgaWYgKGtub3duTWV0YWRhdGFGdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhRnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2hhbGxvd0Fubm90YXRpb25DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1ldGhvZENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXRpY0NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbnZlcnNpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRFeHRlcm5hbFJlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVDb252ZXJzaW9uTWFwKCk7XG4gICAgICAgIGtub3duTWV0YWRhdGFDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGtjKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKF90aGlzLmdldFN0YXRpY1N5bWJvbChrYy5maWxlUGF0aCwga2MubmFtZSksIGtjLmN0b3IpOyB9KTtcbiAgICAgICAga25vd25NZXRhZGF0YUZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrZikgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyRnVuY3Rpb24oX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGtmLmZpbGVQYXRoLCBrZi5uYW1lKSwga2YuZm4pOyB9KTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUsIFtjcmVhdGVEaXJlY3RpdmUsIGNyZWF0ZUNvbXBvbmVudF0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGUsIFtjcmVhdGVQaXBlXSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUsIFtjcmVhdGVOZ01vZHVsZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUsIFtjcmVhdGVJbmplY3RhYmxlLCBjcmVhdGVQaXBlLCBjcmVhdGVEaXJlY3RpdmUsIGNyZWF0ZUNvbXBvbmVudCwgY3JlYXRlTmdNb2R1bGVdKTtcbiAgICB9XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRNb2R1bGVVcmwgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFJlc291cmNlUGF0aChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSB0aGUgc3BlY2lmaWVkIGBzeW1ib2xzYCBvbiBwcm9ncmFtIGNoYW5nZS5cbiAgICAgKiBAcGFyYW0gc3ltYm9sc1xuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW52YWxpZGF0ZVN5bWJvbHMgPSBmdW5jdGlvbiAoc3ltYm9scykge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIHN5bWJvbHNfMSA9IF9fdmFsdWVzKHN5bWJvbHMpLCBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCk7ICFzeW1ib2xzXzFfMS5kb25lOyBzeW1ib2xzXzFfMSA9IHN5bWJvbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFsbG93QW5ub3RhdGlvbkNhY2hlLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlDYWNoZS5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlckNhY2hlLmRlbGV0ZShzeW1ib2wpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kQ2FjaGUuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0aWNDYWNoZS5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnNpb25NYXAuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xzXzFfMSAmJiAhc3ltYm9sc18xXzEuZG9uZSAmJiAoX2EgPSBzeW1ib2xzXzEucmV0dXJuKSkgX2EuY2FsbChzeW1ib2xzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWYsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY29udGFpbmluZ0ZpbGUpIHtcbiAgICAgICAgICAgIGtleSA9IHJlZi5tb2R1bGVOYW1lICsgXCI6XCIgKyByZWYubmFtZTtcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvblN5bWJvbF8xID0gdGhpcy5yZXNvbHZlZEV4dGVybmFsUmVmZXJlbmNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblN5bWJvbF8xKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvblN5bWJvbF8xO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKHJlZi5tb2R1bGVOYW1lLCByZWYubmFtZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25TeW1ib2wgPSB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbihyZWZTeW1ib2wpO1xuICAgICAgICBpZiAoIWNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbFJlc29sdmVyLnJlY29yZE1vZHVsZU5hbWVGb3JGaWxlTmFtZShyZWZTeW1ib2wuZmlsZVBhdGgsIHJlZi5tb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVjb3JkSW1wb3J0QXMoZGVjbGFyYXRpb25TeW1ib2wsIHJlZlN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZEV4dGVybmFsUmVmZXJlbmNlcy5zZXQoa2V5LCBkZWNsYXJhdGlvblN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uU3ltYm9sO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5maW5kRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBuYW1lLCBjb250YWluaW5nRmlsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xCeU1vZHVsZShtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSk7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnRyeUZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmlnbm9yZUVycm9yc0ZvcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5maW5kRGVjbGFyYXRpb24obW9kdWxlVXJsLCBuYW1lLCBjb250YWluaW5nRmlsZSk7IH0pO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5maW5kU3ltYm9sRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlZE1ldGFkYXRhID0gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRNZXRhZGF0YSAmJiByZXNvbHZlZE1ldGFkYXRhLl9fc3ltYm9saWMgPT09ICdyZXNvbHZlZCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZE1ldGFkYXRhID0gcmVzb2x2ZWRNZXRhZGF0YS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRNZXRhZGF0YSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbihyZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUudHJ5QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxSZWNvcmRlciA9IHRoaXMuZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZnVuY3Rpb24gKGVycm9yLCBmaWxlTmFtZSkgeyB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvbnModHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBvcmlnaW5hbFJlY29yZGVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fubm90YXRpb25zKHR5cGUsIGZ1bmN0aW9uICh0eXBlLCBkZWNvcmF0b3JzKSB7IHJldHVybiBfdGhpcy5zaW1wbGlmeSh0eXBlLCBkZWNvcmF0b3JzKTsgfSwgdGhpcy5hbm5vdGF0aW9uQ2FjaGUpO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5zaGFsbG93QW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnModHlwZSwgZnVuY3Rpb24gKHR5cGUsIGRlY29yYXRvcnMpIHsgcmV0dXJuIF90aGlzLnNpbXBsaWZ5KHR5cGUsIGRlY29yYXRvcnMsIHRydWUpOyB9LCB0aGlzLnNoYWxsb3dBbm5vdGF0aW9uQ2FjaGUpO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSwgc2ltcGxpZnksIGFubm90YXRpb25DYWNoZSkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9uQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0aW9ucyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoLmFwcGx5KGFubm90YXRpb25zLCBfX3NwcmVhZChwYXJlbnRBbm5vdGF0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG93bkFubm90YXRpb25zXzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChjbGFzc01ldGFkYXRhWydkZWNvcmF0b3JzJ10pIHtcbiAgICAgICAgICAgICAgICBvd25Bbm5vdGF0aW9uc18xID0gc2ltcGxpZnkodHlwZSwgY2xhc3NNZXRhZGF0YVsnZGVjb3JhdG9ycyddKTtcbiAgICAgICAgICAgICAgICBpZiAob3duQW5ub3RhdGlvbnNfMSkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoLmFwcGx5KGFubm90YXRpb25zLCBfX3NwcmVhZChvd25Bbm5vdGF0aW9uc18xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUgJiYgIXRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUodHlwZS5maWxlUGF0aCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHBhcmVudFR5cGUuZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeSAmJiBzdW1tYXJ5LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzID0gdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuZ2V0KHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlSGFzUmVxdWlyZWRBbm5vdGF0aW9uID0gcmVxdWlyZWRBbm5vdGF0aW9uVHlwZXMuc29tZShmdW5jdGlvbiAocmVxdWlyZWRUeXBlKSB7IHJldHVybiBvd25Bbm5vdGF0aW9uc18xLnNvbWUoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gcmVxdWlyZWRUeXBlLmlzVHlwZU9mKGFubik7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlSGFzUmVxdWlyZWRBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGZvcm1hdE1ldGFkYXRhRXJyb3IobWV0YWRhdGFFcnJvcihcIkNsYXNzIFwiICsgdHlwZS5uYW1lICsgXCIgaW4gXCIgKyB0eXBlLmZpbGVQYXRoICsgXCIgZXh0ZW5kcyBmcm9tIGEgXCIgKyBDb21waWxlU3VtbWFyeUtpbmRbc3VtbWFyeS50eXBlLnN1bW1hcnlLaW5kXSArIFwiIGluIGFub3RoZXIgY29tcGlsYXRpb24gdW5pdCB3aXRob3V0IGR1cGxpY2F0aW5nIHRoZSBkZWNvcmF0b3JcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBzdW1tYXJ5ICovIHVuZGVmaW5lZCwgXCJQbGVhc2UgYWRkIGEgXCIgKyByZXF1aXJlZEFubm90YXRpb25UeXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUubmdNZXRhZGF0YU5hbWU7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyBvciAnKSArIFwiIGRlY29yYXRvciB0byB0aGUgY2xhc3NcIiksIHR5cGUpLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFubm90YXRpb25DYWNoZS5zZXQodHlwZSwgYW5ub3RhdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChhbm4pIHsgcmV0dXJuICEhYW5uOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdGhpcy5wcm9wZXJ0eUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gdGhpcy5maW5kUGFyZW50VHlwZSh0eXBlLCBjbGFzc01ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BNZXRhZGF0YV8xID0gdGhpcy5wcm9wTWV0YWRhdGEocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50UHJvcE1ldGFkYXRhXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3BhcmVudFByb3BdID0gcGFyZW50UHJvcE1ldGFkYXRhXzFbcGFyZW50UHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVtYmVyc18xID0gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWVtYmVyc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wRGF0YSA9IG1lbWJlcnNfMVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wRGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdwcm9wZXJ0eScgfHwgYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBfX3NwcmVhZChwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YVtwcm9wTmFtZV0gPSBkZWNvcmF0b3JzO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wICYmIHByb3BbJ2RlY29yYXRvcnMnXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JzLnB1c2guYXBwbHkoZGVjb3JhdG9ycywgX19zcHJlYWQoX3RoaXMuc2ltcGxpZnkodHlwZSwgcHJvcFsnZGVjb3JhdG9ycyddKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUNhY2hlLnNldCh0eXBlLCBwcm9wTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGE7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJwYXJhbWV0ZXJzIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyc18xID0gdGhpcy5wYXJhbWV0ZXJDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnNfMSkge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHZhciBtZW1iZXJzID0gY2xhc3NNZXRhZGF0YSA/IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGN0b3JEYXRhID0gbWVtYmVycyA/IG1lbWJlcnNbJ19fY3Rvcl9fJ10gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjdG9yRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3RvciA9IGN0b3JEYXRhLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAnY29uc3RydWN0b3InOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd1BhcmFtZXRlclR5cGVzID0gY3RvclsncGFyYW1ldGVycyddIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyRGVjb3JhdG9yc18xID0gdGhpcy5zaW1wbGlmeSh0eXBlLCBjdG9yWydwYXJhbWV0ZXJEZWNvcmF0b3JzJ10gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmF3UGFyYW1ldGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocmF3UGFyYW1UeXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lc3RlZFJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtVHlwZSA9IF90aGlzLnRyeVNpbXBsaWZ5KHR5cGUsIHJhd1BhcmFtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1UeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFJlc3VsdC5wdXNoKHBhcmFtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdG9ycyA9IHBhcmFtZXRlckRlY29yYXRvcnNfMSA/IHBhcmFtZXRlckRlY29yYXRvcnNfMVtpbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRSZXN1bHQucHVzaC5hcHBseShuZXN0ZWRSZXN1bHQsIF9fc3ByZWFkKGRlY29yYXRvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMS5wdXNoKG5lc3RlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMSA9IHRoaXMucGFyYW1ldGVycyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyQ2FjaGUuc2V0KHR5cGUsIHBhcmFtZXRlcnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyc18xO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIG9uIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdpdGggZXJyb3IgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuX21ldGhvZE5hbWVzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWVzID0gdGhpcy5tZXRob2RDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50TWV0aG9kTmFtZXNfMSA9IHRoaXMuX21ldGhvZE5hbWVzKHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudE1ldGhvZE5hbWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZXNbcGFyZW50UHJvcF0gPSBwYXJlbnRNZXRob2ROYW1lc18xW3BhcmVudFByb3BdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1lbWJlcnNfMiA9IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lbWJlcnNfMikuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcERhdGEgPSBtZW1iZXJzXzJbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBpc01ldGhvZCA9IHByb3BEYXRhLnNvbWUoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAnbWV0aG9kJzsgfSk7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZXNbcHJvcE5hbWVdID0gbWV0aG9kTmFtZXNbcHJvcE5hbWVdIHx8IGlzTWV0aG9kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1ldGhvZENhY2hlLnNldCh0eXBlLCBtZXRob2ROYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZE5hbWVzO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fc3RhdGljTWVtYmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBzdGF0aWNNZW1iZXJzID0gdGhpcy5zdGF0aWNDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIGlmICghc3RhdGljTWVtYmVycykge1xuICAgICAgICAgICAgdmFyIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHZhciBzdGF0aWNNZW1iZXJEYXRhID0gY2xhc3NNZXRhZGF0YVsnc3RhdGljcyddIHx8IHt9O1xuICAgICAgICAgICAgc3RhdGljTWVtYmVycyA9IE9iamVjdC5rZXlzKHN0YXRpY01lbWJlckRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNDYWNoZS5zZXQodHlwZSwgc3RhdGljTWVtYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRpY01lbWJlcnM7XG4gICAgfTtcbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRQYXJlbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGNsYXNzTWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIHBhcmVudFR5cGUgPSB0aGlzLnRyeVNpbXBsaWZ5KHR5cGUsIGNsYXNzTWV0YWRhdGFbJ2V4dGVuZHMnXSk7XG4gICAgICAgIGlmIChwYXJlbnRUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VHlwZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiaGFzTGlmZWN5Y2xlSG9vayByZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2hpY2ggaXMgbm90IGEgU3RhdGljU3ltYm9sXCIpLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbWV0aG9kTmFtZXModHlwZSlbbGNQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5ndWFyZHMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiZ3VhcmRzIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0aWNNZW1iZXJzID0gdGhpcy5fc3RhdGljTWVtYmVycyh0eXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgc3RhdGljTWVtYmVyc18xID0gX192YWx1ZXMoc3RhdGljTWVtYmVycyksIHN0YXRpY01lbWJlcnNfMV8xID0gc3RhdGljTWVtYmVyc18xLm5leHQoKTsgIXN0YXRpY01lbWJlcnNfMV8xLmRvbmU7IHN0YXRpY01lbWJlcnNfMV8xID0gc3RhdGljTWVtYmVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdGF0aWNNZW1iZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xLmVuZHNXaXRoKFRZUEVHVUFSRF9QT1NURklYKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lXzEuc3Vic3RyKDAsIG5hbWVfMS5sZW5ndGggLSBUWVBFR1VBUkRfUE9TVEZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5lbmRzV2l0aChVU0VfSUYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG5hbWVfMS5zdWJzdHIoMCwgcHJvcGVydHkubGVuZ3RoIC0gVVNFX0lGLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFVTRV9JRjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRTdGF0aWNTeW1ib2wodHlwZS5maWxlUGF0aCwgdHlwZS5uYW1lLCBbbmFtZV8xXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY01lbWJlcnNfMV8xICYmICFzdGF0aWNNZW1iZXJzXzFfMS5kb25lICYmIChfYSA9IHN0YXRpY01lbWJlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKHN0YXRpY01lbWJlcnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICh0eXBlLCBjdG9yKSB7XG4gICAgICAgIHRoaXMuY29udmVyc2lvbk1hcC5zZXQodHlwZSwgZnVuY3Rpb24gKGNvbnRleHQsIGFyZ3MpIHsgcmV0dXJuIG5ldyAoY3Rvci5iaW5kLmFwcGx5KGN0b3IsIF9fc3ByZWFkKFt2b2lkIDBdLCBhcmdzKSkpKCk7IH0pO1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fcmVnaXN0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xuICAgICAgICB0aGlzLmNvbnZlcnNpb25NYXAuc2V0KHR5cGUsIGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7IHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9KTtcbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3RhYmxlJyksIGNyZWF0ZUluamVjdGFibGUpO1xuICAgICAgICB0aGlzLmluamVjdGlvblRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5qZWN0aW9uVG9rZW4nKTtcbiAgICAgICAgdGhpcy5vcGFxdWVUb2tlbiA9IHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ09wYXF1ZVRva2VuJyk7XG4gICAgICAgIHRoaXMuUk9VVEVTID0gdGhpcy50cnlGaW5kRGVjbGFyYXRpb24oQU5HVUxBUl9ST1VURVIsICdST1VURVMnKTtcbiAgICAgICAgdGhpcy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID1cbiAgICAgICAgICAgIHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgY3JlYXRlSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTZWxmJyksIGNyZWF0ZVNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2tpcFNlbGYnKSwgY3JlYXRlU2tpcFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5qZWN0JyksIGNyZWF0ZUluamVjdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdPcHRpb25hbCcpLCBjcmVhdGVPcHRpb25hbCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdBdHRyaWJ1dGUnKSwgY3JlYXRlQXR0cmlidXRlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0NvbnRlbnRDaGlsZCcpLCBjcmVhdGVDb250ZW50Q2hpbGQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQ29udGVudENoaWxkcmVuJyksIGNyZWF0ZUNvbnRlbnRDaGlsZHJlbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdWaWV3Q2hpbGQnKSwgY3JlYXRlVmlld0NoaWxkKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1ZpZXdDaGlsZHJlbicpLCBjcmVhdGVWaWV3Q2hpbGRyZW4pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSW5wdXQnKSwgY3JlYXRlSW5wdXQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3V0cHV0JyksIGNyZWF0ZU91dHB1dCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdQaXBlJyksIGNyZWF0ZVBpcGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSG9zdEJpbmRpbmcnKSwgY3JlYXRlSG9zdEJpbmRpbmcpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSG9zdExpc3RlbmVyJyksIGNyZWF0ZUhvc3RMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdEaXJlY3RpdmUnKSwgY3JlYXRlRGlyZWN0aXZlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0NvbXBvbmVudCcpLCBjcmVhdGVDb21wb25lbnQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnTmdNb2R1bGUnKSwgY3JlYXRlTmdNb2R1bGUpO1xuICAgICAgICAvLyBOb3RlOiBTb21lIG1ldGFkYXRhIGNsYXNzZXMgY2FuIGJlIHVzZWQgZGlyZWN0bHkgd2l0aCBQcm92aWRlci5kZXBzLlxuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnSG9zdCcpLCBjcmVhdGVIb3N0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NlbGYnKSwgY3JlYXRlU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTa2lwU2VsZicpLCBjcmVhdGVTa2lwU2VsZik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdPcHRpb25hbCcpLCBjcmVhdGVPcHRpb25hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRTdGF0aWNTeW1ib2wgcHJvZHVjZXMgYSBUeXBlIHdob3NlIG1ldGFkYXRhIGlzIGtub3duIGJ1dCB3aG9zZSBpbXBsZW1lbnRhdGlvbiBpcyBub3QgbG9hZGVkLlxuICAgICAqIEFsbCB0eXBlcyBwYXNzZWQgdG8gdGhlIFN0YXRpY1Jlc29sdmVyIHNob3VsZCBiZSBwc2V1ZG8tdHlwZXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmdldFN0YXRpY1N5bWJvbCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sUmVzb2x2ZXIuZ2V0U3RhdGljU3ltYm9sKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGlmeSBidXQgZGlzY2FyZCBhbnkgZXJyb3JzXG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS50cnlTaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3JpZ2luYWxSZWNvcmRlciA9IHRoaXMuZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZnVuY3Rpb24gKGVycm9yLCBmaWxlTmFtZSkgeyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zaW1wbGlmeShjb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IG9yaWdpbmFsUmVjb3JkZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSwgbGF6eSkge1xuICAgICAgICBpZiAobGF6eSA9PT0gdm9pZCAwKSB7IGxhenkgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzY29wZSA9IEJpbmRpbmdTY29wZSQxLmVtcHR5O1xuICAgICAgICB2YXIgY2FsbGluZyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHJvb3RDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgZnVuY3Rpb24gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgdmFsdWUsIGRlcHRoLCByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkU3ltYm9sID0gc2VsZi5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2ltcGxpZnlFYWdlcmx5KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUxhemlseSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgsIHJlZmVyZW5jZXMgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5TmVzdGVkKG5lc3RlZENvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lc3RlZENvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaGFzbid0IGNoYW5nZWQgbGV0IHRoZSBleGNlcHRpb24gcHJvcGFnYXRlIHVubW9kaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChuZXN0ZWRDb250ZXh0LCB2YWx1ZSwgZGVwdGggKyAxLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KG5lc3RlZENvbnRleHQsIHZhbHVlLCBkZXB0aCArIDEsIHJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNZXRhZGF0YUVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIG1lc3NhZ2UgdGV4dCB1cCBidXQgYWRkIGEgbWVzc2FnZSB0byB0aGUgY2hhaW4gdGhhdCBleHBsYWlucyBob3cgd2UgZ290XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5jaGFpbiBpbXBsaWVzIGUuc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeU1zZyA9IGUuY2hhaW4gPyAncmVmZXJlbmNlcyBcXCcnICsgZS5zeW1ib2wubmFtZSArICdcXCcnIDogZXJyb3JTdW1tYXJ5KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bW1hcnkgPSBcIidcIiArIG5lc3RlZENvbnRleHQubmFtZSArIFwiJyBcIiArIHN1bW1hcnlNc2c7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSB7IG1lc3NhZ2U6IHN1bW1hcnksIHBvc2l0aW9uOiBlLnBvc2l0aW9uLCBuZXh0OiBlLmNoYWluIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGNodWNraik6IHJldHJpZXZlIHRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpbmRpcmVjdGx5IGZyb20gdGhlIGNvbGxlY3RvcnMgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFwIGlmIHRoZSBtZXRhZGF0YSBpcyBmcm9tIGEgLnRzIGZpbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2aXNlOiBlLmFkdmlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogbmVzdGVkQ29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBwcm9iYWJseSBhbiBpbnRlcm5hbCBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeUNhbGwoZnVuY3Rpb25TeW1ib2wsIHRhcmdldEZ1bmN0aW9uLCBhcmdzLCB0YXJnZXRFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEZ1bmN0aW9uICYmIHRhcmdldEZ1bmN0aW9uWydfX3N5bWJvbGljJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGluZy5nZXQoZnVuY3Rpb25TeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVjdXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IFwiY2FsbGVkICdcIiArIGZ1bmN0aW9uU3ltYm9sLm5hbWUgKyBcIicgcmVjdXJzaXZlbHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0RnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzEgPSB0YXJnZXRGdW5jdGlvblsndmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xICYmIChkZXB0aCAhPSAwIHx8IHZhbHVlXzEuX19zeW1ib2xpYyAhPSAnZXJyb3InKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGFyZ2V0RnVuY3Rpb25bJ3BhcmFtZXRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSB0YXJnZXRGdW5jdGlvbi5kZWZhdWx0cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlOZXN0ZWQoY29udGV4dCwgYXJnKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaG91bGRJZ25vcmUoYXJnKSA/IHVuZGVmaW5lZCA6IGFyZzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmxlbmd0aCA+IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCBfX3NwcmVhZChkZWZhdWx0cy5zbGljZShhcmdzLmxlbmd0aCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2ltcGxpZnkodmFsdWUpOyB9KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLnNldChmdW5jdGlvblN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uU2NvcGUgPSBCaW5kaW5nU2NvcGUkMS5idWlsZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblNjb3BlLmRlZmluZShwYXJhbWV0ZXJzW2ldLCBhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gZnVuY3Rpb25TY29wZS5kb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xID0gc2ltcGxpZnlOZXN0ZWQoZnVuY3Rpb25TeW1ib2wsIHZhbHVlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBvbGRTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGluZy5kZWxldGUoZnVuY3Rpb25TeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZXB0aCBpcyAwIHdlIGFyZSBldmFsdWF0aW5nIHRoZSB0b3AgbGV2ZWwgZXhwcmVzc2lvbiB0aGF0IGlzIGRlc2NyaWJpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBkZWNvcmF0b3IuIEluIHRoaXMgY2FzZSwgaXQgaXMgYSBkZWNvcmF0b3Igd2UgZG9uJ3QgdW5kZXJzdGFuZCwgc3VjaCBhcyBhIGN1c3RvbVxuICAgICAgICAgICAgICAgICAgICAvLyBub24tYW5ndWxhciBkZWNvcmF0b3IsIGFuZCB3ZSBzaG91bGQganVzdCBpZ25vcmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RXhwcmVzc2lvbiAmJiB0YXJnZXRFeHByZXNzaW9uLl9fc3ltYm9saWMgPT0gJ3Jlc29sdmVkJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHRhcmdldEV4cHJlc3Npb24ubGluZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRhcmdldEV4cHJlc3Npb24uY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0YXJnZXRFeHByZXNzaW9uLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUgIT0gbnVsbCAmJiBsaW5lICE9IG51bGwgJiYgY2hhcmFjdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0geyBmaWxlTmFtZTogZmlsZU5hbWUsIGxpbmU6IGxpbmUsIGNvbHVtbjogY2hhcmFjdGVyIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEZVTkNUSU9OX0NBTExfTk9UX1NVUFBPUlRFRCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZnVuY3Rpb25TeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzaW1wbGlmeShleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJpbWl0aXZlKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoZXhwcmVzc2lvbiksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNwcmVhZCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fX3N5bWJvbGljID09PSAnc3ByZWFkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYWxsIHdpdGggcmVmZXJlbmNlcyBhcyAwIGJlY2F1c2Ugd2UgcmVxdWlyZSB0aGUgYWN0dWFsIHZhbHVlIGFuZCBjYW5ub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9sZXJhdGUgYSByZWZlcmVuY2UgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcmVhZEFycmF5ID0gc2ltcGxpZnlFYWdlcmx5KGl0ZW0uZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwcmVhZEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzcHJlYWRBcnJheV8xID0gKGVfNCA9IHZvaWQgMCwgX192YWx1ZXMoc3ByZWFkQXJyYXkpKSwgc3ByZWFkQXJyYXlfMV8xID0gc3ByZWFkQXJyYXlfMS5uZXh0KCk7ICFzcHJlYWRBcnJheV8xXzEuZG9uZTsgc3ByZWFkQXJyYXlfMV8xID0gc3ByZWFkQXJyYXlfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcmVhZEl0ZW0gPSBzcHJlYWRBcnJheV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2goc3ByZWFkSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcHJlYWRBcnJheV8xXzEgJiYgIXNwcmVhZEFycmF5XzFfMS5kb25lICYmIChfYiA9IHNwcmVhZEFycmF5XzEucmV0dXJuKSkgX2IuY2FsbChzcHJlYWRBcnJheV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzIgPSBzaW1wbGlmeShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHZhbHVlXzIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRfMi5wdXNoKHZhbHVlXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHNpbXBsaWZpY2F0aW9uIGF0IGJ1aWx0aW4gc3ltYm9scyBvciBpZiB3ZSBhcmUgaW4gYSByZWZlcmVuY2UgY29udGV4dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBkb2Vzbid0IGhhdmUgbWVtYmVycy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHNlbGYuaW5qZWN0aW9uVG9rZW4gfHwgc2VsZi5jb252ZXJzaW9uTWFwLmhhcyhleHByZXNzaW9uKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlZmVyZW5jZXMgPiAwICYmICFleHByZXNzaW9uLm1lbWJlcnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGljU3ltYm9sID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb25WYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5TmVzdGVkKHN0YXRpY1N5bWJvbCwgZGVjbGFyYXRpb25WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGljU3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWydfX3N5bWJvbGljJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0aWNTeW1ib2wgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb25bJ19fc3ltYm9saWMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jpbm9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBzaW1wbGlmeShleHByZXNzaW9uWydsZWZ0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKGxlZnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ3JpZ2h0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcmJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgXiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICYgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8PCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPDwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPj4gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBzaW1wbGlmeShleHByZXNzaW9uWydjb25kaXRpb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb24gPyBzaW1wbGlmeShleHByZXNzaW9uWyd0aGVuRXhwcmVzc2lvbiddKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGlmeShleHByZXNzaW9uWydlbHNlRXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmFuZCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ29wZXJhbmQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUob3BlcmFuZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB+b3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleFRhcmdldCA9IHNpbXBsaWZ5RWFnZXJseShleHByZXNzaW9uWydleHByZXNzaW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzaW1wbGlmeUVhZ2VybHkoZXhwcmVzc2lvblsnaW5kZXgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRhcmdldCAmJiBpc1ByaW1pdGl2ZShpbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhUYXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVtYmVyID0gZXhwcmVzc2lvblsnbWVtYmVyJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdFRhcmdldCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXJzID0gc2VsZWN0VGFyZ2V0Lm1lbWJlcnMuY29uY2F0KG1lbWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RDb250ZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdldFN0YXRpY1N5bWJvbChzZWxlY3RUYXJnZXQuZmlsZVBhdGgsIHNlbGVjdFRhcmdldC5uYW1lLCBtZW1iZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHNlbGVjdENvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeU5lc3RlZChzZWxlY3RDb250ZXh0LCBkZWNsYXJhdGlvblZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgJiYgaXNQcmltaXRpdmUobWVtYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeU5lc3RlZChzZWxlY3RDb250ZXh0LCBzZWxlY3RUYXJnZXRbbWVtYmVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgb25seSBoYXMgdG8gZGVhbCB3aXRoIHZhcmlhYmxlIHJlZmVyZW5jZXMsIGFzIHN5bWJvbCByZWZlcmVuY2VzIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBjb252ZXJ0ZWQgaW50byAncmVzb2x2ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBTdGF0aWNTeW1ib2xSZXNvbHZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGV4cHJlc3Npb25bJ25hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsVmFsdWUgPSBzY29wZS5yZXNvbHZlKG5hbWVfMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFZhbHVlICE9IEJpbmRpbmdTY29wZSQxLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Jlc29sdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeShleHByZXNzaW9uLnN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIGlzIHJlcG9ydGVkIGV2YWx1YXRpbmcgdGhlIHN5bWJvbCByZWNvcmQgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGluIHRoZSBlcnJvciBzbyBpdCBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHJlcG9ydGVkIGluIHRoZSBlcnJvciBtZXNzYWdlIGdlbmVyYXRlZCBmcm9tIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNZXRhZGF0YUVycm9yKGUpICYmIGV4cHJlc3Npb24uZmlsZU5hbWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24ubGluZSAhPSBudWxsICYmIGV4cHJlc3Npb24uY2hhcmFjdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZXhwcmVzc2lvbi5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZXhwcmVzc2lvbi5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGV4cHJlc3Npb24uY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjYWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBmdW5jdGlvbiBpcyBhIGJ1aWx0LWluIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljU3ltYm9sID0gc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddLCBkZXB0aCArIDEsIC8qIHJlZmVyZW5jZXMgKi8gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTeW1ib2wgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTeW1ib2wgPT09IHNlbGYuaW5qZWN0aW9uVG9rZW4gfHwgc3RhdGljU3ltYm9sID09PSBzZWxmLm9wYXF1ZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgc29tZWJvZHkgY2FsbHMgbmV3IEluamVjdGlvblRva2VuLCBkb24ndCBjcmVhdGUgYW4gSW5qZWN0aW9uVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHJhdGhlciByZXR1cm4gdGhlIHN5bWJvbCB0byB3aGljaCB0aGUgSW5qZWN0aW9uVG9rZW4gaXMgYXNzaWduZWQgdG8uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BhcXVlVG9rZW4gaXMgc3VwcG9ydGVkIHRvbyBhcyBpdCBpcyByZXF1aXJlZCBieSB0aGUgbGFuZ3VhZ2Ugc2VydmljZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgdjQgYW5kIHByaW9yIHZlcnNpb25zIG9mIEFuZ3VsYXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnRXhwcmVzc2lvbnMgPSBleHByZXNzaW9uWydhcmd1bWVudHMnXSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZXIgPSBzZWxmLmNvbnZlcnNpb25NYXAuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmdFeHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2ltcGxpZnlOZXN0ZWQoY29udGV4dCwgYXJnKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaG91bGRJZ25vcmUoYXJnKSA/IHVuZGVmaW5lZCA6IGFyZzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlcihjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZnVuY3Rpb24gaXMgb25lIHdlIGNhbiBzaW1wbGlmeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RnVuY3Rpb24gPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlDYWxsKHN0YXRpY1N5bWJvbCwgdGFyZ2V0RnVuY3Rpb24sIGFyZ0V4cHJlc3Npb25zLCBleHByZXNzaW9uWydleHByZXNzaW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGV4cHJlc3Npb24ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25bJ2xpbmUnXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGV4cHJlc3Npb24uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogZXhwcmVzc2lvblsnZmlsZU5hbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZXhwcmVzc2lvblsnbGluZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGV4cHJlc3Npb25bJ2NoYXJhY3RlciddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSwgY29udGV4dDogZXhwcmVzc2lvbi5jb250ZXh0IH0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwU3RyaW5nTWFwKGV4cHJlc3Npb24sIGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFRkVSRU5DRV9TRVQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFVTRV9WQUxVRSQxICYmIFBST1ZJREUgaW4gZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJvdmlkZXIgZXhwcmVzc2lvbiwgY2hlY2sgZm9yIHNwZWNpYWwgdG9rZW5zIHRoYXQgbmVlZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVyaW5nIGFuYWx5c2lzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZSA9IHNpbXBsaWZ5KGV4cHJlc3Npb24ucHJvdmlkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlID09PSBzZWxmLlJPVVRFUyB8fCBwcm92aWRlID09IHNlbGYuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlMYXppbHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgMCwgbGF6eSA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JSZWNvcmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBmb3JtYXRNZXRhZGF0YUVycm9yKGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmUocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2wodHlwZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSA/IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIDpcbiAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ2NsYXNzJyB9O1xuICAgIH07XG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIoZm9ybWF0TWV0YWRhdGFFcnJvcihlcnJvciwgY29udGV4dCksIChjb250ZXh0ICYmIGNvbnRleHQuZmlsZVBhdGgpIHx8IHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoX2EsIHJlcG9ydGluZ0NvbnRleHQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBfYS5tZXNzYWdlLCBzdW1tYXJ5ID0gX2Euc3VtbWFyeSwgYWR2aXNlID0gX2EuYWR2aXNlLCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCBjb250ZXh0ID0gX2EuY29udGV4dCwgdmFsdWUgPSBfYS52YWx1ZSwgc3ltYm9sID0gX2Euc3ltYm9sLCBjaGFpbiA9IF9hLmNoYWluO1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG1ldGFkYXRhRXJyb3IobWVzc2FnZSwgc3VtbWFyeSwgYWR2aXNlLCBwb3NpdGlvbiwgc3ltYm9sLCBjb250ZXh0LCBjaGFpbiksIHJlcG9ydGluZ0NvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1JlZmxlY3Rvcjtcbn0oKSk7XG52YXIgTUVUQURBVEFfRVJST1IgPSAnbmdNZXRhZGF0YUVycm9yJztcbmZ1bmN0aW9uIG1ldGFkYXRhRXJyb3IobWVzc2FnZSwgc3VtbWFyeSwgYWR2aXNlLCBwb3NpdGlvbiwgc3ltYm9sLCBjb250ZXh0LCBjaGFpbikge1xuICAgIHZhciBlcnJvciA9IHN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yW01FVEFEQVRBX0VSUk9SXSA9IHRydWU7XG4gICAgaWYgKGFkdmlzZSlcbiAgICAgICAgZXJyb3IuYWR2aXNlID0gYWR2aXNlO1xuICAgIGlmIChwb3NpdGlvbilcbiAgICAgICAgZXJyb3IucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBpZiAoc3VtbWFyeSlcbiAgICAgICAgZXJyb3Iuc3VtbWFyeSA9IHN1bW1hcnk7XG4gICAgaWYgKGNvbnRleHQpXG4gICAgICAgIGVycm9yLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChjaGFpbilcbiAgICAgICAgZXJyb3IuY2hhaW4gPSBjaGFpbjtcbiAgICBpZiAoc3ltYm9sKVxuICAgICAgICBlcnJvci5zeW1ib2wgPSBzeW1ib2w7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZnVuY3Rpb24gaXNNZXRhZGF0YUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuICEhZXJyb3JbTUVUQURBVEFfRVJST1JdO1xufVxudmFyIFJFRkVSRU5DRV9UT19OT05FWFBPUlRFRF9DTEFTUyA9ICdSZWZlcmVuY2UgdG8gbm9uLWV4cG9ydGVkIGNsYXNzJztcbnZhciBWQVJJQUJMRV9OT1RfSU5JVElBTElaRUQgPSAnVmFyaWFibGUgbm90IGluaXRpYWxpemVkJztcbnZhciBERVNUUlVDVFVSRV9OT1RfU1VQUE9SVEVEID0gJ0Rlc3RydWN0dXJpbmcgbm90IHN1cHBvcnRlZCc7XG52YXIgQ09VTERfTk9UX1JFU09MVkVfVFlQRSA9ICdDb3VsZCBub3QgcmVzb2x2ZSB0eXBlJztcbnZhciBGVU5DVElPTl9DQUxMX05PVF9TVVBQT1JURUQgPSAnRnVuY3Rpb24gY2FsbCBub3Qgc3VwcG9ydGVkJztcbnZhciBSRUZFUkVOQ0VfVE9fTE9DQUxfU1lNQk9MID0gJ1JlZmVyZW5jZSB0byBhIGxvY2FsIHN5bWJvbCc7XG52YXIgTEFNQkRBX05PVF9TVVBQT1JURUQgPSAnTGFtYmRhIG5vdCBzdXBwb3J0ZWQnO1xuZnVuY3Rpb24gZXhwYW5kZWRNZXNzYWdlKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UpIHtcbiAgICAgICAgY2FzZSBSRUZFUkVOQ0VfVE9fTk9ORVhQT1JURURfQ0xBU1M6XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlJlZmVyZW5jZXMgdG8gYSBub24tZXhwb3J0ZWQgY2xhc3MgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gZGVjb3JhdG9ycyBidXQgXCIgKyBjb250ZXh0LmNsYXNzTmFtZSArIFwiIHdhcyByZWZlcmVuY2VkLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfTk9UX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuICdPbmx5IGluaXRpYWxpemVkIHZhcmlhYmxlcyBhbmQgY29uc3RhbnRzIGNhbiBiZSByZWZlcmVuY2VkIGluIGRlY29yYXRvcnMgYmVjYXVzZSB0aGUgdmFsdWUgb2YgdGhpcyB2YXJpYWJsZSBpcyBuZWVkZWQgYnkgdGhlIHRlbXBsYXRlIGNvbXBpbGVyJztcbiAgICAgICAgY2FzZSBERVNUUlVDVFVSRV9OT1RfU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdSZWZlcmVuY2luZyBhbiBleHBvcnRlZCBkZXN0cnVjdHVyZWQgdmFyaWFibGUgb3IgY29uc3RhbnQgaXMgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzIGFuZCB0aGlzIHZhbHVlIGlzIG5lZWRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXInO1xuICAgICAgICBjYXNlIENPVUxEX05PVF9SRVNPTFZFX1RZUEU6XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHJlc29sdmUgdHlwZSBcIiArIGNvbnRleHQudHlwZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGVU5DVElPTl9DQUxMX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJGdW5jdGlvbiBjYWxscyBhcmUgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzIGJ1dCAnXCIgKyBjb250ZXh0Lm5hbWUgKyBcIicgd2FzIGNhbGxlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdGdW5jdGlvbiBjYWxscyBhcmUgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzJztcbiAgICAgICAgY2FzZSBSRUZFUkVOQ0VfVE9fTE9DQUxfU1lNQk9MOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUmVmZXJlbmNlIHRvIGEgbG9jYWwgKG5vbi1leHBvcnRlZCkgc3ltYm9scyBhcmUgbm90IHN1cHBvcnRlZCBpbiBkZWNvcmF0b3JzIGJ1dCAnXCIgKyBjb250ZXh0Lm5hbWUgKyBcIicgd2FzIHJlZmVyZW5jZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExBTUJEQV9OT1RfU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb24gZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gZGVjb3JhdG9yc1wiO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIG1lc3NhZ2VBZHZpc2UobWVzc2FnZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAobWVzc2FnZSkge1xuICAgICAgICBjYXNlIFJFRkVSRU5DRV9UT19OT05FWFBPUlRFRF9DTEFTUzpcbiAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29uc2lkZXIgZXhwb3J0aW5nICdcIiArIGNvbnRleHQuY2xhc3NOYW1lICsgXCInXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBERVNUUlVDVFVSRV9OT1RfU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdDb25zaWRlciBzaW1wbGlmeWluZyB0byBhdm9pZCBkZXN0cnVjdHVyaW5nJztcbiAgICAgICAgY2FzZSBSRUZFUkVOQ0VfVE9fTE9DQUxfU1lNQk9MOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29uc2lkZXIgZXhwb3J0aW5nICdcIiArIGNvbnRleHQubmFtZSArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEFNQkRBX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJDb25zaWRlciBjaGFuZ2luZyB0aGUgZnVuY3Rpb24gZXhwcmVzc2lvbiBpbnRvIGFuIGV4cG9ydGVkIGZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBlcnJvclN1bW1hcnkoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3Iuc3VtbWFyeSkge1xuICAgICAgICByZXR1cm4gZXJyb3Iuc3VtbWFyeTtcbiAgICB9XG4gICAgc3dpdGNoIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIGNhc2UgUkVGRVJFTkNFX1RPX05PTkVYUE9SVEVEX0NMQVNTOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZWZlcmVuY2VzIG5vbi1leHBvcnRlZCBjbGFzcyBcIiArIGVycm9yLmNvbnRleHQuY2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVkFSSUFCTEVfTk9UX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuICdpcyBub3QgaW5pdGlhbGl6ZWQnO1xuICAgICAgICBjYXNlIERFU1RSVUNUVVJFX05PVF9TVVBQT1JURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ2lzIGEgZGVzdHJ1Y3R1cmVkIHZhcmlhYmxlJztcbiAgICAgICAgY2FzZSBDT1VMRF9OT1RfUkVTT0xWRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICdjb3VsZCBub3QgYmUgcmVzb2x2ZWQnO1xuICAgICAgICBjYXNlIEZVTkNUSU9OX0NBTExfTk9UX1NVUFBPUlRFRDpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNhbGxzICdcIiArIGVycm9yLmNvbnRleHQubmFtZSArIFwiJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiY2FsbHMgYSBmdW5jdGlvblwiO1xuICAgICAgICBjYXNlIFJFRkVSRU5DRV9UT19MT0NBTF9TWU1CT0w6XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29udGV4dCAmJiBlcnJvci5jb250ZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJyZWZlcmVuY2VzIGxvY2FsIHZhcmlhYmxlIFwiICsgZXJyb3IuY29udGV4dC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwicmVmZXJlbmNlcyBhIGxvY2FsIHZhcmlhYmxlXCI7XG4gICAgfVxuICAgIHJldHVybiAnY29udGFpbnMgdGhlIGVycm9yJztcbn1cbmZ1bmN0aW9uIG1hcFN0cmluZ01hcChpbnB1dCwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybShpbnB1dFtrZXldLCBrZXkpO1xuICAgICAgICBpZiAoIXNob3VsZElnbm9yZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChISURERU5fS0VZLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG8gIT09ICdvYmplY3QnKTtcbn1cbnZhciBCaW5kaW5nU2NvcGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nU2NvcGUoKSB7XG4gICAgfVxuICAgIEJpbmRpbmdTY29wZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZpbmU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuc2l6ZSA+IDAgPyBuZXcgUG9wdWxhdGVkU2NvcGUoY3VycmVudCkgOiBCaW5kaW5nU2NvcGUuZW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBCaW5kaW5nU2NvcGUubWlzc2luZyA9IHt9O1xuICAgIEJpbmRpbmdTY29wZS5lbXB0eSA9IHsgcmVzb2x2ZTogZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIEJpbmRpbmdTY29wZS5taXNzaW5nOyB9IH07XG4gICAgcmV0dXJuIEJpbmRpbmdTY29wZTtcbn0oKSk7XG52YXIgUG9wdWxhdGVkU2NvcGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVsYXRlZFNjb3BlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcHVsYXRlZFNjb3BlKGJpbmRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9wdWxhdGVkU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5oYXMobmFtZSkgPyB0aGlzLmJpbmRpbmdzLmdldChuYW1lKSA6IEJpbmRpbmdTY29wZSQxLm1pc3Npbmc7XG4gICAgfTtcbiAgICByZXR1cm4gUG9wdWxhdGVkU2NvcGU7XG59KEJpbmRpbmdTY29wZSQxKSk7XG5mdW5jdGlvbiBmb3JtYXRNZXRhZGF0YU1lc3NhZ2VDaGFpbihjaGFpbiwgYWR2aXNlKSB7XG4gICAgdmFyIGV4cGFuZGVkID0gZXhwYW5kZWRNZXNzYWdlKGNoYWluLm1lc3NhZ2UsIGNoYWluLmNvbnRleHQpO1xuICAgIHZhciBuZXN0aW5nID0gY2hhaW4uc3ltYm9sID8gXCIgaW4gJ1wiICsgY2hhaW4uc3ltYm9sLm5hbWUgKyBcIidcIiA6ICcnO1xuICAgIHZhciBtZXNzYWdlID0gXCJcIiArIGV4cGFuZGVkICsgbmVzdGluZztcbiAgICB2YXIgcG9zaXRpb24gPSBjaGFpbi5wb3NpdGlvbjtcbiAgICB2YXIgbmV4dCA9IGNoYWluLm5leHQgP1xuICAgICAgICBmb3JtYXRNZXRhZGF0YU1lc3NhZ2VDaGFpbihjaGFpbi5uZXh0LCBhZHZpc2UpIDpcbiAgICAgICAgYWR2aXNlID8geyBtZXNzYWdlOiBhZHZpc2UgfSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlLCBwb3NpdGlvbjogcG9zaXRpb24sIG5leHQ6IG5leHQgPyBbbmV4dF0gOiB1bmRlZmluZWQgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1ldGFkYXRhRXJyb3IoZSwgY29udGV4dCkge1xuICAgIGlmIChpc01ldGFkYXRhRXJyb3IoZSkpIHtcbiAgICAgICAgLy8gUHJvZHVjZSBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBhbmQgbGVhdmluZyBlbm91Z2ggaW5mb3JtYXRpb24gaW4gdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgIC8vIHRvIHJlY292ZXIgdGhlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gdG8gZXZlbnR1YWxseSBwcm9kdWNlIGEgZGlhZ25vc3RpYyBlcnJvciBtZXNzYWdlLlxuICAgICAgICB2YXIgcG9zaXRpb24gPSBlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgY2hhaW4gPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkVycm9yIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxlIG9mICdcIiArIGNvbnRleHQubmFtZSArIFwiJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgbmV4dDogeyBtZXNzYWdlOiBlLm1lc3NhZ2UsIG5leHQ6IGUuY2hhaW4sIGNvbnRleHQ6IGUuY29udGV4dCwgc3ltYm9sOiBlLnN5bWJvbCB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhZHZpc2UgPSBlLmFkdmlzZSB8fCBtZXNzYWdlQWR2aXNlKGUubWVzc2FnZSwgZS5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZEVycm9yKGZvcm1hdE1ldGFkYXRhTWVzc2FnZUNoYWluKGNoYWluLCBhZHZpc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBb3RTdW1tYXJ5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW90U3VtbWFyeVJlc29sdmVyKGhvc3QsIHN0YXRpY1N5bWJvbENhY2hlKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsIG9ubHkgY29udGFpbiBTdGF0aWNTeW1ib2xzIHdpdGhvdXQgbWVtYmVycyFcbiAgICAgICAgdGhpcy5zdW1tYXJ5Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVkRmlsZVBhdGhzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOb3RlOiB0aGlzIHdpbGwgb25seSBjb250YWluIFN0YXRpY1N5bWJvbHMgd2l0aG91dCBtZW1iZXJzIVxuICAgICAgICB0aGlzLmltcG9ydEFzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtub3duRmlsZU5hbWVUb01vZHVsZU5hbWVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmlzTGlicmFyeUZpbGUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBzdHJpcCB0aGUgLm5nZmFjdG9yeS4gZmlsZSBwYXRoLFxuICAgICAgICAvLyBzbyB0aGlzIG1ldGhvZCBhbHNvIHdvcmtzIGZvciBnZW5lcmF0ZWQgZmlsZXNcbiAgICAgICAgLy8gKGZvciB3aGljaCBob3N0LmlzU291cmNlRmlsZSB3aWxsIGFsd2F5cyByZXR1cm4gZmFsc2UpLlxuICAgICAgICByZXR1cm4gIXRoaXMuaG9zdC5pc1NvdXJjZUZpbGUoc3RyaXBHZW5lcmF0ZWRGaWxlU3VmZml4KGZpbGVQYXRoKSk7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnRvU3VtbWFyeUZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVQYXRoLCByZWZlcnJpbmdTcmNGaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0LnRvU3VtbWFyeUZpbGVOYW1lKGZpbGVQYXRoLCByZWZlcnJpbmdTcmNGaWxlTmFtZSk7XG4gICAgfTtcbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmZyb21TdW1tYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZU5hbWUsIHJlZmVycmluZ0xpYkZpbGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3QuZnJvbVN1bW1hcnlGaWxlTmFtZShmaWxlTmFtZSwgcmVmZXJyaW5nTGliRmlsZU5hbWUpO1xuICAgIH07XG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgdmFyIHJvb3RTeW1ib2wgPSBzdGF0aWNTeW1ib2wubWVtYmVycy5sZW5ndGggP1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xDYWNoZS5nZXQoc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSkgOlxuICAgICAgICAgICAgc3RhdGljU3ltYm9sO1xuICAgICAgICB2YXIgc3VtbWFyeSA9IHRoaXMuc3VtbWFyeUNhY2hlLmdldChyb290U3ltYm9sKTtcbiAgICAgICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkU3VtbWFyeUZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgICAgIHN1bW1hcnkgPSB0aGlzLnN1bW1hcnlDYWNoZS5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHJvb3RTeW1ib2wgPT09IHN0YXRpY1N5bWJvbCAmJiBzdW1tYXJ5KSB8fCBudWxsO1xuICAgIH07XG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRTdW1tYXJ5RmlsZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3VtbWFyeUNhY2hlLmtleXMoKSkuZmlsdGVyKGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIHN5bWJvbC5maWxlUGF0aCA9PT0gZmlsZVBhdGg7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgc3RhdGljU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRBcy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZmlsZSBwYXRoIHRvIGEgbW9kdWxlIG5hbWUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBgaW1wb3J0YC5cbiAgICAgKi9cbiAgICBBb3RTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEtub3duTW9kdWxlTmFtZSA9IGZ1bmN0aW9uIChpbXBvcnRlZEZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtub3duRmlsZU5hbWVUb01vZHVsZU5hbWVzLmdldChpbXBvcnRlZEZpbGVQYXRoKSB8fCBudWxsO1xuICAgIH07XG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5hZGRTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdGhpcy5zdW1tYXJ5Q2FjaGUuc2V0KHN1bW1hcnkuc3ltYm9sLCBzdW1tYXJ5KTtcbiAgICB9O1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRTdW1tYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFzU3VtbWFyeSA9IHRoaXMubG9hZGVkRmlsZVBhdGhzLmdldChmaWxlUGF0aCk7XG4gICAgICAgIGlmIChoYXNTdW1tYXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNTdW1tYXJ5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNMaWJyYXJ5RmlsZShmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBzdW1tYXJ5RmlsZVBhdGggPSBzdW1tYXJ5RmlsZU5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBqc29uID0gdGhpcy5ob3N0LmxvYWRTdW1tYXJ5KHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN1bW1hcnkgZmlsZSBcIiArIHN1bW1hcnlGaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoYXNTdW1tYXJ5ID0ganNvbiAhPSBudWxsO1xuICAgICAgICB0aGlzLmxvYWRlZEZpbGVQYXRocy5zZXQoZmlsZVBhdGgsIGhhc1N1bW1hcnkpO1xuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgdmFyIF9hID0gZGVzZXJpYWxpemVTdW1tYXJpZXModGhpcy5zdGF0aWNTeW1ib2xDYWNoZSwgdGhpcywgZmlsZVBhdGgsIGpzb24pLCBtb2R1bGVOYW1lID0gX2EubW9kdWxlTmFtZSwgc3VtbWFyaWVzID0gX2Euc3VtbWFyaWVzLCBpbXBvcnRBcyA9IF9hLmltcG9ydEFzO1xuICAgICAgICAgICAgc3VtbWFyaWVzLmZvckVhY2goZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIF90aGlzLnN1bW1hcnlDYWNoZS5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9KTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rbm93bkZpbGVOYW1lVG9Nb2R1bGVOYW1lcy5zZXQoZmlsZVBhdGgsIG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1wb3J0QXMuZm9yRWFjaChmdW5jdGlvbiAoaW1wb3J0QXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbXBvcnRBcy5zZXQoaW1wb3J0QXMuc3ltYm9sLCBpbXBvcnRBcy5pbXBvcnRBcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzU3VtbWFyeTtcbiAgICB9O1xuICAgIHJldHVybiBBb3RTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjcmVhdGVBb3RVcmxSZXNvbHZlcihob3N0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzb2x2ZTogZnVuY3Rpb24gKGJhc2VQYXRoLCB1cmwpIHtcbiAgICAgICAgICAgIHZhciBmaWxlUGF0aCA9IGhvc3QucmVzb3VyY2VOYW1lVG9GaWxlTmFtZSh1cmwsIGJhc2VQYXRoKTtcbiAgICAgICAgICAgIGlmICghZmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIkNvdWxkbid0IHJlc29sdmUgcmVzb3VyY2UgXCIgKyB1cmwgKyBcIiBmcm9tIFwiICsgYmFzZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBb3RDb21waWxlciBiYXNlZCBvbiBvcHRpb25zIGFuZCBhIGhvc3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFvdENvbXBpbGVyKGNvbXBpbGVySG9zdCwgb3B0aW9ucywgZXJyb3JDb2xsZWN0b3IpIHtcbiAgICB2YXIgdHJhbnNsYXRpb25zID0gb3B0aW9ucy50cmFuc2xhdGlvbnMgfHwgJyc7XG4gICAgdmFyIHVybFJlc29sdmVyID0gY3JlYXRlQW90VXJsUmVzb2x2ZXIoY29tcGlsZXJIb3N0KTtcbiAgICB2YXIgc3ltYm9sQ2FjaGUgPSBuZXcgU3RhdGljU3ltYm9sQ2FjaGUoKTtcbiAgICB2YXIgc3VtbWFyeVJlc29sdmVyID0gbmV3IEFvdFN1bW1hcnlSZXNvbHZlcihjb21waWxlckhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICB2YXIgc3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICB2YXIgc3RhdGljUmVmbGVjdG9yID0gbmV3IFN0YXRpY1JlZmxlY3RvcihzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyLCBbXSwgW10sIGVycm9yQ29sbGVjdG9yKTtcbiAgICB2YXIgaHRtbFBhcnNlcjtcbiAgICBpZiAoISFvcHRpb25zLmVuYWJsZUl2eSkge1xuICAgICAgICAvLyBJdnkgaGFuZGxlcyBpMThuIGF0IHRoZSBjb21waWxlciBsZXZlbCBzbyB3ZSBtdXN0IHVzZSBhIHJlZ3VsYXIgcGFyc2VyXG4gICAgICAgIGh0bWxQYXJzZXIgPSBuZXcgSHRtbFBhcnNlcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaHRtbFBhcnNlciA9IG5ldyBJMThOSHRtbFBhcnNlcihuZXcgSHRtbFBhcnNlcigpLCB0cmFuc2xhdGlvbnMsIG9wdGlvbnMuaTE4bkZvcm1hdCwgb3B0aW9ucy5taXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgIH1cbiAgICB2YXIgY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICB1c2VKaXQ6IGZhbHNlLFxuICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IG9wdGlvbnMubWlzc2luZ1RyYW5zbGF0aW9uLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgIHN0cmljdEluamVjdGlvblBhcmFtZXRlcnM6IG9wdGlvbnMuc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyxcbiAgICB9KTtcbiAgICB2YXIgbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBjb21waWxlckhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgdmFyIGV4cHJlc3Npb25QYXJzZXIgPSBuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpO1xuICAgIHZhciBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgdmFyIHRtcGxQYXJzZXIgPSBuZXcgVGVtcGxhdGVQYXJzZXIoY29uZmlnLCBzdGF0aWNSZWZsZWN0b3IsIGV4cHJlc3Npb25QYXJzZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgaHRtbFBhcnNlciwgY29uc29sZSwgW10pO1xuICAgIHZhciByZXNvbHZlciA9IG5ldyBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihjb25maWcsIGh0bWxQYXJzZXIsIG5ldyBOZ01vZHVsZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBEaXJlY3RpdmVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgUGlwZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIHN1bW1hcnlSZXNvbHZlciwgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBub3JtYWxpemVyLCBjb25zb2xlLCBzeW1ib2xDYWNoZSwgc3RhdGljUmVmbGVjdG9yLCBlcnJvckNvbGxlY3Rvcik7XG4gICAgLy8gVE9ETyh2aWNiKTogZG8gbm90IHBhc3Mgb3B0aW9ucy5pMThuRm9ybWF0IGhlcmVcbiAgICB2YXIgdmlld0NvbXBpbGVyID0gbmV3IFZpZXdDb21waWxlcihzdGF0aWNSZWZsZWN0b3IpO1xuICAgIHZhciB0eXBlQ2hlY2tDb21waWxlciA9IG5ldyBUeXBlQ2hlY2tDb21waWxlcihvcHRpb25zLCBzdGF0aWNSZWZsZWN0b3IpO1xuICAgIHZhciBjb21waWxlciA9IG5ldyBBb3RDb21waWxlcihjb25maWcsIG9wdGlvbnMsIGNvbXBpbGVySG9zdCwgc3RhdGljUmVmbGVjdG9yLCByZXNvbHZlciwgdG1wbFBhcnNlciwgbmV3IFN0eWxlQ29tcGlsZXIodXJsUmVzb2x2ZXIpLCB2aWV3Q29tcGlsZXIsIHR5cGVDaGVja0NvbXBpbGVyLCBuZXcgTmdNb2R1bGVDb21waWxlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgSW5qZWN0YWJsZUNvbXBpbGVyKHN0YXRpY1JlZmxlY3RvciwgISFvcHRpb25zLmVuYWJsZUl2eSksIG5ldyBUeXBlU2NyaXB0RW1pdHRlcigpLCBzdW1tYXJ5UmVzb2x2ZXIsIHN5bWJvbFJlc29sdmVyKTtcbiAgICByZXR1cm4geyBjb21waWxlcjogY29tcGlsZXIsIHJlZmxlY3Rvcjogc3RhdGljUmVmbGVjdG9yIH07XG59XG5cbnZhciBTdW1tYXJ5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3VtbWFyeVJlc29sdmVyKCkge1xuICAgIH1cbiAgICByZXR1cm4gU3VtbWFyeVJlc29sdmVyO1xufSgpKTtcbnZhciBKaXRTdW1tYXJ5UmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSml0U3VtbWFyeVJlc29sdmVyKCkge1xuICAgICAgICB0aGlzLl9zdW1tYXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS50b1N1bW1hcnlGaWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gZmlsZU5hbWU7XG4gICAgfTtcbiAgICBKaXRTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmZyb21TdW1tYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lO1xuICAgIH07XG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3VtbWFyeSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1bW1hcmllcy5nZXQocmVmZXJlbmNlKSB8fCBudWxsO1xuICAgIH07XG4gICAgSml0U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0SW1wb3J0QXMgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfTtcbiAgICBKaXRTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEtub3duTW9kdWxlTmFtZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEppdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuYWRkU3VtbWFyeSA9IGZ1bmN0aW9uIChzdW1tYXJ5KSB7XG4gICAgICAgIHRoaXMuX3N1bW1hcmllcy5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIEppdFN1bW1hcnlSZXNvbHZlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgcmVmbGVjdG9yKSB7XG4gICAgdmFyIGN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChudWxsLCBudWxsLCBudWxsLCBuZXcgTWFwKCkpO1xuICAgIHZhciB2aXNpdG9yID0gbmV3IFN0YXRlbWVudEludGVycHJldGVyKHJlZmxlY3Rvcik7XG4gICAgdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgY3R4LmV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAoZXhwb3J0TmFtZSkge1xuICAgICAgICByZXN1bHRbZXhwb3J0TmFtZV0gPSBjdHgudmFycy5nZXQoZXhwb3J0TmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCB2YXJWYWx1ZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgIHZhciBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KHZhck5hbWVzW2ldLCB2YXJWYWx1ZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY2hpbGRDdHgpO1xuICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQudmFsdWUgOiBudWxsO1xufVxudmFyIF9FeGVjdXRpb25Db250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9FeGVjdXRpb25Db250ZXh0KHBhcmVudCwgaW5zdGFuY2UsIGNsYXNzTmFtZSwgdmFycykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy52YXJzID0gdmFycztcbiAgICAgICAgdGhpcy5leHBvcnRzID0gW107XG4gICAgfVxuICAgIF9FeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0V4ZWN1dGlvbkNvbnRleHQodGhpcywgdGhpcy5pbnN0YW5jZSwgdGhpcy5jbGFzc05hbWUsIG5ldyBNYXAoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0V4ZWN1dGlvbkNvbnRleHQ7XG59KCkpO1xudmFyIFJldHVyblZhbHVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJldHVyblZhbHVlO1xufSgpKTtcbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNDbGFzcyhfY2xhc3NTdG10LCBfY3R4LCBfdmlzaXRvcikge1xuICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3JzID0ge307XG4gICAgX2NsYXNzU3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikge1xuICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgIHByb3BlcnR5RGVzY3JpcHRvcnNbZ2V0dGVyLm5hbWVdID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKFtdLCBbXSwgZ2V0dGVyLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgX2NsYXNzU3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgcGFyYW1OYW1lcyA9IG1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1ttZXRob2QubmFtZV0gPSB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMocGFyYW1OYW1lcywgYXJncywgbWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGN0b3JQYXJhbU5hbWVzID0gX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgIHZhciBjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgIF9jbGFzc1N0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICBfdGhpc1tmaWVsZC5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKGN0b3JQYXJhbU5hbWVzLCBhcmdzLCBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgfTtcbiAgICB2YXIgc3VwZXJDbGFzcyA9IF9jbGFzc1N0bXQucGFyZW50ID8gX2NsYXNzU3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKF92aXNpdG9yLCBfY3R4KSA6IE9iamVjdDtcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5RGVzY3JpcHRvcnMpO1xuICAgIHJldHVybiBjdG9yO1xufVxudmFyIFN0YXRlbWVudEludGVycHJldGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlbWVudEludGVycHJldGVyKHJlZmxlY3Rvcikge1xuICAgICAgICB0aGlzLnJlZmxlY3RvciA9IHJlZmxlY3RvcjtcbiAgICB9XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLmRlYnVnQXN0ID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICByZXR1cm4gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gc3RtdC52YWx1ZSA/IHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIGN0eC5leHBvcnRzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdXJyQ3R4LnZhcnMuaGFzKGV4cHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyQ3R4LnZhcnMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyBleHByLm5hbWUpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JhcHBlZE5vZGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGludGVycHJldCBhIFdyYXBwZWROb2RlRXhwci4nKTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFR5cGVvZkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW50ZXJwcmV0IGEgVHlwZW9mRXhwcicpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIHZhck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3R4Lmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX0VSUk9SX1ZBUiQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjazpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX1NUQUNLX1ZBUiQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdXJyQ3R4LnZhcnMuaGFzKHZhck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJDdHgudmFycy5nZXQodmFyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyQ3R4ID0gY3VyckN0eC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgdmFyTmFtZSk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBpbmRleCA9IGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZWNlaXZlcltleHByLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY29uY2F0LmFwcGx5KHJlY2VpdmVyLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5zdWJzY3JpYmUoeyBuZXh0OiBhcmdzWzBdIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuYmluZC5hcHBseShyZWNlaXZlciwgX19zcHJlYWQoYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kIFwiICsgZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyW2V4cHIubmFtZV0uYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKHN0bXQuYXJncywgY3R4KTtcbiAgICAgICAgdmFyIGZuRXhwciA9IHN0bXQuZm47XG4gICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgY3R4Lmluc3RhbmNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseShjdHguaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBzdG10LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFJldHVyblZhbHVlKHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIGNsYXp6ID0gY3JlYXRlRHluYW1pY0NsYXNzKHN0bXQsIGN0eCwgdGhpcyk7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIGNsYXp6KTtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgY3R4LmV4cG9ydHMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RtdC5mYWxzZUNhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9FUlJPUl9WQVIkMiwgZSk7XG4gICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9TVEFDS19WQVIkMiwgZS5zdGFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRKU0RvY0NvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciBjbGF6eiA9IGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBuZXcgKGNsYXp6LmJpbmQuYXBwbHkoY2xhenosIF9fc3ByZWFkKFt2b2lkIDBdLCBhcmdzKSkpKCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TG9jYWxpemVkU3RyaW5nID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0b3IucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKGFzdC52YWx1ZSk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgaWYgKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmZhbHNlQ2FzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuICFhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBwYXJhbU5hbWVzID0gYXN0LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgcmV0dXJuIF9kZWNsYXJlRm4ocGFyYW1OYW1lcywgYXN0LnN0YXRlbWVudHMsIGN0eCwgdGhpcyk7XG4gICAgfTtcbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgcGFyYW1OYW1lcyA9IHN0bXQucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIGN0eC5leHBvcnRzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0Lmxocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgIHZhciByaHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfTtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgIT09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgfHwgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICsgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIC8gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAqIHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPD0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA+PSByaHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvciBcIiArIGFzdC5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyW2FzdC5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIHByb3AgPSBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcltwcm9wXTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4KTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHJlc3VsdFtlbnRyeS5rZXldID0gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1hRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRzLCBjdHgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RtdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgdmFsID0gc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZW1lbnRJbnRlcnByZXRlcjtcbn0oKSk7XG5mdW5jdGlvbiBfZGVjbGFyZUZuKHZhck5hbWVzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgYXJncywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKTtcbiAgICB9O1xufVxudmFyIENBVENIX0VSUk9SX1ZBUiQyID0gJ2Vycm9yJztcbnZhciBDQVRDSF9TVEFDS19WQVIkMiA9ICdzdGFjayc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW50ZXJuYWwgbW9kdWxlIG9mIHRoZSBBbmd1bGFyIGNvbXBpbGVyIHRoYXQgYmVnaW5zIHdpdGggY29tcG9uZW50IHR5cGVzLFxuICogZXh0cmFjdHMgdGVtcGxhdGVzLCBhbmQgZXZlbnR1YWxseSBwcm9kdWNlcyBhIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICogcmVhZHkgZm9yIGxpbmtpbmcgaW50byBhbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAc2VjdXJpdHkgIFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgZW50aXJlIHRlbXBsYXRlIGNvbWVzXG4gKiBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuIEF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGEgdGVtcGxhdGUgY291bGQgZXhwb3NlIHlvdXJcbiAqIGFwcGxpY2F0aW9uIHRvIFhTUyByaXNrcy4gIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAqL1xudmFyIEppdENvbXBpbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEppdENvbXBpbGVyKF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX3N1bW1hcnlSZXNvbHZlciwgX3JlZmxlY3RvciwgX2ppdEV2YWx1YXRvciwgX2NvbXBpbGVyQ29uZmlnLCBfY29uc29sZSwgZ2V0RXh0cmFOZ01vZHVsZVByb3ZpZGVycykge1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fc3VtbWFyeVJlc29sdmVyID0gX3N1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgICAgdGhpcy5faml0RXZhbHVhdG9yID0gX2ppdEV2YWx1YXRvcjtcbiAgICAgICAgdGhpcy5fY29tcGlsZXJDb25maWcgPSBfY29tcGlsZXJDb25maWc7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5nZXRFeHRyYU5nTW9kdWxlUHJvdmlkZXJzID0gZ2V0RXh0cmFOZ01vZHVsZVByb3ZpZGVycztcbiAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zaGFyZWRTdHlsZXNoZWV0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLl9hZGRlZEFvdFN1bW1hcmllcyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy5hc3NlcnRTeW5jKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzKG1vZHVsZVR5cGUsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy5hc3NlcnRTeW5jKHRoaXMuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzKG1vZHVsZVR5cGUsIHRydWUpKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmdldENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBzdW1tYXJ5ID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVTdW1tYXJ5KGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBzdW1tYXJ5LmNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUubG9hZEFvdFN1bW1hcmllcyA9IGZ1bmN0aW9uIChzdW1tYXJpZXMpIHtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHRoaXMuX2FkZEFvdFN1bW1hcmllcyhzdW1tYXJpZXMpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9hZGRBb3RTdW1tYXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2FkZGVkQW90U3VtbWFyaWVzLmhhcyhmbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRlZEFvdFN1bW1hcmllcy5hZGQoZm4pO1xuICAgICAgICB2YXIgc3VtbWFyaWVzID0gZm4oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdW1tYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN1bW1hcmllc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRBb3RTdW1tYXJpZXMoZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bW1hcnkgPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIuYWRkU3VtbWFyeSh7IHN5bWJvbDogc3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgbWV0YWRhdGE6IG51bGwsIHR5cGU6IHN1bW1hcnkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5oYXNBb3RTdW1tYXJ5ID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkocmVmKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fZmlsdGVySml0SWRlbnRpZmllcnMgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBpZHMubWFwKGZ1bmN0aW9uIChtb2QpIHsgcmV0dXJuIG1vZC5yZWZlcmVuY2U7IH0pLmZpbHRlcihmdW5jdGlvbiAocmVmKSB7IHJldHVybiAhX3RoaXMuaGFzQW90U3VtbWFyeShyZWYpOyB9KTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBTeW5jQXN5bmMudGhlbih0aGlzLl9sb2FkTW9kdWxlcyhtb2R1bGVUeXBlLCBpc1N5bmMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fY29tcGlsZUNvbXBvbmVudHMobW9kdWxlVHlwZSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBpbGVNb2R1bGUobW9kdWxlVHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFN5bmNBc3luYy50aGVuKHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBjb21wb25lbnRGYWN0b3JpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZUZhY3Rvcnk6IF90aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEZhY3RvcmllczogY29tcG9uZW50RmFjdG9yaWVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fbG9hZE1vZHVsZXMgPSBmdW5jdGlvbiAobWFpbk1vZHVsZSwgaXNTeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2FkaW5nID0gW107XG4gICAgICAgIHZhciBtYWluTmdNb2R1bGUgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobWFpbk1vZHVsZSk7XG4gICAgICAgIC8vIE5vdGU6IGZvciBydW50aW1lIGNvbXBpbGF0aW9uLCB3ZSB3YW50IHRvIHRyYW5zaXRpdmVseSBjb21waWxlIGFsbCBtb2R1bGVzLFxuICAgICAgICAvLyBzbyB3ZSBhbHNvIG5lZWQgdG8gbG9hZCB0aGUgZGVjbGFyZWQgZGlyZWN0aXZlcyAvIHBpcGVzIGZvciBhbGwgbmVzdGVkIG1vZHVsZXMuXG4gICAgICAgIHRoaXMuX2ZpbHRlckppdElkZW50aWZpZXJzKG1haW5OZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZE5nTW9kdWxlKSB7XG4gICAgICAgICAgICAvLyBnZXROZ01vZHVsZU1ldGFkYXRhIG9ubHkgcmV0dXJucyBudWxsIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaW4gaXMgbm90IGFuIE5nTW9kdWxlXG4gICAgICAgICAgICB2YXIgbW9kdWxlTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobmVzdGVkTmdNb2R1bGUpO1xuICAgICAgICAgICAgX3RoaXMuX2ZpbHRlckppdElkZW50aWZpZXJzKG1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmxvYWREaXJlY3RpdmVNZXRhZGF0YShtb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlLCByZWYsIGlzU3luYyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuX2ZpbHRlckppdElkZW50aWZpZXJzKG1vZHVsZU1ldGEuZGVjbGFyZWRQaXBlcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRPckxvYWRQaXBlTWV0YWRhdGEocmVmKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU3luY0FzeW5jLmFsbChsb2FkaW5nKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoIW5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldE5nTW9kdWxlTWV0YWRhdGEobW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICB2YXIgZXh0cmFQcm92aWRlcnMgPSB0aGlzLmdldEV4dHJhTmdNb2R1bGVQcm92aWRlcnMobW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB2YXIgb3V0cHV0Q3R4ID0gY3JlYXRlT3V0cHV0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUob3V0cHV0Q3R4LCBtb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycyk7XG4gICAgICAgICAgICBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9pbnRlcnByZXRPckppdChuZ01vZHVsZUppdFVybChtb2R1bGVNZXRhKSwgb3V0cHV0Q3R4LnN0YXRlbWVudHMpW2NvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGVGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmdNb2R1bGVGYWN0b3J5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtYWluTW9kdWxlLCBhbGxDb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICB2YXIgbW9kdWxlQnlKaXREaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciB0cmFuc0ppdE1vZHVsZXMgPSB0aGlzLl9maWx0ZXJKaXRJZGVudGlmaWVycyhuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMpO1xuICAgICAgICB0cmFuc0ppdE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2QpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbE1vZHVsZU1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kKTtcbiAgICAgICAgICAgIF90aGlzLl9maWx0ZXJKaXRJZGVudGlmaWVycyhsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJSZWYpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVCeUppdERpcmVjdGl2ZS5zZXQoZGlyUmVmLCBsb2NhbE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyUmVmKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlKGRpck1ldGEsIGxvY2FsTW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcG9uZW50RmFjdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29tcG9uZW50RmFjdG9yaWVzLnB1c2goZGlyTWV0YS5jb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNKaXRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxNb2R1bGVNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShsb2NhbE1vZCk7XG4gICAgICAgICAgICBfdGhpcy5fZmlsdGVySml0SWRlbnRpZmllcnMobG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcykuZm9yRWFjaChmdW5jdGlvbiAoZGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJSZWYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpck1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSBtb2R1bGVCeUppdERpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUsIG1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaGFzQW90U3VtbWFyeShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSBtb2R1bGVCeUppdERpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUuY29tcG9uZW50VHlwZSwgbW9kdWxlTWV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlKTsgfSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZUZvcih0eXBlKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb3RlOiBkb24ndCBjbGVhciB0aGUgX2FkZGVkQW90U3VtbWFyaWVzLCBhcyB0aGV5IGRvbid0IGNoYW5nZSFcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgIH07XG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wVHlwZSwgbmdNb2R1bGUpIHtcbiAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIG5vdCBwYXJ0IG9mIGFueSBOZ01vZHVsZSBvciB0aGUgbW9kdWxlIGhhcyBub3QgYmVlbiBpbXBvcnRlZCBpbnRvIHlvdXIgbW9kdWxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKTtcbiAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgY29tcE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGNvbXBUeXBlKTtcbiAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRNZXRhZGF0YShjb21wTWV0YSwgY29tcE1ldGEuY29tcG9uZW50RmFjdG9yeS52aWV3RGVmRmFjdG9yeSk7XG4gICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID1cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS50eXBlLCBob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSk7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLnNldChjb21wVHlwZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlKSB7XG4gICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZShmYWxzZSwgY29tcE1ldGEudHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGVtcGxhdGUuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wTWV0YSA9IHRlbXBsYXRlLmNvbXBNZXRhO1xuICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgb3V0cHV0Q29udGV4dCA9IGNyZWF0ZU91dHB1dENvbnRleHQoKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudFN0eWxlc2hlZXQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQob3V0cHV0Q29udGV4dCwgY29tcE1ldGEpO1xuICAgICAgICBjb21wTWV0YS50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXRNZXRhKSB7XG4gICAgICAgICAgICB2YXIgY29tcGlsZWRTdHlsZXNoZWV0ID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZVN0eWxlcyhjcmVhdGVPdXRwdXRDb250ZXh0KCksIGNvbXBNZXRhLCBzdHlsZXNoZWV0TWV0YSk7XG4gICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuc2V0KHN0eWxlc2hlZXRNZXRhLm1vZHVsZVVybCwgY29tcGlsZWRTdHlsZXNoZWV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIHZhciBwaXBlcyA9IHRlbXBsYXRlLm5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9wYXJzZVRlbXBsYXRlKGNvbXBNZXRhLCB0ZW1wbGF0ZS5uZ01vZHVsZSwgdGVtcGxhdGUuZGlyZWN0aXZlcyksIHBhcnNlZFRlbXBsYXRlID0gX2EudGVtcGxhdGUsIHVzZWRQaXBlcyA9IF9hLnBpcGVzO1xuICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KG91dHB1dENvbnRleHQsIGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgdmFyaWFibGUoY29tcG9uZW50U3R5bGVzaGVldC5zdHlsZXNWYXIpLCB1c2VkUGlwZXMpO1xuICAgICAgICB2YXIgZXZhbFJlc3VsdCA9IHRoaXMuX2ludGVycHJldE9ySml0KHRlbXBsYXRlSml0VXJsKHRlbXBsYXRlLm5nTW9kdWxlLnR5cGUsIHRlbXBsYXRlLmNvbXBNZXRhKSwgb3V0cHV0Q29udGV4dC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIHZpZXdDbGFzcyA9IGV2YWxSZXN1bHRbY29tcGlsZVJlc3VsdC52aWV3Q2xhc3NWYXJdO1xuICAgICAgICB2YXIgcmVuZGVyZXJUeXBlID0gZXZhbFJlc3VsdFtjb21waWxlUmVzdWx0LnJlbmRlcmVyVHlwZVZhcl07XG4gICAgICAgIHRlbXBsYXRlLmNvbXBpbGVkKHZpZXdDbGFzcywgcmVuZGVyZXJUeXBlKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZUlkZW50aWZpZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5vdGU6ICEgaXMgb2sgaGVyZSBhcyBjb21wb25lbnRzIGFsd2F5cyBoYXZlIGEgdGVtcGxhdGUuXG4gICAgICAgIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2VzID0gY29tcE1ldGEudGVtcGxhdGUucHJlc2VydmVXaGl0ZXNwYWNlcztcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVJZGVudGlmaWVycy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBwaXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLmh0bWxBc3QsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZS50eXBlLCBjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUpLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzKTtcbiAgICB9O1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXAsIGkpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRDb21waWxlUmVzdWx0ID0gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLmdldChkZXAubW9kdWxlVXJsKTtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRTdHlsZXNBcnIgPSBfdGhpcy5fcmVzb2x2ZUFuZEV2YWxTdHlsZXNDb21waWxlUmVzdWx0KG5lc3RlZENvbXBpbGVSZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgICAgICBkZXAuc2V0VmFsdWUobmVzdGVkU3R5bGVzQXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnByZXRPckppdChzaGFyZWRTdHlsZXNoZWV0Sml0VXJsKHJlc3VsdC5tZXRhLCB0aGlzLl9zaGFyZWRTdHlsZXNoZWV0Q291bnQrKyksIHJlc3VsdC5vdXRwdXRDdHguc3RhdGVtZW50cylbcmVzdWx0LnN0eWxlc1Zhcl07XG4gICAgfTtcbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2ludGVycHJldE9ySml0ID0gZnVuY3Rpb24gKHNvdXJjZVVybCwgc3RhdGVtZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgdGhpcy5fcmVmbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9qaXRFdmFsdWF0b3IuZXZhbHVhdGVTdGF0ZW1lbnRzKHNvdXJjZVVybCwgc3RhdGVtZW50cywgdGhpcy5fcmVmbGVjdG9yLCB0aGlzLl9jb21waWxlckNvbmZpZy5qaXREZXZNb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEppdENvbXBpbGVyO1xufSgpKTtcbnZhciBDb21waWxlZFRlbXBsYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVkVGVtcGxhdGUoaXNIb3N0LCBjb21wVHlwZSwgY29tcE1ldGEsIG5nTW9kdWxlLCBkaXJlY3RpdmVzKSB7XG4gICAgICAgIHRoaXMuaXNIb3N0ID0gaXNIb3N0O1xuICAgICAgICB0aGlzLmNvbXBUeXBlID0gY29tcFR5cGU7XG4gICAgICAgIHRoaXMuY29tcE1ldGEgPSBjb21wTWV0YTtcbiAgICAgICAgdGhpcy5uZ01vZHVsZSA9IG5nTW9kdWxlO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgQ29tcGlsZWRUZW1wbGF0ZS5wcm90b3R5cGUuY29tcGlsZWQgPSBmdW5jdGlvbiAodmlld0NsYXNzLCByZW5kZXJlclR5cGUpIHtcbiAgICAgICAgdGhpcy5fdmlld0NsYXNzID0gdmlld0NsYXNzO1xuICAgICAgICB0aGlzLmNvbXBNZXRhLmNvbXBvbmVudFZpZXdUeXBlLnNldERlbGVnYXRlKHZpZXdDbGFzcyk7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcmVuZGVyZXJUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBNZXRhLnJlbmRlcmVyVHlwZVtwcm9wXSA9IHJlbmRlcmVyVHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGU7XG59KCkpO1xuZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgaWRlbnRpZmllck5hbWUobWV0YS50eXBlKSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlT3V0cHV0Q29udGV4dCgpIHtcbiAgICB2YXIgaW1wb3J0RXhwciQxID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0RXhwcih7IG5hbWU6IGlkZW50aWZpZXJOYW1lKHN5bWJvbCksIG1vZHVsZU5hbWU6IG51bGwsIHJ1bnRpbWU6IHN5bWJvbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiB7IHN0YXRlbWVudHM6IFtdLCBnZW5GaWxlUGF0aDogJycsIGltcG9ydEV4cHI6IGltcG9ydEV4cHIkMSwgY29uc3RhbnRQb29sOiBuZXcgQ29uc3RhbnRQb29sKCkgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMgdGhhdCB0aGUgY29tcGlsZXIgbmVlZHMuXG4gKi9cbnZhciBDb21waWxlUmVmbGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVSZWZsZWN0b3IoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlUmVmbGVjdG9yO1xufSgpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgVXJsUmVzb2x2ZXJ9IHdpdGggbm8gcGFja2FnZSBwcmVmaXguXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgoKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcigpO1xufVxuZnVuY3Rpb24gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpIHtcbiAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKCcuJyk7XG59XG52YXIgVXJsUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXJsUmVzb2x2ZXJJbXBsKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgIGlmIChfcGFja2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IF9wYWNrYWdlUHJlZml4ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9wYWNrYWdlUHJlZml4ID0gX3BhY2thZ2VQcmVmaXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBgdXJsYCBnaXZlbiB0aGUgYGJhc2VVcmxgOlxuICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgKiAtIGlmIGB1cmxgIGlzIHJlbGF0aXZlICgncGF0aC90by9oZXJlJywgJy4vcGF0aC90by9oZXJlJyksIHRoZSByZXNvbHZlZCB1cmwgaXMgYSBjb21iaW5hdGlvbiBvZlxuICAgICAqIGBiYXNlVXJsYCBhbmQgYHVybGAsXG4gICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgKiByZXR1cm5lZCBhcyBpcyAoaWdub3JpbmcgdGhlIGBiYXNlVXJsYClcbiAgICAgKi9cbiAgICBVcmxSZXNvbHZlckltcGwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoYmFzZVVybCwgdXJsKSB7XG4gICAgICAgIHZhciByZXNvbHZlZFVybCA9IHVybDtcbiAgICAgICAgaWYgKGJhc2VVcmwgIT0gbnVsbCAmJiBiYXNlVXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc29sdmVkVXJsID0gX3Jlc29sdmVVcmwoYmFzZVVybCwgcmVzb2x2ZWRVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvbHZlZFBhcnRzID0gX3NwbGl0KHJlc29sdmVkVXJsKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuX3BhY2thZ2VQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggIT0gbnVsbCAmJiByZXNvbHZlZFBhcnRzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLysvLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIvXCIgKyBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFVybDtcbiAgICB9O1xuICAgIHJldHVybiBVcmxSZXNvbHZlckltcGw7XG59KCkpO1xuLyoqXG4gKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gKi9cbmZ1bmN0aW9uIGdldFVybFNjaGVtZSh1cmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBfc3BsaXQodXJsKTtcbiAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoW19Db21wb25lbnRJbmRleC5TY2hlbWVdKSB8fCAnJztcbn1cbi8vIFRoZSBjb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSBUcmFjZXVyOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90cmFjZXVyLWNvbXBpbGVyL2Jsb2IvOTUxMWMxZGFmYTk3MmJmMGRlMTIwMmE4YTg2M2JhZDAyZjBmOTVhOC9zcmMvcnVudGltZS91cmwuanNcbi8qKlxuICogQnVpbGRzIGEgVVJJIHN0cmluZyBmcm9tIGFscmVhZHktZW5jb2RlZCBwYXJ0cy5cbiAqXG4gKiBObyBlbmNvZGluZyBpcyBwZXJmb3JtZWQuICBBbnkgY29tcG9uZW50IG1heSBiZSBvbWl0dGVkIGFzIGVpdGhlciBudWxsIG9yXG4gKiB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIG9wdF9zY2hlbWUgVGhlIHNjaGVtZSBzdWNoIGFzICdodHRwJy5cbiAqIEBwYXJhbSBvcHRfdXNlckluZm8gVGhlIHVzZXIgbmFtZSBiZWZvcmUgdGhlICdAJy5cbiAqIEBwYXJhbSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gKiAgICAgVVJJLWVuY29kZWQuXG4gKiBAcGFyYW0gb3B0X3BvcnQgVGhlIHBvcnQgbnVtYmVyLlxuICogQHBhcmFtIG9wdF9wYXRoIFRoZSBwYXRoLCBhbHJlYWR5IFVSSS1lbmNvZGVkLiAgSWYgaXQgaXMgbm90XG4gKiAgICAgZW1wdHksIGl0IG11c3QgYmVnaW4gd2l0aCBhIHNsYXNoLlxuICogQHBhcmFtIG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gKiBAcGFyYW0gb3B0X2ZyYWdtZW50IFRoZSBVUkktZW5jb2RlZCBmcmFnbWVudCBpZGVudGlmaWVyLlxuICogQHJldHVybiBUaGUgZnVsbHkgY29tYmluZWQgVVJJLlxuICovXG5mdW5jdGlvbiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKG9wdF9zY2hlbWUsIG9wdF91c2VySW5mbywgb3B0X2RvbWFpbiwgb3B0X3BvcnQsIG9wdF9wYXRoLCBvcHRfcXVlcnlEYXRhLCBvcHRfZnJhZ21lbnQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgaWYgKG9wdF9zY2hlbWUgIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaChvcHRfc2NoZW1lICsgJzonKTtcbiAgICB9XG4gICAgaWYgKG9wdF9kb21haW4gIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaCgnLy8nKTtcbiAgICAgICAgaWYgKG9wdF91c2VySW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8gKyAnQCcpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKG9wdF9kb21haW4pO1xuICAgICAgICBpZiAob3B0X3BvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0LnB1c2goJzonICsgb3B0X3BvcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRfcGF0aCAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdF9xdWVyeURhdGEgIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaCgnPycgKyBvcHRfcXVlcnlEYXRhKTtcbiAgICB9XG4gICAgaWYgKG9wdF9mcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcjJyArIG9wdF9mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbignJyk7XG59XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICoge0BsaW5rIGh0dHA6Ly93d3cuZ2Jpdi5jb20vcHJvdG9jb2xzL3VyaS9yZmMvcmZjMzk4Ni5odG1sI1JGQzIyMzR9IHNheXNcbiAqIEFzIHRoZSBcImZpcnN0LW1hdGNoLXdpbnNcIiBhbGdvcml0aG0gaXMgaWRlbnRpY2FsIHRvIHRoZSBcImdyZWVkeVwiXG4gKiBkaXNhbWJpZ3VhdGlvbiBtZXRob2QgdXNlZCBieSBQT1NJWCByZWd1bGFyIGV4cHJlc3Npb25zLCBpdCBpcyBuYXR1cmFsIGFuZFxuICogY29tbW9ucGxhY2UgdG8gdXNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBwYXJzaW5nIHRoZSBwb3RlbnRpYWwgZml2ZVxuICogY29tcG9uZW50cyBvZiBhIFVSSSByZWZlcmVuY2UuXG4gKlxuICogVGhlIGZvbGxvd2luZyBsaW5lIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nLWRvd24gYVxuICogd2VsbC1mb3JtZWQgVVJJIHJlZmVyZW5jZSBpbnRvIGl0cyBjb21wb25lbnRzLlxuICpcbiAqIDxwcmU+XG4gKiBeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/XG4gKiAgMTIgICAgICAgICAgICAzICA0ICAgICAgICAgIDUgICAgICAgNiAgNyAgICAgICAgOCA5XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgbnVtYmVycyBpbiB0aGUgc2Vjb25kIGxpbmUgYWJvdmUgYXJlIG9ubHkgdG8gYXNzaXN0IHJlYWRhYmlsaXR5OyB0aGV5XG4gKiBpbmRpY2F0ZSB0aGUgcmVmZXJlbmNlIHBvaW50cyBmb3IgZWFjaCBzdWJleHByZXNzaW9uIChpLmUuLCBlYWNoIHBhaXJlZFxuICogcGFyZW50aGVzaXMpLiBXZSByZWZlciB0byB0aGUgdmFsdWUgbWF0Y2hlZCBmb3Igc3ViZXhwcmVzc2lvbiA8bj4gYXMgJDxuPi5cbiAqIEZvciBleGFtcGxlLCBtYXRjaGluZyB0aGUgYWJvdmUgZXhwcmVzc2lvbiB0b1xuICogPHByZT5cbiAqICAgICBodHRwOi8vd3d3Lmljcy51Y2kuZWR1L3B1Yi9pZXRmL3VyaS8jUmVsYXRlZFxuICogPC9wcmU+XG4gKiByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgc3ViZXhwcmVzc2lvbiBtYXRjaGVzOlxuICogPHByZT5cbiAqICAgICQxID0gaHR0cDpcbiAqICAgICQyID0gaHR0cFxuICogICAgJDMgPSAvL3d3dy5pY3MudWNpLmVkdVxuICogICAgJDQgPSB3d3cuaWNzLnVjaS5lZHVcbiAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS9cbiAqICAgICQ2ID0gPHVuZGVmaW5lZD5cbiAqICAgICQ3ID0gPHVuZGVmaW5lZD5cbiAqICAgICQ4ID0gI1JlbGF0ZWRcbiAqICAgICQ5ID0gUmVsYXRlZFxuICogPC9wcmU+XG4gKiB3aGVyZSA8dW5kZWZpbmVkPiBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tcG9uZW50IGlzIG5vdCBwcmVzZW50LCBhcyBpcyB0aGVcbiAqIGNhc2UgZm9yIHRoZSBxdWVyeSBjb21wb25lbnQgaW4gdGhlIGFib3ZlIGV4YW1wbGUuIFRoZXJlZm9yZSwgd2UgY2FuXG4gKiBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBmaXZlIGNvbXBvbmVudHMgYXNcbiAqIDxwcmU+XG4gKiAgICBzY2hlbWUgICAgPSAkMlxuICogICAgYXV0aG9yaXR5ID0gJDRcbiAqICAgIHBhdGggICAgICA9ICQ1XG4gKiAgICBxdWVyeSAgICAgPSAkN1xuICogICAgZnJhZ21lbnQgID0gJDlcbiAqIDwvcHJlPlxuICpcbiAqIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gaGFzIGJlZW4gbW9kaWZpZWQgc2xpZ2h0bHkgdG8gZXhwb3NlIHRoZVxuICogdXNlckluZm8sIGRvbWFpbiwgYW5kIHBvcnQgc2VwYXJhdGVseSBmcm9tIHRoZSBhdXRob3JpdHkuXG4gKiBUaGUgbW9kaWZpZWQgdmVyc2lvbiB5aWVsZHNcbiAqIDxwcmU+XG4gKiAgICAkMSA9IGh0dHAgICAgICAgICAgICAgIHNjaGVtZVxuICogICAgJDIgPSA8dW5kZWZpbmVkPiAgICAgICB1c2VySW5mbyAtXFxcbiAqICAgICQzID0gd3d3Lmljcy51Y2kuZWR1ICAgZG9tYWluICAgICB8IGF1dGhvcml0eVxuICogICAgJDQgPSA8dW5kZWZpbmVkPiAgICAgICBwb3J0ICAgICAtL1xuICogICAgJDUgPSAvcHViL2lldGYvdXJpLyAgICBwYXRoXG4gKiAgICAkNiA9IDx1bmRlZmluZWQ+ICAgICAgIHF1ZXJ5IHdpdGhvdXQgP1xuICogICAgJDcgPSBSZWxhdGVkICAgICAgICAgICBmcmFnbWVudCB3aXRob3V0ICNcbiAqIDwvcHJlPlxuICogQGludGVybmFsXG4gKi9cbnZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAnKD86JyArXG4gICAgJyhbXjovPyMuXSspJyArIC8vIHNjaGVtZSAtIGlnbm9yZSBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICAvLyB1c2VkIGJ5IG90aGVyIFVSTCBwYXJ0cyBzdWNoIGFzIDosXG4gICAgLy8gPywgLywgIywgYW5kIC5cbiAgICAnOik/JyArXG4gICAgJyg/Oi8vJyArXG4gICAgJyg/OihbXi8/I10qKUApPycgKyAvLyB1c2VySW5mb1xuICAgICcoW1xcXFx3XFxcXGRcXFxcLVxcXFx1MDEwMC1cXFxcdWZmZmYuJV0qKScgKyAvLyBkb21haW4gLSByZXN0cmljdCB0byBsZXR0ZXJzLFxuICAgIC8vIGRpZ2l0cywgZGFzaGVzLCBkb3RzLCBwZXJjZW50XG4gICAgLy8gZXNjYXBlcywgYW5kIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAnKD86OihbMC05XSspKT8nICsgLy8gcG9ydFxuICAgICcpPycgK1xuICAgICcoW14/I10rKT8nICsgLy8gcGF0aFxuICAgICcoPzpcXFxcPyhbXiNdKikpPycgKyAvLyBxdWVyeVxuICAgICcoPzojKC4qKSk/JyArIC8vIGZyYWdtZW50XG4gICAgJyQnKTtcbi8qKlxuICogVGhlIGluZGV4IG9mIGVhY2ggVVJJIGNvbXBvbmVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIG9mIGdvb2cudXJpLnV0aWxzLnNwbGl0LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIF9Db21wb25lbnRJbmRleDtcbihmdW5jdGlvbiAoX0NvbXBvbmVudEluZGV4KSB7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlNjaGVtZVwiXSA9IDFdID0gXCJTY2hlbWVcIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiVXNlckluZm9cIl0gPSAyXSA9IFwiVXNlckluZm9cIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiRG9tYWluXCJdID0gM10gPSBcIkRvbWFpblwiO1xuICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJQb3J0XCJdID0gNF0gPSBcIlBvcnRcIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUGF0aFwiXSA9IDVdID0gXCJQYXRoXCI7XG4gICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlF1ZXJ5RGF0YVwiXSA9IDZdID0gXCJRdWVyeURhdGFcIjtcbiAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiRnJhZ21lbnRcIl0gPSA3XSA9IFwiRnJhZ21lbnRcIjtcbn0pKF9Db21wb25lbnRJbmRleCB8fCAoX0NvbXBvbmVudEluZGV4ID0ge30pKTtcbi8qKlxuICogU3BsaXRzIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAqXG4gKiBFYWNoIGNvbXBvbmVudCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBjb21wb25lbnQgaW5kaWNlczsgZm9yIGV4YW1wbGU6XG4gKiA8cHJlPlxuICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICogPC9wcmU+XG4gKlxuICogQHBhcmFtIHVyaSBUaGUgVVJJIHN0cmluZyB0byBleGFtaW5lLlxuICogQHJldHVybiBFYWNoIGNvbXBvbmVudCBzdGlsbCBVUkktZW5jb2RlZC5cbiAqICAgICBFYWNoIGNvbXBvbmVudCB0aGF0IGlzIHByZXNlbnQgd2lsbCBjb250YWluIHRoZSBlbmNvZGVkIHZhbHVlLCB3aGVyZWFzXG4gKiAgICAgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcHJlc2VudCB3aWxsIGJlIHVuZGVmaW5lZCBvciBlbXB0eSwgZGVwZW5kaW5nXG4gKiAgICAgb24gdGhlIGJyb3dzZXIncyByZWd1bGFyIGV4cHJlc3Npb24gaW1wbGVtZW50YXRpb24uICBOZXZlciBudWxsLCBzaW5jZVxuICogICAgIGFyYml0cmFyeSBzdHJpbmdzIG1heSBzdGlsbCBsb29rIGxpa2UgcGF0aCBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gX3NwbGl0KHVyaSkge1xuICAgIHJldHVybiB1cmkubWF0Y2goX3NwbGl0UmUpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cbiAqXG4gKiBAcGFyYW0gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cbiAqIEByZXR1cm4gUGF0aCBjb21wb25lbnQgd2l0aCByZW1vdmVkIGRvdCBzZWdtZW50cy5cbiAqL1xuZnVuY3Rpb24gX3JlbW92ZURvdFNlZ21lbnRzKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PSAnLycpXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgdmFyIGxlYWRpbmdTbGFzaCA9IHBhdGhbMF0gPT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIHVwID0gMDtcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBzZWdtZW50cy5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbcG9zXTtcbiAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XG4gICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcuLic6XG4gICAgICAgICAgICAgICAgaWYgKG91dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXQucHVzaChzZWdtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVhZGluZ1NsYXNoID09ICcnKSB7XG4gICAgICAgIHdoaWxlICh1cC0tID4gMCkge1xuICAgICAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBvdXQucHVzaCgnLicpO1xuICAgIH1cbiAgICByZXR1cm4gbGVhZGluZ1NsYXNoICsgb3V0LmpvaW4oJy8nKSArIHRyYWlsaW5nU2xhc2g7XG59XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIHRoZSBwYXJ0cyBmcm9tIHNwbGl0IGFuZCBjYW5vbmljYWxpemVzIHRoZSBwYXRoIHBhcnRcbiAqIGFuZCB0aGVuIGpvaW5zIGFsbCB0aGUgcGFydHMuXG4gKi9cbmZ1bmN0aW9uIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cykge1xuICAgIHZhciBwYXRoID0gcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIHBhdGggPSBwYXRoID09IG51bGwgPyAnJyA6IF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbiAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgIHJldHVybiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguVXNlckluZm9dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRG9tYWluXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlBvcnRdLCBwYXRoLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUXVlcnlEYXRhXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkZyYWdtZW50XSk7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgVVJMLlxuICogQHBhcmFtIGJhc2UgVGhlIFVSTCBhY3RpbmcgYXMgdGhlIGJhc2UgVVJMLlxuICogQHBhcmFtIHRvIFRoZSBVUkwgdG8gcmVzb2x2ZS5cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIHBhcnRzID0gX3NwbGl0KGVuY29kZVVSSSh1cmwpKTtcbiAgICB2YXIgYmFzZVBhcnRzID0gX3NwbGl0KGJhc2UpO1xuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgaWYgKHBhdGggPT0gbnVsbClcbiAgICAgICAgcGF0aCA9ICcvJztcbiAgICB2YXIgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSkgKyBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHRyYWN0b3IoaG9zdCwgc3RhdGljU3ltYm9sUmVzb2x2ZXIsIG1lc3NhZ2VCdW5kbGUsIG1ldGFkYXRhUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xSZXNvbHZlciA9IHN0YXRpY1N5bWJvbFJlc29sdmVyO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdW5kbGUgPSBtZXNzYWdlQnVuZGxlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhUmVzb2x2ZXIgPSBtZXRhZGF0YVJlc29sdmVyO1xuICAgIH1cbiAgICBFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhyb290RmlsZXMsIHRoaXMuaG9zdCwgdGhpcy5zdGF0aWNTeW1ib2xSZXNvbHZlciwgdGhpcy5tZXRhZGF0YVJlc29sdmVyKSwgZmlsZXMgPSBfYS5maWxlcywgbmdNb2R1bGVzID0gX2EubmdNb2R1bGVzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIGZhbHNlKTsgfSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBNZXRhcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZpbGUuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gX3RoaXMubWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEgJiYgZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcE1ldGFzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wTWV0YXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcE1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgVVJMIHBvaW50cyB0byBlaXRoZXIgYW4gSFRNTCBvciBUUyBmaWxlIGRlcGVuZGluZyBvblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZSBmaWxlIGlzIHVzZWQgd2l0aCBgdGVtcGxhdGVVcmw6YCBvciBgdGVtcGxhdGU6YCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZVVybDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wTWV0YS50ZW1wbGF0ZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfX3NwcmVhZChfdGhpcy5tZXNzYWdlQnVuZGxlLnVwZGF0ZUZyb21UZW1wbGF0ZShodG1sLCB0ZW1wbGF0ZVVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50b1N0cmluZygpOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubWVzc2FnZUJ1bmRsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFeHRyYWN0b3IuY3JlYXRlID0gZnVuY3Rpb24gKGhvc3QsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgICAgIHZhciB1cmxSZXNvbHZlciA9IGNyZWF0ZUFvdFVybFJlc29sdmVyKGhvc3QpO1xuICAgICAgICB2YXIgc3ltYm9sQ2FjaGUgPSBuZXcgU3RhdGljU3ltYm9sQ2FjaGUoKTtcbiAgICAgICAgdmFyIHN1bW1hcnlSZXNvbHZlciA9IG5ldyBBb3RTdW1tYXJ5UmVzb2x2ZXIoaG9zdCwgc3ltYm9sQ2FjaGUpO1xuICAgICAgICB2YXIgc3RhdGljU3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoaG9zdCwgc3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgICAgIHZhciBzdGF0aWNSZWZsZWN0b3IgPSBuZXcgU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3RhdGljU3ltYm9sUmVzb2x2ZXIpO1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHsgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLCB1c2VKaXQ6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgbm9ybWFsaXplciA9IG5ldyBEaXJlY3RpdmVOb3JtYWxpemVyKHsgZ2V0OiBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBob3N0LmxvYWRSZXNvdXJjZSh1cmwpOyB9IH0sIHVybFJlc29sdmVyLCBodG1sUGFyc2VyLCBjb25maWcpO1xuICAgICAgICB2YXIgZWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gbmV3IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuICAgICAgICB2YXIgcmVzb2x2ZXIgPSBuZXcgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoY29uZmlnLCBodG1sUGFyc2VyLCBuZXcgTmdNb2R1bGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgRGlyZWN0aXZlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IFBpcGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBzdW1tYXJ5UmVzb2x2ZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgbm9ybWFsaXplciwgY29uc29sZSwgc3ltYm9sQ2FjaGUsIHN0YXRpY1JlZmxlY3Rvcik7XG4gICAgICAgIC8vIFRPRE8odmljYik6IGltcGxpY2l0IHRhZ3MgJiBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciBtZXNzYWdlQnVuZGxlID0gbmV3IE1lc3NhZ2VCdW5kbGUoaHRtbFBhcnNlciwgW10sIHt9LCBsb2NhbGUpO1xuICAgICAgICB2YXIgZXh0cmFjdG9yID0gbmV3IEV4dHJhY3Rvcihob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWVzc2FnZUJ1bmRsZSwgcmVzb2x2ZXIpO1xuICAgICAgICByZXR1cm4geyBleHRyYWN0b3I6IGV4dHJhY3Rvciwgc3RhdGljUmVmbGVjdG9yOiBzdGF0aWNSZWZsZWN0b3IgfTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRyYWN0b3I7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUHJvY2Vzc2VzIGBUYXJnZXRgcyB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBlcmZvcm1zIGEgYmluZGluZyBvcGVyYXRpb24sIHdoaWNoXG4gKiByZXR1cm5zIGFuIG9iamVjdCBzaW1pbGFyIHRvIFR5cGVTY3JpcHQncyBgdHMuVHlwZUNoZWNrZXJgIHRoYXQgY29udGFpbnMga25vd2xlZGdlIGFib3V0IHRoZVxuICogdGFyZ2V0LlxuICovXG52YXIgUjNUYXJnZXRCaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUjNUYXJnZXRCaW5kZXIoZGlyZWN0aXZlTWF0Y2hlcikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIgPSBkaXJlY3RpdmVNYXRjaGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgYmluZGluZyBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGBUYXJnZXRgIGFuZCByZXR1cm4gYSBgQm91bmRUYXJnZXRgIHdoaWNoIGNvbnRhaW5zXG4gICAgICogbWV0YWRhdGEgYWJvdXQgdGhlIHR5cGVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIFIzVGFyZ2V0QmluZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBoYW5kbGUgdGFyZ2V0cyB3aGljaCBjb250YWluIHRoaW5ncyBsaWtlIEhvc3RCaW5kaW5ncywgZXRjLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaW5kaW5nIHdpdGhvdXQgYSB0ZW1wbGF0ZSBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0LCBwYXJzZSB0aGUgdGVtcGxhdGUgaW50byBhIGBTY29wZWAgc3RydWN0dXJlLiBUaGlzIG9wZXJhdGlvbiBjYXB0dXJlcyB0aGUgc3ludGFjdGljXG4gICAgICAgIC8vIHNjb3BlcyBpbiB0aGUgdGVtcGxhdGUgYW5kIG1ha2VzIHRoZW0gYXZhaWxhYmxlIGZvciBsYXRlciB1c2UuXG4gICAgICAgIHZhciBzY29wZSA9IFNjb3BlLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSk7XG4gICAgICAgIC8vIE5leHQsIHBlcmZvcm0gZGlyZWN0aXZlIG1hdGNoaW5nIG9uIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUgYERpcmVjdGl2ZUJpbmRlcmAuIFRoaXMgcmV0dXJuczpcbiAgICAgICAgLy8gICAtIGRpcmVjdGl2ZXM6IE1hcCBvZiBub2RlcyAoZWxlbWVudHMgJiBuZy10ZW1wbGF0ZXMpIHRvIHRoZSBkaXJlY3RpdmVzIG9uIHRoZW0uXG4gICAgICAgIC8vICAgLSBiaW5kaW5nczogTWFwIG9mIGlucHV0cywgb3V0cHV0cywgYW5kIGF0dHJpYnV0ZXMgdG8gdGhlIGRpcmVjdGl2ZS9lbGVtZW50IHRoYXQgY2xhaW1zXG4gICAgICAgIC8vICAgICB0aGVtLiBUT0RPKGFseGh1Yik6IGhhbmRsZSBtdWx0aXBsZSBkaXJlY3RpdmVzIGNsYWltaW5nIGFuIGlucHV0L291dHB1dC9ldGMuXG4gICAgICAgIC8vICAgLSByZWZlcmVuY2VzOiBNYXAgb2YgI3JlZmVyZW5jZXMgdG8gdGhlaXIgdGFyZ2V0cy5cbiAgICAgICAgdmFyIF9hID0gRGlyZWN0aXZlQmluZGVyLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSwgdGhpcy5kaXJlY3RpdmVNYXRjaGVyKSwgZGlyZWN0aXZlcyA9IF9hLmRpcmVjdGl2ZXMsIGJpbmRpbmdzID0gX2EuYmluZGluZ3MsIHJlZmVyZW5jZXMgPSBfYS5yZWZlcmVuY2VzO1xuICAgICAgICAvLyBGaW5hbGx5LCBydW4gdGhlIFRlbXBsYXRlQmluZGVyIHRvIGJpbmQgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBhbmQgb3RoZXIgZW50aXRpZXMgd2l0aGluIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gVGhpcyBleHRyYWN0cyBhbGwgdGhlIG1ldGFkYXRhIHRoYXQgZG9lc24ndCBkZXBlbmQgb24gZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICB2YXIgX2IgPSBUZW1wbGF0ZUJpbmRlci5hcHBseSh0YXJnZXQudGVtcGxhdGUsIHNjb3BlKSwgZXhwcmVzc2lvbnMgPSBfYi5leHByZXNzaW9ucywgc3ltYm9scyA9IF9iLnN5bWJvbHMsIG5lc3RpbmdMZXZlbCA9IF9iLm5lc3RpbmdMZXZlbCwgdXNlZFBpcGVzID0gX2IudXNlZFBpcGVzO1xuICAgICAgICByZXR1cm4gbmV3IFIzQm91bmRUYXJnZXQodGFyZ2V0LCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcywgZXhwcmVzc2lvbnMsIHN5bWJvbHMsIG5lc3RpbmdMZXZlbCwgdXNlZFBpcGVzKTtcbiAgICB9O1xuICAgIHJldHVybiBSM1RhcmdldEJpbmRlcjtcbn0oKSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiaW5kaW5nIHNjb3BlIHdpdGhpbiBhIHRlbXBsYXRlLlxuICpcbiAqIEFueSB2YXJpYWJsZXMsIHJlZmVyZW5jZXMsIG9yIG90aGVyIG5hbWVkIGVudGl0aWVzIGRlY2xhcmVkIHdpdGhpbiB0aGUgdGVtcGxhdGUgd2lsbFxuICogYmUgY2FwdHVyZWQgYW5kIGF2YWlsYWJsZSBieSBuYW1lIGluIGBuYW1lZEVudGl0aWVzYC4gQWRkaXRpb25hbGx5LCBjaGlsZCB0ZW1wbGF0ZXMgd2lsbFxuICogYmUgYW5hbHl6ZWQgYW5kIGhhdmUgdGhlaXIgY2hpbGQgYFNjb3BlYHMgYXZhaWxhYmxlIGluIGBjaGlsZFNjb3Blc2AuXG4gKi9cbnZhciBTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY29wZShwYXJlbnRTY29wZSkge1xuICAgICAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lZCBtZW1iZXJzIG9mIHRoZSBgU2NvcGVgLCBzdWNoIGFzIGBSZWZlcmVuY2VgcyBvciBgVmFyaWFibGVgcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZWRFbnRpdGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoaWxkIGBTY29wZWBzIGZvciBpbW1lZGlhdGVseSBuZXN0ZWQgYFRlbXBsYXRlYHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgKGVpdGhlciBhcyBhIGBUZW1wbGF0ZWAgc3ViLXRlbXBsYXRlIHdpdGggdmFyaWFibGVzLCBvciBhIHBsYWluIGFycmF5IG9mXG4gICAgICogdGVtcGxhdGUgYE5vZGVgcykgYW5kIGNvbnN0cnVjdCBpdHMgYFNjb3BlYC5cbiAgICAgKi9cbiAgICBTY29wZS5hcHBseSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSBuZXcgU2NvcGUoKTtcbiAgICAgICAgc2NvcGUuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIHByb2Nlc3MgdGhlIHRlbXBsYXRlIGFuZCBwb3B1bGF0ZSB0aGUgYFNjb3BlYC5cbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuaW5nZXN0ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZXMgb24gYW4gPG5nLXRlbXBsYXRlPiBhcmUgZGVmaW5lZCBpbiB0aGUgaW5uZXIgc2NvcGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMudmlzaXRWYXJpYWJsZShub2RlKTsgfSk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBub2RlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBvdmVyYXJjaGluZyBgVGVtcGxhdGVgIGluc3RhbmNlLCBzbyBwcm9jZXNzIHRoZSBub2RlcyBkaXJlY3RseS5cbiAgICAgICAgICAgIHRlbXBsYXRlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGBFbGVtZW50YHMgaW4gdGhlIHRlbXBsYXRlIG1heSBoYXZlIGBSZWZlcmVuY2VgcyB3aGljaCBhcmUgY2FwdHVyZWQgaW4gdGhlIHNjb3BlLlxuICAgICAgICBlbGVtZW50LnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMudmlzaXRSZWZlcmVuY2Uobm9kZSk7IH0pO1xuICAgICAgICAvLyBSZWN1cnNlIGludG8gdGhlIGBFbGVtZW50YCdzIGNoaWxkcmVuLlxuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdFRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlZmVyZW5jZXMgb24gYSA8bmctdGVtcGxhdGU+IGFyZSBkZWZpbmVkIGluIHRoZSBvdXRlciBzY29wZSwgc28gY2FwdHVyZSB0aGVtIGJlZm9yZVxuICAgICAgICAvLyBwcm9jZXNzaW5nIHRoZSB0ZW1wbGF0ZSdzIGNoaWxkIHNjb3BlLlxuICAgICAgICB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnZpc2l0UmVmZXJlbmNlKG5vZGUpOyB9KTtcbiAgICAgICAgLy8gTmV4dCwgY3JlYXRlIGFuIGlubmVyIHNjb3BlIGFuZCBwcm9jZXNzIHRoZSB0ZW1wbGF0ZSB3aXRoaW4gaXQuXG4gICAgICAgIHZhciBzY29wZSA9IG5ldyBTY29wZSh0aGlzKTtcbiAgICAgICAgc2NvcGUuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5jaGlsZFNjb3Blcy5zZXQodGVtcGxhdGUsIHNjb3BlKTtcbiAgICB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHZhcmlhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkuXG4gICAgICAgIHRoaXMubWF5YmVEZWNsYXJlKHZhcmlhYmxlKTtcbiAgICB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gRGVjbGFyZSB0aGUgdmFyaWFibGUgaWYgaXQncyBub3QgYWxyZWFkeS5cbiAgICAgICAgdGhpcy5tYXliZURlY2xhcmUocmVmZXJlbmNlKTtcbiAgICB9O1xuICAgIC8vIFVudXNlZCB2aXNpdG9ycy5cbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgfTtcbiAgICBTY29wZS5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0Qm91bmRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkgeyB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0VGV4dEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7IH07XG4gICAgU2NvcGUucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSkgeyB9O1xuICAgIFNjb3BlLnByb3RvdHlwZS5tYXliZURlY2xhcmUgPSBmdW5jdGlvbiAodGhpbmcpIHtcbiAgICAgICAgLy8gRGVjbGFyZSBzb21ldGhpbmcgd2l0aCBhIG5hbWUsIGFzIGxvbmcgYXMgdGhhdCBuYW1lIGlzbid0IHRha2VuLlxuICAgICAgICBpZiAoIXRoaXMubmFtZWRFbnRpdGllcy5oYXModGhpbmcubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZWRFbnRpdGllcy5zZXQodGhpbmcubmFtZSwgdGhpbmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb29rIHVwIGEgdmFyaWFibGUgd2l0aGluIHRoaXMgYFNjb3BlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIHJlY3Vyc2UgaW50byBhIHBhcmVudCBgU2NvcGVgIGlmIGl0J3MgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIFNjb3BlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lZEVudGl0aWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gRm91bmQgaW4gdGhlIGxvY2FsIHNjb3BlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRFbnRpdGllcy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wYXJlbnRTY29wZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBOb3QgaW4gdGhlIGxvY2FsIHNjb3BlLCBidXQgdGhlcmUncyBhIHBhcmVudCBzY29wZSBzbyBjaGVjayB0aGVyZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjb3BlLmxvb2t1cChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF0IHRoZSB0b3AgbGV2ZWwgYW5kIGl0IHdhc24ndCBmb3VuZC5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoaWxkIHNjb3BlIGZvciBhIGBUZW1wbGF0ZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBhbHdheXMgYmUgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBTY29wZS5wcm90b3R5cGUuZ2V0Q2hpbGRTY29wZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5jaGlsZFNjb3Blcy5nZXQodGVtcGxhdGUpO1xuICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvcjogY2hpbGQgc2NvcGUgZm9yIFwiICsgdGVtcGxhdGUgKyBcIiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBTY29wZTtcbn0oKSk7XG4vKipcbiAqIFByb2Nlc3NlcyBhIHRlbXBsYXRlIGFuZCBtYXRjaGVzIGRpcmVjdGl2ZXMgb24gbm9kZXMgKGVsZW1lbnRzIGFuZCB0ZW1wbGF0ZXMpLlxuICpcbiAqIFVzdWFsbHkgdXNlZCB2aWEgdGhlIHN0YXRpYyBgYXBwbHkoKWAgbWV0aG9kLlxuICovXG52YXIgRGlyZWN0aXZlQmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZUJpbmRlcihtYXRjaGVyLCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcykge1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSAobGlzdCBvZiBgTm9kZWBzKSBhbmQgcGVyZm9ybSBkaXJlY3RpdmUgbWF0Y2hpbmcgYWdhaW5zdCBlYWNoIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUgdGhlIGxpc3Qgb2YgdGVtcGxhdGUgYE5vZGVgcyB0byBtYXRjaCAocmVjdXJzaXZlbHkpLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rvck1hdGNoZXIgYSBgU2VsZWN0b3JNYXRjaGVyYCBjb250YWluaW5nIHRoZSBkaXJlY3RpdmVzIHRoYXQgYXJlIGluIHNjb3BlIGZvclxuICAgICAqIHRoaXMgdGVtcGxhdGUuXG4gICAgICogQHJldHVybnMgdGhyZWUgbWFwcyB3aGljaCBjb250YWluIGluZm9ybWF0aW9uIGFib3V0IGRpcmVjdGl2ZXMgaW4gdGhlIHRlbXBsYXRlOiB0aGVcbiAgICAgKiBgZGlyZWN0aXZlc2AgbWFwIHdoaWNoIGxpc3RzIGRpcmVjdGl2ZXMgbWF0Y2hlZCBvbiBlYWNoIG5vZGUsIHRoZSBgYmluZGluZ3NgIG1hcCB3aGljaFxuICAgICAqIGluZGljYXRlcyB3aGljaCBkaXJlY3RpdmVzIGNsYWltZWQgd2hpY2ggYmluZGluZ3MgKGlucHV0cywgb3V0cHV0cywgZXRjKSwgYW5kIHRoZSBgcmVmZXJlbmNlc2BcbiAgICAgKiBtYXAgd2hpY2ggcmVzb2x2ZXMgI3JlZmVyZW5jZXMgKGBSZWZlcmVuY2Vgcykgd2l0aGluIHRoZSB0ZW1wbGF0ZSB0byB0aGUgbmFtZWQgZGlyZWN0aXZlIG9yXG4gICAgICogdGVtcGxhdGUgbm9kZS5cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVCaW5kZXIuYXBwbHkgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHNlbGVjdG9yTWF0Y2hlcikge1xuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgcmVmZXJlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgRGlyZWN0aXZlQmluZGVyKHNlbGVjdG9yTWF0Y2hlciwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMpO1xuICAgICAgICBtYXRjaGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB7IGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMsIGJpbmRpbmdzOiBiaW5kaW5ncywgcmVmZXJlbmNlczogcmVmZXJlbmNlcyB9O1xuICAgIH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS5pbmdlc3QgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGVtcGxhdGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoZWxlbWVudC5uYW1lLCBlbGVtZW50KTtcbiAgICB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoJ25nLXRlbXBsYXRlJywgdGVtcGxhdGUpO1xuICAgIH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnRPclRlbXBsYXRlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpcnN0LCBkZXRlcm1pbmUgdGhlIEhUTUwgc2hhcGUgb2YgdGhlIG5vZGUgZm9yIHRoZSBwdXJwb3NlIG9mIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAgICAgICAgLy8gRG8gdGhpcyBieSBidWlsZGluZyB1cCBhIGBDc3NTZWxlY3RvcmAgZm9yIHRoZSBub2RlLlxuICAgICAgICB2YXIgY3NzU2VsZWN0b3IgPSBjcmVhdGVDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgZ2V0QXR0cnNGb3JEaXJlY3RpdmVNYXRjaGluZyhub2RlKSk7XG4gICAgICAgIC8vIE5leHQsIHVzZSB0aGUgYFNlbGVjdG9yTWF0Y2hlcmAgdG8gZ2V0IHRoZSBsaXN0IG9mIGRpcmVjdGl2ZXMgb24gdGhlIG5vZGUuXG4gICAgICAgIHZhciBkaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgZnVuY3Rpb24gKF8sIGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7IH0pO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuc2V0KG5vZGUsIGRpcmVjdGl2ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBhcmUgY3JlYXRlZCBvbiB0aGlzIG5vZGUuXG4gICAgICAgIG5vZGUucmVmZXJlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBkaXJUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBleHByZXNzaW9uIGlzIGVtcHR5LCB0aGVuIGl0IG1hdGNoZXMgdGhlIFwicHJpbWFyeVwiIGRpcmVjdGl2ZSBvbiB0aGUgbm9kZVxuICAgICAgICAgICAgLy8gKGlmIHRoZXJlIGlzIG9uZSkuIE90aGVyd2lzZSBpdCBtYXRjaGVzIHRoZSBob3N0IG5vZGUgaXRzZWxmIChlaXRoZXIgYW4gZWxlbWVudCBvclxuICAgICAgICAgICAgLy8gPG5nLXRlbXBsYXRlPiBub2RlKS5cbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSByZWZlcmVuY2UgdG8gYSBjb21wb25lbnQgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgICAgICAgIGRpclRhcmdldCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXIuaXNDb21wb25lbnQ7IH0pIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhIHJlZmVyZW5jZSB0byBhIGRpcmVjdGl2ZSBleHBvcnRlZCB2aWEgZXhwb3J0QXMuXG4gICAgICAgICAgICAgICAgZGlyVGFyZ2V0ID1cbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5leHBvcnRBcyAhPT0gbnVsbCAmJiBkaXIuZXhwb3J0QXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlID09PSByZWYudmFsdWU7IH0pOyB9KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIG1hdGNoaW5nIGRpcmVjdGl2ZSB3YXMgZm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKGRpclRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtYXRjaGluZyBkaXJlY3RpdmUgd2FzIGZvdW5kIC0gdGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIGFuIHVua25vd24gdGFyZ2V0LiBMZWF2ZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyB1bm1hcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlZmVyZW5jZSBwb2ludHMgdG8gYSBkaXJlY3RpdmUuXG4gICAgICAgICAgICAgICAgX3RoaXMucmVmZXJlbmNlcy5zZXQocmVmLCB7IGRpcmVjdGl2ZTogZGlyVGFyZ2V0LCBub2RlOiBub2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIHRoZSBub2RlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWZlcmVuY2VzLnNldChyZWYsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNldEF0dHJpYnV0ZUJpbmRpbmcgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBpb1R5cGUpIHtcbiAgICAgICAgICAgIHZhciBkaXIgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gZGlyW2lvVHlwZV0uaGFzT3duUHJvcGVydHkoYXR0cmlidXRlLm5hbWUpOyB9KTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gZGlyICE9PSB1bmRlZmluZWQgPyBkaXIgOiBub2RlO1xuICAgICAgICAgICAgX3RoaXMuYmluZGluZ3Muc2V0KGF0dHJpYnV0ZSwgYmluZGluZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vZGUgaW5wdXRzIChib3VuZCBhdHRyaWJ1dGVzKSBhbmQgdGV4dCBhdHRyaWJ1dGVzIGNhbiBiZSBib3VuZCB0byBhblxuICAgICAgICAvLyBpbnB1dCBvbiBhIGRpcmVjdGl2ZS5cbiAgICAgICAgbm9kZS5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZUJpbmRpbmcoaW5wdXQsICdpbnB1dHMnKTsgfSk7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGF0dHIsICdpbnB1dHMnKTsgfSk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG5vZGUudGVtcGxhdGVBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGF0dHIsICdpbnB1dHMnKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZSBvdXRwdXRzIChib3VuZCBldmVudHMpIGNhbiBiZSBib3VuZCB0byBhbiBvdXRwdXQgb24gYSBkaXJlY3RpdmUuXG4gICAgICAgIG5vZGUub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZUJpbmRpbmcob3V0cHV0LCAnb3V0cHV0cycpOyB9KTtcbiAgICAgICAgLy8gUmVjdXJzZSBpbnRvIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvLyBVbnVzZWQgdmlzaXRvcnMuXG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZSkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdFRleHRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7IH07XG4gICAgRGlyZWN0aXZlQmluZGVyLnByb3RvdHlwZS52aXNpdEJvdW5kQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZEV2ZW50ID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZU9yRXZlbnQgPSBmdW5jdGlvbiAobm9kZSkgeyB9O1xuICAgIERpcmVjdGl2ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBEaXJlY3RpdmVCaW5kZXIucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSkgeyB9O1xuICAgIHJldHVybiBEaXJlY3RpdmVCaW5kZXI7XG59KCkpO1xuLyoqXG4gKiBQcm9jZXNzZXMgYSB0ZW1wbGF0ZSBhbmQgZXh0cmFjdCBtZXRhZGF0YSBhYm91dCBleHByZXNzaW9ucyBhbmQgc3ltYm9scyB3aXRoaW4uXG4gKlxuICogVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGUgYERpcmVjdGl2ZUJpbmRlcmAgdGhhdCBkb2Vzbid0IHJlcXVpcmUga25vd2xlZGdlIG9mIGRpcmVjdGl2ZXMgbWF0Y2hlZFxuICogd2l0aGluIHRoZSB0ZW1wbGF0ZSBpbiBvcmRlciB0byBvcGVyYXRlLlxuICpcbiAqIEV4cHJlc3Npb25zIGFyZSB2aXNpdGVkIGJ5IHRoZSBzdXBlcmNsYXNzIGBSZWN1cnNpdmVBc3RWaXNpdG9yYCwgd2l0aCBjdXN0b20gbG9naWMgcHJvdmlkZWRcbiAqIGJ5IG92ZXJyaWRkZW4gbWV0aG9kcyBmcm9tIHRoYXQgdmlzaXRvci5cbiAqL1xudmFyIFRlbXBsYXRlQmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZUJpbmRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUJpbmRlcihiaW5kaW5ncywgc3ltYm9scywgdXNlZFBpcGVzLCBuZXN0aW5nTGV2ZWwsIHNjb3BlLCB0ZW1wbGF0ZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgX3RoaXMuc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgICAgIF90aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICAgICAgX3RoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICAgICAgICBfdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICBfdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICBfdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICBfdGhpcy5waXBlc1VzZWQgPSBbXTtcbiAgICAgICAgLy8gU2F2ZSBhIGJpdCBvZiBwcm9jZXNzaW5nIHRpbWUgYnkgY29uc3RydWN0aW5nIHRoaXMgY2xvc3VyZSBpbiBhZHZhbmNlLlxuICAgICAgICBfdGhpcy52aXNpdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgZGVmaW5lZCB0byByZWNvbmNpbGUgdGhlIHR5cGUgb2YgVGVtcGxhdGVCaW5kZXIgc2luY2UgYm90aFxuICAgIC8vIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgYW5kIFZpc2l0b3IgZGVmaW5lIHRoZSB2aXNpdCgpIG1ldGhvZCBpbiB0aGVpclxuICAgIC8vIGludGVyZmFjZXMuXG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1QpIHtcbiAgICAgICAgICAgIG5vZGUudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgYW5kIGV4dHJhY3QgbWV0YWRhdGEgYWJvdXQgZXhwcmVzc2lvbnMgYW5kIHN5bWJvbHMgd2l0aGluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHRoZSBub2RlcyBvZiB0aGUgdGVtcGxhdGUgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSBzY29wZSB0aGUgYFNjb3BlYCBvZiB0aGUgdGVtcGxhdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHRocmVlIG1hcHMgd2hpY2ggY29udGFpbiBtZXRhZGF0YSBhYm91dCB0aGUgdGVtcGxhdGU6IGBleHByZXNzaW9uc2Agd2hpY2ggaW50ZXJwcmV0c1xuICAgICAqIHNwZWNpYWwgYEFTVGAgbm9kZXMgaW4gZXhwcmVzc2lvbnMgYXMgcG9pbnRpbmcgdG8gcmVmZXJlbmNlcyBvciB2YXJpYWJsZXMgZGVjbGFyZWQgd2l0aGluIHRoZVxuICAgICAqIHRlbXBsYXRlLCBgc3ltYm9sc2Agd2hpY2ggbWFwcyB0aG9zZSB2YXJpYWJsZXMgYW5kIHJlZmVyZW5jZXMgdG8gdGhlIG5lc3RlZCBgVGVtcGxhdGVgIHdoaWNoXG4gICAgICogZGVjbGFyZXMgdGhlbSwgaWYgYW55LCBhbmQgYG5lc3RpbmdMZXZlbGAgd2hpY2ggYXNzb2NpYXRlcyBlYWNoIGBUZW1wbGF0ZWAgd2l0aCBhIGludGVnZXJcbiAgICAgKiBuZXN0aW5nIGxldmVsIChob3cgbWFueSBsZXZlbHMgZGVlcCB3aXRoaW4gdGhlIHRlbXBsYXRlIHN0cnVjdHVyZSB0aGUgYFRlbXBsYXRlYCBpcyksIHN0YXJ0aW5nXG4gICAgICogYXQgMS5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUJpbmRlci5hcHBseSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgc3ltYm9scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIG5lc3RpbmdMZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHVzZWRQaXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gVGhlIHRvcC1sZXZlbCB0ZW1wbGF0ZSBoYXMgbmVzdGluZyBsZXZlbCAwLlxuICAgICAgICB2YXIgYmluZGVyID0gbmV3IFRlbXBsYXRlQmluZGVyKGV4cHJlc3Npb25zLCBzeW1ib2xzLCB1c2VkUGlwZXMsIG5lc3RpbmdMZXZlbCwgc2NvcGUsIHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUgPyB0ZW1wbGF0ZSA6IG51bGwsIDApO1xuICAgICAgICBiaW5kZXIuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHsgZXhwcmVzc2lvbnM6IGV4cHJlc3Npb25zLCBzeW1ib2xzOiBzeW1ib2xzLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgdXNlZFBpcGVzOiB1c2VkUGlwZXMgfTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS5pbmdlc3QgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIEZvciA8bmctdGVtcGxhdGU+cywgcHJvY2VzcyBvbmx5IHZhcmlhYmxlcyBhbmQgY2hpbGQgbm9kZXMuIElucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycyxcbiAgICAgICAgICAgIC8vIGFuZCByZWZlcmVuY2VzIHdlcmUgYWxsIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNvbnRhaW5pbmcgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVzdGluZyBsZXZlbC5cbiAgICAgICAgICAgIHRoaXMubmVzdGluZ0xldmVsLnNldCh0ZW1wbGF0ZSwgdGhpcy5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpdCBlYWNoIG5vZGUgZnJvbSB0aGUgdG9wLWxldmVsIHRlbXBsYXRlLlxuICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBWaXNpdCB0aGUgaW5wdXRzLCBvdXRwdXRzLCBhbmQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIGVsZW1lbnQuaW5wdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICBlbGVtZW50Lm91dHB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBGaXJzdCwgdmlzaXQgaW5wdXRzLCBvdXRwdXRzIGFuZCB0ZW1wbGF0ZSBhdHRyaWJ1dGVzIG9mIHRoZSB0ZW1wbGF0ZSBub2RlLlxuICAgICAgICB0ZW1wbGF0ZS5pbnB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIHRlbXBsYXRlLm91dHB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIC8vIFJlZmVyZW5jZXMgYXJlIGFsc28gZXZhbHVhdGVkIGluIHRoZSBvdXRlciBjb250ZXh0LlxuICAgICAgICB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICAvLyBOZXh0LCByZWN1cnNlIGludG8gdGhlIHRlbXBsYXRlIHVzaW5nIGl0cyBzY29wZSwgYW5kIGJ1bXBpbmcgdGhlIG5lc3RpbmcgbGV2ZWwgdXAgYnkgb25lLlxuICAgICAgICB2YXIgY2hpbGRTY29wZSA9IHRoaXMuc2NvcGUuZ2V0Q2hpbGRTY29wZSh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciBiaW5kZXIgPSBuZXcgVGVtcGxhdGVCaW5kZXIodGhpcy5iaW5kaW5ncywgdGhpcy5zeW1ib2xzLCB0aGlzLnVzZWRQaXBlcywgdGhpcy5uZXN0aW5nTGV2ZWwsIGNoaWxkU2NvcGUsIHRlbXBsYXRlLCB0aGlzLmxldmVsICsgMSk7XG4gICAgICAgIGJpbmRlci5pbmdlc3QodGVtcGxhdGUpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGBWYXJpYWJsZWAgYXMgYSBzeW1ib2wgaW4gdGhlIGN1cnJlbnQgYFRlbXBsYXRlYC5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9scy5zZXQodmFyaWFibGUsIHRoaXMudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBgUmVmZXJlbmNlYCBhcyBhIHN5bWJvbCBpbiB0aGUgY3VycmVudCBgVGVtcGxhdGVgLlxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zeW1ib2xzLnNldChyZWZlcmVuY2UsIHRoaXMudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBVbnVzZWQgdGVtcGxhdGUgdmlzaXRvcnNcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRUZXh0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UpIHsgfTtcbiAgICAvLyBUaGUgcmVtYWluaW5nIHZpc2l0b3JzIGFyZSBjb25jZXJuZWQgd2l0aCBwcm9jZXNzaW5nIEFTVCBleHByZXNzaW9ucyB3aXRoaW4gdGVtcGxhdGUgYmluZGluZ3NcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0Qm91bmRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5oYW5kbGVyLnZpc2l0KHRoaXMpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGV4dC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0UGlwZS5jYWxsKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvLyBUaGVzZSBmaXZlIHR5cGVzIG9mIEFTVCBleHByZXNzaW9ucyBjYW4gcmVmZXIgdG8gZXhwcmVzc2lvbiByb290cywgd2hpY2ggY291bGQgYmUgdmFyaWFibGVzXG4gICAgLy8gb3IgcmVmZXJlbmNlcyBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZC5jYWxsKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgfTtcbiAgICBUZW1wbGF0ZUJpbmRlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUuY2FsbCh0aGlzLCBhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgVGVtcGxhdGVCaW5kZXIucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsLmNhbGwodGhpcywgYXN0LCBjb250ZXh0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlQmluZGVyLnByb3RvdHlwZS5tYXliZU1hcCA9IGZ1bmN0aW9uIChzY29wZSwgYXN0LCBuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSByZWNlaXZlciBvZiB0aGUgZXhwcmVzc2lvbiBpc24ndCB0aGUgYEltcGxpY2l0UmVjZWl2ZXJgLCB0aGlzIGlzbid0IHRoZSByb290IG9mIGFuXG4gICAgICAgIC8vIGBBU1RgIGV4cHJlc3Npb24gdGhhdCBtYXBzIHRvIGEgYFZhcmlhYmxlYCBvciBgUmVmZXJlbmNlYC5cbiAgICAgICAgaWYgKCEoYXN0LnJlY2VpdmVyIGluc3RhbmNlb2YgSW1wbGljaXRSZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBuYW1lIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY29wZS4gSWYgc28sIG1hcCBpdC4gT3RoZXJ3aXNlLCB0aGUgbmFtZSBpc1xuICAgICAgICAvLyBwcm9iYWJseSBhIHByb3BlcnR5IG9uIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50IGNvbnRleHQuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnNjb3BlLmxvb2t1cChuYW1lKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5zZXQoYXN0LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVCaW5kZXI7XG59KFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSkpO1xuLyoqXG4gKiBNZXRhZGF0YSBjb250YWluZXIgZm9yIGEgYFRhcmdldGAgdGhhdCBhbGxvd3MgcXVlcmllcyBmb3Igc3BlY2lmaWMgYml0cyBvZiBtZXRhZGF0YS5cbiAqXG4gKiBTZWUgYEJvdW5kVGFyZ2V0YCBmb3IgZG9jdW1lbnRhdGlvbiBvbiB0aGUgaW5kaXZpZHVhbCBtZXRob2RzLlxuICovXG52YXIgUjNCb3VuZFRhcmdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSM0JvdW5kVGFyZ2V0KHRhcmdldCwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMsIGV4cHJUYXJnZXRzLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmV4cHJUYXJnZXRzID0gZXhwclRhcmdldHM7XG4gICAgICAgIHRoaXMuc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgICAgIHRoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICB9XG4gICAgUjNCb3VuZFRhcmdldC5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlc09mTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGl2ZXMuZ2V0KG5vZGUpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRSZWZlcmVuY2VUYXJnZXQgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZXMuZ2V0KHJlZikgfHwgbnVsbDtcbiAgICB9O1xuICAgIFIzQm91bmRUYXJnZXQucHJvdG90eXBlLmdldENvbnN1bWVyT2ZCaW5kaW5nID0gZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3MuZ2V0KGJpbmRpbmcpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVGFyZ2V0ID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwclRhcmdldHMuZ2V0KGV4cHIpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXRUZW1wbGF0ZU9mU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xzLmdldChzeW1ib2wpIHx8IG51bGw7XG4gICAgfTtcbiAgICBSM0JvdW5kVGFyZ2V0LnByb3RvdHlwZS5nZXROZXN0aW5nTGV2ZWwgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGluZ0xldmVsLmdldCh0ZW1wbGF0ZSkgfHwgMDtcbiAgICB9O1xuICAgIFIzQm91bmRUYXJnZXQucHJvdG90eXBlLmdldFVzZWREaXJlY3RpdmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlycykgeyByZXR1cm4gZGlycy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHNldC5hZGQoZGlyKTsgfSk7IH0pO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzZXQudmFsdWVzKCkpO1xuICAgIH07XG4gICAgUjNCb3VuZFRhcmdldC5wcm90b3R5cGUuZ2V0VXNlZFBpcGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnVzZWRQaXBlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUjNCb3VuZFRhcmdldDtcbn0oKSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbGwgaGFzIGEgZ2xvYmFsIHNpZGUgZWZmZWN0cyBhbmQgcHVibGlzaGVzIHRoZSBjb21waWxlciBpbnRvIGdsb2JhbCBuYW1lc3BhY2UgZm9yXG4vLyB0aGUgbGF0ZSBiaW5kaW5nIG9mIHRoZSBDb21waWxlciB0byB0aGUgQGFuZ3VsYXIvY29yZSBmb3Igaml0IGNvbXBpbGF0aW9uLlxucHVibGlzaEZhY2FkZShfZ2xvYmFsKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmV4cG9ydCB7IEFTVCwgQVNUV2l0aE5hbWUsIEFTVFdpdGhTb3VyY2UsIEFic29sdXRlU291cmNlU3BhbiwgQW90Q29tcGlsZXIsIEFvdFN1bW1hcnlSZXNvbHZlciwgQXJyYXlUeXBlLCBBc3NlcnROb3ROdWxsLCBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciwgQXN0UGF0aCwgQXN0VHJhbnNmb3JtZXIkMSBhcyBBc3RUcmFuc2Zvcm1lciwgQXR0ckFzdCwgQXR0cmlidXRlLCBCaW5hcnksIEJpbmFyeU9wZXJhdG9yLCBCaW5hcnlPcGVyYXRvckV4cHIsIEJpbmRpbmdQaXBlLCBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0LCBCb3VuZEVsZW1lbnRQcm9wZXJ0eSwgQm91bmRFbGVtZW50UHJvcGVydHlBc3QsIEJvdW5kRXZlbnRBc3QsIEJvdW5kVGV4dEFzdCwgQnVpbHRpbk1ldGhvZCwgQnVpbHRpblR5cGUsIEJ1aWx0aW5UeXBlTmFtZSwgQnVpbHRpblZhciwgQ09OVEVOVF9BVFRSLCBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLCBDYXN0RXhwciwgQ2hhaW4sIENsYXNzRmllbGQsIENsYXNzTWV0aG9kLCBDbGFzc1N0bXQsIENvbW1hRXhwciwgQ29tbWVudCwgQ29tbWVudFN0bXQsIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSwgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIsIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLCBDb21waWxlUGlwZU1ldGFkYXRhLCBDb21waWxlUmVmbGVjdG9yLCBDb21waWxlU2hhbGxvd01vZHVsZU1ldGFkYXRhLCBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhLCBDb21waWxlU3VtbWFyeUtpbmQsIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLCBDb21waWxlZFN0eWxlc2hlZXQsIENvbXBpbGVyQ29uZmlnLCBDb25kaXRpb25hbCwgQ29uZGl0aW9uYWxFeHByLCBDb25zdGFudFBvb2wsIENzc1NlbGVjdG9yLCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBEWU5BTUlDX1RZUEUsIERlY2xhcmVGdW5jdGlvblN0bXQsIERlY2xhcmVWYXJTdG10LCBEaXJlY3RpdmVBc3QsIERpcmVjdGl2ZU5vcm1hbGl6ZXIsIERpcmVjdGl2ZVJlc29sdmVyLCBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksIEVPRiwgRVJST1JfQ09NUE9ORU5UX1RZUEUsIEVsZW1lbnQkMSBhcyBFbGVtZW50LCBFbGVtZW50QXN0LCBFbGVtZW50U2NoZW1hUmVnaXN0cnksIEVtYmVkZGVkVGVtcGxhdGVBc3QsIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCwgRW1wdHlFeHByLCBFeHBhbnNpb24sIEV4cGFuc2lvbkNhc2UsIEV4cHJlc3Npb24sIEV4cHJlc3Npb25CaW5kaW5nLCBFeHByZXNzaW9uU3RhdGVtZW50LCBFeHByZXNzaW9uVHlwZSwgRXh0ZXJuYWxFeHByLCBFeHRlcm5hbFJlZmVyZW5jZSwgRXh0cmFjdG9yLCBGdW5jdGlvbkNhbGwsIEZ1bmN0aW9uRXhwciwgR2VuZXJhdGVkRmlsZSwgSE9TVF9BVFRSLCBIdG1sUGFyc2VyLCBIdG1sVGFnRGVmaW5pdGlvbiwgSTE4Tkh0bWxQYXJzZXIsIElkZW50aWZpZXJzLCBJZlN0bXQsIEltcGxpY2l0UmVjZWl2ZXIsIEluc3RhbnRpYXRlRXhwciwgSW50ZXJwb2xhdGlvbiwgSW50ZXJwb2xhdGlvbkNvbmZpZywgSW52b2tlRnVuY3Rpb25FeHByLCBJbnZva2VNZXRob2RFeHByLCBJdnlQYXJzZXIsIEpTRG9jQ29tbWVudFN0bXQsIEppdENvbXBpbGVyLCBKaXRFdmFsdWF0b3IsIEppdFN1bW1hcnlSZXNvbHZlciwgS2V5ZWRSZWFkLCBLZXllZFdyaXRlLCBMZXhlciwgTGl0ZXJhbEFycmF5LCBMaXRlcmFsQXJyYXlFeHByLCBMaXRlcmFsRXhwciwgTGl0ZXJhbE1hcCwgTGl0ZXJhbE1hcEV4cHIsIExpdGVyYWxQcmltaXRpdmUsIE1hcFR5cGUsIE1lc3NhZ2VCdW5kbGUsIE1ldGhvZENhbGwsIE5BTUVEX0VOVElUSUVTLCBOR1NQX1VOSUNPREUsIE5PTkVfVFlQRSwgTk9fRVJST1JTX1NDSEVNQSwgTmdDb250ZW50QXN0LCBOZ01vZHVsZUNvbXBpbGVyLCBOZ01vZHVsZVJlc29sdmVyLCBOb2RlV2l0aEkxOG4sIE5vbk51bGxBc3NlcnQsIE5vdEV4cHIsIE51bGxUZW1wbGF0ZVZpc2l0b3IsIFBhcnNlRXJyb3IsIFBhcnNlRXJyb3JMZXZlbCwgUGFyc2VMb2NhdGlvbiwgUGFyc2VTb3VyY2VGaWxlLCBQYXJzZVNvdXJjZVNwYW4sIFBhcnNlU3BhbiwgUGFyc2VUcmVlUmVzdWx0LCBQYXJzZWRFdmVudCwgUGFyc2VkUHJvcGVydHksIFBhcnNlZFByb3BlcnR5VHlwZSwgUGFyc2VkVmFyaWFibGUsIFBhcnNlciQxIGFzIFBhcnNlciwgUGFyc2VyRXJyb3IsIFBpcGVSZXNvbHZlciwgUHJlZml4Tm90LCBQcm9wZXJ0eVJlYWQsIFByb3BlcnR5V3JpdGUsIFByb3ZpZGVyQXN0LCBQcm92aWRlckFzdFR5cGUsIFByb3ZpZGVyTWV0YSwgUXVvdGUsIFIzQm91bmRUYXJnZXQsIFIzRmFjdG9yeVRhcmdldCwgSWRlbnRpZmllcnMkMSBhcyBSM0lkZW50aWZpZXJzLCBSM1Jlc29sdmVkRGVwZW5kZW5jeVR5cGUsIFIzVGFyZ2V0QmluZGVyLCBSZWFkS2V5RXhwciwgUmVhZFByb3BFeHByLCBSZWFkVmFyRXhwciwgUmVjdXJzaXZlQXN0VmlzaXRvciQxIGFzIFJlY3Vyc2l2ZUFzdFZpc2l0b3IsIFJlY3Vyc2l2ZVRlbXBsYXRlQXN0VmlzaXRvciwgUmVjdXJzaXZlVmlzaXRvciQxIGFzIFJlY3Vyc2l2ZVZpc2l0b3IsIFJlZmVyZW5jZUFzdCwgUmVzb2x2ZWRTdGF0aWNTeW1ib2wsIFJlc291cmNlTG9hZGVyLCBSZXR1cm5TdGF0ZW1lbnQsIFNUUklOR19UWVBFLCBTYWZlTWV0aG9kQ2FsbCwgU2FmZVByb3BlcnR5UmVhZCwgU2VsZWN0b3JDb250ZXh0LCBTZWxlY3Rvckxpc3RDb250ZXh0LCBTZWxlY3Rvck1hdGNoZXIsIFNlcmlhbGl6ZXIsIFNwbGl0SW50ZXJwb2xhdGlvbiwgU3RhdGVtZW50LCBTdGF0aWNSZWZsZWN0b3IsIFN0YXRpY1N5bWJvbCwgU3RhdGljU3ltYm9sQ2FjaGUsIFN0YXRpY1N5bWJvbFJlc29sdmVyLCBTdG10TW9kaWZpZXIsIFN0eWxlQ29tcGlsZXIsIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5LCBTdW1tYXJ5UmVzb2x2ZXIsIFRhZ0NvbnRlbnRUeXBlLCBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCwgVGVtcGxhdGVQYXJzZUVycm9yLCBUZW1wbGF0ZVBhcnNlUmVzdWx0LCBUZW1wbGF0ZVBhcnNlciwgVGV4dCQzIGFzIFRleHQsIFRleHRBc3QsIFRocm93U3RtdCwgQm91bmRBdHRyaWJ1dGUgYXMgVG1wbEFzdEJvdW5kQXR0cmlidXRlLCBCb3VuZEV2ZW50IGFzIFRtcGxBc3RCb3VuZEV2ZW50LCBCb3VuZFRleHQgYXMgVG1wbEFzdEJvdW5kVGV4dCwgQ29udGVudCBhcyBUbXBsQXN0Q29udGVudCwgRWxlbWVudCBhcyBUbXBsQXN0RWxlbWVudCwgUmVjdXJzaXZlVmlzaXRvciBhcyBUbXBsQXN0UmVjdXJzaXZlVmlzaXRvciwgUmVmZXJlbmNlIGFzIFRtcGxBc3RSZWZlcmVuY2UsIFRlbXBsYXRlIGFzIFRtcGxBc3RUZW1wbGF0ZSwgVGV4dCBhcyBUbXBsQXN0VGV4dCwgVGV4dEF0dHJpYnV0ZSBhcyBUbXBsQXN0VGV4dEF0dHJpYnV0ZSwgVmFyaWFibGUgYXMgVG1wbEFzdFZhcmlhYmxlLCBUb2tlbiQxIGFzIFRva2VuLCBUb2tlblR5cGUkMSBhcyBUb2tlblR5cGUsIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSwgVHJlZUVycm9yLCBUcnlDYXRjaFN0bXQsIFR5cGUkMSBhcyBUeXBlLCBUeXBlU2NyaXB0RW1pdHRlciwgVHlwZW9mRXhwciwgVXJsUmVzb2x2ZXIsIFZFUlNJT04kMSBhcyBWRVJTSU9OLCBWYXJpYWJsZUFzdCwgVmFyaWFibGVCaW5kaW5nLCBWZXJzaW9uLCBWaWV3Q29tcGlsZXIsIFdyYXBwZWROb2RlRXhwciwgV3JpdGVLZXlFeHByLCBXcml0ZVByb3BFeHByLCBXcml0ZVZhckV4cHIsIFhsaWZmLCBYbGlmZjIsIFhtYiwgWG1sUGFyc2VyLCBYdGIsIF9QYXJzZUFTVCwgYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzLCBhbmFseXplRmlsZSwgYW5hbHl6ZUZpbGVGb3JJbmplY3RhYmxlcywgYW5hbHl6ZU5nTW9kdWxlcywgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlcywgY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YSwgY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YSwgY29tcGlsZUZhY3RvcnlGdW5jdGlvbiwgY29tcGlsZUluamVjdGFibGUsIGNvbXBpbGVJbmplY3RvciwgY29tcGlsZU5nTW9kdWxlLCBjb21waWxlUGlwZUZyb21NZXRhZGF0YSwgY29tcG9uZW50RmFjdG9yeU5hbWUsIGNvbXB1dGVNc2dJZCwgY29yZSwgY3JlYXRlQW90Q29tcGlsZXIsIGNyZWF0ZUFvdFVybFJlc29sdmVyLCBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IsIGNyZWF0ZUxvd2VyZWRTeW1ib2wsIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIsIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgsIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0LCBmaW5kTm9kZSwgZmxhdHRlbiwgZm9ybWF0dGVkRXJyb3IsIGdldEh0bWxUYWdEZWZpbml0aW9uLCBnZXROc1ByZWZpeCwgZ2V0UGFyc2VFcnJvcnMsIGdldFVybFNjaGVtZSwgaG9zdFZpZXdDbGFzc05hbWUsIGlkZW50aWZpZXJNb2R1bGVVcmwsIGlkZW50aWZpZXJOYW1lLCBpc0VtcHR5RXhwcmVzc2lvbiwgaXNGb3JtYXR0ZWRFcnJvciwgaXNJZGVudGlmaWVyLCBpc0xvd2VyZWRTeW1ib2wsIGlzTmdDb250YWluZXIsIGlzTmdDb250ZW50LCBpc05nVGVtcGxhdGUsIGlzUXVvdGUsIGlzU3ludGF4RXJyb3IsIGxpdGVyYWxNYXAsIG1ha2VCaW5kaW5nUGFyc2VyLCBtZXJnZUFuYWx5emVkRmlsZXMsIG1lcmdlTnNBbmROYW1lLCBuZ01vZHVsZUppdFVybCwgcGFyc2VIb3N0QmluZGluZ3MsIHBhcnNlVGVtcGxhdGUsIHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0LCBwdWJsaXNoRmFjYWRlLCByM0ppdFR5cGVTb3VyY2VTcGFuLCByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcywgcmVuZGVyZXJUeXBlTmFtZSwgc2FuaXRpemVJZGVudGlmaWVyLCBzaGFyZWRTdHlsZXNoZWV0Sml0VXJsLCBzcGxpdENsYXNzZXMsIHNwbGl0TnNOYW1lLCBzeW50YXhFcnJvciwgdGVtcGxhdGVKaXRVcmwsIHRlbXBsYXRlU291cmNlVXJsLCB0ZW1wbGF0ZVZpc2l0QWxsLCB0b1R5cGVTY3JpcHQsIHRva2VuTmFtZSwgdG9rZW5SZWZlcmVuY2UsIHR5cGVTb3VyY2VTcGFuLCB1bmVzY2FwZUlkZW50aWZpZXIsIHVud3JhcFJlc29sdmVkTWV0YWRhdGEsIHZlcmlmeUhvc3RCaW5kaW5ncywgdmlld0NsYXNzTmFtZSwgdmlzaXRBbGwkMSBhcyB2aXNpdEFsbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@angular/compiler/fesm5/compiler.js\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.__extends = __extends;\nexports.__rest = __rest;\nexports.__decorate = __decorate;\nexports.__param = __param;\nexports.__metadata = __metadata;\nexports.__awaiter = __awaiter;\nexports.__generator = __generator;\nexports.__createBinding = __createBinding;\nexports.__exportStar = __exportStar;\nexports.__values = __values;\nexports.__read = __read;\nexports.__spread = __spread;\nexports.__spreadArrays = __spreadArrays;\nexports.__await = __await;\nexports.__asyncGenerator = __asyncGenerator;\nexports.__asyncDelegator = __asyncDelegator;\nexports.__asyncValues = __asyncValues;\nexports.__makeTemplateObject = __makeTemplateObject;\nexports.__importStar = __importStar;\nexports.__importDefault = __importDefault;\nexports.__classPrivateFieldGet = __classPrivateFieldGet;\nexports.__classPrivateFieldSet = __classPrivateFieldSet;\nexports.__assign = void 0;\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  exports.__assign = _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nexports.__assign = _assign;\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : (0, _typeof2.default)(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\n\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : (0, _typeof2.default)(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n}\n\nfunction __exportStar(m, exports) {\n  for (var p in m) {\n    if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}\n\n;\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n\n;\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result.default = mod;\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    default: mod\n  };\n}\n\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBWEE7QUFDQTtBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBakJBO0FBQ0E7QUFpQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ })

}]);