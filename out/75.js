(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[75],{

/***/ "./node_modules/babylon6/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/babylon6/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint max-len: 0 */\n\n// This is a trick taken from Esprima. It turns out that, on\n// non-Chrome browsers, to check whether a string is in a set, a\n// predicate containing a big ugly `switch` statement is faster than\n// a regular expression, and on Chrome the two are about on par.\n// This function uses `eval` (non-lexical) to produce such a\n// predicate from a space-separated string of words.\n//\n// It starts by sorting the words by length.\n\nfunction makePredicate(words) {\n  words = words.split(\" \");\n  return function (str) {\n    return words.indexOf(str) >= 0;\n  };\n}\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  6: makePredicate(\"enum await\"),\n  strict: makePredicate(\"implements interface let package private protected public static yield\"),\n  strictBind: makePredicate(\"eval arguments\")\n};\n\n// And the keywords\n\nvar isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super\");\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\nvar nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA900-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `bin/generate-identifier-regex.js`.\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n// A second optional argument can be given to further configure\nvar defaultOptions = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Line from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n  for (var key in defaultOptions) {\n    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar beforeExpr = true;\nvar startsExpr = true;\nvar isLoop = true;\nvar isAssign = true;\nvar prefix = true;\nvar postfix = true;\n\nvar TokenType = function TokenType(label) {\n  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  classCallCheck(this, TokenType);\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.rightAssociative = !!conf.rightAssociative;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nvar KeywordTokenType = function (_TokenType) {\n  inherits(KeywordTokenType, _TokenType);\n\n  function KeywordTokenType(name) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, KeywordTokenType);\n\n    options.keyword = name;\n\n    return possibleConstructorReturn(this, _TokenType.call(this, name, options));\n  }\n\n  return KeywordTokenType;\n}(TokenType);\n\nvar BinopTokenType = function (_TokenType2) {\n  inherits(BinopTokenType, _TokenType2);\n\n  function BinopTokenType(name, prec) {\n    classCallCheck(this, BinopTokenType);\n    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));\n  }\n\n  return BinopTokenType;\n}(TokenType);\n\nvar types = {\n  num: new TokenType(\"num\", { startsExpr: startsExpr }),\n  regexp: new TokenType(\"regexp\", { startsExpr: startsExpr }),\n  string: new TokenType(\"string\", { startsExpr: startsExpr }),\n  name: new TokenType(\"name\", { startsExpr: startsExpr }),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  braceBarL: new TokenType(\"{|\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", { beforeExpr: beforeExpr }),\n  semi: new TokenType(\";\", { beforeExpr: beforeExpr }),\n  colon: new TokenType(\":\", { beforeExpr: beforeExpr }),\n  doubleColon: new TokenType(\"::\", { beforeExpr: beforeExpr }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", { beforeExpr: beforeExpr }),\n  arrow: new TokenType(\"=>\", { beforeExpr: beforeExpr }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", { beforeExpr: beforeExpr }),\n  backQuote: new TokenType(\"`\", { startsExpr: startsExpr }),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  at: new TokenType(\"@\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr: beforeExpr, isAssign: isAssign }),\n  assign: new TokenType(\"_=\", { beforeExpr: beforeExpr, isAssign: isAssign }),\n  incDec: new TokenType(\"++/--\", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),\n  prefix: new TokenType(\"prefix\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  logicalOR: new BinopTokenType(\"||\", 1),\n  logicalAND: new BinopTokenType(\"&&\", 2),\n  bitwiseOR: new BinopTokenType(\"|\", 3),\n  bitwiseXOR: new BinopTokenType(\"^\", 4),\n  bitwiseAND: new BinopTokenType(\"&\", 5),\n  equality: new BinopTokenType(\"==/!=\", 6),\n  relational: new BinopTokenType(\"</>\", 7),\n  bitShift: new BinopTokenType(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),\n  modulo: new BinopTokenType(\"%\", 10),\n  star: new BinopTokenType(\"*\", 10),\n  slash: new BinopTokenType(\"/\", 10),\n  exponent: new TokenType(\"**\", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })\n};\n\nvar keywords = {\n  \"break\": new KeywordTokenType(\"break\"),\n  \"case\": new KeywordTokenType(\"case\", { beforeExpr: beforeExpr }),\n  \"catch\": new KeywordTokenType(\"catch\"),\n  \"continue\": new KeywordTokenType(\"continue\"),\n  \"debugger\": new KeywordTokenType(\"debugger\"),\n  \"default\": new KeywordTokenType(\"default\", { beforeExpr: beforeExpr }),\n  \"do\": new KeywordTokenType(\"do\", { isLoop: isLoop, beforeExpr: beforeExpr }),\n  \"else\": new KeywordTokenType(\"else\", { beforeExpr: beforeExpr }),\n  \"finally\": new KeywordTokenType(\"finally\"),\n  \"for\": new KeywordTokenType(\"for\", { isLoop: isLoop }),\n  \"function\": new KeywordTokenType(\"function\", { startsExpr: startsExpr }),\n  \"if\": new KeywordTokenType(\"if\"),\n  \"return\": new KeywordTokenType(\"return\", { beforeExpr: beforeExpr }),\n  \"switch\": new KeywordTokenType(\"switch\"),\n  \"throw\": new KeywordTokenType(\"throw\", { beforeExpr: beforeExpr }),\n  \"try\": new KeywordTokenType(\"try\"),\n  \"var\": new KeywordTokenType(\"var\"),\n  \"let\": new KeywordTokenType(\"let\"),\n  \"const\": new KeywordTokenType(\"const\"),\n  \"while\": new KeywordTokenType(\"while\", { isLoop: isLoop }),\n  \"with\": new KeywordTokenType(\"with\"),\n  \"new\": new KeywordTokenType(\"new\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  \"this\": new KeywordTokenType(\"this\", { startsExpr: startsExpr }),\n  \"super\": new KeywordTokenType(\"super\", { startsExpr: startsExpr }),\n  \"class\": new KeywordTokenType(\"class\"),\n  \"extends\": new KeywordTokenType(\"extends\", { beforeExpr: beforeExpr }),\n  \"export\": new KeywordTokenType(\"export\"),\n  \"import\": new KeywordTokenType(\"import\", { startsExpr: startsExpr }),\n  \"yield\": new KeywordTokenType(\"yield\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  \"null\": new KeywordTokenType(\"null\", { startsExpr: startsExpr }),\n  \"true\": new KeywordTokenType(\"true\", { startsExpr: startsExpr }),\n  \"false\": new KeywordTokenType(\"false\", { startsExpr: startsExpr }),\n  \"in\": new KeywordTokenType(\"in\", { beforeExpr: beforeExpr, binop: 7 }),\n  \"instanceof\": new KeywordTokenType(\"instanceof\", { beforeExpr: beforeExpr, binop: 7 }),\n  \"typeof\": new KeywordTokenType(\"typeof\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  \"void\": new KeywordTokenType(\"void\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  \"delete\": new KeywordTokenType(\"delete\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })\n};\n\n// Map keyword names to token types.\nObject.keys(keywords).forEach(function (name) {\n  types[\"_\" + name] = keywords[name];\n});\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  classCallCheck(this, TokContext);\n\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\n\nvar types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", true),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  functionExpression: new TokContext(\"function\", true)\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  var out = this.state.context.pop();\n  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {\n    this.state.context.pop();\n    this.state.exprAllowed = false;\n  } else if (out === types$1.templateQuasi) {\n    this.state.exprAllowed = true;\n  } else {\n    this.state.exprAllowed = !out.isExpr;\n  }\n};\n\ntypes.name.updateContext = function (prevType) {\n  this.state.exprAllowed = false;\n\n  if (prevType === types._let || prevType === types._const || prevType === types._var) {\n    if (lineBreak.test(this.input.slice(this.state.end))) {\n      this.state.exprAllowed = true;\n    }\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = function () {\n  if (this.curContext() !== types$1.braceStatement) {\n    this.state.context.push(types$1.functionExpression);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n  this.state.exprAllowed = false;\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  classCallCheck(this, Position);\n\n  this.line = line;\n  this.column = col;\n};\n\nvar SourceLocation = function SourceLocation(start, end) {\n  classCallCheck(this, SourceLocation);\n\n  this.start = start;\n  this.end = end;\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n}\n\nvar State = function () {\n  function State() {\n    classCallCheck(this, State);\n  }\n\n  State.prototype.init = function init(options, input) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n\n    this.input = input;\n\n    this.potentialArrowAt = -1;\n\n    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false;\n\n    this.labels = [];\n\n    this.decorators = [];\n\n    this.tokens = [];\n\n    this.comments = [];\n\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n\n    this.pos = this.lineStart = 0;\n    this.curLine = options.startLine;\n\n    this.type = types.eof;\n    this.value = null;\n    this.start = this.end = this.pos;\n    this.startLoc = this.endLoc = this.curPosition();\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n\n    this.containsEsc = this.containsOctal = false;\n    this.octalPosition = null;\n\n    this.invalidTemplateEscapePosition = null;\n\n    this.exportedIdentifiers = [];\n\n    return this;\n  };\n\n  // TODO\n\n\n  // TODO\n\n\n  // Used to signify the start of a potential arrow function\n\n\n  // Flags to track whether we are in a function, a generator.\n\n\n  // Labels in scope.\n\n\n  // Leading decorators.\n\n\n  // Token store.\n\n\n  // Comment store.\n\n\n  // Comment attachment store\n\n\n  // The current position of the tokenizer in the input.\n\n\n  // Properties of the current token:\n  // Its type\n\n\n  // For tokens that include more information than their type, the value\n\n\n  // Its start and end offset\n\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n\n\n  // Position information for the previous token\n\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n\n  // TODO\n\n\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n\n\n  State.prototype.curPosition = function curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  };\n\n  State.prototype.clone = function clone(skipArrays) {\n    var state = new State();\n    for (var key in this) {\n      var val = this[key];\n\n      if ((!skipArrays || key === \"context\") && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n    return state;\n  };\n\n  return State;\n}();\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(state) {\n  classCallCheck(this, Token);\n\n  this.type = state.type;\n  this.value = state.value;\n  this.start = state.start;\n  this.end = state.end;\n  this.loc = new SourceLocation(state.startLoc, state.endLoc);\n};\n\n// ## Tokenizer\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  } else {\n    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);\n  }\n}\n\nvar Tokenizer = function () {\n  function Tokenizer(options, input) {\n    classCallCheck(this, Tokenizer);\n\n    this.state = new State();\n    this.state.init(options, input);\n  }\n\n  // Move to the next token\n\n  Tokenizer.prototype.next = function next() {\n    if (!this.isLookahead) {\n      this.state.tokens.push(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  };\n\n  // TODO\n\n  Tokenizer.prototype.eat = function eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  // TODO\n\n  Tokenizer.prototype.match = function match(type) {\n    return this.state.type === type;\n  };\n\n  // TODO\n\n  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {\n    return isKeyword(word);\n  };\n\n  // TODO\n\n  Tokenizer.prototype.lookahead = function lookahead() {\n    var old = this.state;\n    this.state = old.clone(true);\n\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n\n    var curr = this.state.clone(true);\n    this.state = old;\n    return curr;\n  };\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  Tokenizer.prototype.setStrict = function setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n    this.nextToken();\n  };\n\n  Tokenizer.prototype.curContext = function curContext() {\n    return this.state.context[this.state.context.length - 1];\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  Tokenizer.prototype.nextToken = function nextToken() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n\n    this.state.containsOctal = false;\n    this.state.octalPosition = null;\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);\n\n    if (curContext.override) {\n      return curContext.override(this);\n    } else {\n      return this.readToken(this.fullCharCodeAtPos());\n    }\n  };\n\n  Tokenizer.prototype.readToken = function readToken(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) {\n        return this.readWord();\n      } else {\n      return this.getTokenFromCode(code);\n    }\n  };\n\n  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {\n    var code = this.input.charCodeAt(this.state.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n\n    if (!this.isLookahead) {\n      this.state.tokens.push(comment);\n      this.state.comments.push(comment);\n      this.addComment(comment);\n    }\n  };\n\n  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {\n    var startLoc = this.state.curPosition();\n    var start = this.state.pos;\n    var end = this.input.indexOf(\"*/\", this.state.pos += 2);\n    if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    var match = void 0;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {\n    var start = this.state.pos;\n    var startLoc = this.state.curPosition();\n    var ch = this.input.charCodeAt(this.state.pos += startSkip);\n    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++this.state.pos;\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  Tokenizer.prototype.skipSpace = function skipSpace() {\n    loop: while (this.state.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:case 160:\n          // ' '\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:case 8232:case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          // '/'\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              // '*'\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  Tokenizer.prototype.finishToken = function finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    var prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  Tokenizer.prototype.readToken_dot = function readToken_dot() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      return this.readNumber(true);\n    }\n\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.state.pos += 3;\n      return this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      return this.finishToken(types.dot);\n    }\n  };\n\n  Tokenizer.prototype.readToken_slash = function readToken_slash() {\n    // '/'\n    if (this.state.exprAllowed) {\n      ++this.state.pos;\n      return this.readRegexp();\n    }\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.slash, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {\n    // '%*'\n    var type = code === 42 ? types.star : types.modulo;\n    var width = 1;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 42) {\n      // '*'\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61) {\n      width++;\n      type = types.assign;\n    }\n\n    return this.finishOp(type, width);\n  };\n\n  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n    if (next === 61) return this.finishOp(types.assign, 2);\n    if (code === 124 && next === 125 && this.hasPlugin(\"flow\")) return this.finishOp(types.braceBarR, 2);\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  };\n\n  Tokenizer.prototype.readToken_caret = function readToken_caret() {\n    // '^'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.bitwiseXOR, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken();\n      }\n      return this.finishOp(types.incDec, 2);\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.plusMin, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);\n      return this.finishOp(types.bitShift, size);\n    }\n\n    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      if (this.inModule) this.unexpected();\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    if (next === 61) {\n      // <= | >=\n      size = 2;\n    }\n\n    return this.finishOp(types.relational, size);\n  };\n\n  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n    if (code === 61 && next === 62) {\n      // '=>'\n      this.state.pos += 2;\n      return this.finishToken(types.arrow);\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n  };\n\n  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n      case 46:\n        // '.'\n        return this.readToken_dot();\n\n      // Punctuation tokens.\n      case 40:\n        ++this.state.pos;return this.finishToken(types.parenL);\n      case 41:\n        ++this.state.pos;return this.finishToken(types.parenR);\n      case 59:\n        ++this.state.pos;return this.finishToken(types.semi);\n      case 44:\n        ++this.state.pos;return this.finishToken(types.comma);\n      case 91:\n        ++this.state.pos;return this.finishToken(types.bracketL);\n      case 93:\n        ++this.state.pos;return this.finishToken(types.bracketR);\n\n      case 123:\n        if (this.hasPlugin(\"flow\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          return this.finishOp(types.braceBarL, 2);\n        } else {\n          ++this.state.pos;\n          return this.finishToken(types.braceL);\n        }\n\n      case 125:\n        ++this.state.pos;return this.finishToken(types.braceR);\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          return this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          return this.finishToken(types.colon);\n        }\n\n      case 63:\n        ++this.state.pos;return this.finishToken(types.question);\n      case 64:\n        ++this.state.pos;return this.finishToken(types.at);\n\n      case 96:\n        // '`'\n        ++this.state.pos;\n        return this.finishToken(types.backQuote);\n\n      case 48:\n        // '0'\n        var next = this.input.charCodeAt(this.state.pos + 1);\n        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n        // 1-9\n        return this.readNumber(false);\n\n      // Quotes produce strings.\n      case 34:case 39:\n        // '\"', \"'\"\n        return this.readString(code);\n\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return this.readToken_slash();\n\n      case 37:case 42:\n        // '%*'\n        return this.readToken_mult_modulo(code);\n\n      case 124:case 38:\n        // '|&'\n        return this.readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return this.readToken_caret();\n\n      case 43:case 45:\n        // '+-'\n        return this.readToken_plus_min(code);\n\n      case 60:case 62:\n        // '<>'\n        return this.readToken_lt_gt(code);\n\n      case 61:case 33:\n        // '=!'\n        return this.readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return this.finishOp(types.prefix, 1);\n    }\n\n    this.raise(this.state.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  Tokenizer.prototype.finishOp = function finishOp(type, size) {\n    var str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    return this.finishToken(type, str);\n  };\n\n  Tokenizer.prototype.readRegexp = function readRegexp() {\n    var start = this.state.pos;\n    var escaped = void 0,\n        inClass = void 0;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(start, \"Unterminated regular expression\");\n      var ch = this.input.charAt(this.state.pos);\n      if (lineBreak.test(ch)) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n        escaped = ch === \"\\\\\";\n      }\n      ++this.state.pos;\n    }\n    var content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = this.readWord1();\n    if (mods) {\n      var validFlags = /^[gmsiyu]*$/;\n      if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n    }\n    return this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  Tokenizer.prototype.readInt = function readInt(radix, len) {\n    var start = this.state.pos;\n    var total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.state.pos);\n      var val = void 0;\n      if (code >= 97) {\n        val = code - 97 + 10; // a\n      } else if (code >= 65) {\n        val = code - 65 + 10; // A\n      } else if (code >= 48 && code <= 57) {\n        val = code - 48; // 0-9\n      } else {\n        val = Infinity;\n      }\n      if (val >= radix) break;\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;\n\n    return total;\n  };\n\n  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {\n    this.state.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, \"Identifier directly after number\");\n    return this.finishToken(types.num, val);\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {\n    var start = this.state.pos;\n    var octal = this.input.charCodeAt(start) === 48; // '0'\n    var isFloat = false;\n\n    if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    if (octal && this.state.pos == start + 1) octal = false; // number === 0\n\n    var next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !octal) {\n      // '.'\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      // 'eE'\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) ++this.state.pos; // '+-'\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, \"Identifier directly after number\");\n\n    var str = this.input.slice(start, this.state.pos);\n    var val = void 0;\n    if (isFloat) {\n      val = parseFloat(str);\n    } else if (!octal || str.length === 1) {\n      val = parseInt(str, 10);\n    } else if (this.state.strict) {\n      this.raise(start, \"Invalid number\");\n    } else if (/[89]/.test(str)) {\n      val = parseInt(str, 10);\n    } else {\n      val = parseInt(str, 8);\n    }\n    return this.finishToken(types.num, val);\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  Tokenizer.prototype.readCodePoint = function readCodePoint(throwOnInvalid) {\n    var ch = this.input.charCodeAt(this.state.pos);\n    var code = void 0;\n\n    if (ch === 123) {\n      // '{'\n      var codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, throwOnInvalid);\n      ++this.state.pos;\n      if (code === null) {\n        --this.state.invalidTemplateEscapePosition; // to point to the '\\'' instead of the 'u'\n      } else if (code > 0x10FFFF) {\n        if (throwOnInvalid) {\n          this.raise(codePos, \"Code point out of bounds\");\n        } else {\n          this.state.invalidTemplateEscapePosition = codePos - 2;\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, throwOnInvalid);\n    }\n    return code;\n  };\n\n  Tokenizer.prototype.readString = function readString(quote) {\n    var out = \"\",\n        chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(this.state.start, \"Unterminated string constant\");\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else {\n        if (isNewLine(ch)) this.raise(this.state.start, \"Unterminated string constant\");\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  };\n\n  // Reads template string tokens.\n\n  Tokenizer.prototype.readTmplToken = function readTmplToken() {\n    var out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(this.state.start, \"Unterminated template\");\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        // '`', '${'\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            return this.finishToken(types.dollarBraceL);\n          } else {\n            ++this.state.pos;\n            return this.finishToken(types.backQuote);\n          }\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        return this.finishToken(types.template, containsInvalid ? null : out);\n      }\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos);\n        var escaped = this.readEscapedChar(true);\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;\n          case 10:\n            out += \"\\n\";\n            break;\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  };\n\n  // Used to read escaped characters\n\n  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {\n    var throwOnInvalid = !inTemplate;\n    var ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n    switch (ch) {\n      case 110:\n        return \"\\n\"; // 'n' -> '\\n'\n      case 114:\n        return \"\\r\"; // 'r' -> '\\r'\n      case 120:\n        {\n          // 'x'\n          var code = this.readHexChar(2, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n      case 117:\n        {\n          // 'u'\n          var _code = this.readCodePoint(throwOnInvalid);\n          return _code === null ? null : codePointToString(_code);\n        }\n      case 116:\n        return \"\\t\"; // 't' -> '\\t'\n      case 98:\n        return \"\\b\"; // 'b' -> '\\b'\n      case 118:\n        return \"\\x0B\"; // 'v' -> '\\u000b'\n      case 102:\n        return \"\\f\"; // 'f' -> '\\f'\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\\r\\n'\n      case 10:\n        // ' \\n'\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n        return \"\";\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var codePos = this.state.pos - 1;\n          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n          if (octal > 0) {\n            if (inTemplate) {\n              this.state.invalidTemplateEscapePosition = codePos;\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, \"Octal literal in strict mode\");\n            } else if (!this.state.containsOctal) {\n              // These properties are only used to throw an error for an octal which occurs\n              // in a directive which occurs prior to a \"use strict\" directive.\n              this.state.containsOctal = true;\n              this.state.octalPosition = codePos;\n            }\n          }\n          this.state.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n        return String.fromCharCode(ch);\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u').\n\n  Tokenizer.prototype.readHexChar = function readHexChar(len, throwOnInvalid) {\n    var codePos = this.state.pos;\n    var n = this.readInt(16, len);\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, \"Bad character escape sequence\");\n      } else {\n        this.state.pos = codePos - 1;\n        this.state.invalidTemplateEscapePosition = codePos - 1;\n      }\n    }\n    return n;\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  Tokenizer.prototype.readWord1 = function readWord1() {\n    this.state.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.state.pos;\n    while (this.state.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        var escStart = this.state.pos;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          // \"u\"\n          this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n        ++this.state.pos;\n        var esc = this.readCodePoint(true);\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {\n          this.raise(escStart, \"Invalid Unicode escape\");\n        }\n\n        word += codePointToString(esc);\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  Tokenizer.prototype.readWord = function readWord() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (!this.state.containsEsc && this.isKeyword(word)) {\n      type = keywords[word];\n    }\n    return this.finishToken(type, word);\n  };\n\n  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {\n    if (prevType === types.colon) {\n      var parent = this.curContext();\n      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {\n        return !parent.isExpr;\n      }\n    }\n\n    if (prevType === types._return) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return this.curContext() === types$1.braceStatement;\n    }\n\n    return !this.state.exprAllowed;\n  };\n\n  Tokenizer.prototype.updateContext = function updateContext(prevType) {\n    var type = this.state.type;\n    var update = void 0;\n\n    if (type.keyword && prevType === types.dot) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  };\n\n  return Tokenizer;\n}();\n\nvar plugins = {};\nvar frozenDeprecatedWildcardPluginList = [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"decorators\", \"classProperties\", \"exportExtensions\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"flow\"];\n\nvar Parser = function (_Tokenizer) {\n  inherits(Parser, _Tokenizer);\n\n  function Parser(options, input) {\n    classCallCheck(this, Parser);\n\n    options = getOptions(options);\n\n    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));\n\n    _this.options = options;\n    _this.inModule = _this.options.sourceType === \"module\";\n    _this.input = input;\n    _this.plugins = _this.loadPlugins(_this.options.plugins);\n    _this.filename = options.sourceFilename;\n\n    // If enabled, skip leading hashbang line.\n    if (_this.state.pos === 0 && _this.input[0] === \"#\" && _this.input[1] === \"!\") {\n      _this.skipLineComment(2);\n    }\n    return _this;\n  }\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    if (word === \"await\") {\n      return this.inModule;\n    } else {\n      return reservedWords[6](word);\n    }\n  };\n\n  Parser.prototype.hasPlugin = function hasPlugin(name) {\n    if (this.plugins[\"*\"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {\n      return true;\n    }\n\n    return !!this.plugins[name];\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadAllPlugins = function loadAllPlugins() {\n    var _this2 = this;\n\n    // ensure flow plugin loads last, also ensure estree is not loaded with *\n    var pluginNames = Object.keys(plugins).filter(function (name) {\n      return name !== \"flow\" && name !== \"estree\";\n    });\n    pluginNames.push(\"flow\");\n\n    pluginNames.forEach(function (name) {\n      var plugin = plugins[name];\n      if (plugin) plugin(_this2);\n    });\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {\n    // TODO: Deprecate \"*\" option in next major version of Babylon\n    if (pluginList.indexOf(\"*\") >= 0) {\n      this.loadAllPlugins();\n\n      return { \"*\": true };\n    }\n\n    var pluginMap = {};\n\n    if (pluginList.indexOf(\"flow\") >= 0) {\n      // ensure flow plugin loads last\n      pluginList = pluginList.filter(function (plugin) {\n        return plugin !== \"flow\";\n      });\n      pluginList.push(\"flow\");\n    }\n\n    if (pluginList.indexOf(\"estree\") >= 0) {\n      // ensure estree plugin loads first\n      pluginList = pluginList.filter(function (plugin) {\n        return plugin !== \"estree\";\n      });\n      pluginList.unshift(\"estree\");\n    }\n\n    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var name = _ref;\n\n      if (!pluginMap[name]) {\n        pluginMap[name] = true;\n\n        var plugin = plugins[name];\n        if (plugin) plugin(this);\n      }\n    }\n\n    return pluginMap;\n  };\n\n  Parser.prototype.parse = function parse() {\n    var file = this.startNode();\n    var program = this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(file, program);\n  };\n\n  return Parser;\n}(Tokenizer);\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\n// TODO\n\npp.addExtra = function (node, key, val) {\n  if (!node) return;\n\n  var extra = node.extra = node.extra || {};\n  extra[key] = val;\n};\n\n// TODO\n\npp.isRelational = function (op) {\n  return this.match(types.relational) && this.state.value === op;\n};\n\n// TODO\n\npp.expectRelational = function (op) {\n  if (this.isRelational(op)) {\n    this.next();\n  } else {\n    this.unexpected(null, types.relational);\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function (name) {\n  return this.match(types.name) && this.state.value === name;\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function (name) {\n  return this.state.value === name && this.eat(types.name);\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function (name, message) {\n  if (!this.eatContextual(name)) this.unexpected(null, message);\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function () {\n  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n};\n\n// TODO\n\npp.isLineTerminator = function () {\n  return this.eat(types.semi) || this.canInsertSemicolon();\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function () {\n  if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\n\npp.expect = function (type, pos) {\n  return this.eat(type) || this.unexpected(pos, type);\n};\n\n// Raise an unexpected token error. Can take the expected token type\n// instead of a message string.\n\npp.unexpected = function (pos) {\n  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Unexpected token\";\n\n  if (messageOrType && (typeof messageOrType === \"undefined\" ? \"undefined\" : _typeof(messageOrType)) === \"object\" && messageOrType.label) {\n    messageOrType = \"Unexpected token, expected \" + messageOrType.label;\n  }\n  this.raise(pos != null ? pos : this.state.start, messageOrType);\n};\n\n/* eslint max-len: 0 */\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function (file, program) {\n  program.sourceType = this.options.sourceType;\n\n  this.parseBlockBody(program, true, true, types.eof);\n\n  file.program = this.finishNode(program, \"Program\");\n  file.comments = this.state.comments;\n  file.tokens = this.state.tokens;\n\n  return this.finishNode(file, \"File\");\n};\n\nvar loopLabel = { kind: \"loop\" };\nvar switchLabel = { kind: \"switch\" };\n\n// TODO\n\npp$1.stmtToDirective = function (stmt) {\n  var expr = stmt.expression;\n\n  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n  var directive = this.startNodeAt(stmt.start, stmt.loc.start);\n\n  var raw = this.input.slice(expr.start, expr.end);\n  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes\n\n  this.addExtra(directiveLiteral, \"raw\", raw);\n  this.addExtra(directiveLiteral, \"rawValue\", val);\n\n  directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n\n  return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function (declaration, topLevel) {\n  if (this.match(types.at)) {\n    this.parseDecorators(true);\n  }\n\n  var starttype = this.state.type;\n  var node = this.startNode();\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case types._break:case types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n    case types._debugger:\n      return this.parseDebuggerStatement(node);\n    case types._do:\n      return this.parseDoStatement(node);\n    case types._for:\n      return this.parseForStatement(node);\n    case types._function:\n      if (!declaration) this.unexpected();\n      return this.parseFunctionStatement(node);\n\n    case types._class:\n      if (!declaration) this.unexpected();\n      return this.parseClass(node, true);\n\n    case types._if:\n      return this.parseIfStatement(node);\n    case types._return:\n      return this.parseReturnStatement(node);\n    case types._switch:\n      return this.parseSwitchStatement(node);\n    case types._throw:\n      return this.parseThrowStatement(node);\n    case types._try:\n      return this.parseTryStatement(node);\n\n    case types._let:\n    case types._const:\n      if (!declaration) this.unexpected(); // NOTE: falls through to _var\n\n    case types._var:\n      return this.parseVarStatement(node, starttype);\n\n    case types._while:\n      return this.parseWhileStatement(node);\n    case types._with:\n      return this.parseWithStatement(node);\n    case types.braceL:\n      return this.parseBlock();\n    case types.semi:\n      return this.parseEmptyStatement(node);\n    case types._export:\n    case types._import:\n      if (this.hasPlugin(\"dynamicImport\") && this.lookahead().type === types.parenL) break;\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) {\n          this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\");\n        }\n\n        if (!this.inModule) {\n          this.raise(this.state.start, \"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\");\n        }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);\n\n    case types.name:\n      if (this.state.value === \"async\") {\n        // peek ahead and see if next token is a function\n        var state = this.state.clone();\n        this.next();\n        if (this.match(types._function) && !this.canInsertSemicolon()) {\n          this.expect(types._function);\n          return this.parseFunction(node, true, false, true);\n        } else {\n          this.state = state;\n        }\n      }\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  var maybeName = this.state.value;\n  var expr = this.parseExpression();\n\n  if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n    return this.parseLabeledStatement(node, maybeName, expr);\n  } else {\n    return this.parseExpressionStatement(node, expr);\n  }\n};\n\npp$1.takeDecorators = function (node) {\n  if (this.state.decorators.length) {\n    node.decorators = this.state.decorators;\n    this.state.decorators = [];\n  }\n};\n\npp$1.parseDecorators = function (allowExport) {\n  while (this.match(types.at)) {\n    var decorator = this.parseDecorator();\n    this.state.decorators.push(decorator);\n  }\n\n  if (allowExport && this.match(types._export)) {\n    return;\n  }\n\n  if (!this.match(types._class)) {\n    this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n  }\n};\n\npp$1.parseDecorator = function () {\n  if (!this.hasPlugin(\"decorators\")) {\n    this.unexpected();\n  }\n  var node = this.startNode();\n  this.next();\n  node.expression = this.parseMaybeAssign();\n  return this.finishNode(node, \"Decorator\");\n};\n\npp$1.parseBreakContinueStatement = function (node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n\n  if (this.isLineTerminator()) {\n    node.label = null;\n  } else if (!this.match(types.name)) {\n    this.unexpected();\n  } else {\n    node.label = this.parseIdentifier();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = void 0;\n  for (i = 0; i < this.state.labels.length; ++i) {\n    var lab = this.state.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n      if (node.label && isBreak) break;\n    }\n  }\n  if (i === this.state.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp$1.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp$1.parseDoStatement = function (node) {\n  this.next();\n  this.state.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  this.eat(types.semi);\n  return this.finishNode(node, \"DoWhileStatement\");\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function (node) {\n  this.next();\n  this.state.labels.push(loopLabel);\n\n  var forAwait = false;\n  if (this.hasPlugin(\"asyncGenerators\") && this.state.inAsync && this.isContextual(\"await\")) {\n    forAwait = true;\n    this.next();\n  }\n  this.expect(types.parenL);\n\n  if (this.match(types.semi)) {\n    if (forAwait) {\n      this.unexpected();\n    }\n    return this.parseFor(node, null);\n  }\n\n  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {\n    var _init = this.startNode();\n    var varKind = this.state.type;\n    this.next();\n    this.parseVar(_init, true, varKind);\n    this.finishNode(_init, \"VariableDeclaration\");\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      if (_init.declarations.length === 1 && !_init.declarations[0].init) {\n        return this.parseForIn(node, _init, forAwait);\n      }\n    }\n    if (forAwait) {\n      this.unexpected();\n    }\n    return this.parseFor(node, _init);\n  }\n\n  var refShorthandDefaultPos = { start: 0 };\n  var init = this.parseExpression(true, refShorthandDefaultPos);\n  if (this.match(types._in) || this.isContextual(\"of\")) {\n    var description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n    this.toAssignable(init, undefined, description);\n    this.checkLVal(init, undefined, undefined, description);\n    return this.parseForIn(node, init, forAwait);\n  } else if (refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n  if (forAwait) {\n    this.unexpected();\n  }\n  return this.parseFor(node, init);\n};\n\npp$1.parseFunctionStatement = function (node) {\n  this.next();\n  return this.parseFunction(node, true);\n};\n\npp$1.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  node.consequent = this.parseStatement(false);\n  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp$1.parseReturnStatement = function (node) {\n  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {\n    this.raise(this.state.start, \"'return' outside of function\");\n  }\n\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.isLineTerminator()) {\n    node.argument = null;\n  } else {\n    node.argument = this.parseExpression();\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp$1.parseSwitchStatement = function (node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.state.labels.push(switchLabel);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur = void 0;\n  for (var sawDefault; !this.match(types.braceR);) {\n    if (this.match(types._case) || this.match(types._default)) {\n      var isCase = this.match(types._case);\n      if (cur) this.finishNode(cur, \"SwitchCase\");\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) this.raise(this.state.lastTokStart, \"Multiple default clauses\");\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (cur) {\n        cur.consequent.push(this.parseStatement(true));\n      } else {\n        this.unexpected();\n      }\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\");\n  this.next(); // Closing brace\n  this.state.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp$1.parseThrowStatement = function (node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function (node) {\n  this.next();\n\n  node.block = this.parseBlock();\n  node.handler = null;\n\n  if (this.match(types._catch)) {\n    var clause = this.startNode();\n    this.next();\n\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.checkLVal(clause.param, true, Object.create(null), \"catch clause\");\n    this.expect(types.parenR);\n\n    clause.body = this.parseBlock();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n\n  node.guardedHandlers = empty;\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n  if (!node.handler && !node.finalizer) {\n    this.raise(node.start, \"Missing catch or finally clause\");\n  }\n\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp$1.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp$1.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.state.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp$1.parseWithStatement = function (node) {\n  if (this.state.strict) this.raise(this.state.start, \"'with' in strict mode\");\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp$1.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp$1.parseLabeledStatement = function (node, maybeName, expr) {\n  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _label = _ref;\n\n    if (_label.name === maybeName) {\n      this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n  }\n\n  var kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n  for (var i = this.state.labels.length - 1; i >= 0; i--) {\n    var label = this.state.labels[i];\n    if (label.statementStart === node.start) {\n      label.statementStart = this.state.start;\n      label.kind = kind;\n    } else {\n      break;\n    }\n  }\n\n  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });\n  node.body = this.parseStatement(true);\n  this.state.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp$1.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function (allowDirectives) {\n  var node = this.startNode();\n  this.expect(types.braceL);\n  this.parseBlockBody(node, allowDirectives, false, types.braceR);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\npp$1.isValidDirective = function (stmt) {\n  return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n};\n\npp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {\n  node.body = [];\n  node.directives = [];\n\n  var parsedNonDirective = false;\n  var oldStrict = void 0;\n  var octalPosition = void 0;\n\n  while (!this.eat(end)) {\n    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\n      octalPosition = this.state.octalPosition;\n    }\n\n    var stmt = this.parseStatement(true, topLevel);\n\n    if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {\n      var directive = this.stmtToDirective(stmt);\n      node.directives.push(directive);\n\n      if (oldStrict === undefined && directive.value.value === \"use strict\") {\n        oldStrict = this.state.strict;\n        this.setStrict(true);\n\n        if (octalPosition) {\n          this.raise(octalPosition, \"Octal literal in strict mode\");\n        }\n      }\n\n      continue;\n    }\n\n    parsedNonDirective = true;\n    node.body.push(stmt);\n  }\n\n  if (oldStrict === false) {\n    this.setStrict(false);\n  }\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.match(types.semi) ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.match(types.parenR) ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function (node, init, forAwait) {\n  var type = void 0;\n  if (forAwait) {\n    this.eatContextual(\"of\");\n    type = \"ForAwaitStatement\";\n  } else {\n    type = this.match(types._in) ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n  }\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, type);\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function (node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind.keyword;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarHead(decl);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === types._const && !(this.match(types._in) || this.isContextual(\"of\"))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n      this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) break;\n  }\n  return node;\n};\n\npp$1.parseVarHead = function (decl) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, true, undefined, \"variable declaration\");\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {\n  var oldInMethod = this.state.inMethod;\n  this.state.inMethod = false;\n\n  this.initFunction(node, isAsync);\n\n  if (this.match(types.star)) {\n    if (node.async && !this.hasPlugin(\"asyncGenerators\")) {\n      this.unexpected();\n    } else {\n      node.generator = true;\n      this.next();\n    }\n  }\n\n  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {\n    this.unexpected();\n  }\n\n  if (this.match(types.name) || this.match(types._yield)) {\n    node.id = this.parseBindingIdentifier();\n  }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.state.inMethod = oldInMethod;\n\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp$1.parseFunctionParams = function (node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR);\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function (node, isStatement, optionalId) {\n  this.next();\n  this.takeDecorators(node);\n  this.parseClassId(node, isStatement, optionalId);\n  this.parseClassSuper(node);\n  this.parseClassBody(node);\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp$1.isClassProperty = function () {\n  return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n};\n\npp$1.isClassMethod = function () {\n  return this.match(types.parenL);\n};\n\npp$1.isNonstaticConstructor = function (method) {\n  return !method.computed && !method.static && (method.key.name === \"constructor\" || // Identifier\n  method.key.value === \"constructor\" // Literal\n  );\n};\n\npp$1.parseClassBody = function (node) {\n  // class bodies are implicitly strict\n  var oldStrict = this.state.strict;\n  this.state.strict = true;\n\n  var hadConstructorCall = false;\n  var hadConstructor = false;\n  var decorators = [];\n  var classBody = this.startNode();\n\n  classBody.body = [];\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (this.eat(types.semi)) {\n      if (decorators.length > 0) {\n        this.raise(this.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");\n      }\n      continue;\n    }\n\n    if (this.match(types.at)) {\n      decorators.push(this.parseDecorator());\n      continue;\n    }\n\n    var method = this.startNode();\n\n    // steal the decorators if there are any\n    if (decorators.length) {\n      method.decorators = decorators;\n      decorators = [];\n    }\n\n    method.static = false;\n    if (this.match(types.name) && this.state.value === \"static\") {\n      var key = this.parseIdentifier(true); // eats 'static'\n      if (this.isClassMethod()) {\n        // a method named 'static'\n        method.kind = \"method\";\n        method.computed = false;\n        method.key = key;\n        this.parseClassMethod(classBody, method, false, false);\n        continue;\n      } else if (this.isClassProperty()) {\n        // a property named 'static'\n        method.computed = false;\n        method.key = key;\n        classBody.body.push(this.parseClassProperty(method));\n        continue;\n      }\n      // otherwise something static\n      method.static = true;\n    }\n\n    if (this.eat(types.star)) {\n      // a generator\n      method.kind = \"method\";\n      this.parsePropertyName(method);\n      if (this.isNonstaticConstructor(method)) {\n        this.raise(method.key.start, \"Constructor can't be a generator\");\n      }\n      if (!method.computed && method.static && (method.key.name === \"prototype\" || method.key.value === \"prototype\")) {\n        this.raise(method.key.start, \"Classes may not have static property named prototype\");\n      }\n      this.parseClassMethod(classBody, method, true, false);\n    } else {\n      var isSimple = this.match(types.name);\n      var _key = this.parsePropertyName(method);\n      if (!method.computed && method.static && (method.key.name === \"prototype\" || method.key.value === \"prototype\")) {\n        this.raise(method.key.start, \"Classes may not have static property named prototype\");\n      }\n      if (this.isClassMethod()) {\n        // a normal method\n        if (this.isNonstaticConstructor(method)) {\n          if (hadConstructor) {\n            this.raise(_key.start, \"Duplicate constructor in the same class\");\n          } else if (method.decorators) {\n            this.raise(method.start, \"You can't attach decorators to a class constructor\");\n          }\n          hadConstructor = true;\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        this.parseClassMethod(classBody, method, false, false);\n      } else if (this.isClassProperty()) {\n        // a normal property\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Classes may not have a non-static field named 'constructor'\");\n        }\n        classBody.body.push(this.parseClassProperty(method));\n      } else if (isSimple && _key.name === \"async\" && !this.isLineTerminator()) {\n        // an async method\n        var isGenerator = this.hasPlugin(\"asyncGenerators\") && this.eat(types.star);\n        method.kind = \"method\";\n        this.parsePropertyName(method);\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Constructor can't be an async function\");\n        }\n        this.parseClassMethod(classBody, method, isGenerator, true);\n      } else if (isSimple && (_key.name === \"get\" || _key.name === \"set\") && !(this.isLineTerminator() && this.match(types.star))) {\n        // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n        // a getter or setter\n        method.kind = _key.name;\n        this.parsePropertyName(method);\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Constructor can't have get/set modifier\");\n        }\n        this.parseClassMethod(classBody, method, false, false);\n        this.checkGetterSetterParamCount(method);\n      } else if (this.hasPlugin(\"classConstructorCall\") && isSimple && _key.name === \"call\" && this.match(types.name) && this.state.value === \"constructor\") {\n        // a (deprecated) call constructor\n        if (hadConstructorCall) {\n          this.raise(method.start, \"Duplicate constructor call in the same class\");\n        } else if (method.decorators) {\n          this.raise(method.start, \"You can't attach decorators to a class constructor\");\n        }\n        hadConstructorCall = true;\n        method.kind = \"constructorCall\";\n        this.parsePropertyName(method); // consume \"constructor\" and make it the method's name\n        this.parseClassMethod(classBody, method, false, false);\n      } else if (this.isLineTerminator()) {\n        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Classes may not have a non-static field named 'constructor'\");\n        }\n        classBody.body.push(this.parseClassProperty(method));\n      } else {\n        this.unexpected();\n      }\n    }\n  }\n\n  if (decorators.length) {\n    this.raise(this.state.start, \"You have trailing decorators with no method\");\n  }\n\n  node.body = this.finishNode(classBody, \"ClassBody\");\n\n  this.state.strict = oldStrict;\n};\n\npp$1.parseClassProperty = function (node) {\n  this.state.inClassProperty = true;\n  if (this.match(types.eq)) {\n    if (!this.hasPlugin(\"classProperties\")) this.unexpected();\n    this.next();\n    node.value = this.parseMaybeAssign();\n  } else {\n    node.value = null;\n  }\n  this.semicolon();\n  this.state.inClassProperty = false;\n  return this.finishNode(node, \"ClassProperty\");\n};\n\npp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n  this.parseMethod(method, isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"ClassMethod\"));\n};\n\npp$1.parseClassId = function (node, isStatement, optionalId) {\n  if (this.match(types.name)) {\n    node.id = this.parseIdentifier();\n  } else {\n    if (optionalId || !isStatement) {\n      node.id = null;\n    } else {\n      this.unexpected();\n    }\n  }\n};\n\npp$1.parseClassSuper = function (node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function (node) {\n  this.next();\n  // export * from '...'\n  if (this.match(types.star)) {\n    var specifier = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"exportExtensions\") && this.eatContextual(\"as\")) {\n      specifier.exported = this.parseIdentifier();\n      node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n      this.parseExportSpecifiersMaybe(node);\n      this.parseExportFrom(node, true);\n    } else {\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n  } else if (this.hasPlugin(\"exportExtensions\") && this.isExportDefaultSpecifier()) {\n    var _specifier = this.startNode();\n    _specifier.exported = this.parseIdentifier(true);\n    node.specifiers = [this.finishNode(_specifier, \"ExportDefaultSpecifier\")];\n    if (this.match(types.comma) && this.lookahead().type === types.star) {\n      this.expect(types.comma);\n      var _specifier2 = this.startNode();\n      this.expect(types.star);\n      this.expectContextual(\"as\");\n      _specifier2.exported = this.parseIdentifier();\n      node.specifiers.push(this.finishNode(_specifier2, \"ExportNamespaceSpecifier\"));\n    } else {\n      this.parseExportSpecifiersMaybe(node);\n    }\n    this.parseExportFrom(node, true);\n  } else if (this.eat(types._default)) {\n    // export default ...\n    var expr = this.startNode();\n    var needsSemi = false;\n    if (this.eat(types._function)) {\n      expr = this.parseFunction(expr, true, false, false, true);\n    } else if (this.match(types._class)) {\n      expr = this.parseClass(expr, true, true);\n    } else {\n      needsSemi = true;\n      expr = this.parseMaybeAssign();\n    }\n    node.declaration = expr;\n    if (needsSemi) this.semicolon();\n    this.checkExport(node, true, true);\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  } else if (this.shouldParseExportDeclaration()) {\n    node.specifiers = [];\n    node.source = null;\n    node.declaration = this.parseExportDeclaration(node);\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers();\n    this.parseExportFrom(node);\n  }\n  this.checkExport(node, true);\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp$1.parseExportDeclaration = function () {\n  return this.parseStatement(true);\n};\n\npp$1.isExportDefaultSpecifier = function () {\n  if (this.match(types.name)) {\n    return this.state.value !== \"async\";\n  }\n\n  if (!this.match(types._default)) {\n    return false;\n  }\n\n  var lookahead = this.lookahead();\n  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === \"from\";\n};\n\npp$1.parseExportSpecifiersMaybe = function (node) {\n  if (this.eat(types.comma)) {\n    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());\n  }\n};\n\npp$1.parseExportFrom = function (node, expect) {\n  if (this.eatContextual(\"from\")) {\n    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n    this.checkExport(node);\n  } else {\n    if (expect) {\n      this.unexpected();\n    } else {\n      node.source = null;\n    }\n  }\n\n  this.semicolon();\n};\n\npp$1.shouldParseExportDeclaration = function () {\n  return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"let\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isContextual(\"async\");\n};\n\npp$1.checkExport = function (node, checkNames, isDefault) {\n  if (checkNames) {\n    // Check for duplicate exports\n    if (isDefault) {\n      // Default exports\n      this.checkDuplicateExports(node, \"default\");\n    } else if (node.specifiers && node.specifiers.length) {\n      // Named exports\n      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var specifier = _ref2;\n\n        this.checkDuplicateExports(specifier, specifier.exported.name);\n      }\n    } else if (node.declaration) {\n      // Exported declarations\n      if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n        this.checkDuplicateExports(node, node.declaration.id.name);\n      } else if (node.declaration.type === \"VariableDeclaration\") {\n        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) break;\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n            if (_i3.done) break;\n            _ref3 = _i3.value;\n          }\n\n          var declaration = _ref3;\n\n          this.checkDeclaration(declaration.id);\n        }\n      }\n    }\n  }\n\n  if (this.state.decorators.length) {\n    var isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n    if (!node.declaration || !isClass) {\n      this.raise(node.start, \"You can only use decorators on an export when exporting a class\");\n    }\n    this.takeDecorators(node.declaration);\n  }\n};\n\npp$1.checkDeclaration = function (node) {\n  if (node.type === \"ObjectPattern\") {\n    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var prop = _ref4;\n\n      this.checkDeclaration(prop);\n    }\n  } else if (node.type === \"ArrayPattern\") {\n    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var elem = _ref5;\n\n      if (elem) {\n        this.checkDeclaration(elem);\n      }\n    }\n  } else if (node.type === \"ObjectProperty\") {\n    this.checkDeclaration(node.value);\n  } else if (node.type === \"RestElement\" || node.type === \"RestProperty\") {\n    this.checkDeclaration(node.argument);\n  } else if (node.type === \"Identifier\") {\n    this.checkDuplicateExports(node, node.name);\n  }\n};\n\npp$1.checkDuplicateExports = function (node, name) {\n  if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n    this.raiseDuplicateExportError(node, name);\n  }\n  this.state.exportedIdentifiers.push(name);\n};\n\npp$1.raiseDuplicateExportError = function (node, name) {\n  this.raise(node.start, name === \"default\" ? \"Only one default export allowed per module.\" : \"`\" + name + \"` has already been exported. Exported identifiers must be unique.\");\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function () {\n  var nodes = [];\n  var first = true;\n  var needsFrom = void 0;\n\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    var isDefault = this.match(types._default);\n    if (isDefault && !needsFrom) needsFrom = true;\n\n    var node = this.startNode();\n    node.local = this.parseIdentifier(isDefault);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n\n  // https://github.com/ember-cli/ember-cli/pull/3739\n  if (needsFrom && !this.isContextual(\"from\")) {\n    this.unexpected();\n  }\n\n  return nodes;\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function (node) {\n  this.eat(types._import);\n\n  // import '...'\n  if (this.match(types.string)) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = [];\n    this.parseImportSpecifiers(node);\n    this.expectContextual(\"from\");\n    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function (node) {\n  var first = true;\n  if (this.match(types.name)) {\n    // import defaultObj, { x, y as z } from '...'\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));\n    if (!this.eat(types.comma)) return;\n  }\n\n  if (this.match(types.star)) {\n    var specifier = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, true, undefined, \"import namespace specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportNamespaceSpecifier\"));\n    return;\n  }\n\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (this.eat(types.colon)) {\n        this.unexpected(null, \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n      }\n\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    this.parseImportSpecifier(node);\n  }\n};\n\npp$1.parseImportSpecifier = function (node) {\n  var specifier = this.startNode();\n  specifier.imported = this.parseIdentifier(true);\n  if (this.eatContextual(\"as\")) {\n    specifier.local = this.parseIdentifier();\n  } else {\n    this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n    specifier.local = specifier.imported.__clone();\n  }\n  this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n  node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n};\n\npp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.local = id;\n  this.checkLVal(node.local, true, undefined, \"default import specifier\");\n  return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function (node, isBinding, contextDescription) {\n  if (node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var prop = _ref;\n\n          if (prop.type === \"ObjectMethod\") {\n            if (prop.kind === \"get\" || prop.kind === \"set\") {\n              this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n            } else {\n              this.raise(prop.key.start, \"Object pattern can't contain methods\");\n            }\n          } else {\n            this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n          }\n        }\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isBinding, contextDescription);\n        break;\n\n      case \"SpreadProperty\":\n        node.type = \"RestProperty\";\n        var arg = node.argument;\n        this.toAssignable(arg, isBinding, contextDescription);\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, isBinding, contextDescription);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator === \"=\") {\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n        } else {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) break;\n\n      default:\n        {\n          var message = \"Invalid left-hand side\" + (contextDescription ? \" in \" + contextDescription : /* istanbul ignore next */\"expression\");\n          this.raise(node.start, message);\n        }\n    }\n  }\n  return node;\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function (exprList, isBinding, contextDescription) {\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type === \"RestElement\") {\n      --end;\n    } else if (last && last.type === \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding, contextDescription);\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") {\n        this.unexpected(arg.start);\n      }\n      --end;\n    }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) this.toAssignable(elt, isBinding, contextDescription);\n  }\n  return exprList;\n};\n\n// Convert list of expression atoms to a list of\n\npp$2.toReferencedList = function (exprList) {\n  return exprList;\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function (refShorthandDefaultPos) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp$2.parseRest = function () {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseBindingIdentifier();\n  return this.finishNode(node, \"RestElement\");\n};\n\npp$2.shouldAllowYieldIdentifier = function () {\n  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;\n};\n\npp$2.parseBindingIdentifier = function () {\n  return this.parseIdentifier(this.shouldAllowYieldIdentifier());\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function () {\n  switch (this.state.type) {\n    case types._yield:\n      if (this.state.strict || this.state.inGenerator) this.unexpected();\n    // fall-through\n    case types.name:\n      return this.parseIdentifier(true);\n\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true);\n      return this.finishNode(node, \"ArrayPattern\");\n\n    case types.braceL:\n      return this.parseObj(true);\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$2.parseBindingList = function (close, allowEmpty) {\n  var elts = [];\n  var first = true;\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n    }\n    if (allowEmpty && this.match(types.comma)) {\n      elts.push(null);\n    } else if (this.eat(close)) {\n      break;\n    } else if (this.match(types.ellipsis)) {\n      elts.push(this.parseAssignableListItemTypes(this.parseRest()));\n      this.expect(close);\n      break;\n    } else {\n      var decorators = [];\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n      var left = this.parseMaybeDefault();\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n      this.parseAssignableListItemTypes(left);\n      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));\n    }\n  }\n  return elts;\n};\n\npp$2.parseAssignableListItemTypes = function (param) {\n  return param;\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n  startLoc = startLoc || this.state.startLoc;\n  startPos = startPos || this.state.start;\n  left = left || this.parseBindingAtom();\n  if (!this.eat(types.eq)) return left;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n\npp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {\n  switch (expr.type) {\n    case \"Identifier\":\n      this.checkReservedWord(expr.name, expr.start, false, true);\n\n      if (checkClashes) {\n        // we need to prefix this with an underscore for the cases where we have a key of\n        // `__proto__`. there's a bug in old V8 where the following wouldn't work:\n        //\n        //   > var obj = Object.create(null);\n        //   undefined\n        //   > obj.__proto__\n        //   null\n        //   > obj.__proto__ = true;\n        //   true\n        //   > obj.__proto__\n        //   null\n        var key = \"_\" + expr.name;\n\n        if (checkClashes[key]) {\n          this.raise(expr.start, \"Argument name clash in strict mode\");\n        } else {\n          checkClashes[key] = true;\n        }\n      }\n      break;\n\n    case \"MemberExpression\":\n      if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n      break;\n\n    case \"ObjectPattern\":\n      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var prop = _ref2;\n\n        if (prop.type === \"ObjectProperty\") prop = prop.value;\n        this.checkLVal(prop, isBinding, checkClashes, \"object destructuring pattern\");\n      }\n      break;\n\n    case \"ArrayPattern\":\n      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var elem = _ref3;\n\n        if (elem) this.checkLVal(elem, isBinding, checkClashes, \"array destructuring pattern\");\n      }\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, isBinding, checkClashes, \"assignment pattern\");\n      break;\n\n    case \"RestProperty\":\n      this.checkLVal(expr.argument, isBinding, checkClashes, \"rest property\");\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, isBinding, checkClashes, \"rest element\");\n      break;\n\n    default:\n      {\n        var message = (isBinding ? /* istanbul ignore next */\"Binding invalid\" : \"Invalid\") + \" left-hand side\" + (contextDescription ? \" in \" + contextDescription : /* istanbul ignore next */\"expression\");\n        this.raise(expr.start, message);\n      }\n  }\n};\n\n/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function (prop, propHash) {\n  if (prop.computed || prop.kind) return;\n\n  var key = prop.key;\n  // It is either an Identifier or a String/NumericLiteral\n  var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n  if (name === \"__proto__\") {\n    if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n    propHash.proto = true;\n  }\n};\n\n// Convenience method to parse an Expression only\npp$3.getExpression = function () {\n  this.nextToken();\n  var expr = this.parseExpression();\n  if (!this.match(types.eof)) {\n    this.unexpected();\n  }\n  return expr;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initialization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n  if (this.match(types.comma)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) {\n      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n    }\n    this.toReferencedList(node.expressions);\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n  return expr;\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n\n  if (this.match(types._yield) && this.state.inGenerator) {\n    var _left = this.parseYield();\n    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);\n    return _left;\n  }\n\n  var failOnShorthandAssign = void 0;\n  if (refShorthandDefaultPos) {\n    failOnShorthandAssign = false;\n  } else {\n    refShorthandDefaultPos = { start: 0 };\n    failOnShorthandAssign = true;\n  }\n\n  if (this.match(types.parenL) || this.match(types.name)) {\n    this.state.potentialArrowAt = this.state.start;\n  }\n\n  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n  if (this.state.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.state.value;\n    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, \"assignment expression\") : left;\n    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\n\n    this.checkLVal(left, undefined, undefined, \"assignment expression\");\n\n    if (left.extra && left.extra.parenthesized) {\n      var errorMsg = void 0;\n      if (left.type === \"ObjectPattern\") {\n        errorMsg = \"`({a}) = 0` use `({a} = 0)`\";\n      } else if (left.type === \"ArrayPattern\") {\n        errorMsg = \"`([a]) = 0` use `([a] = 0)`\";\n      }\n      if (errorMsg) {\n        this.raise(left.start, \"You're trying to assign to a parenthesized expression, eg. instead of \" + errorMsg);\n      }\n    }\n\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n\n  return left;\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n\n  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n};\n\npp$3.parseConditional = function (expr, noIn, startPos, startLoc) {\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  return expr;\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseMaybeUnary(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n    return expr;\n  } else {\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.state.type.binop;\n  if (prec != null && (!noIn || !this.match(types._in))) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.left = left;\n      node.operator = this.state.value;\n\n      if (node.operator === \"**\" && left.type === \"UnaryExpression\" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {\n        this.raise(left.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n      }\n\n      var op = this.state.type;\n      this.next();\n\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n\n      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n  return left;\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function (refShorthandDefaultPos) {\n  if (this.state.type.prefix) {\n    var node = this.startNode();\n    var update = this.match(types.incDec);\n    node.operator = this.state.value;\n    node.prefix = true;\n    this.next();\n\n    var argType = this.state.type;\n    node.argument = this.parseMaybeUnary();\n\n    this.addExtra(node, \"parenthesizedArgument\", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (update) {\n      this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\n    } else if (this.state.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n      this.raise(node.start, \"Deleting local variable in strict mode\");\n    }\n\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  }\n\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseExprSubscripts(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  while (this.state.type.postfix && !this.canInsertSemicolon()) {\n    var _node = this.startNodeAt(startPos, startLoc);\n    _node.operator = this.state.value;\n    _node.prefix = false;\n    _node.argument = expr;\n    this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n    this.next();\n    expr = this.finishNode(_node, \"UpdateExpression\");\n  }\n  return expr;\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function (refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var potentialArrowAt = this.state.potentialArrowAt;\n  var expr = this.parseExprAtom(refShorthandDefaultPos);\n\n  if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n    return expr;\n  }\n\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n    return expr;\n  }\n\n  return this.parseSubscripts(expr, startPos, startLoc);\n};\n\npp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.callee = this.parseNoCallExpr();\n      return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n    } else if (this.eat(types.dot)) {\n      var _node2 = this.startNodeAt(startPos, startLoc);\n      _node2.object = base;\n      _node2.property = this.parseIdentifier(true);\n      _node2.computed = false;\n      base = this.finishNode(_node2, \"MemberExpression\");\n    } else if (this.eat(types.bracketL)) {\n      var _node3 = this.startNodeAt(startPos, startLoc);\n      _node3.object = base;\n      _node3.property = this.parseExpression();\n      _node3.computed = true;\n      this.expect(types.bracketR);\n      base = this.finishNode(_node3, \"MemberExpression\");\n    } else if (!noCalls && this.match(types.parenL)) {\n      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n      this.next();\n\n      var _node4 = this.startNodeAt(startPos, startLoc);\n      _node4.callee = base;\n      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);\n      if (_node4.callee.type === \"Import\" && _node4.arguments.length !== 1) {\n        this.raise(_node4.start, \"import() requires exactly one argument\");\n      }\n      base = this.finishNode(_node4, \"CallExpression\");\n\n      if (possibleAsync && this.shouldParseAsyncArrow()) {\n        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);\n      } else {\n        this.toReferencedList(_node4.arguments);\n      }\n    } else if (this.match(types.backQuote)) {\n      var _node5 = this.startNodeAt(startPos, startLoc);\n      _node5.tag = base;\n      _node5.quasi = this.parseTemplate(true);\n      base = this.finishNode(_node5, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\npp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {\n  var elts = [];\n  var innerParenStart = void 0;\n  var first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(close)) break;\n    }\n\n    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params\n    if (this.match(types.parenL) && !innerParenStart) {\n      innerParenStart = this.state.start;\n    }\n\n    elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined));\n  }\n\n  // we found an async arrow function so let's not allow any inner parens\n  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n    this.unexpected();\n  }\n\n  return elts;\n};\n\npp$3.shouldParseAsyncArrow = function () {\n  return this.match(types.arrow);\n};\n\npp$3.parseAsyncArrowFromCallExpression = function (node, call) {\n  this.expect(types.arrow);\n  return this.parseArrowExpression(node, call.arguments, true);\n};\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\npp$3.parseNoCallExpr = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function (refShorthandDefaultPos) {\n  var canBeArrow = this.state.potentialArrowAt === this.state.start;\n  var node = void 0;\n\n  switch (this.state.type) {\n    case types._super:\n      if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {\n        this.raise(this.state.start, \"'super' outside of function or class\");\n      }\n\n      node = this.startNode();\n      this.next();\n      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n        this.unexpected();\n      }\n      if (this.match(types.parenL) && this.state.inMethod !== \"constructor\" && !this.options.allowSuperOutsideMethod) {\n        this.raise(node.start, \"super() outside of class constructor\");\n      }\n      return this.finishNode(node, \"Super\");\n\n    case types._import:\n      if (!this.hasPlugin(\"dynamicImport\")) this.unexpected();\n\n      node = this.startNode();\n      this.next();\n      if (!this.match(types.parenL)) {\n        this.unexpected(null, types.parenL);\n      }\n      return this.finishNode(node, \"Import\");\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\");\n\n    case types._yield:\n      if (this.state.inGenerator) this.unexpected();\n\n    case types.name:\n      node = this.startNode();\n      var allowAwait = this.state.value === \"await\" && this.state.inAsync;\n      var allowYield = this.shouldAllowYieldIdentifier();\n      var id = this.parseIdentifier(allowAwait || allowYield);\n\n      if (id.name === \"await\") {\n        if (this.state.inAsync || this.inModule) {\n          return this.parseAwait(node);\n        }\n      } else if (id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n        this.next();\n        return this.parseFunction(node, false, false, true);\n      } else if (canBeArrow && id.name === \"async\" && this.match(types.name)) {\n        var params = [this.parseIdentifier()];\n        this.expect(types.arrow);\n        // let foo = bar => {};\n        return this.parseArrowExpression(node, params, true);\n      }\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        return this.parseArrowExpression(node, [id]);\n      }\n\n      return id;\n\n    case types._do:\n      if (this.hasPlugin(\"doExpressions\")) {\n        var _node6 = this.startNode();\n        this.next();\n        var oldInFunction = this.state.inFunction;\n        var oldLabels = this.state.labels;\n        this.state.labels = [];\n        this.state.inFunction = false;\n        _node6.body = this.parseBlock(false, true);\n        this.state.inFunction = oldInFunction;\n        this.state.labels = oldLabels;\n        return this.finishNode(_node6, \"DoExpression\");\n      }\n\n    case types.regexp:\n      var value = this.state.value;\n      node = this.parseLiteral(value.value, \"RegExpLiteral\");\n      node.pattern = value.pattern;\n      node.flags = value.flags;\n      return node;\n\n    case types.num:\n      return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n    case types.string:\n      return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n    case types._null:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"NullLiteral\");\n\n    case types._true:case types._false:\n      node = this.startNode();\n      node.value = this.match(types._true);\n      this.next();\n      return this.finishNode(node, \"BooleanLiteral\");\n\n    case types.parenL:\n      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);\n      this.toReferencedList(node.elements);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case types.braceL:\n      return this.parseObj(false, refShorthandDefaultPos);\n\n    case types._function:\n      return this.parseFunctionExpression();\n\n    case types.at:\n      this.parseDecorators();\n\n    case types._class:\n      node = this.startNode();\n      this.takeDecorators(node);\n      return this.parseClass(node, false);\n\n    case types._new:\n      return this.parseNew();\n\n    case types.backQuote:\n      return this.parseTemplate(false);\n\n    case types.doubleColon:\n      node = this.startNode();\n      this.next();\n      node.object = null;\n      var callee = node.callee = this.parseNoCallExpr();\n      if (callee.type === \"MemberExpression\") {\n        return this.finishNode(node, \"BindExpression\");\n      } else {\n        this.raise(callee.start, \"Binding should be performed on object property.\");\n      }\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$3.parseFunctionExpression = function () {\n  var node = this.startNode();\n  var meta = this.parseIdentifier(true);\n  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin(\"functionSent\")) {\n    return this.parseMetaProperty(node, meta, \"sent\");\n  } else {\n    return this.parseFunction(node, false);\n  }\n};\n\npp$3.parseMetaProperty = function (node, meta, propertyName) {\n  node.meta = meta;\n  node.property = this.parseIdentifier(true);\n\n  if (node.property.name !== propertyName) {\n    this.raise(node.property.start, \"The only valid meta property for new is \" + meta.name + \".\" + propertyName);\n  }\n\n  return this.finishNode(node, \"MetaProperty\");\n};\n\npp$3.parseLiteral = function (value, type, startPos, startLoc) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  this.addExtra(node, \"rawValue\", value);\n  this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n  node.value = value;\n  this.next();\n  return this.finishNode(node, type);\n};\n\npp$3.parseParenExpression = function () {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val;\n};\n\npp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n\n  var val = void 0;\n  this.expect(types.parenL);\n\n  var innerStartPos = this.state.start;\n  var innerStartLoc = this.state.startLoc;\n  var exprList = [];\n  var refShorthandDefaultPos = { start: 0 };\n  var refNeedsArrowPos = { start: 0 };\n  var first = true;\n  var spreadStart = void 0;\n  var optionalCommaStart = void 0;\n\n  while (!this.match(types.parenR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma, refNeedsArrowPos.start || null);\n      if (this.match(types.parenR)) {\n        optionalCommaStart = this.state.start;\n        break;\n      }\n    }\n\n    if (this.match(types.ellipsis)) {\n      var spreadNodeStartPos = this.state.start;\n      var spreadNodeStartLoc = this.state.startLoc;\n      spreadStart = this.state.start;\n      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));\n      break;\n    } else {\n      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));\n    }\n  }\n\n  var innerEndPos = this.state.start;\n  var innerEndLoc = this.state.startLoc;\n  this.expect(types.parenR);\n\n  var arrowNode = this.startNodeAt(startPos, startLoc);\n  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var param = _ref;\n\n      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);\n    }\n\n    return this.parseArrowExpression(arrowNode, exprList);\n  }\n\n  if (!exprList.length) {\n    this.unexpected(this.state.lastTokStart);\n  }\n  if (optionalCommaStart) this.unexpected(optionalCommaStart);\n  if (spreadStart) this.unexpected(spreadStart);\n  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);\n  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n\n  if (exprList.length > 1) {\n    val = this.startNodeAt(innerStartPos, innerStartLoc);\n    val.expressions = exprList;\n    this.toReferencedList(val.expressions);\n    this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n  } else {\n    val = exprList[0];\n  }\n\n  this.addExtra(val, \"parenthesized\", true);\n  this.addExtra(val, \"parenStart\", startPos);\n\n  return val;\n};\n\npp$3.shouldParseArrow = function () {\n  return !this.canInsertSemicolon();\n};\n\npp$3.parseArrow = function (node) {\n  if (this.eat(types.arrow)) {\n    return node;\n  }\n};\n\npp$3.parseParenItem = function (node) {\n  return node;\n};\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call  at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\npp$3.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdentifier(true);\n\n  if (this.eat(types.dot)) {\n    var metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n    if (!this.state.inFunction) {\n      this.raise(metaProp.property.start, \"new.target can only be used in functions\");\n    }\n\n    return metaProp;\n  }\n\n  node.callee = this.parseNoCallExpr();\n\n  if (this.eat(types.parenL)) {\n    node.arguments = this.parseExprList(types.parenR);\n    this.toReferencedList(node.arguments);\n  } else {\n    node.arguments = [];\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function (isTagged) {\n  var elem = this.startNode();\n  if (this.state.value === null) {\n    if (!isTagged || !this.hasPlugin(\"templateInvalidEscapes\")) {\n      this.raise(this.state.invalidTemplateEscapePosition, \"Invalid escape sequence in template\");\n    } else {\n      this.state.invalidTemplateEscapePosition = null;\n    }\n  }\n  elem.value = {\n    raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.state.value\n  };\n  this.next();\n  elem.tail = this.match(types.backQuote);\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp$3.parseTemplate = function (isTagged) {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement(isTagged);\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function (isPattern, refShorthandDefaultPos) {\n  var decorators = [];\n  var propHash = Object.create(null);\n  var first = true;\n  var node = this.startNode();\n\n  node.properties = [];\n  this.next();\n\n  var firstRestLocation = null;\n\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    while (this.match(types.at)) {\n      decorators.push(this.parseDecorator());\n    }\n\n    var prop = this.startNode(),\n        isGenerator = false,\n        isAsync = false,\n        startPos = void 0,\n        startLoc = void 0;\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    if (this.hasPlugin(\"objectRestSpread\") && this.match(types.ellipsis)) {\n      prop = this.parseSpread(isPattern ? { start: 0 } : undefined);\n      prop.type = isPattern ? \"RestProperty\" : \"SpreadProperty\";\n      if (isPattern) this.toAssignable(prop.argument, true, \"object pattern\");\n      node.properties.push(prop);\n      if (isPattern) {\n        var position = this.state.start;\n        if (firstRestLocation !== null) {\n          this.unexpected(firstRestLocation, \"Cannot have multiple rest elements when destructuring\");\n        } else if (this.eat(types.braceR)) {\n          break;\n        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {\n          // TODO: temporary rollback\n          // this.unexpected(position, \"A trailing comma is not permitted after the rest element\");\n          continue;\n        } else {\n          firstRestLocation = position;\n          continue;\n        }\n      } else {\n        continue;\n      }\n    }\n\n    prop.method = false;\n    prop.shorthand = false;\n\n    if (isPattern || refShorthandDefaultPos) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    if (!isPattern && this.isContextual(\"async\")) {\n      if (isGenerator) this.unexpected();\n\n      var asyncId = this.parseIdentifier();\n      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {\n        prop.key = asyncId;\n        prop.computed = false;\n      } else {\n        isAsync = true;\n        if (this.hasPlugin(\"asyncGenerators\")) isGenerator = this.eat(types.star);\n        this.parsePropertyName(prop);\n      }\n    } else {\n      this.parsePropertyName(prop);\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);\n    this.checkPropClash(prop, propHash);\n\n    if (prop.shorthand) {\n      this.addExtra(prop, \"shorthand\", true);\n    }\n\n    node.properties.push(prop);\n  }\n\n  if (firstRestLocation !== null) {\n    this.unexpected(firstRestLocation, \"The rest element has to be the last element when destructuring\");\n  }\n\n  if (decorators.length) {\n    this.raise(this.state.start, \"You have trailing decorators with no property\");\n  }\n\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp$3.isGetterOrSetterMethod = function (prop, isPattern) {\n  return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || // get \"string\"() {}\n  this.match(types.num) || // get 1() {}\n  this.match(types.bracketL) || // get [\"string\"]() {}\n  this.match(types.name) || // get foo() {}\n  this.state.type.keyword // get debugger() {}\n  );\n};\n\n// get methods aren't allowed to have any parameters\n// set methods must have exactly 1 parameter\npp$3.checkGetterSetterParamCount = function (method) {\n  var paramCount = method.kind === \"get\" ? 0 : 1;\n  if (method.params.length !== paramCount) {\n    var start = method.start;\n    if (method.kind === \"get\") {\n      this.raise(start, \"getter should have no params\");\n    } else {\n      this.raise(start, \"setter should have exactly one param\");\n    }\n  }\n};\n\npp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) {\n  if (isAsync || isGenerator || this.match(types.parenL)) {\n    if (isPattern) this.unexpected();\n    prop.kind = \"method\";\n    prop.method = true;\n    this.parseMethod(prop, isGenerator, isAsync);\n\n    return this.finishNode(prop, \"ObjectMethod\");\n  }\n\n  if (this.isGetterOrSetterMethod(prop, isPattern)) {\n    if (isGenerator || isAsync) this.unexpected();\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    this.parseMethod(prop);\n    this.checkGetterSetterParamCount(prop);\n\n    return this.finishNode(prop, \"ObjectMethod\");\n  }\n};\n\npp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n\n    return this.finishNode(prop, \"ObjectProperty\");\n  }\n\n  if (!prop.computed && prop.key.type === \"Identifier\") {\n    this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n    } else if (this.match(types.eq) && refShorthandDefaultPos) {\n      if (!refShorthandDefaultPos.start) {\n        refShorthandDefaultPos.start = this.state.start;\n      }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n    } else {\n      prop.value = prop.key.__clone();\n    }\n    prop.shorthand = true;\n\n    return this.finishNode(prop, \"ObjectProperty\");\n  }\n};\n\npp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {\n  var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n\n  if (!node) this.unexpected();\n\n  return node;\n};\n\npp$3.parsePropertyName = function (prop) {\n  if (this.eat(types.bracketL)) {\n    prop.computed = true;\n    prop.key = this.parseMaybeAssign();\n    this.expect(types.bracketR);\n  } else {\n    prop.computed = false;\n    var oldInPropertyName = this.state.inPropertyName;\n    this.state.inPropertyName = true;\n    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    this.state.inPropertyName = oldInPropertyName;\n  }\n  return prop.key;\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function (node, isAsync) {\n  node.id = null;\n  node.generator = false;\n  node.expression = false;\n  node.async = !!isAsync;\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function (node, isGenerator, isAsync) {\n  var oldInMethod = this.state.inMethod;\n  this.state.inMethod = node.kind || true;\n  this.initFunction(node, isAsync);\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR);\n  node.generator = !!isGenerator;\n  this.parseFunctionBody(node);\n  this.state.inMethod = oldInMethod;\n  return node;\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function (node, params, isAsync) {\n  this.initFunction(node, isAsync);\n  node.params = this.toAssignableList(params, true, \"arrow function parameters\");\n  this.parseFunctionBody(node, true);\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\npp$3.isStrictBody = function (node, isExpression) {\n  if (!isExpression && node.body.directives.length) {\n    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var directive = _ref2;\n\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Parse function body and check parameters.\npp$3.parseFunctionBody = function (node, allowExpression) {\n  var isExpression = allowExpression && !this.match(types.braceL);\n\n  var oldInAsync = this.state.inAsync;\n  this.state.inAsync = node.async;\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = this.state.inFunction;\n    var oldInGen = this.state.inGenerator;\n    var oldLabels = this.state.labels;\n    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];\n    node.body = this.parseBlock(true);\n    node.expression = false;\n    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;\n  }\n  this.state.inAsync = oldInAsync;\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  var isStrict = this.isStrictBody(node, isExpression);\n  // Also check when allowExpression === true for arrow functions\n  var checkLVal = this.state.strict || allowExpression || isStrict;\n\n  if (isStrict && node.id && node.id.type === \"Identifier\" && node.id.name === \"yield\") {\n    this.raise(node.id.start, \"Binding yield in strict mode\");\n  }\n\n  if (checkLVal) {\n    var nameHash = Object.create(null);\n    var oldStrict = this.state.strict;\n    if (isStrict) this.state.strict = true;\n    if (node.id) {\n      this.checkLVal(node.id, true, undefined, \"function name\");\n    }\n    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var param = _ref3;\n\n      if (isStrict && param.type !== \"Identifier\") {\n        this.raise(param.start, \"Non-simple parameter in strict mode\");\n      }\n      this.checkLVal(param, true, nameHash, \"function parameter list\");\n    }\n    this.state.strict = oldStrict;\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {\n  var elts = [];\n  var first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(close)) break;\n    }\n\n    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\n  }\n  return elts;\n};\n\npp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {\n  var elt = void 0;\n  if (allowEmpty && this.match(types.comma)) {\n    elt = null;\n  } else if (this.match(types.ellipsis)) {\n    elt = this.parseSpread(refShorthandDefaultPos);\n  } else {\n    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);\n  }\n  return elt;\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdentifier = function (liberal) {\n  var node = this.startNode();\n  if (!liberal) {\n    this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);\n  }\n\n  if (this.match(types.name)) {\n    node.name = this.state.value;\n  } else if (this.state.type.keyword) {\n    node.name = this.state.type.keyword;\n  } else {\n    this.unexpected();\n  }\n\n  if (!liberal && node.name === \"await\" && this.state.inAsync) {\n    this.raise(node.start, \"invalid use of await inside of an async function\");\n  }\n\n  node.loc.identifierName = node.name;\n\n  this.next();\n  return this.finishNode(node, \"Identifier\");\n};\n\npp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {\n  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {\n    this.raise(startLoc, word + \" is a reserved word\");\n  }\n\n  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {\n    this.raise(startLoc, word + \" is a reserved word in strict mode\");\n  }\n};\n\n// Parses await expression inside async function.\n\npp$3.parseAwait = function (node) {\n  // istanbul ignore next: this condition is checked at the call site so won't be hit here\n  if (!this.state.inAsync) {\n    this.unexpected();\n  }\n  if (this.match(types.star)) {\n    this.raise(node.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\");\n  }\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\");\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\");\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$4 = Parser.prototype;\nvar commentKeys = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar Node = function () {\n  function Node(pos, loc, filename) {\n    classCallCheck(this, Node);\n\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (filename) this.loc.filename = filename;\n  }\n\n  Node.prototype.__clone = function __clone() {\n    var node2 = new Node();\n    for (var key in this) {\n      // Do not clone comments that are already attached to the node\n      if (commentKeys.indexOf(key) < 0) {\n        node2[key] = this[key];\n      }\n    }\n\n    return node2;\n  };\n\n  return Node;\n}();\n\npp$4.startNode = function () {\n  return new Node(this.state.start, this.state.startLoc, this.filename);\n};\n\npp$4.startNodeAt = function (pos, loc) {\n  return new Node(pos, loc, this.filename);\n};\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  node.loc.end = loc;\n  this.processComment(node);\n  return node;\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\npp$4.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n};\n\n// Finish node at given position\n\npp$4.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n};\n\nvar pp$5 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$5.raise = function (pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;\n  err.loc = loc;\n  throw err;\n};\n\n/* eslint max-len: 0 */\n\n/**\n * Based on the comment attachment algorithm used in espree and estraverse.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nvar pp$6 = Parser.prototype;\n\npp$6.addComment = function (comment) {\n  if (this.filename) comment.loc.filename = this.filename;\n  this.state.trailingComments.push(comment);\n  this.state.leadingComments.push(comment);\n};\n\npp$6.processComment = function (node) {\n  if (node.type === \"Program\" && node.body.length > 0) return;\n\n  var stack = this.state.commentStack;\n\n  var firstChild = void 0,\n      lastChild = void 0,\n      trailingComments = void 0,\n      i = void 0,\n      j = void 0;\n\n  if (this.state.trailingComments.length > 0) {\n    // If the first comment in trailingComments comes after the\n    // current node, then we're good - all comments in the array will\n    // come after the node and so it's safe to add them as official\n    // trailingComments.\n    if (this.state.trailingComments[0].start >= node.end) {\n      trailingComments = this.state.trailingComments;\n      this.state.trailingComments = [];\n    } else {\n      // Otherwise, if the first comment doesn't come after the\n      // current node, that means we have a mix of leading and trailing\n      // comments in the array and that leadingComments contains the\n      // same items as trailingComments. Reset trailingComments to\n      // zero items and we'll handle this by evaluating leadingComments\n      // later.\n      this.state.trailingComments.length = 0;\n    }\n  } else {\n    var lastInStack = last(stack);\n    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n      trailingComments = lastInStack.trailingComments;\n      lastInStack.trailingComments = null;\n    }\n  }\n\n  // Eating the stack.\n  if (stack.length > 0 && last(stack).start >= node.start) {\n    firstChild = stack.pop();\n  }\n\n  while (stack.length > 0 && last(stack).start >= node.start) {\n    lastChild = stack.pop();\n  }\n\n  if (!lastChild && firstChild) lastChild = firstChild;\n\n  // Attach comments that follow a trailing comma on the last\n  // property in an object literal or a trailing comma in function arguments\n  // as trailing comments\n  if (firstChild && this.state.leadingComments.length > 0) {\n    var lastComment = last(this.state.leadingComments);\n\n    if (firstChild.type === \"ObjectProperty\") {\n      if (lastComment.start >= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n\n          if (this.state.leadingComments.length > 0) {\n            firstChild.trailingComments = this.state.leadingComments;\n            this.state.leadingComments = [];\n          }\n        }\n      }\n    } else if (node.type === \"CallExpression\" && node.arguments && node.arguments.length) {\n      var lastArg = last(node.arguments);\n\n      if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {\n        if (this.state.commentPreviousNode) {\n          if (this.state.leadingComments.length > 0) {\n            lastArg.trailingComments = this.state.leadingComments;\n            this.state.leadingComments = [];\n          }\n        }\n      }\n    }\n  }\n\n  if (lastChild) {\n    if (lastChild.leadingComments) {\n      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {\n        node.leadingComments = lastChild.leadingComments;\n        lastChild.leadingComments = null;\n      } else {\n        // A leading comment for an anonymous class had been stolen by its first ClassMethod,\n        // so this takes back the leading comment.\n        // See also: https://github.com/eslint/espree/issues/158\n        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n          if (lastChild.leadingComments[i].end <= node.start) {\n            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n            break;\n          }\n        }\n      }\n    }\n  } else if (this.state.leadingComments.length > 0) {\n    if (last(this.state.leadingComments).end <= node.start) {\n      if (this.state.commentPreviousNode) {\n        for (j = 0; j < this.state.leadingComments.length; j++) {\n          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n            this.state.leadingComments.splice(j, 1);\n            j--;\n          }\n        }\n      }\n      if (this.state.leadingComments.length > 0) {\n        node.leadingComments = this.state.leadingComments;\n        this.state.leadingComments = [];\n      }\n    } else {\n      // https://github.com/eslint/espree/issues/2\n      //\n      // In special cases, such as return (without a value) and\n      // debugger, all comments will end up as leadingComments and\n      // will otherwise be eliminated. This step runs when the\n      // commentStack is empty and there are comments left\n      // in leadingComments.\n      //\n      // This loop figures out the stopping point between the actual\n      // leading and trailing comments by finding the location of the\n      // first comment that comes after the given node.\n      for (i = 0; i < this.state.leadingComments.length; i++) {\n        if (this.state.leadingComments[i].end > node.start) {\n          break;\n        }\n      }\n\n      // Split the array based on the location of the first comment\n      // that comes after the node. Keep in mind that this could\n      // result in an empty array, and if so, the array must be\n      // deleted.\n      node.leadingComments = this.state.leadingComments.slice(0, i);\n      if (node.leadingComments.length === 0) {\n        node.leadingComments = null;\n      }\n\n      // Similarly, trailing comments are attached later. The variable\n      // must be reset to null if there are no trailing comments.\n      trailingComments = this.state.leadingComments.slice(i);\n      if (trailingComments.length === 0) {\n        trailingComments = null;\n      }\n    }\n  }\n\n  this.state.commentPreviousNode = node;\n\n  if (trailingComments) {\n    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n      node.innerComments = trailingComments;\n    } else {\n      node.trailingComments = trailingComments;\n    }\n  }\n\n  stack.push(node);\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.estreeParseRegExpLiteral = function (_ref) {\n  var pattern = _ref.pattern,\n      flags = _ref.flags;\n\n  var regex = null;\n  try {\n    regex = new RegExp(pattern, flags);\n  } catch (e) {\n    // In environments that don't support these flags value will\n    // be null as the regex can't be represented natively.\n  }\n  var node = this.estreeParseLiteral(regex);\n  node.regex = { pattern: pattern, flags: flags };\n\n  return node;\n};\n\npp$7.estreeParseLiteral = function (value) {\n  return this.parseLiteral(value, \"Literal\");\n};\n\npp$7.directiveToStmt = function (directive) {\n  var directiveLiteral = directive.value;\n\n  var stmt = this.startNodeAt(directive.start, directive.loc.start);\n  var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n\n  expression.value = directiveLiteral.value;\n  expression.raw = directiveLiteral.extra.raw;\n\n  stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n  stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n\n  return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n};\n\nfunction isSimpleProperty(node) {\n  return node && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estreePlugin = function (instance) {\n  instance.extend(\"checkDeclaration\", function (inner) {\n    return function (node) {\n      if (isSimpleProperty(node)) {\n        this.checkDeclaration(node.value);\n      } else {\n        inner.call(this, node);\n      }\n    };\n  });\n\n  instance.extend(\"checkGetterSetterParamCount\", function () {\n    return function (prop) {\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.start;\n        if (prop.kind === \"get\") {\n          this.raise(start, \"getter should have no params\");\n        } else {\n          this.raise(start, \"setter should have exactly one param\");\n        }\n      }\n    };\n  });\n\n  instance.extend(\"checkLVal\", function (inner) {\n    return function (expr, isBinding, checkClashes) {\n      var _this = this;\n\n      switch (expr.type) {\n        case \"ObjectPattern\":\n          expr.properties.forEach(function (prop) {\n            _this.checkLVal(prop.type === \"Property\" ? prop.value : prop, isBinding, checkClashes, \"object destructuring pattern\");\n          });\n          break;\n        default:\n          for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n            args[_key - 3] = arguments[_key];\n          }\n\n          inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));\n      }\n    };\n  });\n\n  instance.extend(\"checkPropClash\", function () {\n    return function (prop, propHash) {\n      if (prop.computed || !isSimpleProperty(prop)) return;\n\n      var key = prop.key;\n      // It is either an Identifier or a String/NumericLiteral\n      var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n      if (name === \"__proto__\") {\n        if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n        propHash.proto = true;\n      }\n    };\n  });\n\n  instance.extend(\"isStrictBody\", function () {\n    return function (node, isExpression) {\n      if (!isExpression && node.body.body.length > 0) {\n        for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref2;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref2 = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref2 = _i.value;\n          }\n\n          var directive = _ref2;\n\n          if (directive.type === \"ExpressionStatement\" && directive.expression.type === \"Literal\") {\n            if (directive.expression.value === \"use strict\") return true;\n          } else {\n            // Break for the first non literal expression\n            break;\n          }\n        }\n      }\n\n      return false;\n    };\n  });\n\n  instance.extend(\"isValidDirective\", function () {\n    return function (stmt) {\n      return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n    };\n  });\n\n  instance.extend(\"stmtToDirective\", function (inner) {\n    return function (stmt) {\n      var directive = inner.call(this, stmt);\n      var value = stmt.expression.value;\n\n      // Reset value to the actual value as in estree mode we want\n      // the stmt to have the real value and not the raw value\n      directive.value.value = value;\n\n      return directive;\n    };\n  });\n\n  instance.extend(\"parseBlockBody\", function (inner) {\n    return function (node) {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      inner.call.apply(inner, [this, node].concat(args));\n\n      node.directives.reverse().forEach(function (directive) {\n        node.body.unshift(_this2.directiveToStmt(directive));\n      });\n      delete node.directives;\n    };\n  });\n\n  instance.extend(\"parseClassMethod\", function () {\n    return function (classBody, method, isGenerator, isAsync) {\n      this.parseMethod(method, isGenerator, isAsync);\n      if (method.typeParameters) {\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n    };\n  });\n\n  instance.extend(\"parseExprAtom\", function (inner) {\n    return function () {\n      switch (this.state.type) {\n        case types.regexp:\n          return this.estreeParseRegExpLiteral(this.state.value);\n\n        case types.num:\n        case types.string:\n          return this.estreeParseLiteral(this.state.value);\n\n        case types._null:\n          return this.estreeParseLiteral(null);\n\n        case types._true:\n          return this.estreeParseLiteral(true);\n\n        case types._false:\n          return this.estreeParseLiteral(false);\n\n        default:\n          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return inner.call.apply(inner, [this].concat(args));\n      }\n    };\n  });\n\n  instance.extend(\"parseLiteral\", function (inner) {\n    return function () {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseMethod\", function (inner) {\n    return function (node) {\n      var funcNode = this.startNode();\n      funcNode.kind = node.kind; // provide kind, so inner method correctly sets state\n\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      funcNode = inner.call.apply(inner, [this, funcNode].concat(args));\n      delete funcNode.kind;\n      node.value = this.finishNode(funcNode, \"FunctionExpression\");\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseObjectMethod\", function (inner) {\n    return function () {\n      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n\n      if (node) {\n        if (node.kind === \"method\") node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseObjectProperty\", function (inner) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"toAssignable\", function (inner) {\n    return function (node, isBinding) {\n      for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        args[_key8 - 2] = arguments[_key8];\n      }\n\n      if (isSimpleProperty(node)) {\n        this.toAssignable.apply(this, [node.value, isBinding].concat(args));\n\n        return node;\n      } else if (node.type === \"ObjectExpression\") {\n        node.type = \"ObjectPattern\";\n        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref3 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref3 = _i2.value;\n          }\n\n          var prop = _ref3;\n\n          if (prop.kind === \"get\" || prop.kind === \"set\") {\n            this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n          } else if (prop.method) {\n            this.raise(prop.key.start, \"Object pattern can't contain methods\");\n          } else {\n            this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n          }\n        }\n\n        return node;\n      }\n\n      return inner.call.apply(inner, [this, node, isBinding].concat(args));\n    };\n  });\n};\n\n/* eslint max-len: 0 */\n\nvar primitiveTypes = [\"any\", \"mixed\", \"empty\", \"bool\", \"boolean\", \"number\", \"string\", \"void\", \"null\"];\n\nvar pp$8 = Parser.prototype;\n\npp$8.flowParseTypeInitialiser = function (tok) {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  this.expect(tok || types.colon);\n\n  var type = this.flowParseType();\n  this.state.inType = oldInType;\n  return type;\n};\n\npp$8.flowParsePredicate = function () {\n  var node = this.startNode();\n  var moduloLoc = this.state.startLoc;\n  var moduloPos = this.state.start;\n  this.expect(types.modulo);\n  var checksLoc = this.state.startLoc;\n  this.expectContextual(\"checks\");\n  // Force '%' and 'checks' to be adjacent\n  if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n    this.raise(moduloPos, \"Spaces between % and checks are not allowed here.\");\n  }\n  if (this.eat(types.parenL)) {\n    node.expression = this.parseExpression();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"DeclaredPredicate\");\n  } else {\n    return this.finishNode(node, \"InferredPredicate\");\n  }\n};\n\npp$8.flowParseTypeAndPredicateInitialiser = function () {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  this.expect(types.colon);\n  var type = null;\n  var predicate = null;\n  if (this.match(types.modulo)) {\n    this.state.inType = oldInType;\n    predicate = this.flowParsePredicate();\n  } else {\n    type = this.flowParseType();\n    this.state.inType = oldInType;\n    if (this.match(types.modulo)) {\n      predicate = this.flowParsePredicate();\n    }\n  }\n  return [type, predicate];\n};\n\npp$8.flowParseDeclareClass = function (node) {\n  this.next();\n  this.flowParseInterfaceish(node, true);\n  return this.finishNode(node, \"DeclareClass\");\n};\n\npp$8.flowParseDeclareFunction = function (node) {\n  this.next();\n\n  var id = node.id = this.parseIdentifier();\n\n  var typeNode = this.startNode();\n  var typeContainer = this.startNode();\n\n  if (this.isRelational(\"<\")) {\n    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    typeNode.typeParameters = null;\n  }\n\n  this.expect(types.parenL);\n  var tmp = this.flowParseFunctionTypeParams();\n  typeNode.params = tmp.params;\n  typeNode.rest = tmp.rest;\n  this.expect(types.parenR);\n  var predicate = null;\n\n  var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();\n\n  typeNode.returnType = _flowParseTypeAndPred[0];\n  predicate = _flowParseTypeAndPred[1];\n\n  typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n  typeContainer.predicate = predicate;\n  id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n  this.finishNode(id, id.type);\n\n  this.semicolon();\n\n  return this.finishNode(node, \"DeclareFunction\");\n};\n\npp$8.flowParseDeclare = function (node) {\n  if (this.match(types._class)) {\n    return this.flowParseDeclareClass(node);\n  } else if (this.match(types._function)) {\n    return this.flowParseDeclareFunction(node);\n  } else if (this.match(types._var)) {\n    return this.flowParseDeclareVariable(node);\n  } else if (this.isContextual(\"module\")) {\n    if (this.lookahead().type === types.dot) {\n      return this.flowParseDeclareModuleExports(node);\n    } else {\n      return this.flowParseDeclareModule(node);\n    }\n  } else if (this.isContextual(\"type\")) {\n    return this.flowParseDeclareTypeAlias(node);\n  } else if (this.isContextual(\"opaque\")) {\n    return this.flowParseDeclareOpaqueType(node);\n  } else if (this.isContextual(\"interface\")) {\n    return this.flowParseDeclareInterface(node);\n  } else if (this.match(types._export)) {\n    return this.flowParseDeclareExportDeclaration(node);\n  } else {\n    this.unexpected();\n  }\n};\n\npp$8.flowParseDeclareExportDeclaration = function (node) {\n  this.expect(types._export);\n  if (this.isContextual(\"opaque\") // declare export opaque ...\n  ) {\n      node.declaration = this.flowParseDeclare(this.startNode());\n      node.default = false;\n\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    }\n\n  throw this.unexpected();\n};\n\npp$8.flowParseDeclareVariable = function (node) {\n  this.next();\n  node.id = this.flowParseTypeAnnotatableIdentifier();\n  this.semicolon();\n  return this.finishNode(node, \"DeclareVariable\");\n};\n\npp$8.flowParseDeclareModule = function (node) {\n  this.next();\n\n  if (this.match(types.string)) {\n    node.id = this.parseExprAtom();\n  } else {\n    node.id = this.parseIdentifier();\n  }\n\n  var bodyNode = node.body = this.startNode();\n  var body = bodyNode.body = [];\n  this.expect(types.braceL);\n  while (!this.match(types.braceR)) {\n    var _bodyNode = this.startNode();\n\n    if (this.match(types._import)) {\n      var lookahead = this.lookahead();\n      if (lookahead.value !== \"type\" && lookahead.value !== \"typeof\") {\n        this.unexpected(null, \"Imports within a `declare module` body must always be `import type` or `import typeof`\");\n      }\n\n      this.parseImport(_bodyNode);\n    } else {\n      this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\");\n\n      _bodyNode = this.flowParseDeclare(_bodyNode, true);\n    }\n\n    body.push(_bodyNode);\n  }\n  this.expect(types.braceR);\n\n  this.finishNode(bodyNode, \"BlockStatement\");\n  return this.finishNode(node, \"DeclareModule\");\n};\n\npp$8.flowParseDeclareModuleExports = function (node) {\n  this.expectContextual(\"module\");\n  this.expect(types.dot);\n  this.expectContextual(\"exports\");\n  node.typeAnnotation = this.flowParseTypeAnnotation();\n  this.semicolon();\n\n  return this.finishNode(node, \"DeclareModuleExports\");\n};\n\npp$8.flowParseDeclareTypeAlias = function (node) {\n  this.next();\n  this.flowParseTypeAlias(node);\n  return this.finishNode(node, \"DeclareTypeAlias\");\n};\n\npp$8.flowParseDeclareOpaqueType = function (node) {\n  this.next();\n  this.flowParseOpaqueType(node, true);\n  return this.finishNode(node, \"DeclareOpaqueType\");\n};\n\npp$8.flowParseDeclareInterface = function (node) {\n  this.next();\n  this.flowParseInterfaceish(node);\n  return this.finishNode(node, \"DeclareInterface\");\n};\n\n// Interfaces\n\npp$8.flowParseInterfaceish = function (node) {\n  node.id = this.parseIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  node.extends = [];\n  node.mixins = [];\n\n  if (this.eat(types._extends)) {\n    do {\n      node.extends.push(this.flowParseInterfaceExtends());\n    } while (this.eat(types.comma));\n  }\n\n  if (this.isContextual(\"mixins\")) {\n    this.next();\n    do {\n      node.mixins.push(this.flowParseInterfaceExtends());\n    } while (this.eat(types.comma));\n  }\n\n  node.body = this.flowParseObjectType(true, false, false);\n};\n\npp$8.flowParseInterfaceExtends = function () {\n  var node = this.startNode();\n\n  node.id = this.flowParseQualifiedTypeIdentifier();\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterInstantiation();\n  } else {\n    node.typeParameters = null;\n  }\n\n  return this.finishNode(node, \"InterfaceExtends\");\n};\n\npp$8.flowParseInterface = function (node) {\n  this.flowParseInterfaceish(node, false);\n  return this.finishNode(node, \"InterfaceDeclaration\");\n};\n\npp$8.flowParseRestrictedIdentifier = function (liberal) {\n  if (primitiveTypes.indexOf(this.state.value) > -1) {\n    this.raise(this.state.start, \"Cannot overwrite primitive type \" + this.state.value);\n  }\n\n  return this.parseIdentifier(liberal);\n};\n\n// Type aliases\n\npp$8.flowParseTypeAlias = function (node) {\n  node.id = this.flowParseRestrictedIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  node.right = this.flowParseTypeInitialiser(types.eq);\n  this.semicolon();\n\n  return this.finishNode(node, \"TypeAlias\");\n};\n\n// Opaque type aliases\n\npp$8.flowParseOpaqueType = function (node, declare) {\n  this.expectContextual(\"type\");\n  node.id = this.flowParseRestrictedIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  // Parse the supertype\n  node.supertype = null;\n  if (this.match(types.colon)) {\n    node.supertype = this.flowParseTypeInitialiser(types.colon);\n  }\n\n  node.impltype = null;\n  if (!declare) {\n    node.impltype = this.flowParseTypeInitialiser(types.eq);\n  }\n  this.semicolon();\n\n  return this.finishNode(node, \"OpaqueType\");\n};\n\n// Type annotations\n\npp$8.flowParseTypeParameter = function () {\n  var node = this.startNode();\n\n  var variance = this.flowParseVariance();\n\n  var ident = this.flowParseTypeAnnotatableIdentifier();\n  node.name = ident.name;\n  node.variance = variance;\n  node.bound = ident.typeAnnotation;\n\n  if (this.match(types.eq)) {\n    this.eat(types.eq);\n    node.default = this.flowParseType();\n  }\n\n  return this.finishNode(node, \"TypeParameter\");\n};\n\npp$8.flowParseTypeParameterDeclaration = function () {\n  var oldInType = this.state.inType;\n  var node = this.startNode();\n  node.params = [];\n\n  this.state.inType = true;\n\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n    this.next();\n  } else {\n    this.unexpected();\n  }\n\n  do {\n    node.params.push(this.flowParseTypeParameter());\n    if (!this.isRelational(\">\")) {\n      this.expect(types.comma);\n    }\n  } while (!this.isRelational(\">\"));\n  this.expectRelational(\">\");\n\n  this.state.inType = oldInType;\n\n  return this.finishNode(node, \"TypeParameterDeclaration\");\n};\n\npp$8.flowParseTypeParameterInstantiation = function () {\n  var node = this.startNode();\n  var oldInType = this.state.inType;\n  node.params = [];\n\n  this.state.inType = true;\n\n  this.expectRelational(\"<\");\n  while (!this.isRelational(\">\")) {\n    node.params.push(this.flowParseType());\n    if (!this.isRelational(\">\")) {\n      this.expect(types.comma);\n    }\n  }\n  this.expectRelational(\">\");\n\n  this.state.inType = oldInType;\n\n  return this.finishNode(node, \"TypeParameterInstantiation\");\n};\n\npp$8.flowParseObjectPropertyKey = function () {\n  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n};\n\npp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) {\n  node.static = isStatic;\n\n  this.expect(types.bracketL);\n  if (this.lookahead().type === types.colon) {\n    node.id = this.flowParseObjectPropertyKey();\n    node.key = this.flowParseTypeInitialiser();\n  } else {\n    node.id = null;\n    node.key = this.flowParseType();\n  }\n  this.expect(types.bracketR);\n  node.value = this.flowParseTypeInitialiser();\n  node.variance = variance;\n\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeIndexer\");\n};\n\npp$8.flowParseObjectTypeMethodish = function (node) {\n  node.params = [];\n  node.rest = null;\n  node.typeParameters = null;\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  }\n\n  this.expect(types.parenL);\n  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n    node.params.push(this.flowParseFunctionTypeParam());\n    if (!this.match(types.parenR)) {\n      this.expect(types.comma);\n    }\n  }\n\n  if (this.eat(types.ellipsis)) {\n    node.rest = this.flowParseFunctionTypeParam();\n  }\n  this.expect(types.parenR);\n  node.returnType = this.flowParseTypeInitialiser();\n\n  return this.finishNode(node, \"FunctionTypeAnnotation\");\n};\n\npp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));\n  node.static = isStatic;\n  node.key = key;\n  node.optional = false;\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeProperty\");\n};\n\npp$8.flowParseObjectTypeCallProperty = function (node, isStatic) {\n  var valueNode = this.startNode();\n  node.static = isStatic;\n  node.value = this.flowParseObjectTypeMethodish(valueNode);\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeCallProperty\");\n};\n\npp$8.flowParseObjectType = function (allowStatic, allowExact, allowSpread) {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n\n  var nodeStart = this.startNode();\n  var node = void 0;\n  var propertyKey = void 0;\n  var isStatic = false;\n\n  nodeStart.callProperties = [];\n  nodeStart.properties = [];\n  nodeStart.indexers = [];\n\n  var endDelim = void 0;\n  var exact = void 0;\n  if (allowExact && this.match(types.braceBarL)) {\n    this.expect(types.braceBarL);\n    endDelim = types.braceBarR;\n    exact = true;\n  } else {\n    this.expect(types.braceL);\n    endDelim = types.braceR;\n    exact = false;\n  }\n\n  nodeStart.exact = exact;\n\n  while (!this.match(endDelim)) {\n    var optional = false;\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    node = this.startNode();\n    if (allowStatic && this.isContextual(\"static\") && this.lookahead().type !== types.colon) {\n      this.next();\n      isStatic = true;\n    }\n\n    var variancePos = this.state.start;\n    var variance = this.flowParseVariance();\n\n    if (this.match(types.bracketL)) {\n      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n    } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      if (variance) {\n        this.unexpected(variancePos);\n      }\n      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n    } else {\n      if (this.match(types.ellipsis)) {\n        if (!allowSpread) {\n          this.unexpected(null, \"Spread operator cannot appear in class or interface definitions\");\n        }\n        if (variance) {\n          this.unexpected(variance.start, \"Spread properties cannot have variance\");\n        }\n        this.expect(types.ellipsis);\n        node.argument = this.flowParseType();\n        this.flowObjectTypeSemicolon();\n        nodeStart.properties.push(this.finishNode(node, \"ObjectTypeSpreadProperty\"));\n      } else {\n        propertyKey = this.flowParseObjectPropertyKey();\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          // This is a method property\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n          nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));\n        } else {\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n          node.key = propertyKey;\n          node.value = this.flowParseTypeInitialiser();\n          node.optional = optional;\n          node.static = isStatic;\n          node.variance = variance;\n          this.flowObjectTypeSemicolon();\n          nodeStart.properties.push(this.finishNode(node, \"ObjectTypeProperty\"));\n        }\n      }\n    }\n\n    isStatic = false;\n  }\n\n  this.expect(endDelim);\n\n  var out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n  this.state.inType = oldInType;\n\n  return out;\n};\n\npp$8.flowObjectTypeSemicolon = function () {\n  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n    this.unexpected();\n  }\n};\n\npp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n  var node = id || this.parseIdentifier();\n\n  while (this.eat(types.dot)) {\n    var node2 = this.startNodeAt(startPos, startLoc);\n    node2.qualification = node;\n    node2.id = this.parseIdentifier();\n    node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n  }\n\n  return node;\n};\n\npp$8.flowParseGenericType = function (startPos, startLoc, id) {\n  var node = this.startNodeAt(startPos, startLoc);\n\n  node.typeParameters = null;\n  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterInstantiation();\n  }\n\n  return this.finishNode(node, \"GenericTypeAnnotation\");\n};\n\npp$8.flowParseTypeofType = function () {\n  var node = this.startNode();\n  this.expect(types._typeof);\n  node.argument = this.flowParsePrimaryType();\n  return this.finishNode(node, \"TypeofTypeAnnotation\");\n};\n\npp$8.flowParseTupleType = function () {\n  var node = this.startNode();\n  node.types = [];\n  this.expect(types.bracketL);\n  // We allow trailing commas\n  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {\n    node.types.push(this.flowParseType());\n    if (this.match(types.bracketR)) break;\n    this.expect(types.comma);\n  }\n  this.expect(types.bracketR);\n  return this.finishNode(node, \"TupleTypeAnnotation\");\n};\n\npp$8.flowParseFunctionTypeParam = function () {\n  var name = null;\n  var optional = false;\n  var typeAnnotation = null;\n  var node = this.startNode();\n  var lh = this.lookahead();\n  if (lh.type === types.colon || lh.type === types.question) {\n    name = this.parseIdentifier();\n    if (this.eat(types.question)) {\n      optional = true;\n    }\n    typeAnnotation = this.flowParseTypeInitialiser();\n  } else {\n    typeAnnotation = this.flowParseType();\n  }\n  node.name = name;\n  node.optional = optional;\n  node.typeAnnotation = typeAnnotation;\n  return this.finishNode(node, \"FunctionTypeParam\");\n};\n\npp$8.reinterpretTypeAsFunctionTypeParam = function (type) {\n  var node = this.startNodeAt(type.start, type.loc.start);\n  node.name = null;\n  node.optional = false;\n  node.typeAnnotation = type;\n  return this.finishNode(node, \"FunctionTypeParam\");\n};\n\npp$8.flowParseFunctionTypeParams = function () {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var ret = { params: params, rest: null };\n  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n    ret.params.push(this.flowParseFunctionTypeParam());\n    if (!this.match(types.parenR)) {\n      this.expect(types.comma);\n    }\n  }\n  if (this.eat(types.ellipsis)) {\n    ret.rest = this.flowParseFunctionTypeParam();\n  }\n  return ret;\n};\n\npp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {\n  switch (id.name) {\n    case \"any\":\n      return this.finishNode(node, \"AnyTypeAnnotation\");\n\n    case \"void\":\n      return this.finishNode(node, \"VoidTypeAnnotation\");\n\n    case \"bool\":\n    case \"boolean\":\n      return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n    case \"mixed\":\n      return this.finishNode(node, \"MixedTypeAnnotation\");\n\n    case \"empty\":\n      return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n    case \"number\":\n      return this.finishNode(node, \"NumberTypeAnnotation\");\n\n    case \"string\":\n      return this.finishNode(node, \"StringTypeAnnotation\");\n\n    default:\n      return this.flowParseGenericType(startPos, startLoc, id);\n  }\n};\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\npp$8.flowParsePrimaryType = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var node = this.startNode();\n  var tmp = void 0;\n  var type = void 0;\n  var isGroupedType = false;\n  var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n  switch (this.state.type) {\n    case types.name:\n      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n    case types.braceL:\n      return this.flowParseObjectType(false, false, true);\n\n    case types.braceBarL:\n      return this.flowParseObjectType(false, true, true);\n\n    case types.bracketL:\n      return this.flowParseTupleType();\n\n    case types.relational:\n      if (this.state.value === \"<\") {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(types.parenL);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        this.expect(types.parenR);\n\n        this.expect(types.arrow);\n\n        node.returnType = this.flowParseType();\n\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      break;\n\n    case types.parenL:\n      this.next();\n\n      // Check to see if this is actually a grouped type\n      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        if (this.match(types.name)) {\n          var token = this.lookahead().type;\n          isGroupedType = token !== types.question && token !== types.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n          this.expect(types.parenR);\n          return type;\n        } else {\n          // Eat a comma if there is one\n          this.eat(types.comma);\n        }\n      }\n\n      if (type) {\n        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n      } else {\n        tmp = this.flowParseFunctionTypeParams();\n      }\n\n      node.params = tmp.params;\n      node.rest = tmp.rest;\n\n      this.expect(types.parenR);\n\n      this.expect(types.arrow);\n\n      node.returnType = this.flowParseType();\n\n      node.typeParameters = null;\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n    case types.string:\n      return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n    case types._true:case types._false:\n      node.value = this.match(types._true);\n      this.next();\n      return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n    case types.plusMin:\n      if (this.state.value === \"-\") {\n        this.next();\n        if (!this.match(types.num)) this.unexpected(null, \"Unexpected token, expected number\");\n\n        return this.parseLiteral(-this.state.value, \"NumericLiteralTypeAnnotation\", node.start, node.loc.start);\n      }\n\n      this.unexpected();\n    case types.num:\n      return this.parseLiteral(this.state.value, \"NumericLiteralTypeAnnotation\");\n\n    case types._null:\n      node.value = this.match(types._null);\n      this.next();\n      return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n    case types._this:\n      node.value = this.match(types._this);\n      this.next();\n      return this.finishNode(node, \"ThisTypeAnnotation\");\n\n    case types.star:\n      this.next();\n      return this.finishNode(node, \"ExistentialTypeParam\");\n\n    default:\n      if (this.state.type.keyword === \"typeof\") {\n        return this.flowParseTypeofType();\n      }\n  }\n\n  this.unexpected();\n};\n\npp$8.flowParsePostfixType = function () {\n  var startPos = this.state.start,\n      startLoc = this.state.startLoc;\n  var type = this.flowParsePrimaryType();\n  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.elementType = type;\n    this.expect(types.bracketL);\n    this.expect(types.bracketR);\n    type = this.finishNode(node, \"ArrayTypeAnnotation\");\n  }\n  return type;\n};\n\npp$8.flowParsePrefixType = function () {\n  var node = this.startNode();\n  if (this.eat(types.question)) {\n    node.typeAnnotation = this.flowParsePrefixType();\n    return this.finishNode(node, \"NullableTypeAnnotation\");\n  } else {\n    return this.flowParsePostfixType();\n  }\n};\n\npp$8.flowParseAnonFunctionWithoutParens = function () {\n  var param = this.flowParsePrefixType();\n  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n    var node = this.startNodeAt(param.start, param.loc.start);\n    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n    node.rest = null;\n    node.returnType = this.flowParseType();\n    node.typeParameters = null;\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  return param;\n};\n\npp$8.flowParseIntersectionType = function () {\n  var node = this.startNode();\n  this.eat(types.bitwiseAND);\n  var type = this.flowParseAnonFunctionWithoutParens();\n  node.types = [type];\n  while (this.eat(types.bitwiseAND)) {\n    node.types.push(this.flowParseAnonFunctionWithoutParens());\n  }\n  return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n};\n\npp$8.flowParseUnionType = function () {\n  var node = this.startNode();\n  this.eat(types.bitwiseOR);\n  var type = this.flowParseIntersectionType();\n  node.types = [type];\n  while (this.eat(types.bitwiseOR)) {\n    node.types.push(this.flowParseIntersectionType());\n  }\n  return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n};\n\npp$8.flowParseType = function () {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  var type = this.flowParseUnionType();\n  this.state.inType = oldInType;\n  return type;\n};\n\npp$8.flowParseTypeAnnotation = function () {\n  var node = this.startNode();\n  node.typeAnnotation = this.flowParseTypeInitialiser();\n  return this.finishNode(node, \"TypeAnnotation\");\n};\n\npp$8.flowParseTypeAndPredicateAnnotation = function () {\n  var node = this.startNode();\n\n  var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();\n\n  node.typeAnnotation = _flowParseTypeAndPred2[0];\n  node.predicate = _flowParseTypeAndPred2[1];\n\n  return this.finishNode(node, \"TypeAnnotation\");\n};\n\npp$8.flowParseTypeAnnotatableIdentifier = function () {\n  var ident = this.flowParseRestrictedIdentifier();\n  if (this.match(types.colon)) {\n    ident.typeAnnotation = this.flowParseTypeAnnotation();\n    this.finishNode(ident, ident.type);\n  }\n  return ident;\n};\n\npp$8.typeCastToParameter = function (node) {\n  node.expression.typeAnnotation = node.typeAnnotation;\n\n  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n};\n\npp$8.flowParseVariance = function () {\n  var variance = null;\n  if (this.match(types.plusMin)) {\n    if (this.state.value === \"+\") {\n      variance = \"plus\";\n    } else if (this.state.value === \"-\") {\n      variance = \"minus\";\n    }\n    this.next();\n  }\n  return variance;\n};\n\nvar flowPlugin = function (instance) {\n  // plain function return types: function name(): string {}\n  instance.extend(\"parseFunctionBody\", function (inner) {\n    return function (node, allowExpression) {\n      if (this.match(types.colon) && !allowExpression) {\n        // if allowExpression is true then we're parsing an arrow function and if\n        // there's a return type then it's been handled elsewhere\n        node.returnType = this.flowParseTypeAndPredicateAnnotation();\n      }\n\n      return inner.call(this, node, allowExpression);\n    };\n  });\n\n  // interfaces\n  instance.extend(\"parseStatement\", function (inner) {\n    return function (declaration, topLevel) {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        var node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      } else {\n        return inner.call(this, declaration, topLevel);\n      }\n    };\n  });\n\n  // declares, interfaces and type aliases\n  instance.extend(\"parseExpressionStatement\", function (inner) {\n    return function (node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return inner.call(this, node, expr);\n    };\n  });\n\n  // export type\n  instance.extend(\"shouldParseExportDeclaration\", function (inner) {\n    return function () {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || inner.call(this);\n    };\n  });\n\n  instance.extend(\"isExportDefaultSpecifier\", function (inner) {\n    return function () {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\")) {\n        return false;\n      }\n\n      return inner.call(this);\n    };\n  });\n\n  instance.extend(\"parseConditional\", function (inner) {\n    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (refNeedsArrowPos && this.match(types.question)) {\n        var state = this.state.clone();\n        try {\n          return inner.call(this, expr, noIn, startPos, startLoc);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n            refNeedsArrowPos.start = err.pos || this.state.start;\n            return expr;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      return inner.call(this, expr, noIn, startPos, startLoc);\n    };\n  });\n\n  instance.extend(\"parseParenItem\", function (inner) {\n    return function (node, startPos, startLoc) {\n      node = inner.call(this, node, startPos, startLoc);\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        var typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseExport\", function (inner) {\n    return function (node) {\n      node = inner.call(this, node);\n      if (node.type === \"ExportNamedDeclaration\") {\n        node.exportKind = node.exportKind || \"value\";\n      }\n      return node;\n    };\n  });\n\n  instance.extend(\"parseExportDeclaration\", function (inner) {\n    return function (node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n\n        var declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n\n        var _declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        return this.flowParseOpaqueType(_declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        var _declarationNode2 = this.startNode();\n        this.next();\n        return this.flowParseInterface(_declarationNode2);\n      } else {\n        return inner.call(this, node);\n      }\n    };\n  });\n\n  instance.extend(\"parseClassId\", function (inner) {\n    return function (node) {\n      inner.apply(this, arguments);\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    };\n  });\n\n  // don't consider `void` to be a keyword as then it'll use the void token type\n  // and set startExpr\n  instance.extend(\"isKeyword\", function (inner) {\n    return function (name) {\n      if (this.state.inType && name === \"void\") {\n        return false;\n      } else {\n        return inner.call(this, name);\n      }\n    };\n  });\n\n  // ensure that inside flow types, we bypass the jsx parser plugin\n  instance.extend(\"readToken\", function (inner) {\n    return function (code) {\n      if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else {\n        return inner.call(this, code);\n      }\n    };\n  });\n\n  // don't lex any token as a jsx one inside a flow type\n  instance.extend(\"jsx_readToken\", function (inner) {\n    return function () {\n      if (!this.state.inType) return inner.call(this);\n    };\n  });\n\n  instance.extend(\"toAssignable\", function (inner) {\n    return function (node, isBinding, contextDescription) {\n      if (node.type === \"TypeCastExpression\") {\n        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n      } else {\n        return inner.call(this, node, isBinding, contextDescription);\n      }\n    };\n  });\n\n  // turn type casts that we found in function parameter head into type annotated params\n  instance.extend(\"toAssignableList\", function (inner) {\n    return function (exprList, isBinding, contextDescription) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n        if (expr && expr.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      return inner.call(this, exprList, isBinding, contextDescription);\n    };\n  });\n\n  // this is a list of nodes, from something like a call expression, we need to filter the\n  // type casts that we've found that are illegal in this context\n  instance.extend(\"toReferencedList\", function () {\n    return function (exprList) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n        if (expr && expr._exprListItem && expr.type === \"TypeCastExpression\") {\n          this.raise(expr.start, \"Unexpected type cast\");\n        }\n      }\n\n      return exprList;\n    };\n  });\n\n  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents\n  // the position where this function is called\n  instance.extend(\"parseExprListItem\", function (inner) {\n    return function () {\n      var container = this.startNode();\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n      if (this.match(types.colon)) {\n        container._exprListItem = true;\n        container.expression = node;\n        container.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(container, \"TypeCastExpression\");\n      } else {\n        return node;\n      }\n    };\n  });\n\n  instance.extend(\"checkLVal\", function (inner) {\n    return function (node) {\n      if (node.type !== \"TypeCastExpression\") {\n        return inner.apply(this, arguments);\n      }\n    };\n  });\n\n  // parse class property type annotations\n  instance.extend(\"parseClassProperty\", function (inner) {\n    return function (node) {\n      delete node.variancePos;\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return inner.call(this, node);\n    };\n  });\n\n  // determine whether or not we're currently in the position where a class method would appear\n  instance.extend(\"isClassMethod\", function (inner) {\n    return function () {\n      return this.isRelational(\"<\") || inner.call(this);\n    };\n  });\n\n  // determine whether or not we're currently in the position where a class property would appear\n  instance.extend(\"isClassProperty\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n\n  instance.extend(\"isNonstaticConstructor\", function (inner) {\n    return function (method) {\n      return !this.match(types.colon) && inner.call(this, method);\n    };\n  });\n\n  // parse type parameters for class methods\n  instance.extend(\"parseClassMethod\", function (inner) {\n    return function (classBody, method) {\n      if (method.variance) {\n        this.unexpected(method.variancePos);\n      }\n      delete method.variance;\n      delete method.variancePos;\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      inner.call.apply(inner, [this, classBody, method].concat(args));\n    };\n  });\n\n  // parse a the super class type parameters and implements\n  instance.extend(\"parseClassSuper\", function (inner) {\n    return function (node, isStatement) {\n      inner.call(this, node, isStatement);\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        var implemented = node.implements = [];\n        do {\n          var _node = this.startNode();\n          _node.id = this.parseIdentifier();\n          if (this.isRelational(\"<\")) {\n            _node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            _node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(_node, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    };\n  });\n\n  instance.extend(\"parsePropertyName\", function (inner) {\n    return function (node) {\n      var variancePos = this.state.start;\n      var variance = this.flowParseVariance();\n      var key = inner.call(this, node);\n      node.variance = variance;\n      node.variancePos = variancePos;\n      return key;\n    };\n  });\n\n  // parse type parameters for object method shorthand\n  instance.extend(\"parseObjPropValue\", function (inner) {\n    return function (prop) {\n      if (prop.variance) {\n        this.unexpected(prop.variancePos);\n      }\n      delete prop.variance;\n      delete prop.variancePos;\n\n      var typeParameters = void 0;\n\n      // method shorthand\n      if (this.isRelational(\"<\")) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      inner.apply(this, arguments);\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    };\n  });\n\n  instance.extend(\"parseAssignableListItemTypes\", function () {\n    return function (param) {\n      if (this.eat(types.question)) {\n        param.optional = true;\n      }\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      this.finishNode(param, param.type);\n      return param;\n    };\n  });\n\n  instance.extend(\"parseMaybeDefault\", function (inner) {\n    return function () {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var node = inner.apply(this, args);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\");\n      }\n\n      return node;\n    };\n  });\n\n  // parse typeof and type imports\n  instance.extend(\"parseImportSpecifiers\", function (inner) {\n    return function (node) {\n      node.importKind = \"value\";\n\n      var kind = null;\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n      if (kind) {\n        var lh = this.lookahead();\n        if (lh.type === types.name && lh.value !== \"from\" || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      inner.call(this, node);\n    };\n  });\n\n  // parse import-type/typeof shorthand\n  instance.extend(\"parseImportSpecifier\", function () {\n    return function (node) {\n      var specifier = this.startNode();\n      var firstIdentLoc = this.state.start;\n      var firstIdent = this.parseIdentifier(true);\n\n      var specifierTypeKind = null;\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n\n      var isBinding = false;\n      if (this.isContextual(\"as\")) {\n        var as_ident = this.parseIdentifier(true);\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        // `import {type foo`\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      if ((node.importKind === \"type\" || node.importKind === \"typeof\") && (specifier.importKind === \"type\" || specifier.importKind === \"typeof\")) {\n        this.raise(firstIdentLoc, \"`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`\");\n      }\n\n      if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n\n      this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    };\n  });\n\n  // parse function type parameters - function foo<T>() {}\n  instance.extend(\"parseFunctionParams\", function (inner) {\n    return function (node) {\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      inner.call(this, node);\n    };\n  });\n\n  // parse flow type annotations on variable declarator heads - let foo: string = bar\n  instance.extend(\"parseVarHead\", function (inner) {\n    return function (decl) {\n      inner.call(this, decl);\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.finishNode(decl.id, decl.id.type);\n      }\n    };\n  });\n\n  // parse the return type of an async arrow function - let foo = (async (): number => {});\n  instance.extend(\"parseAsyncArrowFromCallExpression\", function (inner) {\n    return function (node, call) {\n      if (this.match(types.colon)) {\n        var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return inner.call(this, node, call);\n    };\n  });\n\n  // todo description\n  instance.extend(\"shouldParseAsyncArrow\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n\n  // We need to support type parameter declarations for arrow functions. This\n  // is tricky. There are three situations we need to handle\n  //\n  // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n  //    error.\n  // 2. This is an arrow function. We'll parse the type parameter declaration,\n  //    parse the rest, make sure the rest is an arrow function, and go from\n  //    there\n  // 3. This is neither. Just call the inner function\n  instance.extend(\"parseMaybeAssign\", function (inner) {\n    return function () {\n      var jsxError = null;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      if (types.jsxTagStart && this.match(types.jsxTagStart)) {\n        var state = this.state.clone();\n        try {\n          return inner.apply(this, args);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n\n            // Remove `tc.j_expr` and `tc.j_oTag` from context added\n            // by parsing `jsxTagStart` to stop the JSX plugin from\n            // messing with the tokens\n            this.state.context.length -= 2;\n\n            jsxError = err;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      if (jsxError != null || this.isRelational(\"<\")) {\n        var arrowExpression = void 0;\n        var typeParameters = void 0;\n        try {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          arrowExpression = inner.apply(this, args);\n          arrowExpression.typeParameters = typeParameters;\n          arrowExpression.start = typeParameters.start;\n          arrowExpression.loc.start = typeParameters.loc.start;\n        } catch (err) {\n          throw jsxError || err;\n        }\n\n        if (arrowExpression.type === \"ArrowFunctionExpression\") {\n          return arrowExpression;\n        } else if (jsxError != null) {\n          throw jsxError;\n        } else {\n          this.raise(typeParameters.start, \"Expected an arrow function after this type parameter declaration\");\n        }\n      }\n\n      return inner.apply(this, args);\n    };\n  });\n\n  // handle return types for arrow functions\n  instance.extend(\"parseArrow\", function (inner) {\n    return function (node) {\n      if (this.match(types.colon)) {\n        var state = this.state.clone();\n        try {\n          var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          var returnType = this.flowParseTypeAndPredicateAnnotation();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          // assign after it is clear it is an arrow\n          node.returnType = returnType;\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      return inner.call(this, node);\n    };\n  });\n\n  instance.extend(\"shouldParseArrow\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n};\n\n// Adapted from String.fromcodepoint to export the function without modifying String\n/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\n\n// The MIT License (MIT)\n// Copyright (c) Mathias Bynens\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n// associated documentation files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge, publish, distribute,\n// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or\n// substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar fromCodePoint = String.fromCodePoint;\n\nif (!fromCodePoint) {\n  var stringFromCharCode = String.fromCharCode;\n  var floor = Math.floor;\n  fromCodePoint = function fromCodePoint() {\n    var MAX_SIZE = 0x4000;\n    var codeUnits = [];\n    var highSurrogate = void 0;\n    var lowSurrogate = void 0;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return \"\";\n    }\n    var result = \"\";\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n      codePoint < 0 || // not a valid Unicode code point\n      codePoint > 0x10FFFF || // not a valid Unicode code point\n      floor(codePoint) != codePoint // not an integer\n      ) {\n          throw RangeError(\"Invalid code point: \" + codePoint);\n        }\n      if (codePoint <= 0xFFFF) {\n        // BMP code point\n        codeUnits.push(codePoint);\n      } else {\n        // Astral code point; split in surrogate halves\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = codePoint % 0x400 + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n      if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n        result += stringFromCharCode.apply(null, codeUnits);\n        codeUnits.length = 0;\n      }\n    }\n    return result;\n  };\n}\n\nvar fromCodePoint$1 = fromCodePoint;\n\nvar XHTMLEntities = {\n  quot: \"\\\"\",\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\xA0\",\n  iexcl: \"\\xA1\",\n  cent: \"\\xA2\",\n  pound: \"\\xA3\",\n  curren: \"\\xA4\",\n  yen: \"\\xA5\",\n  brvbar: \"\\xA6\",\n  sect: \"\\xA7\",\n  uml: \"\\xA8\",\n  copy: \"\\xA9\",\n  ordf: \"\\xAA\",\n  laquo: \"\\xAB\",\n  not: \"\\xAC\",\n  shy: \"\\xAD\",\n  reg: \"\\xAE\",\n  macr: \"\\xAF\",\n  deg: \"\\xB0\",\n  plusmn: \"\\xB1\",\n  sup2: \"\\xB2\",\n  sup3: \"\\xB3\",\n  acute: \"\\xB4\",\n  micro: \"\\xB5\",\n  para: \"\\xB6\",\n  middot: \"\\xB7\",\n  cedil: \"\\xB8\",\n  sup1: \"\\xB9\",\n  ordm: \"\\xBA\",\n  raquo: \"\\xBB\",\n  frac14: \"\\xBC\",\n  frac12: \"\\xBD\",\n  frac34: \"\\xBE\",\n  iquest: \"\\xBF\",\n  Agrave: \"\\xC0\",\n  Aacute: \"\\xC1\",\n  Acirc: \"\\xC2\",\n  Atilde: \"\\xC3\",\n  Auml: \"\\xC4\",\n  Aring: \"\\xC5\",\n  AElig: \"\\xC6\",\n  Ccedil: \"\\xC7\",\n  Egrave: \"\\xC8\",\n  Eacute: \"\\xC9\",\n  Ecirc: \"\\xCA\",\n  Euml: \"\\xCB\",\n  Igrave: \"\\xCC\",\n  Iacute: \"\\xCD\",\n  Icirc: \"\\xCE\",\n  Iuml: \"\\xCF\",\n  ETH: \"\\xD0\",\n  Ntilde: \"\\xD1\",\n  Ograve: \"\\xD2\",\n  Oacute: \"\\xD3\",\n  Ocirc: \"\\xD4\",\n  Otilde: \"\\xD5\",\n  Ouml: \"\\xD6\",\n  times: \"\\xD7\",\n  Oslash: \"\\xD8\",\n  Ugrave: \"\\xD9\",\n  Uacute: \"\\xDA\",\n  Ucirc: \"\\xDB\",\n  Uuml: \"\\xDC\",\n  Yacute: \"\\xDD\",\n  THORN: \"\\xDE\",\n  szlig: \"\\xDF\",\n  agrave: \"\\xE0\",\n  aacute: \"\\xE1\",\n  acirc: \"\\xE2\",\n  atilde: \"\\xE3\",\n  auml: \"\\xE4\",\n  aring: \"\\xE5\",\n  aelig: \"\\xE6\",\n  ccedil: \"\\xE7\",\n  egrave: \"\\xE8\",\n  eacute: \"\\xE9\",\n  ecirc: \"\\xEA\",\n  euml: \"\\xEB\",\n  igrave: \"\\xEC\",\n  iacute: \"\\xED\",\n  icirc: \"\\xEE\",\n  iuml: \"\\xEF\",\n  eth: \"\\xF0\",\n  ntilde: \"\\xF1\",\n  ograve: \"\\xF2\",\n  oacute: \"\\xF3\",\n  ocirc: \"\\xF4\",\n  otilde: \"\\xF5\",\n  ouml: \"\\xF6\",\n  divide: \"\\xF7\",\n  oslash: \"\\xF8\",\n  ugrave: \"\\xF9\",\n  uacute: \"\\xFA\",\n  ucirc: \"\\xFB\",\n  uuml: \"\\xFC\",\n  yacute: \"\\xFD\",\n  thorn: \"\\xFE\",\n  yuml: \"\\xFF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  \"int\": \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nvar HEX_NUMBER = /^[\\da-fA-F]+$/;\nvar DECIMAL_NUMBER = /^\\d+$/;\n\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\n\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", { beforeExpr: true });\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", { startsExpr: true });\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression\n  this.state.context.push(types$1.j_oTag); // start opening tag context\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  var out = this.state.context.pop();\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nvar pp$9 = Parser.prototype;\n\n// Reads inline JSX contents token.\n\npp$9.jsxReadToken = function () {\n  var out = \"\";\n  var chunkStart = this.state.pos;\n  for (;;) {\n    if (this.state.pos >= this.input.length) {\n      this.raise(this.state.start, \"Unterminated JSX contents\");\n    }\n\n    var ch = this.input.charCodeAt(this.state.pos);\n\n    switch (ch) {\n      case 60: // \"<\"\n      case 123:\n        // \"{\"\n        if (this.state.pos === this.state.start) {\n          if (ch === 60 && this.state.exprAllowed) {\n            ++this.state.pos;\n            return this.finishToken(types.jsxTagStart);\n          }\n          return this.getTokenFromCode(ch);\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        return this.finishToken(types.jsxText, out);\n\n      case 38:\n        // \"&\"\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n        break;\n\n      default:\n        if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(true);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n    }\n  }\n};\n\npp$9.jsxReadNewLine = function (normalizeCRLF) {\n  var ch = this.input.charCodeAt(this.state.pos);\n  var out = void 0;\n  ++this.state.pos;\n  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n    ++this.state.pos;\n    out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n  } else {\n    out = String.fromCharCode(ch);\n  }\n  ++this.state.curLine;\n  this.state.lineStart = this.state.pos;\n\n  return out;\n};\n\npp$9.jsxReadString = function (quote) {\n  var out = \"\";\n  var chunkStart = ++this.state.pos;\n  for (;;) {\n    if (this.state.pos >= this.input.length) {\n      this.raise(this.state.start, \"Unterminated string constant\");\n    }\n\n    var ch = this.input.charCodeAt(this.state.pos);\n    if (ch === quote) break;\n    if (ch === 38) {\n      // \"&\"\n      out += this.input.slice(chunkStart, this.state.pos);\n      out += this.jsxReadEntity();\n      chunkStart = this.state.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.state.pos);\n      out += this.jsxReadNewLine(false);\n      chunkStart = this.state.pos;\n    } else {\n      ++this.state.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.state.pos++);\n  return this.finishToken(types.string, out);\n};\n\npp$9.jsxReadEntity = function () {\n  var str = \"\";\n  var count = 0;\n  var entity = void 0;\n  var ch = this.input[this.state.pos];\n\n  var startPos = ++this.state.pos;\n  while (this.state.pos < this.input.length && count++ < 10) {\n    ch = this.input[this.state.pos++];\n    if (ch === \";\") {\n      if (str[0] === \"#\") {\n        if (str[1] === \"x\") {\n          str = str.substr(2);\n          if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16));\n        } else {\n          str = str.substr(1);\n          if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10));\n        }\n      } else {\n        entity = XHTMLEntities[str];\n      }\n      break;\n    }\n    str += ch;\n  }\n  if (!entity) {\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  return entity;\n};\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can\"t contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\npp$9.jsxReadWord = function () {\n  var ch = void 0;\n  var start = this.state.pos;\n  do {\n    ch = this.input.charCodeAt(++this.state.pos);\n  } while (isIdentifierChar(ch) || ch === 45); // \"-\"\n  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n};\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n}\n\n// Parse next token as JSX identifier\n\npp$9.jsxParseIdentifier = function () {\n  var node = this.startNode();\n  if (this.match(types.jsxName)) {\n    node.name = this.state.value;\n  } else if (this.state.type.keyword) {\n    node.name = this.state.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  return this.finishNode(node, \"JSXIdentifier\");\n};\n\n// Parse namespaced identifier.\n\npp$9.jsxParseNamespacedName = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var name = this.jsxParseIdentifier();\n  if (!this.eat(types.colon)) return name;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.namespace = name;\n  node.name = this.jsxParseIdentifier();\n  return this.finishNode(node, \"JSXNamespacedName\");\n};\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\n\npp$9.jsxParseElementName = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var node = this.jsxParseNamespacedName();\n  while (this.eat(types.dot)) {\n    var newNode = this.startNodeAt(startPos, startLoc);\n    newNode.object = node;\n    newNode.property = this.jsxParseIdentifier();\n    node = this.finishNode(newNode, \"JSXMemberExpression\");\n  }\n  return node;\n};\n\n// Parses any type of JSX attribute value.\n\npp$9.jsxParseAttributeValue = function () {\n  var node = void 0;\n  switch (this.state.type) {\n    case types.braceL:\n      node = this.jsxParseExpressionContainer();\n      if (node.expression.type === \"JSXEmptyExpression\") {\n        this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n      } else {\n        return node;\n      }\n\n    case types.jsxTagStart:\n    case types.string:\n      node = this.parseExprAtom();\n      node.extra = null;\n      return node;\n\n    default:\n      this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n  }\n};\n\n// JSXEmptyExpression is unique type since it doesn't actually parse anything,\n// and so it should start at the end of last read token (left brace) and finish\n// at the beginning of the next one (right brace).\n\npp$9.jsxParseEmptyExpression = function () {\n  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n  return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n};\n\n// Parse JSX spread child\n\npp$9.jsxParseSpreadChild = function () {\n  var node = this.startNode();\n  this.expect(types.braceL);\n  this.expect(types.ellipsis);\n  node.expression = this.parseExpression();\n  this.expect(types.braceR);\n\n  return this.finishNode(node, \"JSXSpreadChild\");\n};\n\n// Parses JSX expression enclosed into curly brackets.\n\n\npp$9.jsxParseExpressionContainer = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.match(types.braceR)) {\n    node.expression = this.jsxParseEmptyExpression();\n  } else {\n    node.expression = this.parseExpression();\n  }\n  this.expect(types.braceR);\n  return this.finishNode(node, \"JSXExpressionContainer\");\n};\n\n// Parses following JSX attribute name-value pair.\n\npp$9.jsxParseAttribute = function () {\n  var node = this.startNode();\n  if (this.eat(types.braceL)) {\n    this.expect(types.ellipsis);\n    node.argument = this.parseMaybeAssign();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadAttribute\");\n  }\n  node.name = this.jsxParseNamespacedName();\n  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n  return this.finishNode(node, \"JSXAttribute\");\n};\n\n// Parses JSX opening tag starting after \"<\".\n\npp$9.jsxParseOpeningElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.attributes = [];\n  node.name = this.jsxParseElementName();\n  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n    node.attributes.push(this.jsxParseAttribute());\n  }\n  node.selfClosing = this.eat(types.slash);\n  this.expect(types.jsxTagEnd);\n  return this.finishNode(node, \"JSXOpeningElement\");\n};\n\n// Parses JSX closing tag starting after \"</\".\n\npp$9.jsxParseClosingElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.name = this.jsxParseElementName();\n  this.expect(types.jsxTagEnd);\n  return this.finishNode(node, \"JSXClosingElement\");\n};\n\n// Parses entire JSX element, including it\"s opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n\npp$9.jsxParseElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  var children = [];\n  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n  var closingElement = null;\n\n  if (!openingElement.selfClosing) {\n    contents: for (;;) {\n      switch (this.state.type) {\n        case types.jsxTagStart:\n          startPos = this.state.start;startLoc = this.state.startLoc;\n          this.next();\n          if (this.eat(types.slash)) {\n            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n            break contents;\n          }\n          children.push(this.jsxParseElementAt(startPos, startLoc));\n          break;\n\n        case types.jsxText:\n          children.push(this.parseExprAtom());\n          break;\n\n        case types.braceL:\n          if (this.lookahead().type === types.ellipsis) {\n            children.push(this.jsxParseSpreadChild());\n          } else {\n            children.push(this.jsxParseExpressionContainer());\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          this.unexpected();\n      }\n    }\n\n    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n      this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n    }\n  }\n\n  node.openingElement = openingElement;\n  node.closingElement = closingElement;\n  node.children = children;\n  if (this.match(types.relational) && this.state.value === \"<\") {\n    this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n  }\n  return this.finishNode(node, \"JSXElement\");\n};\n\n// Parses entire JSX element from current position.\n\npp$9.jsxParseElement = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  this.next();\n  return this.jsxParseElementAt(startPos, startLoc);\n};\n\nvar jsxPlugin = function (instance) {\n  instance.extend(\"parseExprAtom\", function (inner) {\n    return function (refShortHandDefaultPos) {\n      if (this.match(types.jsxText)) {\n        var node = this.parseLiteral(this.state.value, \"JSXText\");\n        // https://github.com/babel/babel/issues/2078\n        node.extra = null;\n        return node;\n      } else if (this.match(types.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else {\n        return inner.call(this, refShortHandDefaultPos);\n      }\n    };\n  });\n\n  instance.extend(\"readToken\", function (inner) {\n    return function (code) {\n      if (this.state.inPropertyName) return inner.call(this, code);\n\n      var context = this.curContext();\n\n      if (context === types$1.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === types$1.j_oTag || context === types$1.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === 62) {\n          ++this.state.pos;\n          return this.finishToken(types.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (code === 60 && this.state.exprAllowed) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagStart);\n      }\n\n      return inner.call(this, code);\n    };\n  });\n\n  instance.extend(\"updateContext\", function (inner) {\n    return function (prevType) {\n      if (this.match(types.braceL)) {\n        var curContext = this.curContext();\n        if (curContext === types$1.j_oTag) {\n          this.state.context.push(types$1.braceExpression);\n        } else if (curContext === types$1.j_expr) {\n          this.state.context.push(types$1.templateQuasi);\n        } else {\n          inner.call(this, prevType);\n        }\n        this.state.exprAllowed = true;\n      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context\n        this.state.exprAllowed = false;\n      } else {\n        return inner.call(this, prevType);\n      }\n    };\n  });\n};\n\nplugins.estree = estreePlugin;\nplugins.flow = flowPlugin;\nplugins.jsx = jsxPlugin;\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse();\n}\n\nfunction parseExpression(input, options) {\n  var parser = new Parser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFieWxvbjYvbGliL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYnlsb242L2xpYi9pbmRleC5qcz8zYzY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxuLy8gVGhpcyBpcyBhIHRyaWNrIHRha2VuIGZyb20gRXNwcmltYS4gSXQgdHVybnMgb3V0IHRoYXQsIG9uXG4vLyBub24tQ2hyb21lIGJyb3dzZXJzLCB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nIGlzIGluIGEgc2V0LCBhXG4vLyBwcmVkaWNhdGUgY29udGFpbmluZyBhIGJpZyB1Z2x5IGBzd2l0Y2hgIHN0YXRlbWVudCBpcyBmYXN0ZXIgdGhhblxuLy8gYSByZWd1bGFyIGV4cHJlc3Npb24sIGFuZCBvbiBDaHJvbWUgdGhlIHR3byBhcmUgYWJvdXQgb24gcGFyLlxuLy8gVGhpcyBmdW5jdGlvbiB1c2VzIGBldmFsYCAobm9uLWxleGljYWwpIHRvIHByb2R1Y2Ugc3VjaCBhXG4vLyBwcmVkaWNhdGUgZnJvbSBhIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgb2Ygd29yZHMuXG4vL1xuLy8gSXQgc3RhcnRzIGJ5IHNvcnRpbmcgdGhlIHdvcmRzIGJ5IGxlbmd0aC5cblxuZnVuY3Rpb24gbWFrZVByZWRpY2F0ZSh3b3Jkcykge1xuICB3b3JkcyA9IHdvcmRzLnNwbGl0KFwiIFwiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gd29yZHMuaW5kZXhPZihzdHIpID49IDA7XG4gIH07XG59XG5cbi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICA2OiBtYWtlUHJlZGljYXRlKFwiZW51bSBhd2FpdFwiKSxcbiAgc3RyaWN0OiBtYWtlUHJlZGljYXRlKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKSxcbiAgc3RyaWN0QmluZDogbWFrZVByZWRpY2F0ZShcImV2YWwgYXJndW1lbnRzXCIpXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBpc0tleXdvcmQgPSBtYWtlUHJlZGljYXRlKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzIGxldCBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgeWllbGQgc3VwZXJcIik7XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwQ1xcdTIwMERcXHhCN1xcdTAzMDAtXFx1MDM2RlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NjlcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNkYwLVxcdTA2RjlcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdDMC1cXHUwN0M5XFx1MDdFQi1cXHUwN0YzXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTAzXFx1MDkzQS1cXHUwOTNDXFx1MDkzRS1cXHUwOTRGXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUU2LVxcdTA5RUZcXHUwQTAxLVxcdTBBMDNcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE2Ni1cXHUwQTcxXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBQkNcXHUwQUJFLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCM0NcXHUwQjNFLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjgyXFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQ0JDXFx1MENCRS1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBEMDEtXFx1MEQwM1xcdTBEM0UtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEODJcXHUwRDgzXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQlxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0VcXHUwRjNGXFx1MEY3MS1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyQi1cXHUxMDNFXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZEXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhEXFx1MTA4Ri1cXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjQtXFx1MTdEM1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTRGXFx1MTlEMC1cXHUxOURBXFx1MUExNy1cXHUxQTFCXFx1MUE1NS1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjA0XFx1MUIzNC1cXHUxQjQ0XFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQjgyXFx1MUJBMS1cXHUxQkFEXFx1MUJCMC1cXHUxQkI5XFx1MUJFNi1cXHUxQkYzXFx1MUMyNC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM1MC1cXHUxQzU5XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0U4XFx1MUNFRFxcdTFDRjItXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY1XFx1MURGQi1cXHUxREZGXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2MjAtXFx1QTYyOVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyMy1cXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjFcXHVBOTAwLVxcdUE5MDlcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTNcXHVBOTgwLVxcdUE5ODNcXHVBOUIzLVxcdUE5QzBcXHVBOUQwLVxcdUE5RDlcXHVBOUU1XFx1QTlGMC1cXHVBOUY5XFx1QUEyOS1cXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE3Qi1cXHVBQTdEXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQi1cXHVBQUVGXFx1QUFGNVxcdUFBRjZcXHVBQkUzLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZGMTAtXFx1RkYxOVxcdUZGM0ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNywgMjYsIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDE1NywgMzEwLCAxMCwgMjEsIDExLCA3LCAxNTMsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyNiwgNDUsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCA3ODUsIDUyLCA3NiwgNDQsIDMzLCAyNCwgMjcsIDM1LCA0MiwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCA4NSwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMTU5LCA1MiwgMTksIDMsIDU0LCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDg2LCAyNSwgMzkxLCA2MywgMzIsIDAsIDQ0OSwgNTYsIDI2NCwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDg4MSwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjc0OSwgMTA3MCwgNDA1MCwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxMTQsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA4ODEsIDY4LCAxMiwgMCwgNjcsIDEyLCA2NSwgMCwgMzIsIDYxMjQsIDIwLCA3NTQsIDk0ODYsIDEsIDMwNzEsIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgNDE0OSwgMTk2LCA2MCwgNjcsIDEyMTMsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzEwLCA0MiwgNDE0OCwgMTIsIDIyMSwgMywgNTc2MSwgMTA1OTEsIDU0MV07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksIDAsIDIyNywgMCwgMTUwLCA0LCAyOTQsIDksIDEzNjgsIDIsIDIsIDEsIDYsIDMsIDQxLCAyLCA1LCAwLCAxNjYsIDEsIDEzMDYsIDIsIDU0LCAxNCwgMzIsIDksIDE2LCAzLCA0NiwgMTAsIDU0LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDUyLCAwLCAxMywgMiwgNDksIDEzLCAxMCwgMiwgNCwgOSwgODMsIDExLCA3LCAwLCAxNjEsIDExLCA2LCA5LCA3LCAzLCA1NywgMCwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgODcsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDQyMywgOSwgODM4LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTk4ODIsIDksIDEzNSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE2LCA0NSwgMTcsIDMsIDE5NzIzLCAxLCA1MzE5LCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAyMjE0LCA2LCAxMTAsIDYsIDYsIDksIDc5MjQ4NywgMjM5XTtcblxuLy8gVGhpcyBoYXMgYSBjb21wbGV4aXR5IGxpbmVhciB0byB0aGUgdmFsdWUgb2YgdGhlIGNvZGUuIFRoZVxuLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuLy8gcmFyZS5cbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIHZhciBwb3MgPSAweDEwMDAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHJldHVybiBmYWxzZTtcblxuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSkge1xuICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDwgMTIzKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuXG4vLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gU291cmNlIHR5cGUgKFwic2NyaXB0XCIgb3IgXCJtb2R1bGVcIikgZm9yIGRpZmZlcmVudCBzZW1hbnRpY3NcbiAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgLy8gU291cmNlIGZpbGVuYW1lLlxuICBzb3VyY2VGaWxlbmFtZTogdW5kZWZpbmVkLFxuICAvLyBMaW5lIGZyb20gd2hpY2ggdG8gc3RhcnQgY291bnRpbmcgc291cmNlLiBVc2VmdWwgZm9yXG4gIC8vIGludGVncmF0aW9uIHdpdGggb3RoZXIgdG9vbHMuXG4gIHN0YXJ0TGluZTogMSxcbiAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gIC8vIGVycm9yLlxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIC8vIFRPRE9cbiAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IGZhbHNlLFxuICAvLyBBbiBhcnJheSBvZiBwbHVnaW5zIHRvIGVuYWJsZVxuICBwbHVnaW5zOiBbXSxcbiAgLy8gVE9ET1xuICBzdHJpY3RNb2RlOiBudWxsXG59O1xuXG4vLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIHZhciBvcHRpb25zID0ge307XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0T3B0aW9ucykge1xuICAgIG9wdGlvbnNba2V5XSA9IG9wdHMgJiYga2V5IGluIG9wdHMgPyBvcHRzW2tleV0gOiBkZWZhdWx0T3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vLyAjIyBUb2tlbiB0eXBlc1xuXG4vLyBUaGUgYXNzaWdubWVudCBvZiBmaW5lLWdyYWluZWQsIGluZm9ybWF0aW9uLWNhcnJ5aW5nIHR5cGUgb2JqZWN0c1xuLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4vLyB0b2tlbiBpbiBhIHdheSB0aGF0IGlzIHZlcnkgY2hlYXAgZm9yIHRoZSBwYXJzZXIgdG8gbG9vayB1cC5cblxuLy8gQWxsIHRva2VuIHR5cGUgdmFyaWFibGVzIHN0YXJ0IHdpdGggYW4gdW5kZXJzY29yZSwgdG8gbWFrZSB0aGVtXG4vLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuLy8gVGhlIGBiZWZvcmVFeHByYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuIHJlZ3VsYXJcbi8vIGV4cHJlc3Npb25zIGFuZCBkaXZpc2lvbnMuIEl0IGlzIHNldCBvbiBhbGwgdG9rZW4gdHlwZXMgdGhhdCBjYW5cbi8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24pLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBiZWZvcmVFeHByID0gdHJ1ZTtcbnZhciBzdGFydHNFeHByID0gdHJ1ZTtcbnZhciBpc0xvb3AgPSB0cnVlO1xudmFyIGlzQXNzaWduID0gdHJ1ZTtcbnZhciBwcmVmaXggPSB0cnVlO1xudmFyIHBvc3RmaXggPSB0cnVlO1xuXG52YXIgVG9rZW5UeXBlID0gZnVuY3Rpb24gVG9rZW5UeXBlKGxhYmVsKSB7XG4gIHZhciBjb25mID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW5UeXBlKTtcblxuICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSAhIWNvbmYucmlnaHRBc3NvY2lhdGl2ZTtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxudmFyIEtleXdvcmRUb2tlblR5cGUgPSBmdW5jdGlvbiAoX1Rva2VuVHlwZSkge1xuICBpbmhlcml0cyhLZXl3b3JkVG9rZW5UeXBlLCBfVG9rZW5UeXBlKTtcblxuICBmdW5jdGlvbiBLZXl3b3JkVG9rZW5UeXBlKG5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5d29yZFRva2VuVHlwZSk7XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lO1xuXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1Rva2VuVHlwZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBLZXl3b3JkVG9rZW5UeXBlO1xufShUb2tlblR5cGUpO1xuXG52YXIgQmlub3BUb2tlblR5cGUgPSBmdW5jdGlvbiAoX1Rva2VuVHlwZTIpIHtcbiAgaW5oZXJpdHMoQmlub3BUb2tlblR5cGUsIF9Ub2tlblR5cGUyKTtcblxuICBmdW5jdGlvbiBCaW5vcFRva2VuVHlwZShuYW1lLCBwcmVjKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQmlub3BUb2tlblR5cGUpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Ub2tlblR5cGUyLmNhbGwodGhpcywgbmFtZSwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogcHJlYyB9KSk7XG4gIH1cblxuICByZXR1cm4gQmlub3BUb2tlblR5cGU7XG59KFRva2VuVHlwZSk7XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgc3RyaW5nOiBuZXcgVG9rZW5UeXBlKFwic3RyaW5nXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGJyYWNlQmFyTDogbmV3IFRva2VuVHlwZShcInt8XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgYnJhY2VCYXJSOiBuZXcgVG9rZW5UeXBlKFwifH1cIiksXG4gIHBhcmVuTDogbmV3IFRva2VuVHlwZShcIihcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBzZW1pOiBuZXcgVG9rZW5UeXBlKFwiO1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIGRvdWJsZUNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOjpcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICBxdWVzdGlvbjogbmV3IFRva2VuVHlwZShcIj9cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBhdDogbmV3IFRva2VuVHlwZShcIkBcIiksXG5cbiAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgLy8gcGFyc2VyIHVzZSB0aGVtIHByb3Blcmx5ICh0aGUgcHJlc2VuY2Ugb2YgdGhlc2UgcHJvcGVydGllcyBpc1xuICAvLyB3aGF0IGNhdGVnb3JpemVzIHRoZW0gYXMgb3BlcmF0b3JzKS5cbiAgLy9cbiAgLy8gYGJpbm9wYCwgd2hlbiBwcmVzZW50LCBzcGVjaWZpZXMgdGhhdCB0aGlzIG9wZXJhdG9yIGlzIGEgYmluYXJ5XG4gIC8vIG9wZXJhdG9yLCBhbmQgd2lsbCByZWZlciB0byBpdHMgcHJlY2VkZW5jZS5cbiAgLy9cbiAgLy8gYHByZWZpeGAgYW5kIGBwb3N0Zml4YCBtYXJrIHRoZSBvcGVyYXRvciBhcyBhIHByZWZpeCBvciBwb3N0Zml4XG4gIC8vIHVuYXJ5IG9wZXJhdG9yLlxuICAvL1xuICAvLyBgaXNBc3NpZ25gIG1hcmtzIGFsbCBvZiBgPWAsIGArPWAsIGAtPWAgZXRjZXRlcmEsIHdoaWNoIGFjdCBhc1xuICAvLyBiaW5hcnkgb3BlcmF0b3JzIHdpdGggYSB2ZXJ5IGxvdyBwcmVjZWRlbmNlLCB0aGF0IHNob3VsZCByZXN1bHRcbiAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgaXNBc3NpZ246IGlzQXNzaWduIH0pLFxuICBhc3NpZ246IG5ldyBUb2tlblR5cGUoXCJfPVwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIGlzQXNzaWduOiBpc0Fzc2lnbiB9KSxcbiAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwgeyBwcmVmaXg6IHByZWZpeCwgcG9zdGZpeDogcG9zdGZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwicHJlZml4XCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIGxvZ2ljYWxPUjogbmV3IEJpbm9wVG9rZW5UeXBlKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IG5ldyBCaW5vcFRva2VuVHlwZShcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IG5ldyBCaW5vcFRva2VuVHlwZShcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IG5ldyBCaW5vcFRva2VuVHlwZShcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IG5ldyBCaW5vcFRva2VuVHlwZShcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBuZXcgQmlub3BUb2tlblR5cGUoXCI9PS8hPVwiLCA2KSxcbiAgcmVsYXRpb25hbDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiPC8+XCIsIDcpLFxuICBiaXRTaGlmdDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiPDwvPj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogOSwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIG1vZHVsbzogbmV3IEJpbm9wVG9rZW5UeXBlKFwiJVwiLCAxMCksXG4gIHN0YXI6IG5ldyBCaW5vcFRva2VuVHlwZShcIipcIiwgMTApLFxuICBzbGFzaDogbmV3IEJpbm9wVG9rZW5UeXBlKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBuZXcgVG9rZW5UeXBlKFwiKipcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBiaW5vcDogMTEsIHJpZ2h0QXNzb2NpYXRpdmU6IHRydWUgfSlcbn07XG5cbnZhciBrZXl3b3JkcyA9IHtcbiAgXCJicmVha1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImJyZWFrXCIpLFxuICBcImNhc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJjYXNlXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgXCJjYXRjaFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImNhdGNoXCIpLFxuICBcImNvbnRpbnVlXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY29udGludWVcIiksXG4gIFwiZGVidWdnZXJcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkZWJ1Z2dlclwiKSxcbiAgXCJkZWZhdWx0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiZGVmYXVsdFwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIFwiZG9cIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkb1wiLCB7IGlzTG9vcDogaXNMb29wLCBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcImVsc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJlbHNlXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciB9KSxcbiAgXCJmaW5hbGx5XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiZmluYWxseVwiKSxcbiAgXCJmb3JcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJmb3JcIiwgeyBpc0xvb3A6IGlzTG9vcCB9KSxcbiAgXCJmdW5jdGlvblwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImZ1bmN0aW9uXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJpZlwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImlmXCIpLFxuICBcInJldHVyblwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInJldHVyblwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIgfSksXG4gIFwic3dpdGNoXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwic3dpdGNoXCIpLFxuICBcInRocm93XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidGhyb3dcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcInRyeVwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInRyeVwiKSxcbiAgXCJ2YXJcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ2YXJcIiksXG4gIFwibGV0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwibGV0XCIpLFxuICBcImNvbnN0XCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY29uc3RcIiksXG4gIFwid2hpbGVcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ3aGlsZVwiLCB7IGlzTG9vcDogaXNMb29wIH0pLFxuICBcIndpdGhcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJ3aXRoXCIpLFxuICBcIm5ld1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcIm5ld1wiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwidGhpc1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInRoaXNcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcInN1cGVyXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwic3VwZXJcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcImNsYXNzXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwiY2xhc3NcIiksXG4gIFwiZXh0ZW5kc1wiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImV4dGVuZHNcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByIH0pLFxuICBcImV4cG9ydFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcImV4cG9ydFwiKSxcbiAgXCJpbXBvcnRcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpbXBvcnRcIiwgeyBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcInlpZWxkXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwieWllbGRcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBzdGFydHNFeHByOiBzdGFydHNFeHByIH0pLFxuICBcIm51bGxcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJudWxsXCIsIHsgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJ0cnVlXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidHJ1ZVwiLCB7IHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwiZmFsc2VcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJmYWxzZVwiLCB7IHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwiaW5cIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpblwiLCB7IGJlZm9yZUV4cHI6IGJlZm9yZUV4cHIsIGJpbm9wOiA3IH0pLFxuICBcImluc3RhbmNlb2ZcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJpbnN0YW5jZW9mXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgYmlub3A6IDcgfSksXG4gIFwidHlwZW9mXCI6IG5ldyBLZXl3b3JkVG9rZW5UeXBlKFwidHlwZW9mXCIsIHsgYmVmb3JlRXhwcjogYmVmb3JlRXhwciwgcHJlZml4OiBwcmVmaXgsIHN0YXJ0c0V4cHI6IHN0YXJ0c0V4cHIgfSksXG4gIFwidm9pZFwiOiBuZXcgS2V5d29yZFRva2VuVHlwZShcInZvaWRcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBwcmVmaXg6IHByZWZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KSxcbiAgXCJkZWxldGVcIjogbmV3IEtleXdvcmRUb2tlblR5cGUoXCJkZWxldGVcIiwgeyBiZWZvcmVFeHByOiBiZWZvcmVFeHByLCBwcmVmaXg6IHByZWZpeCwgc3RhcnRzRXhwcjogc3RhcnRzRXhwciB9KVxufTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5PYmplY3Qua2V5cyhrZXl3b3JkcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICB0eXBlc1tcIl9cIiArIG5hbWVdID0ga2V5d29yZHNbbmFtZV07XG59KTtcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbnZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCBjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5O1xufVxuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLztcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuLy8gZ2l2ZW4gcG9pbnQgaW4gdGhlIHByb2dyYW0gaXMgbG9vc2VseSBiYXNlZCBvbiBzd2VldC5qcycgYXBwcm9hY2guXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cblxudmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlKSB7XG4gIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRva0NvbnRleHQpO1xuXG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYnJhY2VTdGF0ZW1lbnQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gIGJyYWNlRXhwcmVzc2lvbjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICB0ZW1wbGF0ZVF1YXNpOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIHRydWUpLFxuICBwYXJlblN0YXRlbWVudDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgcGFyZW5FeHByZXNzaW9uOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gIHRlbXBsYXRlOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5yZWFkVG1wbFRva2VuKCk7XG4gIH0pLFxuICBmdW5jdGlvbkV4cHJlc3Npb246IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSlcbn07XG5cbi8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3V0ID0gdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuICBpZiAob3V0ID09PSB0eXBlcyQxLmJyYWNlU3RhdGVtZW50ICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmZ1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wb3AoKTtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ID09PSB0eXBlcyQxLnRlbXBsYXRlUXVhc2kpIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG4gIH1cbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG5cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fbGV0IHx8IHByZXZUeXBlID09PSB0eXBlcy5fY29uc3QgfHwgcHJldlR5cGUgPT09IHR5cGVzLl92YXIpIHtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmVuZCkpKSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQgOiB0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEudGVtcGxhdGVRdWFzaSk7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMucGFyZW5MLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucGFyZW5TdGF0ZW1lbnQgOiB0eXBlcyQxLnBhcmVuRXhwcmVzc2lvbik7XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMkMS5icmFjZVN0YXRlbWVudCkge1xuICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEuZnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgfVxuXG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEudGVtcGxhdGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRleHQucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS50ZW1wbGF0ZSk7XG4gIH1cbiAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IGZhbHNlO1xufTtcblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb24pO1xuXG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sO1xufTtcblxudmFyIFNvdXJjZUxvY2F0aW9uID0gZnVuY3Rpb24gU291cmNlTG9jYXRpb24oc3RhcnQsIGVuZCkge1xuICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTb3VyY2VMb2NhdGlvbik7XG5cbiAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICB0aGlzLmVuZCA9IGVuZDtcbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGUoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGUpO1xuICB9XG5cbiAgU3RhdGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMsIGlucHV0KSB7XG4gICAgdGhpcy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG5cbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG5cbiAgICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAgIHRoaXMuaW5NZXRob2QgPSB0aGlzLmluRnVuY3Rpb24gPSB0aGlzLmluR2VuZXJhdG9yID0gdGhpcy5pbkFzeW5jID0gdGhpcy5pblByb3BlcnR5TmFtZSA9IHRoaXMuaW5UeXBlID0gdGhpcy5pbkNsYXNzUHJvcGVydHkgPSB0aGlzLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcblxuICAgIHRoaXMuZGVjb3JhdG9ycyA9IFtdO1xuXG4gICAgdGhpcy50b2tlbnMgPSBbXTtcblxuICAgIHRoaXMuY29tbWVudHMgPSBbXTtcblxuICAgIHRoaXMudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgdGhpcy5jb21tZW50U3RhY2sgPSBbXTtcblxuICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZSA9IG9wdGlvbnMuc3RhcnRMaW5lO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydCA9IHRoaXMubGFzdFRva0VuZCA9IHRoaXMucG9zO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzJDEuYnJhY2VTdGF0ZW1lbnRdO1xuICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNPY3RhbCA9IGZhbHNlO1xuICAgIHRoaXMub2N0YWxQb3NpdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycyA9IFtdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuXG5cbiAgLy8gRmxhZ3MgdG8gdHJhY2sgd2hldGhlciB3ZSBhcmUgaW4gYSBmdW5jdGlvbiwgYSBnZW5lcmF0b3IuXG5cblxuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG5cblxuICAvLyBMZWFkaW5nIGRlY29yYXRvcnMuXG5cblxuICAvLyBUb2tlbiBzdG9yZS5cblxuXG4gIC8vIENvbW1lbnQgc3RvcmUuXG5cblxuICAvLyBDb21tZW50IGF0dGFjaG1lbnQgc3RvcmVcblxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuXG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcblxuXG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcblxuXG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuXG5cbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG5cblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG5cblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cblxuXG4gIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuXG5cbiAgLy8gVE9ET1xuXG5cbiAgLy8gTmFtZXMgb2YgZXhwb3J0cyBzdG9yZS4gYGRlZmF1bHRgIGlzIHN0b3JlZCBhcyBhIG5hbWUgZm9yIGJvdGhcbiAgLy8gYGV4cG9ydCBkZWZhdWx0IGZvbztgIGFuZCBgZXhwb3J0IHsgZm9vIGFzIGRlZmF1bHQgfTtgLlxuXG5cbiAgU3RhdGUucHJvdG90eXBlLmN1clBvc2l0aW9uID0gZnVuY3Rpb24gY3VyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmN1ckxpbmUsIHRoaXMucG9zIC0gdGhpcy5saW5lU3RhcnQpO1xuICB9O1xuXG4gIFN0YXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKHNraXBBcnJheXMpIHtcbiAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykge1xuICAgICAgdmFyIHZhbCA9IHRoaXNba2V5XTtcblxuICAgICAgaWYgKCghc2tpcEFycmF5cyB8fCBrZXkgPT09IFwiY29udGV4dFwiKSAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGU7XG59KCk7XG5cbi8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbi8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbi8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG52YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihzdGF0ZSkge1xuICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlbik7XG5cbiAgdGhpcy50eXBlID0gc3RhdGUudHlwZTtcbiAgdGhpcy52YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gc3RhdGUuc3RhcnQ7XG4gIHRoaXMuZW5kID0gc3RhdGUuZW5kO1xuICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbn07XG5cbi8vICMjIFRva2VuaXplclxuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSB7XG4gIC8vIFVURi0xNiBEZWNvZGluZ1xuICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAtIDB4MTAwMDAgPj4gMTApICsgMHhEODAwLCAoY29kZSAtIDB4MTAwMDAgJiAxMDIzKSArIDB4REMwMCk7XG4gIH1cbn1cblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyKG9wdGlvbnMsIGlucHV0KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9rZW5pemVyKTtcblxuICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICB0aGlzLnN0YXRlLmluaXQob3B0aW9ucywgaW5wdXQpO1xuICB9XG5cbiAgLy8gTW92ZSB0byB0aGUgbmV4dCB0b2tlblxuXG4gIFRva2VuaXplci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnN0YXRlLnRva2Vucy5wdXNoKG5ldyBUb2tlbih0aGlzLnN0YXRlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kID0gdGhpcy5zdGF0ZS5lbmQ7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMuc3RhdGUuZW5kTG9jO1xuICAgIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9O1xuXG4gIC8vIFRPRE9cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ET1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZTtcbiAgfTtcblxuICAvLyBUT0RPXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiBpc0tleXdvcmQkJDEod29yZCkge1xuICAgIHJldHVybiBpc0tleXdvcmQod29yZCk7XG4gIH07XG5cbiAgLy8gVE9ET1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkKCkge1xuICAgIHZhciBvbGQgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBvbGQuY2xvbmUodHJ1ZSk7XG5cbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VyciA9IHRoaXMuc3RhdGUuY2xvbmUodHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IG9sZDtcbiAgICByZXR1cm4gY3VycjtcbiAgfTtcblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnNldFN0cmljdCA9IGZ1bmN0aW9uIHNldFN0cmljdChzdHJpY3QpIHtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHN0cmljdDtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMubnVtKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMuc3RhdGUubGluZVN0YXJ0KSB7XG4gICAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgLSAyKSArIDE7XG4gICAgICAtLXRoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB9XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmN1ckNvbnRleHQgPSBmdW5jdGlvbiBjdXJDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRleHRbdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIC8vIFJlYWQgYSBzaW5nbGUgdG9rZW4sIHVwZGF0aW5nIHRoZSBwYXJzZXIgb2JqZWN0J3MgdG9rZW4tcmVsYXRlZFxuICAvLyBwcm9wZXJ0aWVzLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHRoaXMuc2tpcFNwYWNlKCk7XG5cbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zT2N0YWwgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdGUuc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZW9mKTtcblxuICAgIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7XG4gICAgICByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFRva2VuID0gZnVuY3Rpb24gcmVhZFRva2VuKGNvZGUpIHtcbiAgICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgICAvLyBpZGVudGlmaWVycywgc28gJ1xcJyBhbHNvIGRpc3BhdGNoZXMgdG8gdGhhdC5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkV29yZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbiBmdWxsQ2hhckNvZGVBdFBvcygpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSByZXR1cm4gY29kZTtcblxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDA7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5wdXNoQ29tbWVudCA9IGZ1bmN0aW9uIHB1c2hDb21tZW50KGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQ29tbWVudEJsb2NrXCIgOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIGVuZExvYylcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB7XG4gICAgICB0aGlzLnN0YXRlLnRva2Vucy5wdXNoKGNvbW1lbnQpO1xuICAgICAgdGhpcy5zdGF0ZS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbiBza2lwQmxvY2tDb21tZW50KCkge1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB2YXIgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5zdGF0ZS5wb3MgKz0gMik7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpO1xuXG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBlbmQgKyAyO1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgdmFyIG1hdGNoID0gdm9pZCAwO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWModGhpcy5pbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdGhpcy5zdGF0ZS5wb3MpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2hDb21tZW50KHRydWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdGhpcy5zdGF0ZS5wb3MsIHN0YXJ0TG9jLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24gc2tpcExpbmVDb21tZW50KHN0YXJ0U2tpcCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiBjaCAhPT0gMTAgJiYgY2ggIT09IDEzICYmIGNoICE9PSA4MjMyICYmIGNoICE9PSA4MjMzKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaENvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMuc3RhdGUucG9zKSwgc3RhcnQsIHRoaXMuc3RhdGUucG9zLCBzdGFydExvYywgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgfTtcblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5za2lwU3BhY2UgPSBmdW5jdGlvbiBza2lwU3BhY2UoKSB7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgMzI6Y2FzZSAxNjA6XG4gICAgICAgICAgLy8gJyAnXG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMTA6Y2FzZSA4MjMyOmNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAvLyAnLydcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpKSB7XG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgICAvLyAnKidcbiAgICAgICAgICAgICAgdGhpcy5za2lwQmxvY2tDb21tZW50KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgdG9rZW4uIFNldHMgYGVuZGAsIGB2YWxgLCBhbmRcbiAgLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuICAvLyB0aGUgdG9rZW4sIHNvIHRoYXQgdGhlIG5leHQgb25lJ3MgYHN0YXJ0YCB3aWxsIHBvaW50IGF0IHRoZVxuICAvLyByaWdodCBwb3NpdGlvbi5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmZpbmlzaFRva2VuID0gZnVuY3Rpb24gZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgdGhpcy5zdGF0ZS5lbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLmVuZExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXRlLnZhbHVlID0gdmFsO1xuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgfTtcblxuICAvLyAjIyMgVG9rZW4gcmVhZGluZ1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGZldGNoIHRoZSBuZXh0IHRva2VuLiBJdFxuICAvLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbiAgLy8gdGhhbiBjaGFyYWN0ZXJzLCBhbmQgYmVjYXVzZSBvcGVyYXRvciBwYXJzaW5nIGhhcyBiZWVuIGlubGluZWRcbiAgLy8gaW50byBpdC5cbiAgLy9cbiAgLy8gQWxsIGluIHRoZSBuYW1lIG9mIHNwZWVkLlxuICAvL1xuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0Nikge1xuICAgICAgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAzO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZWxsaXBzaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG90KTtcbiAgICB9XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbiByZWFkVG9rZW5fc2xhc2goKSB7XG4gICAgLy8gJy8nXG4gICAgaWYgKHRoaXMuc3RhdGUuZXhwckFsbG93ZWQpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnNsYXNoLCAxKTtcbiAgICB9XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fbXVsdF9tb2R1bG8gPSBmdW5jdGlvbiByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIC8vICclKidcbiAgICB2YXIgdHlwZSA9IGNvZGUgPT09IDQyID8gdHlwZXMuc3RhciA6IHR5cGVzLm1vZHVsbztcbiAgICB2YXIgd2lkdGggPSAxO1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gNDIpIHtcbiAgICAgIC8vICcqJ1xuICAgICAgd2lkdGgrKztcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKTtcbiAgICAgIHR5cGUgPSB0eXBlcy5leHBvbmVudDtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gdHlwZXMuYXNzaWduO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGUsIHdpZHRoKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUb2tlbl9waXBlX2FtcCA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG4gICAgLy8gJ3wmJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKTtcbiAgICBpZiAoY29kZSA9PT0gMTI0ICYmIG5leHQgPT09IDEyNSAmJiB0aGlzLmhhc1BsdWdpbihcImZsb3dcIikpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJyYWNlQmFyUiwgMik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgLy8gJ14nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdHdpc2VYT1IsIDEpO1xuICAgIH1cbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUb2tlbl9wbHVzX21pbiA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG4gICAgLy8gJystJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKG5leHQgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgICAvLyBBIGAtLT5gIGxpbmUgY29tbWVudFxuICAgICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucGx1c01pbiwgMSk7XG4gICAgfVxuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24gcmVhZFRva2VuX2x0X2d0KGNvZGUpIHtcbiAgICAvLyAnPD4nXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICB2YXIgc2l6ZSA9IDE7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA0NSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgLy8gPD0gfCA+PVxuICAgICAgc2l6ZSA9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uIHJlYWRUb2tlbl9lcV9leGNsKGNvZGUpIHtcbiAgICAvLyAnPSEnXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMik7XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICAvLyAnPT4nXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKTtcbiAgfTtcblxuICBUb2tlbml6ZXIucHJvdG90eXBlLmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIC8vIFRoZSBpbnRlcnByZXRhdGlvbiBvZiBhIGRvdCBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaXMgZm9sbG93ZWRcbiAgICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIC8vICcuJ1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZG90KCk7XG5cbiAgICAgIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICAgIGNhc2UgNDA6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKTtcbiAgICAgIGNhc2UgNDE6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKTtcbiAgICAgIGNhc2UgNTk6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSk7XG4gICAgICBjYXNlIDQ0OlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO3JldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0Uik7XG5cbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5icmFjZUJhckwsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDEyNTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZVIpO1xuXG4gICAgICBjYXNlIDU4OlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvbkJpbmRcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDU4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZG91YmxlQ29sb24sIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNjM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztyZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5hdCk7XG5cbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIC8vICdgJ1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpO1xuXG4gICAgICBjYXNlIDQ4OlxuICAgICAgICAvLyAnMCdcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KTsgLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpOyAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpOyAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgICAgLy8gQW55dGhpbmcgZWxzZSBiZWdpbm5pbmcgd2l0aCBhIGRpZ2l0IGlzIGFuIGludGVnZXIsIG9jdGFsXG4gICAgICAvLyBudW1iZXIsIG9yIGZsb2F0LlxuICAgICAgY2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6XG4gICAgICAgIC8vIDEtOVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKTtcblxuICAgICAgLy8gUXVvdGVzIHByb2R1Y2Ugc3RyaW5ncy5cbiAgICAgIGNhc2UgMzQ6Y2FzZSAzOTpcbiAgICAgICAgLy8gJ1wiJywgXCInXCJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKTtcblxuICAgICAgLy8gT3BlcmF0b3JzIGFyZSBwYXJzZWQgaW5saW5lIGluIHRpbnkgc3RhdGUgbWFjaGluZXMuICc9JyAoNjEpIGlzXG4gICAgICAvLyBvZnRlbiByZWZlcnJlZCB0by4gYGZpbmlzaE9wYCBzaW1wbHkgc2tpcHMgdGhlIGFtb3VudCBvZlxuICAgICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAgIC8vIG9mIHRoZSB0eXBlIGdpdmVuIGJ5IGl0cyBmaXJzdCBhcmd1bWVudC5cblxuICAgICAgY2FzZSA0NzpcbiAgICAgICAgLy8gJy8nXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO1xuXG4gICAgICBjYXNlIDM3OmNhc2UgNDI6XG4gICAgICAgIC8vICclKidcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpO1xuXG4gICAgICBjYXNlIDEyNDpjYXNlIDM4OlxuICAgICAgICAvLyAnfCYnXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcblxuICAgICAgY2FzZSA5NDpcbiAgICAgICAgLy8gJ14nXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO1xuXG4gICAgICBjYXNlIDQzOmNhc2UgNDU6XG4gICAgICAgIC8vICcrLSdcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpO1xuXG4gICAgICBjYXNlIDYwOmNhc2UgNjI6XG4gICAgICAgIC8vICc8PidcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpO1xuXG4gICAgICBjYXNlIDYxOmNhc2UgMzM6XG4gICAgICAgIC8vICc9ISdcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG5cbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICAvLyAnfidcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUuZmluaXNoT3AgPSBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uIHJlYWRSZWdleHAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgdmFyIGVzY2FwZWQgPSB2b2lkIDAsXG4gICAgICAgIGluQ2xhc3MgPSB2b2lkIDA7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7XG4gICAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICB9XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAvLyBOZWVkIHRvIHVzZSBgcmVhZFdvcmQxYCBiZWNhdXNlICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWRcbiAgICAvLyBoZXJlIChkb24ndCBhc2spLlxuICAgIHZhciBtb2RzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICBpZiAobW9kcykge1xuICAgICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnbXNpeXVdKiQvO1xuICAgICAgaWYgKCF2YWxpZEZsYWdzLnRlc3QobW9kcykpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7XG4gICAgICBwYXR0ZXJuOiBjb250ZW50LFxuICAgICAgZmxhZ3M6IG1vZHNcbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuICAvLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuICAvLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiByZWFkSW50KHJhZGl4LCBsZW4pIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB2YXIgdmFsID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPj0gOTcpIHtcbiAgICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7IC8vIGFcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+PSA2NSkge1xuICAgICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDsgLy8gQVxuICAgICAgfSBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHtcbiAgICAgICAgdmFsID0gY29kZSAtIDQ4OyAvLyAwLTlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgYnJlYWs7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbiByZWFkUmFkaXhOdW1iZXIocmFkaXgpIHtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAyOyAvLyAweFxuICAgIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICAgIGlmICh2YWwgPT0gbnVsbCkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpO1xuICB9O1xuXG4gIC8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZE51bWJlciA9IGZ1bmN0aW9uIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBvY3RhbCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzdGFydCkgPT09IDQ4OyAvLyAnMCdcbiAgICB2YXIgaXNGbG9hdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgaWYgKG9jdGFsICYmIHRoaXMuc3RhdGUucG9zID09IHN0YXJ0ICsgMSkgb2N0YWwgPSBmYWxzZTsgLy8gbnVtYmVyID09PSAwXG5cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkge1xuICAgICAgLy8gJy4nXG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuXG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkge1xuICAgICAgLy8gJ2VFJ1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0aGlzLnN0YXRlLnBvczsgLy8gJystJ1xuICAgICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgICBpc0Zsb2F0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTtcblxuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgdmFyIHZhbCA9IHZvaWQgMDtcbiAgICBpZiAoaXNGbG9hdCkge1xuICAgICAgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIH0gZWxzZSBpZiAoIW9jdGFsIHx8IHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhbCA9IHBhcnNlSW50KHN0ciwgMTApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpKSB7XG4gICAgICB2YWwgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gcGFyc2VJbnQoc3RyLCA4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpO1xuICB9O1xuXG4gIC8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbiByZWFkQ29kZVBvaW50KHRocm93T25JbnZhbGlkKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB2YXIgY29kZSA9IHZvaWQgMDtcblxuICAgIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgICAvLyAneydcbiAgICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5zdGF0ZS5wb3MpIC0gdGhpcy5zdGF0ZS5wb3MsIHRocm93T25JbnZhbGlkKTtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAtLXRoaXMuc3RhdGUuaW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zaXRpb247IC8vIHRvIHBvaW50IHRvIHRoZSAnXFwnJyBpbnN0ZWFkIG9mIHRoZSAndSdcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA+IDB4MTBGRkZGKSB7XG4gICAgICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5pbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3NpdGlvbiA9IGNvZGVQb3MgLSAyO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQsIHRocm93T25JbnZhbGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGU7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gcmVhZFN0cmluZyhxdW90ZSkge1xuICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrO1xuICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dCk7XG4gIH07XG5cbiAgLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbiByZWFkVG1wbFRva2VuKCkge1xuICAgIHZhciBvdXQgPSBcIlwiLFxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3MsXG4gICAgICAgIGNvbnRhaW5zSW52YWxpZCA9IGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTIzKSB7XG4gICAgICAgIC8vICdgJywgJyR7J1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQgJiYgdGhpcy5tYXRjaCh0eXBlcy50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMudGVtcGxhdGUsIGNvbnRhaW5zSW52YWxpZCA/IG51bGwgOiBvdXQpO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyAnXFwnXG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgdmFyIGVzY2FwZWQgPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgaWYgKGVzY2FwZWQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250YWluc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBlc2NhcGVkO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZWFkIGVzY2FwZWQgY2hhcmFjdGVyc1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGluVGVtcGxhdGUpIHtcbiAgICB2YXIgdGhyb3dPbkludmFsaWQgPSAhaW5UZW1wbGF0ZTtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICBjYXNlIDExMDpcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7IC8vICduJyAtPiAnXFxuJ1xuICAgICAgY2FzZSAxMTQ6XG4gICAgICAgIHJldHVybiBcIlxcclwiOyAvLyAncicgLT4gJ1xccidcbiAgICAgIGNhc2UgMTIwOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gJ3gnXG4gICAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDIsIHRocm93T25JbnZhbGlkKTtcbiAgICAgICAgICByZXR1cm4gY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDExNzpcbiAgICAgICAge1xuICAgICAgICAgIC8vICd1J1xuICAgICAgICAgIHZhciBfY29kZSA9IHRoaXMucmVhZENvZGVQb2ludCh0aHJvd09uSW52YWxpZCk7XG4gICAgICAgICAgcmV0dXJuIF9jb2RlID09PSBudWxsID8gbnVsbCA6IGNvZGVQb2ludFRvU3RyaW5nKF9jb2RlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMTY6XG4gICAgICAgIHJldHVybiBcIlxcdFwiOyAvLyAndCcgLT4gJ1xcdCdcbiAgICAgIGNhc2UgOTg6XG4gICAgICAgIHJldHVybiBcIlxcYlwiOyAvLyAnYicgLT4gJ1xcYidcbiAgICAgIGNhc2UgMTE4OlxuICAgICAgICByZXR1cm4gXCJcXHgwQlwiOyAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgICBjYXNlIDEwMjpcbiAgICAgICAgcmV0dXJuIFwiXFxmXCI7IC8vICdmJyAtPiAnXFxmJ1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSArK3RoaXMuc3RhdGUucG9zOyAvLyAnXFxyXFxuJ1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgLy8gJyBcXG4nXG4gICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5zdGF0ZS5wb3MgLSAxO1xuICAgICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuc3RhdGUucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2N0YWwgPiAwKSB7XG4gICAgICAgICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gY29kZVBvcztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuc3RyaWN0KSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoY29kZVBvcywgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zdGF0ZS5jb250YWluc09jdGFsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIG9ubHkgdXNlZCB0byB0aHJvdyBhbiBlcnJvciBmb3IgYW4gb2N0YWwgd2hpY2ggb2NjdXJzXG4gICAgICAgICAgICAgIC8vIGluIGEgZGlyZWN0aXZlIHdoaWNoIG9jY3VycyBwcmlvciB0byBhIFwidXNlIHN0cmljdFwiIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc09jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5vY3RhbFBvc2l0aW9uID0gY29kZVBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JykuXG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uIHJlYWRIZXhDaGFyKGxlbiwgdGhyb3dPbkludmFsaWQpIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHZhciBuID0gdGhpcy5yZWFkSW50KDE2LCBsZW4pO1xuICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICBpZiAodGhyb3dPbkludmFsaWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgPSBjb2RlUG9zIC0gMTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3NpdGlvbiA9IGNvZGVQb3MgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIsIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcuIFNldHMgYHRoaXMuc3RhdGUuY29udGFpbnNFc2NgXG4gIC8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuICAvL1xuICAvLyBJbmNyZW1lbnRhbGx5IGFkZHMgb25seSBlc2NhcGVkIGNoYXJzLCBhZGRpbmcgb3RoZXIgY2h1bmtzIGFzLWlzXG4gIC8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG4gIFRva2VuaXplci5wcm90b3R5cGUucmVhZFdvcmQxID0gZnVuY3Rpb24gcmVhZFdvcmQxKCkge1xuICAgIHRoaXMuc3RhdGUuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsXG4gICAgICAgIGZpcnN0ID0gdHJ1ZSxcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAvLyBcIlxcXCJcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluc0VzYyA9IHRydWU7XG5cbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKSAhPT0gMTE3KSB7XG4gICAgICAgICAgLy8gXCJ1XCJcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KHRydWUpO1xuICAgICAgICBpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcikoZXNjLCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICB9O1xuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuICAvLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxuICBUb2tlbml6ZXIucHJvdG90eXBlLnJlYWRXb3JkID0gZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG4gICAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICAgIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdGhpcy5pc0tleXdvcmQod29yZCkpIHtcbiAgICAgIHR5cGUgPSBrZXl3b3Jkc1t3b3JkXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZCk7XG4gIH07XG5cbiAgVG9rZW5pemVyLnByb3RvdHlwZS5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbiBicmFjZUlzQmxvY2socHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmJyYWNlU3RhdGVtZW50IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5icmFjZUV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuICFwYXJlbnQuaXNFeHByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybikge1xuICAgICAgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYnJhY2VTdGF0ZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLnN0YXRlLmV4cHJBbGxvd2VkO1xuICB9O1xuXG4gIFRva2VuaXplci5wcm90b3R5cGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQocHJldlR5cGUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICB2YXIgdXBkYXRlID0gdm9pZCAwO1xuXG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuZG90KSB7XG4gICAgICB0aGlzLnN0YXRlLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpIHtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuaXplcjtcbn0oKTtcblxudmFyIHBsdWdpbnMgPSB7fTtcbnZhciBmcm96ZW5EZXByZWNhdGVkV2lsZGNhcmRQbHVnaW5MaXN0ID0gW1wianN4XCIsIFwiZG9FeHByZXNzaW9uc1wiLCBcIm9iamVjdFJlc3RTcHJlYWRcIiwgXCJkZWNvcmF0b3JzXCIsIFwiY2xhc3NQcm9wZXJ0aWVzXCIsIFwiZXhwb3J0RXh0ZW5zaW9uc1wiLCBcImFzeW5jR2VuZXJhdG9yc1wiLCBcImZ1bmN0aW9uQmluZFwiLCBcImZ1bmN0aW9uU2VudFwiLCBcImR5bmFtaWNJbXBvcnRcIiwgXCJmbG93XCJdO1xuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gKF9Ub2tlbml6ZXIpIHtcbiAgaW5oZXJpdHMoUGFyc2VyLCBfVG9rZW5pemVyKTtcblxuICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzZXIpO1xuXG4gICAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Ub2tlbml6ZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBpbnB1dCkpO1xuXG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgX3RoaXMuaW5Nb2R1bGUgPSBfdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICBfdGhpcy5wbHVnaW5zID0gX3RoaXMubG9hZFBsdWdpbnMoX3RoaXMub3B0aW9ucy5wbHVnaW5zKTtcbiAgICBfdGhpcy5maWxlbmFtZSA9IG9wdGlvbnMuc291cmNlRmlsZW5hbWU7XG5cbiAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICBpZiAoX3RoaXMuc3RhdGUucG9zID09PSAwICYmIF90aGlzLmlucHV0WzBdID09PSBcIiNcIiAmJiBfdGhpcy5pbnB1dFsxXSA9PT0gXCIhXCIpIHtcbiAgICAgIF90aGlzLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5pc1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgICBpZiAod29yZCA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbk1vZHVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc2VydmVkV29yZHNbNl0od29yZCk7XG4gICAgfVxuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuaGFzUGx1Z2luID0gZnVuY3Rpb24gaGFzUGx1Z2luKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wbHVnaW5zW1wiKlwiXSAmJiBmcm96ZW5EZXByZWNhdGVkV2lsZGNhcmRQbHVnaW5MaXN0LmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhdGhpcy5wbHVnaW5zW25hbWVdO1xuICB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIGYpIHtcbiAgICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmxvYWRBbGxQbHVnaW5zID0gZnVuY3Rpb24gbG9hZEFsbFBsdWdpbnMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBlbnN1cmUgZmxvdyBwbHVnaW4gbG9hZHMgbGFzdCwgYWxzbyBlbnN1cmUgZXN0cmVlIGlzIG5vdCBsb2FkZWQgd2l0aCAqXG4gICAgdmFyIHBsdWdpbk5hbWVzID0gT2JqZWN0LmtleXMocGx1Z2lucykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAhPT0gXCJmbG93XCIgJiYgbmFtZSAhPT0gXCJlc3RyZWVcIjtcbiAgICB9KTtcbiAgICBwbHVnaW5OYW1lcy5wdXNoKFwiZmxvd1wiKTtcblxuICAgIHBsdWdpbk5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgICAgaWYgKHBsdWdpbikgcGx1Z2luKF90aGlzMik7XG4gICAgfSk7XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5sb2FkUGx1Z2lucyA9IGZ1bmN0aW9uIGxvYWRQbHVnaW5zKHBsdWdpbkxpc3QpIHtcbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgXCIqXCIgb3B0aW9uIGluIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBCYWJ5bG9uXG4gICAgaWYgKHBsdWdpbkxpc3QuaW5kZXhPZihcIipcIikgPj0gMCkge1xuICAgICAgdGhpcy5sb2FkQWxsUGx1Z2lucygpO1xuXG4gICAgICByZXR1cm4geyBcIipcIjogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5NYXAgPSB7fTtcblxuICAgIGlmIChwbHVnaW5MaXN0LmluZGV4T2YoXCJmbG93XCIpID49IDApIHtcbiAgICAgIC8vIGVuc3VyZSBmbG93IHBsdWdpbiBsb2FkcyBsYXN0XG4gICAgICBwbHVnaW5MaXN0ID0gcGx1Z2luTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luICE9PSBcImZsb3dcIjtcbiAgICAgIH0pO1xuICAgICAgcGx1Z2luTGlzdC5wdXNoKFwiZmxvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2luTGlzdC5pbmRleE9mKFwiZXN0cmVlXCIpID49IDApIHtcbiAgICAgIC8vIGVuc3VyZSBlc3RyZWUgcGx1Z2luIGxvYWRzIGZpcnN0XG4gICAgICBwbHVnaW5MaXN0ID0gcGx1Z2luTGlzdC5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luICE9PSBcImVzdHJlZVwiO1xuICAgICAgfSk7XG4gICAgICBwbHVnaW5MaXN0LnVuc2hpZnQoXCJlc3RyZWVcIik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcGx1Z2luTGlzdCwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBfcmVmO1xuXG4gICAgICBpZiAoIXBsdWdpbk1hcFtuYW1lXSkge1xuICAgICAgICBwbHVnaW5NYXBbbmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgICAgICBpZiAocGx1Z2luKSBwbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsdWdpbk1hcDtcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgdmFyIGZpbGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oVG9rZW5pemVyKTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG4vLyBUT0RPXG5cbnBwLmFkZEV4dHJhID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuXG4gIHZhciBleHRyYSA9IG5vZGUuZXh0cmEgPSBub2RlLmV4dHJhIHx8IHt9O1xuICBleHRyYVtrZXldID0gdmFsO1xufTtcblxuLy8gVE9ET1xuXG5wcC5pc1JlbGF0aW9uYWwgPSBmdW5jdGlvbiAob3ApIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMucmVsYXRpb25hbCkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gb3A7XG59O1xuXG4vLyBUT0RPXG5cbnBwLmV4cGVjdFJlbGF0aW9uYWwgPSBmdW5jdGlvbiAob3ApIHtcbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKG9wKSkge1xuICAgIHRoaXMubmV4dCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5yZWxhdGlvbmFsKTtcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IG5hbWU7XG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZSA9PT0gbmFtZSAmJiB0aGlzLmVhdCh0eXBlcy5uYW1lKTtcbn07XG5cbi8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24gKG5hbWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHRoaXMudW5leHBlY3RlZChudWxsLCBtZXNzYWdlKTtcbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuZW9mKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgfHwgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIHRoaXMuc3RhdGUuc3RhcnQpKTtcbn07XG5cbi8vIFRPRE9cblxucHAuaXNMaW5lVGVybWluYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG59O1xuXG4vLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbi8vIHByZXRlbmQgdGhhdCB0aGVyZSBpcyBhIHNlbWljb2xvbiBhdCB0aGlzIHBvc2l0aW9uLlxuXG5wcC5zZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5zZW1pKTtcbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IgYXQgZ2l2ZW4gcG9zLlxuXG5wcC5leHBlY3QgPSBmdW5jdGlvbiAodHlwZSwgcG9zKSB7XG4gIHJldHVybiB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQocG9zLCB0eXBlKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuIENhbiB0YWtlIHRoZSBleHBlY3RlZCB0b2tlbiB0eXBlXG4vLyBpbnN0ZWFkIG9mIGEgbWVzc2FnZSBzdHJpbmcuXG5cbnBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbiAocG9zKSB7XG4gIHZhciBtZXNzYWdlT3JUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlVuZXhwZWN0ZWQgdG9rZW5cIjtcblxuICBpZiAobWVzc2FnZU9yVHlwZSAmJiAodHlwZW9mIG1lc3NhZ2VPclR5cGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtZXNzYWdlT3JUeXBlKSkgPT09IFwib2JqZWN0XCIgJiYgbWVzc2FnZU9yVHlwZS5sYWJlbCkge1xuICAgIG1lc3NhZ2VPclR5cGUgPSBcIlVuZXhwZWN0ZWQgdG9rZW4sIGV4cGVjdGVkIFwiICsgbWVzc2FnZU9yVHlwZS5sYWJlbDtcbiAgfVxuICB0aGlzLnJhaXNlKHBvcyAhPSBudWxsID8gcG9zIDogdGhpcy5zdGF0ZS5zdGFydCwgbWVzc2FnZU9yVHlwZSk7XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4vLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2Zcbi8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4vLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4vLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbnBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChmaWxlLCBwcm9ncmFtKSB7XG4gIHByb2dyYW0uc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuXG4gIHRoaXMucGFyc2VCbG9ja0JvZHkocHJvZ3JhbSwgdHJ1ZSwgdHJ1ZSwgdHlwZXMuZW9mKTtcblxuICBmaWxlLnByb2dyYW0gPSB0aGlzLmZpbmlzaE5vZGUocHJvZ3JhbSwgXCJQcm9ncmFtXCIpO1xuICBmaWxlLmNvbW1lbnRzID0gdGhpcy5zdGF0ZS5jb21tZW50cztcbiAgZmlsZS50b2tlbnMgPSB0aGlzLnN0YXRlLnRva2VucztcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGZpbGUsIFwiRmlsZVwiKTtcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7IGtpbmQ6IFwibG9vcFwiIH07XG52YXIgc3dpdGNoTGFiZWwgPSB7IGtpbmQ6IFwic3dpdGNoXCIgfTtcblxuLy8gVE9ET1xuXG5wcCQxLnN0bXRUb0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChzdG10KSB7XG4gIHZhciBleHByID0gc3RtdC5leHByZXNzaW9uO1xuXG4gIHZhciBkaXJlY3RpdmVMaXRlcmFsID0gdGhpcy5zdGFydE5vZGVBdChleHByLnN0YXJ0LCBleHByLmxvYy5zdGFydCk7XG4gIHZhciBkaXJlY3RpdmUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0bXQuc3RhcnQsIHN0bXQubG9jLnN0YXJ0KTtcblxuICB2YXIgcmF3ID0gdGhpcy5pbnB1dC5zbGljZShleHByLnN0YXJ0LCBleHByLmVuZCk7XG4gIHZhciB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTsgLy8gcmVtb3ZlIHF1b3Rlc1xuXG4gIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJyYXdcIiwgcmF3KTtcbiAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG5cbiAgZGlyZWN0aXZlLnZhbHVlID0gdGhpcy5maW5pc2hOb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbCwgXCJEaXJlY3RpdmVMaXRlcmFsXCIsIGV4cHIuZW5kLCBleHByLmxvYy5lbmQpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChkaXJlY3RpdmUsIFwiRGlyZWN0aXZlXCIsIHN0bXQuZW5kLCBzdG10LmxvYy5lbmQpO1xufTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbiwgdG9wTGV2ZWwpIHtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuYXQpKSB7XG4gICAgdGhpcy5wYXJzZURlY29yYXRvcnModHJ1ZSk7XG4gIH1cblxuICB2YXIgc3RhcnR0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gIC8vIGNvbXBsZXhpdHkuXG5cbiAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9icmVhazpjYXNlIHR5cGVzLl9jb250aW51ZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZCk7XG4gICAgY2FzZSB0eXBlcy5fZGVidWdnZXI6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX2RvOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl9mb3I6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlKTtcblxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpO1xuXG4gICAgY2FzZSB0eXBlcy5faWY6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3JldHVybjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3N3aXRjaDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX3Rocm93OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLl90cnk6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKTtcblxuICAgIGNhc2UgdHlwZXMuX2xldDpcbiAgICBjYXNlIHR5cGVzLl9jb25zdDpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpOyAvLyBOT1RFOiBmYWxscyB0aHJvdWdoIHRvIF92YXJcblxuICAgIGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZSk7XG5cbiAgICBjYXNlIHR5cGVzLl93aGlsZTpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgY2FzZSB0eXBlcy5fd2l0aDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBjYXNlIHR5cGVzLnNlbWk6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgIGNhc2UgdHlwZXMuX2V4cG9ydDpcbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkeW5hbWljSW1wb3J0XCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMucGFyZW5MKSBicmVhaztcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICAgIGlmICghdG9wTGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXFxcIm1vZHVsZVxcXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0ID8gdGhpcy5wYXJzZUltcG9ydChub2RlKSA6IHRoaXMucGFyc2VFeHBvcnQobm9kZSk7XG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJhc3luY1wiKSB7XG4gICAgICAgIC8vIHBlZWsgYWhlYWQgYW5kIHNlZSBpZiBuZXh0IHRva2VuIGlzIGEgZnVuY3Rpb25cbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2Z1bmN0aW9uKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLl9mdW5jdGlvbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgLy8gc2ltcGx5IHN0YXJ0IHBhcnNpbmcgYW4gZXhwcmVzc2lvbiwgYW5kIGFmdGVyd2FyZHMsIGlmIHRoZVxuICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgdmFyIG1heWJlTmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICB9XG59O1xuXG5wcCQxLnRha2VEZWNvcmF0b3JzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICBub2RlLmRlY29yYXRvcnMgPSB0aGlzLnN0YXRlLmRlY29yYXRvcnM7XG4gICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JzID0gW107XG4gIH1cbn07XG5cbnBwJDEucGFyc2VEZWNvcmF0b3JzID0gZnVuY3Rpb24gKGFsbG93RXhwb3J0KSB7XG4gIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgIHZhciBkZWNvcmF0b3IgPSB0aGlzLnBhcnNlRGVjb3JhdG9yKCk7XG4gICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgfVxuXG4gIGlmIChhbGxvd0V4cG9ydCAmJiB0aGlzLm1hdGNoKHR5cGVzLl9leHBvcnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLl9jbGFzcykpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiTGVhZGluZyBkZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBkZWNsYXJhdGlvblwiKTtcbiAgfVxufTtcblxucHAkMS5wYXJzZURlY29yYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY29yYXRvclwiKTtcbn07XG5cbnBwJDEucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuXG4gIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgIG5vZGUubGFiZWwgPSBudWxsO1xuICB9IGVsc2UgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGFuIGFjdHVhbCBkZXN0aW5hdGlvbiB0byBicmVhayBvclxuICAvLyBjb250aW51ZSB0by5cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGgpIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmVhdCh0eXBlcy5zZW1pKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXG4gIHZhciBmb3JBd2FpdCA9IGZhbHNlO1xuICBpZiAodGhpcy5oYXNQbHVnaW4oXCJhc3luY0dlbmVyYXRvcnNcIikgJiYgdGhpcy5zdGF0ZS5pbkFzeW5jICYmIHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikpIHtcbiAgICBmb3JBd2FpdCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zZW1pKSkge1xuICAgIGlmIChmb3JBd2FpdCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpO1xuICB9XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX3ZhcikgfHwgdGhpcy5tYXRjaCh0eXBlcy5fbGV0KSB8fCB0aGlzLm1hdGNoKHR5cGVzLl9jb25zdCkpIHtcbiAgICB2YXIgX2luaXQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB2YXJLaW5kID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoX2luaXQsIHRydWUsIHZhcktpbmQpO1xuICAgIHRoaXMuZmluaXNoTm9kZShfaW5pdCwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2luKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgICBpZiAoX2luaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSAmJiAhX2luaXQuZGVjbGFyYXRpb25zWzBdLmluaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBfaW5pdCwgZm9yQXdhaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yQXdhaXQpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBfaW5pdCk7XG4gIH1cblxuICB2YXIgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyA9IHsgc3RhcnQ6IDAgfTtcbiAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2luKSB8fCB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSA/IFwiZm9yLW9mIHN0YXRlbWVudFwiIDogXCJmb3ItaW4gc3RhdGVtZW50XCI7XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbik7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGZvckF3YWl0KTtcbiAgfSBlbHNlIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICB9XG4gIGlmIChmb3JBd2FpdCkge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSk7XG59O1xuXG5wcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIXRoaXMuc3RhdGUuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7XG4gIH1cblxuICB0aGlzLm5leHQoKTtcblxuICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuY2FzZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXIgPSB2b2lkIDA7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQ7ICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUik7KSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2Nhc2UpIHx8IHRoaXMubWF0Y2godHlwZXMuX2RlZmF1bHQpKSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy5tYXRjaCh0eXBlcy5fY2FzZSk7XG4gICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTtcbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cikge1xuICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjdXIpIHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgdGhpcy5uZXh0KCk7IC8vIENsb3NpbmcgYnJhY2VcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCB0aGlzLnN0YXRlLnN0YXJ0KSkpIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbn07XG5cbi8vIFJldXNlZCBlbXB0eSBhcnJheSBhZGRlZCBmb3Igbm9kZSBmaWVsZHMgdGhhdCBhcmUgYWx3YXlzIGVtcHR5LlxuXG52YXIgZW1wdHkgPSBbXTtcblxucHAkMS5wYXJzZVRyeVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY2F0Y2gpKSB7XG4gICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgdHJ1ZSwgT2JqZWN0LmNyZWF0ZShudWxsKSwgXCJjYXRjaCBjbGF1c2VcIik7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuXG4gIG5vZGUuZ3VhcmRlZEhhbmRsZXJzID0gZW1wdHk7XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuXG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xufTtcblxucHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0KSB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEucGFyc2VFbXB0eVN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG59O1xuXG5wcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlLCBtYXliZU5hbWUsIGV4cHIpIHtcbiAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5zdGF0ZS5sYWJlbHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgX2xhYmVsID0gX3JlZjtcblxuICAgIGlmIChfbGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKSB7XG4gICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGtpbmQgPSB0aGlzLnN0YXRlLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLm1hdGNoKHR5cGVzLl9zd2l0Y2gpID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMuc3RhdGUubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgbGFiZWwua2luZCA9IGtpbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goeyBuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXRlLnN0YXJ0IH0pO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSwgZXhwcikge1xuICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uIChhbGxvd0RpcmVjdGl2ZXMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB0aGlzLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgZmFsc2UsIHR5cGVzLmJyYWNlUik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbn07XG5cbnBwJDEuaXNWYWxpZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChzdG10KSB7XG4gIHJldHVybiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiAhc3RtdC5leHByZXNzaW9uLmV4dHJhLnBhcmVudGhlc2l6ZWQ7XG59O1xuXG5wcCQxLnBhcnNlQmxvY2tCb2R5ID0gZnVuY3Rpb24gKG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCkge1xuICBub2RlLmJvZHkgPSBbXTtcbiAgbm9kZS5kaXJlY3RpdmVzID0gW107XG5cbiAgdmFyIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IGZhbHNlO1xuICB2YXIgb2xkU3RyaWN0ID0gdm9pZCAwO1xuICB2YXIgb2N0YWxQb3NpdGlvbiA9IHZvaWQgMDtcblxuICB3aGlsZSAoIXRoaXMuZWF0KGVuZCkpIHtcbiAgICBpZiAoIXBhcnNlZE5vbkRpcmVjdGl2ZSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5zT2N0YWwgJiYgIW9jdGFsUG9zaXRpb24pIHtcbiAgICAgIG9jdGFsUG9zaXRpb24gPSB0aGlzLnN0YXRlLm9jdGFsUG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUsIHRvcExldmVsKTtcblxuICAgIGlmIChhbGxvd0RpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSAmJiB0aGlzLmlzVmFsaWREaXJlY3RpdmUoc3RtdCkpIHtcbiAgICAgIHZhciBkaXJlY3RpdmUgPSB0aGlzLnN0bXRUb0RpcmVjdGl2ZShzdG10KTtcbiAgICAgIG5vZGUuZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG5cbiAgICAgIGlmIChvbGRTdHJpY3QgPT09IHVuZGVmaW5lZCAmJiBkaXJlY3RpdmUudmFsdWUudmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgIG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgICB0aGlzLnNldFN0cmljdCh0cnVlKTtcblxuICAgICAgICBpZiAob2N0YWxQb3NpdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2Uob2N0YWxQb3NpdGlvbiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cblxuICBpZiAob2xkU3RyaWN0ID09PSBmYWxzZSkge1xuICAgIHRoaXMuc2V0U3RyaWN0KGZhbHNlKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbiAobm9kZSwgaW5pdCkge1xuICBub2RlLmluaXQgPSBpbml0O1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5tYXRjaCh0eXBlcy5zZW1pKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24gKG5vZGUsIGluaXQsIGZvckF3YWl0KSB7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICBpZiAoZm9yQXdhaXQpIHtcbiAgICB0aGlzLmVhdENvbnRleHR1YWwoXCJvZlwiKTtcbiAgICB0eXBlID0gXCJGb3JBd2FpdFN0YXRlbWVudFwiO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSB0aGlzLm1hdGNoKHR5cGVzLl9pbikgPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCI7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbiAobm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgbm9kZS5raW5kID0ga2luZC5rZXl3b3JkO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMucGFyc2VWYXJIZWFkKGRlY2wpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSB0eXBlcy5fY29uc3QgJiYgISh0aGlzLm1hdGNoKHR5cGVzLl9pbikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLm1hdGNoKHR5cGVzLl9pbikgfHwgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSBicmVhaztcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDEucGFyc2VWYXJIZWFkID0gZnVuY3Rpb24gKGRlY2wpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCB0cnVlLCB1bmRlZmluZWQsIFwidmFyaWFibGUgZGVjbGFyYXRpb25cIik7XG59O1xuXG4vLyBQYXJzZSBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jLCBvcHRpb25hbElkKSB7XG4gIHZhciBvbGRJbk1ldGhvZCA9IHRoaXMuc3RhdGUuaW5NZXRob2Q7XG4gIHRoaXMuc3RhdGUuaW5NZXRob2QgPSBmYWxzZTtcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5zdGFyKSkge1xuICAgIGlmIChub2RlLmFzeW5jICYmICF0aGlzLmhhc1BsdWdpbihcImFzeW5jR2VuZXJhdG9yc1wiKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1N0YXRlbWVudCAmJiAhb3B0aW9uYWxJZCAmJiAhdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5feWllbGQpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl95aWVsZCkpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyKCk7XG4gIH1cblxuICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSk7XG5cbiAgdGhpcy5zdGF0ZS5pbk1ldGhvZCA9IG9sZEluTWV0aG9kO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMudGFrZURlY29yYXRvcnMobm9kZSk7XG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHRoaXMucGFyc2VDbGFzc0JvZHkobm9kZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpO1xufTtcblxucHAkMS5pc0NsYXNzUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmVxKSB8fCB0aGlzLm1hdGNoKHR5cGVzLnNlbWkpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKTtcbn07XG5cbnBwJDEuaXNDbGFzc01ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMucGFyZW5MKTtcbn07XG5cbnBwJDEuaXNOb25zdGF0aWNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuICFtZXRob2QuY29tcHV0ZWQgJiYgIW1ldGhvZC5zdGF0aWMgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IC8vIElkZW50aWZpZXJcbiAgbWV0aG9kLmtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiIC8vIExpdGVyYWxcbiAgKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc0JvZHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBjbGFzcyBib2RpZXMgYXJlIGltcGxpY2l0bHkgc3RyaWN0XG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgdGhpcy5zdGF0ZS5zdHJpY3QgPSB0cnVlO1xuXG4gIHZhciBoYWRDb25zdHJ1Y3RvckNhbGwgPSBmYWxzZTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIHZhciBkZWNvcmF0b3JzID0gW107XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG5cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcblxuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsIFwiRGVjb3JhdG9ycyBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBhIHNlbWljb2xvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIC8vIHN0ZWFsIHRoZSBkZWNvcmF0b3JzIGlmIHRoZXJlIGFyZSBhbnlcbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIG1ldGhvZC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBtZXRob2Quc3RhdGljID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpOyAvLyBlYXRzICdzdGF0aWMnXG4gICAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgICAgLy8gYSBtZXRob2QgbmFtZWQgJ3N0YXRpYydcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWV0aG9kLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgICAvLyBhIHByb3BlcnR5IG5hbWVkICdzdGF0aWMnXG4gICAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICBtZXRob2Qua2V5ID0ga2V5O1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KG1ldGhvZCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBzb21ldGhpbmcgc3RhdGljXG4gICAgICBtZXRob2Quc3RhdGljID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICAgIC8vIGEgZ2VuZXJhdG9yXG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShtZXRob2Qua2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZXRob2QuY29tcHV0ZWQgJiYgbWV0aG9kLnN0YXRpYyAmJiAobWV0aG9kLmtleS5uYW1lID09PSBcInByb3RvdHlwZVwiIHx8IG1ldGhvZC5rZXkudmFsdWUgPT09IFwicHJvdG90eXBlXCIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1NpbXBsZSA9IHRoaXMubWF0Y2godHlwZXMubmFtZSk7XG4gICAgICB2YXIgX2tleSA9IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmIG1ldGhvZC5zdGF0aWMgJiYgKG1ldGhvZC5rZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIiB8fCBtZXRob2Qua2V5LnZhbHVlID09PSBcInByb3RvdHlwZVwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgICAvLyBhIG5vcm1hbCBtZXRob2RcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpKSB7XG4gICAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKF9rZXkuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLnN0YXJ0LCBcIllvdSBjYW4ndCBhdHRhY2ggZGVjb3JhdG9ycyB0byBhIGNsYXNzIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgICAvLyBhIG5vcm1hbCBwcm9wZXJ0eVxuICAgICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBub24tc3RhdGljIGZpZWxkIG5hbWVkICdjb25zdHJ1Y3RvcidcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShtZXRob2QpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTaW1wbGUgJiYgX2tleS5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgIC8vIGFuIGFzeW5jIG1ldGhvZFxuICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmhhc1BsdWdpbihcImFzeW5jR2VuZXJhdG9yc1wiKSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtleS5zdGFydCwgXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTaW1wbGUgJiYgKF9rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBfa2V5Lm5hbWUgPT09IFwic2V0XCIpICYmICEodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkgJiYgdGhpcy5tYXRjaCh0eXBlcy5zdGFyKSkpIHtcbiAgICAgICAgLy8gYGdldFxcbipgIGlzIGFuIHVuaW5pdGlhbGl6ZWQgcHJvcGVydHkgbmFtZWQgJ2dldCcgZm9sbG93ZWQgYnkgYSBnZW5lcmF0b3IuXG4gICAgICAgIC8vIGEgZ2V0dGVyIG9yIHNldHRlclxuICAgICAgICBtZXRob2Qua2luZCA9IF9rZXkubmFtZTtcbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgICAgICBpZiAodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKG1ldGhvZC5rZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtQ291bnQobWV0aG9kKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJjbGFzc0NvbnN0cnVjdG9yQ2FsbFwiKSAmJiBpc1NpbXBsZSAmJiBfa2V5Lm5hbWUgPT09IFwiY2FsbFwiICYmIHRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIC8vIGEgKGRlcHJlY2F0ZWQpIGNhbGwgY29uc3RydWN0b3JcbiAgICAgICAgaWYgKGhhZENvbnN0cnVjdG9yQ2FsbCkge1xuICAgICAgICAgIHRoaXMucmFpc2UobWV0aG9kLnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBjYWxsIGluIHRoZSBzYW1lIGNsYXNzXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5kZWNvcmF0b3JzKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShtZXRob2Quc3RhcnQsIFwiWW91IGNhbid0IGF0dGFjaCBkZWNvcmF0b3JzIHRvIGEgY2xhc3MgY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaGFkQ29uc3RydWN0b3JDYWxsID0gdHJ1ZTtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yQ2FsbFwiO1xuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7IC8vIGNvbnN1bWUgXCJjb25zdHJ1Y3RvclwiIGFuZCBtYWtlIGl0IHRoZSBtZXRob2QncyBuYW1lXG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgLy8gYW4gdW5pbml0aWFsaXplZCBjbGFzcyBwcm9wZXJ0eSAoZHVlIHRvIEFTSSwgc2luY2Ugd2UgZG9uJ3Qgb3RoZXJ3aXNlIHJlY29nbml6ZSB0aGUgbmV4dCB0b2tlbilcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShtZXRob2Qua2V5LnN0YXJ0LCBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgbm9uLXN0YXRpYyBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkobWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiWW91IGhhdmUgdHJhaWxpbmcgZGVjb3JhdG9ycyB3aXRoIG5vIG1ldGhvZFwiKTtcbiAgfVxuXG4gIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuXG4gIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMS5wYXJzZUNsYXNzUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSA9IHRydWU7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVxKSkge1xuICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJjbGFzc1Byb3BlcnRpZXNcIikpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICB0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSA9IGZhbHNlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NQcm9wZXJ0eVwiKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIkNsYXNzTWV0aG9kXCIpKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbmFsSWQgfHwgIWlzU3RhdGVtZW50KSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR5cGVzLl9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbn07XG5cbi8vIFBhcnNlcyBtb2R1bGUgZXhwb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlRXhwb3J0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikpIHtcbiAgICB2YXIgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJleHBvcnRFeHRlbnNpb25zXCIpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpXTtcbiAgICAgIHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzTWF5YmUobm9kZSk7XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RXh0ZW5zaW9uc1wiKSAmJiB0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgdmFyIF9zcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIF9zcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKF9zcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgdmFyIF9zcGVjaWZpZXIyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgICBfc3BlY2lmaWVyMi5leHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoX3NwZWNpZmllcjIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnNNYXliZShub2RlKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMuX2RlZmF1bHQpKSB7XG4gICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdmFyIGV4cHIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBuZWVkc1NlbWkgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuX2Z1bmN0aW9uKSkge1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VGdW5jdGlvbihleHByLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fY2xhc3MpKSB7XG4gICAgICBleHByID0gdGhpcy5wYXJzZUNsYXNzKGV4cHIsIHRydWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZWVkc1NlbWkgPSB0cnVlO1xuICAgICAgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIH1cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gZXhwcjtcbiAgICBpZiAobmVlZHNTZW1pKSB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIG5vZGUuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSk7XG4gIH1cbiAgdGhpcy5jaGVja0V4cG9ydChub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG59O1xuXG5wcCQxLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KHRydWUpO1xufTtcblxucHAkMS5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudmFsdWUgIT09IFwiYXN5bmNcIjtcbiAgfVxuXG4gIGlmICghdGhpcy5tYXRjaCh0eXBlcy5fZGVmYXVsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSB0eXBlcy5jb21tYSB8fCBsb29rYWhlYWQudHlwZSA9PT0gdHlwZXMubmFtZSAmJiBsb29rYWhlYWQudmFsdWUgPT09IFwiZnJvbVwiO1xufTtcblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnNNYXliZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKCkpO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlRXhwb3J0RnJvbSA9IGZ1bmN0aW9uIChub2RlLCBleHBlY3QpIHtcbiAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZXhwZWN0KSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fCB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCA9PT0gXCJjb25zdFwiIHx8IHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcImxldFwiIHx8IHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHwgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgPT09IFwiY2xhc3NcIiB8fCB0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpO1xufTtcblxucHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uIChub2RlLCBjaGVja05hbWVzLCBpc0RlZmF1bHQpIHtcbiAgaWYgKGNoZWNrTmFtZXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIGV4cG9ydHNcbiAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAvLyBEZWZhdWx0IGV4cG9ydHNcbiAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuc3BlY2lmaWVycyAmJiBub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAvLyBOYW1lZCBleHBvcnRzXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gbm9kZS5zcGVjaWZpZXJzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgIGlmIChfaTIuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BlY2lmaWVyID0gX3JlZjI7XG5cbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMoc3BlY2lmaWVyLCBzcGVjaWZpZXIuZXhwb3J0ZWQubmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAvLyBFeHBvcnRlZCBkZWNsYXJhdGlvbnNcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbm9kZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gX3JlZjM7XG5cbiAgICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZGVjbGFyYXRpb24uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuc3RhdGUuZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICB2YXIgaXNDbGFzcyA9IG5vZGUuZGVjbGFyYXRpb24gJiYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgfHwgbm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgICBpZiAoIW5vZGUuZGVjbGFyYXRpb24gfHwgIWlzQ2xhc3MpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJZb3UgY2FuIG9ubHkgdXNlIGRlY29yYXRvcnMgb24gYW4gZXhwb3J0IHdoZW4gZXhwb3J0aW5nIGEgY2xhc3NcIik7XG4gICAgfVxuICAgIHRoaXMudGFrZURlY29yYXRvcnMobm9kZS5kZWNsYXJhdGlvbik7XG4gIH1cbn07XG5cbnBwJDEuY2hlY2tEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICB2YXIgX3JlZjQ7XG5cbiAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgaWYgKF9pNC5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjQgPSBfaTQudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gX3JlZjQ7XG5cbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihwcm9wKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkFycmF5UGF0dGVyblwiKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IG5vZGUuZWxlbWVudHMsIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNSksIF9pNSA9IDAsIF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgPyBfaXRlcmF0b3I1IDogX2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCk7XG4gICAgICAgIGlmIChfaTUuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWY1ID0gX2k1LnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbSA9IF9yZWY1O1xuXG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24oZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJSZXN0UHJvcGVydHlcIikge1xuICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgbm9kZS5uYW1lKTtcbiAgfVxufTtcblxucHAkMS5jaGVja0R1cGxpY2F0ZUV4cG9ydHMgPSBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICBpZiAodGhpcy5zdGF0ZS5leHBvcnRlZElkZW50aWZpZXJzLmluZGV4T2YobmFtZSkgPiAtMSkge1xuICAgIHRoaXMucmFpc2VEdXBsaWNhdGVFeHBvcnRFcnJvcihub2RlLCBuYW1lKTtcbiAgfVxuICB0aGlzLnN0YXRlLmV4cG9ydGVkSWRlbnRpZmllcnMucHVzaChuYW1lKTtcbn07XG5cbnBwJDEucmFpc2VEdXBsaWNhdGVFeHBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgbmFtZSA9PT0gXCJkZWZhdWx0XCIgPyBcIk9ubHkgb25lIGRlZmF1bHQgZXhwb3J0IGFsbG93ZWQgcGVyIG1vZHVsZS5cIiA6IFwiYFwiICsgbmFtZSArIFwiYCBoYXMgYWxyZWFkeSBiZWVuIGV4cG9ydGVkLiBFeHBvcnRlZCBpZGVudGlmaWVycyBtdXN0IGJlIHVuaXF1ZS5cIik7XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxucHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgbmVlZHNGcm9tID0gdm9pZCAwO1xuXG4gIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuXG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBpc0RlZmF1bHQgPSB0aGlzLm1hdGNoKHR5cGVzLl9kZWZhdWx0KTtcbiAgICBpZiAoaXNEZWZhdWx0ICYmICFuZWVkc0Zyb20pIG5lZWRzRnJvbSA9IHRydWU7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzRGVmYXVsdCk7XG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSkgOiBub2RlLmxvY2FsLl9fY2xvbmUoKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1iZXItY2xpL2VtYmVyLWNsaS9wdWxsLzM3MzlcbiAgaWYgKG5lZWRzRnJvbSAmJiAhdGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5lYXQodHlwZXMuX2ltcG9ydCk7XG5cbiAgLy8gaW1wb3J0ICcuLi4nXG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLm5hbWUpKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyRGVmYXVsdCh0aGlzLnBhcnNlSWRlbnRpZmllcigpLCBzdGFydFBvcywgc3RhcnRMb2MpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RhcikpIHtcbiAgICB2YXIgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tMVmFsKHNwZWNpZmllci5sb2NhbCwgdHJ1ZSwgdW5kZWZpbmVkLCBcImltcG9ydCBuYW1lc3BhY2Ugc3BlY2lmaWVyXCIpO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERldGVjdCBhbiBhdHRlbXB0IHRvIGRlZXAgZGVzdHJ1Y3R1cmVcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIFwiRVMyMDE1IG5hbWVkIGltcG9ydHMgZG8gbm90IGRlc3RydWN0dXJlLiBVc2UgYW5vdGhlciBzdGF0ZW1lbnQgZm9yIGRlc3RydWN0dXJpbmcgYWZ0ZXIgdGhlIGltcG9ydC5cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmltcG9ydGVkLm5hbWUsIHNwZWNpZmllci5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgfVxuICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIHRydWUsIHVuZGVmaW5lZCwgXCJpbXBvcnQgc3BlY2lmaWVyXCIpO1xuICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG59O1xuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVyRGVmYXVsdCA9IGZ1bmN0aW9uIChpZCwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxvY2FsID0gaWQ7XG4gIHRoaXMuY2hlY2tMVmFsKG5vZGUubG9jYWwsIHRydWUsIHVuZGVmaW5lZCwgXCJkZWZhdWx0IGltcG9ydCBzcGVjaWZpZXJcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpO1xufTtcblxudmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICBpZiAobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG5vZGUucHJvcGVydGllcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOzspIHtcbiAgICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9wID0gX3JlZjtcblxuICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShwcm9wLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZywgXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIlJlc3RQcm9wZXJ0eVwiO1xuICAgICAgICB2YXIgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgbGVmdC1oYW5kIHNpZGVcIiArIChjb250ZXh0RGVzY3JpcHRpb24gPyBcIiBpbiBcIiArIGNvbnRleHREZXNjcmlwdGlvbiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXCJleHByZXNzaW9uXCIpO1xuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBiaW5kaW5nIGxpc3QuXG5cbnBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uIChleHByTGlzdCwgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pIHtcbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIC0tZW5kO1xuICAgIH0gZWxzZSBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICBsYXN0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICB2YXIgYXJnID0gbGFzdC5hcmd1bWVudDtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgICAgaWYgKGFyZy50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBhcmcudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgYXJnLnR5cGUgIT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGFyZy5zdGFydCk7XG4gICAgICB9XG4gICAgICAtLWVuZDtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBlbHQgPSBleHByTGlzdFtpXTtcbiAgICBpZiAoZWx0KSB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgfVxuICByZXR1cm4gZXhwckxpc3Q7XG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBhIGxpc3Qgb2ZcblxucHAkMi50b1JlZmVyZW5jZWRMaXN0ID0gZnVuY3Rpb24gKGV4cHJMaXN0KSB7XG4gIHJldHVybiBleHByTGlzdDtcbn07XG5cbi8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxucHAkMi5wYXJzZVNwcmVhZCA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKTtcbn07XG5cbnBwJDIucGFyc2VSZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKTtcbn07XG5cbnBwJDIuc2hvdWxkQWxsb3dZaWVsZElkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLl95aWVsZCkgJiYgIXRoaXMuc3RhdGUuc3RyaWN0ICYmICF0aGlzLnN0YXRlLmluR2VuZXJhdG9yO1xufTtcblxucHAkMi5wYXJzZUJpbmRpbmdJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodGhpcy5zaG91bGRBbGxvd1lpZWxkSWRlbnRpZmllcigpKTtcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl95aWVsZDpcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCB8fCB0aGlzLnN0YXRlLmluR2VuZXJhdG9yKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAvLyBmYWxsLXRocm91Z2hcbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoY2xvc2UsIGFsbG93RW1wdHkpIHtcbiAgdmFyIGVsdHMgPSBbXTtcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCh0eXBlcy5jb21tYSkpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyh0aGlzLnBhcnNlUmVzdCgpKSk7XG4gICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKHR5cGVzLmF0KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXMobGVmdCk7XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LnN0YXJ0LCBsZWZ0LmxvYy5zdGFydCwgbGVmdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0cztcbn07XG5cbnBwJDIucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICByZXR1cm4gcGFyYW07XG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHN0YXJ0UG9zID0gc3RhcnRQb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgbGVmdCA9IGxlZnQgfHwgdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIGlmICghdGhpcy5lYXQodHlwZXMuZXEpKSByZXR1cm4gbGVmdDtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbiAoZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGV4cHIubmFtZSwgZXhwci5zdGFydCwgZmFsc2UsIHRydWUpO1xuXG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcHJlZml4IHRoaXMgd2l0aCBhbiB1bmRlcnNjb3JlIGZvciB0aGUgY2FzZXMgd2hlcmUgd2UgaGF2ZSBhIGtleSBvZlxuICAgICAgICAvLyBgX19wcm90b19fYC4gdGhlcmUncyBhIGJ1ZyBpbiBvbGQgVjggd2hlcmUgdGhlIGZvbGxvd2luZyB3b3VsZG4ndCB3b3JrOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgID4gdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8vICAgdW5kZWZpbmVkXG4gICAgICAgIC8vICAgPiBvYmouX19wcm90b19fXG4gICAgICAgIC8vICAgbnVsbFxuICAgICAgICAvLyAgID4gb2JqLl9fcHJvdG9fXyA9IHRydWU7XG4gICAgICAgIC8vICAgdHJ1ZVxuICAgICAgICAvLyAgID4gb2JqLl9fcHJvdG9fX1xuICAgICAgICAvLyAgIG51bGxcbiAgICAgICAgdmFyIGtleSA9IFwiX1wiICsgZXhwci5uYW1lO1xuXG4gICAgICAgIGlmIChjaGVja0NsYXNoZXNba2V5XSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrQ2xhc2hlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKGlzQmluZGluZykgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoaXNCaW5kaW5nID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIG1lbWJlciBleHByZXNzaW9uXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGV4cHIucHJvcGVydGllcywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3AgPSBfcmVmMjtcblxuICAgICAgICBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIpIHByb3AgPSBwcm9wLnZhbHVlO1xuICAgICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcywgXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gZXhwci5lbGVtZW50cywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaTMgPSBfaXRlcmF0b3IzLm5leHQoKTtcbiAgICAgICAgICBpZiAoX2kzLmRvbmUpIGJyZWFrO1xuICAgICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW0gPSBfcmVmMztcblxuICAgICAgICBpZiAoZWxlbSkgdGhpcy5jaGVja0xWYWwoZWxlbSwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMsIFwiYXNzaWdubWVudCBwYXR0ZXJuXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUmVzdFByb3BlcnR5XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcywgXCJyZXN0IHByb3BlcnR5XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzLCBcInJlc3QgZWxlbWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAoaXNCaW5kaW5nID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cIkJpbmRpbmcgaW52YWxpZFwiIDogXCJJbnZhbGlkXCIpICsgXCIgbGVmdC1oYW5kIHNpZGVcIiArIChjb250ZXh0RGVzY3JpcHRpb24gPyBcIiBpbiBcIiArIGNvbnRleHREZXNjcmlwdGlvbiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXCJleHByZXNzaW9uXCIpO1xuICAgICAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIG1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vLyBBIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlciBvcGVyYXRlcyBieSBkZWZpbmluZyBmdW5jdGlvbnMgZm9yIGFsbFxuLy8gc3ludGFjdGljIGVsZW1lbnRzLCBhbmQgcmVjdXJzaXZlbHkgY2FsbGluZyB0aG9zZSwgZWFjaCBmdW5jdGlvblxuLy8gYWR2YW5jaW5nIHRoZSBpbnB1dCBzdHJlYW0gYW5kIHJldHVybmluZyBhbiBBU1Qgbm9kZS4gUHJlY2VkZW5jZVxuLy8gb2YgY29uc3RydWN0cyAoZm9yIGV4YW1wbGUsIHRoZSBmYWN0IHRoYXQgYCF4WzFdYCBtZWFucyBgISh4WzFdKWBcbi8vIGluc3RlYWQgb2YgYCgheClbMV1gIGlzIGhhbmRsZWQgYnkgdGhlIGZhY3QgdGhhdCB0aGUgcGFyc2VyXG4vLyBmdW5jdGlvbiB0aGF0IHBhcnNlcyB1bmFyeSBwcmVmaXggb3BlcmF0b3JzIGlzIGNhbGxlZCBmaXJzdCwgYW5kXG4vLyBpbiB0dXJuIGNhbGxzIHRoZSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBgW11gIHN1YnNjcmlwdHMg4oCUIHRoYXRcbi8vIHdheSwgaXQnbGwgcmVjZWl2ZSB0aGUgbm9kZSBmb3IgYHhbMV1gIGFscmVhZHkgcGFyc2VkLCBhbmQgd3JhcHNcbi8vICp0aGF0KiBpbiB0aGUgdW5hcnkgb3BlcmF0b3Igbm9kZS5cbi8vXG4vLyBBY29ybiB1c2VzIGFuIFtvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNlcl1bb3BwXSB0byBoYW5kbGUgYmluYXJ5XG4vLyBvcGVyYXRvciBwcmVjZWRlbmNlLCBiZWNhdXNlIGl0IGlzIG11Y2ggbW9yZSBjb21wYWN0IHRoYW4gdXNpbmdcbi8vIHRoZSB0ZWNobmlxdWUgb3V0bGluZWQgYWJvdmUsIHdoaWNoIHVzZXMgZGlmZmVyZW50LCBuZXN0aW5nXG4vLyBmdW5jdGlvbnMgdG8gc3BlY2lmeSBwcmVjZWRlbmNlLCBmb3IgYWxsIG9mIHRoZSB0ZW4gYmluYXJ5XG4vLyBwcmVjZWRlbmNlIGxldmVscyB0aGF0IEphdmFTY3JpcHQgZGVmaW5lcy5cbi8vXG4vLyBbb3BwXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvci1wcmVjZWRlbmNlX3BhcnNlclxuXG52YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIENoZWNrIGlmIHByb3BlcnR5IG5hbWUgY2xhc2hlcyB3aXRoIGFscmVhZHkgYWRkZWQuXG4vLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4vLyBlaXRoZXIgd2l0aCBlYWNoIG90aGVyIG9yIHdpdGggYW4gaW5pdCBwcm9wZXJ0eSDigJQgYW5kIGluXG4vLyBzdHJpY3QgbW9kZSwgaW5pdCBwcm9wZXJ0aWVzIGFyZSBhbHNvIG5vdCBhbGxvd2VkIHRvIGJlIHJlcGVhdGVkLlxuXG5wcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24gKHByb3AsIHByb3BIYXNoKSB7XG4gIGlmIChwcm9wLmNvbXB1dGVkIHx8IHByb3Aua2luZCkgcmV0dXJuO1xuXG4gIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgLy8gSXQgaXMgZWl0aGVyIGFuIElkZW50aWZpZXIgb3IgYSBTdHJpbmcvTnVtZXJpY0xpdGVyYWxcbiAgdmFyIG5hbWUgPSBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IFN0cmluZyhrZXkudmFsdWUpO1xuXG4gIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgaWYgKHByb3BIYXNoLnByb3RvKSB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpO1xuICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHBhcnNlIGFuIEV4cHJlc3Npb24gb25seVxucHAkMy5nZXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5leHRUb2tlbigpO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIGlmICghdGhpcy5tYXRjaCh0eXBlcy5lb2YpKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbiAocykgYmVsb3cgdGhlbSBwYXJzZSxcbi8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4vLyB0aGUgQVNUIG5vZGUgdGhhdCB0aGUgaW5uZXIgcGFyc2VyIGdhdmUgdGhlbSBpbiBhbm90aGVyIG5vZGUuXG5cbi8vIFBhcnNlIGEgZnVsbCBleHByZXNzaW9uLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZSB1c2VkIHRvXG4vLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0aWFsaXphdGlvbiBleHByZXNzaW9ucylcbi8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4vLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4vLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxucHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29tbWEpKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpKTtcbiAgICB9XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZXhwcmVzc2lvbnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgYWZ0ZXJMZWZ0UGFyc2UsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5feWllbGQpICYmIHRoaXMuc3RhdGUuaW5HZW5lcmF0b3IpIHtcbiAgICB2YXIgX2xlZnQgPSB0aGlzLnBhcnNlWWllbGQoKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIF9sZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBfbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICByZXR1cm4gX2xlZnQ7XG4gIH1cblxuICB2YXIgZmFpbE9uU2hvcnRoYW5kQXNzaWduID0gdm9pZCAwO1xuICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICAgIGZhaWxPblNob3J0aGFuZEFzc2lnbiA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJlZlNob3J0aGFuZERlZmF1bHRQb3MgPSB7IHN0YXJ0OiAwIH07XG4gICAgZmFpbE9uU2hvcnRoYW5kQXNzaWduID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgfHwgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIH1cblxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MsIHJlZk5lZWRzQXJyb3dQb3MpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmICh0aGlzLnN0YXRlLnR5cGUuaXNBc3NpZ24pIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBub2RlLmxlZnQgPSB0aGlzLm1hdGNoKHR5cGVzLmVxKSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIHVuZGVmaW5lZCwgXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIikgOiBsZWZ0O1xuICAgIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQgPSAwOyAvLyByZXNldCBiZWNhdXNlIHNob3J0aGFuZCBkZWZhdWx0IHdhcyB1c2VkIGNvcnJlY3RseVxuXG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiYXNzaWdubWVudCBleHByZXNzaW9uXCIpO1xuXG4gICAgaWYgKGxlZnQuZXh0cmEgJiYgbGVmdC5leHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSB2b2lkIDA7XG4gICAgICBpZiAobGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgICBlcnJvck1zZyA9IFwiYCh7YX0pID0gMGAgdXNlIGAoe2F9ID0gMClgXCI7XG4gICAgICB9IGVsc2UgaWYgKGxlZnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgICBlcnJvck1zZyA9IFwiYChbYV0pID0gMGAgdXNlIGAoW2FdID0gMClgXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgICAgdGhpcy5yYWlzZShsZWZ0LnN0YXJ0LCBcIllvdSdyZSB0cnlpbmcgdG8gYXNzaWduIHRvIGEgcGFyZW50aGVzaXplZCBleHByZXNzaW9uLCBlZy4gaW5zdGVhZCBvZiBcIiArIGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmIChmYWlsT25TaG9ydGhhbmRBc3NpZ24gJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkge1xuICAgIHRoaXMudW5leHBlY3RlZChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiBsZWZ0O1xufTtcblxuLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxucHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAobm9JbiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgcmVmTmVlZHNBcnJvd1Bvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICBpZiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSByZXR1cm4gZXhwcjtcblxuICByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmTmVlZHNBcnJvd1Bvcyk7XG59O1xuXG5wcCQzLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoZXhwciwgbm9Jbiwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICB9XG4gIHJldHVybiBleHByO1xufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uIChub0luLCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zICYmIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbi8vIGFsZ29yaXRobS4gYGxlZnRgIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgb3BlcmF0b3IuXG4vLyBgbWluUHJlY2AgcHJvdmlkZXMgY29udGV4dCB0aGF0IGFsbG93cyB0aGUgZnVuY3Rpb24gdG8gc3RvcCBhbmRcbi8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbi8vIG9wZXJhdG9yIHRoYXQgaGFzIGEgbG93ZXIgcHJlY2VkZW5jZSB0aGFuIHRoZSBzZXQgaXQgaXMgcGFyc2luZy5cblxucHAkMy5wYXJzZUV4cHJPcCA9IGZ1bmN0aW9uIChsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICB2YXIgcHJlYyA9IHRoaXMuc3RhdGUudHlwZS5iaW5vcDtcbiAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgIXRoaXMubWF0Y2godHlwZXMuX2luKSkpIHtcbiAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcIioqXCIgJiYgbGVmdC50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiICYmIGxlZnQuZXh0cmEgJiYgIWxlZnQuZXh0cmEucGFyZW50aGVzaXplZEFyZ3VtZW50ICYmICFsZWZ0LmV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShsZWZ0LmFyZ3VtZW50LnN0YXJ0LCBcIklsbGVnYWwgZXhwcmVzc2lvbi4gV3JhcCBsZWZ0IGhhbmQgc2lkZSBvciBlbnRpcmUgZXhwb25lbnRpYXRpb24gaW4gcGFyZW50aGVzZXMuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3AgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIG9wLnJpZ2h0QXNzb2NpYXRpdmUgPyBwcmVjIC0gMSA6IHByZWMsIG5vSW4pO1xuXG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3AgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCBvcCA9PT0gdHlwZXMubG9naWNhbEFORCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlZnQ7XG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIGlmICh0aGlzLnN0YXRlLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciB1cGRhdGUgPSB0aGlzLm1hdGNoKHR5cGVzLmluY0RlYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGFyZ1R5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG5cbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicGFyZW50aGVzaXplZEFyZ3VtZW50XCIsIGFyZ1R5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vZGUuYXJndW1lbnQuZXh0cmEgfHwgIW5vZGUuYXJndW1lbnQuZXh0cmEucGFyZW50aGVzaXplZCkpO1xuXG4gICAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcInByZWZpeCBvcGVyYXRpb25cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH1cblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZTaG9ydGhhbmREZWZhdWx0UG9zKTtcbiAgaWYgKHJlZlNob3J0aGFuZERlZmF1bHRQb3MgJiYgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCkgcmV0dXJuIGV4cHI7XG4gIHdoaWxlICh0aGlzLnN0YXRlLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIHZhciBfbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBfbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgX25vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgX25vZGUuYXJndW1lbnQgPSBleHByO1xuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcInBvc3RmaXggb3BlcmF0aW9uXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gZXhwcjtcbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbiAocmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG5cbiAgaWYgKGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIGV4cHIuc3RhcnQgPT09IHBvdGVudGlhbEFycm93QXQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zICYmIHJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyhleHByLCBzdGFydFBvcywgc3RhcnRMb2MpO1xufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbiAoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMuZG91YmxlQ29sb24pKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBfbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBfbm9kZTIub2JqZWN0ID0gYmFzZTtcbiAgICAgIF9ub2RlMi5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgX25vZGUyLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKF9ub2RlMiwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICB2YXIgX25vZGUzID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgX25vZGUzLm9iamVjdCA9IGJhc2U7XG4gICAgICBfbm9kZTMucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgX25vZGUzLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGUzLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkpIHtcbiAgICAgIHZhciBwb3NzaWJsZUFzeW5jID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSBiYXNlLnN0YXJ0ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgdmFyIF9ub2RlNCA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIF9ub2RlNC5jYWxsZWUgPSBiYXNlO1xuICAgICAgX25vZGU0LmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyh0eXBlcy5wYXJlblIsIHBvc3NpYmxlQXN5bmMpO1xuICAgICAgaWYgKF9ub2RlNC5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIiAmJiBfbm9kZTQuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKF9ub2RlNC5zdGFydCwgXCJpbXBvcnQoKSByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgIH1cbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGU0LCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuXG4gICAgICBpZiAocG9zc2libGVBc3luYyAmJiB0aGlzLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIF9ub2RlNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3QoX25vZGU0LmFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmJhY2tRdW90ZSkpIHtcbiAgICAgIHZhciBfbm9kZTUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBfbm9kZTUudGFnID0gYmFzZTtcbiAgICAgIF9ub2RlNS5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0cnVlKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUoX25vZGU1LCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XG59O1xuXG5wcCQzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMgPSBmdW5jdGlvbiAoY2xvc2UsIHBvc3NpYmxlQXN5bmNBcnJvdykge1xuICB2YXIgZWx0cyA9IFtdO1xuICB2YXIgaW5uZXJQYXJlblN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuXG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5lYXQoY2xvc2UpKSBicmVhaztcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHRoaXMgaXMgYW4gYXN5bmMgYXJyb3cgZnVuY3Rpb25zLCB0aGF0IHdlIGRvbid0IGFsbG93IGlubmVyIHBhcmVucyBpbnNpZGUgdGhlIHBhcmFtc1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgaW5uZXJQYXJlblN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG5cbiAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShmYWxzZSwgcG9zc2libGVBc3luY0Fycm93ID8geyBzdGFydDogMCB9IDogdW5kZWZpbmVkLCBwb3NzaWJsZUFzeW5jQXJyb3cgPyB7IHN0YXJ0OiAwIH0gOiB1bmRlZmluZWQpKTtcbiAgfVxuXG4gIC8vIHdlIGZvdW5kIGFuIGFzeW5jIGFycm93IGZ1bmN0aW9uIHNvIGxldCdzIG5vdCBhbGxvdyBhbnkgaW5uZXIgcGFyZW5zXG4gIGlmIChwb3NzaWJsZUFzeW5jQXJyb3cgJiYgaW5uZXJQYXJlblN0YXJ0ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIHJldHVybiBlbHRzO1xufTtcblxucHAkMy5zaG91bGRQYXJzZUFzeW5jQXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmFycm93KTtcbn07XG5cbnBwJDMucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUsIGNhbGwpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMuYXJyb3cpO1xuICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBjYWxsLmFyZ3VtZW50cywgdHJ1ZSk7XG59O1xuXG4vLyBQYXJzZSBhIG5vLWNhbGwgZXhwcmVzc2lvbiAobGlrZSBhcmd1bWVudCBvZiBgbmV3YCBvciBgOjpgIG9wZXJhdG9ycykuXG5cbnBwJDMucGFyc2VOb0NhbGxFeHByID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG59O1xuXG4vLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiDigJQgZWl0aGVyIGEgc2luZ2xlIHRva2VuIHRoYXQgaXMgYW5cbi8vIGV4cHJlc3Npb24sIGFuIGV4cHJlc3Npb24gc3RhcnRlZCBieSBhIGtleXdvcmQgbGlrZSBgZnVuY3Rpb25gIG9yXG4vLyBgbmV3YCwgb3IgYW4gZXhwcmVzc2lvbiB3cmFwcGVkIGluIHB1bmN0dWF0aW9uIGxpa2UgYCgpYCwgYFtdYCxcbi8vIG9yIGB7fWAuXG5cbnBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcblxuICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuX3N1cGVyOlxuICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTWV0aG9kICYmICF0aGlzLnN0YXRlLmluQ2xhc3NQcm9wZXJ0eSAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCwgXCInc3VwZXInIG91dHNpZGUgb2YgZnVuY3Rpb24gb3IgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5MKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5icmFja2V0TCkgJiYgIXRoaXMubWF0Y2godHlwZXMuZG90KSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBhcmVuTCkgJiYgdGhpcy5zdGF0ZS5pbk1ldGhvZCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmICF0aGlzLm9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcInN1cGVyKCkgb3V0c2lkZSBvZiBjbGFzcyBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdXBlclwiKTtcblxuICAgIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJkeW5hbWljSW1wb3J0XCIpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcblxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0eXBlcy5wYXJlbkwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKTtcblxuICAgIGNhc2UgdHlwZXMuX3RoaXM6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5feWllbGQ6XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pbkdlbmVyYXRvcikgdGhpcy51bmV4cGVjdGVkKCk7XG5cbiAgICBjYXNlIHR5cGVzLm5hbWU6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHZhciBhbGxvd0F3YWl0ID0gdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJhd2FpdFwiICYmIHRoaXMuc3RhdGUuaW5Bc3luYztcbiAgICAgIHZhciBhbGxvd1lpZWxkID0gdGhpcy5zaG91bGRBbGxvd1lpZWxkSWRlbnRpZmllcigpO1xuICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoYWxsb3dBd2FpdCB8fCBhbGxvd1lpZWxkKTtcblxuICAgICAgaWYgKGlkLm5hbWUgPT09IFwiYXdhaXRcIikge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkFzeW5jIHx8IHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQmVBcnJvdyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gW3RoaXMucGFyc2VJZGVudGlmaWVyKCldO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG4gICAgICAgIC8vIGxldCBmb28gPSBiYXIgPT4ge307XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBbaWRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuXG4gICAgY2FzZSB0eXBlcy5fZG86XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkb0V4cHJlc3Npb25zXCIpKSB7XG4gICAgICAgIHZhciBfbm9kZTYgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIG9sZEluRnVuY3Rpb24gPSB0aGlzLnN0YXRlLmluRnVuY3Rpb247XG4gICAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgICAgIF9ub2RlNi5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uID0gb2xkSW5GdW5jdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoX25vZGU2LCBcIkRvRXhwcmVzc2lvblwiKTtcbiAgICAgIH1cblxuICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZS52YWx1ZSwgXCJSZWdFeHBMaXRlcmFsXCIpO1xuICAgICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICAgIG5vZGUuZmxhZ3MgPSB2YWx1ZS5mbGFncztcbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgY2FzZSB0eXBlcy5udW06XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgdHlwZXMuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcblxuICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5fdHJ1ZTpjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMubWF0Y2godHlwZXMuX3RydWUpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG5cbiAgICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24obnVsbCwgbnVsbCwgY2FuQmVBcnJvdyk7XG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZWxlbWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuXG4gICAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbigpO1xuXG4gICAgY2FzZSB0eXBlcy5hdDpcbiAgICAgIHRoaXMucGFyc2VEZWNvcmF0b3JzKCk7XG5cbiAgICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50YWtlRGVjb3JhdG9ycyhub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgZmFsc2UpO1xuXG4gICAgY2FzZSB0eXBlcy5fbmV3OlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKTtcblxuICAgIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG5cbiAgICBjYXNlIHR5cGVzLmRvdWJsZUNvbG9uOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUub2JqZWN0ID0gbnVsbDtcbiAgICAgIHZhciBjYWxsZWUgPSBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoY2FsbGVlLnN0YXJ0LCBcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gIGlmICh0aGlzLnN0YXRlLmluR2VuZXJhdG9yICYmIHRoaXMuZWF0KHR5cGVzLmRvdCkgJiYgdGhpcy5oYXNQbHVnaW4oXCJmdW5jdGlvblNlbnRcIikpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInNlbnRcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSk7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VNZXRhUHJvcGVydHkgPSBmdW5jdGlvbiAobm9kZSwgbWV0YSwgcHJvcGVydHlOYW1lKSB7XG4gIG5vZGUubWV0YSA9IG1ldGE7XG4gIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIFwiICsgbWV0YS5uYW1lICsgXCIuXCIgKyBwcm9wZXJ0eU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKTtcbn07XG5cbnBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlLCBzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdcIiwgdGhpcy5pbnB1dC5zbGljZShzdGFydFBvcywgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHZhciB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICByZXR1cm4gdmFsO1xufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgY2FuQmVBcnJvdykge1xuICBzdGFydFBvcyA9IHN0YXJ0UG9zIHx8IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHN0YXJ0TG9jID0gc3RhcnRMb2MgfHwgdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICB2YXIgdmFsID0gdm9pZCAwO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuXG4gIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgZXhwckxpc3QgPSBbXTtcbiAgdmFyIHJlZlNob3J0aGFuZERlZmF1bHRQb3MgPSB7IHN0YXJ0OiAwIH07XG4gIHZhciByZWZOZWVkc0Fycm93UG9zID0geyBzdGFydDogMCB9O1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgc3ByZWFkU3RhcnQgPSB2b2lkIDA7XG4gIHZhciBvcHRpb25hbENvbW1hU3RhcnQgPSB2b2lkIDA7XG5cbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hLCByZWZOZWVkc0Fycm93UG9zLnN0YXJ0IHx8IG51bGwpO1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSkge1xuICAgICAgICBvcHRpb25hbENvbW1hU3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIHZhciBzcHJlYWROb2RlU3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgdmFyIHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3QoKSwgc3ByZWFkTm9kZVN0YXJ0UG9zLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgdGhpcy5wYXJzZVBhcmVuSXRlbSwgcmVmTmVlZHNBcnJvd1BvcykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBpbm5lckVuZExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG5cbiAgdmFyIGFycm93Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KCkgJiYgKGFycm93Tm9kZSA9IHRoaXMucGFyc2VBcnJvdyhhcnJvd05vZGUpKSkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGV4cHJMaXN0LCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW0gPSBfcmVmO1xuXG4gICAgICBpZiAocGFyYW0uZXh0cmEgJiYgcGFyYW0uZXh0cmEucGFyZW50aGVzaXplZCkgdGhpcy51bmV4cGVjdGVkKHBhcmFtLmV4dHJhLnBhcmVuU3RhcnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QpO1xuICB9XG5cbiAgaWYgKCFleHByTGlzdC5sZW5ndGgpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpO1xuICB9XG4gIGlmIChvcHRpb25hbENvbW1hU3RhcnQpIHRoaXMudW5leHBlY3RlZChvcHRpb25hbENvbW1hU3RhcnQpO1xuICBpZiAoc3ByZWFkU3RhcnQpIHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7XG4gIGlmIChyZWZTaG9ydGhhbmREZWZhdWx0UG9zLnN0YXJ0KSB0aGlzLnVuZXhwZWN0ZWQocmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCk7XG4gIGlmIChyZWZOZWVkc0Fycm93UG9zLnN0YXJ0KSB0aGlzLnVuZXhwZWN0ZWQocmVmTmVlZHNBcnJvd1Bvcy5zdGFydCk7XG5cbiAgaWYgKGV4cHJMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdCh2YWwuZXhwcmVzc2lvbnMpO1xuICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgfVxuXG4gIHRoaXMuYWRkRXh0cmEodmFsLCBcInBhcmVudGhlc2l6ZWRcIiwgdHJ1ZSk7XG4gIHRoaXMuYWRkRXh0cmEodmFsLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRQb3MpO1xuXG4gIHJldHVybiB2YWw7XG59O1xuXG5wcCQzLnNob3VsZFBhcnNlQXJyb3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbn07XG5cbnBwJDMucGFyc2VBcnJvdyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gTmV3J3MgcHJlY2VkZW5jZSBpcyBzbGlnaHRseSB0cmlja3kuIEl0IG11c3QgYWxsb3cgaXRzIGFyZ3VtZW50XG4vLyB0byBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXRcbi8vIGxlYXN0LCBub3Qgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBwYXJlbnRoZXNlcy4gVGh1cywgaXQgdXNlcyB0aGVcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbWV0YSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgdmFyIG1ldGFQcm9wID0gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInRhcmdldFwiKTtcblxuICAgIGlmICghdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnJhaXNlKG1ldGFQcm9wLnByb3BlcnR5LnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFQcm9wO1xuICB9XG5cbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SKTtcbiAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXJndW1lbnRzID0gW107XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoaXNUYWdnZWQpIHtcbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgIGlmICghaXNUYWdnZWQgfHwgIXRoaXMuaGFzUGx1Z2luKFwidGVtcGxhdGVJbnZhbGlkRXNjYXBlc1wiKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uLCBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmludmFsaWRUZW1wbGF0ZUVzY2FwZVBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZWxlbS52YWx1ZSA9IHtcbiAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgY29va2VkOiB0aGlzLnN0YXRlLnZhbHVlXG4gIH07XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLm1hdGNoKHR5cGVzLmJhY2tRdW90ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIik7XG59O1xuXG5wcCQzLnBhcnNlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaXNUYWdnZWQpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xufTtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYmluZGluZyBwYXR0ZXJuLlxuXG5wcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24gKGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICB2YXIgZGVjb3JhdG9ycyA9IFtdO1xuICB2YXIgcHJvcEhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuXG4gIHZhciBmaXJzdFJlc3RMb2NhdGlvbiA9IG51bGw7XG5cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBmaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2VSKSkgYnJlYWs7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMubWF0Y2godHlwZXMuYXQpKSB7XG4gICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksXG4gICAgICAgIGlzR2VuZXJhdG9yID0gZmFsc2UsXG4gICAgICAgIGlzQXN5bmMgPSBmYWxzZSxcbiAgICAgICAgc3RhcnRQb3MgPSB2b2lkIDAsXG4gICAgICAgIHN0YXJ0TG9jID0gdm9pZCAwO1xuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcHJvcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJvYmplY3RSZXN0U3ByZWFkXCIpICYmIHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICBwcm9wID0gdGhpcy5wYXJzZVNwcmVhZChpc1BhdHRlcm4gPyB7IHN0YXJ0OiAwIH0gOiB1bmRlZmluZWQpO1xuICAgICAgcHJvcC50eXBlID0gaXNQYXR0ZXJuID8gXCJSZXN0UHJvcGVydHlcIiA6IFwiU3ByZWFkUHJvcGVydHlcIjtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AuYXJndW1lbnQsIHRydWUsIFwib2JqZWN0IHBhdHRlcm5cIik7XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgaWYgKGZpcnN0UmVzdExvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGZpcnN0UmVzdExvY2F0aW9uLCBcIkNhbm5vdCBoYXZlIG11bHRpcGxlIHJlc3QgZWxlbWVudHMgd2hlbiBkZXN0cnVjdHVyaW5nXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmJyYWNlUikge1xuICAgICAgICAgIC8vIFRPRE86IHRlbXBvcmFyeSByb2xsYmFja1xuICAgICAgICAgIC8vIHRoaXMudW5leHBlY3RlZChwb3NpdGlvbiwgXCJBIHRyYWlsaW5nIGNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdFJlc3RMb2NhdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG5cbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG5cbiAgICBpZiAoIWlzUGF0dGVybikge1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGF0dGVybiAmJiB0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHRoaXMudW5leHBlY3RlZCgpO1xuXG4gICAgICB2YXIgYXN5bmNJZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmVxKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSkge1xuICAgICAgICBwcm9wLmtleSA9IGFzeW5jSWQ7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJhc3luY0dlbmVyYXRvcnNcIikpIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICAgIHRoaXMuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gpO1xuXG4gICAgaWYgKHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKHByb3AsIFwic2hvcnRoYW5kXCIsIHRydWUpO1xuICAgIH1cblxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG5cbiAgaWYgKGZpcnN0UmVzdExvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKGZpcnN0UmVzdExvY2F0aW9uLCBcIlRoZSByZXN0IGVsZW1lbnQgaGFzIHRvIGJlIHRoZSBsYXN0IGVsZW1lbnQgd2hlbiBkZXN0cnVjdHVyaW5nXCIpO1xuICB9XG5cbiAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIllvdSBoYXZlIHRyYWlsaW5nIGRlY29yYXRvcnMgd2l0aCBubyBwcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIik7XG59O1xuXG5wcCQzLmlzR2V0dGVyT3JTZXR0ZXJNZXRob2QgPSBmdW5jdGlvbiAocHJvcCwgaXNQYXR0ZXJuKSB7XG4gIHJldHVybiAhaXNQYXR0ZXJuICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmICh0aGlzLm1hdGNoKHR5cGVzLnN0cmluZykgfHwgLy8gZ2V0IFwic3RyaW5nXCIoKSB7fVxuICB0aGlzLm1hdGNoKHR5cGVzLm51bSkgfHwgLy8gZ2V0IDEoKSB7fVxuICB0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSB8fCAvLyBnZXQgW1wic3RyaW5nXCJdKCkge31cbiAgdGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCAvLyBnZXQgZm9vKCkge31cbiAgdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQgLy8gZ2V0IGRlYnVnZ2VyKCkge31cbiAgKTtcbn07XG5cbi8vIGdldCBtZXRob2RzIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgYW55IHBhcmFtZXRlcnNcbi8vIHNldCBtZXRob2RzIG11c3QgaGF2ZSBleGFjdGx5IDEgcGFyYW1ldGVyXG5wcCQzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1Db3VudCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgdmFyIHBhcmFtQ291bnQgPSBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICBpZiAobWV0aG9kLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICB2YXIgc3RhcnQgPSBtZXRob2Quc3RhcnQ7XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFpc2Uoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpO1xuICAgIH1cbiAgfVxufTtcblxucHAkMy5wYXJzZU9iamVjdE1ldGhvZCA9IGZ1bmN0aW9uIChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuKSB7XG4gIGlmIChpc0FzeW5jIHx8IGlzR2VuZXJhdG9yIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHByb3Aua2luZCA9IFwibWV0aG9kXCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdE1ldGhvZFwiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmlzR2V0dGVyT3JTZXR0ZXJNZXRob2QocHJvcCwgaXNQYXR0ZXJuKSkge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgdGhpcy5wYXJzZU1ldGhvZChwcm9wKTtcbiAgICB0aGlzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1Db3VudChwcm9wKTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RNZXRob2RcIik7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VPYmplY3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcykge1xuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdFByb3BlcnR5XCIpO1xuICB9XG5cbiAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChwcm9wLmtleS5uYW1lLCBwcm9wLmtleS5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5Ll9fY2xvbmUoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmVxKSAmJiByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gICAgICBpZiAoIXJlZlNob3J0aGFuZERlZmF1bHRQb3Muc3RhcnQpIHtcbiAgICAgICAgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcy5zdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICB9XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5Ll9fY2xvbmUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleS5fX2Nsb25lKCk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgfVxufTtcblxucHAkMy5wYXJzZU9ialByb3BWYWx1ZSA9IGZ1bmN0aW9uIChwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4pIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcyk7XG5cbiAgaWYgKCFub2RlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAocHJvcCkge1xuICBpZiAodGhpcy5lYXQodHlwZXMuYnJhY2tldEwpKSB7XG4gICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gIH0gZWxzZSB7XG4gICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgIHZhciBvbGRJblByb3BlcnR5TmFtZSA9IHRoaXMuc3RhdGUuaW5Qcm9wZXJ0eU5hbWU7XG4gICAgdGhpcy5zdGF0ZS5pblByb3BlcnR5TmFtZSA9IHRydWU7XG4gICAgcHJvcC5rZXkgPSB0aGlzLm1hdGNoKHR5cGVzLm51bSkgfHwgdGhpcy5tYXRjaCh0eXBlcy5zdHJpbmcpID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lID0gb2xkSW5Qcm9wZXJ0eU5hbWU7XG4gIH1cbiAgcmV0dXJuIHByb3Aua2V5O1xufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBpc0FzeW5jKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgbm9kZS5hc3luYyA9ICEhaXNBc3luYztcbn07XG5cbi8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbnBwJDMucGFyc2VNZXRob2QgPSBmdW5jdGlvbiAobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgdmFyIG9sZEluTWV0aG9kID0gdGhpcy5zdGF0ZS5pbk1ldGhvZDtcbiAgdGhpcy5zdGF0ZS5pbk1ldGhvZCA9IG5vZGUua2luZCB8fCB0cnVlO1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5nZW5lcmF0b3IgPSAhIWlzR2VuZXJhdG9yO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUpO1xuICB0aGlzLnN0YXRlLmluTWV0aG9kID0gb2xkSW5NZXRob2Q7XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUsIFwiYXJyb3cgZnVuY3Rpb24gcGFyYW1ldGVyc1wiKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xufTtcblxucHAkMy5pc1N0cmljdEJvZHkgPSBmdW5jdGlvbiAobm9kZSwgaXNFeHByZXNzaW9uKSB7XG4gIGlmICghaXNFeHByZXNzaW9uICYmIG5vZGUuYm9keS5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLmJvZHkuZGlyZWN0aXZlcywgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICB2YXIgX3JlZjI7XG5cbiAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaTIgPSBfaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgaWYgKF9pMi5kb25lKSBicmVhaztcbiAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3RpdmUgPSBfcmVmMjtcblxuICAgICAgaWYgKGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cbnBwJDMucGFyc2VGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbiAobm9kZSwgYWxsb3dFeHByZXNzaW9uKSB7XG4gIHZhciBpc0V4cHJlc3Npb24gPSBhbGxvd0V4cHJlc3Npb24gJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VMKTtcblxuICB2YXIgb2xkSW5Bc3luYyA9IHRoaXMuc3RhdGUuaW5Bc3luYztcbiAgdGhpcy5zdGF0ZS5pbkFzeW5jID0gbm9kZS5hc3luYztcbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkSW5GdW5jID0gdGhpcy5zdGF0ZS5pbkZ1bmN0aW9uO1xuICAgIHZhciBvbGRJbkdlbiA9IHRoaXMuc3RhdGUuaW5HZW5lcmF0b3I7XG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUuaW5GdW5jdGlvbiA9IHRydWU7dGhpcy5zdGF0ZS5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO3RoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKHRydWUpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUuaW5GdW5jdGlvbiA9IG9sZEluRnVuYzt0aGlzLnN0YXRlLmluR2VuZXJhdG9yID0gb2xkSW5HZW47dGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5zdGF0ZS5pbkFzeW5jID0gb2xkSW5Bc3luYztcblxuICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gIC8vIG9yIGBhcmd1bWVudHNgLlxuICB2YXIgaXNTdHJpY3QgPSB0aGlzLmlzU3RyaWN0Qm9keShub2RlLCBpc0V4cHJlc3Npb24pO1xuICAvLyBBbHNvIGNoZWNrIHdoZW4gYWxsb3dFeHByZXNzaW9uID09PSB0cnVlIGZvciBhcnJvdyBmdW5jdGlvbnNcbiAgdmFyIGNoZWNrTFZhbCA9IHRoaXMuc3RhdGUuc3RyaWN0IHx8IGFsbG93RXhwcmVzc2lvbiB8fCBpc1N0cmljdDtcblxuICBpZiAoaXNTdHJpY3QgJiYgbm9kZS5pZCAmJiBub2RlLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUuaWQubmFtZSA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLmlkLnN0YXJ0LCBcIkJpbmRpbmcgeWllbGQgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cblxuICBpZiAoY2hlY2tMVmFsKSB7XG4gICAgdmFyIG5hbWVIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgaWYgKGlzU3RyaWN0KSB0aGlzLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gICAgaWYgKG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIHRydWUsIHVuZGVmaW5lZCwgXCJmdW5jdGlvbiBuYW1lXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbm9kZS5wYXJhbXMsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCk7XG4gICAgICAgIGlmIChfaTMuZG9uZSkgYnJlYWs7XG4gICAgICAgIF9yZWYzID0gX2kzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyYW0gPSBfcmVmMztcblxuICAgICAgaWYgKGlzU3RyaWN0ICYmIHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGFyYW0uc3RhcnQsIFwiTm9uLXNpbXBsZSBwYXJhbWV0ZXIgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgdHJ1ZSwgbmFtZUhhc2gsIFwiZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3RcIik7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbi8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbi8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxucHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24gKGNsb3NlLCBhbGxvd0VtcHR5LCByZWZTaG9ydGhhbmREZWZhdWx0UG9zKSB7XG4gIHZhciBlbHRzID0gW107XG4gIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmVhdChjbG9zZSkpIGJyZWFrO1xuICAgIH1cblxuICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZlNob3J0aGFuZERlZmF1bHRQb3MpKTtcbiAgfVxuICByZXR1cm4gZWx0cztcbn07XG5cbnBwJDMucGFyc2VFeHByTGlzdEl0ZW0gPSBmdW5jdGlvbiAoYWxsb3dFbXB0eSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgcmVmTmVlZHNBcnJvd1Bvcykge1xuICB2YXIgZWx0ID0gdm9pZCAwO1xuICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLm1hdGNoKHR5cGVzLmNvbW1hKSkge1xuICAgIGVsdCA9IG51bGw7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBlbHQgPSB0aGlzLnBhcnNlU3ByZWFkKHJlZlNob3J0aGFuZERlZmF1bHRQb3MpO1xuICB9IGVsc2Uge1xuICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmU2hvcnRoYW5kRGVmYXVsdFBvcywgdGhpcy5wYXJzZVBhcmVuSXRlbSwgcmVmTmVlZHNBcnJvd1Bvcyk7XG4gIH1cbiAgcmV0dXJuIGVsdDtcbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChsaWJlcmFsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZCh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0LCAhIXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkLCBmYWxzZSk7XG4gIH1cblxuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGlmICghbGliZXJhbCAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIiAmJiB0aGlzLnN0YXRlLmluQXN5bmMpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiaW52YWxpZCB1c2Ugb2YgYXdhaXQgaW5zaWRlIG9mIGFuIGFzeW5jIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBub2RlLm5hbWU7XG5cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xufTtcblxucHAkMy5jaGVja1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uICh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gIGlmICh0aGlzLmlzUmVzZXJ2ZWRXb3JkKHdvcmQpIHx8IGNoZWNrS2V5d29yZHMgJiYgdGhpcy5pc0tleXdvcmQod29yZCkpIHtcbiAgICB0aGlzLnJhaXNlKHN0YXJ0TG9jLCB3b3JkICsgXCIgaXMgYSByZXNlcnZlZCB3b3JkXCIpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIChyZXNlcnZlZFdvcmRzLnN0cmljdCh3b3JkKSB8fCBpc0JpbmRpbmcgJiYgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKHdvcmQpKSkge1xuICAgIHRoaXMucmFpc2Uoc3RhcnRMb2MsIHdvcmQgKyBcIiBpcyBhIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGVcIik7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhd2FpdCBleHByZXNzaW9uIGluc2lkZSBhc3luYyBmdW5jdGlvbi5cblxucHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IHRoaXMgY29uZGl0aW9uIGlzIGNoZWNrZWQgYXQgdGhlIGNhbGwgc2l0ZSBzbyB3b24ndCBiZSBoaXQgaGVyZVxuICBpZiAoIXRoaXMuc3RhdGUuaW5Bc3luYykge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnN0YXIpKSB7XG4gICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcImF3YWl0KiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIik7XG4gIH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnNlbWkpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2godHlwZXMuc3RhcikgJiYgIXRoaXMuc3RhdGUudHlwZS5zdGFydHNFeHByKSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcbnZhciBjb21tZW50S2V5cyA9IFtcImxlYWRpbmdDb21tZW50c1wiLCBcInRyYWlsaW5nQ29tbWVudHNcIiwgXCJpbm5lckNvbW1lbnRzXCJdO1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZShwb3MsIGxvYywgZmlsZW5hbWUpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24obG9jKTtcbiAgICBpZiAoZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gIH1cblxuICBOb2RlLnByb3RvdHlwZS5fX2Nsb25lID0gZnVuY3Rpb24gX19jbG9uZSgpIHtcbiAgICB2YXIgbm9kZTIgPSBuZXcgTm9kZSgpO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAvLyBEbyBub3QgY2xvbmUgY29tbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgbm9kZVxuICAgICAgaWYgKGNvbW1lbnRLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgbm9kZTJba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTI7XG4gIH07XG5cbiAgcmV0dXJuIE5vZGU7XG59KCk7XG5cbnBwJDQuc3RhcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE5vZGUodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYywgdGhpcy5maWxlbmFtZSk7XG59O1xuXG5wcCQ0LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24gKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZShwb3MsIGxvYywgdGhpcy5maWxlbmFtZSk7XG59O1xuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIG5vZGUubG9jLmVuZCA9IGxvYztcbiAgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxucHAkNC5maW5pc2hOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDQuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24gKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYyk7XG59O1xuXG52YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ1LnJhaXNlID0gZnVuY3Rpb24gKHBvcywgbWVzc2FnZSkge1xuICB2YXIgbG9jID0gZ2V0TGluZUluZm8odGhpcy5pbnB1dCwgcG9zKTtcbiAgbWVzc2FnZSArPSBcIiAoXCIgKyBsb2MubGluZSArIFwiOlwiICsgbG9jLmNvbHVtbiArIFwiKVwiO1xuICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICBlcnIucG9zID0gcG9zO1xuICBlcnIubG9jID0gbG9jO1xuICB0aHJvdyBlcnI7XG59O1xuXG4vKiBlc2xpbnQgbWF4LWxlbjogMCAqL1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBjb21tZW50IGF0dGFjaG1lbnQgYWxnb3JpdGhtIHVzZWQgaW4gZXNwcmVlIGFuZCBlc3RyYXZlcnNlLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAqIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAqIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAqIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuZnVuY3Rpb24gbGFzdChzdGFjaykge1xuICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG59XG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5hZGRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgaWYgKHRoaXMuZmlsZW5hbWUpIGNvbW1lbnQubG9jLmZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gIHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG59O1xuXG5wcCQ2LnByb2Nlc3NDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJQcm9ncmFtXCIgJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHJldHVybjtcblxuICB2YXIgc3RhY2sgPSB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjaztcblxuICB2YXIgZmlyc3RDaGlsZCA9IHZvaWQgMCxcbiAgICAgIGxhc3RDaGlsZCA9IHZvaWQgMCxcbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB2b2lkIDAsXG4gICAgICBpID0gdm9pZCAwLFxuICAgICAgaiA9IHZvaWQgMDtcblxuICBpZiAodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgY29tbWVudCBpbiB0cmFpbGluZ0NvbW1lbnRzIGNvbWVzIGFmdGVyIHRoZVxuICAgIC8vIGN1cnJlbnQgbm9kZSwgdGhlbiB3ZSdyZSBnb29kIC0gYWxsIGNvbW1lbnRzIGluIHRoZSBhcnJheSB3aWxsXG4gICAgLy8gY29tZSBhZnRlciB0aGUgbm9kZSBhbmQgc28gaXQncyBzYWZlIHRvIGFkZCB0aGVtIGFzIG9mZmljaWFsXG4gICAgLy8gdHJhaWxpbmdDb21tZW50cy5cbiAgICBpZiAodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzWzBdLnN0YXJ0ID49IG5vZGUuZW5kKSB7XG4gICAgICB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgdGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGZpcnN0IGNvbW1lbnQgZG9lc24ndCBjb21lIGFmdGVyIHRoZVxuICAgICAgLy8gY3VycmVudCBub2RlLCB0aGF0IG1lYW5zIHdlIGhhdmUgYSBtaXggb2YgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgIC8vIGNvbW1lbnRzIGluIHRoZSBhcnJheSBhbmQgdGhhdCBsZWFkaW5nQ29tbWVudHMgY29udGFpbnMgdGhlXG4gICAgICAvLyBzYW1lIGl0ZW1zIGFzIHRyYWlsaW5nQ29tbWVudHMuIFJlc2V0IHRyYWlsaW5nQ29tbWVudHMgdG9cbiAgICAgIC8vIHplcm8gaXRlbXMgYW5kIHdlJ2xsIGhhbmRsZSB0aGlzIGJ5IGV2YWx1YXRpbmcgbGVhZGluZ0NvbW1lbnRzXG4gICAgICAvLyBsYXRlci5cbiAgICAgIHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEluU3RhY2sgPSBsYXN0KHN0YWNrKTtcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzICYmIGxhc3RJblN0YWNrLnRyYWlsaW5nQ29tbWVudHNbMF0uc3RhcnQgPj0gbm9kZS5lbmQpIHtcbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBsYXN0SW5TdGFjay50cmFpbGluZ0NvbW1lbnRzO1xuICAgICAgbGFzdEluU3RhY2sudHJhaWxpbmdDb21tZW50cyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRWF0aW5nIHRoZSBzdGFjay5cbiAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgbGFzdChzdGFjaykuc3RhcnQgPj0gbm9kZS5zdGFydCkge1xuICAgIGZpcnN0Q2hpbGQgPSBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIGxhc3Qoc3RhY2spLnN0YXJ0ID49IG5vZGUuc3RhcnQpIHtcbiAgICBsYXN0Q2hpbGQgPSBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghbGFzdENoaWxkICYmIGZpcnN0Q2hpbGQpIGxhc3RDaGlsZCA9IGZpcnN0Q2hpbGQ7XG5cbiAgLy8gQXR0YWNoIGNvbW1lbnRzIHRoYXQgZm9sbG93IGEgdHJhaWxpbmcgY29tbWEgb24gdGhlIGxhc3RcbiAgLy8gcHJvcGVydHkgaW4gYW4gb2JqZWN0IGxpdGVyYWwgb3IgYSB0cmFpbGluZyBjb21tYSBpbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgLy8gYXMgdHJhaWxpbmcgY29tbWVudHNcbiAgaWYgKGZpcnN0Q2hpbGQgJiYgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBsYXN0Q29tbWVudCA9IGxhc3QodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMpO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAobGFzdENvbW1lbnQuc3RhcnQgPj0gbm9kZS5zdGFydCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbal0uZW5kIDwgdGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlLmVuZCkge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC50cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgbm9kZS5hcmd1bWVudHMgJiYgbm9kZS5hcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGFzdEFyZyA9IGxhc3Qobm9kZS5hcmd1bWVudHMpO1xuXG4gICAgICBpZiAobGFzdEFyZyAmJiBsYXN0Q29tbWVudC5zdGFydCA+PSBsYXN0QXJnLnN0YXJ0ICYmIGxhc3RDb21tZW50LmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxhc3RBcmcudHJhaWxpbmdDb21tZW50cyA9IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGFzdENoaWxkKSB7XG4gICAgaWYgKGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgIGlmIChsYXN0Q2hpbGQgIT09IG5vZGUgJiYgbGFzdChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzKS5lbmQgPD0gbm9kZS5zdGFydCkge1xuICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHM7XG4gICAgICAgIGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSBsZWFkaW5nIGNvbW1lbnQgZm9yIGFuIGFub255bW91cyBjbGFzcyBoYWQgYmVlbiBzdG9sZW4gYnkgaXRzIGZpcnN0IENsYXNzTWV0aG9kLFxuICAgICAgICAvLyBzbyB0aGlzIHRha2VzIGJhY2sgdGhlIGxlYWRpbmcgY29tbWVudC5cbiAgICAgICAgLy8gU2VlIGFsc286IGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNwcmVlL2lzc3Vlcy8xNThcbiAgICAgICAgZm9yIChpID0gbGFzdENoaWxkLmxlYWRpbmdDb21tZW50cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIGlmIChsYXN0Q2hpbGQubGVhZGluZ0NvbW1lbnRzW2ldLmVuZCA8PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGxhc3RDaGlsZC5sZWFkaW5nQ29tbWVudHMuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGxhc3QodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLnN0YXJ0KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50c1tqXS5lbmQgPCB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzO1xuICAgICAgICB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzcHJlZS9pc3N1ZXMvMlxuICAgICAgLy9cbiAgICAgIC8vIEluIHNwZWNpYWwgY2FzZXMsIHN1Y2ggYXMgcmV0dXJuICh3aXRob3V0IGEgdmFsdWUpIGFuZFxuICAgICAgLy8gZGVidWdnZXIsIGFsbCBjb21tZW50cyB3aWxsIGVuZCB1cCBhcyBsZWFkaW5nQ29tbWVudHMgYW5kXG4gICAgICAvLyB3aWxsIG90aGVyd2lzZSBiZSBlbGltaW5hdGVkLiBUaGlzIHN0ZXAgcnVucyB3aGVuIHRoZVxuICAgICAgLy8gY29tbWVudFN0YWNrIGlzIGVtcHR5IGFuZCB0aGVyZSBhcmUgY29tbWVudHMgbGVmdFxuICAgICAgLy8gaW4gbGVhZGluZ0NvbW1lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbG9vcCBmaWd1cmVzIG91dCB0aGUgc3RvcHBpbmcgcG9pbnQgYmV0d2VlbiB0aGUgYWN0dWFsXG4gICAgICAvLyBsZWFkaW5nIGFuZCB0cmFpbGluZyBjb21tZW50cyBieSBmaW5kaW5nIHRoZSBsb2NhdGlvbiBvZiB0aGVcbiAgICAgIC8vIGZpcnN0IGNvbW1lbnQgdGhhdCBjb21lcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbaV0uZW5kID4gbm9kZS5zdGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNwbGl0IHRoZSBhcnJheSBiYXNlZCBvbiB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IGNvbW1lbnRcbiAgICAgIC8vIHRoYXQgY29tZXMgYWZ0ZXIgdGhlIG5vZGUuIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgY291bGRcbiAgICAgIC8vIHJlc3VsdCBpbiBhbiBlbXB0eSBhcnJheSwgYW5kIGlmIHNvLCB0aGUgYXJyYXkgbXVzdCBiZVxuICAgICAgLy8gZGVsZXRlZC5cbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMuc2xpY2UoMCwgaSk7XG4gICAgICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2ltaWxhcmx5LCB0cmFpbGluZyBjb21tZW50cyBhcmUgYXR0YWNoZWQgbGF0ZXIuIFRoZSB2YXJpYWJsZVxuICAgICAgLy8gbXVzdCBiZSByZXNldCB0byBudWxsIGlmIHRoZXJlIGFyZSBubyB0cmFpbGluZyBjb21tZW50cy5cbiAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSB0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zbGljZShpKTtcbiAgICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUgPSBub2RlO1xuXG4gIGlmICh0cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgaWYgKHRyYWlsaW5nQ29tbWVudHMubGVuZ3RoICYmIHRyYWlsaW5nQ29tbWVudHNbMF0uc3RhcnQgPj0gbm9kZS5zdGFydCAmJiBsYXN0KHRyYWlsaW5nQ29tbWVudHMpLmVuZCA8PSBub2RlLmVuZCkge1xuICAgICAgbm9kZS5pbm5lckNvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gdHJhaWxpbmdDb21tZW50cztcbiAgICB9XG4gIH1cblxuICBzdGFjay5wdXNoKG5vZGUpO1xufTtcblxudmFyIHBwJDcgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5wcCQ3LmVzdHJlZVBhcnNlUmVnRXhwTGl0ZXJhbCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwYXR0ZXJuID0gX3JlZi5wYXR0ZXJuLFxuICAgICAgZmxhZ3MgPSBfcmVmLmZsYWdzO1xuXG4gIHZhciByZWdleCA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlc2UgZmxhZ3MgdmFsdWUgd2lsbFxuICAgIC8vIGJlIG51bGwgYXMgdGhlIHJlZ2V4IGNhbid0IGJlIHJlcHJlc2VudGVkIG5hdGl2ZWx5LlxuICB9XG4gIHZhciBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwocmVnZXgpO1xuICBub2RlLnJlZ2V4ID0geyBwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MgfTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnBwJDcuZXN0cmVlUGFyc2VMaXRlcmFsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJMaXRlcmFsXCIpO1xufTtcblxucHAkNy5kaXJlY3RpdmVUb1N0bXQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gIHZhciBkaXJlY3RpdmVMaXRlcmFsID0gZGlyZWN0aXZlLnZhbHVlO1xuXG4gIHZhciBzdG10ID0gdGhpcy5zdGFydE5vZGVBdChkaXJlY3RpdmUuc3RhcnQsIGRpcmVjdGl2ZS5sb2Muc3RhcnQpO1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCwgZGlyZWN0aXZlTGl0ZXJhbC5sb2Muc3RhcnQpO1xuXG4gIGV4cHJlc3Npb24udmFsdWUgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlO1xuICBleHByZXNzaW9uLnJhdyA9IGRpcmVjdGl2ZUxpdGVyYWwuZXh0cmEucmF3O1xuXG4gIHN0bXQuZXhwcmVzc2lvbiA9IHRoaXMuZmluaXNoTm9kZUF0KGV4cHJlc3Npb24sIFwiTGl0ZXJhbFwiLCBkaXJlY3RpdmVMaXRlcmFsLmVuZCwgZGlyZWN0aXZlTGl0ZXJhbC5sb2MuZW5kKTtcbiAgc3RtdC5kaXJlY3RpdmUgPSBkaXJlY3RpdmVMaXRlcmFsLmV4dHJhLnJhdy5zbGljZSgxLCAtMSk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KHN0bXQsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBkaXJlY3RpdmUuZW5kLCBkaXJlY3RpdmUubG9jLmVuZCk7XG59O1xuXG5mdW5jdGlvbiBpc1NpbXBsZVByb3BlcnR5KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgbm9kZS5raW5kID09PSBcImluaXRcIiAmJiBub2RlLm1ldGhvZCA9PT0gZmFsc2U7XG59XG5cbnZhciBlc3RyZWVQbHVnaW4gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tEZWNsYXJhdGlvblwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChpc1NpbXBsZVByb3BlcnR5KG5vZGUpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbUNvdW50XCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByb3Auc3RhcnQ7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJjaGVja0xWYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChleHByLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgc3dpdGNoIChleHByLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgICBleHByLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgX3RoaXMuY2hlY2tMVmFsKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gcHJvcC52YWx1ZSA6IHByb3AsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzLCBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMyA/IF9sZW4gLSAzIDogMCksIF9rZXkgPSAzOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkgLSAzXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiY2hlY2tQcm9wQ2xhc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcCwgcHJvcEhhc2gpIHtcbiAgICAgIGlmIChwcm9wLmNvbXB1dGVkIHx8ICFpc1NpbXBsZVByb3BlcnR5KHByb3ApKSByZXR1cm47XG5cbiAgICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICAgIC8vIEl0IGlzIGVpdGhlciBhbiBJZGVudGlmaWVyIG9yIGEgU3RyaW5nL051bWVyaWNMaXRlcmFsXG4gICAgICB2YXIgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDogU3RyaW5nKGtleS52YWx1ZSk7XG5cbiAgICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgIGlmIChwcm9wSGFzaC5wcm90bykgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTtcbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzU3RyaWN0Qm9keVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBpc0V4cHJlc3Npb24pIHtcbiAgICAgIGlmICghaXNFeHByZXNzaW9uICYmIG5vZGUuYm9keS5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbm9kZS5ib2R5LmJvZHksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjIgPSBfaS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gX3JlZjI7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aXZlLnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIGRpcmVjdGl2ZS5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmV4cHJlc3Npb24udmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQnJlYWsgZm9yIHRoZSBmaXJzdCBub24gbGl0ZXJhbCBleHByZXNzaW9uXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzVmFsaWREaXJlY3RpdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKCFzdG10LmV4cHJlc3Npb24uZXh0cmEgfHwgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJzdG10VG9EaXJlY3RpdmVcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICB2YXIgZGlyZWN0aXZlID0gaW5uZXIuY2FsbCh0aGlzLCBzdG10KTtcbiAgICAgIHZhciB2YWx1ZSA9IHN0bXQuZXhwcmVzc2lvbi52YWx1ZTtcblxuICAgICAgLy8gUmVzZXQgdmFsdWUgdG8gdGhlIGFjdHVhbCB2YWx1ZSBhcyBpbiBlc3RyZWUgbW9kZSB3ZSB3YW50XG4gICAgICAvLyB0aGUgc3RtdCB0byBoYXZlIHRoZSByZWFsIHZhbHVlIGFuZCBub3QgdGhlIHJhdyB2YWx1ZVxuICAgICAgZGlyZWN0aXZlLnZhbHVlLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiBkaXJlY3RpdmU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VCbG9ja0JvZHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgbm9kZV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgbm9kZS5kaXJlY3RpdmVzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgbm9kZS5ib2R5LnVuc2hpZnQoX3RoaXMyLmRpcmVjdGl2ZVRvU3RtdChkaXJlY3RpdmUpKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIG5vZGUuZGlyZWN0aXZlcztcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzTWV0aG9kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgICAgdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgICAgIGlmIChtZXRob2QudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbWV0aG9kLnZhbHVlLnR5cGVQYXJhbWV0ZXJzID0gbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICBkZWxldGUgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRXhwckF0b21cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlUmVnRXhwTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgICBjYXNlIHR5cGVzLm51bTpcbiAgICAgICAgY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX251bGw6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKG51bGwpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX3RydWU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRydWUpO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuX2ZhbHNlOlxuICAgICAgICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChmYWxzZSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUxpdGVyYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgICBkZWxldGUgbm9kZS5leHRyYTtcblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VNZXRob2RcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgZnVuY05vZGUua2luZCA9IG5vZGUua2luZDsgLy8gcHJvdmlkZSBraW5kLCBzbyBpbm5lciBtZXRob2QgY29ycmVjdGx5IHNldHMgc3RhdGVcblxuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICBmdW5jTm9kZSA9IGlubmVyLmNhbGwuYXBwbHkoaW5uZXIsIFt0aGlzLCBmdW5jTm9kZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIGRlbGV0ZSBmdW5jTm9kZS5raW5kO1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmluaXNoTm9kZShmdW5jTm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlT2JqZWN0TWV0aG9kXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gaW5uZXIuY2FsbC5hcHBseShpbm5lciwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIG5vZGUua2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBub2RlLnR5cGUgPSBcIlByb3BlcnR5XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlT2JqZWN0UHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwidG9Bc3NpZ25hYmxlXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuOCA+IDIgPyBfbGVuOCAtIDIgOiAwKSwgX2tleTggPSAyOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTggLSAyXSA9IGFyZ3VtZW50c1tfa2V5OF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1NpbXBsZVByb3BlcnR5KG5vZGUpKSB7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlLmFwcGx5KHRoaXMsIFtub2RlLnZhbHVlLCBpc0JpbmRpbmddLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLnByb3BlcnRpZXMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgICAgICAgIHZhciBfcmVmMztcblxuICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoX2kyLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByb3AgPSBfcmVmMztcblxuICAgICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlclwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKHByb3Aua2V5LnN0YXJ0LCBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gbWV0aG9kc1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nLCBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgbm9kZSwgaXNCaW5kaW5nXS5jb25jYXQoYXJncykpO1xuICAgIH07XG4gIH0pO1xufTtcblxuLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxudmFyIHByaW1pdGl2ZVR5cGVzID0gW1wiYW55XCIsIFwibWl4ZWRcIiwgXCJlbXB0eVwiLCBcImJvb2xcIiwgXCJib29sZWFuXCIsIFwibnVtYmVyXCIsIFwic3RyaW5nXCIsIFwidm9pZFwiLCBcIm51bGxcIl07XG5cbnZhciBwcCQ4ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkOC5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIgPSBmdW5jdGlvbiAodG9rKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICB0aGlzLmV4cGVjdCh0b2sgfHwgdHlwZXMuY29sb24pO1xuXG4gIHZhciB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICByZXR1cm4gdHlwZTtcbn07XG5cbnBwJDguZmxvd1BhcnNlUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB2YXIgbW9kdWxvUG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdGhpcy5leHBlY3QodHlwZXMubW9kdWxvKTtcbiAgdmFyIGNoZWNrc0xvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImNoZWNrc1wiKTtcbiAgLy8gRm9yY2UgJyUnIGFuZCAnY2hlY2tzJyB0byBiZSBhZGphY2VudFxuICBpZiAobW9kdWxvTG9jLmxpbmUgIT09IGNoZWNrc0xvYy5saW5lIHx8IG1vZHVsb0xvYy5jb2x1bW4gIT09IGNoZWNrc0xvYy5jb2x1bW4gLSAxKSB7XG4gICAgdGhpcy5yYWlzZShtb2R1bG9Qb3MsIFwiU3BhY2VzIGJldHdlZW4gwrQlwrQgYW5kIMK0Y2hlY2tzwrQgYXJlIG5vdCBhbGxvd2VkIGhlcmUuXCIpO1xuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW5mZXJyZWRQcmVkaWNhdGVcIik7XG4gIH1cbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICB2YXIgdHlwZSA9IG51bGw7XG4gIHZhciBwcmVkaWNhdGUgPSBudWxsO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5tb2R1bG8pKSB7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcHJlZGljYXRlID0gdGhpcy5mbG93UGFyc2VQcmVkaWNhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMubW9kdWxvKSkge1xuICAgICAgcHJlZGljYXRlID0gdGhpcy5mbG93UGFyc2VQcmVkaWNhdGUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0eXBlLCBwcmVkaWNhdGVdO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlQ2xhc3MgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlQ2xhc3NcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuXG4gIHZhciBpZCA9IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gIHZhciB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciB0eXBlQ29udGFpbmVyID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgdHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHZhciB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICB0eXBlTm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHZhciBwcmVkaWNhdGUgPSBudWxsO1xuXG4gIHZhciBfZmxvd1BhcnNlVHlwZUFuZFByZWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpO1xuXG4gIHR5cGVOb2RlLnJldHVyblR5cGUgPSBfZmxvd1BhcnNlVHlwZUFuZFByZWRbMF07XG4gIHByZWRpY2F0ZSA9IF9mbG93UGFyc2VUeXBlQW5kUHJlZFsxXTtcblxuICB0eXBlQ29udGFpbmVyLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIHR5cGVDb250YWluZXIucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICBpZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlQ29udGFpbmVyLCBcIlR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gIHRoaXMuZmluaXNoTm9kZShpZCwgaWQudHlwZSk7XG5cbiAgdGhpcy5zZW1pY29sb24oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUZ1bmN0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVDbGFzcyhub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLl9mdW5jdGlvbikpIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlRnVuY3Rpb24obm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fdmFyKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcIm1vZHVsZVwiKSkge1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmRvdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGUobm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikpIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5fZXhwb3J0KSkge1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5fZXhwb3J0KTtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwib3BhcXVlXCIpIC8vIGRlY2xhcmUgZXhwb3J0IG9wYXF1ZSAuLi5cbiAgKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5mbG93UGFyc2VEZWNsYXJlKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuXG4gIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZVZhcmlhYmxlXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlTW9kdWxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgfVxuXG4gIHZhciBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBib2R5ID0gYm9keU5vZGUuYm9keSA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB3aGlsZSAoIXRoaXMubWF0Y2godHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBfYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2ltcG9ydCkpIHtcbiAgICAgIHZhciBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgaWYgKGxvb2thaGVhZC52YWx1ZSAhPT0gXCJ0eXBlXCIgJiYgbG9va2FoZWFkLnZhbHVlICE9PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCBcIkltcG9ydHMgd2l0aGluIGEgYGRlY2xhcmUgbW9kdWxlYCBib2R5IG11c3QgYWx3YXlzIGJlIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcnNlSW1wb3J0KF9ib2R5Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImRlY2xhcmVcIiwgXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlXCIpO1xuXG4gICAgICBfYm9keU5vZGUgPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUoX2JvZHlOb2RlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBib2R5LnB1c2goX2JvZHlOb2RlKTtcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuXG4gIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwibW9kdWxlXCIpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5kb3QpO1xuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJleHBvcnRzXCIpO1xuICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVUeXBlQWxpYXNcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VEZWNsYXJlSW50ZXJmYWNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbn07XG5cbi8vIEludGVyZmFjZXNcblxucHAkOC5mbG93UGFyc2VJbnRlcmZhY2Vpc2ggPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gIH1cblxuICBub2RlLmV4dGVuZHMgPSBbXTtcbiAgbm9kZS5taXhpbnMgPSBbXTtcblxuICBpZiAodGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpKSB7XG4gICAgZG8ge1xuICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSk7XG4gIH1cblxuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJtaXhpbnNcIikpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBkbyB7XG4gICAgICBub2RlLm1peGlucy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdCh0eXBlcy5jb21tYSkpO1xuICB9XG5cbiAgbm9kZS5ib2R5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHRydWUsIGZhbHNlLCBmYWxzZSk7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcigpO1xuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VFeHRlbmRzXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIgPSBmdW5jdGlvbiAobGliZXJhbCkge1xuICBpZiAocHJpbWl0aXZlVHlwZXMuaW5kZXhPZih0aGlzLnN0YXRlLnZhbHVlKSA+IC0xKSB7XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIkNhbm5vdCBvdmVyd3JpdGUgcHJpbWl0aXZlIHR5cGUgXCIgKyB0aGlzLnN0YXRlLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcihsaWJlcmFsKTtcbn07XG5cbi8vIFR5cGUgYWxpYXNlc1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVBbGlhcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG5cbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICB9XG5cbiAgbm9kZS5yaWdodCA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKHR5cGVzLmVxKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFsaWFzXCIpO1xufTtcblxuLy8gT3BhcXVlIHR5cGUgYWxpYXNlc1xuXG5wcCQ4LmZsb3dQYXJzZU9wYXF1ZVR5cGUgPSBmdW5jdGlvbiAobm9kZSwgZGVjbGFyZSkge1xuICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJ0eXBlXCIpO1xuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcigpO1xuXG4gIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBzdXBlcnR5cGVcbiAgbm9kZS5zdXBlcnR5cGUgPSBudWxsO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICBub2RlLnN1cGVydHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKHR5cGVzLmNvbG9uKTtcbiAgfVxuXG4gIG5vZGUuaW1wbHR5cGUgPSBudWxsO1xuICBpZiAoIWRlY2xhcmUpIHtcbiAgICBub2RlLmltcGx0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodHlwZXMuZXEpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wYXF1ZVR5cGVcIik7XG59O1xuXG4vLyBUeXBlIGFubm90YXRpb25zXG5cbnBwJDguZmxvd1BhcnNlVHlwZVBhcmFtZXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gIHZhciB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcblxuICB2YXIgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgbm9kZS5uYW1lID0gaWRlbnQubmFtZTtcbiAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG5cbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuZXEpKSB7XG4gICAgdGhpcy5lYXQodHlwZXMuZXEpO1xuICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUucGFyYW1zID0gW107XG5cbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiB0aGlzIGNvbmRpdGlvbiBpcyBhbHJlYWR5IGNoZWNrZWQgYXQgYWxsIGNhbGwgc2l0ZXNcbiAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSB8fCB0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgIHRoaXMubmV4dCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZG8ge1xuICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyKCkpO1xuICAgIGlmICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgfVxuICB9IHdoaWxlICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKTtcbiAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gIG5vZGUucGFyYW1zID0gW107XG5cbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIHRoaXMuZXhwZWN0UmVsYXRpb25hbChcIjxcIik7XG4gIHdoaWxlICghdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpKSB7XG4gICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgaWYgKCF0aGlzLmlzUmVsYXRpb25hbChcIj5cIikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5udW0pIHx8IHRoaXMubWF0Y2godHlwZXMuc3RyaW5nKSA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRMKTtcbiAgaWYgKHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHlwZXMuY29sb24pIHtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcblxuICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW5kZXhlclwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIG5vZGUucGFyYW1zID0gW107XG4gIG5vZGUucmVzdCA9IG51bGw7XG4gIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuXG4gIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIHdoaWxlICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlblIpICYmICF0aGlzLm1hdGNoKHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKTtcbiAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBub2RlLnJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGlzU3RhdGljLCBrZXkpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpKTtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgdGhpcy5mbG93T2JqZWN0VHlwZVNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGljKSB7XG4gIHZhciB2YWx1ZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gIHRoaXMuZmxvd09iamVjdFR5cGVTZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZU9iamVjdFR5cGUgPSBmdW5jdGlvbiAoYWxsb3dTdGF0aWMsIGFsbG93RXhhY3QsIGFsbG93U3ByZWFkKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuXG4gIHZhciBub2RlU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdm9pZCAwO1xuICB2YXIgaXNTdGF0aWMgPSBmYWxzZTtcblxuICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMgPSBbXTtcbiAgbm9kZVN0YXJ0LnByb3BlcnRpZXMgPSBbXTtcbiAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG5cbiAgdmFyIGVuZERlbGltID0gdm9pZCAwO1xuICB2YXIgZXhhY3QgPSB2b2lkIDA7XG4gIGlmIChhbGxvd0V4YWN0ICYmIHRoaXMubWF0Y2godHlwZXMuYnJhY2VCYXJMKSkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlQmFyTCk7XG4gICAgZW5kRGVsaW0gPSB0eXBlcy5icmFjZUJhclI7XG4gICAgZXhhY3QgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gICAgZW5kRGVsaW0gPSB0eXBlcy5icmFjZVI7XG4gICAgZXhhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIG5vZGVTdGFydC5leGFjdCA9IGV4YWN0O1xuXG4gIHdoaWxlICghdGhpcy5tYXRjaChlbmREZWxpbSkpIHtcbiAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKGFsbG93U3RhdGljICYmIHRoaXMuaXNDb250ZXh0dWFsKFwic3RhdGljXCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSAhPT0gdHlwZXMuY29sb24pIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZVBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdmFyIHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2tldEwpKSB7XG4gICAgICBub2RlU3RhcnQuaW5kZXhlcnMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZVBvcyk7XG4gICAgICB9XG4gICAgICBub2RlU3RhcnQuY2FsbFByb3BlcnRpZXMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgaXNTdGF0aWMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgXCJTcHJlYWQgb3BlcmF0b3IgY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLnN0YXJ0LCBcIlNwcmVhZCBwcm9wZXJ0aWVzIGNhbm5vdCBoYXZlIHZhcmlhbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmVsbGlwc2lzKTtcbiAgICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gICAgICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnR5S2V5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5MKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2QgcHJvcGVydHlcbiAgICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kKHN0YXJ0UG9zLCBzdGFydExvYywgaXNTdGF0aWMsIHByb3BlcnR5S2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmtleSA9IHByb3BlcnR5S2V5O1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgICAgICB0aGlzLmZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCk7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlUHJvcGVydHlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNTdGF0aWMgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuZXhwZWN0KGVuZERlbGltKTtcblxuICB2YXIgb3V0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGVTdGFydCwgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKTtcblxuICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICByZXR1cm4gb3V0O1xufTtcblxucHAkOC5mbG93T2JqZWN0VHlwZVNlbWljb2xvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5lYXQodHlwZXMuY29tbWEpICYmICF0aGlzLm1hdGNoKHR5cGVzLmJyYWNlUikgJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2VCYXJSKSkge1xuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBzdGFydExvYywgaWQpIHtcbiAgc3RhcnRQb3MgPSBzdGFydFBvcyB8fCB0aGlzLnN0YXRlLnN0YXJ0O1xuICBzdGFydExvYyA9IHN0YXJ0TG9jIHx8IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBub2RlID0gaWQgfHwgdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICB3aGlsZSAodGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIHZhciBub2RlMiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlMi5xdWFsaWZpY2F0aW9uID0gbm9kZTtcbiAgICBub2RlMi5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxucHAkOC5mbG93UGFyc2VHZW5lcmljVHlwZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MsIGlkKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcblxuICBpZiAodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVvZlR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3R5cGVvZik7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHVwbGVUeXBlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIG5vZGUudHlwZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldEwpO1xuICAvLyBXZSBhbGxvdyB0cmFpbGluZyBjb21tYXNcbiAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgIXRoaXMubWF0Y2godHlwZXMuYnJhY2tldFIpKSB7XG4gICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFja2V0UikpIGJyZWFrO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgfVxuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xufTtcblxucHAkOC5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSBudWxsO1xuICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgdmFyIHR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICBpZiAobGgudHlwZSA9PT0gdHlwZXMuY29sb24gfHwgbGgudHlwZSA9PT0gdHlwZXMucXVlc3Rpb24pIHtcbiAgICBuYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICB9XG4gIG5vZGUubmFtZSA9IG5hbWU7XG4gIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG59O1xuXG5wcCQ4LnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0gPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQodHlwZS5zdGFydCwgdHlwZS5sb2Muc3RhcnQpO1xuICBub2RlLm5hbWUgPSBudWxsO1xuICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgdmFyIHJldCA9IHsgcGFyYW1zOiBwYXJhbXMsIHJlc3Q6IG51bGwgfTtcbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikgJiYgIXRoaXMubWF0Y2godHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgcmV0LnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKSk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKHR5cGVzLnBhcmVuUikpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLmVsbGlwc2lzKSkge1xuICAgIHJldC5yZXN0ID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5wcCQ4LmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlLCBpZCkge1xuICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQW55VHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIFwidm9pZFwiOlxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJib29sXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSBcImVtcHR5XCI6XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcbiAgfVxufTtcblxuLy8gVGhlIHBhcnNpbmcgb2YgdHlwZXMgcm91Z2hseSBwYXJhbGxlbHMgdGhlIHBhcnNpbmcgb2YgZXhwcmVzc2lvbnMsIGFuZFxuLy8gcHJpbWFyeSB0eXBlcyBhcmUga2luZCBvZiBsaWtlIHByaW1hcnkgZXhwcmVzc2lvbnMuLi50aGV5J3JlIHRoZVxuLy8gcHJpbWl0aXZlcyB3aXRoIHdoaWNoIG90aGVyIHR5cGVzIGFyZSBjb25zdHJ1Y3RlZC5cbnBwJDguZmxvd1BhcnNlUHJpbWFyeVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gIHZhciBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIHRtcCA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gIHZhciBpc0dyb3VwZWRUeXBlID0gZmFsc2U7XG4gIHZhciBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgIGNhc2UgdHlwZXMubmFtZTpcbiAgICAgIHJldHVybiB0aGlzLmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlLCB0aGlzLnBhcnNlSWRlbnRpZmllcigpKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZShmYWxzZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgY2FzZSB0eXBlcy5icmFjZUJhckw6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKGZhbHNlLCB0cnVlLCB0cnVlKTtcblxuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcblxuICAgIGNhc2UgdHlwZXMucmVsYXRpb25hbDpcbiAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIjxcIikge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgICAgICAgdG1wID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG5cbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgdHlwZXMucGFyZW5MOlxuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFjdHVhbGx5IGEgZ3JvdXBlZCB0eXBlXG4gICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpLnR5cGU7XG4gICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSB0eXBlcy5xdWVzdGlvbiAmJiB0b2tlbiAhPT0gdHlwZXMuY29sb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICAgICAgICAvLyBBIGAsYCBvciBhIGApID0+YCBtZWFucyB0aGlzIGlzIGFuIGFub255bW91cyBmdW5jdGlvbiB0eXBlXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2godHlwZXMuY29tbWEpIHx8IHRoaXMubWF0Y2godHlwZXMucGFyZW5SKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR5cGVzLmFycm93KSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRWF0IGEgY29tbWEgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgdGhpcy5lYXQodHlwZXMuY29tbWEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuXG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuXG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5hcnJvdyk7XG5cbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuXG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgIGNhc2UgdHlwZXMuX3RydWU6Y2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCh0eXBlcy5fdHJ1ZSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5wbHVzTWluOlxuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2godHlwZXMubnVtKSkgdGhpcy51bmV4cGVjdGVkKG51bGwsIFwiVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgbnVtYmVyXCIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUuc3RhcnQsIG5vZGUubG9jLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgY2FzZSB0eXBlcy5udW06XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5fbnVsbDpcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLm1hdGNoKHR5cGVzLl9udWxsKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG5cbiAgICBjYXNlIHR5cGVzLl90aGlzOlxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMubWF0Y2godHlwZXMuX3RoaXMpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgY2FzZSB0eXBlcy5zdGFyOlxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhpc3RlbnRpYWxUeXBlUGFyYW1cIik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkID09PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVvZlR5cGUoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHRoaXMudW5leHBlY3RlZCgpO1xufTtcblxucHAkOC5mbG93UGFyc2VQb3N0Zml4VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydCxcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gIHdoaWxlICghdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLm1hdGNoKHR5cGVzLmJyYWNrZXRMKSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRMKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFja2V0Uik7XG4gICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5VHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVByZWZpeFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VQb3N0Zml4VHlwZSgpO1xuICB9XG59O1xuXG5wcCQ4LmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbSA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICBpZiAoIXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChwYXJhbS5zdGFydCwgcGFyYW0ubG9jLnN0YXJ0KTtcbiAgICBub2RlLnBhcmFtcyA9IFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0ocGFyYW0pXTtcbiAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIHJldHVybiBwYXJhbTtcbn07XG5cbnBwJDguZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmVhdCh0eXBlcy5iaXR3aXNlQU5EKTtcbiAgdmFyIHR5cGUgPSB0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKTtcbiAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmJpdHdpc2VBTkQpKSB7XG4gICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpKTtcbiAgfVxuICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVVuaW9uVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLmVhdCh0eXBlcy5iaXR3aXNlT1IpO1xuICB2YXIgdHlwZSA9IHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICBub2RlLnR5cGVzID0gW3R5cGVdO1xuICB3aGlsZSAodGhpcy5lYXQodHlwZXMuYml0d2lzZU9SKSkge1xuICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuaW9uVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICB2YXIgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVW5pb25UeXBlKCk7XG4gIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICByZXR1cm4gdHlwZTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUFubm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICB2YXIgX2Zsb3dQYXJzZVR5cGVBbmRQcmVkMiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG5cbiAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IF9mbG93UGFyc2VUeXBlQW5kUHJlZDJbMF07XG4gIG5vZGUucHJlZGljYXRlID0gX2Zsb3dQYXJzZVR5cGVBbmRQcmVkMlsxXTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFubm90YXRpb25cIik7XG59O1xuXG5wcCQ4LmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpZGVudCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoKTtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgaWRlbnQudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGlkZW50LCBpZGVudC50eXBlKTtcbiAgfVxuICByZXR1cm4gaWRlbnQ7XG59O1xuXG5wcCQ4LnR5cGVDYXN0VG9QYXJhbWV0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLmV4cHJlc3Npb24sIG5vZGUuZXhwcmVzc2lvbi50eXBlLCBub2RlLnR5cGVBbm5vdGF0aW9uLmVuZCwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbn07XG5cbnBwJDguZmxvd1BhcnNlVmFyaWFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YXJpYW5jZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hdGNoKHR5cGVzLnBsdXNNaW4pKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICB2YXJpYW5jZSA9IFwicGx1c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgIHZhcmlhbmNlID0gXCJtaW51c1wiO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuICByZXR1cm4gdmFyaWFuY2U7XG59O1xuXG52YXIgZmxvd1BsdWdpbiA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAvLyBwbGFpbiBmdW5jdGlvbiByZXR1cm4gdHlwZXM6IGZ1bmN0aW9uIG5hbWUoKTogc3RyaW5nIHt9XG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRnVuY3Rpb25Cb2R5XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgYWxsb3dFeHByZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgJiYgIWFsbG93RXhwcmVzc2lvbikge1xuICAgICAgICAvLyBpZiBhbGxvd0V4cHJlc3Npb24gaXMgdHJ1ZSB0aGVuIHdlJ3JlIHBhcnNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gYW5kIGlmXG4gICAgICAgIC8vIHRoZXJlJ3MgYSByZXR1cm4gdHlwZSB0aGVuIGl0J3MgYmVlbiBoYW5kbGVkIGVsc2V3aGVyZVxuICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVBbm5vdGF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGFsbG93RXhwcmVzc2lvbik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gaW50ZXJmYWNlc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZVN0YXRlbWVudFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlY2xhcmF0aW9uLCB0b3BMZXZlbCkge1xuICAgICAgLy8gc3RyaWN0IG1vZGUgaGFuZGxpbmcgb2YgYGludGVyZmFjZWAgc2luY2UgaXQncyBhIHJlc2VydmVkIHdvcmRcbiAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgZGVjbGFyYXRpb24sIHRvcExldmVsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBkZWNsYXJlcywgaW50ZXJmYWNlcyBhbmQgdHlwZSBhbGlhc2VzXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlRXhwcmVzc2lvblN0YXRlbWVudFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGV4cHIpIHtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuX2NsYXNzKSB8fCB0aGlzLm1hdGNoKHR5cGVzLm5hbWUpIHx8IHRoaXMubWF0Y2godHlwZXMuX2Z1bmN0aW9uKSB8fCB0aGlzLm1hdGNoKHR5cGVzLl92YXIpIHx8IHRoaXMubWF0Y2godHlwZXMuX2V4cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmUobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2godHlwZXMubmFtZSkpIHtcbiAgICAgICAgICBpZiAoZXhwci5uYW1lID09PSBcImludGVyZmFjZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBleHByKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBleHBvcnQgdHlwZVxuICBpbnN0YW5jZS5leHRlbmQoXCJzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib3BhcXVlXCIpIHx8IGlubmVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwiaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSAmJiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJ0eXBlXCIgfHwgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJpbnRlcmZhY2VcIiB8fCB0aGlzLnN0YXRlLnZhbHVlID09PSBcIm9wYXF1ZVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQ29uZGl0aW9uYWxcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChleHByLCBub0luLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZk5lZWRzQXJyb3dQb3MpIHtcbiAgICAgIC8vIG9ubHkgZG8gdGhlIGV4cGVuc2l2ZSBjbG9uZSBpZiB0aGVyZSBpcyBhIHF1ZXN0aW9uIG1hcmtcbiAgICAgIC8vIGFuZCBpZiB3ZSBjb21lIGZyb20gaW5zaWRlIHBhcmVuc1xuICAgICAgaWYgKHJlZk5lZWRzQXJyb3dQb3MgJiYgdGhpcy5tYXRjaCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGV4cHIsIG5vSW4sIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgcmVmTmVlZHNBcnJvd1Bvcy5zdGFydCA9IGVyci5wb3MgfHwgdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm8gc3VjaCBlcnJvciBpcyBleHBlY3RlZFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBleHByLCBub0luLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlUGFyZW5JdGVtXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgICBub2RlID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciB0eXBlQ2FzdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIHR5cGVDYXN0Tm9kZS5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHBvcnRcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIG5vZGUuZXhwb3J0S2luZCA9IG5vZGUuZXhwb3J0S2luZCB8fCBcInZhbHVlXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUV4cG9ydERlY2xhcmF0aW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKSkge1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcblxuICAgICAgICB2YXIgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICAgIC8vIGV4cG9ydCB0eXBlIHsgZm9vLCBiYXIgfTtcbiAgICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycygpO1xuICAgICAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGV4cG9ydCB0eXBlIEZvbyA9IEJhcjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSkge1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcblxuICAgICAgICB2YXIgX2RlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAvLyBleHBvcnQgb3BhcXVlIHR5cGUgRm9vID0gQmFyO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKF9kZWNsYXJhdGlvbk5vZGUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJpbnRlcmZhY2VcIikpIHtcbiAgICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICAgIHZhciBfZGVjbGFyYXRpb25Ob2RlMiA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoX2RlY2xhcmF0aW9uTm9kZTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VDbGFzc0lkXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaW5uZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZG9uJ3QgY29uc2lkZXIgYHZvaWRgIHRvIGJlIGEga2V5d29yZCBhcyB0aGVuIGl0J2xsIHVzZSB0aGUgdm9pZCB0b2tlbiB0eXBlXG4gIC8vIGFuZCBzZXQgc3RhcnRFeHByXG4gIGluc3RhbmNlLmV4dGVuZChcImlzS2V5d29yZFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBuYW1lID09PSBcInZvaWRcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyBlbnN1cmUgdGhhdCBpbnNpZGUgZmxvdyB0eXBlcywgd2UgYnlwYXNzIHRoZSBqc3ggcGFyc2VyIHBsdWdpblxuICBpbnN0YW5jZS5leHRlbmQoXCJyZWFkVG9rZW5cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUgJiYgKGNvZGUgPT09IDYyIHx8IGNvZGUgPT09IDYwKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5yZWxhdGlvbmFsLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGNvZGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIGRvbid0IGxleCBhbnkgdG9rZW4gYXMgYSBqc3ggb25lIGluc2lkZSBhIGZsb3cgdHlwZVxuICBpbnN0YW5jZS5leHRlbmQoXCJqc3hfcmVhZFRva2VuXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlKSByZXR1cm4gaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJ0b0Fzc2lnbmFibGVcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBpc0JpbmRpbmcsIGNvbnRleHREZXNjcmlwdGlvbikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSksIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICAvLyB0dXJuIHR5cGUgY2FzdHMgdGhhdCB3ZSBmb3VuZCBpbiBmdW5jdGlvbiBwYXJhbWV0ZXIgaGVhZCBpbnRvIHR5cGUgYW5ub3RhdGVkIHBhcmFtc1xuICBpbnN0YW5jZS5leHRlbmQoXCJ0b0Fzc2lnbmFibGVMaXN0XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXhwckxpc3QsIGlzQmluZGluZywgY29udGV4dERlc2NyaXB0aW9uKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHByID0gZXhwckxpc3RbaV07XG4gICAgICAgIGlmIChleHByICYmIGV4cHIudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIGV4cHJMaXN0W2ldID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKGV4cHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBleHByTGlzdCwgaXNCaW5kaW5nLCBjb250ZXh0RGVzY3JpcHRpb24pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgYSBsaXN0IG9mIG5vZGVzLCBmcm9tIHNvbWV0aGluZyBsaWtlIGEgY2FsbCBleHByZXNzaW9uLCB3ZSBuZWVkIHRvIGZpbHRlciB0aGVcbiAgLy8gdHlwZSBjYXN0cyB0aGF0IHdlJ3ZlIGZvdW5kIHRoYXQgYXJlIGlsbGVnYWwgaW4gdGhpcyBjb250ZXh0XG4gIGluc3RhbmNlLmV4dGVuZChcInRvUmVmZXJlbmNlZExpc3RcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXhwckxpc3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgICAgaWYgKGV4cHIgJiYgZXhwci5fZXhwckxpc3RJdGVtICYmIGV4cHIudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgXCJVbmV4cGVjdGVkIHR5cGUgY2FzdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwckxpc3Q7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgYW4gaXRlbSBpbnNpZGUgYSBleHByZXNzaW9uIGxpc3QgZWcuIGAoTk9ERSwgTk9ERSlgIHdoZXJlIE5PREUgcmVwcmVzZW50c1xuICAvLyB0aGUgcG9zaXRpb24gd2hlcmUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHByTGlzdEl0ZW1cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IGlubmVyLmNhbGwuYXBwbHkoaW5uZXIsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIGNvbnRhaW5lci5fZXhwckxpc3RJdGVtID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgICBjb250YWluZXIudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoY29udGFpbmVyLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImNoZWNrTFZhbFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgY2xhc3MgcHJvcGVydHkgdHlwZSBhbm5vdGF0aW9uc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzUHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBkZWxldGUgbm9kZS52YXJpYW5jZVBvcztcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSkge1xuICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlubmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlJ3JlIGN1cnJlbnRseSBpbiB0aGUgcG9zaXRpb24gd2hlcmUgYSBjbGFzcyBtZXRob2Qgd291bGQgYXBwZWFyXG4gIGluc3RhbmNlLmV4dGVuZChcImlzQ2xhc3NNZXRob2RcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIikgfHwgaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3Qgd2UncmUgY3VycmVudGx5IGluIHRoZSBwb3NpdGlvbiB3aGVyZSBhIGNsYXNzIHByb3BlcnR5IHdvdWxkIGFwcGVhclxuICBpbnN0YW5jZS5leHRlbmQoXCJpc0NsYXNzUHJvcGVydHlcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoKHR5cGVzLmNvbG9uKSB8fCBpbm5lci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcImlzTm9uc3RhdGljQ29uc3RydWN0b3JcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHJldHVybiAhdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgJiYgaW5uZXIuY2FsbCh0aGlzLCBtZXRob2QpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHBhcnNlIHR5cGUgcGFyYW1ldGVycyBmb3IgY2xhc3MgbWV0aG9kc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUNsYXNzTWV0aG9kXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2xhc3NCb2R5LCBtZXRob2QpIHtcbiAgICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZVBvcyk7XG4gICAgICB9XG4gICAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuICAgICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZVBvcztcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBpbm5lci5jYWxsLmFwcGx5KGlubmVyLCBbdGhpcywgY2xhc3NCb2R5LCBtZXRob2RdLmNvbmNhdChhcmdzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgYSB0aGUgc3VwZXIgY2xhc3MgdHlwZSBwYXJhbWV0ZXJzIGFuZCBpbXBsZW1lbnRzXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQ2xhc3NTdXBlclwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgICBpbm5lci5jYWxsKHRoaXMsIG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSB7XG4gICAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImltcGxlbWVudHNcIikpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhciBpbXBsZW1lbnRlZCA9IG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBfbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICAgICAgX25vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW1wbGVtZW50ZWQucHVzaCh0aGlzLmZpbmlzaE5vZGUoX25vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZVByb3BlcnR5TmFtZVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciB2YXJpYW5jZVBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICB2YXIgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgICB2YXIga2V5ID0gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICAgIG5vZGUudmFyaWFuY2VQb3MgPSB2YXJpYW5jZVBvcztcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdHlwZSBwYXJhbWV0ZXJzIGZvciBvYmplY3QgbWV0aG9kIHNob3J0aGFuZFxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZU9ialByb3BWYWx1ZVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGlmIChwcm9wLnZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlUG9zKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwcm9wLnZhcmlhbmNlO1xuICAgICAgZGVsZXRlIHByb3AudmFyaWFuY2VQb3M7XG5cbiAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHZvaWQgMDtcblxuICAgICAgLy8gbWV0aG9kIHNob3J0aGFuZFxuICAgICAgaWYgKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5wYXJlbkwpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgLy8gYWRkIHR5cGVQYXJhbWV0ZXJzIGlmIHdlIGZvdW5kIHRoZW1cbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykge1xuICAgICAgICAocHJvcC52YWx1ZSB8fCBwcm9wKS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hOb2RlKHBhcmFtLCBwYXJhbS50eXBlKTtcbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZU1heWJlRGVmYXVsdFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgICB0aGlzLnJhaXNlKG5vZGUudHlwZUFubm90YXRpb24uc3RhcnQsIFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdHlwZW9mIGFuZCB0eXBlIGltcG9ydHNcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VJbXBvcnRTcGVjaWZpZXJzXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuXG4gICAgICB2YXIga2luZCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5fdHlwZW9mKSkge1xuICAgICAgICBraW5kID0gXCJ0eXBlb2ZcIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpKSB7XG4gICAgICAgIGtpbmQgPSBcInR5cGVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kKSB7XG4gICAgICAgIHZhciBsaCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsaC50eXBlID09PSB0eXBlcy5uYW1lICYmIGxoLnZhbHVlICE9PSBcImZyb21cIiB8fCBsaC50eXBlID09PSB0eXBlcy5icmFjZUwgfHwgbGgudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuaW1wb3J0S2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBwYXJzZSBpbXBvcnQtdHlwZS90eXBlb2Ygc2hvcnRoYW5kXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlSW1wb3J0U3BlY2lmaWVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdmFyIGZpcnN0SWRlbnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgdmFyIGZpcnN0SWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgdmFyIHNwZWNpZmllclR5cGVLaW5kID0gbnVsbDtcbiAgICAgIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlb2ZcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZW9mXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIHZhciBhc19pZGVudCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgIXRoaXMubWF0Y2godHlwZXMubmFtZSkgJiYgIXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkKSB7XG4gICAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBhcyAsYCBvciBgaW1wb3J0IHt0eXBlIGFzIH1gXG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gYXNfaWRlbnQ7XG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBhc19pZGVudC5fX2Nsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBhcyBmb29gXG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiAodGhpcy5tYXRjaCh0eXBlcy5uYW1lKSB8fCB0aGlzLnN0YXRlLnR5cGUua2V5d29yZCkpIHtcbiAgICAgICAgLy8gYGltcG9ydCB7dHlwZSBmb29gXG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IHNwZWNpZmllclR5cGVLaW5kO1xuICAgICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQmluZGluZyA9IHRydWU7XG4gICAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gc3BlY2lmaWVyLmltcG9ydGVkLl9fY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBzcGVjaWZpZXIuaW1wb3J0ZWQuX19jbG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSAmJiAoc3BlY2lmaWVyLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IHNwZWNpZmllci5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGZpcnN0SWRlbnRMb2MsIFwiYFRoZSBgdHlwZWAgYW5kIGB0eXBlb2ZgIGtleXdvcmRzIG9uIG5hbWVkIGltcG9ydHMgY2FuIG9ubHkgYmUgdXNlZCBvbiByZWd1bGFyIGBpbXBvcnRgIHN0YXRlbWVudHMuIEl0IGNhbm5vdCBiZSB1c2VkIHdpdGggYGltcG9ydCB0eXBlYCBvciBgaW1wb3J0IHR5cGVvZmAgc3RhdGVtZW50c2BcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0JpbmRpbmcpIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuY2hlY2tMVmFsKHNwZWNpZmllci5sb2NhbCwgdHJ1ZSwgdW5kZWZpbmVkLCBcImltcG9ydCBzcGVjaWZpZXJcIik7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgZnVuY3Rpb24gdHlwZSBwYXJhbWV0ZXJzIC0gZnVuY3Rpb24gZm9vPFQ+KCkge31cbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VGdW5jdGlvblBhcmFtc1wiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpbm5lci5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHBhcnNlIGZsb3cgdHlwZSBhbm5vdGF0aW9ucyBvbiB2YXJpYWJsZSBkZWNsYXJhdG9yIGhlYWRzIC0gbGV0IGZvbzogc3RyaW5nID0gYmFyXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlVmFySGVhZFwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRlY2wpIHtcbiAgICAgIGlubmVyLmNhbGwodGhpcywgZGVjbCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCh0eXBlcy5jb2xvbikpIHtcbiAgICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgICAgdGhpcy5maW5pc2hOb2RlKGRlY2wuaWQsIGRlY2wuaWQudHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgdGhlIHJldHVybiB0eXBlIG9mIGFuIGFzeW5jIGFycm93IGZ1bmN0aW9uIC0gbGV0IGZvbyA9IChhc3luYyAoKTogbnVtYmVyID0+IHt9KTtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uXCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgY2FsbCkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlLCBjYWxsKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyB0b2RvIGRlc2NyaXB0aW9uXG4gIGluc3RhbmNlLmV4dGVuZChcInNob3VsZFBhcnNlQXN5bmNBcnJvd1wiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2godHlwZXMuY29sb24pIHx8IGlubmVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gV2UgbmVlZCB0byBzdXBwb3J0IHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9ucyBmb3IgYXJyb3cgZnVuY3Rpb25zLiBUaGlzXG4gIC8vIGlzIHRyaWNreS4gVGhlcmUgYXJlIHRocmVlIHNpdHVhdGlvbnMgd2UgbmVlZCB0byBoYW5kbGVcbiAgLy9cbiAgLy8gMS4gVGhpcyBpcyBlaXRoZXIgSlNYIG9yIGFuIGFycm93IGZ1bmN0aW9uLiBXZSdsbCB0cnkgSlNYIGZpcnN0LiBJZiB0aGF0XG4gIC8vICAgIGZhaWxzLCB3ZSdsbCB0cnkgYW4gYXJyb3cgZnVuY3Rpb24uIElmIHRoYXQgZmFpbHMsIHdlJ2xsIHRocm93IHRoZSBKU1hcbiAgLy8gICAgZXJyb3IuXG4gIC8vIDIuIFRoaXMgaXMgYW4gYXJyb3cgZnVuY3Rpb24uIFdlJ2xsIHBhcnNlIHRoZSB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbixcbiAgLy8gICAgcGFyc2UgdGhlIHJlc3QsIG1ha2Ugc3VyZSB0aGUgcmVzdCBpcyBhbiBhcnJvdyBmdW5jdGlvbiwgYW5kIGdvIGZyb21cbiAgLy8gICAgdGhlcmVcbiAgLy8gMy4gVGhpcyBpcyBuZWl0aGVyLiBKdXN0IGNhbGwgdGhlIGlubmVyIGZ1bmN0aW9uXG4gIGluc3RhbmNlLmV4dGVuZChcInBhcnNlTWF5YmVBc3NpZ25cIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBqc3hFcnJvciA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVzLmpzeFRhZ1N0YXJ0ICYmIHRoaXMubWF0Y2godHlwZXMuanN4VGFnU3RhcnQpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gaW5uZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgYHRjLmpfZXhwcmAgYW5kIGB0Yy5qX29UYWdgIGZyb20gY29udGV4dCBhZGRlZFxuICAgICAgICAgICAgLy8gYnkgcGFyc2luZyBganN4VGFnU3RhcnRgIHRvIHN0b3AgdGhlIEpTWCBwbHVnaW4gZnJvbVxuICAgICAgICAgICAgLy8gbWVzc2luZyB3aXRoIHRoZSB0b2tlbnNcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5sZW5ndGggLT0gMjtcblxuICAgICAgICAgICAganN4RXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBubyBzdWNoIGVycm9yIGlzIGV4cGVjdGVkXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChqc3hFcnJvciAhPSBudWxsIHx8IHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSkge1xuICAgICAgICB2YXIgYXJyb3dFeHByZXNzaW9uID0gdm9pZCAwO1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuXG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uID0gaW5uZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLnN0YXJ0ID0gdHlwZVBhcmFtZXRlcnMuc3RhcnQ7XG4gICAgICAgICAgYXJyb3dFeHByZXNzaW9uLmxvYy5zdGFydCA9IHR5cGVQYXJhbWV0ZXJzLmxvYy5zdGFydDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cganN4RXJyb3IgfHwgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycm93RXhwcmVzc2lvbi50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3dFeHByZXNzaW9uO1xuICAgICAgICB9IGVsc2UgaWYgKGpzeEVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBqc3hFcnJvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHR5cGVQYXJhbWV0ZXJzLnN0YXJ0LCBcIkV4cGVjdGVkIGFuIGFycm93IGZ1bmN0aW9uIGFmdGVyIHRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlubmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGhhbmRsZSByZXR1cm4gdHlwZXMgZm9yIGFycm93IGZ1bmN0aW9uc1xuICBpbnN0YW5jZS5leHRlbmQoXCJwYXJzZUFycm93XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuY29sb24pKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCh0eXBlcy5hcnJvdykpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIC8vIGFzc2lnbiBhZnRlciBpdCBpcyBjbGVhciBpdCBpcyBhbiBhcnJvd1xuICAgICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm8gc3VjaCBlcnJvciBpcyBleHBlY3RlZFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuICB9KTtcblxuICBpbnN0YW5jZS5leHRlbmQoXCJzaG91bGRQYXJzZUFycm93XCIsIGZ1bmN0aW9uIChpbm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCh0eXBlcy5jb2xvbikgfHwgaW5uZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KTtcbn07XG5cbi8vIEFkYXB0ZWQgZnJvbSBTdHJpbmcuZnJvbWNvZGVwb2ludCB0byBleHBvcnQgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgbW9kaWZ5aW5nIFN0cmluZ1xuLyohIGh0dHBzOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjIuMSBieSBAbWF0aGlhcyAqL1xuXG4vLyBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbi8vIENvcHlyaWdodCAoYykgTWF0aGlhcyBCeW5lbnNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kXG4vLyBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuLy8gaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSxcbi8vIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yXG4vLyBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUXG4vLyBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG5pZiAoIWZyb21Db2RlUG9pbnQpIHtcbiAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICB2YXIgY29kZVVuaXRzID0gW107XG4gICAgdmFyIGhpZ2hTdXJyb2dhdGUgPSB2b2lkIDA7XG4gICAgdmFyIGxvd1N1cnJvZ2F0ZSA9IHZvaWQgMDtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pO1xuICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgIGZsb29yKGNvZGVQb2ludCkgIT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICApIHtcbiAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50OiBcIiArIGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7XG4gICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMDtcbiAgICAgICAgbG93U3Vycm9nYXRlID0gY29kZVBvaW50ICUgMHg0MDAgKyAweERDMDA7XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyAxID09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxudmFyIGZyb21Db2RlUG9pbnQkMSA9IGZyb21Db2RlUG9pbnQ7XG5cbnZhciBYSFRNTEVudGl0aWVzID0ge1xuICBxdW90OiBcIlxcXCJcIixcbiAgYW1wOiBcIiZcIixcbiAgYXBvczogXCInXCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBuYnNwOiBcIlxceEEwXCIsXG4gIGlleGNsOiBcIlxceEExXCIsXG4gIGNlbnQ6IFwiXFx4QTJcIixcbiAgcG91bmQ6IFwiXFx4QTNcIixcbiAgY3VycmVuOiBcIlxceEE0XCIsXG4gIHllbjogXCJcXHhBNVwiLFxuICBicnZiYXI6IFwiXFx4QTZcIixcbiAgc2VjdDogXCJcXHhBN1wiLFxuICB1bWw6IFwiXFx4QThcIixcbiAgY29weTogXCJcXHhBOVwiLFxuICBvcmRmOiBcIlxceEFBXCIsXG4gIGxhcXVvOiBcIlxceEFCXCIsXG4gIG5vdDogXCJcXHhBQ1wiLFxuICBzaHk6IFwiXFx4QURcIixcbiAgcmVnOiBcIlxceEFFXCIsXG4gIG1hY3I6IFwiXFx4QUZcIixcbiAgZGVnOiBcIlxceEIwXCIsXG4gIHBsdXNtbjogXCJcXHhCMVwiLFxuICBzdXAyOiBcIlxceEIyXCIsXG4gIHN1cDM6IFwiXFx4QjNcIixcbiAgYWN1dGU6IFwiXFx4QjRcIixcbiAgbWljcm86IFwiXFx4QjVcIixcbiAgcGFyYTogXCJcXHhCNlwiLFxuICBtaWRkb3Q6IFwiXFx4QjdcIixcbiAgY2VkaWw6IFwiXFx4QjhcIixcbiAgc3VwMTogXCJcXHhCOVwiLFxuICBvcmRtOiBcIlxceEJBXCIsXG4gIHJhcXVvOiBcIlxceEJCXCIsXG4gIGZyYWMxNDogXCJcXHhCQ1wiLFxuICBmcmFjMTI6IFwiXFx4QkRcIixcbiAgZnJhYzM0OiBcIlxceEJFXCIsXG4gIGlxdWVzdDogXCJcXHhCRlwiLFxuICBBZ3JhdmU6IFwiXFx4QzBcIixcbiAgQWFjdXRlOiBcIlxceEMxXCIsXG4gIEFjaXJjOiBcIlxceEMyXCIsXG4gIEF0aWxkZTogXCJcXHhDM1wiLFxuICBBdW1sOiBcIlxceEM0XCIsXG4gIEFyaW5nOiBcIlxceEM1XCIsXG4gIEFFbGlnOiBcIlxceEM2XCIsXG4gIENjZWRpbDogXCJcXHhDN1wiLFxuICBFZ3JhdmU6IFwiXFx4QzhcIixcbiAgRWFjdXRlOiBcIlxceEM5XCIsXG4gIEVjaXJjOiBcIlxceENBXCIsXG4gIEV1bWw6IFwiXFx4Q0JcIixcbiAgSWdyYXZlOiBcIlxceENDXCIsXG4gIElhY3V0ZTogXCJcXHhDRFwiLFxuICBJY2lyYzogXCJcXHhDRVwiLFxuICBJdW1sOiBcIlxceENGXCIsXG4gIEVUSDogXCJcXHhEMFwiLFxuICBOdGlsZGU6IFwiXFx4RDFcIixcbiAgT2dyYXZlOiBcIlxceEQyXCIsXG4gIE9hY3V0ZTogXCJcXHhEM1wiLFxuICBPY2lyYzogXCJcXHhENFwiLFxuICBPdGlsZGU6IFwiXFx4RDVcIixcbiAgT3VtbDogXCJcXHhENlwiLFxuICB0aW1lczogXCJcXHhEN1wiLFxuICBPc2xhc2g6IFwiXFx4RDhcIixcbiAgVWdyYXZlOiBcIlxceEQ5XCIsXG4gIFVhY3V0ZTogXCJcXHhEQVwiLFxuICBVY2lyYzogXCJcXHhEQlwiLFxuICBVdW1sOiBcIlxceERDXCIsXG4gIFlhY3V0ZTogXCJcXHhERFwiLFxuICBUSE9STjogXCJcXHhERVwiLFxuICBzemxpZzogXCJcXHhERlwiLFxuICBhZ3JhdmU6IFwiXFx4RTBcIixcbiAgYWFjdXRlOiBcIlxceEUxXCIsXG4gIGFjaXJjOiBcIlxceEUyXCIsXG4gIGF0aWxkZTogXCJcXHhFM1wiLFxuICBhdW1sOiBcIlxceEU0XCIsXG4gIGFyaW5nOiBcIlxceEU1XCIsXG4gIGFlbGlnOiBcIlxceEU2XCIsXG4gIGNjZWRpbDogXCJcXHhFN1wiLFxuICBlZ3JhdmU6IFwiXFx4RThcIixcbiAgZWFjdXRlOiBcIlxceEU5XCIsXG4gIGVjaXJjOiBcIlxceEVBXCIsXG4gIGV1bWw6IFwiXFx4RUJcIixcbiAgaWdyYXZlOiBcIlxceEVDXCIsXG4gIGlhY3V0ZTogXCJcXHhFRFwiLFxuICBpY2lyYzogXCJcXHhFRVwiLFxuICBpdW1sOiBcIlxceEVGXCIsXG4gIGV0aDogXCJcXHhGMFwiLFxuICBudGlsZGU6IFwiXFx4RjFcIixcbiAgb2dyYXZlOiBcIlxceEYyXCIsXG4gIG9hY3V0ZTogXCJcXHhGM1wiLFxuICBvY2lyYzogXCJcXHhGNFwiLFxuICBvdGlsZGU6IFwiXFx4RjVcIixcbiAgb3VtbDogXCJcXHhGNlwiLFxuICBkaXZpZGU6IFwiXFx4RjdcIixcbiAgb3NsYXNoOiBcIlxceEY4XCIsXG4gIHVncmF2ZTogXCJcXHhGOVwiLFxuICB1YWN1dGU6IFwiXFx4RkFcIixcbiAgdWNpcmM6IFwiXFx4RkJcIixcbiAgdXVtbDogXCJcXHhGQ1wiLFxuICB5YWN1dGU6IFwiXFx4RkRcIixcbiAgdGhvcm46IFwiXFx4RkVcIixcbiAgeXVtbDogXCJcXHhGRlwiLFxuICBPRWxpZzogXCJcXHUwMTUyXCIsXG4gIG9lbGlnOiBcIlxcdTAxNTNcIixcbiAgU2Nhcm9uOiBcIlxcdTAxNjBcIixcbiAgc2Nhcm9uOiBcIlxcdTAxNjFcIixcbiAgWXVtbDogXCJcXHUwMTc4XCIsXG4gIGZub2Y6IFwiXFx1MDE5MlwiLFxuICBjaXJjOiBcIlxcdTAyQzZcIixcbiAgdGlsZGU6IFwiXFx1MDJEQ1wiLFxuICBBbHBoYTogXCJcXHUwMzkxXCIsXG4gIEJldGE6IFwiXFx1MDM5MlwiLFxuICBHYW1tYTogXCJcXHUwMzkzXCIsXG4gIERlbHRhOiBcIlxcdTAzOTRcIixcbiAgRXBzaWxvbjogXCJcXHUwMzk1XCIsXG4gIFpldGE6IFwiXFx1MDM5NlwiLFxuICBFdGE6IFwiXFx1MDM5N1wiLFxuICBUaGV0YTogXCJcXHUwMzk4XCIsXG4gIElvdGE6IFwiXFx1MDM5OVwiLFxuICBLYXBwYTogXCJcXHUwMzlBXCIsXG4gIExhbWJkYTogXCJcXHUwMzlCXCIsXG4gIE11OiBcIlxcdTAzOUNcIixcbiAgTnU6IFwiXFx1MDM5RFwiLFxuICBYaTogXCJcXHUwMzlFXCIsXG4gIE9taWNyb246IFwiXFx1MDM5RlwiLFxuICBQaTogXCJcXHUwM0EwXCIsXG4gIFJobzogXCJcXHUwM0ExXCIsXG4gIFNpZ21hOiBcIlxcdTAzQTNcIixcbiAgVGF1OiBcIlxcdTAzQTRcIixcbiAgVXBzaWxvbjogXCJcXHUwM0E1XCIsXG4gIFBoaTogXCJcXHUwM0E2XCIsXG4gIENoaTogXCJcXHUwM0E3XCIsXG4gIFBzaTogXCJcXHUwM0E4XCIsXG4gIE9tZWdhOiBcIlxcdTAzQTlcIixcbiAgYWxwaGE6IFwiXFx1MDNCMVwiLFxuICBiZXRhOiBcIlxcdTAzQjJcIixcbiAgZ2FtbWE6IFwiXFx1MDNCM1wiLFxuICBkZWx0YTogXCJcXHUwM0I0XCIsXG4gIGVwc2lsb246IFwiXFx1MDNCNVwiLFxuICB6ZXRhOiBcIlxcdTAzQjZcIixcbiAgZXRhOiBcIlxcdTAzQjdcIixcbiAgdGhldGE6IFwiXFx1MDNCOFwiLFxuICBpb3RhOiBcIlxcdTAzQjlcIixcbiAga2FwcGE6IFwiXFx1MDNCQVwiLFxuICBsYW1iZGE6IFwiXFx1MDNCQlwiLFxuICBtdTogXCJcXHUwM0JDXCIsXG4gIG51OiBcIlxcdTAzQkRcIixcbiAgeGk6IFwiXFx1MDNCRVwiLFxuICBvbWljcm9uOiBcIlxcdTAzQkZcIixcbiAgcGk6IFwiXFx1MDNDMFwiLFxuICByaG86IFwiXFx1MDNDMVwiLFxuICBzaWdtYWY6IFwiXFx1MDNDMlwiLFxuICBzaWdtYTogXCJcXHUwM0MzXCIsXG4gIHRhdTogXCJcXHUwM0M0XCIsXG4gIHVwc2lsb246IFwiXFx1MDNDNVwiLFxuICBwaGk6IFwiXFx1MDNDNlwiLFxuICBjaGk6IFwiXFx1MDNDN1wiLFxuICBwc2k6IFwiXFx1MDNDOFwiLFxuICBvbWVnYTogXCJcXHUwM0M5XCIsXG4gIHRoZXRhc3ltOiBcIlxcdTAzRDFcIixcbiAgdXBzaWg6IFwiXFx1MDNEMlwiLFxuICBwaXY6IFwiXFx1MDNENlwiLFxuICBlbnNwOiBcIlxcdTIwMDJcIixcbiAgZW1zcDogXCJcXHUyMDAzXCIsXG4gIHRoaW5zcDogXCJcXHUyMDA5XCIsXG4gIHp3bmo6IFwiXFx1MjAwQ1wiLFxuICB6d2o6IFwiXFx1MjAwRFwiLFxuICBscm06IFwiXFx1MjAwRVwiLFxuICBybG06IFwiXFx1MjAwRlwiLFxuICBuZGFzaDogXCJcXHUyMDEzXCIsXG4gIG1kYXNoOiBcIlxcdTIwMTRcIixcbiAgbHNxdW86IFwiXFx1MjAxOFwiLFxuICByc3F1bzogXCJcXHUyMDE5XCIsXG4gIHNicXVvOiBcIlxcdTIwMUFcIixcbiAgbGRxdW86IFwiXFx1MjAxQ1wiLFxuICByZHF1bzogXCJcXHUyMDFEXCIsXG4gIGJkcXVvOiBcIlxcdTIwMUVcIixcbiAgZGFnZ2VyOiBcIlxcdTIwMjBcIixcbiAgRGFnZ2VyOiBcIlxcdTIwMjFcIixcbiAgYnVsbDogXCJcXHUyMDIyXCIsXG4gIGhlbGxpcDogXCJcXHUyMDI2XCIsXG4gIHBlcm1pbDogXCJcXHUyMDMwXCIsXG4gIHByaW1lOiBcIlxcdTIwMzJcIixcbiAgUHJpbWU6IFwiXFx1MjAzM1wiLFxuICBsc2FxdW86IFwiXFx1MjAzOVwiLFxuICByc2FxdW86IFwiXFx1MjAzQVwiLFxuICBvbGluZTogXCJcXHUyMDNFXCIsXG4gIGZyYXNsOiBcIlxcdTIwNDRcIixcbiAgZXVybzogXCJcXHUyMEFDXCIsXG4gIGltYWdlOiBcIlxcdTIxMTFcIixcbiAgd2VpZXJwOiBcIlxcdTIxMThcIixcbiAgcmVhbDogXCJcXHUyMTFDXCIsXG4gIHRyYWRlOiBcIlxcdTIxMjJcIixcbiAgYWxlZnN5bTogXCJcXHUyMTM1XCIsXG4gIGxhcnI6IFwiXFx1MjE5MFwiLFxuICB1YXJyOiBcIlxcdTIxOTFcIixcbiAgcmFycjogXCJcXHUyMTkyXCIsXG4gIGRhcnI6IFwiXFx1MjE5M1wiLFxuICBoYXJyOiBcIlxcdTIxOTRcIixcbiAgY3JhcnI6IFwiXFx1MjFCNVwiLFxuICBsQXJyOiBcIlxcdTIxRDBcIixcbiAgdUFycjogXCJcXHUyMUQxXCIsXG4gIHJBcnI6IFwiXFx1MjFEMlwiLFxuICBkQXJyOiBcIlxcdTIxRDNcIixcbiAgaEFycjogXCJcXHUyMUQ0XCIsXG4gIGZvcmFsbDogXCJcXHUyMjAwXCIsXG4gIHBhcnQ6IFwiXFx1MjIwMlwiLFxuICBleGlzdDogXCJcXHUyMjAzXCIsXG4gIGVtcHR5OiBcIlxcdTIyMDVcIixcbiAgbmFibGE6IFwiXFx1MjIwN1wiLFxuICBpc2luOiBcIlxcdTIyMDhcIixcbiAgbm90aW46IFwiXFx1MjIwOVwiLFxuICBuaTogXCJcXHUyMjBCXCIsXG4gIHByb2Q6IFwiXFx1MjIwRlwiLFxuICBzdW06IFwiXFx1MjIxMVwiLFxuICBtaW51czogXCJcXHUyMjEyXCIsXG4gIGxvd2FzdDogXCJcXHUyMjE3XCIsXG4gIHJhZGljOiBcIlxcdTIyMUFcIixcbiAgcHJvcDogXCJcXHUyMjFEXCIsXG4gIGluZmluOiBcIlxcdTIyMUVcIixcbiAgYW5nOiBcIlxcdTIyMjBcIixcbiAgYW5kOiBcIlxcdTIyMjdcIixcbiAgb3I6IFwiXFx1MjIyOFwiLFxuICBjYXA6IFwiXFx1MjIyOVwiLFxuICBjdXA6IFwiXFx1MjIyQVwiLFxuICBcImludFwiOiBcIlxcdTIyMkJcIixcbiAgdGhlcmU0OiBcIlxcdTIyMzRcIixcbiAgc2ltOiBcIlxcdTIyM0NcIixcbiAgY29uZzogXCJcXHUyMjQ1XCIsXG4gIGFzeW1wOiBcIlxcdTIyNDhcIixcbiAgbmU6IFwiXFx1MjI2MFwiLFxuICBlcXVpdjogXCJcXHUyMjYxXCIsXG4gIGxlOiBcIlxcdTIyNjRcIixcbiAgZ2U6IFwiXFx1MjI2NVwiLFxuICBzdWI6IFwiXFx1MjI4MlwiLFxuICBzdXA6IFwiXFx1MjI4M1wiLFxuICBuc3ViOiBcIlxcdTIyODRcIixcbiAgc3ViZTogXCJcXHUyMjg2XCIsXG4gIHN1cGU6IFwiXFx1MjI4N1wiLFxuICBvcGx1czogXCJcXHUyMjk1XCIsXG4gIG90aW1lczogXCJcXHUyMjk3XCIsXG4gIHBlcnA6IFwiXFx1MjJBNVwiLFxuICBzZG90OiBcIlxcdTIyQzVcIixcbiAgbGNlaWw6IFwiXFx1MjMwOFwiLFxuICByY2VpbDogXCJcXHUyMzA5XCIsXG4gIGxmbG9vcjogXCJcXHUyMzBBXCIsXG4gIHJmbG9vcjogXCJcXHUyMzBCXCIsXG4gIGxhbmc6IFwiXFx1MjMyOVwiLFxuICByYW5nOiBcIlxcdTIzMkFcIixcbiAgbG96OiBcIlxcdTI1Q0FcIixcbiAgc3BhZGVzOiBcIlxcdTI2NjBcIixcbiAgY2x1YnM6IFwiXFx1MjY2M1wiLFxuICBoZWFydHM6IFwiXFx1MjY2NVwiLFxuICBkaWFtczogXCJcXHUyNjY2XCJcbn07XG5cbnZhciBIRVhfTlVNQkVSID0gL15bXFxkYS1mQS1GXSskLztcbnZhciBERUNJTUFMX05VTUJFUiA9IC9eXFxkKyQvO1xuXG50eXBlcyQxLmpfb1RhZyA9IG5ldyBUb2tDb250ZXh0KFwiPHRhZ1wiLCBmYWxzZSk7XG50eXBlcyQxLmpfY1RhZyA9IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiwgZmFsc2UpO1xudHlwZXMkMS5qX2V4cHIgPSBuZXcgVG9rQ29udGV4dChcIjx0YWc+Li4uPC90YWc+XCIsIHRydWUsIHRydWUpO1xuXG50eXBlcy5qc3hOYW1lID0gbmV3IFRva2VuVHlwZShcImpzeE5hbWVcIik7XG50eXBlcy5qc3hUZXh0ID0gbmV3IFRva2VuVHlwZShcImpzeFRleHRcIiwgeyBiZWZvcmVFeHByOiB0cnVlIH0pO1xudHlwZXMuanN4VGFnU3RhcnQgPSBuZXcgVG9rZW5UeXBlKFwianN4VGFnU3RhcnRcIiwgeyBzdGFydHNFeHByOiB0cnVlIH0pO1xudHlwZXMuanN4VGFnRW5kID0gbmV3IFRva2VuVHlwZShcImpzeFRhZ0VuZFwiKTtcblxudHlwZXMuanN4VGFnU3RhcnQudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS5qX2V4cHIpOyAvLyB0cmVhdCBhcyBiZWdpbm5pbmcgb2YgSlNYIGV4cHJlc3Npb25cbiAgdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godHlwZXMkMS5qX29UYWcpOyAvLyBzdGFydCBvcGVuaW5nIHRhZyBjb250ZXh0XG4gIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmpzeFRhZ0VuZC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHByZXZUeXBlKSB7XG4gIHZhciBvdXQgPSB0aGlzLnN0YXRlLmNvbnRleHQucG9wKCk7XG4gIGlmIChvdXQgPT09IHR5cGVzJDEual9vVGFnICYmIHByZXZUeXBlID09PSB0eXBlcy5zbGFzaCB8fCBvdXQgPT09IHR5cGVzJDEual9jVGFnKSB7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO1xuICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5qX2V4cHI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCA9IHRydWU7XG4gIH1cbn07XG5cbnZhciBwcCQ5ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gUmVhZHMgaW5saW5lIEpTWCBjb250ZW50cyB0b2tlbi5cblxucHAkOS5qc3hSZWFkVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBcIlwiO1xuICB2YXIgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50c1wiKTtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSA2MDogLy8gXCI8XCJcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICAvLyBcIntcIlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQpIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdTdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY2gpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGV4dCwgb3V0KTtcblxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gXCImXCJcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKHRydWUpO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5wcCQ5LmpzeFJlYWROZXdMaW5lID0gZnVuY3Rpb24gKG5vcm1hbGl6ZUNSTEYpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgdmFyIG91dCA9IHZvaWQgMDtcbiAgKyt0aGlzLnN0YXRlLnBvcztcbiAgaWYgKGNoID09PSAxMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpID09PSAxMCkge1xuICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgb3V0ID0gbm9ybWFsaXplQ1JMRiA/IFwiXFxuXCIgOiBcIlxcclxcblwiO1xuICB9IGVsc2Uge1xuICAgIG91dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICB9XG4gICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5wcCQ5LmpzeFJlYWRTdHJpbmcgPSBmdW5jdGlvbiAocXVvdGUpIHtcbiAgdmFyIG91dCA9IFwiXCI7XG4gIHZhciBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcbiAgICBpZiAoY2ggPT09IDM4KSB7XG4gICAgICAvLyBcIiZcIlxuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZEVudGl0eSgpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpO1xufTtcblxucHAkOS5qc3hSZWFkRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGVudGl0eSA9IHZvaWQgMDtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc107XG5cbiAgdmFyIHN0YXJ0UG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgY291bnQrKyA8IDEwKSB7XG4gICAgY2ggPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zKytdO1xuICAgIGlmIChjaCA9PT0gXCI7XCIpIHtcbiAgICAgIGlmIChzdHJbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIGlmIChzdHJbMV0gPT09IFwieFwiKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigyKTtcbiAgICAgICAgICBpZiAoSEVYX05VTUJFUi50ZXN0KHN0cikpIGVudGl0eSA9IGZyb21Db2RlUG9pbnQkMShwYXJzZUludChzdHIsIDE2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgICAgICAgICBpZiAoREVDSU1BTF9OVU1CRVIudGVzdChzdHIpKSBlbnRpdHkgPSBmcm9tQ29kZVBvaW50JDEocGFyc2VJbnQoc3RyLCAxMCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBYSFRNTEVudGl0aWVzW3N0cl07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyICs9IGNoO1xuICB9XG4gIGlmICghZW50aXR5KSB7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBzdGFydFBvcztcbiAgICByZXR1cm4gXCImXCI7XG4gIH1cbiAgcmV0dXJuIGVudGl0eTtcbn07XG5cbi8vIFJlYWQgYSBKU1ggaWRlbnRpZmllciAodmFsaWQgdGFnIG9yIGF0dHJpYnV0ZSBuYW1lKS5cbi8vXG4vLyBPcHRpbWl6ZWQgdmVyc2lvbiBzaW5jZSBKU1ggaWRlbnRpZmllcnMgY2FuXCJ0IGNvbnRhaW5cbi8vIGVzY2FwZSBjaGFyYWN0ZXJzIGFuZCBzbyBjYW4gYmUgcmVhZCBhcyBzaW5nbGUgc2xpY2UuXG4vLyBBbHNvIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgd2FzIGFscmVhZHkgY2hlY2tlZFxuLy8gYnkgaXNJZGVudGlmaWVyU3RhcnQgaW4gcmVhZFRva2VuLlxuXG5wcCQ5LmpzeFJlYWRXb3JkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2ggPSB2b2lkIDA7XG4gIHZhciBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICBkbyB7XG4gICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG4gIH0gd2hpbGUgKGlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7IC8vIFwiLVwiXG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmpzeE5hbWUsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG59O1xuXG4vLyBUcmFuc2Zvcm1zIEpTWCBlbGVtZW50IG5hbWUgdG8gc3RyaW5nLlxuXG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWVzcGFjZS5uYW1lICsgXCI6XCIgKyBvYmplY3QubmFtZS5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cbn1cblxuLy8gUGFyc2UgbmV4dCB0b2tlbiBhcyBKU1ggaWRlbnRpZmllclxuXG5wcCQ5LmpzeFBhcnNlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5qc3hOYW1lKSkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnR5cGUua2V5d29yZDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG59O1xuXG4vLyBQYXJzZSBuYW1lc3BhY2VkIGlkZW50aWZpZXIuXG5cbnBwJDkuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIG5hbWUgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbG9uKSkgcmV0dXJuIG5hbWU7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubmFtZXNwYWNlID0gbmFtZTtcbiAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xufTtcblxuLy8gUGFyc2VzIGVsZW1lbnQgbmFtZSBpbiBhbnkgZm9ybSAtIG5hbWVzcGFjZWQsIG1lbWJlclxuLy8gb3Igc2luZ2xlIGlkZW50aWZpZXIuXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgdmFyIG5vZGUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgbmV3Tm9kZS5wcm9wZXJ0eSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShuZXdOb2RlLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIik7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vLyBQYXJzZXMgYW55IHR5cGUgb2YgSlNYIGF0dHJpYnV0ZSB2YWx1ZS5cblxucHAkOS5qc3hQYXJzZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIG5vZGUgPSB0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcigpO1xuICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgY2FzZSB0eXBlcy5qc3hUYWdTdGFydDpcbiAgICBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIG5vZGUuZXh0cmEgPSBudWxsO1xuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LCBcIkpTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHRcIik7XG4gIH1cbn07XG5cbi8vIEpTWEVtcHR5RXhwcmVzc2lvbiBpcyB1bmlxdWUgdHlwZSBzaW5jZSBpdCBkb2Vzbid0IGFjdHVhbGx5IHBhcnNlIGFueXRoaW5nLFxuLy8gYW5kIHNvIGl0IHNob3VsZCBzdGFydCBhdCB0aGUgZW5kIG9mIGxhc3QgcmVhZCB0b2tlbiAobGVmdCBicmFjZSkgYW5kIGZpbmlzaFxuLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBvbmUgKHJpZ2h0IGJyYWNlKS5cblxucHAkOS5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva0VuZCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xufTtcblxuLy8gUGFyc2UgSlNYIHNwcmVhZCBjaGlsZFxuXG5wcCQ5LmpzeFBhcnNlU3ByZWFkQ2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuZWxsaXBzaXMpO1xuICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRDaGlsZFwiKTtcbn07XG5cbi8vIFBhcnNlcyBKU1ggZXhwcmVzc2lvbiBlbmNsb3NlZCBpbnRvIGN1cmx5IGJyYWNrZXRzLlxuXG5cbnBwJDkuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5tYXRjaCh0eXBlcy5icmFjZVIpKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5qc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG59O1xuXG4vLyBQYXJzZXMgZm9sbG93aW5nIEpTWCBhdHRyaWJ1dGUgbmFtZS12YWx1ZSBwYWlyLlxuXG5wcCQ5LmpzeFBhcnNlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5icmFjZUwpKSB7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuZWxsaXBzaXMpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gIH1cbiAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gIG5vZGUudmFsdWUgPSB0aGlzLmVhdCh0eXBlcy5lcSkgPyB0aGlzLmpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hBdHRyaWJ1dGVcIik7XG59O1xuXG4vLyBQYXJzZXMgSlNYIG9wZW5pbmcgdGFnIHN0YXJ0aW5nIGFmdGVyIFwiPFwiLlxuXG5wcCQ5LmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdCA9IGZ1bmN0aW9uIChzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgd2hpbGUgKCF0aGlzLm1hdGNoKHR5cGVzLnNsYXNoKSAmJiAhdGhpcy5tYXRjaCh0eXBlcy5qc3hUYWdFbmQpKSB7XG4gICAgbm9kZS5hdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtcbiAgfVxuICBub2RlLnNlbGZDbG9zaW5nID0gdGhpcy5lYXQodHlwZXMuc2xhc2gpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5qc3hUYWdFbmQpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0VsZW1lbnRcIik7XG59O1xuXG4vLyBQYXJzZXMgSlNYIGNsb3NpbmcgdGFnIHN0YXJ0aW5nIGFmdGVyIFwiPC9cIi5cblxucHAkOS5qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuanN4VGFnRW5kKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdFbGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2VzIGVudGlyZSBKU1ggZWxlbWVudCwgaW5jbHVkaW5nIGl0XCJzIG9wZW5pbmcgdGFnXG4vLyAoc3RhcnRpbmcgYWZ0ZXIgXCI8XCIpLCBhdHRyaWJ1dGVzLCBjb250ZW50cyBhbmQgY2xvc2luZyB0YWcuXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50QXQgPSBmdW5jdGlvbiAoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgdmFyIG9wZW5pbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgdmFyIGNsb3NpbmdFbGVtZW50ID0gbnVsbDtcblxuICBpZiAoIW9wZW5pbmdFbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgY29udGVudHM6IGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuanN4VGFnU3RhcnQ6XG4gICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O3N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpZiAodGhpcy5lYXQodHlwZXMuc2xhc2gpKSB7XG4gICAgICAgICAgICBjbG9zaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VDbG9zaW5nRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICBicmVhayBjb250ZW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHlwZXMuanN4VGV4dDpcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQoKS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlU3ByZWFkQ2hpbGQoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdldFF1YWxpZmllZEpTWE5hbWUoY2xvc2luZ0VsZW1lbnQubmFtZSkgIT09IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkpIHtcbiAgICAgIHRoaXMucmFpc2UoY2xvc2luZ0VsZW1lbnQuc3RhcnQsIFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDxcIiArIGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkgKyBcIj5cIik7XG4gICAgfVxuICB9XG5cbiAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgaWYgKHRoaXMubWF0Y2godHlwZXMucmVsYXRpb25hbCkgJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCI8XCIpIHtcbiAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsIFwiQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFbGVtZW50XCIpO1xufTtcblxuLy8gUGFyc2VzIGVudGlyZSBKU1ggZWxlbWVudCBmcm9tIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwJDkuanN4UGFyc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbn07XG5cbnZhciBqc3hQbHVnaW4gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UuZXh0ZW5kKFwicGFyc2VFeHByQXRvbVwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZlNob3J0SGFuZERlZmF1bHRQb3MpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRleHQpKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJKU1hUZXh0XCIpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzIwNzhcbiAgICAgICAgbm9kZS5leHRyYSA9IG51bGw7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLmpzeFRhZ1N0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIHJlZlNob3J0SGFuZERlZmF1bHRQb3MpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInJlYWRUb2tlblwiLCBmdW5jdGlvbiAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lKSByZXR1cm4gaW5uZXIuY2FsbCh0aGlzLCBjb2RlKTtcblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcblxuICAgICAgaWYgKGNvbnRleHQgPT09IHR5cGVzJDEual9leHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzeFJlYWRUb2tlbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMkMS5qX29UYWcgfHwgY29udGV4dCA9PT0gdHlwZXMkMS5qX2NUYWcpIHtcbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanN4UmVhZFdvcmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuanN4VGFnRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoY29kZSA9PT0gMzQgfHwgY29kZSA9PT0gMzkpICYmIGNvbnRleHQgPT09IHR5cGVzJDEual9vVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuanN4UmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5leHByQWxsb3dlZCkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5qc3hUYWdTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIGNvZGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIGluc3RhbmNlLmV4dGVuZChcInVwZGF0ZUNvbnRleHRcIiwgZnVuY3Rpb24gKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmV2VHlwZSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2godHlwZXMuYnJhY2VMKSkge1xuICAgICAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgICAgICBpZiAoY3VyQ29udGV4dCA9PT0gdHlwZXMkMS5qX29UYWcpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLmJyYWNlRXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyQ29udGV4dCA9PT0gdHlwZXMkMS5qX2V4cHIpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh0eXBlcyQxLnRlbXBsYXRlUXVhc2kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubmVyLmNhbGwodGhpcywgcHJldlR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHR5cGVzLnNsYXNoKSAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuanN4VGFnU3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtPSAyOyAvLyBkbyBub3QgY29uc2lkZXIgSlNYIGV4cHIgLT4gSlNYIG9wZW4gdGFnIC0+IC4uLiBhbnltb3JlXG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHR5cGVzJDEual9jVGFnKTsgLy8gcmVjb25zaWRlciBhcyBjbG9zaW5nIHRhZyBjb250ZXh0XG4gICAgICAgIHRoaXMuc3RhdGUuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbm5lci5jYWxsKHRoaXMsIHByZXZUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn07XG5cbnBsdWdpbnMuZXN0cmVlID0gZXN0cmVlUGx1Z2luO1xucGx1Z2lucy5mbG93ID0gZmxvd1BsdWdpbjtcbnBsdWdpbnMuanN4ID0ganN4UGx1Z2luO1xuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgaWYgKHBhcnNlci5vcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwYXJzZXIuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcGFyc2VyLmdldEV4cHJlc3Npb24oKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb247XG5leHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babylon6/lib/index.js\n");

/***/ })

}]);