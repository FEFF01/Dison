(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[78],{

/***/ "./node_modules/exports-loader/index.js?traceur!./node_modules/traceur/bin/traceur.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/exports-loader?traceur!./node_modules/traceur/bin/traceur.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(global) {\n  'use strict';\n  if (global.$traceurRuntime) {\n    return;\n  }\n  function setupGlobals(global) {\n    global.Reflect = global.Reflect || {};\n    global.Reflect.global = global.Reflect.global || global;\n  }\n  setupGlobals(global);\n  var typeOf = function(x) {\n    return typeof x;\n  };\n  global.$traceurRuntime = {\n    options: {},\n    setupGlobals: setupGlobals,\n    typeof: typeOf\n  };\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);\n(function() {\n  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme) {\n      out.push(opt_scheme, ':');\n    }\n    if (opt_domain) {\n      out.push('//');\n      if (opt_userInfo) {\n        out.push(opt_userInfo, '@');\n      }\n      out.push(opt_domain);\n      if (opt_port) {\n        out.push(':', opt_port);\n      }\n    }\n    if (opt_path) {\n      out.push(opt_path);\n    }\n    if (opt_queryData) {\n      out.push('?', opt_queryData);\n    }\n    if (opt_fragment) {\n      out.push('#', opt_fragment);\n    }\n    return out.join('');\n  }\n  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n  var ComponentIndex = {\n    SCHEME: 1,\n    USER_INFO: 2,\n    DOMAIN: 3,\n    PORT: 4,\n    PATH: 5,\n    QUERY_DATA: 6,\n    FRAGMENT: 7\n  };\n  function split(uri) {\n    return (uri.match(splitRe));\n  }\n  function removeDotSegments(path) {\n    if (path === '/')\n      return '/';\n    var leadingSlash = path[0] === '/' ? '/' : '';\n    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n      switch (segment) {\n        case '':\n        case '.':\n          break;\n        case '..':\n          if (out.length)\n            out.pop();\n          else\n            up++;\n          break;\n        default:\n          out.push(segment);\n      }\n    }\n    if (!leadingSlash) {\n      while (up-- > 0) {\n        out.unshift('..');\n      }\n      if (out.length === 0)\n        out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n  }\n  function joinAndCanonicalizePath(parts) {\n    var path = parts[ComponentIndex.PATH] || '';\n    path = removeDotSegments(path);\n    parts[ComponentIndex.PATH] = path;\n    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n  }\n  function canonicalizeUrl(url) {\n    var parts = split(url);\n    return joinAndCanonicalizePath(parts);\n  }\n  function resolveUrl(base, url) {\n    var parts = split(url);\n    var baseParts = split(base);\n    if (parts[ComponentIndex.SCHEME]) {\n      return joinAndCanonicalizePath(parts);\n    } else {\n      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n    }\n    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n      if (!parts[i]) {\n        parts[i] = baseParts[i];\n      }\n    }\n    if (parts[ComponentIndex.PATH][0] == '/') {\n      return joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[ComponentIndex.PATH];\n    var index = path.lastIndexOf('/');\n    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n    parts[ComponentIndex.PATH] = path;\n    return joinAndCanonicalizePath(parts);\n  }\n  function isAbsolute(name) {\n    if (!name)\n      return false;\n    if (name[0] === '/')\n      return true;\n    var parts = split(name);\n    if (parts[ComponentIndex.SCHEME])\n      return true;\n    return false;\n  }\n  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n  $traceurRuntime.isAbsolute = isAbsolute;\n  $traceurRuntime.removeDotSegments = removeDotSegments;\n  $traceurRuntime.resolveUrl = resolveUrl;\n})();\n(function(global) {\n  'use strict';\n  var $__3 = $traceurRuntime,\n      canonicalizeUrl = $__3.canonicalizeUrl,\n      resolveUrl = $__3.resolveUrl,\n      isAbsolute = $__3.isAbsolute;\n  var moduleInstantiators = Object.create(null);\n  var baseURL;\n  if (global.location && global.location.href)\n    baseURL = resolveUrl(global.location.href, './');\n  else\n    baseURL = '';\n  function UncoatedModuleEntry(url, uncoatedModule) {\n    this.url = url;\n    this.value_ = uncoatedModule;\n  }\n  function ModuleEvaluationError(erroneousModuleName, cause) {\n    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;\n    if (!(cause instanceof ModuleEvaluationError) && cause.stack)\n      this.stack = this.stripStack(cause.stack);\n    else\n      this.stack = '';\n  }\n  ModuleEvaluationError.prototype = Object.create(Error.prototype);\n  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;\n  ModuleEvaluationError.prototype.stripError = function(message) {\n    return message.replace(/.*Error:/, this.constructor.name + ':');\n  };\n  ModuleEvaluationError.prototype.stripCause = function(cause) {\n    if (!cause)\n      return '';\n    if (!cause.message)\n      return cause + '';\n    return this.stripError(cause.message);\n  };\n  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {\n    this.stack += '\\n loaded by ' + moduleName;\n  };\n  ModuleEvaluationError.prototype.stripStack = function(causeStack) {\n    var stack = [];\n    causeStack.split('\\n').some(function(frame) {\n      if (/UncoatedModuleInstantiator/.test(frame))\n        return true;\n      stack.push(frame);\n    });\n    stack[0] = this.stripError(stack[0]);\n    return stack.join('\\n');\n  };\n  function beforeLines(lines, number) {\n    var result = [];\n    var first = number - 3;\n    if (first < 0)\n      first = 0;\n    for (var i = first; i < number; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function afterLines(lines, number) {\n    var last = number + 1;\n    if (last > lines.length - 1)\n      last = lines.length - 1;\n    var result = [];\n    for (var i = number; i <= last; i++) {\n      result.push(lines[i]);\n    }\n    return result;\n  }\n  function columnSpacing(columns) {\n    var result = '';\n    for (var i = 0; i < columns - 1; i++) {\n      result += '-';\n    }\n    return result;\n  }\n  function UncoatedModuleInstantiator(url, func) {\n    UncoatedModuleEntry.call(this, url, null);\n    this.func = func;\n  }\n  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);\n  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {\n    var $__2 = this;\n    if (this.value_)\n      return this.value_;\n    try {\n      var relativeRequire;\n      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {\n        relativeRequire = $traceurRuntime.require.bind(null, this.url);\n      }\n      return this.value_ = this.func.call(global, relativeRequire);\n    } catch (ex) {\n      if (ex instanceof ModuleEvaluationError) {\n        ex.loadedBy(this.url);\n        throw ex;\n      }\n      if (ex.stack) {\n        var lines = this.func.toString().split('\\n');\n        var evaled = [];\n        ex.stack.split('\\n').some(function(frame, index) {\n          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)\n            return true;\n          var m = /(at\\s[^\\s]*\\s).*>:(\\d*):(\\d*)\\)/.exec(frame);\n          if (m) {\n            var line = parseInt(m[2], 10);\n            evaled = evaled.concat(beforeLines(lines, line));\n            if (index === 1) {\n              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);\n            } else {\n              evaled.push(columnSpacing(m[3]) + '^');\n            }\n            evaled = evaled.concat(afterLines(lines, line));\n            evaled.push('= = = = = = = = =');\n          } else {\n            evaled.push(frame);\n          }\n        });\n        ex.stack = evaled.join('\\n');\n      }\n      throw new ModuleEvaluationError(this.url, ex);\n    }\n  };\n  function getUncoatedModuleInstantiator(name) {\n    if (!name)\n      return;\n    var url = ModuleStore.normalize(name);\n    return moduleInstantiators[url];\n  }\n  ;\n  var moduleInstances = Object.create(null);\n  var liveModuleSentinel = {};\n  function Module(uncoatedModule) {\n    var isLive = arguments[1];\n    var coatedModule = Object.create(null);\n    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {\n      var getter,\n          value;\n      if (isLive === liveModuleSentinel) {\n        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n        if (descr.get)\n          getter = descr.get;\n      }\n      if (!getter) {\n        value = uncoatedModule[name];\n        getter = function() {\n          return value;\n        };\n      }\n      Object.defineProperty(coatedModule, name, {\n        get: getter,\n        enumerable: true\n      });\n    });\n    Object.preventExtensions(coatedModule);\n    return coatedModule;\n  }\n  var ModuleStore = {\n    normalize: function(name, refererName, refererAddress) {\n      if (typeof name !== 'string')\n        throw new TypeError('module name must be a string, not ' + typeof name);\n      if (isAbsolute(name))\n        return canonicalizeUrl(name);\n      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n        throw new Error('module name embeds /../: ' + name);\n      }\n      if (name[0] === '.' && refererName)\n        return resolveUrl(refererName, name);\n      return canonicalizeUrl(name);\n    },\n    get: function(normalizedName) {\n      var m = getUncoatedModuleInstantiator(normalizedName);\n      if (!m)\n        return undefined;\n      var moduleInstance = moduleInstances[m.url];\n      if (moduleInstance)\n        return moduleInstance;\n      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n      return moduleInstances[m.url] = moduleInstance;\n    },\n    set: function(normalizedName, module) {\n      normalizedName = String(normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {\n        return module;\n      });\n      moduleInstances[normalizedName] = module;\n    },\n    get baseURL() {\n      return baseURL;\n    },\n    set baseURL(v) {\n      baseURL = String(v);\n    },\n    registerModule: function(name, deps, func) {\n      var normalizedName = ModuleStore.normalize(name);\n      if (moduleInstantiators[normalizedName])\n        throw new Error('duplicate module named ' + normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n    },\n    bundleStore: Object.create(null),\n    register: function(name, deps, func) {\n      if (!deps || !deps.length && !func.length) {\n        this.registerModule(name, deps, func);\n      } else {\n        this.bundleStore[name] = {\n          deps: deps,\n          execute: function() {\n            var $__2 = arguments;\n            var depMap = {};\n            deps.forEach(function(dep, index) {\n              return depMap[dep] = $__2[index];\n            });\n            var registryEntry = func.call(this, depMap);\n            registryEntry.execute.call(this);\n            return registryEntry.exports;\n          }\n        };\n      }\n    },\n    getAnonymousModule: function(func) {\n      return new Module(func(), liveModuleSentinel);\n    }\n  };\n  var moduleStoreModule = new Module({ModuleStore: ModuleStore});\n  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n  };\n  $traceurRuntime.ModuleStore = ModuleStore;\n  $traceurRuntime.registerModule = ModuleStore.registerModule.bind(ModuleStore);\n  $traceurRuntime.getModule = ModuleStore.get;\n  $traceurRuntime.setModule = ModuleStore.set;\n  $traceurRuntime.normalizeModuleName = ModuleStore.normalize;\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/new-unique-string.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/new-unique-string.js\";\n  var random = Math.random;\n  var counter = Date.now() % 1e9;\n  function newUniqueString() {\n    return '__$' + (random() * 1e9 >>> 1) + '$' + ++counter + '$__';\n  }\n  return {get default() {\n      return newUniqueString;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/has-native-symbols.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/has-native-symbols.js\";\n  var v = !!Object.getOwnPropertySymbols && typeof Symbol === 'function';\n  function hasNativeSymbol() {\n    return v;\n  }\n  return {get default() {\n      return hasNativeSymbol;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/symbols.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/symbols.js\";\n  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../new-unique-string.js\", \"traceur@0.0.111/src/runtime/modules/symbols.js\")).default;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../has-native-symbols.js\", \"traceur@0.0.111/src/runtime/modules/symbols.js\")).default;\n  var $create = Object.create;\n  var $defineProperty = Object.defineProperty;\n  var $freeze = Object.freeze;\n  var $getOwnPropertyNames = Object.getOwnPropertyNames;\n  var $keys = Object.keys;\n  var $TypeError = TypeError;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var symbolInternalProperty = newUniqueString();\n  var symbolDescriptionProperty = newUniqueString();\n  var symbolDataProperty = newUniqueString();\n  var symbolValues = $create(null);\n  var SymbolImpl = function Symbol(description) {\n    var value = new SymbolValue(description);\n    if (!(this instanceof SymbolImpl))\n      return value;\n    throw new $TypeError('Symbol cannot be new\\'ed');\n  };\n  $defineProperty(SymbolImpl.prototype, 'constructor', nonEnum(SymbolImpl));\n  $defineProperty(SymbolImpl.prototype, 'toString', nonEnum(function() {\n    var symbolValue = this[symbolDataProperty];\n    return symbolValue[symbolInternalProperty];\n  }));\n  $defineProperty(SymbolImpl.prototype, 'valueOf', nonEnum(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!symbolValue)\n      throw $TypeError('Conversion from symbol to string');\n    return symbolValue[symbolInternalProperty];\n  }));\n  function SymbolValue(description) {\n    var key = newUniqueString();\n    $defineProperty(this, symbolDataProperty, {value: this});\n    $defineProperty(this, symbolInternalProperty, {value: key});\n    $defineProperty(this, symbolDescriptionProperty, {value: description});\n    $freeze(this);\n    symbolValues[key] = this;\n  }\n  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(SymbolImpl));\n  $defineProperty(SymbolValue.prototype, 'toString', {\n    value: SymbolImpl.prototype.toString,\n    enumerable: false\n  });\n  $defineProperty(SymbolValue.prototype, 'valueOf', {\n    value: SymbolImpl.prototype.valueOf,\n    enumerable: false\n  });\n  $freeze(SymbolValue.prototype);\n  function isSymbolString(s) {\n    return symbolValues[s];\n  }\n  function removeSymbolKeys(array) {\n    var rv = [];\n    for (var i = 0; i < array.length; i++) {\n      if (!isSymbolString(array[i])) {\n        rv.push(array[i]);\n      }\n    }\n    return rv;\n  }\n  function getOwnPropertyNames(object) {\n    return removeSymbolKeys($getOwnPropertyNames(object));\n  }\n  function keys(object) {\n    return removeSymbolKeys($keys(object));\n  }\n  function getOwnPropertySymbols(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var symbol = symbolValues[names[i]];\n      if (symbol) {\n        rv.push(symbol);\n      }\n    }\n    return rv;\n  }\n  function polyfillSymbol(global) {\n    var Object = global.Object;\n    if (!hasNativeSymbol()) {\n      global.Symbol = SymbolImpl;\n      Object.getOwnPropertyNames = getOwnPropertyNames;\n      Object.keys = keys;\n      $defineProperty(Object, 'getOwnPropertySymbols', nonEnum(getOwnPropertySymbols));\n    }\n    if (!global.Symbol.iterator) {\n      global.Symbol.iterator = global.Symbol('Symbol.iterator');\n    }\n    if (!global.Symbol.observer) {\n      global.Symbol.observer = global.Symbol('Symbol.observer');\n    }\n  }\n  var g = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : (void 0);\n  polyfillSymbol(g);\n  var typeOf = hasNativeSymbol() ? function(x) {\n    return typeof x;\n  } : function(x) {\n    return x instanceof SymbolValue ? 'symbol' : typeof x;\n  };\n  return {get typeof() {\n      return typeOf;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/typeof.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/typeof.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./symbols.js\", \"traceur@0.0.111/src/runtime/modules/typeof.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__.typeof;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/symbols.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/symbols.js\";\n  var t = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/typeof.js\", \"traceur@0.0.111/src/runtime/symbols.js\")).default;\n  $traceurRuntime.typeof = t;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/createClass.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/createClass.js\";\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $__1 = Object,\n      create = $__1.create,\n      defineProperties = $__1.defineProperties,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,\n      getOwnPropertyNames = $__1.getOwnPropertyNames,\n      getOwnPropertySymbols = $__1.getOwnPropertySymbols;\n  function forEachPropertyKey(object, f) {\n    getOwnPropertyNames(object).forEach(f);\n    if (getOwnPropertySymbols) {\n      getOwnPropertySymbols(object).forEach(f);\n    }\n  }\n  function getDescriptors(object) {\n    var descriptors = {};\n    forEachPropertyKey(object, function(key) {\n      descriptors[key] = getOwnPropertyDescriptor(object, key);\n      descriptors[key].enumerable = false;\n    });\n    return descriptors;\n  }\n  var nonEnum = {enumerable: false};\n  function makePropertiesNonEnumerable(object) {\n    forEachPropertyKey(object, function(key) {\n      defineProperty(object, key, nonEnum);\n    });\n  }\n  function createClass(ctor, object, staticObject, superClass) {\n    defineProperty(object, 'constructor', {\n      value: ctor,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    if (arguments.length > 3) {\n      if (typeof superClass === 'function')\n        ctor.__proto__ = superClass;\n      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));\n    } else {\n      makePropertiesNonEnumerable(object);\n      ctor.prototype = object;\n    }\n    defineProperty(ctor, 'prototype', {\n      configurable: false,\n      writable: false\n    });\n    return defineProperties(ctor, getDescriptors(staticObject));\n  }\n  function getProtoParent(superClass) {\n    if (typeof superClass === 'function') {\n      var prototype = superClass.prototype;\n      if ($Object(prototype) === prototype || prototype === null)\n        return superClass.prototype;\n      throw new $TypeError('super prototype must be an Object or null');\n    }\n    if (superClass === null)\n      return null;\n    throw new $TypeError((\"Super expression must either be null or a function, not \" + typeof superClass + \".\"));\n  }\n  return {get default() {\n      return createClass;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/superConstructor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/superConstructor.js\";\n  function superConstructor(ctor) {\n    return ctor.__proto__;\n  }\n  return {get default() {\n      return superConstructor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/superDescriptor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/superDescriptor.js\";\n  var $__0 = Object,\n      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,\n      getPrototypeOf = $__0.getPrototypeOf;\n  function superDescriptor(homeObject, name) {\n    var proto = getPrototypeOf(homeObject);\n    do {\n      var result = getOwnPropertyDescriptor(proto, name);\n      if (result)\n        return result;\n      proto = getPrototypeOf(proto);\n    } while (proto);\n    return undefined;\n  }\n  return {get default() {\n      return superDescriptor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/superGet.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/superGet.js\";\n  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./superDescriptor.js\", \"traceur@0.0.111/src/runtime/modules/superGet.js\")).default;\n  function superGet(self, homeObject, name) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      var value = descriptor.value;\n      if (value)\n        return value;\n      if (!descriptor.get)\n        return value;\n      return descriptor.get.call(self);\n    }\n    return undefined;\n  }\n  return {get default() {\n      return superGet;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/superSet.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/superSet.js\";\n  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./superDescriptor.js\", \"traceur@0.0.111/src/runtime/modules/superSet.js\")).default;\n  var $TypeError = TypeError;\n  function superSet(self, homeObject, name, value) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(self, value);\n      return value;\n    }\n    throw $TypeError((\"super has no setter '\" + name + \"'.\"));\n  }\n  return {get default() {\n      return superSet;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/classes.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/classes.js\";\n  var createClass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/createClass.js\", \"traceur@0.0.111/src/runtime/classes.js\")).default;\n  var superConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/superConstructor.js\", \"traceur@0.0.111/src/runtime/classes.js\")).default;\n  var superGet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/superGet.js\", \"traceur@0.0.111/src/runtime/classes.js\")).default;\n  var superSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/superSet.js\", \"traceur@0.0.111/src/runtime/classes.js\")).default;\n  $traceurRuntime.createClass = createClass;\n  $traceurRuntime.superConstructor = superConstructor;\n  $traceurRuntime.superGet = superGet;\n  $traceurRuntime.superSet = superSet;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/exportStar.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/exportStar.js\";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyNames = $__1.getOwnPropertyNames;\n  function exportStar(object) {\n    var $__2 = arguments,\n        $__3 = function(i) {\n          var mod = $__2[i];\n          var names = getOwnPropertyNames(mod);\n          var $__5 = function(j) {\n            var name = names[j];\n            if (name === '__esModule' || name === 'default') {\n              return 0;\n            }\n            defineProperty(object, name, {\n              get: function() {\n                return mod[name];\n              },\n              enumerable: true\n            });\n          },\n              $__6;\n          $__4: for (var j = 0; j < names.length; j++) {\n            $__6 = $__5(j);\n            switch ($__6) {\n              case 0:\n                continue $__4;\n            }\n          }\n        };\n    for (var i = 1; i < arguments.length; i++) {\n      $__3(i);\n    }\n    return object;\n  }\n  return {get default() {\n      return exportStar;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/exportStar.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/exportStar.js\";\n  var exportStar = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/exportStar.js\", \"traceur@0.0.111/src/runtime/exportStar.js\")).default;\n  $traceurRuntime.exportStar = exportStar;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/private-symbol.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/private-symbol.js\";\n  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./new-unique-string.js\", \"traceur@0.0.111/src/runtime/private-symbol.js\")).default;\n  var $Symbol = typeof Symbol === 'function' ? Symbol : undefined;\n  var $getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  var $create = Object.create;\n  var privateNames = $create(null);\n  function isPrivateSymbol(s) {\n    return privateNames[s];\n  }\n  ;\n  function createPrivateSymbol() {\n    var s = ($Symbol || newUniqueString)();\n    privateNames[s] = true;\n    return s;\n  }\n  ;\n  function hasPrivate(obj, sym) {\n    return hasOwnProperty.call(obj, sym);\n  }\n  ;\n  function deletePrivate(obj, sym) {\n    if (!hasPrivate(obj, sym)) {\n      return false;\n    }\n    delete obj[sym];\n    return true;\n  }\n  ;\n  function setPrivate(obj, sym, val) {\n    obj[sym] = val;\n  }\n  ;\n  function getPrivate(obj, sym) {\n    var val = obj[sym];\n    if (val === undefined)\n      return undefined;\n    return hasOwnProperty.call(obj, sym) ? val : undefined;\n  }\n  ;\n  function init() {\n    if ($getOwnPropertySymbols) {\n      Object.getOwnPropertySymbols = function getOwnPropertySymbols(object) {\n        var rv = [];\n        var symbols = $getOwnPropertySymbols(object);\n        for (var i = 0; i < symbols.length; i++) {\n          var symbol = symbols[i];\n          if (!isPrivateSymbol(symbol)) {\n            rv.push(symbol);\n          }\n        }\n        return rv;\n      };\n    }\n  }\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    },\n    get init() {\n      return init;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/private-weak-map.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/private-weak-map.js\";\n  var $WeakMap = typeof WeakMap === 'function' ? WeakMap : undefined;\n  function isPrivateSymbol(s) {\n    return false;\n  }\n  function createPrivateSymbol() {\n    return new $WeakMap();\n  }\n  function hasPrivate(obj, sym) {\n    return sym.has(obj);\n  }\n  function deletePrivate(obj, sym) {\n    return sym.delete(obj);\n  }\n  function setPrivate(obj, sym, val) {\n    sym.set(obj, val);\n  }\n  function getPrivate(obj, sym) {\n    return sym.get(obj);\n  }\n  function init() {}\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    },\n    get init() {\n      return init;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/private.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/private.js\";\n  var sym = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./private-symbol.js\", \"traceur@0.0.111/src/runtime/private.js\"));\n  var weak = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./private-weak-map.js\", \"traceur@0.0.111/src/runtime/private.js\"));\n  var hasWeakMap = typeof WeakMap === 'function';\n  var m = hasWeakMap ? weak : sym;\n  var isPrivateSymbol = m.isPrivateSymbol;\n  var createPrivateSymbol = m.createPrivateSymbol;\n  var hasPrivate = m.hasPrivate;\n  var deletePrivate = m.deletePrivate;\n  var setPrivate = m.setPrivate;\n  var getPrivate = m.getPrivate;\n  m.init();\n  return {\n    get isPrivateSymbol() {\n      return isPrivateSymbol;\n    },\n    get createPrivateSymbol() {\n      return createPrivateSymbol;\n    },\n    get hasPrivate() {\n      return hasPrivate;\n    },\n    get deletePrivate() {\n      return deletePrivate;\n    },\n    get setPrivate() {\n      return setPrivate;\n    },\n    get getPrivate() {\n      return getPrivate;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/properTailCalls.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/properTailCalls.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/modules/properTailCalls.js\")),\n      getPrivate = $__0.getPrivate,\n      setPrivate = $__0.setPrivate,\n      createPrivateSymbol = $__0.createPrivateSymbol;\n  var $apply = Function.prototype.call.bind(Function.prototype.apply);\n  var CONTINUATION_TYPE = Object.create(null);\n  var isTailRecursiveName = null;\n  function createContinuation(operand, thisArg, argsArray) {\n    return [CONTINUATION_TYPE, operand, thisArg, argsArray];\n  }\n  function isContinuation(object) {\n    return object && object[0] === CONTINUATION_TYPE;\n  }\n  function $bind(operand, thisArg, args) {\n    var argArray = [thisArg];\n    for (var i = 0; i < args.length; i++) {\n      argArray[i + 1] = args[i];\n    }\n    var func = $apply(Function.prototype.bind, operand, argArray);\n    return func;\n  }\n  function $construct(func, argArray) {\n    var object = new ($bind(func, null, argArray));\n    return object;\n  }\n  function isTailRecursive(func) {\n    return !!getPrivate(func, isTailRecursiveName);\n  }\n  function tailCall(func, thisArg, argArray) {\n    var continuation = argArray[0];\n    if (isContinuation(continuation)) {\n      continuation = $apply(func, thisArg, continuation[3]);\n      return continuation;\n    }\n    continuation = createContinuation(func, thisArg, argArray);\n    while (true) {\n      if (isTailRecursive(func)) {\n        continuation = $apply(func, continuation[2], [continuation]);\n      } else {\n        continuation = $apply(func, continuation[2], continuation[3]);\n      }\n      if (!isContinuation(continuation)) {\n        return continuation;\n      }\n      func = continuation[1];\n    }\n  }\n  function construct() {\n    var object;\n    if (isTailRecursive(this)) {\n      object = $construct(this, [createContinuation(null, null, arguments)]);\n    } else {\n      object = $construct(this, arguments);\n    }\n    return object;\n  }\n  function setupProperTailCalls() {\n    isTailRecursiveName = createPrivateSymbol();\n    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {\n      var result = tailCall(function(thisArg) {\n        var argArray = [];\n        for (var i = 1; i < arguments.length; ++i) {\n          argArray[i - 1] = arguments[i];\n        }\n        var continuation = createContinuation(this, thisArg, argArray);\n        return continuation;\n      }, this, arguments);\n      return result;\n    });\n    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {\n      var result = tailCall(function(thisArg, argArray) {\n        var continuation = createContinuation(this, thisArg, argArray);\n        return continuation;\n      }, this, arguments);\n      return result;\n    });\n  }\n  function initTailRecursiveFunction(func) {\n    if (isTailRecursiveName === null) {\n      setupProperTailCalls();\n    }\n    setPrivate(func, isTailRecursiveName, true);\n    return func;\n  }\n  return {\n    get createContinuation() {\n      return createContinuation;\n    },\n    get tailCall() {\n      return tailCall;\n    },\n    get construct() {\n      return construct;\n    },\n    get initTailRecursiveFunction() {\n      return initTailRecursiveFunction;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./properTailCalls.js\", \"traceur@0.0.111/src/runtime/modules/initTailRecursiveFunction.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.initTailRecursiveFunction;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/call.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/call.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./properTailCalls.js\", \"traceur@0.0.111/src/runtime/modules/call.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.tailCall;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/continuation.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/continuation.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./properTailCalls.js\", \"traceur@0.0.111/src/runtime/modules/continuation.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.createContinuation;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/construct.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/construct.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./properTailCalls.js\", \"traceur@0.0.111/src/runtime/modules/construct.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.construct;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/properTailCalls.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/properTailCalls.js\";\n  var initTailRecursiveFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/initTailRecursiveFunction.js\", \"traceur@0.0.111/src/runtime/properTailCalls.js\")).default;\n  var call = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/call.js\", \"traceur@0.0.111/src/runtime/properTailCalls.js\")).default;\n  var continuation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/continuation.js\", \"traceur@0.0.111/src/runtime/properTailCalls.js\")).default;\n  var construct = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/construct.js\", \"traceur@0.0.111/src/runtime/properTailCalls.js\")).default;\n  $traceurRuntime.initTailRecursiveFunction = initTailRecursiveFunction;\n  $traceurRuntime.call = call;\n  $traceurRuntime.continuation = continuation;\n  $traceurRuntime.construct = construct;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/relativeRequire.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/relativeRequire.js\";\n  var path;\n  function relativeRequire(callerPath, requiredPath) {\n    path = path || typeof require !== 'undefined' && require('path');\n    function isDirectory(path) {\n      return path.slice(-1) === '/';\n    }\n    function isAbsolute(path) {\n      return path[0] === '/';\n    }\n    function isRelative(path) {\n      return path[0] === '.';\n    }\n    if (isDirectory(requiredPath) || isAbsolute(requiredPath))\n      return;\n    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);\n  }\n  $traceurRuntime.require = relativeRequire;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/checkObjectCoercible.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/checkObjectCoercible.js\";\n  var $TypeError = TypeError;\n  function checkObjectCoercible(v) {\n    if (v === null || v === undefined) {\n      throw new $TypeError('Value cannot be converted to an Object');\n    }\n    return v;\n  }\n  return {get default() {\n      return checkObjectCoercible;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/spread.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/spread.js\";\n  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../checkObjectCoercible.js\", \"traceur@0.0.111/src/runtime/modules/spread.js\")).default;\n  function spread() {\n    var rv = [],\n        j = 0,\n        iterResult;\n    for (var i = 0; i < arguments.length; i++) {\n      var valueToSpread = checkObjectCoercible(arguments[i]);\n      if (typeof valueToSpread[Symbol.iterator] !== 'function') {\n        throw new TypeError('Cannot spread non-iterable object.');\n      }\n      var iter = valueToSpread[Symbol.iterator]();\n      while (!(iterResult = iter.next()).done) {\n        rv[j++] = iterResult.value;\n      }\n    }\n    return rv;\n  }\n  return {get default() {\n      return spread;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/spread.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/spread.js\";\n  var spread = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/spread.js\", \"traceur@0.0.111/src/runtime/spread.js\")).default;\n  $traceurRuntime.spread = spread;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/iteratorToArray.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/iteratorToArray.js\";\n  function iteratorToArray(iter) {\n    var rv = [];\n    var i = 0;\n    var tmp;\n    while (!(tmp = iter.next()).done) {\n      rv[i++] = tmp.value;\n    }\n    return rv;\n  }\n  return {get default() {\n      return iteratorToArray;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/destructuring.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/destructuring.js\";\n  var iteratorToArray = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/iteratorToArray.js\", \"traceur@0.0.111/src/runtime/destructuring.js\")).default;\n  $traceurRuntime.iteratorToArray = iteratorToArray;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/async.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/async.js\";\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/modules/async.js\")),\n      createPrivateSymbol = $__12.createPrivateSymbol,\n      getPrivate = $__12.getPrivate,\n      setPrivate = $__12.setPrivate;\n  var $__11 = Object,\n      create = $__11.create,\n      defineProperty = $__11.defineProperty;\n  var observeName = createPrivateSymbol();\n  function AsyncGeneratorFunction() {}\n  function AsyncGeneratorFunctionPrototype() {}\n  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;\n  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;\n  defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});\n  var AsyncGeneratorContext = function() {\n    function AsyncGeneratorContext(observer) {\n      var $__2 = this;\n      this.decoratedObserver = createDecoratedGenerator(observer, function() {\n        $__2.done = true;\n      });\n      this.done = false;\n      this.inReturn = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {\n      throw: function(error) {\n        if (!this.inReturn) {\n          throw error;\n        }\n      },\n      yield: function(value) {\n        if (this.done) {\n          this.inReturn = true;\n          throw undefined;\n        }\n        var result;\n        try {\n          result = this.decoratedObserver.next(value);\n        } catch (e) {\n          this.done = true;\n          throw e;\n        }\n        if (result === undefined) {\n          return;\n        }\n        if (result.done) {\n          this.done = true;\n          this.inReturn = true;\n          throw undefined;\n        }\n        return result.value;\n      },\n      yieldFor: function(observable) {\n        var ctx = this;\n        return observeForEach(observable[Symbol.observer].bind(observable), function(value) {\n          if (ctx.done) {\n            this.return();\n            return;\n          }\n          var result;\n          try {\n            result = ctx.decoratedObserver.next(value);\n          } catch (e) {\n            ctx.done = true;\n            throw e;\n          }\n          if (result === undefined) {\n            return;\n          }\n          if (result.done) {\n            ctx.done = true;\n          }\n          return result;\n        });\n      }\n    }, {});\n  }();\n  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {\n    var observe = getPrivate(this, observeName);\n    var ctx = new AsyncGeneratorContext(observer);\n    schedule(function() {\n      return observe(ctx);\n    }).then(function(value) {\n      if (!ctx.done) {\n        ctx.decoratedObserver.return(value);\n      }\n    }).catch(function(error) {\n      if (!ctx.done) {\n        ctx.decoratedObserver.throw(error);\n      }\n    });\n    return ctx.decoratedObserver;\n  };\n  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});\n  function initAsyncGeneratorFunction(functionObject) {\n    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);\n    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;\n    return functionObject;\n  }\n  function createAsyncGeneratorInstance(observe, functionObject) {\n    for (var args = [],\n        $__10 = 2; $__10 < arguments.length; $__10++)\n      args[$__10 - 2] = arguments[$__10];\n    var object = create(functionObject.prototype);\n    setPrivate(object, observeName, observe);\n    return object;\n  }\n  function observeForEach(observe, next) {\n    return new Promise(function(resolve, reject) {\n      var generator = observe({\n        next: function(value) {\n          return next.call(generator, value);\n        },\n        throw: function(error) {\n          reject(error);\n        },\n        return: function(value) {\n          resolve(value);\n        }\n      });\n    });\n  }\n  function schedule(asyncF) {\n    return Promise.resolve().then(asyncF);\n  }\n  var generator = Symbol();\n  var onDone = Symbol();\n  var DecoratedGenerator = function() {\n    function DecoratedGenerator(_generator, _onDone) {\n      this[generator] = _generator;\n      this[onDone] = _onDone;\n    }\n    return ($traceurRuntime.createClass)(DecoratedGenerator, {\n      next: function(value) {\n        var result = this[generator].next(value);\n        if (result !== undefined && result.done) {\n          this[onDone].call(this);\n        }\n        return result;\n      },\n      throw: function(error) {\n        this[onDone].call(this);\n        return this[generator].throw(error);\n      },\n      return: function(value) {\n        this[onDone].call(this);\n        return this[generator].return(value);\n      }\n    }, {});\n  }();\n  function createDecoratedGenerator(generator, onDone) {\n    return new DecoratedGenerator(generator, onDone);\n  }\n  Array.prototype[Symbol.observer] = function(observer) {\n    var done = false;\n    var decoratedObserver = createDecoratedGenerator(observer, function() {\n      return done = true;\n    });\n    var $__6 = true;\n    var $__7 = false;\n    var $__8 = undefined;\n    try {\n      for (var $__4 = void 0,\n          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n        var value = $__4.value;\n        {\n          decoratedObserver.next(value);\n          if (done) {\n            return;\n          }\n        }\n      }\n    } catch ($__9) {\n      $__7 = true;\n      $__8 = $__9;\n    } finally {\n      try {\n        if (!$__6 && $__3.return != null) {\n          $__3.return();\n        }\n      } finally {\n        if ($__7) {\n          throw $__8;\n        }\n      }\n    }\n    decoratedObserver.return();\n    return decoratedObserver;\n  };\n  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});\n  return {\n    get initAsyncGeneratorFunction() {\n      return initAsyncGeneratorFunction;\n    },\n    get createAsyncGeneratorInstance() {\n      return createAsyncGeneratorInstance;\n    },\n    get observeForEach() {\n      return observeForEach;\n    },\n    get schedule() {\n      return schedule;\n    },\n    get createDecoratedGenerator() {\n      return createDecoratedGenerator;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.initAsyncGeneratorFunction;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createAsyncGeneratorInstance;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/observeForEach.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/observeForEach.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/modules/observeForEach.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.observeForEach;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/schedule.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/schedule.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/modules/schedule.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.schedule;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/modules/createDecoratedGenerator.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createDecoratedGenerator;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/async.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/async.js\";\n  var initAsyncGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/initAsyncGeneratorFunction.js\", \"traceur@0.0.111/src/runtime/async.js\")).default;\n  var createAsyncGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/createAsyncGeneratorInstance.js\", \"traceur@0.0.111/src/runtime/async.js\")).default;\n  var observeForEach = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/observeForEach.js\", \"traceur@0.0.111/src/runtime/async.js\")).default;\n  var schedule = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/schedule.js\", \"traceur@0.0.111/src/runtime/async.js\")).default;\n  var createDecoratedGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/createDecoratedGenerator.js\", \"traceur@0.0.111/src/runtime/async.js\")).default;\n  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;\n  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;\n  $traceurRuntime.observeForEach = observeForEach;\n  $traceurRuntime.schedule = schedule;\n  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/generators.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/generators.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/modules/generators.js\")),\n      createPrivateSymbol = $__2.createPrivateSymbol,\n      getPrivate = $__2.getPrivate,\n      setPrivate = $__2.setPrivate;\n  var $TypeError = TypeError;\n  var $__1 = Object,\n      create = $__1.create,\n      defineProperties = $__1.defineProperties,\n      defineProperty = $__1.defineProperty;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var ST_NEWBORN = 0;\n  var ST_EXECUTING = 1;\n  var ST_SUSPENDED = 2;\n  var ST_CLOSED = 3;\n  var END_STATE = -2;\n  var RETHROW_STATE = -3;\n  function getInternalError(state) {\n    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);\n  }\n  var RETURN_SENTINEL = {};\n  function GeneratorContext() {\n    this.state = 0;\n    this.GState = ST_NEWBORN;\n    this.storedException = undefined;\n    this.finallyFallThrough = undefined;\n    this.sent_ = undefined;\n    this.returnValue = undefined;\n    this.oldReturnValue = undefined;\n    this.tryStack_ = [];\n  }\n  GeneratorContext.prototype = {\n    pushTry: function(catchState, finallyState) {\n      if (finallyState !== null) {\n        var finallyFallThrough = null;\n        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n          if (this.tryStack_[i].catch !== undefined) {\n            finallyFallThrough = this.tryStack_[i].catch;\n            break;\n          }\n        }\n        if (finallyFallThrough === null)\n          finallyFallThrough = RETHROW_STATE;\n        this.tryStack_.push({\n          finally: finallyState,\n          finallyFallThrough: finallyFallThrough\n        });\n      }\n      if (catchState !== null) {\n        this.tryStack_.push({catch: catchState});\n      }\n    },\n    popTry: function() {\n      this.tryStack_.pop();\n    },\n    maybeUncatchable: function() {\n      if (this.storedException === RETURN_SENTINEL) {\n        throw RETURN_SENTINEL;\n      }\n    },\n    get sent() {\n      this.maybeThrow();\n      return this.sent_;\n    },\n    set sent(v) {\n      this.sent_ = v;\n    },\n    get sentIgnoreThrow() {\n      return this.sent_;\n    },\n    maybeThrow: function() {\n      if (this.action === 'throw') {\n        this.action = 'next';\n        throw this.sent_;\n      }\n    },\n    end: function() {\n      switch (this.state) {\n        case END_STATE:\n          return this;\n        case RETHROW_STATE:\n          throw this.storedException;\n        default:\n          throw getInternalError(this.state);\n      }\n    },\n    handleException: function(ex) {\n      this.GState = ST_CLOSED;\n      this.state = END_STATE;\n      throw ex;\n    },\n    wrapYieldStar: function(iterator) {\n      var ctx = this;\n      return {\n        next: function(v) {\n          return iterator.next(v);\n        },\n        throw: function(e) {\n          var result;\n          if (e === RETURN_SENTINEL) {\n            if (iterator.return) {\n              result = iterator.return(ctx.returnValue);\n              if (!result.done) {\n                ctx.returnValue = ctx.oldReturnValue;\n                return result;\n              }\n              ctx.returnValue = result.value;\n            }\n            throw e;\n          }\n          if (iterator.throw) {\n            return iterator.throw(e);\n          }\n          iterator.return && iterator.return();\n          throw $TypeError('Inner iterator does not have a throw method');\n        }\n      };\n    }\n  };\n  function nextOrThrow(ctx, moveNext, action, x) {\n    switch (ctx.GState) {\n      case ST_EXECUTING:\n        throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n      case ST_CLOSED:\n        if (action == 'next') {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n        if (x === RETURN_SENTINEL) {\n          return {\n            value: ctx.returnValue,\n            done: true\n          };\n        }\n        throw x;\n      case ST_NEWBORN:\n        if (action === 'throw') {\n          ctx.GState = ST_CLOSED;\n          if (x === RETURN_SENTINEL) {\n            return {\n              value: ctx.returnValue,\n              done: true\n            };\n          }\n          throw x;\n        }\n        if (x !== undefined)\n          throw $TypeError('Sent value to newborn generator');\n      case ST_SUSPENDED:\n        ctx.GState = ST_EXECUTING;\n        ctx.action = action;\n        ctx.sent = x;\n        var value;\n        try {\n          value = moveNext(ctx);\n        } catch (ex) {\n          if (ex === RETURN_SENTINEL) {\n            value = ctx;\n          } else {\n            throw ex;\n          }\n        }\n        var done = value === ctx;\n        if (done)\n          value = ctx.returnValue;\n        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n        return {\n          value: value,\n          done: done\n        };\n    }\n  }\n  var ctxName = createPrivateSymbol();\n  var moveNextName = createPrivateSymbol();\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));\n  GeneratorFunctionPrototype.prototype = {\n    constructor: GeneratorFunctionPrototype,\n    next: function(v) {\n      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'next', v);\n    },\n    throw: function(v) {\n      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'throw', v);\n    },\n    return: function(v) {\n      var ctx = getPrivate(this, ctxName);\n      ctx.oldReturnValue = ctx.returnValue;\n      ctx.returnValue = v;\n      return nextOrThrow(ctx, getPrivate(this, moveNextName), 'throw', RETURN_SENTINEL);\n    }\n  };\n  defineProperties(GeneratorFunctionPrototype.prototype, {\n    constructor: {enumerable: false},\n    next: {enumerable: false},\n    throw: {enumerable: false},\n    return: {enumerable: false}\n  });\n  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {\n    return this;\n  }));\n  function createGeneratorInstance(innerFunction, functionObject, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new GeneratorContext();\n    var object = create(functionObject.prototype);\n    setPrivate(object, ctxName, ctx);\n    setPrivate(object, moveNextName, moveNext);\n    return object;\n  }\n  function initGeneratorFunction(functionObject) {\n    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);\n    functionObject.__proto__ = GeneratorFunctionPrototype;\n    return functionObject;\n  }\n  function AsyncFunctionContext() {\n    GeneratorContext.call(this);\n    this.err = undefined;\n    var ctx = this;\n    ctx.result = new Promise(function(resolve, reject) {\n      ctx.resolve = resolve;\n      ctx.reject = reject;\n    });\n  }\n  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);\n  AsyncFunctionContext.prototype.end = function() {\n    switch (this.state) {\n      case END_STATE:\n        this.resolve(this.returnValue);\n        break;\n      case RETHROW_STATE:\n        this.reject(this.storedException);\n        break;\n      default:\n        this.reject(getInternalError(this.state));\n    }\n  };\n  AsyncFunctionContext.prototype.handleException = function() {\n    this.state = RETHROW_STATE;\n  };\n  function asyncWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new AsyncFunctionContext();\n    ctx.createCallback = function(newState) {\n      return function(value) {\n        ctx.state = newState;\n        ctx.value = value;\n        moveNext(ctx);\n      };\n    };\n    ctx.errback = function(err) {\n      handleCatch(ctx, err);\n      moveNext(ctx);\n    };\n    moveNext(ctx);\n    return ctx.result;\n  }\n  function getMoveNext(innerFunction, self) {\n    return function(ctx) {\n      while (true) {\n        try {\n          return innerFunction.call(self, ctx);\n        } catch (ex) {\n          handleCatch(ctx, ex);\n        }\n      }\n    };\n  }\n  function handleCatch(ctx, ex) {\n    ctx.storedException = ex;\n    var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n    if (!last) {\n      ctx.handleException(ex);\n      return;\n    }\n    ctx.state = last.catch !== undefined ? last.catch : last.finally;\n    if (last.finallyFallThrough !== undefined)\n      ctx.finallyFallThrough = last.finallyFallThrough;\n  }\n  return {\n    get createGeneratorInstance() {\n      return createGeneratorInstance;\n    },\n    get initGeneratorFunction() {\n      return initGeneratorFunction;\n    },\n    get asyncWrap() {\n      return asyncWrap;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/asyncWrap.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/asyncWrap.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generators.js\", \"traceur@0.0.111/src/runtime/modules/asyncWrap.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.asyncWrap;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generators.js\", \"traceur@0.0.111/src/runtime/modules/initGeneratorFunction.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.initGeneratorFunction;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generators.js\", \"traceur@0.0.111/src/runtime/modules/createGeneratorInstance.js\"));\n  return {get default() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.createGeneratorInstance;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/generators.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/generators.js\";\n  var asyncWrap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/asyncWrap.js\", \"traceur@0.0.111/src/runtime/generators.js\")).default;\n  var initGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/initGeneratorFunction.js\", \"traceur@0.0.111/src/runtime/generators.js\")).default;\n  var createGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/createGeneratorInstance.js\", \"traceur@0.0.111/src/runtime/generators.js\")).default;\n  $traceurRuntime.asyncWrap = asyncWrap;\n  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;\n  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/spawn.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/spawn.js\";\n  function spawn(self, args, gen) {\n    return new Promise(function(resolve, reject) {\n      function fulfill(v) {\n        try {\n          step(gen.next(v));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(v) {\n        try {\n          step(gen.throw(v));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(res) {\n        if (res.done) {\n          resolve(res.value);\n        } else {\n          Promise.resolve(res.value).then(fulfill, rejected);\n        }\n      }\n      step((gen = gen.apply(self, args)).next());\n    });\n  }\n  return {get default() {\n      return spawn;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/spawn.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/spawn.js\";\n  var spawn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/spawn.js\", \"traceur@0.0.111/src/runtime/spawn.js\")).default;\n  $traceurRuntime.spawn = spawn;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/getTemplateObject.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/getTemplateObject.js\";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      freeze = $__1.freeze;\n  var slice = Array.prototype.slice;\n  var map = Object.create(null);\n  function getTemplateObject(raw) {\n    var cooked = arguments[1];\n    var key = raw.join('${}');\n    var templateObject = map[key];\n    if (templateObject)\n      return templateObject;\n    if (!cooked) {\n      cooked = slice.call(raw);\n    }\n    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));\n  }\n  return {get default() {\n      return getTemplateObject;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/template.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/template.js\";\n  var getTemplateObject = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/getTemplateObject.js\", \"traceur@0.0.111/src/runtime/template.js\")).default;\n  $traceurRuntime.getTemplateObject = getTemplateObject;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/modules/spreadProperties.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/modules/spreadProperties.js\";\n  var $__1 = Object,\n      defineProperty = $__1.defineProperty,\n      getOwnPropertyNames = $__1.getOwnPropertyNames,\n      getOwnPropertySymbols = $__1.getOwnPropertySymbols,\n      propertyIsEnumerable = $__1.propertyIsEnumerable;\n  function createDataProperty(o, p, v) {\n    defineProperty(o, p, {\n      configurable: true,\n      enumerable: true,\n      value: v,\n      writable: true\n    });\n  }\n  function copyDataProperties(target, source) {\n    if (source == null) {\n      return;\n    }\n    var copy = function(keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var nextKey = keys[i];\n        if (propertyIsEnumerable.call(source, nextKey)) {\n          var propValue = source[nextKey];\n          createDataProperty(target, nextKey, propValue);\n        }\n      }\n    };\n    copy(getOwnPropertyNames(source));\n    copy(getOwnPropertySymbols(source));\n  }\n  var $__default = function() {\n    var target = arguments[0];\n    for (var i = 1; i < arguments.length; i++) {\n      copyDataProperties(target, arguments[i]);\n    }\n    return target;\n  };\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/jsx.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/jsx.js\";\n  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./modules/spreadProperties.js\", \"traceur@0.0.111/src/runtime/jsx.js\")).default;\n  $traceurRuntime.spreadProperties = spreadProperties;\n  return {};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/runtime-modules.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/runtime-modules.js\";\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./symbols.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./classes.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./exportStar.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./properTailCalls.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./relativeRequire.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./spread.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./destructuring.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./async.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generators.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./spawn.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./template.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./jsx.js\", \"traceur@0.0.111/src/runtime/runtime-modules.js\"));\n  return {};\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/runtime-modules.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/frozen-data.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/frozen-data.js\";\n  function findIndex(arr, key) {\n    for (var i = 0; i < arr.length; i += 2) {\n      if (arr[i] === key) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function setFrozen(arr, key, val) {\n    var i = findIndex(arr, key);\n    if (i === -1) {\n      arr.push(key, val);\n    }\n  }\n  function getFrozen(arr, key) {\n    var i = findIndex(arr, key);\n    if (i !== -1) {\n      return arr[i + 1];\n    }\n    return undefined;\n  }\n  function hasFrozen(arr, key) {\n    return findIndex(arr, key) !== -1;\n  }\n  function deleteFrozen(arr, key) {\n    var i = findIndex(arr, key);\n    if (i !== -1) {\n      arr.splice(i, 2);\n      return true;\n    }\n    return false;\n  }\n  return {\n    get setFrozen() {\n      return setFrozen;\n    },\n    get getFrozen() {\n      return getFrozen;\n    },\n    get hasFrozen() {\n      return hasFrozen;\n    },\n    get deleteFrozen() {\n      return deleteFrozen;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/utils.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/utils.js\";\n  var $ceil = Math.ceil;\n  var $floor = Math.floor;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $pow = Math.pow;\n  var $min = Math.min;\n  var $TypeError = TypeError;\n  var $Object = Object;\n  function toObject(x) {\n    if (x == null) {\n      throw $TypeError();\n    }\n    return $Object(x);\n  }\n  function toUint32(x) {\n    return x >>> 0;\n  }\n  function isObject(x) {\n    return x && (typeof x === 'object' || typeof x === 'function');\n  }\n  function isCallable(x) {\n    return typeof x === 'function';\n  }\n  function isNumber(x) {\n    return typeof x === 'number';\n  }\n  function toInteger(x) {\n    x = +x;\n    if ($isNaN(x))\n      return 0;\n    if (x === 0 || !$isFinite(x))\n      return x;\n    return x > 0 ? $floor(x) : $ceil(x);\n  }\n  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;\n  function toLength(x) {\n    var len = toInteger(x);\n    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);\n  }\n  function checkIterable(x) {\n    return !isObject(x) ? undefined : x[Symbol.iterator];\n  }\n  function isConstructor(x) {\n    return isCallable(x);\n  }\n  function createIteratorResultObject(value, done) {\n    return {\n      value: value,\n      done: done\n    };\n  }\n  function maybeDefine(object, name, descr) {\n    if (!(name in object)) {\n      Object.defineProperty(object, name, descr);\n    }\n  }\n  function maybeDefineMethod(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  function maybeDefineConst(object, name, value) {\n    maybeDefine(object, name, {\n      value: value,\n      configurable: false,\n      enumerable: false,\n      writable: false\n    });\n  }\n  function maybeAddFunctions(object, functions) {\n    for (var i = 0; i < functions.length; i += 2) {\n      var name = functions[i];\n      var value = functions[i + 1];\n      maybeDefineMethod(object, name, value);\n    }\n  }\n  function maybeAddConsts(object, consts) {\n    for (var i = 0; i < consts.length; i += 2) {\n      var name = consts[i];\n      var value = consts[i + 1];\n      maybeDefineConst(object, name, value);\n    }\n  }\n  function maybeAddIterator(object, func, Symbol) {\n    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])\n      return;\n    if (object['@@iterator'])\n      func = object['@@iterator'];\n    Object.defineProperty(object, Symbol.iterator, {\n      value: func,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  var polyfills = [];\n  function registerPolyfill(func) {\n    polyfills.push(func);\n  }\n  function polyfillAll(global) {\n    polyfills.forEach(function(f) {\n      return f(global);\n    });\n  }\n  return {\n    get toObject() {\n      return toObject;\n    },\n    get toUint32() {\n      return toUint32;\n    },\n    get isObject() {\n      return isObject;\n    },\n    get isCallable() {\n      return isCallable;\n    },\n    get isNumber() {\n      return isNumber;\n    },\n    get toInteger() {\n      return toInteger;\n    },\n    get toLength() {\n      return toLength;\n    },\n    get checkIterable() {\n      return checkIterable;\n    },\n    get isConstructor() {\n      return isConstructor;\n    },\n    get createIteratorResultObject() {\n      return createIteratorResultObject;\n    },\n    get maybeDefine() {\n      return maybeDefine;\n    },\n    get maybeDefineMethod() {\n      return maybeDefineMethod;\n    },\n    get maybeDefineConst() {\n      return maybeDefineConst;\n    },\n    get maybeAddFunctions() {\n      return maybeAddFunctions;\n    },\n    get maybeAddConsts() {\n      return maybeAddConsts;\n    },\n    get maybeAddIterator() {\n      return maybeAddIterator;\n    },\n    get registerPolyfill() {\n      return registerPolyfill;\n    },\n    get polyfillAll() {\n      return polyfillAll;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Map.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Map.js\";\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/polyfills/Map.js\")),\n      createPrivateSymbol = $__16.createPrivateSymbol,\n      getPrivate = $__16.getPrivate,\n      setPrivate = $__16.setPrivate;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../frozen-data.js\", \"traceur@0.0.111/src/runtime/polyfills/Map.js\")),\n      deleteFrozen = $__17.deleteFrozen,\n      getFrozen = $__17.getFrozen,\n      setFrozen = $__17.setFrozen;\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Map.js\")),\n      isObject = $__18.isObject,\n      registerPolyfill = $__18.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../has-native-symbols.js\", \"traceur@0.0.111/src/runtime/polyfills/Map.js\")).default;\n  var $__9 = Object,\n      defineProperty = $__9.defineProperty,\n      getOwnPropertyDescriptor = $__9.getOwnPropertyDescriptor,\n      hasOwnProperty = $__9.hasOwnProperty,\n      isExtensible = $__9.isExtensible;\n  var deletedSentinel = {};\n  var counter = 1;\n  var hashCodeName = createPrivateSymbol();\n  function getHashCodeForObject(obj) {\n    return getPrivate(obj, hashCodeName);\n  }\n  function getOrSetHashCodeForObject(obj) {\n    var hash = getHashCodeForObject(obj);\n    if (!hash) {\n      hash = counter++;\n      setPrivate(obj, hashCodeName, hash);\n    }\n    return hash;\n  }\n  function lookupIndex(map, key) {\n    if (typeof key === 'string') {\n      return map.stringIndex_[key];\n    }\n    if (isObject(key)) {\n      if (!isExtensible(key)) {\n        return getFrozen(map.frozenData_, key);\n      }\n      var hc = getHashCodeForObject(key);\n      if (hc === undefined) {\n        return undefined;\n      }\n      return map.objectIndex_[hc];\n    }\n    return map.primitiveIndex_[key];\n  }\n  function initMap(map) {\n    map.entries_ = [];\n    map.objectIndex_ = Object.create(null);\n    map.stringIndex_ = Object.create(null);\n    map.primitiveIndex_ = Object.create(null);\n    map.frozenData_ = [];\n    map.deletedCount_ = 0;\n  }\n  var Map = function() {\n    function Map() {\n      var $__11,\n          $__12;\n      var iterable = arguments[0];\n      if (!isObject(this))\n        throw new TypeError('Map called on incompatible type');\n      if (hasOwnProperty.call(this, 'entries_')) {\n        throw new TypeError('Map can not be reentrantly initialised');\n      }\n      initMap(this);\n      if (iterable !== null && iterable !== undefined) {\n        var $__5 = true;\n        var $__6 = false;\n        var $__7 = undefined;\n        try {\n          for (var $__3 = void 0,\n              $__2 = (iterable)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {\n            var $__10 = $__3.value,\n                key = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),\n                value = ($__12 = $__11.next()).done ? void 0 : $__12.value;\n            {\n              this.set(key, value);\n            }\n          }\n        } catch ($__8) {\n          $__6 = true;\n          $__7 = $__8;\n        } finally {\n          try {\n            if (!$__5 && $__2.return != null) {\n              $__2.return();\n            }\n          } finally {\n            if ($__6) {\n              throw $__7;\n            }\n          }\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(Map, {\n      get size() {\n        return this.entries_.length / 2 - this.deletedCount_;\n      },\n      get: function(key) {\n        var index = lookupIndex(this, key);\n        if (index !== undefined) {\n          return this.entries_[index + 1];\n        }\n      },\n      set: function(key, value) {\n        var index = lookupIndex(this, key);\n        if (index !== undefined) {\n          this.entries_[index + 1] = value;\n        } else {\n          index = this.entries_.length;\n          this.entries_[index] = key;\n          this.entries_[index + 1] = value;\n          if (isObject(key)) {\n            if (!isExtensible(key)) {\n              setFrozen(this.frozenData_, key, index);\n            } else {\n              var hash = getOrSetHashCodeForObject(key);\n              this.objectIndex_[hash] = index;\n            }\n          } else if (typeof key === 'string') {\n            this.stringIndex_[key] = index;\n          } else {\n            this.primitiveIndex_[key] = index;\n          }\n        }\n        return this;\n      },\n      has: function(key) {\n        return lookupIndex(this, key) !== undefined;\n      },\n      delete: function(key) {\n        var index = lookupIndex(this, key);\n        if (index === undefined) {\n          return false;\n        }\n        this.entries_[index] = deletedSentinel;\n        this.entries_[index + 1] = undefined;\n        this.deletedCount_++;\n        if (isObject(key)) {\n          if (!isExtensible(key)) {\n            deleteFrozen(this.frozenData_, key);\n          } else {\n            var hash = getHashCodeForObject(key);\n            delete this.objectIndex_[hash];\n          }\n        } else if (typeof key === 'string') {\n          delete this.stringIndex_[key];\n        } else {\n          delete this.primitiveIndex_[key];\n        }\n        return true;\n      },\n      clear: function() {\n        initMap(this);\n      },\n      forEach: function(callbackFn) {\n        var thisArg = arguments[1];\n        for (var i = 0; i < this.entries_.length; i += 2) {\n          var key = this.entries_[i];\n          var value = this.entries_[i + 1];\n          if (key === deletedSentinel)\n            continue;\n          callbackFn.call(thisArg, value, key, this);\n        }\n      },\n      entries: $traceurRuntime.initGeneratorFunction(function $__13() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return [key, value];\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__13, this);\n      }),\n      keys: $traceurRuntime.initGeneratorFunction(function $__14() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return key;\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__14, this);\n      }),\n      values: $traceurRuntime.initGeneratorFunction(function $__15() {\n        var i,\n            key,\n            value;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                i = 0;\n                $ctx.state = 12;\n                break;\n              case 12:\n                $ctx.state = (i < this.entries_.length) ? 8 : -2;\n                break;\n              case 4:\n                i += 2;\n                $ctx.state = 12;\n                break;\n              case 8:\n                key = this.entries_[i];\n                value = this.entries_[i + 1];\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = (key === deletedSentinel) ? 4 : 6;\n                break;\n              case 6:\n                $ctx.state = 2;\n                return value;\n              case 2:\n                $ctx.maybeThrow();\n                $ctx.state = 4;\n                break;\n              default:\n                return $ctx.end();\n            }\n        }, $__15, this);\n      })\n    }, {});\n  }();\n  defineProperty(Map.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Map.prototype.entries\n  });\n  function needsPolyfill(global) {\n    var $__10 = global,\n        Map = $__10.Map,\n        Symbol = $__10.Symbol;\n    if (!Map || !hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {\n      return true;\n    }\n    try {\n      return new Map([[]]).size !== 1;\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillMap(global) {\n    if (needsPolyfill(global)) {\n      global.Map = Map;\n    }\n  }\n  registerPolyfill(polyfillMap);\n  return {\n    get Map() {\n      return Map;\n    },\n    get polyfillMap() {\n      return polyfillMap;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Map.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Set.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Set.js\";\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Set.js\")),\n      isObject = $__18.isObject,\n      registerPolyfill = $__18.registerPolyfill;\n  var Map = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Map.js\", \"traceur@0.0.111/src/runtime/polyfills/Set.js\")).Map;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../has-native-symbols.js\", \"traceur@0.0.111/src/runtime/polyfills/Set.js\")).default;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var Set = function() {\n    function Set() {\n      var iterable = arguments[0];\n      if (!isObject(this))\n        throw new TypeError('Set called on incompatible type');\n      if (hasOwnProperty.call(this, 'map_')) {\n        throw new TypeError('Set can not be reentrantly initialised');\n      }\n      this.map_ = new Map();\n      if (iterable !== null && iterable !== undefined) {\n        var $__6 = true;\n        var $__7 = false;\n        var $__8 = undefined;\n        try {\n          for (var $__4 = void 0,\n              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n            var item = $__4.value;\n            {\n              this.add(item);\n            }\n          }\n        } catch ($__9) {\n          $__7 = true;\n          $__8 = $__9;\n        } finally {\n          try {\n            if (!$__6 && $__3.return != null) {\n              $__3.return();\n            }\n          } finally {\n            if ($__7) {\n              throw $__8;\n            }\n          }\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(Set, {\n      get size() {\n        return this.map_.size;\n      },\n      has: function(key) {\n        return this.map_.has(key);\n      },\n      add: function(key) {\n        this.map_.set(key, key);\n        return this;\n      },\n      delete: function(key) {\n        return this.map_.delete(key);\n      },\n      clear: function() {\n        return this.map_.clear();\n      },\n      forEach: function(callbackFn) {\n        var thisArg = arguments[1];\n        var $__2 = this;\n        return this.map_.forEach(function(value, key) {\n          callbackFn.call(thisArg, key, key, $__2);\n        });\n      },\n      values: $traceurRuntime.initGeneratorFunction(function $__12() {\n        var $__13,\n            $__14;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                $__13 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());\n                $ctx.sent = void 0;\n                $ctx.action = 'next';\n                $ctx.state = 12;\n                break;\n              case 12:\n                $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = ($__14.done) ? 3 : 2;\n                break;\n              case 3:\n                $ctx.sent = $__14.value;\n                $ctx.state = -2;\n                break;\n              case 2:\n                $ctx.state = 12;\n                return $__14.value;\n              default:\n                return $ctx.end();\n            }\n        }, $__12, this);\n      }),\n      entries: $traceurRuntime.initGeneratorFunction(function $__15() {\n        var $__16,\n            $__17;\n        return $traceurRuntime.createGeneratorInstance(function($ctx) {\n          while (true)\n            switch ($ctx.state) {\n              case 0:\n                $__16 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());\n                $ctx.sent = void 0;\n                $ctx.action = 'next';\n                $ctx.state = 12;\n                break;\n              case 12:\n                $__17 = $__16[$ctx.action]($ctx.sentIgnoreThrow);\n                $ctx.state = 9;\n                break;\n              case 9:\n                $ctx.state = ($__17.done) ? 3 : 2;\n                break;\n              case 3:\n                $ctx.sent = $__17.value;\n                $ctx.state = -2;\n                break;\n              case 2:\n                $ctx.state = 12;\n                return $__17.value;\n              default:\n                return $ctx.end();\n            }\n        }, $__15, this);\n      })\n    }, {});\n  }();\n  Object.defineProperty(Set.prototype, Symbol.iterator, {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  Object.defineProperty(Set.prototype, 'keys', {\n    configurable: true,\n    writable: true,\n    value: Set.prototype.values\n  });\n  function needsPolyfill(global) {\n    var $__11 = global,\n        Set = $__11.Set,\n        Symbol = $__11.Symbol;\n    if (!Set || !hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {\n      return true;\n    }\n    try {\n      return new Set([1]).size !== 1;\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillSet(global) {\n    if (needsPolyfill(global)) {\n      global.Set = Set;\n    }\n  }\n  registerPolyfill(polyfillSet);\n  return {\n    get Set() {\n      return Set;\n    },\n    get polyfillSet() {\n      return polyfillSet;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Set.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/node_modules/rsvp/lib/rsvp/asap.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/node_modules/rsvp/lib/rsvp/asap.js\";\n  var len = 0;\n  var toString = {}.toString;\n  var vertxNext;\n  function asap(callback, arg) {\n    queue[len] = callback;\n    queue[len + 1] = arg;\n    len += 2;\n    if (len === 2) {\n      scheduleFlush();\n    }\n  }\n  var browserWindow = (typeof window !== 'undefined') ? window : undefined;\n  var browserGlobal = browserWindow || {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n  function useNextTick() {\n    var nextTick = process.nextTick;\n    var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n      nextTick = setImmediate;\n    }\n    return function() {\n      nextTick(flush);\n    };\n  }\n  function useVertxTimer() {\n    return function() {\n      vertxNext(flush);\n    };\n  }\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {characterData: true});\n    return function() {\n      node.data = (iterations = ++iterations % 2);\n    };\n  }\n  function useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    return function() {\n      channel.port2.postMessage(0);\n    };\n  }\n  function useSetTimeout() {\n    return function() {\n      setTimeout(flush, 1);\n    };\n  }\n  var queue = new Array(1000);\n  function flush() {\n    for (var i = 0; i < len; i += 2) {\n      var callback = queue[i];\n      var arg = queue[i + 1];\n      callback(arg);\n      queue[i] = undefined;\n      queue[i + 1] = undefined;\n    }\n    len = 0;\n  }\n  function attemptVertex() {\n    try {\n      var r = require;\n      var vertx = r('vertx');\n      vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return useVertxTimer();\n    } catch (e) {\n      return useSetTimeout();\n    }\n  }\n  var scheduleFlush;\n  if (isNode) {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else if (isWorker) {\n    scheduleFlush = useMessageChannel();\n  } else if (browserWindow === undefined && typeof require === 'function') {\n    scheduleFlush = attemptVertex();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n  return {get default() {\n      return asap;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Promise.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Promise.js\";\n  var async = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../../node_modules/rsvp/lib/rsvp/asap.js\", \"traceur@0.0.111/src/runtime/polyfills/Promise.js\")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Promise.js\")),\n      isObject = $__9.isObject,\n      registerPolyfill = $__9.registerPolyfill;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/polyfills/Promise.js\")),\n      createPrivateSymbol = $__10.createPrivateSymbol,\n      getPrivate = $__10.getPrivate,\n      setPrivate = $__10.setPrivate;\n  var promiseRaw = {};\n  function isPromise(x) {\n    return x && typeof x === 'object' && x.status_ !== undefined;\n  }\n  function idResolveHandler(x) {\n    return x;\n  }\n  function idRejectHandler(x) {\n    throw x;\n  }\n  function chain(promise) {\n    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;\n    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;\n    var deferred = getDeferred(promise.constructor);\n    switch (promise.status_) {\n      case undefined:\n        throw TypeError;\n      case 0:\n        promise.onResolve_.push(onResolve, deferred);\n        promise.onReject_.push(onReject, deferred);\n        break;\n      case +1:\n        promiseEnqueue(promise.value_, [onResolve, deferred]);\n        break;\n      case -1:\n        promiseEnqueue(promise.value_, [onReject, deferred]);\n        break;\n    }\n    return deferred.promise;\n  }\n  function getDeferred(C) {\n    if (this === $Promise) {\n      var promise = promiseInit(new $Promise(promiseRaw));\n      return {\n        promise: promise,\n        resolve: function(x) {\n          promiseResolve(promise, x);\n        },\n        reject: function(r) {\n          promiseReject(promise, r);\n        }\n      };\n    } else {\n      var result = {};\n      result.promise = new C(function(resolve, reject) {\n        result.resolve = resolve;\n        result.reject = reject;\n      });\n      return result;\n    }\n  }\n  function promiseSet(promise, status, value, onResolve, onReject) {\n    promise.status_ = status;\n    promise.value_ = value;\n    promise.onResolve_ = onResolve;\n    promise.onReject_ = onReject;\n    return promise;\n  }\n  function promiseInit(promise) {\n    return promiseSet(promise, 0, undefined, [], []);\n  }\n  var Promise = function() {\n    function Promise(resolver) {\n      if (resolver === promiseRaw)\n        return;\n      if (typeof resolver !== 'function')\n        throw new TypeError;\n      var promise = promiseInit(this);\n      try {\n        resolver(function(x) {\n          promiseResolve(promise, x);\n        }, function(r) {\n          promiseReject(promise, r);\n        });\n      } catch (e) {\n        promiseReject(promise, e);\n      }\n    }\n    return ($traceurRuntime.createClass)(Promise, {\n      catch: function(onReject) {\n        return this.then(undefined, onReject);\n      },\n      then: function(onResolve, onReject) {\n        if (typeof onResolve !== 'function')\n          onResolve = idResolveHandler;\n        if (typeof onReject !== 'function')\n          onReject = idRejectHandler;\n        var that = this;\n        var constructor = this.constructor;\n        return chain(this, function(x) {\n          x = promiseCoerce(constructor, x);\n          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n        }, onReject);\n      }\n    }, {\n      resolve: function(x) {\n        if (this === $Promise) {\n          if (isPromise(x)) {\n            return x;\n          }\n          return promiseSet(new $Promise(promiseRaw), +1, x);\n        } else {\n          return new this(function(resolve, reject) {\n            resolve(x);\n          });\n        }\n      },\n      reject: function(r) {\n        if (this === $Promise) {\n          return promiseSet(new $Promise(promiseRaw), -1, r);\n        } else {\n          return new this(function(resolve, reject) {\n            reject(r);\n          });\n        }\n      },\n      all: function(values) {\n        var deferred = getDeferred(this);\n        var resolutions = [];\n        try {\n          var makeCountdownFunction = function(i) {\n            return function(x) {\n              resolutions[i] = x;\n              if (--count === 0)\n                deferred.resolve(resolutions);\n            };\n          };\n          var count = 0;\n          var i = 0;\n          var $__4 = true;\n          var $__5 = false;\n          var $__6 = undefined;\n          try {\n            for (var $__2 = void 0,\n                $__1 = (values)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {\n              var value = $__2.value;\n              {\n                var countdownFunction = makeCountdownFunction(i);\n                this.resolve(value).then(countdownFunction, function(r) {\n                  deferred.reject(r);\n                });\n                ++i;\n                ++count;\n              }\n            }\n          } catch ($__7) {\n            $__5 = true;\n            $__6 = $__7;\n          } finally {\n            try {\n              if (!$__4 && $__1.return != null) {\n                $__1.return();\n              }\n            } finally {\n              if ($__5) {\n                throw $__6;\n              }\n            }\n          }\n          if (count === 0) {\n            deferred.resolve(resolutions);\n          }\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      },\n      race: function(values) {\n        var deferred = getDeferred(this);\n        try {\n          for (var i = 0; i < values.length; i++) {\n            this.resolve(values[i]).then(function(x) {\n              deferred.resolve(x);\n            }, function(r) {\n              deferred.reject(r);\n            });\n          }\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      }\n    });\n  }();\n  var $Promise = Promise;\n  var $PromiseReject = $Promise.reject;\n  function promiseResolve(promise, x) {\n    promiseDone(promise, +1, x, promise.onResolve_);\n  }\n  function promiseReject(promise, r) {\n    promiseDone(promise, -1, r, promise.onReject_);\n  }\n  function promiseDone(promise, status, value, reactions) {\n    if (promise.status_ !== 0)\n      return;\n    promiseEnqueue(value, reactions);\n    promiseSet(promise, status, value);\n  }\n  function promiseEnqueue(value, tasks) {\n    async(function() {\n      for (var i = 0; i < tasks.length; i += 2) {\n        promiseHandle(value, tasks[i], tasks[i + 1]);\n      }\n    });\n  }\n  function promiseHandle(value, handler, deferred) {\n    try {\n      var result = handler(value);\n      if (result === deferred.promise)\n        throw new TypeError;\n      else if (isPromise(result))\n        chain(result, deferred.resolve, deferred.reject);\n      else\n        deferred.resolve(result);\n    } catch (e) {\n      try {\n        deferred.reject(e);\n      } catch (e) {}\n    }\n  }\n  var thenableSymbol = createPrivateSymbol();\n  function promiseCoerce(constructor, x) {\n    if (!isPromise(x) && isObject(x)) {\n      var then;\n      try {\n        then = x.then;\n      } catch (r) {\n        var promise = $PromiseReject.call(constructor, r);\n        setPrivate(x, thenableSymbol, promise);\n        return promise;\n      }\n      if (typeof then === 'function') {\n        var p = getPrivate(x, thenableSymbol);\n        if (p) {\n          return p;\n        } else {\n          var deferred = getDeferred(constructor);\n          setPrivate(x, thenableSymbol, deferred.promise);\n          try {\n            then.call(x, deferred.resolve, deferred.reject);\n          } catch (r) {\n            deferred.reject(r);\n          }\n          return deferred.promise;\n        }\n      }\n    }\n    return x;\n  }\n  function polyfillPromise(global) {\n    if (!global.Promise)\n      global.Promise = Promise;\n  }\n  registerPolyfill(polyfillPromise);\n  return {\n    get Promise() {\n      return Promise;\n    },\n    get polyfillPromise() {\n      return polyfillPromise;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Promise.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/StringIterator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/StringIterator.js\";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/StringIterator.js\")),\n      createIteratorResultObject = $__3.createIteratorResultObject,\n      isObject = $__3.isObject;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var iteratedString = Symbol('iteratedString');\n  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');\n  var StringIterator = function() {\n    var $__1;\n    function StringIterator() {}\n    return ($traceurRuntime.createClass)(StringIterator, ($__1 = {}, Object.defineProperty($__1, \"next\", {\n      value: function() {\n        var o = this;\n        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {\n          throw new TypeError('this must be a StringIterator object');\n        }\n        var s = o[iteratedString];\n        if (s === undefined) {\n          return createIteratorResultObject(undefined, true);\n        }\n        var position = o[stringIteratorNextIndex];\n        var len = s.length;\n        if (position >= len) {\n          o[iteratedString] = undefined;\n          return createIteratorResultObject(undefined, true);\n        }\n        var first = s.charCodeAt(position);\n        var resultString;\n        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {\n          resultString = String.fromCharCode(first);\n        } else {\n          var second = s.charCodeAt(position + 1);\n          if (second < 0xDC00 || second > 0xDFFF) {\n            resultString = String.fromCharCode(first);\n          } else {\n            resultString = String.fromCharCode(first) + String.fromCharCode(second);\n          }\n        }\n        o[stringIteratorNextIndex] = position + resultString.length;\n        return createIteratorResultObject(resultString, false);\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__1, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__1), {});\n  }();\n  function createStringIterator(string) {\n    var s = String(string);\n    var iterator = Object.create(StringIterator.prototype);\n    iterator[iteratedString] = s;\n    iterator[stringIteratorNextIndex] = 0;\n    return iterator;\n  }\n  return {get createStringIterator() {\n      return createStringIterator;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/String.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/String.js\";\n  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../checkObjectCoercible.js\", \"traceur@0.0.111/src/runtime/polyfills/String.js\")).default;\n  var createStringIterator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./StringIterator.js\", \"traceur@0.0.111/src/runtime/polyfills/String.js\")).createStringIterator;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/String.js\")),\n      maybeAddFunctions = $__3.maybeAddFunctions,\n      maybeAddIterator = $__3.maybeAddIterator,\n      registerPolyfill = $__3.registerPolyfill;\n  var $toString = Object.prototype.toString;\n  var $indexOf = String.prototype.indexOf;\n  var $lastIndexOf = String.prototype.lastIndexOf;\n  function startsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) == start;\n  }\n  function endsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var pos = stringLength;\n    if (arguments.length > 1) {\n      var position = arguments[1];\n      if (position !== undefined) {\n        pos = position ? Number(position) : 0;\n        if (isNaN(pos)) {\n          pos = 0;\n        }\n      }\n    }\n    var end = Math.min(Math.max(pos, 0), stringLength);\n    var start = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return $lastIndexOf.call(string, searchString, start) == start;\n  }\n  function includes(search) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    if (search && $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (pos != pos) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    if (searchLength + start > stringLength) {\n      return false;\n    }\n    return $indexOf.call(string, searchString, pos) != -1;\n  }\n  function repeat(count) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var n = count ? Number(count) : 0;\n    if (isNaN(n)) {\n      n = 0;\n    }\n    if (n < 0 || n == Infinity) {\n      throw RangeError();\n    }\n    if (n == 0) {\n      return '';\n    }\n    var result = '';\n    while (n--) {\n      result += string;\n    }\n    return result;\n  }\n  function codePointAt(position) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = position ? Number(position) : 0;\n    if (isNaN(index)) {\n      index = 0;\n    }\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n  function raw(callsite) {\n    var raw = callsite.raw;\n    var len = raw.length >>> 0;\n    if (len === 0)\n      return '';\n    var s = '';\n    var i = 0;\n    while (true) {\n      s += raw[i];\n      if (i + 1 === len)\n        return s;\n      s += arguments[++i];\n    }\n  }\n  function fromCodePoint(_) {\n    var codeUnits = [];\n    var floor = Math.floor;\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        codeUnits.push(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n    }\n    return String.fromCharCode.apply(null, codeUnits);\n  }\n  function stringPrototypeIterator() {\n    var o = checkObjectCoercible(this);\n    var s = String(o);\n    return createStringIterator(s);\n  }\n  function polyfillString(global) {\n    var String = global.String;\n    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);\n    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);\n  }\n  registerPolyfill(polyfillString);\n  return {\n    get startsWith() {\n      return startsWith;\n    },\n    get endsWith() {\n      return endsWith;\n    },\n    get includes() {\n      return includes;\n    },\n    get repeat() {\n      return repeat;\n    },\n    get codePointAt() {\n      return codePointAt;\n    },\n    get raw() {\n      return raw;\n    },\n    get fromCodePoint() {\n      return fromCodePoint;\n    },\n    get stringPrototypeIterator() {\n      return stringPrototypeIterator;\n    },\n    get polyfillString() {\n      return polyfillString;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/String.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/ArrayIterator.js\")),\n      toObject = $__2.toObject,\n      toUint32 = $__2.toUint32,\n      createIteratorResultObject = $__2.createIteratorResultObject;\n  var ARRAY_ITERATOR_KIND_KEYS = 1;\n  var ARRAY_ITERATOR_KIND_VALUES = 2;\n  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n  var ArrayIterator = function() {\n    var $__1;\n    function ArrayIterator() {}\n    return ($traceurRuntime.createClass)(ArrayIterator, ($__1 = {}, Object.defineProperty($__1, \"next\", {\n      value: function() {\n        var iterator = toObject(this);\n        var array = iterator.iteratorObject_;\n        if (!array) {\n          throw new TypeError('Object is not an ArrayIterator');\n        }\n        var index = iterator.arrayIteratorNextIndex_;\n        var itemKind = iterator.arrayIterationKind_;\n        var length = toUint32(array.length);\n        if (index >= length) {\n          iterator.arrayIteratorNextIndex_ = Infinity;\n          return createIteratorResultObject(undefined, true);\n        }\n        iterator.arrayIteratorNextIndex_ = index + 1;\n        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n          return createIteratorResultObject(array[index], false);\n        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n          return createIteratorResultObject([index, array[index]], false);\n        return createIteratorResultObject(index, false);\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__1, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__1), {});\n  }();\n  function createArrayIterator(array, kind) {\n    var object = toObject(array);\n    var iterator = new ArrayIterator;\n    iterator.iteratorObject_ = object;\n    iterator.arrayIteratorNextIndex_ = 0;\n    iterator.arrayIterationKind_ = kind;\n    return iterator;\n  }\n  function entries() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n  }\n  function keys() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n  }\n  function values() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n  }\n  return {\n    get entries() {\n      return entries;\n    },\n    get keys() {\n      return keys;\n    },\n    get values() {\n      return values;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Array.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Array.js\";\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ArrayIterator.js\", \"traceur@0.0.111/src/runtime/polyfills/Array.js\")),\n      entries = $__9.entries,\n      keys = $__9.keys,\n      jsValues = $__9.values;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Array.js\")),\n      checkIterable = $__10.checkIterable,\n      isCallable = $__10.isCallable,\n      isConstructor = $__10.isConstructor,\n      maybeAddFunctions = $__10.maybeAddFunctions,\n      maybeAddIterator = $__10.maybeAddIterator,\n      registerPolyfill = $__10.registerPolyfill,\n      toInteger = $__10.toInteger,\n      toLength = $__10.toLength,\n      toObject = $__10.toObject;\n  function from(arrLike) {\n    var mapFn = arguments[1];\n    var thisArg = arguments[2];\n    var C = this;\n    var items = toObject(arrLike);\n    var mapping = mapFn !== undefined;\n    var k = 0;\n    var arr,\n        len;\n    if (mapping && !isCallable(mapFn)) {\n      throw TypeError();\n    }\n    if (checkIterable(items)) {\n      arr = isConstructor(C) ? new C() : [];\n      var $__3 = true;\n      var $__4 = false;\n      var $__5 = undefined;\n      try {\n        for (var $__1 = void 0,\n            $__0 = (items)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {\n          var item = $__1.value;\n          {\n            if (mapping) {\n              arr[k] = mapFn.call(thisArg, item, k);\n            } else {\n              arr[k] = item;\n            }\n            k++;\n          }\n        }\n      } catch ($__6) {\n        $__4 = true;\n        $__5 = $__6;\n      } finally {\n        try {\n          if (!$__3 && $__0.return != null) {\n            $__0.return();\n          }\n        } finally {\n          if ($__4) {\n            throw $__5;\n          }\n        }\n      }\n      arr.length = k;\n      return arr;\n    }\n    len = toLength(items.length);\n    arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (; k < len; k++) {\n      if (mapping) {\n        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);\n      } else {\n        arr[k] = items[k];\n      }\n    }\n    arr.length = len;\n    return arr;\n  }\n  function of() {\n    for (var items = [],\n        $__7 = 0; $__7 < arguments.length; $__7++)\n      items[$__7] = arguments[$__7];\n    var C = this;\n    var len = items.length;\n    var arr = isConstructor(C) ? new C(len) : new Array(len);\n    for (var k = 0; k < len; k++) {\n      arr[k] = items[k];\n    }\n    arr.length = len;\n    return arr;\n  }\n  function fill(value) {\n    var start = arguments[1] !== (void 0) ? arguments[1] : 0;\n    var end = arguments[2];\n    var object = toObject(this);\n    var len = toLength(object.length);\n    var fillStart = toInteger(start);\n    var fillEnd = end !== undefined ? toInteger(end) : len;\n    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);\n    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);\n    while (fillStart < fillEnd) {\n      object[fillStart] = value;\n      fillStart++;\n    }\n    return object;\n  }\n  function find(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg);\n  }\n  function findIndex(predicate) {\n    var thisArg = arguments[1];\n    return findHelper(this, predicate, thisArg, true);\n  }\n  function findHelper(self, predicate) {\n    var thisArg = arguments[2];\n    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;\n    var object = toObject(self);\n    var len = toLength(object.length);\n    if (!isCallable(predicate)) {\n      throw TypeError();\n    }\n    for (var i = 0; i < len; i++) {\n      var value = object[i];\n      if (predicate.call(thisArg, value, i, object)) {\n        return returnIndex ? i : value;\n      }\n    }\n    return returnIndex ? -1 : undefined;\n  }\n  function polyfillArray(global) {\n    var $__8 = global,\n        Array = $__8.Array,\n        Object = $__8.Object,\n        Symbol = $__8.Symbol;\n    var values = jsValues;\n    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {\n      values = Array.prototype[Symbol.iterator];\n    }\n    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);\n    maybeAddFunctions(Array, ['from', from, 'of', of]);\n    maybeAddIterator(Array.prototype, values, Symbol);\n    maybeAddIterator(Object.getPrototypeOf([].values()), function() {\n      return this;\n    }, Symbol);\n  }\n  registerPolyfill(polyfillArray);\n  return {\n    get from() {\n      return from;\n    },\n    get of() {\n      return of;\n    },\n    get fill() {\n      return fill;\n    },\n    get find() {\n      return find;\n    },\n    get findIndex() {\n      return findIndex;\n    },\n    get polyfillArray() {\n      return polyfillArray;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Array.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/assign.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/assign.js\";\n  var keys = Object.keys;\n  function assign(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      var props = source == null ? [] : keys(source);\n      var p = void 0,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        var name = props[p];\n        target[name] = source[name];\n      }\n    }\n    return target;\n  }\n  return {get default() {\n      return assign;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Object.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Object.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Object.js\")),\n      maybeAddFunctions = $__2.maybeAddFunctions,\n      registerPolyfill = $__2.registerPolyfill;\n  var assign = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./assign.js\", \"traceur@0.0.111/src/runtime/polyfills/Object.js\")).default;\n  var $__0 = Object,\n      defineProperty = $__0.defineProperty,\n      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,\n      getOwnPropertyNames = $__0.getOwnPropertyNames;\n  function is(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    return left !== left && right !== right;\n  }\n  function mixin(target, source) {\n    var props = getOwnPropertyNames(source);\n    var p,\n        descriptor,\n        length = props.length;\n    for (p = 0; p < length; p++) {\n      var name = props[p];\n      descriptor = getOwnPropertyDescriptor(source, props[p]);\n      defineProperty(target, props[p], descriptor);\n    }\n    return target;\n  }\n  function polyfillObject(global) {\n    var Object = global.Object;\n    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);\n  }\n  registerPolyfill(polyfillObject);\n  return {\n    get assign() {\n      return assign;\n    },\n    get is() {\n      return is;\n    },\n    get mixin() {\n      return mixin;\n    },\n    get polyfillObject() {\n      return polyfillObject;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Object.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Number.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Number.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Number.js\")),\n      isNumber = $__1.isNumber,\n      maybeAddConsts = $__1.maybeAddConsts,\n      maybeAddFunctions = $__1.maybeAddFunctions,\n      registerPolyfill = $__1.registerPolyfill,\n      toInteger = $__1.toInteger;\n  var $abs = Math.abs;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;\n  var EPSILON = Math.pow(2, -52);\n  function NumberIsFinite(number) {\n    return isNumber(number) && $isFinite(number);\n  }\n  function isInteger(number) {\n    return NumberIsFinite(number) && toInteger(number) === number;\n  }\n  function NumberIsNaN(number) {\n    return isNumber(number) && $isNaN(number);\n  }\n  function isSafeInteger(number) {\n    if (NumberIsFinite(number)) {\n      var integral = toInteger(number);\n      if (integral === number)\n        return $abs(integral) <= MAX_SAFE_INTEGER;\n    }\n    return false;\n  }\n  function polyfillNumber(global) {\n    var Number = global.Number;\n    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);\n    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);\n  }\n  registerPolyfill(polyfillNumber);\n  return {\n    get MAX_SAFE_INTEGER() {\n      return MAX_SAFE_INTEGER;\n    },\n    get MIN_SAFE_INTEGER() {\n      return MIN_SAFE_INTEGER;\n    },\n    get EPSILON() {\n      return EPSILON;\n    },\n    get isFinite() {\n      return NumberIsFinite;\n    },\n    get isInteger() {\n      return isInteger;\n    },\n    get isNaN() {\n      return NumberIsNaN;\n    },\n    get isSafeInteger() {\n      return isSafeInteger;\n    },\n    get polyfillNumber() {\n      return polyfillNumber;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Number.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/fround.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/fround.js\";\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $__0 = Math,\n      LN2 = $__0.LN2,\n      abs = $__0.abs,\n      floor = $__0.floor,\n      log = $__0.log,\n      min = $__0.min,\n      pow = $__0.pow;\n  function packIEEE754(v, ebits, fbits) {\n    var bias = (1 << (ebits - 1)) - 1,\n        s,\n        e,\n        f,\n        ln,\n        i,\n        bits,\n        str,\n        bytes;\n    function roundToEven(n) {\n      var w = floor(n),\n          f = n - w;\n      if (f < 0.5)\n        return w;\n      if (f > 0.5)\n        return w + 1;\n      return w % 2 ? w + 1 : w;\n    }\n    if (v !== v) {\n      e = (1 << ebits) - 1;\n      f = pow(2, fbits - 1);\n      s = 0;\n    } else if (v === Infinity || v === -Infinity) {\n      e = (1 << ebits) - 1;\n      f = 0;\n      s = (v < 0) ? 1 : 0;\n    } else if (v === 0) {\n      e = 0;\n      f = 0;\n      s = (1 / v === -Infinity) ? 1 : 0;\n    } else {\n      s = v < 0;\n      v = abs(v);\n      if (v >= pow(2, 1 - bias)) {\n        e = min(floor(log(v) / LN2), 1023);\n        f = roundToEven(v / pow(2, e) * pow(2, fbits));\n        if (f / pow(2, fbits) >= 2) {\n          e = e + 1;\n          f = 1;\n        }\n        if (e > bias) {\n          e = (1 << ebits) - 1;\n          f = 0;\n        } else {\n          e = e + bias;\n          f = f - pow(2, fbits);\n        }\n      } else {\n        e = 0;\n        f = roundToEven(v / pow(2, 1 - bias - fbits));\n      }\n    }\n    bits = [];\n    for (i = fbits; i; i -= 1) {\n      bits.push(f % 2 ? 1 : 0);\n      f = floor(f / 2);\n    }\n    for (i = ebits; i; i -= 1) {\n      bits.push(e % 2 ? 1 : 0);\n      e = floor(e / 2);\n    }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    str = bits.join('');\n    bytes = [];\n    while (str.length) {\n      bytes.push(parseInt(str.substring(0, 8), 2));\n      str = str.substring(8);\n    }\n    return bytes;\n  }\n  function unpackIEEE754(bytes, ebits, fbits) {\n    var bits = [],\n        i,\n        j,\n        b,\n        str,\n        bias,\n        s,\n        e,\n        f;\n    for (i = bytes.length; i; i -= 1) {\n      b = bytes[i - 1];\n      for (j = 8; j; j -= 1) {\n        bits.push(b % 2 ? 1 : 0);\n        b = b >> 1;\n      }\n    }\n    bits.reverse();\n    str = bits.join('');\n    bias = (1 << (ebits - 1)) - 1;\n    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n    e = parseInt(str.substring(1, 1 + ebits), 2);\n    f = parseInt(str.substring(1 + ebits), 2);\n    if (e === (1 << ebits) - 1) {\n      return f !== 0 ? NaN : s * Infinity;\n    } else if (e > 0) {\n      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n    } else if (f !== 0) {\n      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n    } else {\n      return s < 0 ? -0 : 0;\n    }\n  }\n  function unpackF32(b) {\n    return unpackIEEE754(b, 8, 23);\n  }\n  function packF32(v) {\n    return packIEEE754(v, 8, 23);\n  }\n  function fround(x) {\n    if (x === 0 || !$isFinite(x) || $isNaN(x)) {\n      return x;\n    }\n    return unpackF32(packF32(Number(x)));\n  }\n  return {get fround() {\n      return fround;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/Math.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/Math.js\";\n  var jsFround = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./fround.js\", \"traceur@0.0.111/src/runtime/polyfills/Math.js\")).fround;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/Math.js\")),\n      maybeAddFunctions = $__3.maybeAddFunctions,\n      registerPolyfill = $__3.registerPolyfill,\n      toUint32 = $__3.toUint32;\n  var $isFinite = isFinite;\n  var $isNaN = isNaN;\n  var $__0 = Math,\n      abs = $__0.abs,\n      ceil = $__0.ceil,\n      exp = $__0.exp,\n      floor = $__0.floor,\n      log = $__0.log,\n      pow = $__0.pow,\n      sqrt = $__0.sqrt;\n  function clz32(x) {\n    x = toUint32(+x);\n    if (x == 0)\n      return 32;\n    var result = 0;\n    if ((x & 0xFFFF0000) === 0) {\n      x <<= 16;\n      result += 16;\n    }\n    ;\n    if ((x & 0xFF000000) === 0) {\n      x <<= 8;\n      result += 8;\n    }\n    ;\n    if ((x & 0xF0000000) === 0) {\n      x <<= 4;\n      result += 4;\n    }\n    ;\n    if ((x & 0xC0000000) === 0) {\n      x <<= 2;\n      result += 2;\n    }\n    ;\n    if ((x & 0x80000000) === 0) {\n      x <<= 1;\n      result += 1;\n    }\n    ;\n    return result;\n  }\n  function imul(x, y) {\n    x = toUint32(+x);\n    y = toUint32(+y);\n    var xh = (x >>> 16) & 0xffff;\n    var xl = x & 0xffff;\n    var yh = (y >>> 16) & 0xffff;\n    var yl = y & 0xffff;\n    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;\n  }\n  function sign(x) {\n    x = +x;\n    if (x > 0)\n      return 1;\n    if (x < 0)\n      return -1;\n    return x;\n  }\n  function log10(x) {\n    return log(x) * 0.434294481903251828;\n  }\n  function log2(x) {\n    return log(x) * 1.442695040888963407;\n  }\n  function log1p(x) {\n    x = +x;\n    if (x < -1 || $isNaN(x)) {\n      return NaN;\n    }\n    if (x === 0 || x === Infinity) {\n      return x;\n    }\n    if (x === -1) {\n      return -Infinity;\n    }\n    var result = 0;\n    var n = 50;\n    if (x < 0 || x > 1) {\n      return log(1 + x);\n    }\n    for (var i = 1; i < n; i++) {\n      if ((i % 2) === 0) {\n        result -= pow(x, i) / i;\n      } else {\n        result += pow(x, i) / i;\n      }\n    }\n    return result;\n  }\n  function expm1(x) {\n    x = +x;\n    if (x === -Infinity) {\n      return -1;\n    }\n    if (!$isFinite(x) || x === 0) {\n      return x;\n    }\n    return exp(x) - 1;\n  }\n  function cosh(x) {\n    x = +x;\n    if (x === 0) {\n      return 1;\n    }\n    if ($isNaN(x)) {\n      return NaN;\n    }\n    if (!$isFinite(x)) {\n      return Infinity;\n    }\n    if (x < 0) {\n      x = -x;\n    }\n    if (x > 21) {\n      return exp(x) / 2;\n    }\n    return (exp(x) + exp(-x)) / 2;\n  }\n  function sinh(x) {\n    x = +x;\n    if (!$isFinite(x) || x === 0) {\n      return x;\n    }\n    return (exp(x) - exp(-x)) / 2;\n  }\n  function tanh(x) {\n    x = +x;\n    if (x === 0)\n      return x;\n    if (!$isFinite(x))\n      return sign(x);\n    var exp1 = exp(x);\n    var exp2 = exp(-x);\n    return (exp1 - exp2) / (exp1 + exp2);\n  }\n  function acosh(x) {\n    x = +x;\n    if (x < 1)\n      return NaN;\n    if (!$isFinite(x))\n      return x;\n    return log(x + sqrt(x + 1) * sqrt(x - 1));\n  }\n  function asinh(x) {\n    x = +x;\n    if (x === 0 || !$isFinite(x))\n      return x;\n    if (x > 0)\n      return log(x + sqrt(x * x + 1));\n    return -log(-x + sqrt(x * x + 1));\n  }\n  function atanh(x) {\n    x = +x;\n    if (x === -1) {\n      return -Infinity;\n    }\n    if (x === 1) {\n      return Infinity;\n    }\n    if (x === 0) {\n      return x;\n    }\n    if ($isNaN(x) || x < -1 || x > 1) {\n      return NaN;\n    }\n    return 0.5 * log((1 + x) / (1 - x));\n  }\n  function hypot(x, y) {\n    var length = arguments.length;\n    var args = new Array(length);\n    var max = 0;\n    for (var i = 0; i < length; i++) {\n      var n = arguments[i];\n      n = +n;\n      if (n === Infinity || n === -Infinity)\n        return Infinity;\n      n = abs(n);\n      if (n > max)\n        max = n;\n      args[i] = n;\n    }\n    if (max === 0)\n      max = 1;\n    var sum = 0;\n    var compensation = 0;\n    for (var i = 0; i < length; i++) {\n      var n = args[i] / max;\n      var summand = n * n - compensation;\n      var preliminary = sum + summand;\n      compensation = (preliminary - sum) - summand;\n      sum = preliminary;\n    }\n    return sqrt(sum) * max;\n  }\n  function trunc(x) {\n    x = +x;\n    if (x > 0)\n      return floor(x);\n    if (x < 0)\n      return ceil(x);\n    return x;\n  }\n  var fround,\n      f32;\n  if (typeof Float32Array === 'function') {\n    f32 = new Float32Array(1);\n    fround = function(x) {\n      f32[0] = Number(x);\n      return f32[0];\n    };\n  } else {\n    fround = jsFround;\n  }\n  function cbrt(x) {\n    x = +x;\n    if (x === 0)\n      return x;\n    var negate = x < 0;\n    if (negate)\n      x = -x;\n    var result = pow(x, 1 / 3);\n    return negate ? -result : result;\n  }\n  function polyfillMath(global) {\n    var Math = global.Math;\n    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);\n  }\n  registerPolyfill(polyfillMath);\n  return {\n    get clz32() {\n      return clz32;\n    },\n    get imul() {\n      return imul;\n    },\n    get sign() {\n      return sign;\n    },\n    get log10() {\n      return log10;\n    },\n    get log2() {\n      return log2;\n    },\n    get log1p() {\n      return log1p;\n    },\n    get expm1() {\n      return expm1;\n    },\n    get cosh() {\n      return cosh;\n    },\n    get sinh() {\n      return sinh;\n    },\n    get tanh() {\n      return tanh;\n    },\n    get acosh() {\n      return acosh;\n    },\n    get asinh() {\n      return asinh;\n    },\n    get atanh() {\n      return atanh;\n    },\n    get hypot() {\n      return hypot;\n    },\n    get trunc() {\n      return trunc;\n    },\n    get fround() {\n      return fround;\n    },\n    get cbrt() {\n      return cbrt;\n    },\n    get polyfillMath() {\n      return polyfillMath;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/Math.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\")),\n      createPrivateSymbol = $__5.createPrivateSymbol,\n      deletePrivate = $__5.deletePrivate,\n      getPrivate = $__5.getPrivate,\n      hasPrivate = $__5.hasPrivate,\n      setPrivate = $__5.setPrivate;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../frozen-data.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\")),\n      deleteFrozen = $__6.deleteFrozen,\n      getFrozen = $__6.getFrozen,\n      hasFrozen = $__6.hasFrozen,\n      setFrozen = $__6.setFrozen;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\")),\n      isObject = $__7.isObject,\n      registerPolyfill = $__7.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../has-native-symbols.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\")).default;\n  var $__2 = Object,\n      defineProperty = $__2.defineProperty,\n      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,\n      isExtensible = $__2.isExtensible;\n  var $TypeError = TypeError;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var sentinel = {};\n  var WeakMap = function() {\n    function WeakMap() {\n      this.name_ = createPrivateSymbol();\n      this.frozenData_ = [];\n    }\n    return ($traceurRuntime.createClass)(WeakMap, {\n      set: function(key, value) {\n        if (!isObject(key))\n          throw new $TypeError('key must be an object');\n        if (!isExtensible(key)) {\n          setFrozen(this.frozenData_, key, value);\n        } else {\n          setPrivate(key, this.name_, value);\n        }\n        return this;\n      },\n      get: function(key) {\n        if (!isObject(key))\n          return undefined;\n        if (!isExtensible(key)) {\n          return getFrozen(this.frozenData_, key);\n        }\n        return getPrivate(key, this.name_);\n      },\n      delete: function(key) {\n        if (!isObject(key))\n          return false;\n        if (!isExtensible(key)) {\n          return deleteFrozen(this.frozenData_, key);\n        }\n        return deletePrivate(key, this.name_);\n      },\n      has: function(key) {\n        if (!isObject(key))\n          return false;\n        if (!isExtensible(key)) {\n          return hasFrozen(this.frozenData_, key);\n        }\n        return hasPrivate(key, this.name_);\n      }\n    }, {});\n  }();\n  function needsPolyfill(global) {\n    var $__4 = global,\n        WeakMap = $__4.WeakMap,\n        Symbol = $__4.Symbol;\n    if (!WeakMap || !hasNativeSymbol()) {\n      return true;\n    }\n    try {\n      var o = {};\n      var wm = new WeakMap([[o, false]]);\n      return wm.get(o);\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillWeakMap(global) {\n    if (needsPolyfill(global)) {\n      global.WeakMap = WeakMap;\n    }\n  }\n  registerPolyfill(polyfillWeakMap);\n  return {\n    get WeakMap() {\n      return WeakMap;\n    },\n    get polyfillWeakMap() {\n      return polyfillWeakMap;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/WeakMap.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../private.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\")),\n      createPrivateSymbol = $__5.createPrivateSymbol,\n      deletePrivate = $__5.deletePrivate,\n      getPrivate = $__5.getPrivate,\n      hasPrivate = $__5.hasPrivate,\n      setPrivate = $__5.setPrivate;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../frozen-data.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\")),\n      deleteFrozen = $__6.deleteFrozen,\n      getFrozen = $__6.getFrozen,\n      setFrozen = $__6.setFrozen;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\")),\n      isObject = $__7.isObject,\n      registerPolyfill = $__7.registerPolyfill;\n  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../has-native-symbols.js\", \"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\")).default;\n  var $__2 = Object,\n      defineProperty = $__2.defineProperty,\n      isExtensible = $__2.isExtensible;\n  var $TypeError = TypeError;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var WeakSet = function() {\n    function WeakSet() {\n      this.name_ = createPrivateSymbol();\n      this.frozenData_ = [];\n    }\n    return ($traceurRuntime.createClass)(WeakSet, {\n      add: function(value) {\n        if (!isObject(value))\n          throw new $TypeError('value must be an object');\n        if (!isExtensible(value)) {\n          setFrozen(this.frozenData_, value, value);\n        } else {\n          setPrivate(value, this.name_, true);\n        }\n        return this;\n      },\n      delete: function(value) {\n        if (!isObject(value))\n          return false;\n        if (!isExtensible(value)) {\n          return deleteFrozen(this.frozenData_, value);\n        }\n        return deletePrivate(value, this.name_);\n      },\n      has: function(value) {\n        if (!isObject(value))\n          return false;\n        if (!isExtensible(value)) {\n          return getFrozen(this.frozenData_, value) === value;\n        }\n        return hasPrivate(value, this.name_);\n      }\n    }, {});\n  }();\n  function needsPolyfill(global) {\n    var $__4 = global,\n        WeakSet = $__4.WeakSet,\n        Symbol = $__4.Symbol;\n    if (!WeakSet || !hasNativeSymbol()) {\n      return true;\n    }\n    try {\n      var o = {};\n      var wm = new WeakSet([[o]]);\n      return !wm.has(o);\n    } catch (e) {\n      return false;\n    }\n  }\n  function polyfillWeakSet(global) {\n    if (needsPolyfill(global)) {\n      global.WeakSet = WeakSet;\n    }\n  }\n  registerPolyfill(polyfillWeakSet);\n  return {\n    get WeakSet() {\n      return WeakSet;\n    },\n    get polyfillWeakSet() {\n      return polyfillWeakSet;\n    }\n  };\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/WeakSet.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/runtime/polyfills/polyfills.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/runtime/polyfills/polyfills.js\";\n  var polyfillAll = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./utils.js\", \"traceur@0.0.111/src/runtime/polyfills/polyfills.js\")).polyfillAll;\n  polyfillAll(Reflect.global);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n    polyfillAll(global);\n  };\n  return {};\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/runtime/polyfills/polyfills.js\" + '');\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/SourceRange.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/SourceRange.js\";\n  var SourceRange = function() {\n    function SourceRange(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n    return ($traceurRuntime.createClass)(SourceRange, {toString: function() {\n        var str = this.start.source.contents;\n        return str.slice(this.start.offset, this.end.offset);\n      }}, {});\n  }();\n  return {get SourceRange() {\n      return SourceRange;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/ErrorReporter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/ErrorReporter.js\";\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SourceRange.js\", \"traceur@0.0.111/src/util/ErrorReporter.js\")).SourceRange;\n  var ErrorReporter = function() {\n    function ErrorReporter() {\n      this.hadError_ = false;\n    }\n    return ($traceurRuntime.createClass)(ErrorReporter, {\n      reportError: function(location, message) {\n        this.hadError_ = true;\n        this.reportMessageInternal(location, message);\n      },\n      reportMessageInternal: function(location, message) {\n        if (location)\n          message = (location.start + \": \" + message);\n        console.error(message);\n      },\n      hadError: function() {\n        return this.hadError_;\n      },\n      clearError: function() {\n        this.hadError_ = false;\n      }\n    }, {});\n  }();\n  function format(location, text) {\n    var args = arguments[2];\n    var i = 0;\n    text = text.replace(/%./g, function(s) {\n      switch (s) {\n        case '%s':\n          return args && args[i++];\n        case '%%':\n          return '%';\n      }\n      return s;\n    });\n    if (location)\n      text = (location + \": \" + text);\n    return text;\n  }\n  ;\n  ErrorReporter.format = format;\n  return {\n    get ErrorReporter() {\n      return ErrorReporter;\n    },\n    get format() {\n      return format;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/MutedErrorReporter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/MutedErrorReporter.js\";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ErrorReporter.js\", \"traceur@0.0.111/src/util/MutedErrorReporter.js\")).ErrorReporter;\n  var MutedErrorReporter = function($__super) {\n    function MutedErrorReporter() {\n      $traceurRuntime.superConstructor(MutedErrorReporter).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MutedErrorReporter, {reportMessageInternal: function(location, format, args) {}}, {}, $__super);\n  }(ErrorReporter);\n  return {get MutedErrorReporter() {\n      return MutedErrorReporter;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/Options.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/Options.js\";\n  function enumerableOnlyObject(obj) {\n    var result = Object.create(null);\n    Object.keys(obj).forEach(function(key) {\n      Object.defineProperty(result, key, {\n        enumerable: true,\n        value: obj[key]\n      });\n    });\n    return result;\n  }\n  var optionsV01 = enumerableOnlyObject({\n    annotations: false,\n    arrayComprehension: false,\n    arrowFunctions: true,\n    asyncFunctions: false,\n    asyncGenerators: false,\n    blockBinding: true,\n    classes: true,\n    commentCallback: false,\n    computedPropertyNames: true,\n    debug: false,\n    debugNames: false,\n    defaultParameters: true,\n    destructuring: true,\n    exponentiation: false,\n    exportFromExtended: false,\n    forOf: true,\n    forOn: false,\n    freeVariableChecker: false,\n    generatorComprehension: false,\n    generators: true,\n    importRuntime: false,\n    inputSourceMap: false,\n    jsx: false,\n    lowResolutionSourceMap: false,\n    memberVariables: false,\n    moduleName: 'default',\n    modules: 'bootstrap',\n    numericLiterals: true,\n    outputLanguage: 'es5',\n    properTailCalls: false,\n    propertyMethods: true,\n    propertyNameShorthand: true,\n    referrer: '',\n    require: false,\n    restParameters: true,\n    script: false,\n    sourceMaps: false,\n    sourceRoot: false,\n    spread: true,\n    spreadProperties: false,\n    symbols: true,\n    templateLiterals: true,\n    types: false,\n    unicodeEscapeSequences: true,\n    unicodeExpressions: true,\n    validate: false\n  });\n  var versionLockedOptions = optionsV01;\n  var defaultValues = Object.create(null);\n  var featureOptions = Object.create(null);\n  var experimentalOptions = Object.create(null);\n  var moduleOptions = ['amd', 'commonjs', 'closure', 'instantiate', 'inline', 'bootstrap', 'parse'];\n  var EXPERIMENTAL = 0;\n  var ON_BY_DEFAULT = 1;\n  function addFeatureOption(name, kind) {\n    featureOptions[name] = true;\n    if (kind === EXPERIMENTAL)\n      experimentalOptions[name] = true;\n    var defaultValue = kind === ON_BY_DEFAULT;\n    defaultValues[name] = defaultValue;\n  }\n  function addBoolOption(name) {\n    defaultValues[name] = false;\n  }\n  addFeatureOption('arrowFunctions', ON_BY_DEFAULT);\n  addFeatureOption('blockBinding', ON_BY_DEFAULT);\n  addFeatureOption('classes', ON_BY_DEFAULT);\n  addFeatureOption('computedPropertyNames', ON_BY_DEFAULT);\n  addFeatureOption('defaultParameters', ON_BY_DEFAULT);\n  addFeatureOption('destructuring', ON_BY_DEFAULT);\n  addFeatureOption('forOf', ON_BY_DEFAULT);\n  addFeatureOption('generators', ON_BY_DEFAULT);\n  addFeatureOption('modules', 'SPECIAL');\n  addFeatureOption('numericLiterals', ON_BY_DEFAULT);\n  addFeatureOption('propertyMethods', ON_BY_DEFAULT);\n  addFeatureOption('propertyNameShorthand', ON_BY_DEFAULT);\n  addFeatureOption('restParameters', ON_BY_DEFAULT);\n  addFeatureOption('sourceMaps', 'SPECIAL');\n  addFeatureOption('spread', ON_BY_DEFAULT);\n  addFeatureOption('symbols', ON_BY_DEFAULT);\n  addFeatureOption('templateLiterals', ON_BY_DEFAULT);\n  addFeatureOption('unicodeEscapeSequences', ON_BY_DEFAULT);\n  addFeatureOption('unicodeExpressions', ON_BY_DEFAULT);\n  addFeatureOption('properTailCalls', EXPERIMENTAL);\n  addFeatureOption('annotations', EXPERIMENTAL);\n  addFeatureOption('arrayComprehension', EXPERIMENTAL);\n  addFeatureOption('asyncFunctions', EXPERIMENTAL);\n  addFeatureOption('asyncGenerators', EXPERIMENTAL);\n  addFeatureOption('exponentiation', EXPERIMENTAL);\n  addFeatureOption('exportFromExtended', EXPERIMENTAL);\n  addFeatureOption('forOn', EXPERIMENTAL);\n  addFeatureOption('generatorComprehension', EXPERIMENTAL);\n  addFeatureOption('importRuntime', EXPERIMENTAL);\n  addFeatureOption('jsx', EXPERIMENTAL);\n  addFeatureOption('memberVariables', EXPERIMENTAL);\n  addFeatureOption('require', EXPERIMENTAL);\n  addFeatureOption('spreadProperties', EXPERIMENTAL);\n  addFeatureOption('types', EXPERIMENTAL);\n  var transformOptionsPrototype = {};\n  Object.keys(featureOptions).forEach(function(name) {\n    Object.defineProperty(transformOptionsPrototype, name, {\n      get: function() {\n        var v = this.proxiedOptions_[name];\n        if (v === 'parse')\n          return false;\n        return v;\n      },\n      enumerable: true\n    });\n  });\n  var parseOptionsPrototype = {};\n  Object.keys(featureOptions).forEach(function(name) {\n    Object.defineProperty(parseOptionsPrototype, name, {\n      get: function() {\n        return !!this.proxiedOptions_[name];\n      },\n      enumerable: true\n    });\n  });\n  addBoolOption('commentCallback');\n  addBoolOption('debug');\n  addBoolOption('debugNames');\n  addBoolOption('freeVariableChecker');\n  addBoolOption('script');\n  addBoolOption('validate');\n  var Options = function() {\n    function Options() {\n      var options = arguments[0] !== (void 0) ? arguments[0] : Object.create(null);\n      this.reset();\n      Object.defineProperties(this, {\n        modules_: {\n          value: versionLockedOptions.modules,\n          writable: true,\n          enumerable: false\n        },\n        sourceMaps_: {\n          value: versionLockedOptions.sourceMaps,\n          writable: true,\n          enumerable: false\n        },\n        sourceRoot_: {\n          value: versionLockedOptions.sourceRoot,\n          writable: true,\n          enumerable: false\n        },\n        transformOptions: {\n          value: Object.create(transformOptionsPrototype, {proxiedOptions_: {\n              value: this,\n              enumerable: false\n            }}),\n          enumerable: false\n        },\n        parseOptions: {\n          value: Object.create(parseOptionsPrototype, {proxiedOptions_: {\n              value: this,\n              enumerable: false\n            }}),\n          enumerable: false\n        }\n      });\n      this.setFromObject(options);\n    }\n    return ($traceurRuntime.createClass)(Options, {\n      set experimental(v) {\n        var $__2 = this;\n        v = coerceOptionValue(v);\n        Object.keys(experimentalOptions).forEach(function(name) {\n          $__2[name] = v;\n        });\n      },\n      get experimental() {\n        var $__2 = this;\n        var value;\n        Object.keys(experimentalOptions).every(function(name) {\n          var currentValue = $__2[name];\n          if (value === undefined) {\n            value = currentValue;\n            return true;\n          }\n          if (currentValue !== value) {\n            value = null;\n            return false;\n          }\n          return true;\n        });\n        return value;\n      },\n      get atscript() {\n        return this.types && this.annotations && this.memberVariables;\n      },\n      set atscript(value) {\n        this.types = value;\n        this.annotations = value;\n        this.memberVariables = value;\n      },\n      get modules() {\n        return this.modules_;\n      },\n      set modules(value) {\n        if (typeof value === 'boolean' && !value)\n          value = 'bootstrap';\n        if (moduleOptions.indexOf(value) === -1) {\n          throw new Error('Invalid \\'modules\\' option \\'' + value + '\\', not in ' + moduleOptions.join(', '));\n        }\n        this.modules_ = value;\n      },\n      get sourceMaps() {\n        return this.sourceMaps_;\n      },\n      set sourceMaps(value) {\n        if (value === null || typeof value === 'boolean') {\n          this.sourceMaps_ = value ? 'file' : false;\n          return;\n        }\n        if (value === 'file' || value === 'inline' || value === 'memory') {\n          this.sourceMaps_ = value;\n        } else {\n          throw new Error('Option sourceMaps should be ' + '[false|inline|file|memory], not ' + value);\n        }\n      },\n      reset: function() {\n        var allOff = arguments[0];\n        var $__2 = this;\n        var useDefault = allOff === undefined;\n        Object.keys(defaultValues).forEach(function(name) {\n          $__2[name] = useDefault && defaultValues[name];\n        });\n        this.setDefaults();\n      },\n      setDefaults: function() {\n        this.modules = 'bootstrap';\n        this.moduleName = 'default';\n        this.outputLanguage = 'es5';\n        this.referrer = '';\n        this.sourceMaps = false;\n        this.sourceRoot = false;\n        this.lowResolutionSourceMap = false;\n        this.inputSourceMap = false;\n      },\n      setFromObject: function(object) {\n        var $__2 = this;\n        Object.keys(this).forEach(function(name) {\n          if (name in object)\n            $__2.setOption(name, object[name]);\n        });\n        this.modules = object.modules || this.modules;\n        if (typeof object.sourceMaps === 'boolean' || typeof object.sourceMaps === 'string') {\n          this.sourceMaps = object.sourceMaps;\n        }\n        if (object.sourceRoot !== undefined)\n          this.sourceRoot = object.sourceRoot;\n        return this;\n      },\n      setOption: function(name, value) {\n        name = toCamelCase(name);\n        if (name in this) {\n          this[name] = value;\n        } else {\n          throw Error('Unknown option: ' + name);\n        }\n      },\n      diff: function(ref) {\n        var $__2 = this;\n        var mismatches = [];\n        Object.keys(this).forEach(function(key) {\n          if ($__2[key] !== ref[key]) {\n            mismatches.push({\n              key: key,\n              now: $traceurRuntime.options[key],\n              v01: ref[key]\n            });\n          }\n        });\n        return mismatches;\n      }\n    }, {\n      experimental: function() {\n        return new Options(experimentalOptions);\n      },\n      atscript: function() {\n        return new Options({\n          types: true,\n          annotations: true,\n          memberVariables: true\n        });\n      },\n      listUnknownOptions: function(obj) {\n        var unknowns = [];\n        Object.keys(obj).forEach(function(propName) {\n          if (!(propName in optionsV01)) {\n            unknowns.push(propName);\n          }\n        });\n        return unknowns;\n      }\n    });\n  }();\n  ;\n  var descriptions = {\n    experimental: 'Turns on all experimental features',\n    require: 'Generate require function argument for node when modules=register',\n    sourceMaps: 'Generate source map and (\\'file\\') write to .map' + ' or (\\'inline\\') append data URL'\n  };\n  var CommandOptions = function($__super) {\n    function CommandOptions() {\n      $traceurRuntime.superConstructor(CommandOptions).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(CommandOptions, {\n      parseCommand: function(s) {\n        var re = /--([^=]+)(?:=(.+))?/;\n        var m = re.exec(s);\n        if (m)\n          this.setOptionCoerced(m[1], m[2]);\n      },\n      setOptionCoerced: function(name, value) {\n        if (typeof value !== 'undefined' && value !== null)\n          value = coerceOptionValue(value);\n        else\n          value = true;\n        this.setOption(name, value);\n      }\n    }, {\n      fromString: function(s) {\n        return CommandOptions.fromArgv(s.split(/\\s+/));\n      },\n      fromArgv: function(args) {\n        var options = new CommandOptions();\n        args.forEach(function(arg) {\n          return options.parseCommand(arg);\n        });\n        return options;\n      }\n    }, $__super);\n  }(Options);\n  function coerceOptionValue(v) {\n    switch (v) {\n      case 'false':\n        return false;\n      case 'true':\n      case true:\n        return true;\n      default:\n        return !!v && String(v);\n    }\n  }\n  function toCamelCase(s) {\n    return s.replace(/-\\w/g, function(ch) {\n      return ch[1].toUpperCase();\n    });\n  }\n  function toDashCase(s) {\n    return s.replace(/[A-Z]/g, function(ch) {\n      return '-' + ch.toLowerCase();\n    });\n  }\n  function addOptions(flags, commandOptions) {\n    flags.option('--referrer <name>', 'Bracket output code with System.referrerName=<name>', function(name) {\n      commandOptions.setOption('referrer', name);\n      System.map = System.semverMap(name);\n      return name;\n    });\n    flags.option('--modules <' + moduleOptions.join(', ') + '>', 'select the output format for modules', function(moduleFormat) {\n      commandOptions.modules = moduleFormat;\n    });\n    flags.option('--moduleName [true|false|default]', 'true for named, false for anonymous modules; default depends on --modules', function(moduleName) {\n      if (moduleName === 'true')\n        moduleName = true;\n      else if (moduleName === 'false')\n        moduleName = false;\n      else\n        moduleName = 'default';\n      commandOptions.moduleName = moduleName;\n    });\n    flags.option('--outputLanguage <es6|es5>', 'compilation target language', function(outputLanguage) {\n      if (outputLanguage === 'es6' || outputLanguage === 'es5')\n        commandOptions.outputLanguage = outputLanguage;\n      else\n        throw new Error('outputLanguage must be one of es5, es6');\n    });\n    flags.option('--source-maps [file|inline|memory]', 'sourceMaps generated to file or inline with data: URL', function(to) {\n      return commandOptions.sourceMaps = to;\n    });\n    flags.option('--source-root <true|false|string>', 'sourcemap sourceRoot value. false to omit, ' + 'true for directory of output file.', function(to) {\n      if (to === 'false')\n        to = false;\n      else if (to === 'true')\n        to = true;\n      return commandOptions.sourceRoot = to;\n    });\n    flags.option('--low-resolution-source-maps', 'Lower sourceMaps granularity to one mapping per output line', function() {\n      return commandOptions.lowResolutionSourceMap = true;\n    });\n    flags.option('--experimental', 'Turns on all experimental features', function() {\n      commandOptions.experimental = true;\n    });\n    flags.option('--atscript', 'Turns on all AtScript features', function() {\n      commandOptions.atscript = true;\n    });\n    Object.keys(commandOptions).forEach(function(name) {\n      var dashedName = toDashCase(name);\n      if (flags.optionFor('--' + name) || flags.optionFor('--' + dashedName)) {\n        return;\n      } else if (name in featureOptions) {\n        flags.option('--' + dashedName + ' [true|false|parse]', descriptions[name]);\n        flags.on(dashedName, function(value) {\n          return commandOptions.setOptionCoerced(dashedName, value);\n        });\n      } else if (commandOptions[name] !== null) {\n        flags.option('--' + dashedName, descriptions[name]);\n        flags.on(dashedName, function() {\n          return commandOptions.setOption(dashedName, true);\n        });\n      } else {\n        throw new Error('Unexpected null commandOption ' + name);\n      }\n    });\n    commandOptions.setDefaults();\n  }\n  return {\n    get optionsV01() {\n      return optionsV01;\n    },\n    get versionLockedOptions() {\n      return versionLockedOptions;\n    },\n    get Options() {\n      return Options;\n    },\n    get CommandOptions() {\n      return CommandOptions;\n    },\n    get toDashCase() {\n      return toDashCase;\n    },\n    get addOptions() {\n      return addOptions;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/webLoader.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/webLoader.js\";\n  var webLoader = {load: function(url, callback, errback) {\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function() {\n        if (xhr.status == 200 || xhr.status == 0) {\n          callback(xhr.responseText);\n        } else {\n          var err;\n          if (xhr.status === 404)\n            err = 'File not found \\'' + url + '\\'';\n          else\n            err = xhr.status + xhr.statusText;\n          errback(err);\n        }\n        xhr = null;\n      };\n      xhr.onerror = function(err) {\n        errback(err);\n      };\n      xhr.open('GET', url, true);\n      xhr.send();\n      return function() {\n        xhr && xhr.abort();\n      };\n    }};\n  return {get webLoader() {\n      return webLoader;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/WebPageTranscoder.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/WebPageTranscoder.js\";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/ErrorReporter.js\", \"traceur@0.0.111/src/WebPageTranscoder.js\")).ErrorReporter;\n  var CommandOptions = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Options.js\", \"traceur@0.0.111/src/WebPageTranscoder.js\")).CommandOptions;\n  var webLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./loader/webLoader.js\", \"traceur@0.0.111/src/WebPageTranscoder.js\")).webLoader;\n  var scriptSelector = 'script[type=\"module\"],script[type=\"text/traceur\"]';\n  var WebPageTranscoder = function() {\n    function WebPageTranscoder() {\n      var url = arguments[0] !== (void 0) ? arguments[0] : document.location.href;\n      var traceurOptions = arguments[1] !== (void 0) ? arguments[1] : new Options();\n      this.url = url;\n      this.numPending_ = 0;\n      this.numberInlined_ = 0;\n      this.traceurOptions_ = traceurOptions;\n    }\n    return ($traceurRuntime.createClass)(WebPageTranscoder, {\n      asyncLoad_: function(url, fncOfContent, onScriptsReady) {\n        var $__3 = this;\n        this.numPending_++;\n        webLoader.load(url, function(content) {\n          if (content)\n            fncOfContent(content);\n          else\n            console.warn('Failed to load', url);\n          if (--$__3.numPending_ <= 0)\n            onScriptsReady();\n        }, function(error) {\n          console.error('WebPageTranscoder FAILED to load ' + url, error.stack || error);\n        });\n      },\n      addFileFromScriptElement: function(scriptElement, name, content) {\n        var options = this.traceurOptions_;\n        var elementOptionString = scriptElement.getAttribute('traceurOptions');\n        if (elementOptionString) {\n          options = CommandOptions.fromString(elementOptionString);\n        }\n        var nameInfo = {\n          address: name,\n          referrerName: window.location.href,\n          name: name,\n          metadata: {traceurOptions: options}\n        };\n        var loadingResult;\n        if (scriptElement.type === 'module')\n          loadingResult = System.module(content, nameInfo);\n        else\n          loadingResult = System.script(content, nameInfo);\n        loadingResult.catch(function(error) {\n          console.error(error.stack || error);\n        });\n      },\n      nextInlineScriptName_: function() {\n        this.numberInlined_ += 1;\n        if (!this.inlineScriptNameBase_) {\n          var segments = this.url.split('.');\n          segments.pop();\n          this.inlineScriptNameBase_ = segments.join('.');\n        }\n        return this.inlineScriptNameBase_ + '_inline_script_' + this.numberInlined_ + '.js';\n      },\n      addFilesFromScriptElements: function(scriptElements, onScriptsReady) {\n        for (var i = 0,\n            length = scriptElements.length; i < length; i++) {\n          var scriptElement = scriptElements[i];\n          if (!scriptElement.src) {\n            var name = this.nextInlineScriptName_();\n            var content = scriptElement.textContent;\n            this.addFileFromScriptElement(scriptElement, name, content);\n          } else {\n            var name$__4 = scriptElement.src;\n            this.asyncLoad_(name$__4, this.addFileFromScriptElement.bind(this, scriptElement, name$__4), onScriptsReady);\n          }\n        }\n        if (this.numPending_ <= 0)\n          onScriptsReady();\n      },\n      get reporter() {\n        if (!this.reporter_) {\n          this.reporter_ = new ErrorReporter();\n        }\n        return this.reporter_;\n      },\n      putFile: function(file) {\n        var scriptElement = document.createElement('script');\n        scriptElement.setAttribute('data-traceur-src-url', file.name);\n        scriptElement.textContent = file.generatedSource;\n        var parent = file.scriptElement.parentNode;\n        parent.insertBefore(scriptElement, file.scriptElement || null);\n      },\n      selectAndProcessScripts: function(done) {\n        var selector = scriptSelector;\n        var scripts = document.querySelectorAll(selector);\n        if (!scripts.length) {\n          done();\n          return;\n        }\n        this.addFilesFromScriptElements(scripts, function() {\n          done();\n        });\n      },\n      run: function() {\n        var done = arguments[0] !== (void 0) ? arguments[0] : function() {};\n        var $__3 = this;\n        var ready = document.readyState;\n        if (ready === 'complete' || ready === 'loaded') {\n          this.selectAndProcessScripts(done);\n        } else {\n          document.addEventListener('DOMContentLoaded', function() {\n            return $__3.selectAndProcessScripts(done);\n          }, false);\n        }\n      }\n    }, {});\n  }();\n  return {\n    get scriptSelector() {\n      return scriptSelector;\n    },\n    get WebPageTranscoder() {\n      return WebPageTranscoder;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/StringSet.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/StringSet.js\";\n  function assertString(value) {\n    if (typeof value !== 'string')\n      throw new TypeError();\n  }\n  var StringSet = function() {\n    function StringSet() {\n      this.storage_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(StringSet, {\n      add: function(value) {\n        assertString(value);\n        this.storage_[value] = true;\n      },\n      has: function(value) {\n        assertString(value);\n        return this.storage_[value] !== undefined;\n      },\n      delete: function(value) {\n        assertString(value);\n        delete this.storage_[value];\n      },\n      isEmpty: function() {\n        for (var _ in this.storage_) {\n          return false;\n        }\n        return true;\n      },\n      valuesAsArray: function() {\n        return Object.keys(this.storage_);\n      },\n      forEach: function(func) {\n        for (var value in this.storage_) {\n          func(value);\n        }\n      }\n    }, {});\n  }();\n  return {get StringSet() {\n      return StringSet;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/StringMap.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/StringMap.js\";\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./StringSet.js\", \"traceur@0.0.111/src/util/StringMap.js\")).StringSet;\n  function assertString(value) {\n    if (typeof value !== 'string')\n      throw new TypeError();\n  }\n  var StringMap = function() {\n    function StringMap() {\n      this.storage_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(StringMap, {\n      set: function(key, value) {\n        assertString(key);\n        this.storage_[key] = value;\n      },\n      get: function(key) {\n        assertString(key);\n        return this.storage_[key];\n      },\n      delete: function(key) {\n        assertString(key);\n        delete this.storage_[key];\n      },\n      has: function(key) {\n        assertString(key);\n        return this.storage_[key] !== undefined;\n      },\n      keysAsArray: function() {\n        return Object.keys(this.storage_);\n      },\n      keysAsSet: function() {\n        var set = new StringSet();\n        this.forEach(function(key) {\n          return set.add(key);\n        });\n        return set;\n      },\n      forEach: function(func) {\n        for (var key in this.storage_) {\n          func(key, this.storage_[key]);\n        }\n      }\n    }, {});\n  }();\n  return {get StringMap() {\n      return StringMap;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/HTMLImportTranscoder.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/HTMLImportTranscoder.js\";\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/StringMap.js\", \"traceur@0.0.111/src/HTMLImportTranscoder.js\")).StringMap;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./WebPageTranscoder.js\", \"traceur@0.0.111/src/HTMLImportTranscoder.js\")),\n      WebPageTranscoder = $__4.WebPageTranscoder,\n      scriptSelector = $__4.scriptSelector;\n  var importSelector = 'link[rel=import][href]';\n  var HTMLImportTranscoder = function() {\n    function HTMLImportTranscoder() {\n      this.importsToProcess_ = [];\n    }\n    return ($traceurRuntime.createClass)(HTMLImportTranscoder, {\n      findAllChildrenHTMLImports_: function(parentImportNodes) {\n        var foundImportNodes = [];\n        for (var parentIndex = 0; parentIndex < parentImportNodes.length; parentIndex++) {\n          var parentLink = parentImportNodes[parentIndex];\n          var childImportNodes = parentLink.import.querySelectorAll(importSelector);\n          if (childImportNodes.length > 0)\n            this.findAllChildrenHTMLImports_(childImportNodes);\n          this.importsToProcess_.push(parentLink);\n        }\n      },\n      filterHTMLImports_: function(importNodes) {\n        this.findAllChildrenHTMLImports_(importNodes);\n        var importsToParse = [];\n        var dupFilterMap = new StringMap();\n        for (var index = 0; index < this.importsToProcess_.length; index++) {\n          var processLink = this.importsToProcess_[index];\n          if (!dupFilterMap.has(processLink.href)) {\n            dupFilterMap.set(processLink.href, 0);\n            var scripts = processLink.import.querySelectorAll(scriptSelector);\n            if (scripts.length > 0)\n              importsToParse.push({\n                href: processLink.href,\n                scripts: scripts\n              });\n          }\n        }\n        this.importsToProcess_ = [];\n        return importsToParse;\n      },\n      selectAndProcessHTMLImports: function(importNodes, done) {\n        var importInfoList = this.filterHTMLImports_(importNodes);\n        if (importInfoList.length === 0)\n          done();\n        var processCount = importInfoList.length;\n        importInfoList.forEach(function(importInfo) {\n          var transcoder = new WebPageTranscoder(importInfo.href);\n          transcoder.addFilesFromScriptElements(importInfo.scripts, function() {\n            processCount--;\n            if (processCount === 0 && done)\n              done();\n          });\n        });\n      },\n      run: function() {\n        var done = arguments[0] !== (void 0) ? arguments[0] : function() {};\n        var $__2 = this;\n        var ready = document.readyState;\n        if (ready === 'complete' || ready === 'loaded') {\n          var importNodes = document.querySelectorAll(importSelector);\n          if (importNodes.length > 0)\n            this.selectAndProcessHTMLImports(importNodes, done);\n        } else {\n          document.addEventListener('HTMLImportsLoaded', function(event) {\n            var importNodes = event.detail && event.detail.allImports ? event.detail.allImports : document.querySelectorAll(importSelector);\n            if (importNodes.length > 0)\n              $__2.selectAndProcessHTMLImports(importNodes, done);\n          });\n        }\n      }\n    }, {});\n  }();\n  return {get HTMLImportTranscoder() {\n      return HTMLImportTranscoder;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/CollectingErrorReporter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/CollectingErrorReporter.js\";\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/ErrorReporter.js\", \"traceur@0.0.111/src/util/CollectingErrorReporter.js\")).ErrorReporter;\n  var MultipleErrors = function($__super) {\n    function MultipleErrors(errors) {\n      $traceurRuntime.superConstructor(MultipleErrors).call(this);\n      this.message = errors ? errors.join('\\n') : '';\n      this.name = 'MultipleErrors';\n      this.errors = errors;\n    }\n    return ($traceurRuntime.createClass)(MultipleErrors, {}, {}, $__super);\n  }(Error);\n  var CollectingErrorReporter = function($__super) {\n    function CollectingErrorReporter() {\n      $traceurRuntime.superConstructor(CollectingErrorReporter).call(this);\n      this.errors = [];\n    }\n    return ($traceurRuntime.createClass)(CollectingErrorReporter, {\n      reportMessageInternal: function(location, message) {\n        this.errors.push((location.start + \": \" + message));\n      },\n      errorsAsString: function() {\n        return this.toError().message;\n      },\n      toError: function() {\n        return new MultipleErrors(this.errors);\n      }\n    }, {}, $__super);\n  }(ErrorReporter);\n  return {\n    get MultipleErrors() {\n      return MultipleErrors;\n    },\n    get CollectingErrorReporter() {\n      return CollectingErrorReporter;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util-imports.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util-imports.js\";\n  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/MutedErrorReporter.js\", \"traceur@0.0.111/src/util-imports.js\"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_WebPageTranscoder_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./WebPageTranscoder.js\", \"traceur@0.0.111/src/util-imports.js\"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_HTMLImportTranscoder_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./HTMLImportTranscoder.js\", \"traceur@0.0.111/src/util-imports.js\"));\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Options.js\", \"traceur@0.0.111/src/util-imports.js\")),\n      addOptions = $__1.addOptions,\n      CommandOptions = $__1.CommandOptions,\n      Options = $__1.Options;\n  var ErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/ErrorReporter.js\", \"traceur@0.0.111/src/util-imports.js\")).ErrorReporter;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/CollectingErrorReporter.js\", \"traceur@0.0.111/src/util-imports.js\")).CollectingErrorReporter;\n  var util = {\n    addOptions: addOptions,\n    CommandOptions: CommandOptions,\n    CollectingErrorReporter: CollectingErrorReporter,\n    ErrorReporter: ErrorReporter,\n    Options: Options\n  };\n  return {\n    get WebPageTranscoder() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_WebPageTranscoder_46_js__.WebPageTranscoder;\n    },\n    get HTMLImportTranscoder() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_HTMLImportTranscoder_46_js__.HTMLImportTranscoder;\n    },\n    get util() {\n      return util;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/trees/ParseTreeType.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/trees/ParseTreeType.js\";\n  var ANNOTATION = 'ANNOTATION';\n  var ANON_BLOCK = 'ANON_BLOCK';\n  var ARGUMENT_LIST = 'ARGUMENT_LIST';\n  var ARRAY_COMPREHENSION = 'ARRAY_COMPREHENSION';\n  var ARRAY_LITERAL = 'ARRAY_LITERAL';\n  var ARRAY_PATTERN = 'ARRAY_PATTERN';\n  var ARRAY_TYPE = 'ARRAY_TYPE';\n  var ARROW_FUNCTION = 'ARROW_FUNCTION';\n  var ASSIGNMENT_ELEMENT = 'ASSIGNMENT_ELEMENT';\n  var AWAIT_EXPRESSION = 'AWAIT_EXPRESSION';\n  var BINARY_EXPRESSION = 'BINARY_EXPRESSION';\n  var BINDING_ELEMENT = 'BINDING_ELEMENT';\n  var BINDING_IDENTIFIER = 'BINDING_IDENTIFIER';\n  var BLOCK = 'BLOCK';\n  var BREAK_STATEMENT = 'BREAK_STATEMENT';\n  var CALL_EXPRESSION = 'CALL_EXPRESSION';\n  var CALL_SIGNATURE = 'CALL_SIGNATURE';\n  var CASE_CLAUSE = 'CASE_CLAUSE';\n  var CATCH = 'CATCH';\n  var CLASS_DECLARATION = 'CLASS_DECLARATION';\n  var CLASS_EXPRESSION = 'CLASS_EXPRESSION';\n  var COMMA_EXPRESSION = 'COMMA_EXPRESSION';\n  var COMPREHENSION_FOR = 'COMPREHENSION_FOR';\n  var COMPREHENSION_IF = 'COMPREHENSION_IF';\n  var COMPUTED_PROPERTY_NAME = 'COMPUTED_PROPERTY_NAME';\n  var CONDITIONAL_EXPRESSION = 'CONDITIONAL_EXPRESSION';\n  var CONSTRUCT_SIGNATURE = 'CONSTRUCT_SIGNATURE';\n  var CONSTRUCTOR_TYPE = 'CONSTRUCTOR_TYPE';\n  var CONTINUE_STATEMENT = 'CONTINUE_STATEMENT';\n  var COVER_FORMALS = 'COVER_FORMALS';\n  var COVER_INITIALIZED_NAME = 'COVER_INITIALIZED_NAME';\n  var DEBUGGER_STATEMENT = 'DEBUGGER_STATEMENT';\n  var DEFAULT_CLAUSE = 'DEFAULT_CLAUSE';\n  var DO_WHILE_STATEMENT = 'DO_WHILE_STATEMENT';\n  var EMPTY_STATEMENT = 'EMPTY_STATEMENT';\n  var EXPORT_DECLARATION = 'EXPORT_DECLARATION';\n  var EXPORT_DEFAULT = 'EXPORT_DEFAULT';\n  var EXPORT_SPECIFIER = 'EXPORT_SPECIFIER';\n  var EXPORT_SPECIFIER_SET = 'EXPORT_SPECIFIER_SET';\n  var EXPORT_STAR = 'EXPORT_STAR';\n  var EXPRESSION_STATEMENT = 'EXPRESSION_STATEMENT';\n  var FINALLY = 'FINALLY';\n  var FOR_IN_STATEMENT = 'FOR_IN_STATEMENT';\n  var FOR_OF_STATEMENT = 'FOR_OF_STATEMENT';\n  var FOR_ON_STATEMENT = 'FOR_ON_STATEMENT';\n  var FOR_STATEMENT = 'FOR_STATEMENT';\n  var FORMAL_PARAMETER = 'FORMAL_PARAMETER';\n  var FORMAL_PARAMETER_LIST = 'FORMAL_PARAMETER_LIST';\n  var FORWARD_DEFAULT_EXPORT = 'FORWARD_DEFAULT_EXPORT';\n  var FUNCTION_BODY = 'FUNCTION_BODY';\n  var FUNCTION_DECLARATION = 'FUNCTION_DECLARATION';\n  var FUNCTION_EXPRESSION = 'FUNCTION_EXPRESSION';\n  var FUNCTION_TYPE = 'FUNCTION_TYPE';\n  var GENERATOR_COMPREHENSION = 'GENERATOR_COMPREHENSION';\n  var GET_ACCESSOR = 'GET_ACCESSOR';\n  var IDENTIFIER_EXPRESSION = 'IDENTIFIER_EXPRESSION';\n  var IF_STATEMENT = 'IF_STATEMENT';\n  var IMPORT_CLAUSE_PAIR = 'IMPORT_CLAUSE_PAIR';\n  var IMPORT_DECLARATION = 'IMPORT_DECLARATION';\n  var IMPORT_SPECIFIER = 'IMPORT_SPECIFIER';\n  var IMPORT_SPECIFIER_SET = 'IMPORT_SPECIFIER_SET';\n  var IMPORT_TYPE_CLAUSE = 'IMPORT_TYPE_CLAUSE';\n  var IMPORTED_BINDING = 'IMPORTED_BINDING';\n  var INDEX_SIGNATURE = 'INDEX_SIGNATURE';\n  var INTERFACE_DECLARATION = 'INTERFACE_DECLARATION';\n  var JSX_ATTRIBUTE = 'JSX_ATTRIBUTE';\n  var JSX_ELEMENT = 'JSX_ELEMENT';\n  var JSX_ELEMENT_NAME = 'JSX_ELEMENT_NAME';\n  var JSX_PLACEHOLDER = 'JSX_PLACEHOLDER';\n  var JSX_SPREAD_ATTRIBUTE = 'JSX_SPREAD_ATTRIBUTE';\n  var JSX_TEXT = 'JSX_TEXT';\n  var LABELLED_STATEMENT = 'LABELLED_STATEMENT';\n  var LITERAL_EXPRESSION = 'LITERAL_EXPRESSION';\n  var LITERAL_PROPERTY_NAME = 'LITERAL_PROPERTY_NAME';\n  var MEMBER_EXPRESSION = 'MEMBER_EXPRESSION';\n  var MEMBER_LOOKUP_EXPRESSION = 'MEMBER_LOOKUP_EXPRESSION';\n  var METHOD = 'METHOD';\n  var METHOD_SIGNATURE = 'METHOD_SIGNATURE';\n  var MODULE = 'MODULE';\n  var MODULE_SPECIFIER = 'MODULE_SPECIFIER';\n  var NAME_SPACE_EXPORT = 'NAME_SPACE_EXPORT';\n  var NAME_SPACE_IMPORT = 'NAME_SPACE_IMPORT';\n  var NAMED_EXPORT = 'NAMED_EXPORT';\n  var NEW_EXPRESSION = 'NEW_EXPRESSION';\n  var OBJECT_LITERAL = 'OBJECT_LITERAL';\n  var OBJECT_PATTERN = 'OBJECT_PATTERN';\n  var OBJECT_PATTERN_FIELD = 'OBJECT_PATTERN_FIELD';\n  var OBJECT_TYPE = 'OBJECT_TYPE';\n  var PAREN_EXPRESSION = 'PAREN_EXPRESSION';\n  var POSTFIX_EXPRESSION = 'POSTFIX_EXPRESSION';\n  var PREDEFINED_TYPE = 'PREDEFINED_TYPE';\n  var PROPERTY_NAME_ASSIGNMENT = 'PROPERTY_NAME_ASSIGNMENT';\n  var PROPERTY_NAME_SHORTHAND = 'PROPERTY_NAME_SHORTHAND';\n  var PROPERTY_SIGNATURE = 'PROPERTY_SIGNATURE';\n  var PROPERTY_VARIABLE_DECLARATION = 'PROPERTY_VARIABLE_DECLARATION';\n  var REST_PARAMETER = 'REST_PARAMETER';\n  var RETURN_STATEMENT = 'RETURN_STATEMENT';\n  var SCRIPT = 'SCRIPT';\n  var SET_ACCESSOR = 'SET_ACCESSOR';\n  var SPREAD_EXPRESSION = 'SPREAD_EXPRESSION';\n  var SPREAD_PATTERN_ELEMENT = 'SPREAD_PATTERN_ELEMENT';\n  var STATE_MACHINE = 'STATE_MACHINE';\n  var SUPER_EXPRESSION = 'SUPER_EXPRESSION';\n  var SWITCH_STATEMENT = 'SWITCH_STATEMENT';\n  var SYNTAX_ERROR_TREE = 'SYNTAX_ERROR_TREE';\n  var TEMPLATE_LITERAL_EXPRESSION = 'TEMPLATE_LITERAL_EXPRESSION';\n  var TEMPLATE_LITERAL_PORTION = 'TEMPLATE_LITERAL_PORTION';\n  var TEMPLATE_SUBSTITUTION = 'TEMPLATE_SUBSTITUTION';\n  var THIS_EXPRESSION = 'THIS_EXPRESSION';\n  var THROW_STATEMENT = 'THROW_STATEMENT';\n  var TRY_STATEMENT = 'TRY_STATEMENT';\n  var TYPE_ALIAS_DECLARATION = 'TYPE_ALIAS_DECLARATION';\n  var TYPE_ARGUMENTS = 'TYPE_ARGUMENTS';\n  var TYPE_NAME = 'TYPE_NAME';\n  var TYPE_PARAMETER = 'TYPE_PARAMETER';\n  var TYPE_PARAMETERS = 'TYPE_PARAMETERS';\n  var TYPE_REFERENCE = 'TYPE_REFERENCE';\n  var UNARY_EXPRESSION = 'UNARY_EXPRESSION';\n  var UNION_TYPE = 'UNION_TYPE';\n  var VARIABLE_DECLARATION = 'VARIABLE_DECLARATION';\n  var VARIABLE_DECLARATION_LIST = 'VARIABLE_DECLARATION_LIST';\n  var VARIABLE_STATEMENT = 'VARIABLE_STATEMENT';\n  var WHILE_STATEMENT = 'WHILE_STATEMENT';\n  var WITH_STATEMENT = 'WITH_STATEMENT';\n  var YIELD_EXPRESSION = 'YIELD_EXPRESSION';\n  return {\n    get ANNOTATION() {\n      return ANNOTATION;\n    },\n    get ANON_BLOCK() {\n      return ANON_BLOCK;\n    },\n    get ARGUMENT_LIST() {\n      return ARGUMENT_LIST;\n    },\n    get ARRAY_COMPREHENSION() {\n      return ARRAY_COMPREHENSION;\n    },\n    get ARRAY_LITERAL() {\n      return ARRAY_LITERAL;\n    },\n    get ARRAY_PATTERN() {\n      return ARRAY_PATTERN;\n    },\n    get ARRAY_TYPE() {\n      return ARRAY_TYPE;\n    },\n    get ARROW_FUNCTION() {\n      return ARROW_FUNCTION;\n    },\n    get ASSIGNMENT_ELEMENT() {\n      return ASSIGNMENT_ELEMENT;\n    },\n    get AWAIT_EXPRESSION() {\n      return AWAIT_EXPRESSION;\n    },\n    get BINARY_EXPRESSION() {\n      return BINARY_EXPRESSION;\n    },\n    get BINDING_ELEMENT() {\n      return BINDING_ELEMENT;\n    },\n    get BINDING_IDENTIFIER() {\n      return BINDING_IDENTIFIER;\n    },\n    get BLOCK() {\n      return BLOCK;\n    },\n    get BREAK_STATEMENT() {\n      return BREAK_STATEMENT;\n    },\n    get CALL_EXPRESSION() {\n      return CALL_EXPRESSION;\n    },\n    get CALL_SIGNATURE() {\n      return CALL_SIGNATURE;\n    },\n    get CASE_CLAUSE() {\n      return CASE_CLAUSE;\n    },\n    get CATCH() {\n      return CATCH;\n    },\n    get CLASS_DECLARATION() {\n      return CLASS_DECLARATION;\n    },\n    get CLASS_EXPRESSION() {\n      return CLASS_EXPRESSION;\n    },\n    get COMMA_EXPRESSION() {\n      return COMMA_EXPRESSION;\n    },\n    get COMPREHENSION_FOR() {\n      return COMPREHENSION_FOR;\n    },\n    get COMPREHENSION_IF() {\n      return COMPREHENSION_IF;\n    },\n    get COMPUTED_PROPERTY_NAME() {\n      return COMPUTED_PROPERTY_NAME;\n    },\n    get CONDITIONAL_EXPRESSION() {\n      return CONDITIONAL_EXPRESSION;\n    },\n    get CONSTRUCT_SIGNATURE() {\n      return CONSTRUCT_SIGNATURE;\n    },\n    get CONSTRUCTOR_TYPE() {\n      return CONSTRUCTOR_TYPE;\n    },\n    get CONTINUE_STATEMENT() {\n      return CONTINUE_STATEMENT;\n    },\n    get COVER_FORMALS() {\n      return COVER_FORMALS;\n    },\n    get COVER_INITIALIZED_NAME() {\n      return COVER_INITIALIZED_NAME;\n    },\n    get DEBUGGER_STATEMENT() {\n      return DEBUGGER_STATEMENT;\n    },\n    get DEFAULT_CLAUSE() {\n      return DEFAULT_CLAUSE;\n    },\n    get DO_WHILE_STATEMENT() {\n      return DO_WHILE_STATEMENT;\n    },\n    get EMPTY_STATEMENT() {\n      return EMPTY_STATEMENT;\n    },\n    get EXPORT_DECLARATION() {\n      return EXPORT_DECLARATION;\n    },\n    get EXPORT_DEFAULT() {\n      return EXPORT_DEFAULT;\n    },\n    get EXPORT_SPECIFIER() {\n      return EXPORT_SPECIFIER;\n    },\n    get EXPORT_SPECIFIER_SET() {\n      return EXPORT_SPECIFIER_SET;\n    },\n    get EXPORT_STAR() {\n      return EXPORT_STAR;\n    },\n    get EXPRESSION_STATEMENT() {\n      return EXPRESSION_STATEMENT;\n    },\n    get FINALLY() {\n      return FINALLY;\n    },\n    get FOR_IN_STATEMENT() {\n      return FOR_IN_STATEMENT;\n    },\n    get FOR_OF_STATEMENT() {\n      return FOR_OF_STATEMENT;\n    },\n    get FOR_ON_STATEMENT() {\n      return FOR_ON_STATEMENT;\n    },\n    get FOR_STATEMENT() {\n      return FOR_STATEMENT;\n    },\n    get FORMAL_PARAMETER() {\n      return FORMAL_PARAMETER;\n    },\n    get FORMAL_PARAMETER_LIST() {\n      return FORMAL_PARAMETER_LIST;\n    },\n    get FORWARD_DEFAULT_EXPORT() {\n      return FORWARD_DEFAULT_EXPORT;\n    },\n    get FUNCTION_BODY() {\n      return FUNCTION_BODY;\n    },\n    get FUNCTION_DECLARATION() {\n      return FUNCTION_DECLARATION;\n    },\n    get FUNCTION_EXPRESSION() {\n      return FUNCTION_EXPRESSION;\n    },\n    get FUNCTION_TYPE() {\n      return FUNCTION_TYPE;\n    },\n    get GENERATOR_COMPREHENSION() {\n      return GENERATOR_COMPREHENSION;\n    },\n    get GET_ACCESSOR() {\n      return GET_ACCESSOR;\n    },\n    get IDENTIFIER_EXPRESSION() {\n      return IDENTIFIER_EXPRESSION;\n    },\n    get IF_STATEMENT() {\n      return IF_STATEMENT;\n    },\n    get IMPORT_CLAUSE_PAIR() {\n      return IMPORT_CLAUSE_PAIR;\n    },\n    get IMPORT_DECLARATION() {\n      return IMPORT_DECLARATION;\n    },\n    get IMPORT_SPECIFIER() {\n      return IMPORT_SPECIFIER;\n    },\n    get IMPORT_SPECIFIER_SET() {\n      return IMPORT_SPECIFIER_SET;\n    },\n    get IMPORT_TYPE_CLAUSE() {\n      return IMPORT_TYPE_CLAUSE;\n    },\n    get IMPORTED_BINDING() {\n      return IMPORTED_BINDING;\n    },\n    get INDEX_SIGNATURE() {\n      return INDEX_SIGNATURE;\n    },\n    get INTERFACE_DECLARATION() {\n      return INTERFACE_DECLARATION;\n    },\n    get JSX_ATTRIBUTE() {\n      return JSX_ATTRIBUTE;\n    },\n    get JSX_ELEMENT() {\n      return JSX_ELEMENT;\n    },\n    get JSX_ELEMENT_NAME() {\n      return JSX_ELEMENT_NAME;\n    },\n    get JSX_PLACEHOLDER() {\n      return JSX_PLACEHOLDER;\n    },\n    get JSX_SPREAD_ATTRIBUTE() {\n      return JSX_SPREAD_ATTRIBUTE;\n    },\n    get JSX_TEXT() {\n      return JSX_TEXT;\n    },\n    get LABELLED_STATEMENT() {\n      return LABELLED_STATEMENT;\n    },\n    get LITERAL_EXPRESSION() {\n      return LITERAL_EXPRESSION;\n    },\n    get LITERAL_PROPERTY_NAME() {\n      return LITERAL_PROPERTY_NAME;\n    },\n    get MEMBER_EXPRESSION() {\n      return MEMBER_EXPRESSION;\n    },\n    get MEMBER_LOOKUP_EXPRESSION() {\n      return MEMBER_LOOKUP_EXPRESSION;\n    },\n    get METHOD() {\n      return METHOD;\n    },\n    get METHOD_SIGNATURE() {\n      return METHOD_SIGNATURE;\n    },\n    get MODULE() {\n      return MODULE;\n    },\n    get MODULE_SPECIFIER() {\n      return MODULE_SPECIFIER;\n    },\n    get NAME_SPACE_EXPORT() {\n      return NAME_SPACE_EXPORT;\n    },\n    get NAME_SPACE_IMPORT() {\n      return NAME_SPACE_IMPORT;\n    },\n    get NAMED_EXPORT() {\n      return NAMED_EXPORT;\n    },\n    get NEW_EXPRESSION() {\n      return NEW_EXPRESSION;\n    },\n    get OBJECT_LITERAL() {\n      return OBJECT_LITERAL;\n    },\n    get OBJECT_PATTERN() {\n      return OBJECT_PATTERN;\n    },\n    get OBJECT_PATTERN_FIELD() {\n      return OBJECT_PATTERN_FIELD;\n    },\n    get OBJECT_TYPE() {\n      return OBJECT_TYPE;\n    },\n    get PAREN_EXPRESSION() {\n      return PAREN_EXPRESSION;\n    },\n    get POSTFIX_EXPRESSION() {\n      return POSTFIX_EXPRESSION;\n    },\n    get PREDEFINED_TYPE() {\n      return PREDEFINED_TYPE;\n    },\n    get PROPERTY_NAME_ASSIGNMENT() {\n      return PROPERTY_NAME_ASSIGNMENT;\n    },\n    get PROPERTY_NAME_SHORTHAND() {\n      return PROPERTY_NAME_SHORTHAND;\n    },\n    get PROPERTY_SIGNATURE() {\n      return PROPERTY_SIGNATURE;\n    },\n    get PROPERTY_VARIABLE_DECLARATION() {\n      return PROPERTY_VARIABLE_DECLARATION;\n    },\n    get REST_PARAMETER() {\n      return REST_PARAMETER;\n    },\n    get RETURN_STATEMENT() {\n      return RETURN_STATEMENT;\n    },\n    get SCRIPT() {\n      return SCRIPT;\n    },\n    get SET_ACCESSOR() {\n      return SET_ACCESSOR;\n    },\n    get SPREAD_EXPRESSION() {\n      return SPREAD_EXPRESSION;\n    },\n    get SPREAD_PATTERN_ELEMENT() {\n      return SPREAD_PATTERN_ELEMENT;\n    },\n    get STATE_MACHINE() {\n      return STATE_MACHINE;\n    },\n    get SUPER_EXPRESSION() {\n      return SUPER_EXPRESSION;\n    },\n    get SWITCH_STATEMENT() {\n      return SWITCH_STATEMENT;\n    },\n    get SYNTAX_ERROR_TREE() {\n      return SYNTAX_ERROR_TREE;\n    },\n    get TEMPLATE_LITERAL_EXPRESSION() {\n      return TEMPLATE_LITERAL_EXPRESSION;\n    },\n    get TEMPLATE_LITERAL_PORTION() {\n      return TEMPLATE_LITERAL_PORTION;\n    },\n    get TEMPLATE_SUBSTITUTION() {\n      return TEMPLATE_SUBSTITUTION;\n    },\n    get THIS_EXPRESSION() {\n      return THIS_EXPRESSION;\n    },\n    get THROW_STATEMENT() {\n      return THROW_STATEMENT;\n    },\n    get TRY_STATEMENT() {\n      return TRY_STATEMENT;\n    },\n    get TYPE_ALIAS_DECLARATION() {\n      return TYPE_ALIAS_DECLARATION;\n    },\n    get TYPE_ARGUMENTS() {\n      return TYPE_ARGUMENTS;\n    },\n    get TYPE_NAME() {\n      return TYPE_NAME;\n    },\n    get TYPE_PARAMETER() {\n      return TYPE_PARAMETER;\n    },\n    get TYPE_PARAMETERS() {\n      return TYPE_PARAMETERS;\n    },\n    get TYPE_REFERENCE() {\n      return TYPE_REFERENCE;\n    },\n    get UNARY_EXPRESSION() {\n      return UNARY_EXPRESSION;\n    },\n    get UNION_TYPE() {\n      return UNION_TYPE;\n    },\n    get VARIABLE_DECLARATION() {\n      return VARIABLE_DECLARATION;\n    },\n    get VARIABLE_DECLARATION_LIST() {\n      return VARIABLE_DECLARATION_LIST;\n    },\n    get VARIABLE_STATEMENT() {\n      return VARIABLE_STATEMENT;\n    },\n    get WHILE_STATEMENT() {\n      return WHILE_STATEMENT;\n    },\n    get WITH_STATEMENT() {\n      return WITH_STATEMENT;\n    },\n    get YIELD_EXPRESSION() {\n      return YIELD_EXPRESSION;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/TokenType.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/TokenType.js\";\n  var AMPERSAND = '&';\n  var AMPERSAND_EQUAL = '&=';\n  var AND = '&&';\n  var ARROW = '=>';\n  var AT = '@';\n  var BACK_QUOTE = '`';\n  var BANG = '!';\n  var BAR = '|';\n  var BAR_EQUAL = '|=';\n  var BREAK = 'break';\n  var CARET = '^';\n  var CARET_EQUAL = '^=';\n  var CASE = 'case';\n  var CATCH = 'catch';\n  var CLASS = 'class';\n  var CLOSE_ANGLE = '>';\n  var CLOSE_CURLY = '}';\n  var CLOSE_PAREN = ')';\n  var CLOSE_SQUARE = ']';\n  var COLON = ':';\n  var COMMA = ',';\n  var CONST = 'const';\n  var CONTINUE = 'continue';\n  var DEBUGGER = 'debugger';\n  var DEFAULT = 'default';\n  var DELETE = 'delete';\n  var DO = 'do';\n  var DOT_DOT_DOT = '...';\n  var ELSE = 'else';\n  var END_OF_FILE = 'End of File';\n  var ENUM = 'enum';\n  var EQUAL = '=';\n  var EQUAL_EQUAL = '==';\n  var EQUAL_EQUAL_EQUAL = '===';\n  var ERROR = 'error';\n  var EXPORT = 'export';\n  var EXTENDS = 'extends';\n  var FALSE = 'false';\n  var FINALLY = 'finally';\n  var FOR = 'for';\n  var FUNCTION = 'function';\n  var GREATER_EQUAL = '>=';\n  var IDENTIFIER = 'identifier';\n  var IF = 'if';\n  var IMPLEMENTS = 'implements';\n  var IMPORT = 'import';\n  var IN = 'in';\n  var INSTANCEOF = 'instanceof';\n  var INTERFACE = 'interface';\n  var JSX_IDENTIFIER = 'jsx identifier';\n  var LEFT_SHIFT = '<<';\n  var LEFT_SHIFT_EQUAL = '<<=';\n  var LESS_EQUAL = '<=';\n  var LET = 'let';\n  var MINUS = '-';\n  var MINUS_EQUAL = '-=';\n  var MINUS_MINUS = '--';\n  var NEW = 'new';\n  var NO_SUBSTITUTION_TEMPLATE = 'no substitution template';\n  var NOT_EQUAL = '!=';\n  var NOT_EQUAL_EQUAL = '!==';\n  var NULL = 'null';\n  var NUMBER = 'number literal';\n  var OPEN_ANGLE = '<';\n  var OPEN_CURLY = '{';\n  var OPEN_PAREN = '(';\n  var OPEN_SQUARE = '[';\n  var OR = '||';\n  var PACKAGE = 'package';\n  var PERCENT = '%';\n  var PERCENT_EQUAL = '%=';\n  var PERIOD = '.';\n  var PLUS = '+';\n  var PLUS_EQUAL = '+=';\n  var PLUS_PLUS = '++';\n  var PRIVATE = 'private';\n  var PROTECTED = 'protected';\n  var PUBLIC = 'public';\n  var QUESTION = '?';\n  var REGULAR_EXPRESSION = 'regular expression literal';\n  var RETURN = 'return';\n  var RIGHT_SHIFT = '>>';\n  var RIGHT_SHIFT_EQUAL = '>>=';\n  var SEMI_COLON = ';';\n  var SLASH = '/';\n  var SLASH_EQUAL = '/=';\n  var STAR = '*';\n  var STAR_EQUAL = '*=';\n  var STAR_STAR = '**';\n  var STAR_STAR_EQUAL = '**=';\n  var STATIC = 'static';\n  var STRING = 'string literal';\n  var SUPER = 'super';\n  var SWITCH = 'switch';\n  var TEMPLATE_HEAD = 'template head';\n  var TEMPLATE_MIDDLE = 'template middle';\n  var TEMPLATE_TAIL = 'template tail';\n  var THIS = 'this';\n  var THROW = 'throw';\n  var TILDE = '~';\n  var TRUE = 'true';\n  var TRY = 'try';\n  var TYPEOF = 'typeof';\n  var UNSIGNED_RIGHT_SHIFT = '>>>';\n  var UNSIGNED_RIGHT_SHIFT_EQUAL = '>>>=';\n  var VAR = 'var';\n  var VOID = 'void';\n  var WHILE = 'while';\n  var WITH = 'with';\n  var YIELD = 'yield';\n  return {\n    get AMPERSAND() {\n      return AMPERSAND;\n    },\n    get AMPERSAND_EQUAL() {\n      return AMPERSAND_EQUAL;\n    },\n    get AND() {\n      return AND;\n    },\n    get ARROW() {\n      return ARROW;\n    },\n    get AT() {\n      return AT;\n    },\n    get BACK_QUOTE() {\n      return BACK_QUOTE;\n    },\n    get BANG() {\n      return BANG;\n    },\n    get BAR() {\n      return BAR;\n    },\n    get BAR_EQUAL() {\n      return BAR_EQUAL;\n    },\n    get BREAK() {\n      return BREAK;\n    },\n    get CARET() {\n      return CARET;\n    },\n    get CARET_EQUAL() {\n      return CARET_EQUAL;\n    },\n    get CASE() {\n      return CASE;\n    },\n    get CATCH() {\n      return CATCH;\n    },\n    get CLASS() {\n      return CLASS;\n    },\n    get CLOSE_ANGLE() {\n      return CLOSE_ANGLE;\n    },\n    get CLOSE_CURLY() {\n      return CLOSE_CURLY;\n    },\n    get CLOSE_PAREN() {\n      return CLOSE_PAREN;\n    },\n    get CLOSE_SQUARE() {\n      return CLOSE_SQUARE;\n    },\n    get COLON() {\n      return COLON;\n    },\n    get COMMA() {\n      return COMMA;\n    },\n    get CONST() {\n      return CONST;\n    },\n    get CONTINUE() {\n      return CONTINUE;\n    },\n    get DEBUGGER() {\n      return DEBUGGER;\n    },\n    get DEFAULT() {\n      return DEFAULT;\n    },\n    get DELETE() {\n      return DELETE;\n    },\n    get DO() {\n      return DO;\n    },\n    get DOT_DOT_DOT() {\n      return DOT_DOT_DOT;\n    },\n    get ELSE() {\n      return ELSE;\n    },\n    get END_OF_FILE() {\n      return END_OF_FILE;\n    },\n    get ENUM() {\n      return ENUM;\n    },\n    get EQUAL() {\n      return EQUAL;\n    },\n    get EQUAL_EQUAL() {\n      return EQUAL_EQUAL;\n    },\n    get EQUAL_EQUAL_EQUAL() {\n      return EQUAL_EQUAL_EQUAL;\n    },\n    get ERROR() {\n      return ERROR;\n    },\n    get EXPORT() {\n      return EXPORT;\n    },\n    get EXTENDS() {\n      return EXTENDS;\n    },\n    get FALSE() {\n      return FALSE;\n    },\n    get FINALLY() {\n      return FINALLY;\n    },\n    get FOR() {\n      return FOR;\n    },\n    get FUNCTION() {\n      return FUNCTION;\n    },\n    get GREATER_EQUAL() {\n      return GREATER_EQUAL;\n    },\n    get IDENTIFIER() {\n      return IDENTIFIER;\n    },\n    get IF() {\n      return IF;\n    },\n    get IMPLEMENTS() {\n      return IMPLEMENTS;\n    },\n    get IMPORT() {\n      return IMPORT;\n    },\n    get IN() {\n      return IN;\n    },\n    get INSTANCEOF() {\n      return INSTANCEOF;\n    },\n    get INTERFACE() {\n      return INTERFACE;\n    },\n    get JSX_IDENTIFIER() {\n      return JSX_IDENTIFIER;\n    },\n    get LEFT_SHIFT() {\n      return LEFT_SHIFT;\n    },\n    get LEFT_SHIFT_EQUAL() {\n      return LEFT_SHIFT_EQUAL;\n    },\n    get LESS_EQUAL() {\n      return LESS_EQUAL;\n    },\n    get LET() {\n      return LET;\n    },\n    get MINUS() {\n      return MINUS;\n    },\n    get MINUS_EQUAL() {\n      return MINUS_EQUAL;\n    },\n    get MINUS_MINUS() {\n      return MINUS_MINUS;\n    },\n    get NEW() {\n      return NEW;\n    },\n    get NO_SUBSTITUTION_TEMPLATE() {\n      return NO_SUBSTITUTION_TEMPLATE;\n    },\n    get NOT_EQUAL() {\n      return NOT_EQUAL;\n    },\n    get NOT_EQUAL_EQUAL() {\n      return NOT_EQUAL_EQUAL;\n    },\n    get NULL() {\n      return NULL;\n    },\n    get NUMBER() {\n      return NUMBER;\n    },\n    get OPEN_ANGLE() {\n      return OPEN_ANGLE;\n    },\n    get OPEN_CURLY() {\n      return OPEN_CURLY;\n    },\n    get OPEN_PAREN() {\n      return OPEN_PAREN;\n    },\n    get OPEN_SQUARE() {\n      return OPEN_SQUARE;\n    },\n    get OR() {\n      return OR;\n    },\n    get PACKAGE() {\n      return PACKAGE;\n    },\n    get PERCENT() {\n      return PERCENT;\n    },\n    get PERCENT_EQUAL() {\n      return PERCENT_EQUAL;\n    },\n    get PERIOD() {\n      return PERIOD;\n    },\n    get PLUS() {\n      return PLUS;\n    },\n    get PLUS_EQUAL() {\n      return PLUS_EQUAL;\n    },\n    get PLUS_PLUS() {\n      return PLUS_PLUS;\n    },\n    get PRIVATE() {\n      return PRIVATE;\n    },\n    get PROTECTED() {\n      return PROTECTED;\n    },\n    get PUBLIC() {\n      return PUBLIC;\n    },\n    get QUESTION() {\n      return QUESTION;\n    },\n    get REGULAR_EXPRESSION() {\n      return REGULAR_EXPRESSION;\n    },\n    get RETURN() {\n      return RETURN;\n    },\n    get RIGHT_SHIFT() {\n      return RIGHT_SHIFT;\n    },\n    get RIGHT_SHIFT_EQUAL() {\n      return RIGHT_SHIFT_EQUAL;\n    },\n    get SEMI_COLON() {\n      return SEMI_COLON;\n    },\n    get SLASH() {\n      return SLASH;\n    },\n    get SLASH_EQUAL() {\n      return SLASH_EQUAL;\n    },\n    get STAR() {\n      return STAR;\n    },\n    get STAR_EQUAL() {\n      return STAR_EQUAL;\n    },\n    get STAR_STAR() {\n      return STAR_STAR;\n    },\n    get STAR_STAR_EQUAL() {\n      return STAR_STAR_EQUAL;\n    },\n    get STATIC() {\n      return STATIC;\n    },\n    get STRING() {\n      return STRING;\n    },\n    get SUPER() {\n      return SUPER;\n    },\n    get SWITCH() {\n      return SWITCH;\n    },\n    get TEMPLATE_HEAD() {\n      return TEMPLATE_HEAD;\n    },\n    get TEMPLATE_MIDDLE() {\n      return TEMPLATE_MIDDLE;\n    },\n    get TEMPLATE_TAIL() {\n      return TEMPLATE_TAIL;\n    },\n    get THIS() {\n      return THIS;\n    },\n    get THROW() {\n      return THROW;\n    },\n    get TILDE() {\n      return TILDE;\n    },\n    get TRUE() {\n      return TRUE;\n    },\n    get TRY() {\n      return TRY;\n    },\n    get TYPEOF() {\n      return TYPEOF;\n    },\n    get UNSIGNED_RIGHT_SHIFT() {\n      return UNSIGNED_RIGHT_SHIFT;\n    },\n    get UNSIGNED_RIGHT_SHIFT_EQUAL() {\n      return UNSIGNED_RIGHT_SHIFT_EQUAL;\n    },\n    get VAR() {\n      return VAR;\n    },\n    get VOID() {\n      return VOID;\n    },\n    get WHILE() {\n      return WHILE;\n    },\n    get WITH() {\n      return WITH;\n    },\n    get YIELD() {\n      return YIELD;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/Token.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/Token.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/Token.js\")),\n      AMPERSAND_EQUAL = $__1.AMPERSAND_EQUAL,\n      BAR_EQUAL = $__1.BAR_EQUAL,\n      CARET_EQUAL = $__1.CARET_EQUAL,\n      EQUAL = $__1.EQUAL,\n      LEFT_SHIFT_EQUAL = $__1.LEFT_SHIFT_EQUAL,\n      MINUS_EQUAL = $__1.MINUS_EQUAL,\n      PERCENT_EQUAL = $__1.PERCENT_EQUAL,\n      PLUS_EQUAL = $__1.PLUS_EQUAL,\n      RIGHT_SHIFT_EQUAL = $__1.RIGHT_SHIFT_EQUAL,\n      SLASH_EQUAL = $__1.SLASH_EQUAL,\n      STAR_EQUAL = $__1.STAR_EQUAL,\n      STAR_STAR_EQUAL = $__1.STAR_STAR_EQUAL,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__1.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  var Token = function() {\n    function Token(type, location) {\n      this.type = type;\n      this.location = location;\n    }\n    return ($traceurRuntime.createClass)(Token, {\n      toString: function() {\n        return this.type;\n      },\n      isAssignmentOperator: function() {\n        return isAssignmentOperator(this.type);\n      },\n      isKeyword: function() {\n        return false;\n      },\n      isStrictKeyword: function() {\n        return false;\n      }\n    }, {});\n  }();\n  function isAssignmentOperator(type) {\n    switch (type) {\n      case AMPERSAND_EQUAL:\n      case BAR_EQUAL:\n      case CARET_EQUAL:\n      case EQUAL:\n      case LEFT_SHIFT_EQUAL:\n      case MINUS_EQUAL:\n      case PERCENT_EQUAL:\n      case PLUS_EQUAL:\n      case RIGHT_SHIFT_EQUAL:\n      case SLASH_EQUAL:\n      case STAR_EQUAL:\n      case STAR_STAR_EQUAL:\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        return true;\n    }\n    return false;\n  }\n  return {\n    get Token() {\n      return Token;\n    },\n    get isAssignmentOperator() {\n      return isAssignmentOperator;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/JSON.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/JSON.js\";\n  function transform(v) {\n    var replacer = arguments[1] !== (void 0) ? arguments[1] : function(k, v) {\n      return v;\n    };\n    return transform_(replacer('', v), replacer);\n  }\n  function transform_(v, replacer) {\n    var rv,\n        tv;\n    if (Array.isArray(v)) {\n      var len = v.length;\n      rv = Array(len);\n      for (var i = 0; i < len; i++) {\n        tv = transform_(replacer(String(i), v[i]), replacer);\n        rv[i] = tv === undefined ? null : tv;\n      }\n      return rv;\n    }\n    if (v instanceof Object) {\n      rv = {};\n      Object.keys(v).forEach(function(k) {\n        tv = transform_(replacer(k, v[k]), replacer);\n        if (tv !== undefined) {\n          rv[k] = tv;\n        }\n      });\n      return rv;\n    }\n    return v;\n  }\n  return {get transform() {\n      return transform;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/PredefinedName.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/PredefinedName.js\";\n  var $ARGUMENTS = '$arguments';\n  var ANY = 'any';\n  var APPLY = 'apply';\n  var ARGUMENTS = 'arguments';\n  var ARRAY = 'Array';\n  var AS = 'as';\n  var ASYNC = 'async';\n  var ASYNC_STAR = 'async star';\n  var AWAIT = 'await';\n  var BIND = 'bind';\n  var CALL = 'call';\n  var CONFIGURABLE = 'configurable';\n  var CONSTRUCTOR = 'constructor';\n  var CREATE = 'create';\n  var CURRENT = 'current';\n  var DEFINE_PROPERTY = 'defineProperty';\n  var ENUMERABLE = 'enumerable';\n  var FREEZE = 'freeze';\n  var FROM = 'from';\n  var FUNCTION = 'Function';\n  var GET = 'get';\n  var HAS = 'has';\n  var LENGTH = 'length';\n  var MODULE = 'module';\n  var NEW = 'new';\n  var OBJECT = 'Object';\n  var OBJECT_NAME = 'Object';\n  var OF = 'of';\n  var ON = 'on';\n  var PREVENT_EXTENSIONS = 'preventExtensions';\n  var PROTOTYPE = 'prototype';\n  var PUSH = 'push';\n  var SET = 'set';\n  var SLICE = 'slice';\n  var THIS = 'this';\n  var TRACEUR_RUNTIME = '$traceurRuntime';\n  var TYPE = 'type';\n  var UNDEFINED = 'undefined';\n  var WRITABLE = 'writable';\n  return {\n    get $ARGUMENTS() {\n      return $ARGUMENTS;\n    },\n    get ANY() {\n      return ANY;\n    },\n    get APPLY() {\n      return APPLY;\n    },\n    get ARGUMENTS() {\n      return ARGUMENTS;\n    },\n    get ARRAY() {\n      return ARRAY;\n    },\n    get AS() {\n      return AS;\n    },\n    get ASYNC() {\n      return ASYNC;\n    },\n    get ASYNC_STAR() {\n      return ASYNC_STAR;\n    },\n    get AWAIT() {\n      return AWAIT;\n    },\n    get BIND() {\n      return BIND;\n    },\n    get CALL() {\n      return CALL;\n    },\n    get CONFIGURABLE() {\n      return CONFIGURABLE;\n    },\n    get CONSTRUCTOR() {\n      return CONSTRUCTOR;\n    },\n    get CREATE() {\n      return CREATE;\n    },\n    get CURRENT() {\n      return CURRENT;\n    },\n    get DEFINE_PROPERTY() {\n      return DEFINE_PROPERTY;\n    },\n    get ENUMERABLE() {\n      return ENUMERABLE;\n    },\n    get FREEZE() {\n      return FREEZE;\n    },\n    get FROM() {\n      return FROM;\n    },\n    get FUNCTION() {\n      return FUNCTION;\n    },\n    get GET() {\n      return GET;\n    },\n    get HAS() {\n      return HAS;\n    },\n    get LENGTH() {\n      return LENGTH;\n    },\n    get MODULE() {\n      return MODULE;\n    },\n    get NEW() {\n      return NEW;\n    },\n    get OBJECT() {\n      return OBJECT;\n    },\n    get OBJECT_NAME() {\n      return OBJECT_NAME;\n    },\n    get OF() {\n      return OF;\n    },\n    get ON() {\n      return ON;\n    },\n    get PREVENT_EXTENSIONS() {\n      return PREVENT_EXTENSIONS;\n    },\n    get PROTOTYPE() {\n      return PROTOTYPE;\n    },\n    get PUSH() {\n      return PUSH;\n    },\n    get SET() {\n      return SET;\n    },\n    get SLICE() {\n      return SLICE;\n    },\n    get THIS() {\n      return THIS;\n    },\n    get TRACEUR_RUNTIME() {\n      return TRACEUR_RUNTIME;\n    },\n    get TYPE() {\n      return TYPE;\n    },\n    get UNDEFINED() {\n      return UNDEFINED;\n    },\n    get WRITABLE() {\n      return WRITABLE;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/trees/ParseTree.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/trees/ParseTree.js\";\n  var ParseTreeType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeType.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\"));\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../TokenType.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\")),\n      IDENTIFIER = $__2.IDENTIFIER,\n      STAR = $__2.STAR,\n      STRING = $__2.STRING,\n      VAR = $__2.VAR;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Token.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\")).Token;\n  var utilJSON = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/JSON.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\"));\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PredefinedName.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\")),\n      ASYNC = $__4.ASYNC,\n      ASYNC_STAR = $__4.ASYNC_STAR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeType.js\", \"traceur@0.0.111/src/syntax/trees/ParseTree.js\")),\n      ARRAY_COMPREHENSION = $__5.ARRAY_COMPREHENSION,\n      ARRAY_LITERAL = $__5.ARRAY_LITERAL,\n      ARRAY_PATTERN = $__5.ARRAY_PATTERN,\n      ARROW_FUNCTION = $__5.ARROW_FUNCTION,\n      AWAIT_EXPRESSION = $__5.AWAIT_EXPRESSION,\n      BINARY_EXPRESSION = $__5.BINARY_EXPRESSION,\n      BINDING_IDENTIFIER = $__5.BINDING_IDENTIFIER,\n      BLOCK = $__5.BLOCK,\n      BREAK_STATEMENT = $__5.BREAK_STATEMENT,\n      CALL_EXPRESSION = $__5.CALL_EXPRESSION,\n      CLASS_DECLARATION = $__5.CLASS_DECLARATION,\n      CLASS_EXPRESSION = $__5.CLASS_EXPRESSION,\n      COMMA_EXPRESSION = $__5.COMMA_EXPRESSION,\n      CONDITIONAL_EXPRESSION = $__5.CONDITIONAL_EXPRESSION,\n      CONSTRUCTOR_TYPE = $__5.CONSTRUCTOR_TYPE,\n      CONTINUE_STATEMENT = $__5.CONTINUE_STATEMENT,\n      DEBUGGER_STATEMENT = $__5.DEBUGGER_STATEMENT,\n      DO_WHILE_STATEMENT = $__5.DO_WHILE_STATEMENT,\n      EMPTY_STATEMENT = $__5.EMPTY_STATEMENT,\n      EXPORT_DECLARATION = $__5.EXPORT_DECLARATION,\n      EXPRESSION_STATEMENT = $__5.EXPRESSION_STATEMENT,\n      FOR_IN_STATEMENT = $__5.FOR_IN_STATEMENT,\n      FOR_OF_STATEMENT = $__5.FOR_OF_STATEMENT,\n      FOR_ON_STATEMENT = $__5.FOR_ON_STATEMENT,\n      FOR_STATEMENT = $__5.FOR_STATEMENT,\n      FORMAL_PARAMETER = $__5.FORMAL_PARAMETER,\n      FUNCTION_DECLARATION = $__5.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__5.FUNCTION_EXPRESSION,\n      FUNCTION_TYPE = $__5.FUNCTION_TYPE,\n      GENERATOR_COMPREHENSION = $__5.GENERATOR_COMPREHENSION,\n      IDENTIFIER_EXPRESSION = $__5.IDENTIFIER_EXPRESSION,\n      IF_STATEMENT = $__5.IF_STATEMENT,\n      IMPORT_DECLARATION = $__5.IMPORT_DECLARATION,\n      IMPORTED_BINDING = $__5.IMPORTED_BINDING,\n      INTERFACE_DECLARATION = $__5.INTERFACE_DECLARATION,\n      JSX_ELEMENT = $__5.JSX_ELEMENT,\n      LABELLED_STATEMENT = $__5.LABELLED_STATEMENT,\n      LITERAL_EXPRESSION = $__5.LITERAL_EXPRESSION,\n      LITERAL_PROPERTY_NAME = $__5.LITERAL_PROPERTY_NAME,\n      MEMBER_EXPRESSION = $__5.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__5.MEMBER_LOOKUP_EXPRESSION,\n      NEW_EXPRESSION = $__5.NEW_EXPRESSION,\n      OBJECT_LITERAL = $__5.OBJECT_LITERAL,\n      OBJECT_PATTERN = $__5.OBJECT_PATTERN,\n      OBJECT_TYPE = $__5.OBJECT_TYPE,\n      PAREN_EXPRESSION = $__5.PAREN_EXPRESSION,\n      POSTFIX_EXPRESSION = $__5.POSTFIX_EXPRESSION,\n      PREDEFINED_TYPE = $__5.PREDEFINED_TYPE,\n      PROPERTY_NAME_SHORTHAND = $__5.PROPERTY_NAME_SHORTHAND,\n      REST_PARAMETER = $__5.REST_PARAMETER,\n      RETURN_STATEMENT = $__5.RETURN_STATEMENT,\n      SPREAD_EXPRESSION = $__5.SPREAD_EXPRESSION,\n      SPREAD_PATTERN_ELEMENT = $__5.SPREAD_PATTERN_ELEMENT,\n      SUPER_EXPRESSION = $__5.SUPER_EXPRESSION,\n      SWITCH_STATEMENT = $__5.SWITCH_STATEMENT,\n      TEMPLATE_LITERAL_EXPRESSION = $__5.TEMPLATE_LITERAL_EXPRESSION,\n      THIS_EXPRESSION = $__5.THIS_EXPRESSION,\n      THROW_STATEMENT = $__5.THROW_STATEMENT,\n      TRY_STATEMENT = $__5.TRY_STATEMENT,\n      TYPE_ALIAS_DECLARATION = $__5.TYPE_ALIAS_DECLARATION,\n      TYPE_NAME = $__5.TYPE_NAME,\n      TYPE_REFERENCE = $__5.TYPE_REFERENCE,\n      UNARY_EXPRESSION = $__5.UNARY_EXPRESSION,\n      VARIABLE_DECLARATION = $__5.VARIABLE_DECLARATION,\n      VARIABLE_STATEMENT = $__5.VARIABLE_STATEMENT,\n      WHILE_STATEMENT = $__5.WHILE_STATEMENT,\n      WITH_STATEMENT = $__5.WITH_STATEMENT,\n      YIELD_EXPRESSION = $__5.YIELD_EXPRESSION;\n  var ParseTree = function() {\n    function ParseTree(location) {\n      this.location = location;\n    }\n    return ($traceurRuntime.createClass)(ParseTree, {\n      isPattern: function() {\n        switch (this.type) {\n          case ARRAY_PATTERN:\n          case OBJECT_PATTERN:\n            return true;\n          default:\n            return false;\n        }\n      },\n      isLeftHandSideExpression: function() {\n        switch (this.type) {\n          case ARRAY_PATTERN:\n          case IDENTIFIER_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case OBJECT_PATTERN:\n            return true;\n          case PAREN_EXPRESSION:\n            return this.expression.isLeftHandSideExpression();\n          default:\n            return false;\n        }\n      },\n      isAssignmentExpression: function() {\n        switch (this.type) {\n          case ARRAY_COMPREHENSION:\n          case ARRAY_LITERAL:\n          case ARROW_FUNCTION:\n          case AWAIT_EXPRESSION:\n          case BINARY_EXPRESSION:\n          case CALL_EXPRESSION:\n          case CLASS_EXPRESSION:\n          case CONDITIONAL_EXPRESSION:\n          case FUNCTION_EXPRESSION:\n          case GENERATOR_COMPREHENSION:\n          case IDENTIFIER_EXPRESSION:\n          case JSX_ELEMENT:\n          case LITERAL_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case NEW_EXPRESSION:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n          case POSTFIX_EXPRESSION:\n          case TEMPLATE_LITERAL_EXPRESSION:\n          case SUPER_EXPRESSION:\n          case THIS_EXPRESSION:\n          case UNARY_EXPRESSION:\n          case YIELD_EXPRESSION:\n            return true;\n          default:\n            return false;\n        }\n      },\n      isMemberExpression: function() {\n        switch (this.type) {\n          case THIS_EXPRESSION:\n          case CLASS_EXPRESSION:\n          case SUPER_EXPRESSION:\n          case IDENTIFIER_EXPRESSION:\n          case JSX_ELEMENT:\n          case LITERAL_EXPRESSION:\n          case ARRAY_LITERAL:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n          case TEMPLATE_LITERAL_EXPRESSION:\n          case FUNCTION_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case CALL_EXPRESSION:\n            return true;\n          case NEW_EXPRESSION:\n            return this.args !== null;\n        }\n        return false;\n      },\n      isExpression: function() {\n        return this.isAssignmentExpression() || this.type === COMMA_EXPRESSION;\n      },\n      isAssignmentOrSpread: function() {\n        return this.isAssignmentExpression() || this.type === SPREAD_EXPRESSION;\n      },\n      isRestParameter: function() {\n        return this.type === REST_PARAMETER || (this.type === FORMAL_PARAMETER && this.parameter.isRestParameter());\n      },\n      isSpreadPatternElement: function() {\n        return this.type === SPREAD_PATTERN_ELEMENT;\n      },\n      isStatementListItem: function() {\n        return this.isStatement() || this.isDeclaration() || this.type === TYPE_ALIAS_DECLARATION;\n      },\n      isStatement: function() {\n        switch (this.type) {\n          case BLOCK:\n          case VARIABLE_STATEMENT:\n          case EMPTY_STATEMENT:\n          case EXPRESSION_STATEMENT:\n          case IF_STATEMENT:\n          case CONTINUE_STATEMENT:\n          case BREAK_STATEMENT:\n          case RETURN_STATEMENT:\n          case WITH_STATEMENT:\n          case LABELLED_STATEMENT:\n          case THROW_STATEMENT:\n          case TRY_STATEMENT:\n          case DEBUGGER_STATEMENT:\n            return true;\n        }\n        return this.isBreakableStatement();\n      },\n      isDeclaration: function() {\n        switch (this.type) {\n          case FUNCTION_DECLARATION:\n          case CLASS_DECLARATION:\n            return true;\n        }\n        return this.isLexicalDeclaration();\n      },\n      isLexicalDeclaration: function() {\n        switch (this.type) {\n          case VARIABLE_STATEMENT:\n            return this.declarations.declarationType !== VAR;\n        }\n        return false;\n      },\n      isBreakableStatement: function() {\n        switch (this.type) {\n          case SWITCH_STATEMENT:\n            return true;\n        }\n        return this.isIterationStatement();\n      },\n      isIterationStatement: function() {\n        switch (this.type) {\n          case DO_WHILE_STATEMENT:\n          case FOR_IN_STATEMENT:\n          case FOR_OF_STATEMENT:\n          case FOR_ON_STATEMENT:\n          case FOR_STATEMENT:\n          case WHILE_STATEMENT:\n            return true;\n        }\n        return false;\n      },\n      isScriptElement: function() {\n        switch (this.type) {\n          case CLASS_DECLARATION:\n          case EXPORT_DECLARATION:\n          case FUNCTION_DECLARATION:\n          case IMPORT_DECLARATION:\n          case INTERFACE_DECLARATION:\n          case VARIABLE_DECLARATION:\n          case TYPE_ALIAS_DECLARATION:\n            return true;\n        }\n        return this.isStatement();\n      },\n      isGenerator: function() {\n        return this.functionKind !== null && this.functionKind.type === STAR;\n      },\n      isAsyncFunction: function() {\n        return this.functionKind !== null && this.functionKind.type === IDENTIFIER && this.functionKind.value === ASYNC;\n      },\n      isAsyncGenerator: function() {\n        return this.functionKind !== null && this.functionKind.type === IDENTIFIER && this.functionKind.value === ASYNC_STAR;\n      },\n      isType: function() {\n        switch (this.type) {\n          case CONSTRUCTOR_TYPE:\n          case FUNCTION_TYPE:\n          case OBJECT_TYPE:\n          case PREDEFINED_TYPE:\n          case TYPE_NAME:\n          case TYPE_REFERENCE:\n            return true;\n        }\n        return false;\n      },\n      getDirectivePrologueStringToken_: function() {\n        var tree = this;\n        if (tree.type !== EXPRESSION_STATEMENT || !(tree = tree.expression))\n          return null;\n        if (tree.type !== LITERAL_EXPRESSION || !(tree = tree.literalToken))\n          return null;\n        if (tree.type !== STRING)\n          return null;\n        return tree;\n      },\n      isDirectivePrologue: function() {\n        return this.getDirectivePrologueStringToken_() !== null;\n      },\n      isUseStrictDirective: function() {\n        var token = this.getDirectivePrologueStringToken_();\n        if (!token)\n          return false;\n        var v = token.value;\n        return v === '\"use strict\"' || v === \"'use strict'\";\n      },\n      toJSON: function() {\n        return utilJSON.transform(this, ParseTree.replacer);\n      },\n      stringify: function() {\n        var indent = arguments[0] !== (void 0) ? arguments[0] : 2;\n        return JSON.stringify(this, ParseTree.replacer, indent);\n      },\n      getStringValue: function() {\n        switch (this.type) {\n          case IDENTIFIER_EXPRESSION:\n          case BINDING_IDENTIFIER:\n            return this.identifierToken.toString();\n          case IMPORTED_BINDING:\n            return this.binding.getStringValue();\n          case PROPERTY_NAME_SHORTHAND:\n            return this.name.toString();\n          case LITERAL_PROPERTY_NAME:\n            return this.literalToken.toString();\n        }\n        throw new Error('Not yet implemented');\n      }\n    }, {\n      stripLocation: function(key, value) {\n        if (key === 'location') {\n          return undefined;\n        }\n        return value;\n      },\n      replacer: function(k, v) {\n        if (v instanceof ParseTree || v instanceof Token) {\n          var rv = {type: v.type};\n          Object.keys(v).forEach(function(name) {\n            if (name !== 'location')\n              rv[name] = v[name];\n          });\n          return rv;\n        }\n        return v;\n      }\n    });\n  }();\n  return {\n    get ParseTreeType() {\n      return ParseTreeType;\n    },\n    get ParseTree() {\n      return ParseTree;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/trees/ParseTrees.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/trees/ParseTrees.js\";\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTree.js\", \"traceur@0.0.111/src/syntax/trees/ParseTrees.js\")).ParseTree;\n  var ParseTreeType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeType.js\", \"traceur@0.0.111/src/syntax/trees/ParseTrees.js\"));\n  var ANNOTATION = ParseTreeType.ANNOTATION;\n  var Annotation = function($__super) {\n    function Annotation(location, name, args) {\n      $traceurRuntime.superConstructor(Annotation).call(this, location);\n      this.name = name;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(Annotation, {\n      transform: function(transformer) {\n        return transformer.transformAnnotation(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAnnotation(this);\n      },\n      get type() {\n        return ANNOTATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ANON_BLOCK = ParseTreeType.ANON_BLOCK;\n  var AnonBlock = function($__super) {\n    function AnonBlock(location, statements) {\n      $traceurRuntime.superConstructor(AnonBlock).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(AnonBlock, {\n      transform: function(transformer) {\n        return transformer.transformAnonBlock(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAnonBlock(this);\n      },\n      get type() {\n        return ANON_BLOCK;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARGUMENT_LIST = ParseTreeType.ARGUMENT_LIST;\n  var ArgumentList = function($__super) {\n    function ArgumentList(location, args) {\n      $traceurRuntime.superConstructor(ArgumentList).call(this, location);\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(ArgumentList, {\n      transform: function(transformer) {\n        return transformer.transformArgumentList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArgumentList(this);\n      },\n      get type() {\n        return ARGUMENT_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_COMPREHENSION = ParseTreeType.ARRAY_COMPREHENSION;\n  var ArrayComprehension = function($__super) {\n    function ArrayComprehension(location, comprehensionList, expression) {\n      $traceurRuntime.superConstructor(ArrayComprehension).call(this, location);\n      this.comprehensionList = comprehensionList;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ArrayComprehension, {\n      transform: function(transformer) {\n        return transformer.transformArrayComprehension(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayComprehension(this);\n      },\n      get type() {\n        return ARRAY_COMPREHENSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_LITERAL = ParseTreeType.ARRAY_LITERAL;\n  var ArrayLiteral = function($__super) {\n    function ArrayLiteral(location, elements) {\n      $traceurRuntime.superConstructor(ArrayLiteral).call(this, location);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(ArrayLiteral, {\n      transform: function(transformer) {\n        return transformer.transformArrayLiteral(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayLiteral(this);\n      },\n      get type() {\n        return ARRAY_LITERAL;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_PATTERN = ParseTreeType.ARRAY_PATTERN;\n  var ArrayPattern = function($__super) {\n    function ArrayPattern(location, elements) {\n      $traceurRuntime.superConstructor(ArrayPattern).call(this, location);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(ArrayPattern, {\n      transform: function(transformer) {\n        return transformer.transformArrayPattern(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayPattern(this);\n      },\n      get type() {\n        return ARRAY_PATTERN;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARRAY_TYPE = ParseTreeType.ARRAY_TYPE;\n  var ArrayType = function($__super) {\n    function ArrayType(location, elementType) {\n      $traceurRuntime.superConstructor(ArrayType).call(this, location);\n      this.elementType = elementType;\n    }\n    return ($traceurRuntime.createClass)(ArrayType, {\n      transform: function(transformer) {\n        return transformer.transformArrayType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrayType(this);\n      },\n      get type() {\n        return ARRAY_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ARROW_FUNCTION = ParseTreeType.ARROW_FUNCTION;\n  var ArrowFunction = function($__super) {\n    function ArrowFunction(location, functionKind, parameterList, body) {\n      $traceurRuntime.superConstructor(ArrowFunction).call(this, location);\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ArrowFunction, {\n      transform: function(transformer) {\n        return transformer.transformArrowFunction(this);\n      },\n      visit: function(visitor) {\n        visitor.visitArrowFunction(this);\n      },\n      get type() {\n        return ARROW_FUNCTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var ASSIGNMENT_ELEMENT = ParseTreeType.ASSIGNMENT_ELEMENT;\n  var AssignmentElement = function($__super) {\n    function AssignmentElement(location, assignment, initializer) {\n      $traceurRuntime.superConstructor(AssignmentElement).call(this, location);\n      this.assignment = assignment;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(AssignmentElement, {\n      transform: function(transformer) {\n        return transformer.transformAssignmentElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAssignmentElement(this);\n      },\n      get type() {\n        return ASSIGNMENT_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var AWAIT_EXPRESSION = ParseTreeType.AWAIT_EXPRESSION;\n  var AwaitExpression = function($__super) {\n    function AwaitExpression(location, expression) {\n      $traceurRuntime.superConstructor(AwaitExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(AwaitExpression, {\n      transform: function(transformer) {\n        return transformer.transformAwaitExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitAwaitExpression(this);\n      },\n      get type() {\n        return AWAIT_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINARY_EXPRESSION = ParseTreeType.BINARY_EXPRESSION;\n  var BinaryExpression = function($__super) {\n    function BinaryExpression(location, left, operator, right) {\n      $traceurRuntime.superConstructor(BinaryExpression).call(this, location);\n      this.left = left;\n      this.operator = operator;\n      this.right = right;\n    }\n    return ($traceurRuntime.createClass)(BinaryExpression, {\n      transform: function(transformer) {\n        return transformer.transformBinaryExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBinaryExpression(this);\n      },\n      get type() {\n        return BINARY_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINDING_ELEMENT = ParseTreeType.BINDING_ELEMENT;\n  var BindingElement = function($__super) {\n    function BindingElement(location, binding, initializer) {\n      $traceurRuntime.superConstructor(BindingElement).call(this, location);\n      this.binding = binding;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(BindingElement, {\n      transform: function(transformer) {\n        return transformer.transformBindingElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBindingElement(this);\n      },\n      get type() {\n        return BINDING_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BINDING_IDENTIFIER = ParseTreeType.BINDING_IDENTIFIER;\n  var BindingIdentifier = function($__super) {\n    function BindingIdentifier(location, identifierToken) {\n      $traceurRuntime.superConstructor(BindingIdentifier).call(this, location);\n      this.identifierToken = identifierToken;\n    }\n    return ($traceurRuntime.createClass)(BindingIdentifier, {\n      transform: function(transformer) {\n        return transformer.transformBindingIdentifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBindingIdentifier(this);\n      },\n      get type() {\n        return BINDING_IDENTIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BLOCK = ParseTreeType.BLOCK;\n  var Block = function($__super) {\n    function Block(location, statements) {\n      $traceurRuntime.superConstructor(Block).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(Block, {\n      transform: function(transformer) {\n        return transformer.transformBlock(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBlock(this);\n      },\n      get type() {\n        return BLOCK;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var BREAK_STATEMENT = ParseTreeType.BREAK_STATEMENT;\n  var BreakStatement = function($__super) {\n    function BreakStatement(location, name) {\n      $traceurRuntime.superConstructor(BreakStatement).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(BreakStatement, {\n      transform: function(transformer) {\n        return transformer.transformBreakStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitBreakStatement(this);\n      },\n      get type() {\n        return BREAK_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CALL_EXPRESSION = ParseTreeType.CALL_EXPRESSION;\n  var CallExpression = function($__super) {\n    function CallExpression(location, operand, args) {\n      $traceurRuntime.superConstructor(CallExpression).call(this, location);\n      this.operand = operand;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(CallExpression, {\n      transform: function(transformer) {\n        return transformer.transformCallExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCallExpression(this);\n      },\n      get type() {\n        return CALL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CALL_SIGNATURE = ParseTreeType.CALL_SIGNATURE;\n  var CallSignature = function($__super) {\n    function CallSignature(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(CallSignature).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(CallSignature, {\n      transform: function(transformer) {\n        return transformer.transformCallSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCallSignature(this);\n      },\n      get type() {\n        return CALL_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CASE_CLAUSE = ParseTreeType.CASE_CLAUSE;\n  var CaseClause = function($__super) {\n    function CaseClause(location, expression, statements) {\n      $traceurRuntime.superConstructor(CaseClause).call(this, location);\n      this.expression = expression;\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(CaseClause, {\n      transform: function(transformer) {\n        return transformer.transformCaseClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCaseClause(this);\n      },\n      get type() {\n        return CASE_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CATCH = ParseTreeType.CATCH;\n  var Catch = function($__super) {\n    function Catch(location, binding, catchBody) {\n      $traceurRuntime.superConstructor(Catch).call(this, location);\n      this.binding = binding;\n      this.catchBody = catchBody;\n    }\n    return ($traceurRuntime.createClass)(Catch, {\n      transform: function(transformer) {\n        return transformer.transformCatch(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCatch(this);\n      },\n      get type() {\n        return CATCH;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CLASS_DECLARATION = ParseTreeType.CLASS_DECLARATION;\n  var ClassDeclaration = function($__super) {\n    function ClassDeclaration(location, name, superClass, elements, annotations, typeParameters) {\n      $traceurRuntime.superConstructor(ClassDeclaration).call(this, location);\n      this.name = name;\n      this.superClass = superClass;\n      this.elements = elements;\n      this.annotations = annotations;\n      this.typeParameters = typeParameters;\n    }\n    return ($traceurRuntime.createClass)(ClassDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformClassDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitClassDeclaration(this);\n      },\n      get type() {\n        return CLASS_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CLASS_EXPRESSION = ParseTreeType.CLASS_EXPRESSION;\n  var ClassExpression = function($__super) {\n    function ClassExpression(location, name, superClass, elements, annotations, typeParameters) {\n      $traceurRuntime.superConstructor(ClassExpression).call(this, location);\n      this.name = name;\n      this.superClass = superClass;\n      this.elements = elements;\n      this.annotations = annotations;\n      this.typeParameters = typeParameters;\n    }\n    return ($traceurRuntime.createClass)(ClassExpression, {\n      transform: function(transformer) {\n        return transformer.transformClassExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitClassExpression(this);\n      },\n      get type() {\n        return CLASS_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMMA_EXPRESSION = ParseTreeType.COMMA_EXPRESSION;\n  var CommaExpression = function($__super) {\n    function CommaExpression(location, expressions) {\n      $traceurRuntime.superConstructor(CommaExpression).call(this, location);\n      this.expressions = expressions;\n    }\n    return ($traceurRuntime.createClass)(CommaExpression, {\n      transform: function(transformer) {\n        return transformer.transformCommaExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCommaExpression(this);\n      },\n      get type() {\n        return COMMA_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPREHENSION_FOR = ParseTreeType.COMPREHENSION_FOR;\n  var ComprehensionFor = function($__super) {\n    function ComprehensionFor(location, left, iterator) {\n      $traceurRuntime.superConstructor(ComprehensionFor).call(this, location);\n      this.left = left;\n      this.iterator = iterator;\n    }\n    return ($traceurRuntime.createClass)(ComprehensionFor, {\n      transform: function(transformer) {\n        return transformer.transformComprehensionFor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComprehensionFor(this);\n      },\n      get type() {\n        return COMPREHENSION_FOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPREHENSION_IF = ParseTreeType.COMPREHENSION_IF;\n  var ComprehensionIf = function($__super) {\n    function ComprehensionIf(location, expression) {\n      $traceurRuntime.superConstructor(ComprehensionIf).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ComprehensionIf, {\n      transform: function(transformer) {\n        return transformer.transformComprehensionIf(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComprehensionIf(this);\n      },\n      get type() {\n        return COMPREHENSION_IF;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COMPUTED_PROPERTY_NAME = ParseTreeType.COMPUTED_PROPERTY_NAME;\n  var ComputedPropertyName = function($__super) {\n    function ComputedPropertyName(location, expression) {\n      $traceurRuntime.superConstructor(ComputedPropertyName).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ComputedPropertyName, {\n      transform: function(transformer) {\n        return transformer.transformComputedPropertyName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitComputedPropertyName(this);\n      },\n      get type() {\n        return COMPUTED_PROPERTY_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONDITIONAL_EXPRESSION = ParseTreeType.CONDITIONAL_EXPRESSION;\n  var ConditionalExpression = function($__super) {\n    function ConditionalExpression(location, condition, left, right) {\n      $traceurRuntime.superConstructor(ConditionalExpression).call(this, location);\n      this.condition = condition;\n      this.left = left;\n      this.right = right;\n    }\n    return ($traceurRuntime.createClass)(ConditionalExpression, {\n      transform: function(transformer) {\n        return transformer.transformConditionalExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConditionalExpression(this);\n      },\n      get type() {\n        return CONDITIONAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONSTRUCT_SIGNATURE = ParseTreeType.CONSTRUCT_SIGNATURE;\n  var ConstructSignature = function($__super) {\n    function ConstructSignature(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(ConstructSignature).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(ConstructSignature, {\n      transform: function(transformer) {\n        return transformer.transformConstructSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConstructSignature(this);\n      },\n      get type() {\n        return CONSTRUCT_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONSTRUCTOR_TYPE = ParseTreeType.CONSTRUCTOR_TYPE;\n  var ConstructorType = function($__super) {\n    function ConstructorType(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(ConstructorType).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(ConstructorType, {\n      transform: function(transformer) {\n        return transformer.transformConstructorType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitConstructorType(this);\n      },\n      get type() {\n        return CONSTRUCTOR_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var CONTINUE_STATEMENT = ParseTreeType.CONTINUE_STATEMENT;\n  var ContinueStatement = function($__super) {\n    function ContinueStatement(location, name) {\n      $traceurRuntime.superConstructor(ContinueStatement).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ContinueStatement, {\n      transform: function(transformer) {\n        return transformer.transformContinueStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitContinueStatement(this);\n      },\n      get type() {\n        return CONTINUE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COVER_FORMALS = ParseTreeType.COVER_FORMALS;\n  var CoverFormals = function($__super) {\n    function CoverFormals(location, expressions) {\n      $traceurRuntime.superConstructor(CoverFormals).call(this, location);\n      this.expressions = expressions;\n    }\n    return ($traceurRuntime.createClass)(CoverFormals, {\n      transform: function(transformer) {\n        return transformer.transformCoverFormals(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCoverFormals(this);\n      },\n      get type() {\n        return COVER_FORMALS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var COVER_INITIALIZED_NAME = ParseTreeType.COVER_INITIALIZED_NAME;\n  var CoverInitializedName = function($__super) {\n    function CoverInitializedName(location, name, equalToken, initializer) {\n      $traceurRuntime.superConstructor(CoverInitializedName).call(this, location);\n      this.name = name;\n      this.equalToken = equalToken;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(CoverInitializedName, {\n      transform: function(transformer) {\n        return transformer.transformCoverInitializedName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitCoverInitializedName(this);\n      },\n      get type() {\n        return COVER_INITIALIZED_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DEBUGGER_STATEMENT = ParseTreeType.DEBUGGER_STATEMENT;\n  var DebuggerStatement = function($__super) {\n    function DebuggerStatement(location) {\n      $traceurRuntime.superConstructor(DebuggerStatement).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(DebuggerStatement, {\n      transform: function(transformer) {\n        return transformer.transformDebuggerStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDebuggerStatement(this);\n      },\n      get type() {\n        return DEBUGGER_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DEFAULT_CLAUSE = ParseTreeType.DEFAULT_CLAUSE;\n  var DefaultClause = function($__super) {\n    function DefaultClause(location, statements) {\n      $traceurRuntime.superConstructor(DefaultClause).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(DefaultClause, {\n      transform: function(transformer) {\n        return transformer.transformDefaultClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDefaultClause(this);\n      },\n      get type() {\n        return DEFAULT_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var DO_WHILE_STATEMENT = ParseTreeType.DO_WHILE_STATEMENT;\n  var DoWhileStatement = function($__super) {\n    function DoWhileStatement(location, body, condition) {\n      $traceurRuntime.superConstructor(DoWhileStatement).call(this, location);\n      this.body = body;\n      this.condition = condition;\n    }\n    return ($traceurRuntime.createClass)(DoWhileStatement, {\n      transform: function(transformer) {\n        return transformer.transformDoWhileStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitDoWhileStatement(this);\n      },\n      get type() {\n        return DO_WHILE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EMPTY_STATEMENT = ParseTreeType.EMPTY_STATEMENT;\n  var EmptyStatement = function($__super) {\n    function EmptyStatement(location) {\n      $traceurRuntime.superConstructor(EmptyStatement).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(EmptyStatement, {\n      transform: function(transformer) {\n        return transformer.transformEmptyStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitEmptyStatement(this);\n      },\n      get type() {\n        return EMPTY_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_DECLARATION = ParseTreeType.EXPORT_DECLARATION;\n  var ExportDeclaration = function($__super) {\n    function ExportDeclaration(location, declaration, annotations) {\n      $traceurRuntime.superConstructor(ExportDeclaration).call(this, location);\n      this.declaration = declaration;\n      this.annotations = annotations;\n    }\n    return ($traceurRuntime.createClass)(ExportDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformExportDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportDeclaration(this);\n      },\n      get type() {\n        return EXPORT_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_DEFAULT = ParseTreeType.EXPORT_DEFAULT;\n  var ExportDefault = function($__super) {\n    function ExportDefault(location, expression) {\n      $traceurRuntime.superConstructor(ExportDefault).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ExportDefault, {\n      transform: function(transformer) {\n        return transformer.transformExportDefault(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportDefault(this);\n      },\n      get type() {\n        return EXPORT_DEFAULT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_SPECIFIER = ParseTreeType.EXPORT_SPECIFIER;\n  var ExportSpecifier = function($__super) {\n    function ExportSpecifier(location, lhs, rhs) {\n      $traceurRuntime.superConstructor(ExportSpecifier).call(this, location);\n      this.lhs = lhs;\n      this.rhs = rhs;\n    }\n    return ($traceurRuntime.createClass)(ExportSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformExportSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportSpecifier(this);\n      },\n      get type() {\n        return EXPORT_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_SPECIFIER_SET = ParseTreeType.EXPORT_SPECIFIER_SET;\n  var ExportSpecifierSet = function($__super) {\n    function ExportSpecifierSet(location, specifiers) {\n      $traceurRuntime.superConstructor(ExportSpecifierSet).call(this, location);\n      this.specifiers = specifiers;\n    }\n    return ($traceurRuntime.createClass)(ExportSpecifierSet, {\n      transform: function(transformer) {\n        return transformer.transformExportSpecifierSet(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportSpecifierSet(this);\n      },\n      get type() {\n        return EXPORT_SPECIFIER_SET;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPORT_STAR = ParseTreeType.EXPORT_STAR;\n  var ExportStar = function($__super) {\n    function ExportStar(location) {\n      $traceurRuntime.superConstructor(ExportStar).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(ExportStar, {\n      transform: function(transformer) {\n        return transformer.transformExportStar(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExportStar(this);\n      },\n      get type() {\n        return EXPORT_STAR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var EXPRESSION_STATEMENT = ParseTreeType.EXPRESSION_STATEMENT;\n  var ExpressionStatement = function($__super) {\n    function ExpressionStatement(location, expression) {\n      $traceurRuntime.superConstructor(ExpressionStatement).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ExpressionStatement, {\n      transform: function(transformer) {\n        return transformer.transformExpressionStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitExpressionStatement(this);\n      },\n      get type() {\n        return EXPRESSION_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FINALLY = ParseTreeType.FINALLY;\n  var Finally = function($__super) {\n    function Finally(location, block) {\n      $traceurRuntime.superConstructor(Finally).call(this, location);\n      this.block = block;\n    }\n    return ($traceurRuntime.createClass)(Finally, {\n      transform: function(transformer) {\n        return transformer.transformFinally(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFinally(this);\n      },\n      get type() {\n        return FINALLY;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_IN_STATEMENT = ParseTreeType.FOR_IN_STATEMENT;\n  var ForInStatement = function($__super) {\n    function ForInStatement(location, initializer, collection, body) {\n      $traceurRuntime.superConstructor(ForInStatement).call(this, location);\n      this.initializer = initializer;\n      this.collection = collection;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForInStatement, {\n      transform: function(transformer) {\n        return transformer.transformForInStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForInStatement(this);\n      },\n      get type() {\n        return FOR_IN_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_OF_STATEMENT = ParseTreeType.FOR_OF_STATEMENT;\n  var ForOfStatement = function($__super) {\n    function ForOfStatement(location, initializer, collection, body) {\n      $traceurRuntime.superConstructor(ForOfStatement).call(this, location);\n      this.initializer = initializer;\n      this.collection = collection;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForOfStatement, {\n      transform: function(transformer) {\n        return transformer.transformForOfStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForOfStatement(this);\n      },\n      get type() {\n        return FOR_OF_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_ON_STATEMENT = ParseTreeType.FOR_ON_STATEMENT;\n  var ForOnStatement = function($__super) {\n    function ForOnStatement(location, initializer, observable, body) {\n      $traceurRuntime.superConstructor(ForOnStatement).call(this, location);\n      this.initializer = initializer;\n      this.observable = observable;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForOnStatement, {\n      transform: function(transformer) {\n        return transformer.transformForOnStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForOnStatement(this);\n      },\n      get type() {\n        return FOR_ON_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FOR_STATEMENT = ParseTreeType.FOR_STATEMENT;\n  var ForStatement = function($__super) {\n    function ForStatement(location, initializer, condition, increment, body) {\n      $traceurRuntime.superConstructor(ForStatement).call(this, location);\n      this.initializer = initializer;\n      this.condition = condition;\n      this.increment = increment;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(ForStatement, {\n      transform: function(transformer) {\n        return transformer.transformForStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForStatement(this);\n      },\n      get type() {\n        return FOR_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORMAL_PARAMETER = ParseTreeType.FORMAL_PARAMETER;\n  var FormalParameter = function($__super) {\n    function FormalParameter(location, parameter, typeAnnotation, annotations) {\n      $traceurRuntime.superConstructor(FormalParameter).call(this, location);\n      this.parameter = parameter;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n    }\n    return ($traceurRuntime.createClass)(FormalParameter, {\n      transform: function(transformer) {\n        return transformer.transformFormalParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFormalParameter(this);\n      },\n      get type() {\n        return FORMAL_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORMAL_PARAMETER_LIST = ParseTreeType.FORMAL_PARAMETER_LIST;\n  var FormalParameterList = function($__super) {\n    function FormalParameterList(location, parameters) {\n      $traceurRuntime.superConstructor(FormalParameterList).call(this, location);\n      this.parameters = parameters;\n    }\n    return ($traceurRuntime.createClass)(FormalParameterList, {\n      transform: function(transformer) {\n        return transformer.transformFormalParameterList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFormalParameterList(this);\n      },\n      get type() {\n        return FORMAL_PARAMETER_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FORWARD_DEFAULT_EXPORT = ParseTreeType.FORWARD_DEFAULT_EXPORT;\n  var ForwardDefaultExport = function($__super) {\n    function ForwardDefaultExport(location, name) {\n      $traceurRuntime.superConstructor(ForwardDefaultExport).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ForwardDefaultExport, {\n      transform: function(transformer) {\n        return transformer.transformForwardDefaultExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitForwardDefaultExport(this);\n      },\n      get type() {\n        return FORWARD_DEFAULT_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_BODY = ParseTreeType.FUNCTION_BODY;\n  var FunctionBody = function($__super) {\n    function FunctionBody(location, statements) {\n      $traceurRuntime.superConstructor(FunctionBody).call(this, location);\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(FunctionBody, {\n      transform: function(transformer) {\n        return transformer.transformFunctionBody(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionBody(this);\n      },\n      get type() {\n        return FUNCTION_BODY;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_DECLARATION = ParseTreeType.FUNCTION_DECLARATION;\n  var FunctionDeclaration = function($__super) {\n    function FunctionDeclaration(location, name, functionKind, parameterList, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(FunctionDeclaration).call(this, location);\n      this.name = name;\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(FunctionDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformFunctionDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionDeclaration(this);\n      },\n      get type() {\n        return FUNCTION_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_EXPRESSION = ParseTreeType.FUNCTION_EXPRESSION;\n  var FunctionExpression = function($__super) {\n    function FunctionExpression(location, name, functionKind, parameterList, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(FunctionExpression).call(this, location);\n      this.name = name;\n      this.functionKind = functionKind;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(FunctionExpression, {\n      transform: function(transformer) {\n        return transformer.transformFunctionExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionExpression(this);\n      },\n      get type() {\n        return FUNCTION_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var FUNCTION_TYPE = ParseTreeType.FUNCTION_TYPE;\n  var FunctionType = function($__super) {\n    function FunctionType(location, typeParameters, parameterList, returnType) {\n      $traceurRuntime.superConstructor(FunctionType).call(this, location);\n      this.typeParameters = typeParameters;\n      this.parameterList = parameterList;\n      this.returnType = returnType;\n    }\n    return ($traceurRuntime.createClass)(FunctionType, {\n      transform: function(transformer) {\n        return transformer.transformFunctionType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitFunctionType(this);\n      },\n      get type() {\n        return FUNCTION_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var GENERATOR_COMPREHENSION = ParseTreeType.GENERATOR_COMPREHENSION;\n  var GeneratorComprehension = function($__super) {\n    function GeneratorComprehension(location, comprehensionList, expression) {\n      $traceurRuntime.superConstructor(GeneratorComprehension).call(this, location);\n      this.comprehensionList = comprehensionList;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(GeneratorComprehension, {\n      transform: function(transformer) {\n        return transformer.transformGeneratorComprehension(this);\n      },\n      visit: function(visitor) {\n        visitor.visitGeneratorComprehension(this);\n      },\n      get type() {\n        return GENERATOR_COMPREHENSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var GET_ACCESSOR = ParseTreeType.GET_ACCESSOR;\n  var GetAccessor = function($__super) {\n    function GetAccessor(location, isStatic, name, typeAnnotation, annotations, body) {\n      $traceurRuntime.superConstructor(GetAccessor).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(GetAccessor, {\n      transform: function(transformer) {\n        return transformer.transformGetAccessor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitGetAccessor(this);\n      },\n      get type() {\n        return GET_ACCESSOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IDENTIFIER_EXPRESSION = ParseTreeType.IDENTIFIER_EXPRESSION;\n  var IdentifierExpression = function($__super) {\n    function IdentifierExpression(location, identifierToken) {\n      $traceurRuntime.superConstructor(IdentifierExpression).call(this, location);\n      this.identifierToken = identifierToken;\n    }\n    return ($traceurRuntime.createClass)(IdentifierExpression, {\n      transform: function(transformer) {\n        return transformer.transformIdentifierExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIdentifierExpression(this);\n      },\n      get type() {\n        return IDENTIFIER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IF_STATEMENT = ParseTreeType.IF_STATEMENT;\n  var IfStatement = function($__super) {\n    function IfStatement(location, condition, ifClause, elseClause) {\n      $traceurRuntime.superConstructor(IfStatement).call(this, location);\n      this.condition = condition;\n      this.ifClause = ifClause;\n      this.elseClause = elseClause;\n    }\n    return ($traceurRuntime.createClass)(IfStatement, {\n      transform: function(transformer) {\n        return transformer.transformIfStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIfStatement(this);\n      },\n      get type() {\n        return IF_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORTED_BINDING = ParseTreeType.IMPORTED_BINDING;\n  var ImportedBinding = function($__super) {\n    function ImportedBinding(location, binding) {\n      $traceurRuntime.superConstructor(ImportedBinding).call(this, location);\n      this.binding = binding;\n    }\n    return ($traceurRuntime.createClass)(ImportedBinding, {\n      transform: function(transformer) {\n        return transformer.transformImportedBinding(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportedBinding(this);\n      },\n      get type() {\n        return IMPORTED_BINDING;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_CLAUSE_PAIR = ParseTreeType.IMPORT_CLAUSE_PAIR;\n  var ImportClausePair = function($__super) {\n    function ImportClausePair(location, first, second) {\n      $traceurRuntime.superConstructor(ImportClausePair).call(this, location);\n      this.first = first;\n      this.second = second;\n    }\n    return ($traceurRuntime.createClass)(ImportClausePair, {\n      transform: function(transformer) {\n        return transformer.transformImportClausePair(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportClausePair(this);\n      },\n      get type() {\n        return IMPORT_CLAUSE_PAIR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_DECLARATION = ParseTreeType.IMPORT_DECLARATION;\n  var ImportDeclaration = function($__super) {\n    function ImportDeclaration(location, importClause, moduleSpecifier) {\n      $traceurRuntime.superConstructor(ImportDeclaration).call(this, location);\n      this.importClause = importClause;\n      this.moduleSpecifier = moduleSpecifier;\n    }\n    return ($traceurRuntime.createClass)(ImportDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformImportDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportDeclaration(this);\n      },\n      get type() {\n        return IMPORT_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_SPECIFIER = ParseTreeType.IMPORT_SPECIFIER;\n  var ImportSpecifier = function($__super) {\n    function ImportSpecifier(location, binding, name) {\n      $traceurRuntime.superConstructor(ImportSpecifier).call(this, location);\n      this.binding = binding;\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(ImportSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformImportSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportSpecifier(this);\n      },\n      get type() {\n        return IMPORT_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_SPECIFIER_SET = ParseTreeType.IMPORT_SPECIFIER_SET;\n  var ImportSpecifierSet = function($__super) {\n    function ImportSpecifierSet(location, specifiers) {\n      $traceurRuntime.superConstructor(ImportSpecifierSet).call(this, location);\n      this.specifiers = specifiers;\n    }\n    return ($traceurRuntime.createClass)(ImportSpecifierSet, {\n      transform: function(transformer) {\n        return transformer.transformImportSpecifierSet(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportSpecifierSet(this);\n      },\n      get type() {\n        return IMPORT_SPECIFIER_SET;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var IMPORT_TYPE_CLAUSE = ParseTreeType.IMPORT_TYPE_CLAUSE;\n  var ImportTypeClause = function($__super) {\n    function ImportTypeClause(location, clause) {\n      $traceurRuntime.superConstructor(ImportTypeClause).call(this, location);\n      this.clause = clause;\n    }\n    return ($traceurRuntime.createClass)(ImportTypeClause, {\n      transform: function(transformer) {\n        return transformer.transformImportTypeClause(this);\n      },\n      visit: function(visitor) {\n        visitor.visitImportTypeClause(this);\n      },\n      get type() {\n        return IMPORT_TYPE_CLAUSE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var INDEX_SIGNATURE = ParseTreeType.INDEX_SIGNATURE;\n  var IndexSignature = function($__super) {\n    function IndexSignature(location, name, indexType, typeAnnotation) {\n      $traceurRuntime.superConstructor(IndexSignature).call(this, location);\n      this.name = name;\n      this.indexType = indexType;\n      this.typeAnnotation = typeAnnotation;\n    }\n    return ($traceurRuntime.createClass)(IndexSignature, {\n      transform: function(transformer) {\n        return transformer.transformIndexSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitIndexSignature(this);\n      },\n      get type() {\n        return INDEX_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var INTERFACE_DECLARATION = ParseTreeType.INTERFACE_DECLARATION;\n  var InterfaceDeclaration = function($__super) {\n    function InterfaceDeclaration(location, name, typeParameters, extendsClause, objectType) {\n      $traceurRuntime.superConstructor(InterfaceDeclaration).call(this, location);\n      this.name = name;\n      this.typeParameters = typeParameters;\n      this.extendsClause = extendsClause;\n      this.objectType = objectType;\n    }\n    return ($traceurRuntime.createClass)(InterfaceDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformInterfaceDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitInterfaceDeclaration(this);\n      },\n      get type() {\n        return INTERFACE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ATTRIBUTE = ParseTreeType.JSX_ATTRIBUTE;\n  var JsxAttribute = function($__super) {\n    function JsxAttribute(location, name, value) {\n      $traceurRuntime.superConstructor(JsxAttribute).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxAttribute, {\n      transform: function(transformer) {\n        return transformer.transformJsxAttribute(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxAttribute(this);\n      },\n      get type() {\n        return JSX_ATTRIBUTE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ELEMENT = ParseTreeType.JSX_ELEMENT;\n  var JsxElement = function($__super) {\n    function JsxElement(location, name, attributes, children) {\n      $traceurRuntime.superConstructor(JsxElement).call(this, location);\n      this.name = name;\n      this.attributes = attributes;\n      this.children = children;\n    }\n    return ($traceurRuntime.createClass)(JsxElement, {\n      transform: function(transformer) {\n        return transformer.transformJsxElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxElement(this);\n      },\n      get type() {\n        return JSX_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_ELEMENT_NAME = ParseTreeType.JSX_ELEMENT_NAME;\n  var JsxElementName = function($__super) {\n    function JsxElementName(location, names) {\n      $traceurRuntime.superConstructor(JsxElementName).call(this, location);\n      this.names = names;\n    }\n    return ($traceurRuntime.createClass)(JsxElementName, {\n      transform: function(transformer) {\n        return transformer.transformJsxElementName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxElementName(this);\n      },\n      get type() {\n        return JSX_ELEMENT_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_PLACEHOLDER = ParseTreeType.JSX_PLACEHOLDER;\n  var JsxPlaceholder = function($__super) {\n    function JsxPlaceholder(location, expression) {\n      $traceurRuntime.superConstructor(JsxPlaceholder).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(JsxPlaceholder, {\n      transform: function(transformer) {\n        return transformer.transformJsxPlaceholder(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxPlaceholder(this);\n      },\n      get type() {\n        return JSX_PLACEHOLDER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_SPREAD_ATTRIBUTE = ParseTreeType.JSX_SPREAD_ATTRIBUTE;\n  var JsxSpreadAttribute = function($__super) {\n    function JsxSpreadAttribute(location, expression) {\n      $traceurRuntime.superConstructor(JsxSpreadAttribute).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(JsxSpreadAttribute, {\n      transform: function(transformer) {\n        return transformer.transformJsxSpreadAttribute(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxSpreadAttribute(this);\n      },\n      get type() {\n        return JSX_SPREAD_ATTRIBUTE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var JSX_TEXT = ParseTreeType.JSX_TEXT;\n  var JsxText = function($__super) {\n    function JsxText(location, value) {\n      $traceurRuntime.superConstructor(JsxText).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxText, {\n      transform: function(transformer) {\n        return transformer.transformJsxText(this);\n      },\n      visit: function(visitor) {\n        visitor.visitJsxText(this);\n      },\n      get type() {\n        return JSX_TEXT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LABELLED_STATEMENT = ParseTreeType.LABELLED_STATEMENT;\n  var LabelledStatement = function($__super) {\n    function LabelledStatement(location, name, statement) {\n      $traceurRuntime.superConstructor(LabelledStatement).call(this, location);\n      this.name = name;\n      this.statement = statement;\n    }\n    return ($traceurRuntime.createClass)(LabelledStatement, {\n      transform: function(transformer) {\n        return transformer.transformLabelledStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLabelledStatement(this);\n      },\n      get type() {\n        return LABELLED_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LITERAL_EXPRESSION = ParseTreeType.LITERAL_EXPRESSION;\n  var LiteralExpression = function($__super) {\n    function LiteralExpression(location, literalToken) {\n      $traceurRuntime.superConstructor(LiteralExpression).call(this, location);\n      this.literalToken = literalToken;\n    }\n    return ($traceurRuntime.createClass)(LiteralExpression, {\n      transform: function(transformer) {\n        return transformer.transformLiteralExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLiteralExpression(this);\n      },\n      get type() {\n        return LITERAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var LITERAL_PROPERTY_NAME = ParseTreeType.LITERAL_PROPERTY_NAME;\n  var LiteralPropertyName = function($__super) {\n    function LiteralPropertyName(location, literalToken) {\n      $traceurRuntime.superConstructor(LiteralPropertyName).call(this, location);\n      this.literalToken = literalToken;\n    }\n    return ($traceurRuntime.createClass)(LiteralPropertyName, {\n      transform: function(transformer) {\n        return transformer.transformLiteralPropertyName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitLiteralPropertyName(this);\n      },\n      get type() {\n        return LITERAL_PROPERTY_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MEMBER_EXPRESSION = ParseTreeType.MEMBER_EXPRESSION;\n  var MemberExpression = function($__super) {\n    function MemberExpression(location, operand, memberName) {\n      $traceurRuntime.superConstructor(MemberExpression).call(this, location);\n      this.operand = operand;\n      this.memberName = memberName;\n    }\n    return ($traceurRuntime.createClass)(MemberExpression, {\n      transform: function(transformer) {\n        return transformer.transformMemberExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMemberExpression(this);\n      },\n      get type() {\n        return MEMBER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MEMBER_LOOKUP_EXPRESSION = ParseTreeType.MEMBER_LOOKUP_EXPRESSION;\n  var MemberLookupExpression = function($__super) {\n    function MemberLookupExpression(location, operand, memberExpression) {\n      $traceurRuntime.superConstructor(MemberLookupExpression).call(this, location);\n      this.operand = operand;\n      this.memberExpression = memberExpression;\n    }\n    return ($traceurRuntime.createClass)(MemberLookupExpression, {\n      transform: function(transformer) {\n        return transformer.transformMemberLookupExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMemberLookupExpression(this);\n      },\n      get type() {\n        return MEMBER_LOOKUP_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var METHOD = ParseTreeType.METHOD;\n  var Method = function($__super) {\n    function Method(location, isStatic, functionKind, name, parameterList, typeAnnotation, annotations, body, debugName) {\n      $traceurRuntime.superConstructor(Method).call(this, location);\n      this.isStatic = isStatic;\n      this.functionKind = functionKind;\n      this.name = name;\n      this.parameterList = parameterList;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.body = body;\n      this.debugName = debugName;\n    }\n    return ($traceurRuntime.createClass)(Method, {\n      transform: function(transformer) {\n        return transformer.transformMethod(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMethod(this);\n      },\n      get type() {\n        return METHOD;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var METHOD_SIGNATURE = ParseTreeType.METHOD_SIGNATURE;\n  var MethodSignature = function($__super) {\n    function MethodSignature(location, name, optional, callSignature) {\n      $traceurRuntime.superConstructor(MethodSignature).call(this, location);\n      this.name = name;\n      this.optional = optional;\n      this.callSignature = callSignature;\n    }\n    return ($traceurRuntime.createClass)(MethodSignature, {\n      transform: function(transformer) {\n        return transformer.transformMethodSignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitMethodSignature(this);\n      },\n      get type() {\n        return METHOD_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MODULE = ParseTreeType.MODULE;\n  var Module = function($__super) {\n    function Module(location, scriptItemList, moduleName) {\n      $traceurRuntime.superConstructor(Module).call(this, location);\n      this.scriptItemList = scriptItemList;\n      this.moduleName = moduleName;\n    }\n    return ($traceurRuntime.createClass)(Module, {\n      transform: function(transformer) {\n        return transformer.transformModule(this);\n      },\n      visit: function(visitor) {\n        visitor.visitModule(this);\n      },\n      get type() {\n        return MODULE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var MODULE_SPECIFIER = ParseTreeType.MODULE_SPECIFIER;\n  var ModuleSpecifier = function($__super) {\n    function ModuleSpecifier(location, token) {\n      $traceurRuntime.superConstructor(ModuleSpecifier).call(this, location);\n      this.token = token;\n    }\n    return ($traceurRuntime.createClass)(ModuleSpecifier, {\n      transform: function(transformer) {\n        return transformer.transformModuleSpecifier(this);\n      },\n      visit: function(visitor) {\n        visitor.visitModuleSpecifier(this);\n      },\n      get type() {\n        return MODULE_SPECIFIER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAME_SPACE_EXPORT = ParseTreeType.NAME_SPACE_EXPORT;\n  var NameSpaceExport = function($__super) {\n    function NameSpaceExport(location, name) {\n      $traceurRuntime.superConstructor(NameSpaceExport).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(NameSpaceExport, {\n      transform: function(transformer) {\n        return transformer.transformNameSpaceExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNameSpaceExport(this);\n      },\n      get type() {\n        return NAME_SPACE_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAME_SPACE_IMPORT = ParseTreeType.NAME_SPACE_IMPORT;\n  var NameSpaceImport = function($__super) {\n    function NameSpaceImport(location, binding) {\n      $traceurRuntime.superConstructor(NameSpaceImport).call(this, location);\n      this.binding = binding;\n    }\n    return ($traceurRuntime.createClass)(NameSpaceImport, {\n      transform: function(transformer) {\n        return transformer.transformNameSpaceImport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNameSpaceImport(this);\n      },\n      get type() {\n        return NAME_SPACE_IMPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NAMED_EXPORT = ParseTreeType.NAMED_EXPORT;\n  var NamedExport = function($__super) {\n    function NamedExport(location, exportClause, moduleSpecifier) {\n      $traceurRuntime.superConstructor(NamedExport).call(this, location);\n      this.exportClause = exportClause;\n      this.moduleSpecifier = moduleSpecifier;\n    }\n    return ($traceurRuntime.createClass)(NamedExport, {\n      transform: function(transformer) {\n        return transformer.transformNamedExport(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNamedExport(this);\n      },\n      get type() {\n        return NAMED_EXPORT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var NEW_EXPRESSION = ParseTreeType.NEW_EXPRESSION;\n  var NewExpression = function($__super) {\n    function NewExpression(location, operand, args) {\n      $traceurRuntime.superConstructor(NewExpression).call(this, location);\n      this.operand = operand;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(NewExpression, {\n      transform: function(transformer) {\n        return transformer.transformNewExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitNewExpression(this);\n      },\n      get type() {\n        return NEW_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_LITERAL = ParseTreeType.OBJECT_LITERAL;\n  var ObjectLiteral = function($__super) {\n    function ObjectLiteral(location, propertyNameAndValues) {\n      $traceurRuntime.superConstructor(ObjectLiteral).call(this, location);\n      this.propertyNameAndValues = propertyNameAndValues;\n    }\n    return ($traceurRuntime.createClass)(ObjectLiteral, {\n      transform: function(transformer) {\n        return transformer.transformObjectLiteral(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectLiteral(this);\n      },\n      get type() {\n        return OBJECT_LITERAL;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_PATTERN = ParseTreeType.OBJECT_PATTERN;\n  var ObjectPattern = function($__super) {\n    function ObjectPattern(location, fields) {\n      $traceurRuntime.superConstructor(ObjectPattern).call(this, location);\n      this.fields = fields;\n    }\n    return ($traceurRuntime.createClass)(ObjectPattern, {\n      transform: function(transformer) {\n        return transformer.transformObjectPattern(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectPattern(this);\n      },\n      get type() {\n        return OBJECT_PATTERN;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_PATTERN_FIELD = ParseTreeType.OBJECT_PATTERN_FIELD;\n  var ObjectPatternField = function($__super) {\n    function ObjectPatternField(location, name, element) {\n      $traceurRuntime.superConstructor(ObjectPatternField).call(this, location);\n      this.name = name;\n      this.element = element;\n    }\n    return ($traceurRuntime.createClass)(ObjectPatternField, {\n      transform: function(transformer) {\n        return transformer.transformObjectPatternField(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectPatternField(this);\n      },\n      get type() {\n        return OBJECT_PATTERN_FIELD;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var OBJECT_TYPE = ParseTreeType.OBJECT_TYPE;\n  var ObjectType = function($__super) {\n    function ObjectType(location, typeMembers) {\n      $traceurRuntime.superConstructor(ObjectType).call(this, location);\n      this.typeMembers = typeMembers;\n    }\n    return ($traceurRuntime.createClass)(ObjectType, {\n      transform: function(transformer) {\n        return transformer.transformObjectType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitObjectType(this);\n      },\n      get type() {\n        return OBJECT_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PAREN_EXPRESSION = ParseTreeType.PAREN_EXPRESSION;\n  var ParenExpression = function($__super) {\n    function ParenExpression(location, expression) {\n      $traceurRuntime.superConstructor(ParenExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ParenExpression, {\n      transform: function(transformer) {\n        return transformer.transformParenExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitParenExpression(this);\n      },\n      get type() {\n        return PAREN_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var POSTFIX_EXPRESSION = ParseTreeType.POSTFIX_EXPRESSION;\n  var PostfixExpression = function($__super) {\n    function PostfixExpression(location, operand, operator) {\n      $traceurRuntime.superConstructor(PostfixExpression).call(this, location);\n      this.operand = operand;\n      this.operator = operator;\n    }\n    return ($traceurRuntime.createClass)(PostfixExpression, {\n      transform: function(transformer) {\n        return transformer.transformPostfixExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPostfixExpression(this);\n      },\n      get type() {\n        return POSTFIX_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PREDEFINED_TYPE = ParseTreeType.PREDEFINED_TYPE;\n  var PredefinedType = function($__super) {\n    function PredefinedType(location, typeToken) {\n      $traceurRuntime.superConstructor(PredefinedType).call(this, location);\n      this.typeToken = typeToken;\n    }\n    return ($traceurRuntime.createClass)(PredefinedType, {\n      transform: function(transformer) {\n        return transformer.transformPredefinedType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPredefinedType(this);\n      },\n      get type() {\n        return PREDEFINED_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SCRIPT = ParseTreeType.SCRIPT;\n  var Script = function($__super) {\n    function Script(location, scriptItemList, moduleName) {\n      $traceurRuntime.superConstructor(Script).call(this, location);\n      this.scriptItemList = scriptItemList;\n      this.moduleName = moduleName;\n    }\n    return ($traceurRuntime.createClass)(Script, {\n      transform: function(transformer) {\n        return transformer.transformScript(this);\n      },\n      visit: function(visitor) {\n        visitor.visitScript(this);\n      },\n      get type() {\n        return SCRIPT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_NAME_ASSIGNMENT = ParseTreeType.PROPERTY_NAME_ASSIGNMENT;\n  var PropertyNameAssignment = function($__super) {\n    function PropertyNameAssignment(location, name, value) {\n      $traceurRuntime.superConstructor(PropertyNameAssignment).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(PropertyNameAssignment, {\n      transform: function(transformer) {\n        return transformer.transformPropertyNameAssignment(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyNameAssignment(this);\n      },\n      get type() {\n        return PROPERTY_NAME_ASSIGNMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_NAME_SHORTHAND = ParseTreeType.PROPERTY_NAME_SHORTHAND;\n  var PropertyNameShorthand = function($__super) {\n    function PropertyNameShorthand(location, name) {\n      $traceurRuntime.superConstructor(PropertyNameShorthand).call(this, location);\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(PropertyNameShorthand, {\n      transform: function(transformer) {\n        return transformer.transformPropertyNameShorthand(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyNameShorthand(this);\n      },\n      get type() {\n        return PROPERTY_NAME_SHORTHAND;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_VARIABLE_DECLARATION = ParseTreeType.PROPERTY_VARIABLE_DECLARATION;\n  var PropertyVariableDeclaration = function($__super) {\n    function PropertyVariableDeclaration(location, isStatic, name, typeAnnotation, annotations, initializer) {\n      $traceurRuntime.superConstructor(PropertyVariableDeclaration).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.typeAnnotation = typeAnnotation;\n      this.annotations = annotations;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(PropertyVariableDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformPropertyVariableDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertyVariableDeclaration(this);\n      },\n      get type() {\n        return PROPERTY_VARIABLE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var PROPERTY_SIGNATURE = ParseTreeType.PROPERTY_SIGNATURE;\n  var PropertySignature = function($__super) {\n    function PropertySignature(location, name, optional, typeAnnotation) {\n      $traceurRuntime.superConstructor(PropertySignature).call(this, location);\n      this.name = name;\n      this.optional = optional;\n      this.typeAnnotation = typeAnnotation;\n    }\n    return ($traceurRuntime.createClass)(PropertySignature, {\n      transform: function(transformer) {\n        return transformer.transformPropertySignature(this);\n      },\n      visit: function(visitor) {\n        visitor.visitPropertySignature(this);\n      },\n      get type() {\n        return PROPERTY_SIGNATURE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var REST_PARAMETER = ParseTreeType.REST_PARAMETER;\n  var RestParameter = function($__super) {\n    function RestParameter(location, identifier) {\n      $traceurRuntime.superConstructor(RestParameter).call(this, location);\n      this.identifier = identifier;\n    }\n    return ($traceurRuntime.createClass)(RestParameter, {\n      transform: function(transformer) {\n        return transformer.transformRestParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitRestParameter(this);\n      },\n      get type() {\n        return REST_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var RETURN_STATEMENT = ParseTreeType.RETURN_STATEMENT;\n  var ReturnStatement = function($__super) {\n    function ReturnStatement(location, expression) {\n      $traceurRuntime.superConstructor(ReturnStatement).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(ReturnStatement, {\n      transform: function(transformer) {\n        return transformer.transformReturnStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitReturnStatement(this);\n      },\n      get type() {\n        return RETURN_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SET_ACCESSOR = ParseTreeType.SET_ACCESSOR;\n  var SetAccessor = function($__super) {\n    function SetAccessor(location, isStatic, name, parameterList, annotations, body) {\n      $traceurRuntime.superConstructor(SetAccessor).call(this, location);\n      this.isStatic = isStatic;\n      this.name = name;\n      this.parameterList = parameterList;\n      this.annotations = annotations;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(SetAccessor, {\n      transform: function(transformer) {\n        return transformer.transformSetAccessor(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSetAccessor(this);\n      },\n      get type() {\n        return SET_ACCESSOR;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SPREAD_EXPRESSION = ParseTreeType.SPREAD_EXPRESSION;\n  var SpreadExpression = function($__super) {\n    function SpreadExpression(location, expression) {\n      $traceurRuntime.superConstructor(SpreadExpression).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(SpreadExpression, {\n      transform: function(transformer) {\n        return transformer.transformSpreadExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSpreadExpression(this);\n      },\n      get type() {\n        return SPREAD_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SPREAD_PATTERN_ELEMENT = ParseTreeType.SPREAD_PATTERN_ELEMENT;\n  var SpreadPatternElement = function($__super) {\n    function SpreadPatternElement(location, lvalue) {\n      $traceurRuntime.superConstructor(SpreadPatternElement).call(this, location);\n      this.lvalue = lvalue;\n    }\n    return ($traceurRuntime.createClass)(SpreadPatternElement, {\n      transform: function(transformer) {\n        return transformer.transformSpreadPatternElement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSpreadPatternElement(this);\n      },\n      get type() {\n        return SPREAD_PATTERN_ELEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SUPER_EXPRESSION = ParseTreeType.SUPER_EXPRESSION;\n  var SuperExpression = function($__super) {\n    function SuperExpression(location) {\n      $traceurRuntime.superConstructor(SuperExpression).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(SuperExpression, {\n      transform: function(transformer) {\n        return transformer.transformSuperExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSuperExpression(this);\n      },\n      get type() {\n        return SUPER_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SWITCH_STATEMENT = ParseTreeType.SWITCH_STATEMENT;\n  var SwitchStatement = function($__super) {\n    function SwitchStatement(location, expression, caseClauses) {\n      $traceurRuntime.superConstructor(SwitchStatement).call(this, location);\n      this.expression = expression;\n      this.caseClauses = caseClauses;\n    }\n    return ($traceurRuntime.createClass)(SwitchStatement, {\n      transform: function(transformer) {\n        return transformer.transformSwitchStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSwitchStatement(this);\n      },\n      get type() {\n        return SWITCH_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var SYNTAX_ERROR_TREE = ParseTreeType.SYNTAX_ERROR_TREE;\n  var SyntaxErrorTree = function($__super) {\n    function SyntaxErrorTree(location, nextToken, message) {\n      $traceurRuntime.superConstructor(SyntaxErrorTree).call(this, location);\n      this.nextToken = nextToken;\n      this.message = message;\n    }\n    return ($traceurRuntime.createClass)(SyntaxErrorTree, {\n      transform: function(transformer) {\n        return transformer.transformSyntaxErrorTree(this);\n      },\n      visit: function(visitor) {\n        visitor.visitSyntaxErrorTree(this);\n      },\n      get type() {\n        return SYNTAX_ERROR_TREE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_LITERAL_EXPRESSION = ParseTreeType.TEMPLATE_LITERAL_EXPRESSION;\n  var TemplateLiteralExpression = function($__super) {\n    function TemplateLiteralExpression(location, operand, elements) {\n      $traceurRuntime.superConstructor(TemplateLiteralExpression).call(this, location);\n      this.operand = operand;\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralExpression, {\n      transform: function(transformer) {\n        return transformer.transformTemplateLiteralExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateLiteralExpression(this);\n      },\n      get type() {\n        return TEMPLATE_LITERAL_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_LITERAL_PORTION = ParseTreeType.TEMPLATE_LITERAL_PORTION;\n  var TemplateLiteralPortion = function($__super) {\n    function TemplateLiteralPortion(location, value) {\n      $traceurRuntime.superConstructor(TemplateLiteralPortion).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralPortion, {\n      transform: function(transformer) {\n        return transformer.transformTemplateLiteralPortion(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateLiteralPortion(this);\n      },\n      get type() {\n        return TEMPLATE_LITERAL_PORTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TEMPLATE_SUBSTITUTION = ParseTreeType.TEMPLATE_SUBSTITUTION;\n  var TemplateSubstitution = function($__super) {\n    function TemplateSubstitution(location, expression) {\n      $traceurRuntime.superConstructor(TemplateSubstitution).call(this, location);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(TemplateSubstitution, {\n      transform: function(transformer) {\n        return transformer.transformTemplateSubstitution(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTemplateSubstitution(this);\n      },\n      get type() {\n        return TEMPLATE_SUBSTITUTION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var THIS_EXPRESSION = ParseTreeType.THIS_EXPRESSION;\n  var ThisExpression = function($__super) {\n    function ThisExpression(location) {\n      $traceurRuntime.superConstructor(ThisExpression).call(this, location);\n    }\n    return ($traceurRuntime.createClass)(ThisExpression, {\n      transform: function(transformer) {\n        return transformer.transformThisExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitThisExpression(this);\n      },\n      get type() {\n        return THIS_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var THROW_STATEMENT = ParseTreeType.THROW_STATEMENT;\n  var ThrowStatement = function($__super) {\n    function ThrowStatement(location, value) {\n      $traceurRuntime.superConstructor(ThrowStatement).call(this, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(ThrowStatement, {\n      transform: function(transformer) {\n        return transformer.transformThrowStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitThrowStatement(this);\n      },\n      get type() {\n        return THROW_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TRY_STATEMENT = ParseTreeType.TRY_STATEMENT;\n  var TryStatement = function($__super) {\n    function TryStatement(location, body, catchBlock, finallyBlock) {\n      $traceurRuntime.superConstructor(TryStatement).call(this, location);\n      this.body = body;\n      this.catchBlock = catchBlock;\n      this.finallyBlock = finallyBlock;\n    }\n    return ($traceurRuntime.createClass)(TryStatement, {\n      transform: function(transformer) {\n        return transformer.transformTryStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTryStatement(this);\n      },\n      get type() {\n        return TRY_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_ALIAS_DECLARATION = ParseTreeType.TYPE_ALIAS_DECLARATION;\n  var TypeAliasDeclaration = function($__super) {\n    function TypeAliasDeclaration(location, name, value) {\n      $traceurRuntime.superConstructor(TypeAliasDeclaration).call(this, location);\n      this.name = name;\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(TypeAliasDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformTypeAliasDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeAliasDeclaration(this);\n      },\n      get type() {\n        return TYPE_ALIAS_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_ARGUMENTS = ParseTreeType.TYPE_ARGUMENTS;\n  var TypeArguments = function($__super) {\n    function TypeArguments(location, args) {\n      $traceurRuntime.superConstructor(TypeArguments).call(this, location);\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(TypeArguments, {\n      transform: function(transformer) {\n        return transformer.transformTypeArguments(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeArguments(this);\n      },\n      get type() {\n        return TYPE_ARGUMENTS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_NAME = ParseTreeType.TYPE_NAME;\n  var TypeName = function($__super) {\n    function TypeName(location, moduleName, name) {\n      $traceurRuntime.superConstructor(TypeName).call(this, location);\n      this.moduleName = moduleName;\n      this.name = name;\n    }\n    return ($traceurRuntime.createClass)(TypeName, {\n      transform: function(transformer) {\n        return transformer.transformTypeName(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeName(this);\n      },\n      get type() {\n        return TYPE_NAME;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_PARAMETER = ParseTreeType.TYPE_PARAMETER;\n  var TypeParameter = function($__super) {\n    function TypeParameter(location, identifierToken, extendsType) {\n      $traceurRuntime.superConstructor(TypeParameter).call(this, location);\n      this.identifierToken = identifierToken;\n      this.extendsType = extendsType;\n    }\n    return ($traceurRuntime.createClass)(TypeParameter, {\n      transform: function(transformer) {\n        return transformer.transformTypeParameter(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeParameter(this);\n      },\n      get type() {\n        return TYPE_PARAMETER;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_PARAMETERS = ParseTreeType.TYPE_PARAMETERS;\n  var TypeParameters = function($__super) {\n    function TypeParameters(location, parameters) {\n      $traceurRuntime.superConstructor(TypeParameters).call(this, location);\n      this.parameters = parameters;\n    }\n    return ($traceurRuntime.createClass)(TypeParameters, {\n      transform: function(transformer) {\n        return transformer.transformTypeParameters(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeParameters(this);\n      },\n      get type() {\n        return TYPE_PARAMETERS;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var TYPE_REFERENCE = ParseTreeType.TYPE_REFERENCE;\n  var TypeReference = function($__super) {\n    function TypeReference(location, typeName, args) {\n      $traceurRuntime.superConstructor(TypeReference).call(this, location);\n      this.typeName = typeName;\n      this.args = args;\n    }\n    return ($traceurRuntime.createClass)(TypeReference, {\n      transform: function(transformer) {\n        return transformer.transformTypeReference(this);\n      },\n      visit: function(visitor) {\n        visitor.visitTypeReference(this);\n      },\n      get type() {\n        return TYPE_REFERENCE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var UNARY_EXPRESSION = ParseTreeType.UNARY_EXPRESSION;\n  var UnaryExpression = function($__super) {\n    function UnaryExpression(location, operator, operand) {\n      $traceurRuntime.superConstructor(UnaryExpression).call(this, location);\n      this.operator = operator;\n      this.operand = operand;\n    }\n    return ($traceurRuntime.createClass)(UnaryExpression, {\n      transform: function(transformer) {\n        return transformer.transformUnaryExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitUnaryExpression(this);\n      },\n      get type() {\n        return UNARY_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var UNION_TYPE = ParseTreeType.UNION_TYPE;\n  var UnionType = function($__super) {\n    function UnionType(location, types) {\n      $traceurRuntime.superConstructor(UnionType).call(this, location);\n      this.types = types;\n    }\n    return ($traceurRuntime.createClass)(UnionType, {\n      transform: function(transformer) {\n        return transformer.transformUnionType(this);\n      },\n      visit: function(visitor) {\n        visitor.visitUnionType(this);\n      },\n      get type() {\n        return UNION_TYPE;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_DECLARATION = ParseTreeType.VARIABLE_DECLARATION;\n  var VariableDeclaration = function($__super) {\n    function VariableDeclaration(location, lvalue, typeAnnotation, initializer) {\n      $traceurRuntime.superConstructor(VariableDeclaration).call(this, location);\n      this.lvalue = lvalue;\n      this.typeAnnotation = typeAnnotation;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(VariableDeclaration, {\n      transform: function(transformer) {\n        return transformer.transformVariableDeclaration(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableDeclaration(this);\n      },\n      get type() {\n        return VARIABLE_DECLARATION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_DECLARATION_LIST = ParseTreeType.VARIABLE_DECLARATION_LIST;\n  var VariableDeclarationList = function($__super) {\n    function VariableDeclarationList(location, declarationType, declarations) {\n      $traceurRuntime.superConstructor(VariableDeclarationList).call(this, location);\n      this.declarationType = declarationType;\n      this.declarations = declarations;\n    }\n    return ($traceurRuntime.createClass)(VariableDeclarationList, {\n      transform: function(transformer) {\n        return transformer.transformVariableDeclarationList(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableDeclarationList(this);\n      },\n      get type() {\n        return VARIABLE_DECLARATION_LIST;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var VARIABLE_STATEMENT = ParseTreeType.VARIABLE_STATEMENT;\n  var VariableStatement = function($__super) {\n    function VariableStatement(location, declarations) {\n      $traceurRuntime.superConstructor(VariableStatement).call(this, location);\n      this.declarations = declarations;\n    }\n    return ($traceurRuntime.createClass)(VariableStatement, {\n      transform: function(transformer) {\n        return transformer.transformVariableStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitVariableStatement(this);\n      },\n      get type() {\n        return VARIABLE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var WHILE_STATEMENT = ParseTreeType.WHILE_STATEMENT;\n  var WhileStatement = function($__super) {\n    function WhileStatement(location, condition, body) {\n      $traceurRuntime.superConstructor(WhileStatement).call(this, location);\n      this.condition = condition;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(WhileStatement, {\n      transform: function(transformer) {\n        return transformer.transformWhileStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitWhileStatement(this);\n      },\n      get type() {\n        return WHILE_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var WITH_STATEMENT = ParseTreeType.WITH_STATEMENT;\n  var WithStatement = function($__super) {\n    function WithStatement(location, expression, body) {\n      $traceurRuntime.superConstructor(WithStatement).call(this, location);\n      this.expression = expression;\n      this.body = body;\n    }\n    return ($traceurRuntime.createClass)(WithStatement, {\n      transform: function(transformer) {\n        return transformer.transformWithStatement(this);\n      },\n      visit: function(visitor) {\n        visitor.visitWithStatement(this);\n      },\n      get type() {\n        return WITH_STATEMENT;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  var YIELD_EXPRESSION = ParseTreeType.YIELD_EXPRESSION;\n  var YieldExpression = function($__super) {\n    function YieldExpression(location, expression, isYieldFor) {\n      $traceurRuntime.superConstructor(YieldExpression).call(this, location);\n      this.expression = expression;\n      this.isYieldFor = isYieldFor;\n    }\n    return ($traceurRuntime.createClass)(YieldExpression, {\n      transform: function(transformer) {\n        return transformer.transformYieldExpression(this);\n      },\n      visit: function(visitor) {\n        visitor.visitYieldExpression(this);\n      },\n      get type() {\n        return YIELD_EXPRESSION;\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  return {\n    get Annotation() {\n      return Annotation;\n    },\n    get AnonBlock() {\n      return AnonBlock;\n    },\n    get ArgumentList() {\n      return ArgumentList;\n    },\n    get ArrayComprehension() {\n      return ArrayComprehension;\n    },\n    get ArrayLiteral() {\n      return ArrayLiteral;\n    },\n    get ArrayPattern() {\n      return ArrayPattern;\n    },\n    get ArrayType() {\n      return ArrayType;\n    },\n    get ArrowFunction() {\n      return ArrowFunction;\n    },\n    get AssignmentElement() {\n      return AssignmentElement;\n    },\n    get AwaitExpression() {\n      return AwaitExpression;\n    },\n    get BinaryExpression() {\n      return BinaryExpression;\n    },\n    get BindingElement() {\n      return BindingElement;\n    },\n    get BindingIdentifier() {\n      return BindingIdentifier;\n    },\n    get Block() {\n      return Block;\n    },\n    get BreakStatement() {\n      return BreakStatement;\n    },\n    get CallExpression() {\n      return CallExpression;\n    },\n    get CallSignature() {\n      return CallSignature;\n    },\n    get CaseClause() {\n      return CaseClause;\n    },\n    get Catch() {\n      return Catch;\n    },\n    get ClassDeclaration() {\n      return ClassDeclaration;\n    },\n    get ClassExpression() {\n      return ClassExpression;\n    },\n    get CommaExpression() {\n      return CommaExpression;\n    },\n    get ComprehensionFor() {\n      return ComprehensionFor;\n    },\n    get ComprehensionIf() {\n      return ComprehensionIf;\n    },\n    get ComputedPropertyName() {\n      return ComputedPropertyName;\n    },\n    get ConditionalExpression() {\n      return ConditionalExpression;\n    },\n    get ConstructSignature() {\n      return ConstructSignature;\n    },\n    get ConstructorType() {\n      return ConstructorType;\n    },\n    get ContinueStatement() {\n      return ContinueStatement;\n    },\n    get CoverFormals() {\n      return CoverFormals;\n    },\n    get CoverInitializedName() {\n      return CoverInitializedName;\n    },\n    get DebuggerStatement() {\n      return DebuggerStatement;\n    },\n    get DefaultClause() {\n      return DefaultClause;\n    },\n    get DoWhileStatement() {\n      return DoWhileStatement;\n    },\n    get EmptyStatement() {\n      return EmptyStatement;\n    },\n    get ExportDeclaration() {\n      return ExportDeclaration;\n    },\n    get ExportDefault() {\n      return ExportDefault;\n    },\n    get ExportSpecifier() {\n      return ExportSpecifier;\n    },\n    get ExportSpecifierSet() {\n      return ExportSpecifierSet;\n    },\n    get ExportStar() {\n      return ExportStar;\n    },\n    get ExpressionStatement() {\n      return ExpressionStatement;\n    },\n    get Finally() {\n      return Finally;\n    },\n    get ForInStatement() {\n      return ForInStatement;\n    },\n    get ForOfStatement() {\n      return ForOfStatement;\n    },\n    get ForOnStatement() {\n      return ForOnStatement;\n    },\n    get ForStatement() {\n      return ForStatement;\n    },\n    get FormalParameter() {\n      return FormalParameter;\n    },\n    get FormalParameterList() {\n      return FormalParameterList;\n    },\n    get ForwardDefaultExport() {\n      return ForwardDefaultExport;\n    },\n    get FunctionBody() {\n      return FunctionBody;\n    },\n    get FunctionDeclaration() {\n      return FunctionDeclaration;\n    },\n    get FunctionExpression() {\n      return FunctionExpression;\n    },\n    get FunctionType() {\n      return FunctionType;\n    },\n    get GeneratorComprehension() {\n      return GeneratorComprehension;\n    },\n    get GetAccessor() {\n      return GetAccessor;\n    },\n    get IdentifierExpression() {\n      return IdentifierExpression;\n    },\n    get IfStatement() {\n      return IfStatement;\n    },\n    get ImportedBinding() {\n      return ImportedBinding;\n    },\n    get ImportClausePair() {\n      return ImportClausePair;\n    },\n    get ImportDeclaration() {\n      return ImportDeclaration;\n    },\n    get ImportSpecifier() {\n      return ImportSpecifier;\n    },\n    get ImportSpecifierSet() {\n      return ImportSpecifierSet;\n    },\n    get ImportTypeClause() {\n      return ImportTypeClause;\n    },\n    get IndexSignature() {\n      return IndexSignature;\n    },\n    get InterfaceDeclaration() {\n      return InterfaceDeclaration;\n    },\n    get JsxAttribute() {\n      return JsxAttribute;\n    },\n    get JsxElement() {\n      return JsxElement;\n    },\n    get JsxElementName() {\n      return JsxElementName;\n    },\n    get JsxPlaceholder() {\n      return JsxPlaceholder;\n    },\n    get JsxSpreadAttribute() {\n      return JsxSpreadAttribute;\n    },\n    get JsxText() {\n      return JsxText;\n    },\n    get LabelledStatement() {\n      return LabelledStatement;\n    },\n    get LiteralExpression() {\n      return LiteralExpression;\n    },\n    get LiteralPropertyName() {\n      return LiteralPropertyName;\n    },\n    get MemberExpression() {\n      return MemberExpression;\n    },\n    get MemberLookupExpression() {\n      return MemberLookupExpression;\n    },\n    get Method() {\n      return Method;\n    },\n    get MethodSignature() {\n      return MethodSignature;\n    },\n    get Module() {\n      return Module;\n    },\n    get ModuleSpecifier() {\n      return ModuleSpecifier;\n    },\n    get NameSpaceExport() {\n      return NameSpaceExport;\n    },\n    get NameSpaceImport() {\n      return NameSpaceImport;\n    },\n    get NamedExport() {\n      return NamedExport;\n    },\n    get NewExpression() {\n      return NewExpression;\n    },\n    get ObjectLiteral() {\n      return ObjectLiteral;\n    },\n    get ObjectPattern() {\n      return ObjectPattern;\n    },\n    get ObjectPatternField() {\n      return ObjectPatternField;\n    },\n    get ObjectType() {\n      return ObjectType;\n    },\n    get ParenExpression() {\n      return ParenExpression;\n    },\n    get PostfixExpression() {\n      return PostfixExpression;\n    },\n    get PredefinedType() {\n      return PredefinedType;\n    },\n    get Script() {\n      return Script;\n    },\n    get PropertyNameAssignment() {\n      return PropertyNameAssignment;\n    },\n    get PropertyNameShorthand() {\n      return PropertyNameShorthand;\n    },\n    get PropertyVariableDeclaration() {\n      return PropertyVariableDeclaration;\n    },\n    get PropertySignature() {\n      return PropertySignature;\n    },\n    get RestParameter() {\n      return RestParameter;\n    },\n    get ReturnStatement() {\n      return ReturnStatement;\n    },\n    get SetAccessor() {\n      return SetAccessor;\n    },\n    get SpreadExpression() {\n      return SpreadExpression;\n    },\n    get SpreadPatternElement() {\n      return SpreadPatternElement;\n    },\n    get SuperExpression() {\n      return SuperExpression;\n    },\n    get SwitchStatement() {\n      return SwitchStatement;\n    },\n    get SyntaxErrorTree() {\n      return SyntaxErrorTree;\n    },\n    get TemplateLiteralExpression() {\n      return TemplateLiteralExpression;\n    },\n    get TemplateLiteralPortion() {\n      return TemplateLiteralPortion;\n    },\n    get TemplateSubstitution() {\n      return TemplateSubstitution;\n    },\n    get ThisExpression() {\n      return ThisExpression;\n    },\n    get ThrowStatement() {\n      return ThrowStatement;\n    },\n    get TryStatement() {\n      return TryStatement;\n    },\n    get TypeAliasDeclaration() {\n      return TypeAliasDeclaration;\n    },\n    get TypeArguments() {\n      return TypeArguments;\n    },\n    get TypeName() {\n      return TypeName;\n    },\n    get TypeParameter() {\n      return TypeParameter;\n    },\n    get TypeParameters() {\n      return TypeParameters;\n    },\n    get TypeReference() {\n      return TypeReference;\n    },\n    get UnaryExpression() {\n      return UnaryExpression;\n    },\n    get UnionType() {\n      return UnionType;\n    },\n    get VariableDeclaration() {\n      return VariableDeclaration;\n    },\n    get VariableDeclarationList() {\n      return VariableDeclarationList;\n    },\n    get VariableStatement() {\n      return VariableStatement;\n    },\n    get WhileStatement() {\n      return WhileStatement;\n    },\n    get WithStatement() {\n      return WithStatement;\n    },\n    get YieldExpression() {\n      return YieldExpression;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeTransformer.js\")),\n      Annotation = $__2.Annotation,\n      AnonBlock = $__2.AnonBlock,\n      ArgumentList = $__2.ArgumentList,\n      ArrayComprehension = $__2.ArrayComprehension,\n      ArrayLiteral = $__2.ArrayLiteral,\n      ArrayPattern = $__2.ArrayPattern,\n      ArrayType = $__2.ArrayType,\n      ArrowFunction = $__2.ArrowFunction,\n      AssignmentElement = $__2.AssignmentElement,\n      AwaitExpression = $__2.AwaitExpression,\n      BinaryExpression = $__2.BinaryExpression,\n      BindingElement = $__2.BindingElement,\n      BindingIdentifier = $__2.BindingIdentifier,\n      Block = $__2.Block,\n      BreakStatement = $__2.BreakStatement,\n      CallExpression = $__2.CallExpression,\n      CallSignature = $__2.CallSignature,\n      CaseClause = $__2.CaseClause,\n      Catch = $__2.Catch,\n      ClassDeclaration = $__2.ClassDeclaration,\n      ClassExpression = $__2.ClassExpression,\n      CommaExpression = $__2.CommaExpression,\n      ComprehensionFor = $__2.ComprehensionFor,\n      ComprehensionIf = $__2.ComprehensionIf,\n      ComputedPropertyName = $__2.ComputedPropertyName,\n      ConditionalExpression = $__2.ConditionalExpression,\n      ConstructSignature = $__2.ConstructSignature,\n      ConstructorType = $__2.ConstructorType,\n      ContinueStatement = $__2.ContinueStatement,\n      CoverFormals = $__2.CoverFormals,\n      CoverInitializedName = $__2.CoverInitializedName,\n      DebuggerStatement = $__2.DebuggerStatement,\n      DefaultClause = $__2.DefaultClause,\n      DoWhileStatement = $__2.DoWhileStatement,\n      EmptyStatement = $__2.EmptyStatement,\n      ExportDeclaration = $__2.ExportDeclaration,\n      ExportDefault = $__2.ExportDefault,\n      ExportSpecifier = $__2.ExportSpecifier,\n      ExportSpecifierSet = $__2.ExportSpecifierSet,\n      ExportStar = $__2.ExportStar,\n      ExpressionStatement = $__2.ExpressionStatement,\n      Finally = $__2.Finally,\n      ForInStatement = $__2.ForInStatement,\n      ForOfStatement = $__2.ForOfStatement,\n      ForOnStatement = $__2.ForOnStatement,\n      ForStatement = $__2.ForStatement,\n      FormalParameter = $__2.FormalParameter,\n      FormalParameterList = $__2.FormalParameterList,\n      ForwardDefaultExport = $__2.ForwardDefaultExport,\n      FunctionBody = $__2.FunctionBody,\n      FunctionDeclaration = $__2.FunctionDeclaration,\n      FunctionExpression = $__2.FunctionExpression,\n      FunctionType = $__2.FunctionType,\n      GeneratorComprehension = $__2.GeneratorComprehension,\n      GetAccessor = $__2.GetAccessor,\n      IdentifierExpression = $__2.IdentifierExpression,\n      IfStatement = $__2.IfStatement,\n      ImportedBinding = $__2.ImportedBinding,\n      ImportClausePair = $__2.ImportClausePair,\n      ImportDeclaration = $__2.ImportDeclaration,\n      ImportSpecifier = $__2.ImportSpecifier,\n      ImportSpecifierSet = $__2.ImportSpecifierSet,\n      ImportTypeClause = $__2.ImportTypeClause,\n      IndexSignature = $__2.IndexSignature,\n      InterfaceDeclaration = $__2.InterfaceDeclaration,\n      JsxAttribute = $__2.JsxAttribute,\n      JsxElement = $__2.JsxElement,\n      JsxElementName = $__2.JsxElementName,\n      JsxPlaceholder = $__2.JsxPlaceholder,\n      JsxSpreadAttribute = $__2.JsxSpreadAttribute,\n      JsxText = $__2.JsxText,\n      LabelledStatement = $__2.LabelledStatement,\n      LiteralExpression = $__2.LiteralExpression,\n      LiteralPropertyName = $__2.LiteralPropertyName,\n      MemberExpression = $__2.MemberExpression,\n      MemberLookupExpression = $__2.MemberLookupExpression,\n      Method = $__2.Method,\n      MethodSignature = $__2.MethodSignature,\n      Module = $__2.Module,\n      ModuleSpecifier = $__2.ModuleSpecifier,\n      NameSpaceExport = $__2.NameSpaceExport,\n      NameSpaceImport = $__2.NameSpaceImport,\n      NamedExport = $__2.NamedExport,\n      NewExpression = $__2.NewExpression,\n      ObjectLiteral = $__2.ObjectLiteral,\n      ObjectPattern = $__2.ObjectPattern,\n      ObjectPatternField = $__2.ObjectPatternField,\n      ObjectType = $__2.ObjectType,\n      ParenExpression = $__2.ParenExpression,\n      PostfixExpression = $__2.PostfixExpression,\n      PredefinedType = $__2.PredefinedType,\n      Script = $__2.Script,\n      PropertyNameAssignment = $__2.PropertyNameAssignment,\n      PropertyNameShorthand = $__2.PropertyNameShorthand,\n      PropertyVariableDeclaration = $__2.PropertyVariableDeclaration,\n      PropertySignature = $__2.PropertySignature,\n      RestParameter = $__2.RestParameter,\n      ReturnStatement = $__2.ReturnStatement,\n      SetAccessor = $__2.SetAccessor,\n      SpreadExpression = $__2.SpreadExpression,\n      SpreadPatternElement = $__2.SpreadPatternElement,\n      SuperExpression = $__2.SuperExpression,\n      SwitchStatement = $__2.SwitchStatement,\n      SyntaxErrorTree = $__2.SyntaxErrorTree,\n      TemplateLiteralExpression = $__2.TemplateLiteralExpression,\n      TemplateLiteralPortion = $__2.TemplateLiteralPortion,\n      TemplateSubstitution = $__2.TemplateSubstitution,\n      ThisExpression = $__2.ThisExpression,\n      ThrowStatement = $__2.ThrowStatement,\n      TryStatement = $__2.TryStatement,\n      TypeAliasDeclaration = $__2.TypeAliasDeclaration,\n      TypeArguments = $__2.TypeArguments,\n      TypeName = $__2.TypeName,\n      TypeParameter = $__2.TypeParameter,\n      TypeParameters = $__2.TypeParameters,\n      TypeReference = $__2.TypeReference,\n      UnaryExpression = $__2.UnaryExpression,\n      UnionType = $__2.UnionType,\n      VariableDeclaration = $__2.VariableDeclaration,\n      VariableDeclarationList = $__2.VariableDeclarationList,\n      VariableStatement = $__2.VariableStatement,\n      WhileStatement = $__2.WhileStatement,\n      WithStatement = $__2.WithStatement,\n      YieldExpression = $__2.YieldExpression;\n  var ParseTreeTransformer = function() {\n    function ParseTreeTransformer() {}\n    return ($traceurRuntime.createClass)(ParseTreeTransformer, {\n      transformAny: function(tree) {\n        return tree === null ? null : tree.transform(this);\n      },\n      transformList: function(list) {\n        var $__1;\n        var builder = null;\n        for (var index = 0; index < list.length; index++) {\n          var element = list[index];\n          var transformed = this.transformAny(element);\n          if (builder != null || element != transformed) {\n            if (builder === null) {\n              builder = list.slice(0, index);\n            }\n            if (transformed instanceof AnonBlock)\n              ($__1 = builder).push.apply($__1, $traceurRuntime.spread(transformed.statements));\n            else\n              builder.push(transformed);\n          }\n        }\n        return builder || list;\n      },\n      transformStateMachine: function(tree) {\n        throw Error('State machines should not live outside of the GeneratorTransformer.');\n      },\n      transformToBlockOrStatement: function(tree) {\n        var transformed = this.transformAny(tree);\n        if (transformed instanceof AnonBlock) {\n          return new Block(transformed.location, transformed.statements);\n        }\n        return transformed;\n      },\n      transformAnnotation: function(tree) {\n        var name = this.transformAny(tree.name);\n        var args = this.transformAny(tree.args);\n        if (name === tree.name && args === tree.args) {\n          return tree;\n        }\n        return new Annotation(tree.location, name, args);\n      },\n      transformAnonBlock: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new AnonBlock(tree.location, statements);\n      },\n      transformArgumentList: function(tree) {\n        var args = this.transformList(tree.args);\n        if (args === tree.args) {\n          return tree;\n        }\n        return new ArgumentList(tree.location, args);\n      },\n      transformArrayComprehension: function(tree) {\n        var comprehensionList = this.transformList(tree.comprehensionList);\n        var expression = this.transformAny(tree.expression);\n        if (comprehensionList === tree.comprehensionList && expression === tree.expression) {\n          return tree;\n        }\n        return new ArrayComprehension(tree.location, comprehensionList, expression);\n      },\n      transformArrayLiteral: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements) {\n          return tree;\n        }\n        return new ArrayLiteral(tree.location, elements);\n      },\n      transformArrayPattern: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements) {\n          return tree;\n        }\n        return new ArrayPattern(tree.location, elements);\n      },\n      transformArrayType: function(tree) {\n        var elementType = this.transformAny(tree.elementType);\n        if (elementType === tree.elementType) {\n          return tree;\n        }\n        return new ArrayType(tree.location, elementType);\n      },\n      transformArrowFunction: function(tree) {\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new ArrowFunction(tree.location, tree.functionKind, parameterList, body);\n      },\n      transformAssignmentElement: function(tree) {\n        var assignment = this.transformAny(tree.assignment);\n        var initializer = this.transformAny(tree.initializer);\n        if (assignment === tree.assignment && initializer === tree.initializer) {\n          return tree;\n        }\n        return new AssignmentElement(tree.location, assignment, initializer);\n      },\n      transformAwaitExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new AwaitExpression(tree.location, expression);\n      },\n      transformBinaryExpression: function(tree) {\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left === tree.left && right === tree.right) {\n          return tree;\n        }\n        return new BinaryExpression(tree.location, left, tree.operator, right);\n      },\n      transformBindingElement: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        var initializer = this.transformAny(tree.initializer);\n        if (binding === tree.binding && initializer === tree.initializer) {\n          return tree;\n        }\n        return new BindingElement(tree.location, binding, initializer);\n      },\n      transformBindingIdentifier: function(tree) {\n        return tree;\n      },\n      transformBlock: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new Block(tree.location, statements);\n      },\n      transformBreakStatement: function(tree) {\n        return tree;\n      },\n      transformCallExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        if (operand === tree.operand && args === tree.args) {\n          return tree;\n        }\n        return new CallExpression(tree.location, operand, args);\n      },\n      transformCallSignature: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new CallSignature(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformCaseClause: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var statements = this.transformList(tree.statements);\n        if (expression === tree.expression && statements === tree.statements) {\n          return tree;\n        }\n        return new CaseClause(tree.location, expression, statements);\n      },\n      transformCatch: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        var catchBody = this.transformAny(tree.catchBody);\n        if (binding === tree.binding && catchBody === tree.catchBody) {\n          return tree;\n        }\n        return new Catch(tree.location, binding, catchBody);\n      },\n      transformClassDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var typeParameters = this.transformAny(tree.typeParameters);\n        if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations && typeParameters === tree.typeParameters) {\n          return tree;\n        }\n        return new ClassDeclaration(tree.location, name, superClass, elements, annotations, typeParameters);\n      },\n      transformClassExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var typeParameters = this.transformAny(tree.typeParameters);\n        if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations && typeParameters === tree.typeParameters) {\n          return tree;\n        }\n        return new ClassExpression(tree.location, name, superClass, elements, annotations, typeParameters);\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions) {\n          return tree;\n        }\n        return new CommaExpression(tree.location, expressions);\n      },\n      transformComprehensionFor: function(tree) {\n        var left = this.transformAny(tree.left);\n        var iterator = this.transformAny(tree.iterator);\n        if (left === tree.left && iterator === tree.iterator) {\n          return tree;\n        }\n        return new ComprehensionFor(tree.location, left, iterator);\n      },\n      transformComprehensionIf: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ComprehensionIf(tree.location, expression);\n      },\n      transformComputedPropertyName: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ComputedPropertyName(tree.location, expression);\n      },\n      transformConditionalExpression: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (condition === tree.condition && left === tree.left && right === tree.right) {\n          return tree;\n        }\n        return new ConditionalExpression(tree.location, condition, left, right);\n      },\n      transformConstructSignature: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new ConstructSignature(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformConstructorType: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new ConstructorType(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformContinueStatement: function(tree) {\n        return tree;\n      },\n      transformCoverFormals: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions) {\n          return tree;\n        }\n        return new CoverFormals(tree.location, expressions);\n      },\n      transformCoverInitializedName: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        if (initializer === tree.initializer) {\n          return tree;\n        }\n        return new CoverInitializedName(tree.location, tree.name, tree.equalToken, initializer);\n      },\n      transformDebuggerStatement: function(tree) {\n        return tree;\n      },\n      transformDefaultClause: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new DefaultClause(tree.location, statements);\n      },\n      transformDoWhileStatement: function(tree) {\n        var body = this.transformToBlockOrStatement(tree.body);\n        var condition = this.transformAny(tree.condition);\n        if (body === tree.body && condition === tree.condition) {\n          return tree;\n        }\n        return new DoWhileStatement(tree.location, body, condition);\n      },\n      transformEmptyStatement: function(tree) {\n        return tree;\n      },\n      transformExportDeclaration: function(tree) {\n        var declaration = this.transformAny(tree.declaration);\n        var annotations = this.transformList(tree.annotations);\n        if (declaration === tree.declaration && annotations === tree.annotations) {\n          return tree;\n        }\n        return new ExportDeclaration(tree.location, declaration, annotations);\n      },\n      transformExportDefault: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ExportDefault(tree.location, expression);\n      },\n      transformExportSpecifier: function(tree) {\n        return tree;\n      },\n      transformExportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        if (specifiers === tree.specifiers) {\n          return tree;\n        }\n        return new ExportSpecifierSet(tree.location, specifiers);\n      },\n      transformExportStar: function(tree) {\n        return tree;\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ExpressionStatement(tree.location, expression);\n      },\n      transformFinally: function(tree) {\n        var block = this.transformAny(tree.block);\n        if (block === tree.block) {\n          return tree;\n        }\n        return new Finally(tree.location, block);\n      },\n      transformForInStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ForInStatement(tree.location, initializer, collection, body);\n      },\n      transformForOfStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ForOfStatement(tree.location, initializer, collection, body);\n      },\n      transformForOnStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var observable = this.transformAny(tree.observable);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && observable === tree.observable && body === tree.body) {\n          return tree;\n        }\n        return new ForOnStatement(tree.location, initializer, observable, body);\n      },\n      transformForStatement: function(tree) {\n        var initializer = this.transformAny(tree.initializer);\n        var condition = this.transformAny(tree.condition);\n        var increment = this.transformAny(tree.increment);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        return new ForStatement(tree.location, initializer, condition, increment, body);\n      },\n      transformFormalParameter: function(tree) {\n        var parameter = this.transformAny(tree.parameter);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        if (parameter === tree.parameter && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations) {\n          return tree;\n        }\n        return new FormalParameter(tree.location, parameter, typeAnnotation, annotations);\n      },\n      transformFormalParameterList: function(tree) {\n        var parameters = this.transformList(tree.parameters);\n        if (parameters === tree.parameters) {\n          return tree;\n        }\n        return new FormalParameterList(tree.location, parameters);\n      },\n      transformForwardDefaultExport: function(tree) {\n        return tree;\n      },\n      transformFunctionBody: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements) {\n          return tree;\n        }\n        return new FunctionBody(tree.location, statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionDeclaration(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionExpression(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionType: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var parameterList = this.transformAny(tree.parameterList);\n        var returnType = this.transformAny(tree.returnType);\n        if (typeParameters === tree.typeParameters && parameterList === tree.parameterList && returnType === tree.returnType) {\n          return tree;\n        }\n        return new FunctionType(tree.location, typeParameters, parameterList, returnType);\n      },\n      transformGeneratorComprehension: function(tree) {\n        var comprehensionList = this.transformList(tree.comprehensionList);\n        var expression = this.transformAny(tree.expression);\n        if (comprehensionList === tree.comprehensionList && expression === tree.expression) {\n          return tree;\n        }\n        return new GeneratorComprehension(tree.location, comprehensionList, expression);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, typeAnnotation, annotations, body);\n      },\n      transformIdentifierExpression: function(tree) {\n        return tree;\n      },\n      transformIfStatement: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var ifClause = this.transformToBlockOrStatement(tree.ifClause);\n        var elseClause = this.transformToBlockOrStatement(tree.elseClause);\n        if (condition === tree.condition && ifClause === tree.ifClause && elseClause === tree.elseClause) {\n          return tree;\n        }\n        return new IfStatement(tree.location, condition, ifClause, elseClause);\n      },\n      transformImportedBinding: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new ImportedBinding(tree.location, binding);\n      },\n      transformImportClausePair: function(tree) {\n        var first = this.transformAny(tree.first);\n        var second = this.transformAny(tree.second);\n        if (first === tree.first && second === tree.second) {\n          return tree;\n        }\n        return new ImportClausePair(tree.location, first, second);\n      },\n      transformImportDeclaration: function(tree) {\n        var importClause = this.transformAny(tree.importClause);\n        var moduleSpecifier = this.transformAny(tree.moduleSpecifier);\n        if (importClause === tree.importClause && moduleSpecifier === tree.moduleSpecifier) {\n          return tree;\n        }\n        return new ImportDeclaration(tree.location, importClause, moduleSpecifier);\n      },\n      transformImportSpecifier: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new ImportSpecifier(tree.location, binding, tree.name);\n      },\n      transformImportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        if (specifiers === tree.specifiers) {\n          return tree;\n        }\n        return new ImportSpecifierSet(tree.location, specifiers);\n      },\n      transformImportTypeClause: function(tree) {\n        var clause = this.transformAny(tree.clause);\n        if (clause === tree.clause) {\n          return tree;\n        }\n        return new ImportTypeClause(tree.location, clause);\n      },\n      transformIndexSignature: function(tree) {\n        var indexType = this.transformAny(tree.indexType);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        if (indexType === tree.indexType && typeAnnotation === tree.typeAnnotation) {\n          return tree;\n        }\n        return new IndexSignature(tree.location, tree.name, indexType, typeAnnotation);\n      },\n      transformInterfaceDeclaration: function(tree) {\n        var typeParameters = this.transformAny(tree.typeParameters);\n        var objectType = this.transformAny(tree.objectType);\n        if (typeParameters === tree.typeParameters && objectType === tree.objectType) {\n          return tree;\n        }\n        return new InterfaceDeclaration(tree.location, tree.name, typeParameters, tree.extendsClause, objectType);\n      },\n      transformJsxAttribute: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new JsxAttribute(tree.location, tree.name, value);\n      },\n      transformJsxElement: function(tree) {\n        var name = this.transformAny(tree.name);\n        var attributes = this.transformList(tree.attributes);\n        var children = this.transformList(tree.children);\n        if (name === tree.name && attributes === tree.attributes && children === tree.children) {\n          return tree;\n        }\n        return new JsxElement(tree.location, name, attributes, children);\n      },\n      transformJsxElementName: function(tree) {\n        return tree;\n      },\n      transformJsxPlaceholder: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new JsxPlaceholder(tree.location, expression);\n      },\n      transformJsxSpreadAttribute: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new JsxSpreadAttribute(tree.location, expression);\n      },\n      transformJsxText: function(tree) {\n        return tree;\n      },\n      transformLabelledStatement: function(tree) {\n        var statement = this.transformAny(tree.statement);\n        if (statement === tree.statement) {\n          return tree;\n        }\n        return new LabelledStatement(tree.location, tree.name, statement);\n      },\n      transformLiteralExpression: function(tree) {\n        return tree;\n      },\n      transformLiteralPropertyName: function(tree) {\n        return tree;\n      },\n      transformMemberExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new MemberExpression(tree.location, operand, tree.memberName);\n      },\n      transformMemberLookupExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var memberExpression = this.transformAny(tree.memberExpression);\n        if (operand === tree.operand && memberExpression === tree.memberExpression) {\n          return tree;\n        }\n        return new MemberLookupExpression(tree.location, operand, memberExpression);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        var debugName = this.transformAny(tree.debugName);\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body && debugName === tree.debugName) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, typeAnnotation, annotations, body, debugName);\n      },\n      transformMethodSignature: function(tree) {\n        var name = this.transformAny(tree.name);\n        var callSignature = this.transformAny(tree.callSignature);\n        if (name === tree.name && callSignature === tree.callSignature) {\n          return tree;\n        }\n        return new MethodSignature(tree.location, name, tree.optional, callSignature);\n      },\n      transformModule: function(tree) {\n        var scriptItemList = this.transformList(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Module(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformModuleSpecifier: function(tree) {\n        return tree;\n      },\n      transformNameSpaceExport: function(tree) {\n        return tree;\n      },\n      transformNameSpaceImport: function(tree) {\n        var binding = this.transformAny(tree.binding);\n        if (binding === tree.binding) {\n          return tree;\n        }\n        return new NameSpaceImport(tree.location, binding);\n      },\n      transformNamedExport: function(tree) {\n        var exportClause = this.transformAny(tree.exportClause);\n        var moduleSpecifier = this.transformAny(tree.moduleSpecifier);\n        if (exportClause === tree.exportClause && moduleSpecifier === tree.moduleSpecifier) {\n          return tree;\n        }\n        return new NamedExport(tree.location, exportClause, moduleSpecifier);\n      },\n      transformNewExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        if (operand === tree.operand && args === tree.args) {\n          return tree;\n        }\n        return new NewExpression(tree.location, operand, args);\n      },\n      transformObjectLiteral: function(tree) {\n        var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);\n        if (propertyNameAndValues === tree.propertyNameAndValues) {\n          return tree;\n        }\n        return new ObjectLiteral(tree.location, propertyNameAndValues);\n      },\n      transformObjectPattern: function(tree) {\n        var fields = this.transformList(tree.fields);\n        if (fields === tree.fields) {\n          return tree;\n        }\n        return new ObjectPattern(tree.location, fields);\n      },\n      transformObjectPatternField: function(tree) {\n        var name = this.transformAny(tree.name);\n        var element = this.transformAny(tree.element);\n        if (name === tree.name && element === tree.element) {\n          return tree;\n        }\n        return new ObjectPatternField(tree.location, name, element);\n      },\n      transformObjectType: function(tree) {\n        var typeMembers = this.transformList(tree.typeMembers);\n        if (typeMembers === tree.typeMembers) {\n          return tree;\n        }\n        return new ObjectType(tree.location, typeMembers);\n      },\n      transformParenExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ParenExpression(tree.location, expression);\n      },\n      transformPostfixExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new PostfixExpression(tree.location, operand, tree.operator);\n      },\n      transformPredefinedType: function(tree) {\n        return tree;\n      },\n      transformScript: function(tree) {\n        var scriptItemList = this.transformList(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Script(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformPropertyNameAssignment: function(tree) {\n        var name = this.transformAny(tree.name);\n        var value = this.transformAny(tree.value);\n        if (name === tree.name && value === tree.value) {\n          return tree;\n        }\n        return new PropertyNameAssignment(tree.location, name, value);\n      },\n      transformPropertyNameShorthand: function(tree) {\n        return tree;\n      },\n      transformPropertyVariableDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var initializer = this.transformAny(tree.initializer);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && initializer === tree.initializer) {\n          return tree;\n        }\n        return new PropertyVariableDeclaration(tree.location, tree.isStatic, name, typeAnnotation, annotations, initializer);\n      },\n      transformPropertySignature: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation) {\n          return tree;\n        }\n        return new PropertySignature(tree.location, name, tree.optional, typeAnnotation);\n      },\n      transformRestParameter: function(tree) {\n        var identifier = this.transformAny(tree.identifier);\n        if (identifier === tree.identifier) {\n          return tree;\n        }\n        return new RestParameter(tree.location, identifier);\n      },\n      transformReturnStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new ReturnStatement(tree.location, expression);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var parameterList = this.transformAny(tree.parameterList);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAny(tree.body);\n        if (name === tree.name && parameterList === tree.parameterList && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, annotations, body);\n      },\n      transformSpreadExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new SpreadExpression(tree.location, expression);\n      },\n      transformSpreadPatternElement: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        if (lvalue === tree.lvalue) {\n          return tree;\n        }\n        return new SpreadPatternElement(tree.location, lvalue);\n      },\n      transformSuperExpression: function(tree) {\n        return tree;\n      },\n      transformSwitchStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var caseClauses = this.transformList(tree.caseClauses);\n        if (expression === tree.expression && caseClauses === tree.caseClauses) {\n          return tree;\n        }\n        return new SwitchStatement(tree.location, expression, caseClauses);\n      },\n      transformSyntaxErrorTree: function(tree) {\n        return tree;\n      },\n      transformTemplateLiteralExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var elements = this.transformList(tree.elements);\n        if (operand === tree.operand && elements === tree.elements) {\n          return tree;\n        }\n        return new TemplateLiteralExpression(tree.location, operand, elements);\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        return tree;\n      },\n      transformTemplateSubstitution: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new TemplateSubstitution(tree.location, expression);\n      },\n      transformThisExpression: function(tree) {\n        return tree;\n      },\n      transformThrowStatement: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new ThrowStatement(tree.location, value);\n      },\n      transformTryStatement: function(tree) {\n        var body = this.transformAny(tree.body);\n        var catchBlock = this.transformAny(tree.catchBlock);\n        var finallyBlock = this.transformAny(tree.finallyBlock);\n        if (body === tree.body && catchBlock === tree.catchBlock && finallyBlock === tree.finallyBlock) {\n          return tree;\n        }\n        return new TryStatement(tree.location, body, catchBlock, finallyBlock);\n      },\n      transformTypeAliasDeclaration: function(tree) {\n        var value = this.transformAny(tree.value);\n        if (value === tree.value) {\n          return tree;\n        }\n        return new TypeAliasDeclaration(tree.location, tree.name, value);\n      },\n      transformTypeArguments: function(tree) {\n        var args = this.transformList(tree.args);\n        if (args === tree.args) {\n          return tree;\n        }\n        return new TypeArguments(tree.location, args);\n      },\n      transformTypeName: function(tree) {\n        var moduleName = this.transformAny(tree.moduleName);\n        if (moduleName === tree.moduleName) {\n          return tree;\n        }\n        return new TypeName(tree.location, moduleName, tree.name);\n      },\n      transformTypeParameter: function(tree) {\n        var extendsType = this.transformAny(tree.extendsType);\n        if (extendsType === tree.extendsType) {\n          return tree;\n        }\n        return new TypeParameter(tree.location, tree.identifierToken, extendsType);\n      },\n      transformTypeParameters: function(tree) {\n        var parameters = this.transformList(tree.parameters);\n        if (parameters === tree.parameters) {\n          return tree;\n        }\n        return new TypeParameters(tree.location, parameters);\n      },\n      transformTypeReference: function(tree) {\n        var typeName = this.transformAny(tree.typeName);\n        var args = this.transformAny(tree.args);\n        if (typeName === tree.typeName && args === tree.args) {\n          return tree;\n        }\n        return new TypeReference(tree.location, typeName, args);\n      },\n      transformUnaryExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand) {\n          return tree;\n        }\n        return new UnaryExpression(tree.location, tree.operator, operand);\n      },\n      transformUnionType: function(tree) {\n        var types = this.transformList(tree.types);\n        if (types === tree.types) {\n          return tree;\n        }\n        return new UnionType(tree.location, types);\n      },\n      transformVariableDeclaration: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var initializer = this.transformAny(tree.initializer);\n        if (lvalue === tree.lvalue && typeAnnotation === tree.typeAnnotation && initializer === tree.initializer) {\n          return tree;\n        }\n        return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initializer);\n      },\n      transformVariableDeclarationList: function(tree) {\n        var declarations = this.transformList(tree.declarations);\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableDeclarationList(tree.location, tree.declarationType, declarations);\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableStatement(tree.location, declarations);\n      },\n      transformWhileStatement: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (condition === tree.condition && body === tree.body) {\n          return tree;\n        }\n        return new WhileStatement(tree.location, condition, body);\n      },\n      transformWithStatement: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var body = this.transformToBlockOrStatement(tree.body);\n        if (expression === tree.expression && body === tree.body) {\n          return tree;\n        }\n        return new WithStatement(tree.location, expression, body);\n      },\n      transformYieldExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression) {\n          return tree;\n        }\n        return new YieldExpression(tree.location, expression, tree.isYieldFor);\n      }\n    }, {});\n  }();\n  return {get ParseTreeTransformer() {\n      return ParseTreeTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js\")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/module/AttachModuleNameTransformer.js\")),\n      Module = $__2.Module,\n      Script = $__2.Script;\n  var AttachModuleNameTransformer = function($__super) {\n    function AttachModuleNameTransformer(moduleName) {\n      $traceurRuntime.superConstructor(AttachModuleNameTransformer).call(this);\n      this.moduleName_ = moduleName;\n    }\n    return ($traceurRuntime.createClass)(AttachModuleNameTransformer, {\n      transformModule: function(tree) {\n        return new Module(tree.location, tree.scriptItemList, this.moduleName_);\n      },\n      transformScript: function(tree) {\n        return new Script(tree.location, tree.scriptItemList, this.moduleName_);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get AttachModuleNameTransformer() {\n      return AttachModuleNameTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/IdentifierToken.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/IdentifierToken.js\";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/IdentifierToken.js\")).Token;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/IdentifierToken.js\")).IDENTIFIER;\n  var IdentifierToken = function($__super) {\n    function IdentifierToken(location, value) {\n      $traceurRuntime.superConstructor(IdentifierToken).call(this, IDENTIFIER, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(IdentifierToken, {toString: function() {\n        return this.value;\n      }}, {}, $__super);\n  }(Token);\n  return {get IdentifierToken() {\n      return IdentifierToken;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/LiteralToken.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/LiteralToken.js\";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/LiteralToken.js\")).Token;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/LiteralToken.js\")),\n      NULL = $__11.NULL,\n      NUMBER = $__11.NUMBER,\n      STRING = $__11.STRING;\n  var StringParser = function() {\n    var $__2;\n    function StringParser(value) {\n      this.value = value;\n      this.index = 0;\n    }\n    return ($traceurRuntime.createClass)(StringParser, ($__2 = {}, Object.defineProperty($__2, Symbol.iterator, {\n      value: function() {\n        return this;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, \"next\", {\n      value: function() {\n        if (++this.index >= this.value.length - 1)\n          return {\n            value: undefined,\n            done: true\n          };\n        return {\n          value: this.value[this.index],\n          done: false\n        };\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, \"parse\", {\n      value: function() {\n        if (this.value.indexOf('\\\\') === -1)\n          return this.value.slice(1, -1);\n        var result = '';\n        var $__6 = true;\n        var $__7 = false;\n        var $__8 = undefined;\n        try {\n          for (var $__4 = void 0,\n              $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {\n            var ch = $__4.value;\n            {\n              result += ch === '\\\\' ? this.parseEscapeSequence() : ch;\n            }\n          }\n        } catch ($__9) {\n          $__7 = true;\n          $__8 = $__9;\n        } finally {\n          try {\n            if (!$__6 && $__3.return != null) {\n              $__3.return();\n            }\n          } finally {\n            if ($__7) {\n              throw $__8;\n            }\n          }\n        }\n        return result;\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), Object.defineProperty($__2, \"parseEscapeSequence\", {\n      value: function() {\n        var ch = this.next().value;\n        switch (ch) {\n          case '\\n':\n          case '\\r':\n          case '\\u2028':\n          case '\\u2029':\n            return '';\n          case '0':\n            return '\\0';\n          case 'b':\n            return '\\b';\n          case 'f':\n            return '\\f';\n          case 'n':\n            return '\\n';\n          case 'r':\n            return '\\r';\n          case 't':\n            return '\\t';\n          case 'v':\n            return '\\v';\n          case 'x':\n            return String.fromCharCode(parseInt(this.next().value + this.next().value, 16));\n          case 'u':\n            {\n              var nextValue = this.next().value;\n              if (nextValue === '{') {\n                var hexDigits = '';\n                while ((nextValue = this.next().value) !== '}') {\n                  hexDigits += nextValue;\n                }\n                var codePoint = parseInt(hexDigits, 16);\n                if (codePoint <= 0xFFFF) {\n                  return String.fromCharCode(codePoint);\n                }\n                var high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n                var low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n                return String.fromCharCode(high, low);\n              }\n              return String.fromCharCode(parseInt(nextValue + this.next().value + this.next().value + this.next().value, 16));\n            }\n          default:\n            if (Number(ch) < 8)\n              throw new Error('Octal literals are not supported');\n            return ch;\n        }\n      },\n      configurable: true,\n      enumerable: true,\n      writable: true\n    }), $__2), {});\n  }();\n  var LiteralToken = function($__super) {\n    function LiteralToken(type, value, location) {\n      $traceurRuntime.superConstructor(LiteralToken).call(this, type, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(LiteralToken, {\n      toString: function() {\n        return this.value;\n      },\n      get processedValue() {\n        switch (this.type) {\n          case NULL:\n            return null;\n          case NUMBER:\n            {\n              var value = this.value;\n              if (value.charCodeAt(0) === 48) {\n                switch (value.charCodeAt(1)) {\n                  case 66:\n                  case 98:\n                    return parseInt(this.value.slice(2), 2);\n                  case 79:\n                  case 111:\n                    return parseInt(this.value.slice(2), 8);\n                }\n              }\n              return Number(this.value);\n            }\n          case STRING:\n            {\n              var parser = new StringParser(this.value);\n              return parser.parse();\n            }\n          default:\n            throw new Error('Not implemented');\n        }\n      }\n    }, {}, $__super);\n  }(Token);\n  return {get LiteralToken() {\n      return LiteralToken;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/assert.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/assert.js\";\n  function assert(b) {\n    if (!b && $traceurRuntime.options.debug)\n      throw Error('Assertion failed');\n  }\n  return {get assert() {\n      return assert;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\";\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/IdentifierToken.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")).IdentifierToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")).LiteralToken;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTree.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")),\n      ParseTree = $__3.ParseTree,\n      ParseTreeType = $__3.ParseTreeType;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")),\n      CALL = $__4.CALL,\n      CREATE = $__4.CREATE,\n      DEFINE_PROPERTY = $__4.DEFINE_PROPERTY,\n      FREEZE = $__4.FREEZE,\n      OBJECT = $__4.OBJECT,\n      UNDEFINED = $__4.UNDEFINED;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Token.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")).Token;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")),\n      EQUAL = $__6.EQUAL,\n      FALSE = $__6.FALSE,\n      NULL = $__6.NULL,\n      NUMBER = $__6.NUMBER,\n      STRING = $__6.STRING,\n      TRUE = $__6.TRUE,\n      VOID = $__6.VOID;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")).assert;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ParseTreeFactory.js\")),\n      ArgumentList = $__8.ArgumentList,\n      ArrayLiteral = $__8.ArrayLiteral,\n      BindingElement = $__8.BindingElement,\n      BinaryExpression = $__8.BinaryExpression,\n      BindingIdentifier = $__8.BindingIdentifier,\n      Block = $__8.Block,\n      BreakStatement = $__8.BreakStatement,\n      CallExpression = $__8.CallExpression,\n      CaseClause = $__8.CaseClause,\n      Catch = $__8.Catch,\n      ClassDeclaration = $__8.ClassDeclaration,\n      CommaExpression = $__8.CommaExpression,\n      ConditionalExpression = $__8.ConditionalExpression,\n      ContinueStatement = $__8.ContinueStatement,\n      DefaultClause = $__8.DefaultClause,\n      DoWhileStatement = $__8.DoWhileStatement,\n      EmptyStatement = $__8.EmptyStatement,\n      ExpressionStatement = $__8.ExpressionStatement,\n      Finally = $__8.Finally,\n      ForInStatement = $__8.ForInStatement,\n      ForOfStatement = $__8.ForOfStatement,\n      ForStatement = $__8.ForStatement,\n      FormalParameter = $__8.FormalParameter,\n      FormalParameterList = $__8.FormalParameterList,\n      FunctionBody = $__8.FunctionBody,\n      FunctionExpression = $__8.FunctionExpression,\n      IdentifierExpression = $__8.IdentifierExpression,\n      IfStatement = $__8.IfStatement,\n      ImportedBinding = $__8.ImportedBinding,\n      LiteralExpression = $__8.LiteralExpression,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      MemberExpression = $__8.MemberExpression,\n      MemberLookupExpression = $__8.MemberLookupExpression,\n      NewExpression = $__8.NewExpression,\n      ObjectLiteral = $__8.ObjectLiteral,\n      ParenExpression = $__8.ParenExpression,\n      PostfixExpression = $__8.PostfixExpression,\n      Script = $__8.Script,\n      PropertyNameAssignment = $__8.PropertyNameAssignment,\n      RestParameter = $__8.RestParameter,\n      ReturnStatement = $__8.ReturnStatement,\n      SpreadExpression = $__8.SpreadExpression,\n      SwitchStatement = $__8.SwitchStatement,\n      ThisExpression = $__8.ThisExpression,\n      ThrowStatement = $__8.ThrowStatement,\n      TryStatement = $__8.TryStatement,\n      UnaryExpression = $__8.UnaryExpression,\n      VariableDeclaration = $__8.VariableDeclaration,\n      VariableDeclarationList = $__8.VariableDeclarationList,\n      VariableStatement = $__8.VariableStatement,\n      WhileStatement = $__8.WhileStatement,\n      WithStatement = $__8.WithStatement;\n  var slice = Array.prototype.slice.call.bind(Array.prototype.slice);\n  var map = Array.prototype.map.call.bind(Array.prototype.map);\n  function createOperatorToken(operator) {\n    return new Token(operator, null);\n  }\n  function createIdentifierToken(identifier) {\n    return new IdentifierToken(null, identifier);\n  }\n  function createStringLiteralToken(value) {\n    return new LiteralToken(STRING, JSON.stringify(value), null);\n  }\n  function createBooleanLiteralToken(value) {\n    return new Token(value ? TRUE : FALSE, null);\n  }\n  function createNullLiteralToken() {\n    return new LiteralToken(NULL, 'null', null);\n  }\n  function createNumberLiteralToken(value) {\n    return new LiteralToken(NUMBER, String(value), null);\n  }\n  function createEmptyParameterList() {\n    return new FormalParameterList(null, []);\n  }\n  function createFormalParameter(name) {\n    var bindingIdentifier = createBindingIdentifier(name);\n    return new FormalParameter(null, new BindingElement(null, bindingIdentifier, null), null, []);\n  }\n  function createArgumentList(list) {\n    return new ArgumentList(null, list);\n  }\n  function createEmptyArgumentList() {\n    return createArgumentList([]);\n  }\n  function createArrayLiteral(list) {\n    return new ArrayLiteral(null, list);\n  }\n  function createEmptyArrayLiteral() {\n    return createArrayLiteral([]);\n  }\n  function createAssignmentExpression(lhs, rhs) {\n    return new BinaryExpression(null, lhs, createOperatorToken(EQUAL), rhs);\n  }\n  function createBinaryExpression(left, operator, right) {\n    return new BinaryExpression(null, left, operator, right);\n  }\n  function createBindingIdentifier(identifier) {\n    if (typeof identifier === 'string')\n      identifier = createIdentifierToken(identifier);\n    else if (identifier.type === ParseTreeType.BINDING_IDENTIFIER)\n      return identifier;\n    else if (identifier.type === ParseTreeType.IDENTIFIER_EXPRESSION)\n      return new BindingIdentifier(identifier.location, identifier.identifierToken);\n    return new BindingIdentifier(null, identifier);\n  }\n  function createImportedBinding(name) {\n    var bindingIdentifier = createBindingIdentifier(name);\n    return new ImportedBinding(bindingIdentifier.location, bindingIdentifier);\n  }\n  function createEmptyStatement() {\n    return new EmptyStatement(null);\n  }\n  function createEmptyBlock() {\n    return createBlock([]);\n  }\n  function createBlock(statements) {\n    return new Block(null, statements);\n  }\n  function createFunctionBody(statements) {\n    return new FunctionBody(null, statements);\n  }\n  function createScopedExpression(body, scope) {\n    assert(body.type === 'FUNCTION_BODY');\n    return createCallCall(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)), scope);\n  }\n  function createImmediatelyInvokedFunctionExpression(body) {\n    assert(body.type === 'FUNCTION_BODY');\n    return createCallExpression(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)));\n  }\n  function createCallExpression(operand) {\n    var args = arguments[1] !== (void 0) ? arguments[1] : createEmptyArgumentList();\n    return new CallExpression(null, operand, args);\n  }\n  function createBreakStatement() {\n    var name = arguments[0] !== (void 0) ? arguments[0] : null;\n    return new BreakStatement(null, name);\n  }\n  function createCallCall(func, thisExpression) {\n    return createCallExpression(createMemberExpression(func, CALL), createArgumentList([thisExpression]));\n  }\n  function createCaseClause(expression, statements) {\n    return new CaseClause(null, expression, statements);\n  }\n  function createCatch(identifier, catchBody) {\n    identifier = createBindingIdentifier(identifier);\n    return new Catch(null, identifier, catchBody);\n  }\n  function createClassDeclaration(name, superClass, elements) {\n    return new ClassDeclaration(null, name, superClass, elements, []);\n  }\n  function createCommaExpression(expressions) {\n    return new CommaExpression(null, expressions);\n  }\n  function createConditionalExpression(condition, left, right) {\n    return new ConditionalExpression(null, condition, left, right);\n  }\n  function createContinueStatement() {\n    var name = arguments[0] !== (void 0) ? arguments[0] : null;\n    return new ContinueStatement(null, name);\n  }\n  function createDefaultClause(statements) {\n    return new DefaultClause(null, statements);\n  }\n  function createDoWhileStatement(body, condition) {\n    return new DoWhileStatement(null, body, condition);\n  }\n  function createAssignmentStatement(lhs, rhs) {\n    return createExpressionStatement(createAssignmentExpression(lhs, rhs));\n  }\n  function createCallStatement(operand) {\n    var args = arguments[1];\n    return createExpressionStatement(createCallExpression(operand, args));\n  }\n  function createExpressionStatement(expression) {\n    return new ExpressionStatement(null, expression);\n  }\n  function createFinally(block) {\n    return new Finally(null, block);\n  }\n  function createForOfStatement(initializer, collection, body) {\n    return new ForOfStatement(null, initializer, collection, body);\n  }\n  function createForInStatement(initializer, collection, body) {\n    return new ForInStatement(null, initializer, collection, body);\n  }\n  function createForStatement(variables, condition, increment, body) {\n    return new ForStatement(null, variables, condition, increment, body);\n  }\n  function createFunctionExpression(parameterList, body) {\n    assert(body.type === 'FUNCTION_BODY');\n    return new FunctionExpression(null, null, false, parameterList, null, [], body);\n  }\n  function createIdentifierExpression(identifier) {\n    if (typeof identifier === 'string')\n      identifier = createIdentifierToken(identifier);\n    else if (identifier instanceof BindingIdentifier)\n      identifier = identifier.identifierToken;\n    return new IdentifierExpression(null, identifier);\n  }\n  function createUndefinedExpression() {\n    return createIdentifierExpression(UNDEFINED);\n  }\n  function createIfStatement(condition, ifClause) {\n    var elseClause = arguments[2] !== (void 0) ? arguments[2] : null;\n    return new IfStatement(null, condition, ifClause, elseClause);\n  }\n  function createStringLiteral(value) {\n    return new LiteralExpression(null, createStringLiteralToken(value));\n  }\n  function createBooleanLiteral(value) {\n    return new LiteralExpression(null, createBooleanLiteralToken(value));\n  }\n  function createTrueLiteral() {\n    return createBooleanLiteral(true);\n  }\n  function createFalseLiteral() {\n    return createBooleanLiteral(false);\n  }\n  function createNullLiteral() {\n    return new LiteralExpression(null, createNullLiteralToken());\n  }\n  function createNumberLiteral(value) {\n    return new LiteralExpression(null, createNumberLiteralToken(value));\n  }\n  function createMemberExpression(operand, memberName) {\n    for (var memberNames = [],\n        $__0 = 2; $__0 < arguments.length; $__0++)\n      memberNames[$__0 - 2] = arguments[$__0];\n    if (typeof operand === 'string' || operand instanceof IdentifierToken)\n      operand = createIdentifierExpression(operand);\n    if (typeof memberName === 'string')\n      memberName = createIdentifierToken(memberName);\n    if (memberName instanceof LiteralToken)\n      memberName = new LiteralExpression(null, memberName);\n    var tree = memberName instanceof LiteralExpression ? new MemberLookupExpression(null, operand, memberName) : new MemberExpression(null, operand, memberName);\n    for (var i = 0; i < memberNames.length; i++) {\n      tree = createMemberExpression(tree, memberNames[i]);\n    }\n    return tree;\n  }\n  function createMemberLookupExpression(operand, memberExpression) {\n    return new MemberLookupExpression(null, operand, memberExpression);\n  }\n  function createThisExpression() {\n    return new ThisExpression(null);\n  }\n  function createNewExpression(operand, args) {\n    return new NewExpression(null, operand, args);\n  }\n  function createObjectFreeze(value) {\n    return createCallExpression(createMemberExpression(OBJECT, FREEZE), createArgumentList([value]));\n  }\n  function createObjectCreate(protoExpression) {\n    var descriptors = arguments[1];\n    var argumentList = [protoExpression];\n    if (descriptors)\n      argumentList.push(descriptors);\n    return createCallExpression(createMemberExpression(OBJECT, CREATE), createArgumentList(argumentList));\n  }\n  function createObjectLiteralForDescriptor(descr) {\n    var propertyNameAndValues = Object.keys(descr).map(function(name) {\n      var value = descr[name];\n      if (!(value instanceof ParseTree))\n        value = createBooleanLiteral(!!value);\n      return createPropertyNameAssignment(name, value);\n    });\n    return createObjectLiteral(propertyNameAndValues);\n  }\n  function createDefineProperty(tree, name, descr) {\n    if (typeof name === 'string')\n      name = createStringLiteral(name);\n    return createCallExpression(createMemberExpression(OBJECT, DEFINE_PROPERTY), createArgumentList([tree, name, createObjectLiteralForDescriptor(descr)]));\n  }\n  function createObjectLiteral(propertyNameAndValues) {\n    return new ObjectLiteral(null, propertyNameAndValues);\n  }\n  function createParenExpression(expression) {\n    return new ParenExpression(null, expression);\n  }\n  function createPostfixExpression(operand, operator) {\n    return new PostfixExpression(null, operand, operator);\n  }\n  function createScript(scriptItemList) {\n    return new Script(null, scriptItemList, null);\n  }\n  function createPropertyNameAssignment(identifier, value) {\n    if (typeof identifier === 'string')\n      identifier = createLiteralPropertyName(identifier);\n    return new PropertyNameAssignment(null, identifier, value);\n  }\n  function createLiteralPropertyName(name) {\n    return new LiteralPropertyName(null, createIdentifierToken(name));\n  }\n  function createRestParameter(identifier) {\n    var rest = new RestParameter(null, createBindingIdentifier(identifier));\n    return new FormalParameter(null, rest, null, []);\n  }\n  function createReturnStatement(expression) {\n    return new ReturnStatement(null, expression);\n  }\n  function createSpreadExpression(expression) {\n    return new SpreadExpression(null, expression);\n  }\n  function createSwitchStatement(expression, caseClauses) {\n    return new SwitchStatement(null, expression, caseClauses);\n  }\n  function createThrowStatement(value) {\n    return new ThrowStatement(null, value);\n  }\n  function createTryStatement(body, catchBlock) {\n    var finallyBlock = arguments[2] !== (void 0) ? arguments[2] : null;\n    return new TryStatement(null, body, catchBlock, finallyBlock);\n  }\n  function createUnaryExpression(operator, operand) {\n    return new UnaryExpression(null, operator, operand);\n  }\n  function createUseStrictDirective() {\n    return createExpressionStatement(createStringLiteral('use strict'));\n  }\n  function createVariableDeclarationList(binding, identifierOrDeclarations) {\n    var initializer = arguments[2];\n    if (identifierOrDeclarations instanceof Array) {\n      var declarations = identifierOrDeclarations;\n      return new VariableDeclarationList(null, binding, declarations);\n    }\n    var identifier = identifierOrDeclarations;\n    return createVariableDeclarationList(binding, [createVariableDeclaration(identifier, initializer)]);\n  }\n  function createVariableDeclaration(identifier, initializer) {\n    if (!(identifier instanceof ParseTree) || identifier.type !== ParseTreeType.BINDING_IDENTIFIER && identifier.type !== ParseTreeType.OBJECT_PATTERN && identifier.type !== ParseTreeType.ARRAY_PATTERN) {\n      identifier = createBindingIdentifier(identifier);\n    }\n    return new VariableDeclaration(null, identifier, null, initializer);\n  }\n  function createVariableStatement(listOrBinding) {\n    var identifier = arguments[1];\n    var initializer = arguments[2];\n    if (listOrBinding instanceof VariableDeclarationList)\n      return new VariableStatement(null, listOrBinding);\n    var binding = listOrBinding;\n    var list = createVariableDeclarationList(binding, identifier, initializer);\n    return createVariableStatement(list);\n  }\n  function createVoid0() {\n    return createParenExpression(createUnaryExpression(createOperatorToken(VOID), createNumberLiteral(0)));\n  }\n  function createWhileStatement(condition, body) {\n    return new WhileStatement(null, condition, body);\n  }\n  function createWithStatement(expression, body) {\n    return new WithStatement(null, expression, body);\n  }\n  function createAssignStateStatement(state) {\n    return createAssignmentStatement(createMemberExpression('$ctx', 'state'), createNumberLiteral(state));\n  }\n  return {\n    get createOperatorToken() {\n      return createOperatorToken;\n    },\n    get createIdentifierToken() {\n      return createIdentifierToken;\n    },\n    get createStringLiteralToken() {\n      return createStringLiteralToken;\n    },\n    get createBooleanLiteralToken() {\n      return createBooleanLiteralToken;\n    },\n    get createNullLiteralToken() {\n      return createNullLiteralToken;\n    },\n    get createNumberLiteralToken() {\n      return createNumberLiteralToken;\n    },\n    get createEmptyParameterList() {\n      return createEmptyParameterList;\n    },\n    get createFormalParameter() {\n      return createFormalParameter;\n    },\n    get createArgumentList() {\n      return createArgumentList;\n    },\n    get createEmptyArgumentList() {\n      return createEmptyArgumentList;\n    },\n    get createArrayLiteral() {\n      return createArrayLiteral;\n    },\n    get createEmptyArrayLiteral() {\n      return createEmptyArrayLiteral;\n    },\n    get createAssignmentExpression() {\n      return createAssignmentExpression;\n    },\n    get createBinaryExpression() {\n      return createBinaryExpression;\n    },\n    get createBindingIdentifier() {\n      return createBindingIdentifier;\n    },\n    get createImportedBinding() {\n      return createImportedBinding;\n    },\n    get createEmptyStatement() {\n      return createEmptyStatement;\n    },\n    get createEmptyBlock() {\n      return createEmptyBlock;\n    },\n    get createBlock() {\n      return createBlock;\n    },\n    get createFunctionBody() {\n      return createFunctionBody;\n    },\n    get createScopedExpression() {\n      return createScopedExpression;\n    },\n    get createImmediatelyInvokedFunctionExpression() {\n      return createImmediatelyInvokedFunctionExpression;\n    },\n    get createCallExpression() {\n      return createCallExpression;\n    },\n    get createBreakStatement() {\n      return createBreakStatement;\n    },\n    get createCaseClause() {\n      return createCaseClause;\n    },\n    get createCatch() {\n      return createCatch;\n    },\n    get createClassDeclaration() {\n      return createClassDeclaration;\n    },\n    get createCommaExpression() {\n      return createCommaExpression;\n    },\n    get createConditionalExpression() {\n      return createConditionalExpression;\n    },\n    get createContinueStatement() {\n      return createContinueStatement;\n    },\n    get createDefaultClause() {\n      return createDefaultClause;\n    },\n    get createDoWhileStatement() {\n      return createDoWhileStatement;\n    },\n    get createAssignmentStatement() {\n      return createAssignmentStatement;\n    },\n    get createCallStatement() {\n      return createCallStatement;\n    },\n    get createExpressionStatement() {\n      return createExpressionStatement;\n    },\n    get createFinally() {\n      return createFinally;\n    },\n    get createForOfStatement() {\n      return createForOfStatement;\n    },\n    get createForInStatement() {\n      return createForInStatement;\n    },\n    get createForStatement() {\n      return createForStatement;\n    },\n    get createFunctionExpression() {\n      return createFunctionExpression;\n    },\n    get createIdentifierExpression() {\n      return createIdentifierExpression;\n    },\n    get createUndefinedExpression() {\n      return createUndefinedExpression;\n    },\n    get createIfStatement() {\n      return createIfStatement;\n    },\n    get createStringLiteral() {\n      return createStringLiteral;\n    },\n    get createBooleanLiteral() {\n      return createBooleanLiteral;\n    },\n    get createTrueLiteral() {\n      return createTrueLiteral;\n    },\n    get createFalseLiteral() {\n      return createFalseLiteral;\n    },\n    get createNullLiteral() {\n      return createNullLiteral;\n    },\n    get createNumberLiteral() {\n      return createNumberLiteral;\n    },\n    get createMemberExpression() {\n      return createMemberExpression;\n    },\n    get createMemberLookupExpression() {\n      return createMemberLookupExpression;\n    },\n    get createThisExpression() {\n      return createThisExpression;\n    },\n    get createNewExpression() {\n      return createNewExpression;\n    },\n    get createObjectFreeze() {\n      return createObjectFreeze;\n    },\n    get createObjectCreate() {\n      return createObjectCreate;\n    },\n    get createObjectLiteralForDescriptor() {\n      return createObjectLiteralForDescriptor;\n    },\n    get createDefineProperty() {\n      return createDefineProperty;\n    },\n    get createObjectLiteral() {\n      return createObjectLiteral;\n    },\n    get createParenExpression() {\n      return createParenExpression;\n    },\n    get createPostfixExpression() {\n      return createPostfixExpression;\n    },\n    get createScript() {\n      return createScript;\n    },\n    get createPropertyNameAssignment() {\n      return createPropertyNameAssignment;\n    },\n    get createLiteralPropertyName() {\n      return createLiteralPropertyName;\n    },\n    get createRestParameter() {\n      return createRestParameter;\n    },\n    get createReturnStatement() {\n      return createReturnStatement;\n    },\n    get createSwitchStatement() {\n      return createSwitchStatement;\n    },\n    get createThrowStatement() {\n      return createThrowStatement;\n    },\n    get createTryStatement() {\n      return createTryStatement;\n    },\n    get createUnaryExpression() {\n      return createUnaryExpression;\n    },\n    get createUseStrictDirective() {\n      return createUseStrictDirective;\n    },\n    get createVariableDeclarationList() {\n      return createVariableDeclarationList;\n    },\n    get createVariableDeclaration() {\n      return createVariableDeclaration;\n    },\n    get createVariableStatement() {\n      return createVariableStatement;\n    },\n    get createVoid0() {\n      return createVoid0;\n    },\n    get createWhileStatement() {\n      return createWhileStatement;\n    },\n    get createWithStatement() {\n      return createWithStatement;\n    },\n    get createAssignStateStatement() {\n      return createAssignStateStatement;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/ParseTreeVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/ParseTreeVisitor.js\";\n  var ParseTreeVisitor = function() {\n    function ParseTreeVisitor() {}\n    return ($traceurRuntime.createClass)(ParseTreeVisitor, {\n      visitAny: function(tree) {\n        tree !== null && tree.visit(this);\n      },\n      visit: function(tree) {\n        this.visitAny(tree);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      },\n      visitStateMachine: function(tree) {\n        throw Error('State machines should not live outside of the GeneratorTransformer.');\n      },\n      visitAnnotation: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.args);\n      },\n      visitAnonBlock: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitArgumentList: function(tree) {\n        this.visitList(tree.args);\n      },\n      visitArrayComprehension: function(tree) {\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n      },\n      visitArrayLiteral: function(tree) {\n        this.visitList(tree.elements);\n      },\n      visitArrayPattern: function(tree) {\n        this.visitList(tree.elements);\n      },\n      visitArrayType: function(tree) {\n        this.visitAny(tree.elementType);\n      },\n      visitArrowFunction: function(tree) {\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.body);\n      },\n      visitAssignmentElement: function(tree) {\n        this.visitAny(tree.assignment);\n        this.visitAny(tree.initializer);\n      },\n      visitAwaitExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitBinaryExpression: function(tree) {\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n        this.visitAny(tree.initializer);\n      },\n      visitBindingIdentifier: function(tree) {},\n      visitBlock: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitBreakStatement: function(tree) {},\n      visitCallExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCallSignature: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitCaseClause: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitList(tree.statements);\n      },\n      visitCatch: function(tree) {\n        this.visitAny(tree.binding);\n        this.visitAny(tree.catchBody);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.superClass);\n        this.visitList(tree.elements);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.typeParameters);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.superClass);\n        this.visitList(tree.elements);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.typeParameters);\n      },\n      visitCommaExpression: function(tree) {\n        this.visitList(tree.expressions);\n      },\n      visitComprehensionFor: function(tree) {\n        this.visitAny(tree.left);\n        this.visitAny(tree.iterator);\n      },\n      visitComprehensionIf: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitComputedPropertyName: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitConditionalExpression: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitConstructSignature: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitConstructorType: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitContinueStatement: function(tree) {},\n      visitCoverFormals: function(tree) {\n        this.visitList(tree.expressions);\n      },\n      visitCoverInitializedName: function(tree) {\n        this.visitAny(tree.initializer);\n      },\n      visitDebuggerStatement: function(tree) {},\n      visitDefaultClause: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitDoWhileStatement: function(tree) {\n        this.visitAny(tree.body);\n        this.visitAny(tree.condition);\n      },\n      visitEmptyStatement: function(tree) {},\n      visitExportDeclaration: function(tree) {\n        this.visitAny(tree.declaration);\n        this.visitList(tree.annotations);\n      },\n      visitExportDefault: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitExportSpecifier: function(tree) {},\n      visitExportSpecifierSet: function(tree) {\n        this.visitList(tree.specifiers);\n      },\n      visitExportStar: function(tree) {},\n      visitExpressionStatement: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitFinally: function(tree) {\n        this.visitAny(tree.block);\n      },\n      visitForInStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.collection);\n        this.visitAny(tree.body);\n      },\n      visitForOfStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.collection);\n        this.visitAny(tree.body);\n      },\n      visitForOnStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.observable);\n        this.visitAny(tree.body);\n      },\n      visitForStatement: function(tree) {\n        this.visitAny(tree.initializer);\n        this.visitAny(tree.condition);\n        this.visitAny(tree.increment);\n        this.visitAny(tree.body);\n      },\n      visitFormalParameter: function(tree) {\n        this.visitAny(tree.parameter);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n      },\n      visitFormalParameterList: function(tree) {\n        this.visitList(tree.parameters);\n      },\n      visitForwardDefaultExport: function(tree) {},\n      visitFunctionBody: function(tree) {\n        this.visitList(tree.statements);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitFunctionType: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.returnType);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitIdentifierExpression: function(tree) {},\n      visitIfStatement: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.ifClause);\n        this.visitAny(tree.elseClause);\n      },\n      visitImportedBinding: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitImportClausePair: function(tree) {\n        this.visitAny(tree.first);\n        this.visitAny(tree.second);\n      },\n      visitImportDeclaration: function(tree) {\n        this.visitAny(tree.importClause);\n        this.visitAny(tree.moduleSpecifier);\n      },\n      visitImportSpecifier: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitImportSpecifierSet: function(tree) {\n        this.visitList(tree.specifiers);\n      },\n      visitImportTypeClause: function(tree) {\n        this.visitAny(tree.clause);\n      },\n      visitIndexSignature: function(tree) {\n        this.visitAny(tree.indexType);\n        this.visitAny(tree.typeAnnotation);\n      },\n      visitInterfaceDeclaration: function(tree) {\n        this.visitAny(tree.typeParameters);\n        this.visitAny(tree.objectType);\n      },\n      visitJsxAttribute: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitJsxElement: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.attributes);\n        this.visitList(tree.children);\n      },\n      visitJsxElementName: function(tree) {},\n      visitJsxPlaceholder: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitJsxSpreadAttribute: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitJsxText: function(tree) {},\n      visitLabelledStatement: function(tree) {\n        this.visitAny(tree.statement);\n      },\n      visitLiteralExpression: function(tree) {},\n      visitLiteralPropertyName: function(tree) {},\n      visitMemberExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.memberExpression);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n        this.visitAny(tree.debugName);\n      },\n      visitMethodSignature: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.callSignature);\n      },\n      visitModule: function(tree) {\n        this.visitList(tree.scriptItemList);\n      },\n      visitModuleSpecifier: function(tree) {},\n      visitNameSpaceExport: function(tree) {},\n      visitNameSpaceImport: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitNamedExport: function(tree) {\n        this.visitAny(tree.exportClause);\n        this.visitAny(tree.moduleSpecifier);\n      },\n      visitNewExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        this.visitList(tree.propertyNameAndValues);\n      },\n      visitObjectPattern: function(tree) {\n        this.visitList(tree.fields);\n      },\n      visitObjectPatternField: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.element);\n      },\n      visitObjectType: function(tree) {\n        this.visitList(tree.typeMembers);\n      },\n      visitParenExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitPostfixExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitPredefinedType: function(tree) {},\n      visitScript: function(tree) {\n        this.visitList(tree.scriptItemList);\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.value);\n      },\n      visitPropertyNameShorthand: function(tree) {},\n      visitPropertyVariableDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.initializer);\n      },\n      visitPropertySignature: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.typeAnnotation);\n      },\n      visitRestParameter: function(tree) {\n        this.visitAny(tree.identifier);\n      },\n      visitReturnStatement: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitAny(tree.parameterList);\n        this.visitList(tree.annotations);\n        this.visitAny(tree.body);\n      },\n      visitSpreadExpression: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitSpreadPatternElement: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitSuperExpression: function(tree) {},\n      visitSwitchStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitList(tree.caseClauses);\n      },\n      visitSyntaxErrorTree: function(tree) {},\n      visitTemplateLiteralExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitList(tree.elements);\n      },\n      visitTemplateLiteralPortion: function(tree) {},\n      visitTemplateSubstitution: function(tree) {\n        this.visitAny(tree.expression);\n      },\n      visitThisExpression: function(tree) {},\n      visitThrowStatement: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitTryStatement: function(tree) {\n        this.visitAny(tree.body);\n        this.visitAny(tree.catchBlock);\n        this.visitAny(tree.finallyBlock);\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.visitAny(tree.value);\n      },\n      visitTypeArguments: function(tree) {\n        this.visitList(tree.args);\n      },\n      visitTypeName: function(tree) {\n        this.visitAny(tree.moduleName);\n      },\n      visitTypeParameter: function(tree) {\n        this.visitAny(tree.extendsType);\n      },\n      visitTypeParameters: function(tree) {\n        this.visitList(tree.parameters);\n      },\n      visitTypeReference: function(tree) {\n        this.visitAny(tree.typeName);\n        this.visitAny(tree.args);\n      },\n      visitUnaryExpression: function(tree) {\n        this.visitAny(tree.operand);\n      },\n      visitUnionType: function(tree) {\n        this.visitList(tree.types);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n        this.visitAny(tree.typeAnnotation);\n        this.visitAny(tree.initializer);\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.visitList(tree.declarations);\n      },\n      visitVariableStatement: function(tree) {\n        this.visitAny(tree.declarations);\n      },\n      visitWhileStatement: function(tree) {\n        this.visitAny(tree.condition);\n        this.visitAny(tree.body);\n      },\n      visitWithStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.visitAny(tree.body);\n      },\n      visitYieldExpression: function(tree) {\n        this.visitAny(tree.expression);\n      }\n    }, {});\n  }();\n  return {get ParseTreeVisitor() {\n      return ParseTreeVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FindVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FindVisitor.js\";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/codegeneration/FindVisitor.js\")).ParseTreeVisitor;\n  var FindVisitor = function($__super) {\n    function FindVisitor() {\n      var keepOnGoing = arguments[0];\n      $traceurRuntime.superConstructor(FindVisitor).call(this);\n      this.found_ = false;\n      this.shouldContinue_ = true;\n      this.keepOnGoing_ = keepOnGoing;\n    }\n    return ($traceurRuntime.createClass)(FindVisitor, {\n      get found() {\n        return this.found_;\n      },\n      set found(v) {\n        if (v) {\n          this.found_ = true;\n          if (!this.keepOnGoing_)\n            this.shouldContinue_ = false;\n        }\n      },\n      visitAny: function(tree) {\n        this.shouldContinue_ && tree && tree.visit(this);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; this.shouldContinue_ && i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get FindVisitor() {\n      return FindVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/SyntaxErrorReporter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/SyntaxErrorReporter.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ErrorReporter.js\", \"traceur@0.0.111/src/util/SyntaxErrorReporter.js\")),\n      ErrorReporter = $__1.ErrorReporter,\n      format = $__1.format;\n  var SyntaxErrorReporter = function($__super) {\n    function SyntaxErrorReporter() {\n      $traceurRuntime.superConstructor(SyntaxErrorReporter).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(SyntaxErrorReporter, {reportMessageInternal: function(location, message) {\n        var s = format(location, message);\n        throw new SyntaxError(s);\n      }}, {}, $__super);\n  }(ErrorReporter);\n  return {get SyntaxErrorReporter() {\n      return SyntaxErrorReporter;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/JsxIdentifierToken.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/JsxIdentifierToken.js\";\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/JsxIdentifierToken.js\")).Token;\n  var JSX_IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/JsxIdentifierToken.js\")).JSX_IDENTIFIER;\n  var JsxIdentifierToken = function($__super) {\n    function JsxIdentifierToken(location, value) {\n      $traceurRuntime.superConstructor(JsxIdentifierToken).call(this, JSX_IDENTIFIER, location);\n      this.value = value;\n    }\n    return ($traceurRuntime.createClass)(JsxIdentifierToken, {toString: function() {\n        return this.value;\n      }}, {}, $__super);\n  }(Token);\n  return {get JsxIdentifierToken() {\n      return JsxIdentifierToken;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/Keywords.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/Keywords.js\";\n  var keywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'let', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'enum', 'extends', 'null', 'true', 'false'];\n  var strictKeywords = ['implements', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield'];\n  var keywordsByName = Object.create(null);\n  var NORMAL_KEYWORD = 1;\n  var STRICT_KEYWORD = 2;\n  keywords.forEach(function(value) {\n    keywordsByName[value] = NORMAL_KEYWORD;\n  });\n  strictKeywords.forEach(function(value) {\n    keywordsByName[value] = STRICT_KEYWORD;\n  });\n  function getKeywordType(value) {\n    return keywordsByName[value];\n  }\n  function isStrictKeyword(value) {\n    return getKeywordType(value) === STRICT_KEYWORD;\n  }\n  return {\n    get NORMAL_KEYWORD() {\n      return NORMAL_KEYWORD;\n    },\n    get STRICT_KEYWORD() {\n      return STRICT_KEYWORD;\n    },\n    get getKeywordType() {\n      return getKeywordType;\n    },\n    get isStrictKeyword() {\n      return isStrictKeyword;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/KeywordToken.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/KeywordToken.js\";\n  var STRICT_KEYWORD = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Keywords.js\", \"traceur@0.0.111/src/syntax/KeywordToken.js\")).STRICT_KEYWORD;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/KeywordToken.js\")).Token;\n  var KeywordToken = function($__super) {\n    function KeywordToken(type, keywordType, location) {\n      $traceurRuntime.superConstructor(KeywordToken).call(this, type, location);\n      this.isStrictKeyword_ = keywordType === STRICT_KEYWORD;\n    }\n    return ($traceurRuntime.createClass)(KeywordToken, {\n      isKeyword: function() {\n        return true;\n      },\n      isStrictKeyword: function() {\n        return this.isStrictKeyword_;\n      }\n    }, {}, $__super);\n  }(Token);\n  return {get KeywordToken() {\n      return KeywordToken;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/unicode-tables.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/unicode-tables.js\";\n  var idStartTable = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 442, 443, 443, 444, 447, 448, 451, 452, 659, 660, 660, 661, 687, 688, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 883, 884, 884, 886, 887, 890, 890, 891, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1599, 1600, 1600, 1601, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2226, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2417, 2418, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3653, 3654, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4348, 4349, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5873, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6210, 6211, 6211, 6212, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7287, 7288, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7467, 7468, 7530, 7531, 7543, 7544, 7544, 7545, 7578, 7579, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8472, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8494, 8494, 8495, 8500, 8501, 8504, 8505, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8578, 8579, 8580, 8581, 8584, 11264, 11310, 11312, 11358, 11360, 11387, 11388, 11389, 11390, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12293, 12294, 12294, 12295, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12347, 12347, 12348, 12348, 12353, 12438, 12443, 12444, 12445, 12446, 12447, 12447, 12449, 12538, 12540, 12542, 12543, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 40980, 40981, 40981, 40982, 42124, 42192, 42231, 42232, 42237, 42240, 42507, 42508, 42508, 42512, 42527, 42538, 42539, 42560, 42605, 42606, 42606, 42623, 42623, 42624, 42651, 42652, 42653, 42656, 42725, 42726, 42735, 42775, 42783, 42786, 42863, 42864, 42864, 42865, 42887, 42888, 42888, 42891, 42894, 42896, 42925, 42928, 42929, 42999, 42999, 43000, 43001, 43002, 43002, 43003, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43494, 43495, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43631, 43632, 43632, 43633, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43740, 43741, 43741, 43744, 43754, 43762, 43762, 43763, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43871, 43876, 43877, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65391, 65392, 65392, 65393, 65437, 65438, 65439, 65440, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66352, 66368, 66369, 66369, 66370, 66377, 66378, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66639, 66640, 66717, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68147, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70144, 70161, 70163, 70187, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70493, 70497, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71168, 71215, 71236, 71236, 71296, 71338, 71840, 71903, 71935, 71935, 72384, 72440, 73728, 74648, 74752, 74862, 77824, 78894, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93952, 94020, 94032, 94032, 94099, 94111, 110592, 110593, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 124928, 125124, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 194560, 195101];\n  var idContinueTable = [183, 183, 768, 879, 903, 903, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1631, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2306, 2307, 2307, 2362, 2362, 2363, 2363, 2364, 2364, 2366, 2368, 2369, 2376, 2377, 2380, 2381, 2381, 2382, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2433, 2434, 2435, 2492, 2492, 2494, 2496, 2497, 2500, 2503, 2504, 2507, 2508, 2509, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2562, 2563, 2563, 2620, 2620, 2622, 2624, 2625, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2671, 2672, 2673, 2677, 2677, 2689, 2690, 2691, 2691, 2748, 2748, 2750, 2752, 2753, 2757, 2759, 2760, 2761, 2761, 2763, 2764, 2765, 2765, 2786, 2787, 2790, 2799, 2817, 2817, 2818, 2819, 2876, 2876, 2878, 2878, 2879, 2879, 2880, 2880, 2881, 2884, 2887, 2888, 2891, 2892, 2893, 2893, 2902, 2902, 2903, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3007, 3008, 3008, 3009, 3010, 3014, 3016, 3018, 3020, 3021, 3021, 3031, 3031, 3046, 3055, 3072, 3072, 3073, 3075, 3134, 3136, 3137, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3201, 3201, 3202, 3203, 3260, 3260, 3262, 3262, 3263, 3263, 3264, 3268, 3270, 3270, 3271, 3272, 3274, 3275, 3276, 3277, 3285, 3286, 3298, 3299, 3302, 3311, 3329, 3329, 3330, 3331, 3390, 3392, 3393, 3396, 3398, 3400, 3402, 3404, 3405, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3537, 3538, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3966, 3967, 3967, 3968, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4140, 4141, 4144, 4145, 4145, 4146, 4151, 4152, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4160, 4169, 4182, 4183, 4184, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4226, 4227, 4228, 4229, 4230, 4231, 4236, 4237, 4237, 4239, 4239, 4240, 4249, 4250, 4252, 4253, 4253, 4957, 4959, 4969, 4977, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6069, 6070, 6070, 6071, 6077, 6078, 6085, 6086, 6086, 6087, 6088, 6089, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6434, 6435, 6438, 6439, 6440, 6441, 6443, 6448, 6449, 6450, 6450, 6451, 6456, 6457, 6459, 6470, 6479, 6576, 6592, 6600, 6601, 6608, 6617, 6618, 6618, 6679, 6680, 6681, 6682, 6683, 6683, 6741, 6741, 6742, 6742, 6743, 6743, 6744, 6750, 6752, 6752, 6753, 6753, 6754, 6754, 6755, 6756, 6757, 6764, 6765, 6770, 6771, 6780, 6783, 6783, 6784, 6793, 6800, 6809, 6832, 6845, 6912, 6915, 6916, 6916, 6964, 6964, 6965, 6965, 6966, 6970, 6971, 6971, 6972, 6972, 6973, 6977, 6978, 6978, 6979, 6980, 6992, 7001, 7019, 7027, 7040, 7041, 7042, 7042, 7073, 7073, 7074, 7077, 7078, 7079, 7080, 7081, 7082, 7082, 7083, 7085, 7088, 7097, 7142, 7142, 7143, 7143, 7144, 7145, 7146, 7148, 7149, 7149, 7150, 7150, 7151, 7153, 7154, 7155, 7204, 7211, 7212, 7219, 7220, 7221, 7222, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7392, 7393, 7393, 7394, 7400, 7405, 7405, 7410, 7411, 7412, 7412, 7416, 7417, 7616, 7669, 7676, 7679, 8255, 8256, 8276, 8276, 8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12333, 12334, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43044, 43045, 43046, 43047, 43047, 43136, 43137, 43188, 43203, 43204, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43345, 43346, 43347, 43392, 43394, 43395, 43395, 43443, 43443, 43444, 43445, 43446, 43449, 43450, 43451, 43452, 43452, 43453, 43456, 43472, 43481, 43493, 43493, 43504, 43513, 43561, 43566, 43567, 43568, 43569, 43570, 43571, 43572, 43573, 43574, 43587, 43587, 43596, 43596, 43597, 43597, 43600, 43609, 43643, 43643, 43644, 43644, 43645, 43645, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43755, 43756, 43757, 43758, 43759, 43765, 43765, 43766, 43766, 44003, 44004, 44005, 44005, 44006, 44007, 44008, 44008, 44009, 44010, 44012, 44012, 44013, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65069, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 66045, 66045, 66272, 66272, 66422, 66426, 66720, 66729, 68097, 68099, 68101, 68102, 68108, 68111, 68152, 68154, 68159, 68159, 68325, 68326, 69632, 69632, 69633, 69633, 69634, 69634, 69688, 69702, 69734, 69743, 69759, 69761, 69762, 69762, 69808, 69810, 69811, 69814, 69815, 69816, 69817, 69818, 69872, 69881, 69888, 69890, 69927, 69931, 69932, 69932, 69933, 69940, 69942, 69951, 70003, 70003, 70016, 70017, 70018, 70018, 70067, 70069, 70070, 70078, 70079, 70080, 70096, 70105, 70188, 70190, 70191, 70193, 70194, 70195, 70196, 70196, 70197, 70197, 70198, 70199, 70367, 70367, 70368, 70370, 70371, 70378, 70384, 70393, 70401, 70401, 70402, 70403, 70460, 70460, 70462, 70463, 70464, 70464, 70465, 70468, 70471, 70472, 70475, 70477, 70487, 70487, 70498, 70499, 70502, 70508, 70512, 70516, 70832, 70834, 70835, 70840, 70841, 70841, 70842, 70842, 70843, 70846, 70847, 70848, 70849, 70849, 70850, 70851, 70864, 70873, 71087, 71089, 71090, 71093, 71096, 71099, 71100, 71101, 71102, 71102, 71103, 71104, 71216, 71218, 71219, 71226, 71227, 71228, 71229, 71229, 71230, 71230, 71231, 71232, 71248, 71257, 71339, 71339, 71340, 71340, 71341, 71341, 71342, 71343, 71344, 71349, 71350, 71350, 71351, 71351, 71360, 71369, 71904, 71913, 92768, 92777, 92912, 92916, 92976, 92982, 93008, 93017, 94033, 94078, 94095, 94098, 113821, 113822, 119141, 119142, 119143, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 120782, 120831, 125136, 125142, 917760, 917999];\n  return {\n    get idStartTable() {\n      return idStartTable;\n    },\n    get idContinueTable() {\n      return idContinueTable;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/Scanner.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/Scanner.js\";\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./IdentifierToken.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).IdentifierToken;\n  var JsxIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./JsxIdentifierToken.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).JsxIdentifierToken;\n  var KeywordToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./KeywordToken.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).KeywordToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LiteralToken.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).LiteralToken;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/SourceRange.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).SourceRange;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).Token;\n  var getKeywordType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Keywords.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")).getKeywordType;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./unicode-tables.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")),\n      idContinueTable = $__10.idContinueTable,\n      idStartTable = $__10.idStartTable;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/Scanner.js\")),\n      AMPERSAND = $__11.AMPERSAND,\n      AMPERSAND_EQUAL = $__11.AMPERSAND_EQUAL,\n      AND = $__11.AND,\n      ARROW = $__11.ARROW,\n      AT = $__11.AT,\n      BANG = $__11.BANG,\n      BAR = $__11.BAR,\n      BAR_EQUAL = $__11.BAR_EQUAL,\n      CARET = $__11.CARET,\n      CARET_EQUAL = $__11.CARET_EQUAL,\n      CLOSE_ANGLE = $__11.CLOSE_ANGLE,\n      CLOSE_CURLY = $__11.CLOSE_CURLY,\n      CLOSE_PAREN = $__11.CLOSE_PAREN,\n      CLOSE_SQUARE = $__11.CLOSE_SQUARE,\n      COLON = $__11.COLON,\n      COMMA = $__11.COMMA,\n      DOT_DOT_DOT = $__11.DOT_DOT_DOT,\n      END_OF_FILE = $__11.END_OF_FILE,\n      EQUAL = $__11.EQUAL,\n      EQUAL_EQUAL = $__11.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__11.EQUAL_EQUAL_EQUAL,\n      ERROR = $__11.ERROR,\n      GREATER_EQUAL = $__11.GREATER_EQUAL,\n      LEFT_SHIFT = $__11.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__11.LEFT_SHIFT_EQUAL,\n      LESS_EQUAL = $__11.LESS_EQUAL,\n      MINUS = $__11.MINUS,\n      MINUS_EQUAL = $__11.MINUS_EQUAL,\n      MINUS_MINUS = $__11.MINUS_MINUS,\n      NO_SUBSTITUTION_TEMPLATE = $__11.NO_SUBSTITUTION_TEMPLATE,\n      NOT_EQUAL = $__11.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__11.NOT_EQUAL_EQUAL,\n      NUMBER = $__11.NUMBER,\n      OPEN_ANGLE = $__11.OPEN_ANGLE,\n      OPEN_CURLY = $__11.OPEN_CURLY,\n      OPEN_PAREN = $__11.OPEN_PAREN,\n      OPEN_SQUARE = $__11.OPEN_SQUARE,\n      OR = $__11.OR,\n      PERCENT = $__11.PERCENT,\n      PERCENT_EQUAL = $__11.PERCENT_EQUAL,\n      PERIOD = $__11.PERIOD,\n      PLUS = $__11.PLUS,\n      PLUS_EQUAL = $__11.PLUS_EQUAL,\n      PLUS_PLUS = $__11.PLUS_PLUS,\n      QUESTION = $__11.QUESTION,\n      REGULAR_EXPRESSION = $__11.REGULAR_EXPRESSION,\n      RIGHT_SHIFT = $__11.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__11.RIGHT_SHIFT_EQUAL,\n      SEMI_COLON = $__11.SEMI_COLON,\n      SLASH = $__11.SLASH,\n      SLASH_EQUAL = $__11.SLASH_EQUAL,\n      STAR = $__11.STAR,\n      STAR_EQUAL = $__11.STAR_EQUAL,\n      STAR_STAR = $__11.STAR_STAR,\n      STAR_STAR_EQUAL = $__11.STAR_STAR_EQUAL,\n      STRING = $__11.STRING,\n      TEMPLATE_HEAD = $__11.TEMPLATE_HEAD,\n      TEMPLATE_MIDDLE = $__11.TEMPLATE_MIDDLE,\n      TEMPLATE_TAIL = $__11.TEMPLATE_TAIL,\n      TILDE = $__11.TILDE,\n      UNSIGNED_RIGHT_SHIFT = $__11.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__11.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  var isWhitespaceArray = [];\n  for (var i = 0; i < 128; i++) {\n    isWhitespaceArray[i] = i >= 9 && i <= 13 || i === 0x20;\n  }\n  function isWhitespace(code) {\n    if (code < 128)\n      return isWhitespaceArray[code];\n    switch (code) {\n      case 0xA0:\n      case 0xFEFF:\n      case 0x2028:\n      case 0x2029:\n        return true;\n    }\n    return false;\n  }\n  function isLineTerminator(code) {\n    switch (code) {\n      case 10:\n      case 13:\n      case 0x2028:\n      case 0x2029:\n        return true;\n    }\n    return false;\n  }\n  function isDecimalDigit(code) {\n    return code >= 48 && code <= 57;\n  }\n  var isHexDigitArray = [];\n  for (var i$__0 = 0; i$__0 < 128; i$__0++) {\n    isHexDigitArray[i$__0] = i$__0 >= 48 && i$__0 <= 57 || i$__0 >= 65 && i$__0 <= 70 || i$__0 >= 97 && i$__0 <= 102;\n  }\n  function isHexDigit(code) {\n    return code < 128 && isHexDigitArray[code];\n  }\n  function isBinaryDigit(code) {\n    return code === 48 || code === 49;\n  }\n  function isOctalDigit(code) {\n    return code >= 48 && code <= 55;\n  }\n  var isIdentifierStartArray = [];\n  for (var i$__1 = 0; i$__1 < 128; i$__1++) {\n    isIdentifierStartArray[i$__1] = i$__1 === 36 || i$__1 >= 65 && i$__1 <= 90 || i$__1 === 95 || i$__1 >= 97 && i$__1 <= 122;\n  }\n  function isIdentifierStart(code) {\n    return code < 128 ? isIdentifierStartArray[code] : inTable(idStartTable, code);\n  }\n  var isIdentifierPartArray = [];\n  for (var i$__2 = 0; i$__2 < 128; i$__2++) {\n    isIdentifierPartArray[i$__2] = isIdentifierStart(i$__2) || isDecimalDigit(i$__2);\n  }\n  function isIdentifierPart(code) {\n    return code < 128 ? isIdentifierPartArray[code] : inTable(idStartTable, code) || inTable(idContinueTable, code) || code === 8204 || code === 8205;\n  }\n  function inTable(table, code) {\n    for (var i = 0; i < table.length; ) {\n      if (code < table[i++])\n        return false;\n      if (code <= table[i++])\n        return true;\n    }\n    return false;\n  }\n  function isRegularExpressionChar(code) {\n    switch (code) {\n      case 47:\n        return false;\n      case 91:\n      case 92:\n        return true;\n    }\n    return !isLineTerminator(code);\n  }\n  function isRegularExpressionFirstChar(code) {\n    return isRegularExpressionChar(code) && code !== 42;\n  }\n  var index,\n      input,\n      length,\n      token,\n      lastToken,\n      lookaheadToken,\n      currentCharCode,\n      lineNumberTable,\n      errorReporter,\n      currentParser,\n      options;\n  function init(reporter, file, parser, traceurOptions) {\n    errorReporter = reporter;\n    lineNumberTable = file.lineNumberTable;\n    input = file.contents;\n    length = file.contents.length;\n    setIndex(0);\n    currentParser = parser;\n    options = traceurOptions;\n  }\n  function getLastToken() {\n    return lastToken;\n  }\n  function nextRegularExpressionLiteralToken() {\n    lastToken = nextRegularExpressionLiteralToken2();\n    token = scanToken();\n    return lastToken;\n  }\n  function nextTemplateLiteralToken() {\n    var t = nextTemplateLiteralToken2();\n    token = scanToken();\n    return t;\n  }\n  function setIndex(i) {\n    index = i;\n    lastToken = null;\n    token = null;\n    lookaheadToken = null;\n    updateCurrentCharCode();\n  }\n  function getPosition() {\n    return getPositionByOffset(getOffset());\n  }\n  function getPositionByOffset(offset) {\n    return lineNumberTable.getSourcePosition(offset);\n  }\n  function nextCloseAngle() {\n    switch (token.type) {\n      case GREATER_EQUAL:\n      case RIGHT_SHIFT:\n      case RIGHT_SHIFT_EQUAL:\n      case UNSIGNED_RIGHT_SHIFT:\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        setIndex(index - token.type.length + 1);\n        lastToken = createToken(CLOSE_ANGLE, index);\n        token = scanToken();\n        return lastToken;\n    }\n    return nextToken();\n  }\n  function getTokenRange(startOffset) {\n    return lineNumberTable.getSourceRange(startOffset, index);\n  }\n  function getOffset() {\n    return token ? token.location.start.offset : index;\n  }\n  function nextRegularExpressionLiteralToken2() {\n    var beginIndex = index - token.toString().length;\n    if (token.type === SLASH_EQUAL) {\n      skipRegularExpressionBodyContinuation();\n    } else {\n      skipRegularExpressionBody(beginIndex);\n    }\n    if (currentCharCode !== 47) {\n      reportError('Expected \\'/\\' in regular expression literal', beginIndex);\n      return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));\n    }\n    next();\n    while (isIdentifierPart(currentCharCode)) {\n      next();\n    }\n    return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function skipRegularExpressionBody(beginIndex) {\n    if (!isRegularExpressionFirstChar(currentCharCode)) {\n      reportError('Expected regular expression first char', beginIndex);\n      return;\n    }\n    skipRegularExpressionBodyContinuation();\n  }\n  function skipRegularExpressionBodyContinuation() {\n    while (!isAtEnd() && isRegularExpressionChar(currentCharCode)) {\n      if (!skipRegularExpressionChar()) {\n        return;\n      }\n    }\n  }\n  function skipRegularExpressionChar() {\n    switch (currentCharCode) {\n      case 92:\n        return skipRegularExpressionBackslashSequence();\n      case 91:\n        return skipRegularExpressionClass();\n      default:\n        next();\n        return true;\n    }\n  }\n  function skipRegularExpressionBackslashSequence() {\n    var beginIndex = index;\n    next();\n    if (isLineTerminator(currentCharCode) || isAtEnd()) {\n      reportError('New line not allowed in regular expression literal', beginIndex, index);\n      return false;\n    }\n    next();\n    return true;\n  }\n  function skipRegularExpressionClass() {\n    var beginIndex = index;\n    next();\n    while (!isAtEnd() && peekRegularExpressionClassChar()) {\n      if (!skipRegularExpressionClassChar()) {\n        return false;\n      }\n    }\n    if (currentCharCode !== 93) {\n      reportError('\\']\\' expected', beginIndex, index);\n      return false;\n    }\n    next();\n    return true;\n  }\n  function peekRegularExpressionClassChar() {\n    return currentCharCode !== 93 && !isLineTerminator(currentCharCode);\n  }\n  function skipRegularExpressionClassChar() {\n    if (currentCharCode === 92) {\n      return skipRegularExpressionBackslashSequence();\n    }\n    next();\n    return true;\n  }\n  function skipTemplateCharacter() {\n    while (!isAtEnd()) {\n      switch (currentCharCode) {\n        case 96:\n          return;\n        case 92:\n          skipStringLiteralEscapeSequence();\n          break;\n        case 36:\n          {\n            var code = input.charCodeAt(index + 1);\n            if (code === 123)\n              return;\n            next();\n            break;\n          }\n        default:\n          next();\n      }\n    }\n  }\n  function scanTemplateStart(beginIndex) {\n    if (isAtEnd()) {\n      reportError('Unterminated template literal', beginIndex, index);\n      return lastToken = createToken(END_OF_FILE, beginIndex);\n    }\n    return nextTemplateLiteralTokenShared(NO_SUBSTITUTION_TEMPLATE, TEMPLATE_HEAD);\n  }\n  function nextTemplateLiteralToken2() {\n    if (isAtEnd()) {\n      reportError('Expected \\'}\\' after expression in template literal', index, index);\n      return createToken(END_OF_FILE, index);\n    }\n    if (token.type !== CLOSE_CURLY) {\n      reportError('Expected \\'}\\' after expression in template literal', index, index);\n      return createToken(ERROR, index);\n    }\n    return nextTemplateLiteralTokenShared(TEMPLATE_TAIL, TEMPLATE_MIDDLE);\n  }\n  function nextTemplateLiteralTokenShared(endType, middleType) {\n    var beginIndex = index;\n    skipTemplateCharacter();\n    if (isAtEnd()) {\n      reportError('Unterminated template literal');\n      return createToken(ERROR, beginIndex);\n    }\n    var value = getTokenString(beginIndex);\n    switch (currentCharCode) {\n      case 96:\n        next();\n        return lastToken = new LiteralToken(endType, value, getTokenRange(beginIndex - 1));\n      case 36:\n        next();\n        next();\n        return lastToken = new LiteralToken(middleType, value, getTokenRange(beginIndex - 1));\n    }\n  }\n  function peekJsxToken() {\n    return token || (token = scanJsxToken());\n  }\n  function nextJsxToken() {\n    lastToken = peekJsxToken();\n    token = null;\n    return lastToken;\n  }\n  function scanJsxToken() {\n    skipComments();\n    var beginIndex = index;\n    switch (currentCharCode) {\n      case 34:\n      case 39:\n        return scanJsxStringLiteral(beginIndex, currentCharCode);\n      case 62:\n        next();\n        return createToken(CLOSE_ANGLE, beginIndex);\n    }\n    if (!isIdentifierStart(currentCharCode)) {\n      return scanToken();\n    }\n    next();\n    while (isIdentifierPart(currentCharCode) || currentCharCode === 45) {\n      next();\n    }\n    var value = input.slice(beginIndex, index);\n    return new JsxIdentifierToken(getTokenRange(beginIndex), value);\n  }\n  function scanJsxStringLiteral(beginIndex, terminator) {\n    next();\n    while (!isAtEnd() && currentCharCode !== terminator) {\n      next();\n    }\n    if (currentCharCode !== terminator) {\n      reportError('Unterminated String Literal', beginIndex);\n    } else {\n      next();\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function nextJsxTextToken() {\n    lastToken = token || scanJsxTextToken();\n    token = null;\n    return lastToken;\n  }\n  function skipJsxText() {\n    while (!isAtEnd() && peekJsxText()) {\n      next();\n    }\n  }\n  function isJsxTextChar(code) {\n    switch (code) {\n      case 60:\n      case 123:\n        return false;\n    }\n    return true;\n  }\n  function skipJsxText() {\n    while (!isAtEnd() && isJsxTextChar(currentCharCode)) {\n      next();\n    }\n  }\n  function scanJsxTextToken() {\n    var beginIndex = index;\n    if (isAtEnd()) {\n      return createToken(END_OF_FILE, beginIndex);\n    }\n    skipJsxText();\n    if (beginIndex === index) {\n      switch (currentCharCode) {\n        case 60:\n          next();\n          return createToken(OPEN_ANGLE, beginIndex);\n        case 123:\n          next();\n          return createToken(OPEN_CURLY, beginIndex);\n      }\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function nextToken() {\n    var t = peekToken();\n    token = lookaheadToken || scanToken();\n    lookaheadToken = null;\n    lastToken = t;\n    return t;\n  }\n  function peekTokenNoLineTerminator() {\n    var t = peekToken();\n    var start = lastToken.location.end.offset;\n    var end = t.location.start.offset;\n    for (var i = start; i < end; i++) {\n      if (isLineTerminator(input.charCodeAt(i))) {\n        return null;\n      }\n    }\n    return t;\n  }\n  function peek(expectedType) {\n    return peekToken().type === expectedType;\n  }\n  function peekLookahead(expectedType) {\n    return peekTokenLookahead().type === expectedType;\n  }\n  function peekToken() {\n    return token || (token = scanToken());\n  }\n  function peekType() {\n    return peekToken().type;\n  }\n  function peekLocation() {\n    return peekToken().location;\n  }\n  function peekTokenLookahead() {\n    if (!token)\n      token = scanToken();\n    if (!lookaheadToken)\n      lookaheadToken = scanToken();\n    return lookaheadToken;\n  }\n  function skipWhitespace() {\n    while (!isAtEnd() && peekWhitespace()) {\n      next();\n    }\n  }\n  function peekWhitespace() {\n    return isWhitespace(currentCharCode);\n  }\n  function skipComments() {\n    while (skipComment()) {}\n  }\n  function skipComment() {\n    skipWhitespace();\n    var code = currentCharCode;\n    if (code === 47) {\n      code = input.charCodeAt(index + 1);\n      switch (code) {\n        case 47:\n          skipSingleLineComment();\n          return true;\n        case 42:\n          skipMultiLineComment();\n          return true;\n      }\n    }\n    return false;\n  }\n  function commentCallback(start, index) {\n    if (options.commentCallback)\n      currentParser.handleComment(lineNumberTable.getSourceRange(start, index));\n  }\n  function skipSingleLineComment() {\n    var start = index;\n    index += 2;\n    while (!isAtEnd() && !isLineTerminator(input.charCodeAt(index++))) {}\n    updateCurrentCharCode();\n    commentCallback(start, index);\n  }\n  function skipMultiLineComment() {\n    var start = index;\n    var i = input.indexOf('*/', index + 2);\n    if (i !== -1)\n      index = i + 2;\n    else\n      index = length;\n    updateCurrentCharCode();\n    commentCallback(start, index);\n  }\n  function scanToken() {\n    skipComments();\n    var beginIndex = index;\n    if (isAtEnd())\n      return createToken(END_OF_FILE, beginIndex);\n    var code = currentCharCode;\n    next();\n    switch (code) {\n      case 123:\n        return createToken(OPEN_CURLY, beginIndex);\n      case 125:\n        return createToken(CLOSE_CURLY, beginIndex);\n      case 40:\n        return createToken(OPEN_PAREN, beginIndex);\n      case 41:\n        return createToken(CLOSE_PAREN, beginIndex);\n      case 91:\n        return createToken(OPEN_SQUARE, beginIndex);\n      case 93:\n        return createToken(CLOSE_SQUARE, beginIndex);\n      case 46:\n        switch (currentCharCode) {\n          case 46:\n            if (input.charCodeAt(index + 1) === 46) {\n              next();\n              next();\n              return createToken(DOT_DOT_DOT, beginIndex);\n            }\n            break;\n          default:\n            if (isDecimalDigit(currentCharCode))\n              return scanNumberPostPeriod(beginIndex);\n        }\n        return createToken(PERIOD, beginIndex);\n      case 59:\n        return createToken(SEMI_COLON, beginIndex);\n      case 44:\n        return createToken(COMMA, beginIndex);\n      case 126:\n        return createToken(TILDE, beginIndex);\n      case 63:\n        return createToken(QUESTION, beginIndex);\n      case 58:\n        return createToken(COLON, beginIndex);\n      case 60:\n        switch (currentCharCode) {\n          case 60:\n            next();\n            if (currentCharCode === 61) {\n              next();\n              return createToken(LEFT_SHIFT_EQUAL, beginIndex);\n            }\n            return createToken(LEFT_SHIFT, beginIndex);\n          case 61:\n            next();\n            return createToken(LESS_EQUAL, beginIndex);\n          default:\n            return createToken(OPEN_ANGLE, beginIndex);\n        }\n      case 62:\n        switch (currentCharCode) {\n          case 62:\n            next();\n            switch (currentCharCode) {\n              case 61:\n                next();\n                return createToken(RIGHT_SHIFT_EQUAL, beginIndex);\n              case 62:\n                next();\n                if (currentCharCode === 61) {\n                  next();\n                  return createToken(UNSIGNED_RIGHT_SHIFT_EQUAL, beginIndex);\n                }\n                return createToken(UNSIGNED_RIGHT_SHIFT, beginIndex);\n              default:\n                return createToken(RIGHT_SHIFT, beginIndex);\n            }\n          case 61:\n            next();\n            return createToken(GREATER_EQUAL, beginIndex);\n          default:\n            return createToken(CLOSE_ANGLE, beginIndex);\n        }\n      case 61:\n        if (currentCharCode === 61) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(EQUAL_EQUAL_EQUAL, beginIndex);\n          }\n          return createToken(EQUAL_EQUAL, beginIndex);\n        }\n        if (currentCharCode === 62 && options.arrowFunctions) {\n          next();\n          return createToken(ARROW, beginIndex);\n        }\n        return createToken(EQUAL, beginIndex);\n      case 33:\n        if (currentCharCode === 61) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(NOT_EQUAL_EQUAL, beginIndex);\n          }\n          return createToken(NOT_EQUAL, beginIndex);\n        }\n        return createToken(BANG, beginIndex);\n      case 42:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(STAR_EQUAL, beginIndex);\n        }\n        if (currentCharCode === 42 && options.exponentiation) {\n          next();\n          if (currentCharCode === 61) {\n            next();\n            return createToken(STAR_STAR_EQUAL, beginIndex);\n          }\n          return createToken(STAR_STAR, beginIndex);\n        }\n        return createToken(STAR, beginIndex);\n      case 37:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(PERCENT_EQUAL, beginIndex);\n        }\n        return createToken(PERCENT, beginIndex);\n      case 94:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(CARET_EQUAL, beginIndex);\n        }\n        return createToken(CARET, beginIndex);\n      case 47:\n        if (currentCharCode === 61) {\n          next();\n          return createToken(SLASH_EQUAL, beginIndex);\n        }\n        return createToken(SLASH, beginIndex);\n      case 43:\n        switch (currentCharCode) {\n          case 43:\n            next();\n            return createToken(PLUS_PLUS, beginIndex);\n          case 61:\n            next();\n            return createToken(PLUS_EQUAL, beginIndex);\n          default:\n            return createToken(PLUS, beginIndex);\n        }\n      case 45:\n        switch (currentCharCode) {\n          case 45:\n            next();\n            return createToken(MINUS_MINUS, beginIndex);\n          case 61:\n            next();\n            return createToken(MINUS_EQUAL, beginIndex);\n          default:\n            return createToken(MINUS, beginIndex);\n        }\n      case 38:\n        switch (currentCharCode) {\n          case 38:\n            next();\n            return createToken(AND, beginIndex);\n          case 61:\n            next();\n            return createToken(AMPERSAND_EQUAL, beginIndex);\n          default:\n            return createToken(AMPERSAND, beginIndex);\n        }\n      case 124:\n        switch (currentCharCode) {\n          case 124:\n            next();\n            return createToken(OR, beginIndex);\n          case 61:\n            next();\n            return createToken(BAR_EQUAL, beginIndex);\n          default:\n            return createToken(BAR, beginIndex);\n        }\n      case 96:\n        return scanTemplateStart(beginIndex);\n      case 64:\n        return createToken(AT, beginIndex);\n      case 48:\n        return scanPostZero(beginIndex);\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        return scanPostDigit(beginIndex);\n      case 34:\n      case 39:\n        return scanStringLiteral(beginIndex, code);\n      default:\n        return scanIdentifierOrKeyword(beginIndex, code);\n    }\n  }\n  function scanNumberPostPeriod(beginIndex) {\n    skipDecimalDigits();\n    return scanExponentOfNumericLiteral(beginIndex);\n  }\n  function scanPostDigit(beginIndex) {\n    skipDecimalDigits();\n    return scanFractionalNumericLiteral(beginIndex);\n  }\n  function scanPostZero(beginIndex) {\n    switch (currentCharCode) {\n      case 46:\n        return scanFractionalNumericLiteral(beginIndex);\n      case 88:\n      case 120:\n        next();\n        if (!isHexDigit(currentCharCode)) {\n          reportError('Hex Integer Literal must contain at least one digit', beginIndex);\n        }\n        skipHexDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 66:\n      case 98:\n        if (!options.numericLiterals)\n          break;\n        next();\n        if (!isBinaryDigit(currentCharCode)) {\n          reportError('Binary Integer Literal must contain at least one digit', beginIndex);\n        }\n        skipBinaryDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 79:\n      case 111:\n        if (!options.numericLiterals)\n          break;\n        next();\n        if (!isOctalDigit(currentCharCode)) {\n          reportError('Octal Integer Literal must contain at least one digit', beginIndex);\n        }\n        skipOctalDigits();\n        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n      case 48:\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        return scanPostDigit(beginIndex);\n    }\n    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function createToken(type, beginIndex) {\n    return new Token(type, getTokenRange(beginIndex));\n  }\n  function readUnicodeEscapeSequence() {\n    var beginIndex = index;\n    if (currentCharCode === 117) {\n      next();\n      if (skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit()) {\n        return parseInt(getTokenString(beginIndex + 1), 16);\n      }\n    }\n    reportError('Invalid unicode escape sequence in identifier', beginIndex - 1);\n    return 0;\n  }\n  function scanIdentifierOrKeyword(beginIndex, code) {\n    var escapedCharCodes;\n    if (code === 92) {\n      code = readUnicodeEscapeSequence();\n      escapedCharCodes = [code];\n    }\n    if (!isIdentifierStart(code)) {\n      reportError((\"Character code '\" + code + \"' is not a valid identifier start char\"), beginIndex);\n      return createToken(ERROR, beginIndex);\n    }\n    for (; ; ) {\n      code = currentCharCode;\n      if (isIdentifierPart(code)) {\n        next();\n      } else if (code === 92) {\n        next();\n        code = readUnicodeEscapeSequence();\n        if (!escapedCharCodes)\n          escapedCharCodes = [];\n        escapedCharCodes.push(code);\n        if (!isIdentifierPart(code))\n          return createToken(ERROR, beginIndex);\n      } else {\n        break;\n      }\n    }\n    var value = input.slice(beginIndex, index);\n    var keywordType = getKeywordType(value);\n    if (keywordType)\n      return new KeywordToken(value, keywordType, getTokenRange(beginIndex));\n    if (escapedCharCodes) {\n      var i = 0;\n      value = value.replace(/\\\\u..../g, function(s) {\n        return String.fromCharCode(escapedCharCodes[i++]);\n      });\n    }\n    return new IdentifierToken(getTokenRange(beginIndex), value);\n  }\n  function scanStringLiteral(beginIndex, terminator) {\n    while (peekStringLiteralChar(terminator)) {\n      if (!skipStringLiteralChar()) {\n        return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n      }\n    }\n    if (currentCharCode !== terminator) {\n      reportError('Unterminated String Literal', beginIndex);\n    } else {\n      next();\n    }\n    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function getTokenString(beginIndex) {\n    return input.substring(beginIndex, index);\n  }\n  function peekStringLiteralChar(terminator) {\n    return !isAtEnd() && currentCharCode !== terminator && !isLineTerminator(currentCharCode);\n  }\n  function skipStringLiteralChar() {\n    if (currentCharCode === 92) {\n      return skipStringLiteralEscapeSequence();\n    }\n    next();\n    return true;\n  }\n  function skipStringLiteralEscapeSequence() {\n    next();\n    if (isAtEnd()) {\n      reportError('Unterminated string literal escape sequence');\n      return false;\n    }\n    if (isLineTerminator(currentCharCode)) {\n      skipLineTerminator();\n      return true;\n    }\n    var code = currentCharCode;\n    next();\n    switch (code) {\n      case 39:\n      case 34:\n      case 92:\n      case 98:\n      case 102:\n      case 110:\n      case 114:\n      case 116:\n      case 118:\n      case 48:\n        return true;\n      case 120:\n        return skipHexDigit() && skipHexDigit();\n      case 117:\n        return skipUnicodeEscapeSequence();\n      default:\n        return true;\n    }\n  }\n  function skipUnicodeEscapeSequence() {\n    if (currentCharCode === 123 && options.unicodeEscapeSequences) {\n      next();\n      var beginIndex = index;\n      if (!isHexDigit(currentCharCode)) {\n        reportError('Hex digit expected', beginIndex);\n        return false;\n      }\n      skipHexDigits();\n      if (currentCharCode !== 125) {\n        reportError('Hex digit expected', beginIndex);\n        return false;\n      }\n      var codePoint = getTokenString(beginIndex, index);\n      if (parseInt(codePoint, 16) > 0x10FFFF) {\n        reportError('The code point in a Unicode escape sequence cannot exceed 10FFFF', beginIndex);\n        return false;\n      }\n      next();\n      return true;\n    }\n    return skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit();\n  }\n  function skipHexDigit() {\n    if (!isHexDigit(currentCharCode)) {\n      reportError('Hex digit expected');\n      return false;\n    }\n    next();\n    return true;\n  }\n  function skipLineTerminator() {\n    var first = currentCharCode;\n    next();\n    if (first === 13 && currentCharCode === 10) {\n      next();\n    }\n  }\n  function scanFractionalNumericLiteral(beginIndex) {\n    if (currentCharCode === 46) {\n      next();\n      skipDecimalDigits();\n    }\n    return scanExponentOfNumericLiteral(beginIndex);\n  }\n  function scanExponentOfNumericLiteral(beginIndex) {\n    switch (currentCharCode) {\n      case 101:\n      case 69:\n        next();\n        switch (currentCharCode) {\n          case 43:\n          case 45:\n            next();\n            break;\n        }\n        if (!isDecimalDigit(currentCharCode)) {\n          reportError('Exponent part must contain at least one digit', beginIndex);\n        }\n        skipDecimalDigits();\n        break;\n      default:\n        break;\n    }\n    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));\n  }\n  function skipDecimalDigits() {\n    while (isDecimalDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipHexDigits() {\n    while (isHexDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipBinaryDigits() {\n    while (isBinaryDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function skipOctalDigits() {\n    while (isOctalDigit(currentCharCode)) {\n      next();\n    }\n  }\n  function isAtEnd() {\n    return index === length;\n  }\n  function next() {\n    index++;\n    updateCurrentCharCode();\n  }\n  function updateCurrentCharCode() {\n    currentCharCode = input.charCodeAt(index);\n  }\n  function reportError(message) {\n    var startIndex = arguments[1] !== (void 0) ? arguments[1] : index;\n    var endIndex = arguments[2] !== (void 0) ? arguments[2] : index;\n    var start = getPositionByOffset(startIndex);\n    var end = getPositionByOffset(endIndex);\n    var location = new SourceRange(start, end);\n    errorReporter.reportError(location, message);\n  }\n  return {\n    get isWhitespace() {\n      return isWhitespace;\n    },\n    get isLineTerminator() {\n      return isLineTerminator;\n    },\n    get isIdentifierPart() {\n      return isIdentifierPart;\n    },\n    get init() {\n      return init;\n    },\n    get getLastToken() {\n      return getLastToken;\n    },\n    get nextRegularExpressionLiteralToken() {\n      return nextRegularExpressionLiteralToken;\n    },\n    get nextTemplateLiteralToken() {\n      return nextTemplateLiteralToken;\n    },\n    get setIndex() {\n      return setIndex;\n    },\n    get getPosition() {\n      return getPosition;\n    },\n    get nextCloseAngle() {\n      return nextCloseAngle;\n    },\n    get peekJsxToken() {\n      return peekJsxToken;\n    },\n    get nextJsxToken() {\n      return nextJsxToken;\n    },\n    get nextJsxTextToken() {\n      return nextJsxTextToken;\n    },\n    get nextToken() {\n      return nextToken;\n    },\n    get peekTokenNoLineTerminator() {\n      return peekTokenNoLineTerminator;\n    },\n    get peek() {\n      return peek;\n    },\n    get peekLookahead() {\n      return peekLookahead;\n    },\n    get peekToken() {\n      return peekToken;\n    },\n    get peekType() {\n      return peekType;\n    },\n    get peekLocation() {\n      return peekLocation;\n    },\n    get peekTokenLookahead() {\n      return peekTokenLookahead;\n    },\n    get isAtEnd() {\n      return isAtEnd;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ConstructorValidator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ConstructorValidator.js\";\n  var SUPER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/ConstructorValidator.js\")).SUPER_EXPRESSION;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/FindVisitor.js\", \"traceur@0.0.111/src/semantics/ConstructorValidator.js\")).FindVisitor;\n  var ConstructorValidator = function($__super) {\n    function ConstructorValidator(reporter) {\n      $traceurRuntime.superConstructor(ConstructorValidator).call(this);\n      this.reporter_ = reporter;\n      this.hasError = false;\n    }\n    return ($traceurRuntime.createClass)(ConstructorValidator, {\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n      },\n      visitThisExpression: function(tree) {\n        this.reportError_(tree.location, 'this');\n      },\n      visitCallExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          this.visitAny(tree.args);\n          this.found = true;\n          return;\n        }\n        $traceurRuntime.superGet(this, ConstructorValidator.prototype, \"visitCallExpression\").call(this, tree);\n      },\n      visitSuperExpression: function(tree) {\n        this.reportError_(tree.location, 'super property');\n      },\n      reportError_: function(location, kind) {\n        this.reporter_.reportError(location, (\"'\" + kind + \"' is not allowed before super()\"));\n        this.hasError = true;\n        this.found = true;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  function validateConstructor(tree, reporter) {\n    var visitor = new ConstructorValidator(reporter);\n    visitor.visitAny(tree);\n    if (visitor.hasError)\n      return false;\n    if (visitor.found)\n      return true;\n    reporter.reportError(tree.location, 'Derived constructor must call super()');\n    return false;\n  }\n  return {get validateConstructor() {\n      return validateConstructor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/staticsemantics/validateParameters.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/staticsemantics/validateParameters.js\";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/staticsemantics/validateParameters.js\")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/staticsemantics/validateParameters.js\")).StringSet;\n  var isStrictKeyword = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Keywords.js\", \"traceur@0.0.111/src/staticsemantics/validateParameters.js\")).isStrictKeyword;\n  var ParameterValidationVisitor = function($__super) {\n    function ParameterValidationVisitor(isStrict, reporter) {\n      $traceurRuntime.superConstructor(ParameterValidationVisitor).call(this);\n      this.reporter_ = reporter;\n      this.names_ = new StringSet();\n      this.errors_ = [];\n      this.reportStrictKeywords_ = isStrict;\n      this.reportDuplicates_ = isStrict;\n    }\n    return ($traceurRuntime.createClass)(ParameterValidationVisitor, {\n      visitBindingIdentifier: function(tree) {\n        var name = tree.identifierToken.toString();\n        if (this.reportStrictKeywords_ && (isStrictKeyword(name) || name === 'eval' || name === 'arguments')) {\n          this.reporter_.reportError(tree.location, (name + \" is a reserved identifier\"));\n        }\n        if (this.names_.has(name)) {\n          this.maybeReportDuplicateError_(name, tree.location);\n        }\n        this.names_.add(name);\n      },\n      visitBindingElement: function(tree) {\n        if (tree.initializer !== null) {\n          this.reportEarlierErrors_();\n        }\n        this.visitAny(tree.binding);\n      },\n      visitRestParameter: function(tree) {\n        this.reportEarlierErrors_();\n        this.visitAny(tree.identifier);\n      },\n      visitFormalParameter: function(tree) {\n        this.visitAny(tree.parameter);\n      },\n      visitArrayPattern: function(tree) {\n        this.reportEarlierErrors_();\n        $traceurRuntime.superGet(this, ParameterValidationVisitor.prototype, \"visitArrayPattern\").call(this, tree);\n      },\n      visitObjectPattern: function(tree) {\n        this.reportEarlierErrors_();\n        $traceurRuntime.superGet(this, ParameterValidationVisitor.prototype, \"visitObjectPattern\").call(this, tree);\n      },\n      reportDuplicateError_: function(name, location) {\n        this.reporter_.reportError(location, (\"Duplicate parameter name \" + name));\n      },\n      maybeReportDuplicateError_: function(name, location) {\n        if (this.reportDuplicates_) {\n          this.reportDuplicateError_(name, location);\n        } else {\n          this.errors_.push(name, location);\n        }\n      },\n      reportEarlierErrors_: function() {\n        if (!this.reportDuplicates_) {\n          this.reportDuplicates_ = true;\n          for (var i = 0; i < this.errors_.length; i += 2) {\n            var name = this.errors_[i];\n            var location = this.errors_[i + 1];\n            this.reportDuplicateError_(name, location);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  var $__default = function(tree, isStrict, reporter) {\n    new ParameterValidationVisitor(isStrict, reporter).visitAny(tree);\n  };\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/staticsemantics/isValidSimpleAssignmentTarget.js\")),\n      IDENTIFIER_EXPRESSION = $__1.IDENTIFIER_EXPRESSION,\n      MEMBER_EXPRESSION = $__1.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__1.MEMBER_LOOKUP_EXPRESSION,\n      PAREN_EXPRESSION = $__1.PAREN_EXPRESSION;\n  function isValidSimpleAssignmentTarget(tree, isStrict) {\n    switch (tree.type) {\n      case IDENTIFIER_EXPRESSION:\n        {\n          if (!isStrict)\n            return true;\n          var value = tree.identifierToken.value;\n          return value !== 'arguments' && value !== 'eval';\n        }\n      case PAREN_EXPRESSION:\n        return isValidSimpleAssignmentTarget(tree.expression, isStrict);\n      case MEMBER_EXPRESSION:\n      case MEMBER_LOOKUP_EXPRESSION:\n        return true;\n      default:\n        return false;\n    }\n  }\n  return {get default() {\n      return isValidSimpleAssignmentTarget;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/Parser.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/Parser.js\";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/FindVisitor.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).FindVisitor;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./IdentifierToken.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).IdentifierToken;\n  var $__25 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./trees/ParseTreeType.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      ARRAY_LITERAL = $__25.ARRAY_LITERAL,\n      BINDING_IDENTIFIER = $__25.BINDING_IDENTIFIER,\n      CALL_EXPRESSION = $__25.CALL_EXPRESSION,\n      COMPUTED_PROPERTY_NAME = $__25.COMPUTED_PROPERTY_NAME,\n      COVER_FORMALS = $__25.COVER_FORMALS,\n      FORMAL_PARAMETER_LIST = $__25.FORMAL_PARAMETER_LIST,\n      IDENTIFIER_EXPRESSION = $__25.IDENTIFIER_EXPRESSION,\n      LITERAL_PROPERTY_NAME = $__25.LITERAL_PROPERTY_NAME,\n      OBJECT_LITERAL = $__25.OBJECT_LITERAL,\n      REST_PARAMETER = $__25.REST_PARAMETER,\n      SYNTAX_ERROR_TREE = $__25.SYNTAX_ERROR_TREE;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Options.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).Options;\n  var $__27 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PredefinedName.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      AS = $__27.AS,\n      ASYNC = $__27.ASYNC,\n      ASYNC_STAR = $__27.ASYNC_STAR,\n      AWAIT = $__27.AWAIT,\n      CONSTRUCTOR = $__27.CONSTRUCTOR,\n      FROM = $__27.FROM,\n      GET = $__27.GET,\n      OF = $__27.OF,\n      ON = $__27.ON,\n      SET = $__27.SET,\n      TYPE = $__27.TYPE;\n  var SyntaxErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/SyntaxErrorReporter.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).SyntaxErrorReporter;\n  var $__29 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Scanner.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      getLastToken = $__29.getLastToken,\n      getPosition = $__29.getPosition,\n      initScanner = $__29.init,\n      isAtEnd = $__29.isAtEnd,\n      nextCloseAngle = $__29.nextCloseAngle,\n      nextJsxTextToken = $__29.nextJsxTextToken,\n      nextJsxToken = $__29.nextJsxToken,\n      nextRegularExpressionLiteralToken = $__29.nextRegularExpressionLiteralToken,\n      nextTemplateLiteralToken = $__29.nextTemplateLiteralToken,\n      nextToken = $__29.nextToken,\n      peek = $__29.peek,\n      peekJsxToken = $__29.peekJsxToken,\n      peekLocation = $__29.peekLocation,\n      peekLookahead = $__29.peekLookahead,\n      peekToken = $__29.peekToken,\n      peekTokenLookahead = $__29.peekTokenLookahead,\n      peekTokenNoLineTerminator = $__29.peekTokenNoLineTerminator,\n      peekType = $__29.peekType,\n      resetScanner = $__29.setIndex;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/SourceRange.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).SourceRange;\n  var $__31 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Token.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      Token = $__31.Token,\n      isAssignmentOperator = $__31.isAssignmentOperator;\n  var getKeywordType = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Keywords.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).getKeywordType;\n  var validateConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/ConstructorValidator.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).validateConstructor;\n  var validateParameters = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../staticsemantics/validateParameters.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).default;\n  var isValidSimpleAssignmentTarget = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../staticsemantics/isValidSimpleAssignmentTarget.js\", \"traceur@0.0.111/src/syntax/Parser.js\")).default;\n  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      AMPERSAND = $__36.AMPERSAND,\n      AND = $__36.AND,\n      ARROW = $__36.ARROW,\n      AT = $__36.AT,\n      BANG = $__36.BANG,\n      BAR = $__36.BAR,\n      BREAK = $__36.BREAK,\n      CARET = $__36.CARET,\n      CASE = $__36.CASE,\n      CATCH = $__36.CATCH,\n      CLASS = $__36.CLASS,\n      CLOSE_ANGLE = $__36.CLOSE_ANGLE,\n      CLOSE_CURLY = $__36.CLOSE_CURLY,\n      CLOSE_PAREN = $__36.CLOSE_PAREN,\n      CLOSE_SQUARE = $__36.CLOSE_SQUARE,\n      COLON = $__36.COLON,\n      COMMA = $__36.COMMA,\n      CONST = $__36.CONST,\n      CONTINUE = $__36.CONTINUE,\n      DEBUGGER = $__36.DEBUGGER,\n      DEFAULT = $__36.DEFAULT,\n      DELETE = $__36.DELETE,\n      DO = $__36.DO,\n      DOT_DOT_DOT = $__36.DOT_DOT_DOT,\n      ELSE = $__36.ELSE,\n      END_OF_FILE = $__36.END_OF_FILE,\n      EQUAL = $__36.EQUAL,\n      EQUAL_EQUAL = $__36.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__36.EQUAL_EQUAL_EQUAL,\n      ERROR = $__36.ERROR,\n      EXPORT = $__36.EXPORT,\n      EXTENDS = $__36.EXTENDS,\n      FALSE = $__36.FALSE,\n      FINALLY = $__36.FINALLY,\n      FOR = $__36.FOR,\n      FUNCTION = $__36.FUNCTION,\n      GREATER_EQUAL = $__36.GREATER_EQUAL,\n      IDENTIFIER = $__36.IDENTIFIER,\n      IF = $__36.IF,\n      IMPLEMENTS = $__36.IMPLEMENTS,\n      IMPORT = $__36.IMPORT,\n      IN = $__36.IN,\n      INSTANCEOF = $__36.INSTANCEOF,\n      INTERFACE = $__36.INTERFACE,\n      JSX_IDENTIFIER = $__36.JSX_IDENTIFIER,\n      LEFT_SHIFT = $__36.LEFT_SHIFT,\n      LESS_EQUAL = $__36.LESS_EQUAL,\n      LET = $__36.LET,\n      MINUS = $__36.MINUS,\n      MINUS_MINUS = $__36.MINUS_MINUS,\n      NEW = $__36.NEW,\n      NO_SUBSTITUTION_TEMPLATE = $__36.NO_SUBSTITUTION_TEMPLATE,\n      NOT_EQUAL = $__36.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__36.NOT_EQUAL_EQUAL,\n      NULL = $__36.NULL,\n      NUMBER = $__36.NUMBER,\n      OPEN_ANGLE = $__36.OPEN_ANGLE,\n      OPEN_CURLY = $__36.OPEN_CURLY,\n      OPEN_PAREN = $__36.OPEN_PAREN,\n      OPEN_SQUARE = $__36.OPEN_SQUARE,\n      OR = $__36.OR,\n      PACKAGE = $__36.PACKAGE,\n      PERCENT = $__36.PERCENT,\n      PERIOD = $__36.PERIOD,\n      PLUS = $__36.PLUS,\n      PLUS_PLUS = $__36.PLUS_PLUS,\n      PRIVATE = $__36.PRIVATE,\n      PROTECTED = $__36.PROTECTED,\n      PUBLIC = $__36.PUBLIC,\n      QUESTION = $__36.QUESTION,\n      RETURN = $__36.RETURN,\n      RIGHT_SHIFT = $__36.RIGHT_SHIFT,\n      SEMI_COLON = $__36.SEMI_COLON,\n      SLASH = $__36.SLASH,\n      SLASH_EQUAL = $__36.SLASH_EQUAL,\n      STAR = $__36.STAR,\n      STAR_STAR = $__36.STAR_STAR,\n      STATIC = $__36.STATIC,\n      STRING = $__36.STRING,\n      SUPER = $__36.SUPER,\n      SWITCH = $__36.SWITCH,\n      TEMPLATE_HEAD = $__36.TEMPLATE_HEAD,\n      TEMPLATE_TAIL = $__36.TEMPLATE_TAIL,\n      THIS = $__36.THIS,\n      THROW = $__36.THROW,\n      TILDE = $__36.TILDE,\n      TRUE = $__36.TRUE,\n      TRY = $__36.TRY,\n      TYPEOF = $__36.TYPEOF,\n      UNSIGNED_RIGHT_SHIFT = $__36.UNSIGNED_RIGHT_SHIFT,\n      VAR = $__36.VAR,\n      VOID = $__36.VOID,\n      WHILE = $__36.WHILE,\n      WITH = $__36.WITH,\n      YIELD = $__36.YIELD;\n  var $__37 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./trees/ParseTrees.js\", \"traceur@0.0.111/src/syntax/Parser.js\")),\n      ArgumentList = $__37.ArgumentList,\n      ArrayComprehension = $__37.ArrayComprehension,\n      ArrayLiteral = $__37.ArrayLiteral,\n      ArrayPattern = $__37.ArrayPattern,\n      ArrayType = $__37.ArrayType,\n      ArrowFunction = $__37.ArrowFunction,\n      AssignmentElement = $__37.AssignmentElement,\n      AwaitExpression = $__37.AwaitExpression,\n      BinaryExpression = $__37.BinaryExpression,\n      BindingElement = $__37.BindingElement,\n      BindingIdentifier = $__37.BindingIdentifier,\n      Block = $__37.Block,\n      BreakStatement = $__37.BreakStatement,\n      CallExpression = $__37.CallExpression,\n      CallSignature = $__37.CallSignature,\n      CaseClause = $__37.CaseClause,\n      Catch = $__37.Catch,\n      ClassDeclaration = $__37.ClassDeclaration,\n      ClassExpression = $__37.ClassExpression,\n      CommaExpression = $__37.CommaExpression,\n      ComprehensionFor = $__37.ComprehensionFor,\n      ComprehensionIf = $__37.ComprehensionIf,\n      ComputedPropertyName = $__37.ComputedPropertyName,\n      ConditionalExpression = $__37.ConditionalExpression,\n      ConstructSignature = $__37.ConstructSignature,\n      ConstructorType = $__37.ConstructorType,\n      ContinueStatement = $__37.ContinueStatement,\n      CoverFormals = $__37.CoverFormals,\n      CoverInitializedName = $__37.CoverInitializedName,\n      DebuggerStatement = $__37.DebuggerStatement,\n      Annotation = $__37.Annotation,\n      DefaultClause = $__37.DefaultClause,\n      DoWhileStatement = $__37.DoWhileStatement,\n      EmptyStatement = $__37.EmptyStatement,\n      ExportDeclaration = $__37.ExportDeclaration,\n      ExportDefault = $__37.ExportDefault,\n      ExportSpecifier = $__37.ExportSpecifier,\n      ExportSpecifierSet = $__37.ExportSpecifierSet,\n      ExportStar = $__37.ExportStar,\n      ExpressionStatement = $__37.ExpressionStatement,\n      Finally = $__37.Finally,\n      ForInStatement = $__37.ForInStatement,\n      ForOfStatement = $__37.ForOfStatement,\n      ForOnStatement = $__37.ForOnStatement,\n      ForStatement = $__37.ForStatement,\n      FormalParameter = $__37.FormalParameter,\n      FormalParameterList = $__37.FormalParameterList,\n      ForwardDefaultExport = $__37.ForwardDefaultExport,\n      FunctionBody = $__37.FunctionBody,\n      FunctionDeclaration = $__37.FunctionDeclaration,\n      FunctionExpression = $__37.FunctionExpression,\n      FunctionType = $__37.FunctionType,\n      GeneratorComprehension = $__37.GeneratorComprehension,\n      GetAccessor = $__37.GetAccessor,\n      IdentifierExpression = $__37.IdentifierExpression,\n      IfStatement = $__37.IfStatement,\n      ImportClausePair = $__37.ImportClausePair,\n      ImportDeclaration = $__37.ImportDeclaration,\n      ImportSpecifier = $__37.ImportSpecifier,\n      ImportSpecifierSet = $__37.ImportSpecifierSet,\n      ImportedBinding = $__37.ImportedBinding,\n      ImportTypeClause = $__37.ImportTypeClause,\n      IndexSignature = $__37.IndexSignature,\n      InterfaceDeclaration = $__37.InterfaceDeclaration,\n      JsxAttribute = $__37.JsxAttribute,\n      JsxElement = $__37.JsxElement,\n      JsxElementName = $__37.JsxElementName,\n      JsxPlaceholder = $__37.JsxPlaceholder,\n      JsxSpreadAttribute = $__37.JsxSpreadAttribute,\n      JsxText = $__37.JsxText,\n      LabelledStatement = $__37.LabelledStatement,\n      LiteralExpression = $__37.LiteralExpression,\n      LiteralPropertyName = $__37.LiteralPropertyName,\n      MemberExpression = $__37.MemberExpression,\n      MemberLookupExpression = $__37.MemberLookupExpression,\n      Method = $__37.Method,\n      MethodSignature = $__37.MethodSignature,\n      Module = $__37.Module,\n      ModuleSpecifier = $__37.ModuleSpecifier,\n      NameSpaceExport = $__37.NameSpaceExport,\n      NameSpaceImport = $__37.NameSpaceImport,\n      NamedExport = $__37.NamedExport,\n      NewExpression = $__37.NewExpression,\n      ObjectLiteral = $__37.ObjectLiteral,\n      ObjectPattern = $__37.ObjectPattern,\n      ObjectPatternField = $__37.ObjectPatternField,\n      ObjectType = $__37.ObjectType,\n      ParenExpression = $__37.ParenExpression,\n      PostfixExpression = $__37.PostfixExpression,\n      PredefinedType = $__37.PredefinedType,\n      PropertyNameAssignment = $__37.PropertyNameAssignment,\n      PropertyNameShorthand = $__37.PropertyNameShorthand,\n      PropertySignature = $__37.PropertySignature,\n      PropertyVariableDeclaration = $__37.PropertyVariableDeclaration,\n      RestParameter = $__37.RestParameter,\n      ReturnStatement = $__37.ReturnStatement,\n      Script = $__37.Script,\n      SetAccessor = $__37.SetAccessor,\n      SpreadExpression = $__37.SpreadExpression,\n      SpreadPatternElement = $__37.SpreadPatternElement,\n      SuperExpression = $__37.SuperExpression,\n      SwitchStatement = $__37.SwitchStatement,\n      SyntaxErrorTree = $__37.SyntaxErrorTree,\n      TemplateLiteralExpression = $__37.TemplateLiteralExpression,\n      TemplateLiteralPortion = $__37.TemplateLiteralPortion,\n      TemplateSubstitution = $__37.TemplateSubstitution,\n      ThisExpression = $__37.ThisExpression,\n      ThrowStatement = $__37.ThrowStatement,\n      TryStatement = $__37.TryStatement,\n      TypeAliasDeclaration = $__37.TypeAliasDeclaration,\n      TypeArguments = $__37.TypeArguments,\n      TypeName = $__37.TypeName,\n      TypeParameter = $__37.TypeParameter,\n      TypeParameters = $__37.TypeParameters,\n      TypeReference = $__37.TypeReference,\n      UnaryExpression = $__37.UnaryExpression,\n      UnionType = $__37.UnionType,\n      VariableDeclaration = $__37.VariableDeclaration,\n      VariableDeclarationList = $__37.VariableDeclarationList,\n      VariableStatement = $__37.VariableStatement,\n      WhileStatement = $__37.WhileStatement,\n      WithStatement = $__37.WithStatement,\n      YieldExpression = $__37.YieldExpression;\n  var ALLOW_IN = true;\n  var NO_IN = false;\n  var INITIALIZER_REQUIRED = true;\n  var INITIALIZER_OPTIONAL = false;\n  var ValidateObjectLiteral = function($__super) {\n    function ValidateObjectLiteral() {\n      $traceurRuntime.superConstructor(ValidateObjectLiteral).call(this);\n      this.errorToken = null;\n    }\n    return ($traceurRuntime.createClass)(ValidateObjectLiteral, {visitCoverInitializedName: function(tree) {\n        this.errorToken = tree.equalToken;\n        this.found = true;\n      }}, {}, $__super);\n  }(FindVisitor);\n  function containsInitializer(declarations) {\n    return declarations.some(function(v) {\n      return v.initializer;\n    });\n  }\n  var FUNCTION_STATE_SCRIPT = 1;\n  var FUNCTION_STATE_MODULE = 1 << 1;\n  var FUNCTION_STATE_FUNCTION = 1 << 2;\n  var FUNCTION_STATE_ARROW = 1 << 3;\n  var FUNCTION_STATE_METHOD = 1 << 4;\n  var FUNCTION_STATE_DERIVED_CONSTRUCTOR = 1 << 5;\n  var FUNCTION_STATE_GENERATOR = 1 << 6;\n  var FUNCTION_STATE_ASYNC = 1 << 7;\n  var FUNCTION_STATE_LENIENT = FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR | FUNCTION_STATE_ASYNC | FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n  var FunctionState = function() {\n    function FunctionState(outer, kind) {\n      this.outer = outer;\n      this.kind = kind;\n    }\n    return ($traceurRuntime.createClass)(FunctionState, {\n      isTopMost: function() {\n        return this.kind & (FUNCTION_STATE_SCRIPT | FUNCTION_STATE_MODULE);\n      },\n      isMethod: function() {\n        return this.kind & FUNCTION_STATE_METHOD;\n      },\n      isDerivedConstructor: function() {\n        return this.kind & FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n      },\n      isArrowFunction: function() {\n        return this.kind & FUNCTION_STATE_ARROW;\n      },\n      isGenerator: function() {\n        return this.kind & FUNCTION_STATE_GENERATOR;\n      },\n      isAsyncFunction: function() {\n        return this.kind & FUNCTION_STATE_ASYNC;\n      },\n      isAsyncGenerator: function() {\n        return this.isGenerator() && this.isAsyncFunction();\n      }\n    }, {});\n  }();\n  var Parser = function() {\n    function Parser(file) {\n      var errorReporter = arguments[1] !== (void 0) ? arguments[1] : new SyntaxErrorReporter();\n      var options = arguments[2] !== (void 0) ? arguments[2] : new Options();\n      this.errorReporter_ = errorReporter;\n      initScanner(errorReporter, file, this, options);\n      this.options_ = options;\n      this.coverInitializedNameCount_ = 0;\n      this.strictMode_ = false;\n      this.annotations_ = [];\n      this.functionState_ = null;\n    }\n    return ($traceurRuntime.createClass)(Parser, {\n      get allowYield_() {\n        return this.functionState_.isGenerator();\n      },\n      get allowAwait_() {\n        return this.functionState_.isAsyncFunction();\n      },\n      get allowForOn_() {\n        return this.functionState_.isAsyncFunction();\n      },\n      parseScript: function() {\n        this.strictMode_ = false;\n        var start = this.getTreeStartLocation_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_SCRIPT);\n        var scriptItemList = this.parseStatementList_(true);\n        this.eat_(END_OF_FILE);\n        this.popFunctionState_(fs);\n        return new Script(this.getTreeLocation_(start), scriptItemList, null);\n      },\n      pushFunctionState_: function(kind) {\n        return this.functionState_ = new FunctionState(this.functionState_, kind);\n      },\n      popFunctionState_: function(fs) {\n        if (fs != this.functionState_) {\n          throw new Error('Internal error');\n        }\n        this.functionState_ = this.functionState_.outer;\n      },\n      parseStatementList_: function(checkUseStrictDirective) {\n        var result = [];\n        var type;\n        while ((type = peekType()) !== CLOSE_CURLY && type !== END_OF_FILE) {\n          var statement = this.parseStatementListItem_(type);\n          if (checkUseStrictDirective) {\n            if (!statement.isDirectivePrologue()) {\n              checkUseStrictDirective = false;\n            } else if (statement.isUseStrictDirective()) {\n              this.strictMode_ = true;\n              checkUseStrictDirective = false;\n            }\n          }\n          result.push(statement);\n        }\n        return result;\n      },\n      parseStatementListItem_: function(type) {\n        switch (type) {\n          case LET:\n          case CONST:\n            if (this.options_.blockBinding) {\n              return this.parseVariableStatement_();\n            }\n            break;\n          case CLASS:\n            if (this.options_.classes) {\n              return this.parseClassDeclaration_();\n            }\n            break;\n          case FUNCTION:\n            return this.parseFunctionDeclaration_();\n          case IDENTIFIER:\n            if (this.options_.types && this.peekPredefinedString_(TYPE) && peekLookahead(IDENTIFIER)) {\n              return this.parseTypeAliasDeclaration_();\n            }\n            break;\n        }\n        return this.parseStatementWithType_(type);\n      },\n      parseModule: function() {\n        var start = this.getTreeStartLocation_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_MODULE);\n        var scriptItemList = this.parseModuleItemList_();\n        this.eat_(END_OF_FILE);\n        this.popFunctionState_(fs);\n        return new Module(this.getTreeLocation_(start), scriptItemList, null);\n      },\n      parseModuleItemList_: function() {\n        this.strictMode_ = true;\n        var result = [];\n        var type;\n        while ((type = peekType()) !== END_OF_FILE) {\n          var statement = this.parseModuleItem_(type);\n          result.push(statement);\n        }\n        return result;\n      },\n      parseModuleItem_: function(type) {\n        switch (type) {\n          case IMPORT:\n            return this.parseImportDeclaration_();\n          case EXPORT:\n            return this.parseExportDeclaration_();\n          case AT:\n            if (this.options_.annotations)\n              return this.parseAnnotatedDeclarations_(true);\n            break;\n        }\n        return this.parseStatementListItem_(type);\n      },\n      parseModuleSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = this.eat_(STRING);\n        return new ModuleSpecifier(this.getTreeLocation_(start), token);\n      },\n      parseNameSpaceImport_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(STAR);\n        this.eatId_(AS);\n        var binding = this.parseImportedBinding_();\n        return new NameSpaceImport(this.getTreeLocation_(start), binding);\n      },\n      parseImportDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IMPORT);\n        var importClause = null;\n        if (!peek(STRING)) {\n          importClause = this.parseImportClause_(true, this.options_.types);\n          this.eatId_(FROM);\n        }\n        var moduleSpecifier = this.parseModuleSpecifier_();\n        this.eatPossibleImplicitSemiColon_();\n        return new ImportDeclaration(this.getTreeLocation_(start), importClause, moduleSpecifier);\n      },\n      parseImportClause_: function(allowImportedDefaultBinding, allowType) {\n        switch (peekType()) {\n          case STAR:\n            return this.parseNameSpaceImport_();\n          case OPEN_CURLY:\n            return this.parseImportSpecifierSet_();\n          case IDENTIFIER:\n            if (allowType && this.peekPredefinedString_(TYPE)) {\n              var start = this.getTreeStartLocation_();\n              var t = peekTokenLookahead();\n              if (t.type === OPEN_CURLY || t.type === IDENTIFIER && t.value !== FROM) {\n                this.eatId_(TYPE);\n                var clause = this.parseImportClause_(allowImportedDefaultBinding, false);\n                return new ImportTypeClause(this.getTreeLocation_(start), clause);\n              }\n            }\n            if (allowImportedDefaultBinding) {\n              var start$__4 = this.getTreeStartLocation_();\n              var importedBinding = this.parseImportedBinding_();\n              if (this.eatIf_(COMMA)) {\n                var second = this.parseImportClause_(false, false);\n                return new ImportClausePair(this.getTreeLocation_(start$__4), importedBinding, second);\n              }\n              return importedBinding;\n            }\n            break;\n        }\n        return this.parseUnexpectedToken_();\n      },\n      parseImportSpecifierSet_: function() {\n        var start = this.getTreeStartLocation_();\n        var specifiers = [];\n        this.eat_(OPEN_CURLY);\n        while (!peek(CLOSE_CURLY) && !isAtEnd()) {\n          specifiers.push(this.parseImportSpecifier_());\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ImportSpecifierSet(this.getTreeLocation_(start), specifiers);\n      },\n      parseImportedBinding_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingIdentifier_();\n        return new ImportedBinding(this.getTreeLocation_(start), binding);\n      },\n      parseImportSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = peekToken();\n        var isKeyword = token.isKeyword();\n        var binding;\n        var name = this.eatIdName_();\n        if (isKeyword || this.peekPredefinedString_(AS)) {\n          this.eatId_(AS);\n          binding = this.parseImportedBinding_();\n        } else {\n          binding = new ImportedBinding(name.location, new BindingIdentifier(name.location, name));\n          name = null;\n        }\n        return new ImportSpecifier(this.getTreeLocation_(start), binding, name);\n      },\n      parseExportDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(EXPORT);\n        var exportTree;\n        var annotations = this.popAnnotations_();\n        var type = peekType();\n        switch (type) {\n          case CONST:\n          case LET:\n            if (this.options_.blockBinding) {\n              exportTree = this.parseVariableStatement_();\n              break;\n            }\n            return this.parseUnexpectedToken_();\n          case VAR:\n            exportTree = this.parseVariableStatement_();\n            break;\n          case FUNCTION:\n            exportTree = this.parseFunctionDeclaration_();\n            break;\n          case CLASS:\n            exportTree = this.parseClassDeclaration_();\n            break;\n          case DEFAULT:\n            exportTree = this.parseExportDefault_();\n            break;\n          case OPEN_CURLY:\n          case STAR:\n            exportTree = this.parseNamedExport_();\n            break;\n          case IDENTIFIER:\n            if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC)) {\n              var asyncToken = this.eatId_();\n              exportTree = this.parseAsyncFunctionDeclaration_(asyncToken);\n            } else if (this.options_.types && this.peekPredefinedString_(TYPE) && peekLookahead(IDENTIFIER)) {\n              exportTree = this.parseTypeAliasDeclaration_();\n            } else if (this.options_.exportFromExtended) {\n              exportTree = this.parseNamedExport_();\n            } else {\n              return this.parseUnexpectedToken_();\n            }\n            break;\n          default:\n            {\n              var token = peekToken();\n              if (!token.isKeyword()) {\n                return this.parseUnexpectedToken_();\n              }\n              exportTree = this.parseNamedExport_();\n            }\n        }\n        return new ExportDeclaration(this.getTreeLocation_(start), exportTree, annotations);\n      },\n      parseExportDefault_: function() {\n        var start = this.getTreeStartLocation_();\n        var defaultToken = this.eat_(DEFAULT);\n        if (this.options_.exportFromExtended && this.peekPredefinedString_(FROM)) {\n          var idName = new IdentifierToken(defaultToken.location, DEFAULT);\n          var namedExport = new ForwardDefaultExport(this.getTreeLocation_(start), idName);\n          this.eatId_(FROM);\n          var moduleSpecifier = this.parseModuleSpecifier_();\n          return new NamedExport(this.getTreeLocation_(start), namedExport, moduleSpecifier);\n        }\n        var exportValue;\n        switch (peekType()) {\n          case FUNCTION:\n            {\n              var tree = this.parseFunctionExpression_();\n              if (tree.name) {\n                tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n              }\n              exportValue = tree;\n              break;\n            }\n          case CLASS:\n            {\n              if (!this.options_.classes) {\n                return this.parseSyntaxError_('Unexpected reserved word');\n              }\n              var tree$__5 = this.parseClassExpression_();\n              if (tree$__5.name) {\n                tree$__5 = new ClassDeclaration(tree$__5.location, tree$__5.name, tree$__5.superClass, tree$__5.elements, tree$__5.annotations, tree$__5.typeParameters);\n              }\n              exportValue = tree$__5;\n              break;\n            }\n          default:\n            exportValue = this.parseAssignmentExpression_(ALLOW_IN);\n            this.eatPossibleImplicitSemiColon_();\n        }\n        return new ExportDefault(this.getTreeLocation_(start), exportValue);\n      },\n      parseNamedExport_: function() {\n        var start = this.getTreeStartLocation_();\n        var exportClause,\n            moduleSpecifier = null;\n        switch (peekType()) {\n          case OPEN_CURLY:\n            exportClause = this.parseExportSpecifierSet_();\n            if (this.peekPredefinedString_(FROM)) {\n              this.eatId_(FROM);\n              moduleSpecifier = this.parseModuleSpecifier_();\n            } else {\n              this.validateExportSpecifierSet_(exportClause);\n            }\n            break;\n          case STAR:\n            exportClause = this.parseExportStar_();\n            this.eatId_(FROM);\n            moduleSpecifier = this.parseModuleSpecifier_();\n            break;\n          default:\n            exportClause = this.parseForwardDefaultExport_();\n            this.eatId_(FROM);\n            moduleSpecifier = this.parseModuleSpecifier_();\n            break;\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new NamedExport(this.getTreeLocation_(start), exportClause, moduleSpecifier);\n      },\n      parseExportStar_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(STAR);\n        if (this.peekPredefinedString_(AS)) {\n          this.eatId_(AS);\n          var name = this.eatIdName_();\n          return new NameSpaceExport(this.getTreeLocation_(start), name);\n        }\n        return new ExportStar(this.getTreeLocation_(start));\n      },\n      parseExportSpecifierSet_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var specifiers = [this.parseExportSpecifier_()];\n        while (this.eatIf_(COMMA)) {\n          if (peek(CLOSE_CURLY))\n            break;\n          specifiers.push(this.parseExportSpecifier_());\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ExportSpecifierSet(this.getTreeLocation_(start), specifiers);\n      },\n      parseExportSpecifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var lhs = this.eatIdName_();\n        var rhs = null;\n        if (this.peekPredefinedString_(AS)) {\n          this.eatId_();\n          rhs = this.eatIdName_();\n        }\n        return new ExportSpecifier(this.getTreeLocation_(start), lhs, rhs);\n      },\n      parseForwardDefaultExport_: function() {\n        var start = this.getTreeStartLocation_();\n        var idName = this.eatIdName_();\n        return new ForwardDefaultExport(this.getTreeLocation_(start), idName);\n      },\n      validateExportSpecifierSet_: function(tree) {\n        for (var i = 0; i < tree.specifiers.length; i++) {\n          var specifier = tree.specifiers[i];\n          if (getKeywordType(specifier.lhs.value)) {\n            this.reportError_(specifier.lhs.location, (\"Unexpected token \" + specifier.lhs.value));\n          }\n        }\n      },\n      peekId_: function(type) {\n        if (type === IDENTIFIER)\n          return true;\n        if (this.strictMode_)\n          return false;\n        return peekToken().isStrictKeyword();\n      },\n      peekIdName_: function(token) {\n        return token.type === IDENTIFIER || token.isKeyword();\n      },\n      parseClassShared_: function(constr) {\n        var start = this.getTreeStartLocation_();\n        var strictMode = this.strictMode_;\n        this.strictMode_ = true;\n        this.eat_(CLASS);\n        var name = null;\n        var typeParameters = null;\n        var annotations = [];\n        if (constr === ClassDeclaration || !peek(EXTENDS) && !peek(OPEN_CURLY)) {\n          name = this.parseBindingIdentifier_();\n          if (this.options_.types) {\n            typeParameters = this.parseTypeParametersOpt_();\n          }\n          annotations = this.popAnnotations_();\n        }\n        var superClass = null;\n        if (this.eatIf_(EXTENDS)) {\n          superClass = this.parseLeftHandSideExpression_();\n          superClass = this.coverFormalsToParenExpression_(superClass);\n        }\n        this.eat_(OPEN_CURLY);\n        var elements = this.parseClassElements_(superClass);\n        this.eat_(CLOSE_CURLY);\n        this.strictMode_ = strictMode;\n        return new constr(this.getTreeLocation_(start), name, superClass, elements, annotations, typeParameters);\n      },\n      parseClassDeclaration_: function() {\n        return this.parseClassShared_(ClassDeclaration);\n      },\n      parseClassExpression_: function() {\n        return this.parseClassShared_(ClassExpression);\n      },\n      parseClassElements_: function(derivedClass) {\n        var result = [];\n        while (true) {\n          var type = peekType();\n          if (type === SEMI_COLON) {\n            nextToken();\n          } else if (this.peekClassElement_(peekType())) {\n            result.push(this.parseClassElement_(derivedClass));\n          } else {\n            break;\n          }\n        }\n        return result;\n      },\n      peekClassElement_: function(type) {\n        return this.peekPropertyName_(type) || type === STAR && this.options_.generators || type === AT && this.options_.annotations;\n      },\n      parsePropertyName_: function() {\n        if (peek(OPEN_SQUARE))\n          return this.parseComputedPropertyName_();\n        return this.parseLiteralPropertyName_();\n      },\n      parseLiteralPropertyName_: function() {\n        var start = this.getTreeStartLocation_();\n        var token = nextToken();\n        return new LiteralPropertyName(this.getTreeLocation_(start), token);\n      },\n      parseComputedPropertyName_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_SQUARE);\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new ComputedPropertyName(this.getTreeLocation_(start), expression);\n      },\n      parseStatement: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var result = this.parseModuleItem_(peekType());\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parseStatements: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var result = this.parseModuleItemList_();\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parseStatement_: function() {\n        return this.parseStatementWithType_(peekType());\n      },\n      parseStatementWithType_: function(type) {\n        switch (type) {\n          case RETURN:\n            return this.parseReturnStatement_();\n          case VAR:\n            return this.parseVariableStatement_();\n          case IF:\n            return this.parseIfStatement_();\n          case FOR:\n            return this.parseForStatement_();\n          case BREAK:\n            return this.parseBreakStatement_();\n          case SWITCH:\n            return this.parseSwitchStatement_();\n          case THROW:\n            return this.parseThrowStatement_();\n          case WHILE:\n            return this.parseWhileStatement_();\n          case AT:\n            if (this.options_.annotations)\n              return this.parseAnnotatedDeclarations_(false);\n            break;\n          case CONTINUE:\n            return this.parseContinueStatement_();\n          case DEBUGGER:\n            return this.parseDebuggerStatement_();\n          case DO:\n            return this.parseDoWhileStatement_();\n          case OPEN_CURLY:\n            return this.parseBlock_();\n          case SEMI_COLON:\n            return this.parseEmptyStatement_();\n          case TRY:\n            return this.parseTryStatement_();\n          case WITH:\n            return this.parseWithStatement_();\n          case INTERFACE:\n            if (this.options_.types) {\n              return this.parseInterfaceDeclaration_();\n            }\n        }\n        return this.parseFallThroughStatement_();\n      },\n      parseFunctionDeclaration_: function() {\n        return this.parseFunction_(FunctionDeclaration);\n      },\n      parseFunctionExpression_: function() {\n        return this.parseFunction_(FunctionExpression);\n      },\n      parseAsyncFunctionDeclaration_: function(asyncToken) {\n        return this.parseAsyncFunction_(asyncToken, FunctionDeclaration);\n      },\n      parseAsyncFunctionExpression_: function(asyncToken) {\n        return this.parseAsyncFunction_(asyncToken, FunctionExpression);\n      },\n      peekAsyncStar_: function() {\n        return this.options_.asyncGenerators && peek(STAR);\n      },\n      parseAsyncFunction_: function(asyncToken, ctor) {\n        var start = asyncToken.location.start;\n        this.eat_(FUNCTION);\n        var kind = FUNCTION_STATE_FUNCTION | FUNCTION_STATE_ASYNC;\n        if (this.peekAsyncStar_()) {\n          kind |= FUNCTION_STATE_GENERATOR;\n          this.eat_(STAR);\n          asyncToken = new IdentifierToken(asyncToken.location, ASYNC_STAR);\n        }\n        var fs = this.pushFunctionState_(kind);\n        var f = this.parseFunction2_(start, asyncToken, ctor);\n        this.popFunctionState_(fs);\n        return f;\n      },\n      parseFunction_: function(ctor) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FUNCTION);\n        var functionKind = null;\n        var kind = FUNCTION_STATE_FUNCTION;\n        if (this.options_.generators && peek(STAR)) {\n          functionKind = this.eat_(STAR);\n          kind |= FUNCTION_STATE_GENERATOR;\n        }\n        var fs = this.pushFunctionState_(kind);\n        var f = this.parseFunction2_(start, functionKind, ctor);\n        this.popFunctionState_(fs);\n        return f;\n      },\n      parseFunction2_: function(start, functionKind, ctor) {\n        var name = null;\n        var annotations = [];\n        if (ctor === FunctionDeclaration || this.peekBindingIdentifier_(peekType())) {\n          name = this.parseBindingIdentifier_();\n          annotations = this.popAnnotations_();\n        }\n        this.eat_(OPEN_PAREN);\n        var parameters = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(parameters);\n        return new ctor(this.getTreeLocation_(start), name, functionKind, parameters, typeAnnotation, annotations, body);\n      },\n      peekRest_: function(type) {\n        return type === DOT_DOT_DOT && this.options_.restParameters;\n      },\n      parseFormalParameters_: function() {\n        var start = this.getTreeStartLocation_();\n        var formals = [];\n        this.pushAnnotations_();\n        var type = peekType();\n        if (this.peekRest_(type)) {\n          formals.push(this.parseFormalRestParameter_());\n        } else {\n          if (this.peekFormalParameter_(peekType()))\n            formals.push(this.parseFormalParameter_(INITIALIZER_OPTIONAL));\n          while (this.eatIf_(COMMA)) {\n            this.pushAnnotations_();\n            if (this.peekRest_(peekType())) {\n              formals.push(this.parseFormalRestParameter_());\n              break;\n            }\n            formals.push(this.parseFormalParameter_(INITIALIZER_OPTIONAL));\n          }\n        }\n        return new FormalParameterList(this.getTreeLocation_(start), formals);\n      },\n      peekFormalParameter_: function(type) {\n        return this.peekBindingElement_(type);\n      },\n      parseFormalParameter_: function(initializerAllowed) {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingElementBinding_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var initializer = this.parseBindingElementInitializer_(initializerAllowed);\n        return new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, initializer), typeAnnotation, this.popAnnotations_());\n      },\n      parseFormalRestParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        var restParameter = this.parseRestParameter_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new FormalParameter(this.getTreeLocation_(start), restParameter, typeAnnotation, this.popAnnotations_());\n      },\n      parseRestParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var id = this.parseBindingIdentifier_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new RestParameter(this.getTreeLocation_(start), id, typeAnnotation);\n      },\n      parseFunctionBody_: function(params) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var strictMode = this.strictMode_;\n        var result = this.parseStatementList_(!strictMode);\n        validateParameters(params, this.strictMode_, this.errorReporter_);\n        this.strictMode_ = strictMode;\n        this.eat_(CLOSE_CURLY);\n        return new FunctionBody(this.getTreeLocation_(start), result);\n      },\n      parseSpreadExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var operand = this.parseAssignmentExpression_(ALLOW_IN);\n        return new SpreadExpression(this.getTreeLocation_(start), operand);\n      },\n      parseBlock_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_CURLY);\n        var result = this.parseStatementList_(false);\n        this.eat_(CLOSE_CURLY);\n        return new Block(this.getTreeLocation_(start), result);\n      },\n      parseVariableStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var declarations = this.parseVariableDeclarationList_(ALLOW_IN, INITIALIZER_REQUIRED);\n        this.checkInitializers_(declarations);\n        this.eatPossibleImplicitSemiColon_();\n        return new VariableStatement(this.getTreeLocation_(start), declarations);\n      },\n      parseVariableDeclarationList_: function(allowIn, initializerRequired) {\n        var type = peekType();\n        switch (type) {\n          case CONST:\n          case LET:\n          case VAR:\n            nextToken();\n            break;\n          default:\n            throw Error('unreachable');\n        }\n        var start = this.getTreeStartLocation_();\n        var declarations = [];\n        declarations.push(this.parseVariableDeclaration_(type, allowIn, initializerRequired));\n        while (this.eatIf_(COMMA)) {\n          declarations.push(this.parseVariableDeclaration_(type, allowIn, initializerRequired));\n        }\n        return new VariableDeclarationList(this.getTreeLocation_(start), type, declarations);\n      },\n      parseVariableDeclaration_: function(binding, noIn, initializerRequired) {\n        var initRequired = initializerRequired !== INITIALIZER_OPTIONAL;\n        var start = this.getTreeStartLocation_();\n        var lvalue;\n        var typeAnnotation;\n        if (this.peekPattern_(peekType())) {\n          lvalue = this.parseBindingPattern_();\n          typeAnnotation = null;\n        } else {\n          lvalue = this.parseBindingIdentifier_();\n          typeAnnotation = this.parseTypeAnnotationOpt_();\n        }\n        var init = null;\n        if (peek(EQUAL)) {\n          init = this.parseInitializer_(noIn);\n        } else if (lvalue.isPattern() && initRequired) {\n          this.reportError_(lvalue.location, 'destructuring must have an initializer');\n        }\n        return new VariableDeclaration(this.getTreeLocation_(start), lvalue, typeAnnotation, init);\n      },\n      parseInitializer_: function(allowIn) {\n        this.eat_(EQUAL);\n        return this.parseAssignmentExpression_(allowIn);\n      },\n      parseInitializerOpt_: function(allowIn) {\n        if (this.eatIf_(EQUAL))\n          return this.parseAssignmentExpression_(allowIn);\n        return null;\n      },\n      parseEmptyStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(SEMI_COLON);\n        return new EmptyStatement(this.getTreeLocation_(start));\n      },\n      parseFallThroughStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression;\n        switch (peekType()) {\n          case OPEN_CURLY:\n            return this.parseUnexpectedToken_();\n          case FUNCTION:\n          case CLASS:\n            return this.parseUnexpectedReservedWord_(peekToken());\n          case LET:\n            {\n              var token = peekLookahead(OPEN_SQUARE);\n              if (token) {\n                return this.parseSyntaxError_(\"A statement cannot start with 'let ['\");\n              }\n            }\n        }\n        if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC) && peekLookahead(FUNCTION)) {\n          var asyncToken = this.eatId_();\n          var functionToken = peekTokenNoLineTerminator();\n          if (functionToken !== null)\n            return this.parseAsyncFunctionDeclaration_(asyncToken);\n          expression = new IdentifierExpression(this.getTreeLocation_(start), asyncToken);\n        } else {\n          expression = this.parseExpression_(ALLOW_IN);\n        }\n        if (expression.type === IDENTIFIER_EXPRESSION) {\n          if (this.eatIf_(COLON)) {\n            var nameToken = expression.identifierToken;\n            var statement = this.parseStatement_();\n            return new LabelledStatement(this.getTreeLocation_(start), nameToken, statement);\n          }\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ExpressionStatement(this.getTreeLocation_(start), expression);\n      },\n      parseIfStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IF);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var ifClause = this.parseStatement_();\n        var elseClause = null;\n        if (this.eatIf_(ELSE)) {\n          elseClause = this.parseStatement_();\n        }\n        return new IfStatement(this.getTreeLocation_(start), condition, ifClause, elseClause);\n      },\n      parseDoWhileStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DO);\n        var body = this.parseStatement_();\n        this.eat_(WHILE);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        this.eatPossibleImplicitSemiColon_();\n        return new DoWhileStatement(this.getTreeLocation_(start), body, condition);\n      },\n      parseWhileStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(WHILE);\n        this.eat_(OPEN_PAREN);\n        var condition = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new WhileStatement(this.getTreeLocation_(start), condition, body);\n      },\n      parseForStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FOR);\n        this.eat_(OPEN_PAREN);\n        var type = peekType();\n        if (this.peekVariableDeclarationList_(type)) {\n          var variables = this.parseVariableDeclarationList_(NO_IN, INITIALIZER_OPTIONAL);\n          var declarations = variables.declarations;\n          if (declarations.length > 1 || containsInitializer(declarations)) {\n            return this.parseForStatement2_(start, variables);\n          }\n          type = peekType();\n          if (type === IN) {\n            return this.parseForInStatement_(start, variables);\n          } else if (this.peekOf_()) {\n            return this.parseForOfStatement_(start, variables);\n          } else if (this.allowForOn_ && this.peekOn_()) {\n            return this.parseForOnStatement_(start, variables);\n          } else {\n            this.checkInitializers_(variables);\n            return this.parseForStatement2_(start, variables);\n          }\n        }\n        if (type === SEMI_COLON) {\n          return this.parseForStatement2_(start, null);\n        }\n        var coverInitializedNameCount = this.coverInitializedNameCount_;\n        var initializer = this.parseExpressionAllowPattern_(NO_IN);\n        type = peekType();\n        if ((type === IN || this.peekOf_() || this.allowForOn_ && this.peekOn_())) {\n          initializer = this.transformLeftHandSideExpression_(initializer);\n          this.validateAssignmentTarget_(initializer, 'assignment');\n          if (this.peekOf_()) {\n            return this.parseForOfStatement_(start, initializer);\n          } else if (this.allowForOn_ && this.peekOn_()) {\n            return this.parseForOnStatement_(start, initializer);\n          }\n          return this.parseForInStatement_(start, initializer);\n        }\n        this.ensureNoCoverInitializedNames_(initializer, coverInitializedNameCount);\n        return this.parseForStatement2_(start, initializer);\n      },\n      peekOf_: function() {\n        return this.options_.forOf && this.peekPredefinedString_(OF);\n      },\n      peekOn_: function() {\n        return this.options_.forOn && this.peekPredefinedString_(ON);\n      },\n      parseForOfStatement_: function(start, initializer) {\n        this.eatId_();\n        var collection = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForOfStatement(this.getTreeLocation_(start), initializer, collection, body);\n      },\n      parseForOnStatement_: function(start, initializer) {\n        this.eatId_();\n        var observable = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForOnStatement(this.getTreeLocation_(start), initializer, observable, body);\n      },\n      checkInitializers_: function(variables) {\n        if (this.options_.blockBinding && variables.declarationType === CONST) {\n          var type = variables.declarationType;\n          for (var i = 0; i < variables.declarations.length; i++) {\n            if (!this.checkInitializer_(type, variables.declarations[i])) {\n              break;\n            }\n          }\n        }\n      },\n      checkInitializer_: function(type, declaration) {\n        if (this.options_.blockBinding && type === CONST && declaration.initializer === null) {\n          this.reportError_(declaration.location, 'const variables must have an initializer');\n          return false;\n        }\n        return true;\n      },\n      peekVariableDeclarationList_: function(type) {\n        switch (type) {\n          case VAR:\n            return true;\n          case CONST:\n          case LET:\n            return this.options_.blockBinding;\n          default:\n            return false;\n        }\n      },\n      parseForStatement2_: function(start, initializer) {\n        this.eat_(SEMI_COLON);\n        var condition = null;\n        if (!peek(SEMI_COLON)) {\n          condition = this.parseExpression_(ALLOW_IN);\n        }\n        this.eat_(SEMI_COLON);\n        var increment = null;\n        if (!peek(CLOSE_PAREN)) {\n          increment = this.parseExpression_(ALLOW_IN);\n        }\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForStatement(this.getTreeLocation_(start), initializer, condition, increment, body);\n      },\n      parseForInStatement_: function(start, initializer) {\n        this.eat_(IN);\n        var collection = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new ForInStatement(this.getTreeLocation_(start), initializer, collection, body);\n      },\n      parseContinueStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(CONTINUE);\n        var name = null;\n        if (!this.peekImplicitSemiColon_()) {\n          name = this.eatIdOpt_();\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ContinueStatement(this.getTreeLocation_(start), name);\n      },\n      parseBreakStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(BREAK);\n        var name = null;\n        if (!this.peekImplicitSemiColon_()) {\n          name = this.eatIdOpt_();\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new BreakStatement(this.getTreeLocation_(start), name);\n      },\n      parseReturnStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var returnToken = this.eat_(RETURN);\n        if (this.functionState_.isTopMost()) {\n          this.reportError_(returnToken.location, 'Illegal return statement');\n        }\n        var expression = null;\n        if (!this.peekImplicitSemiColon_()) {\n          expression = this.parseExpression_(ALLOW_IN);\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ReturnStatement(this.getTreeLocation_(start), expression);\n      },\n      parseYieldExpression_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        this.eat_(YIELD);\n        var expression = null;\n        var isYieldFor = false;\n        var token = peekTokenNoLineTerminator();\n        if (token !== null) {\n          switch (token.type) {\n            case CLOSE_CURLY:\n            case CLOSE_PAREN:\n            case CLOSE_SQUARE:\n            case COLON:\n            case COMMA:\n            case END_OF_FILE:\n            case SEMI_COLON:\n              break;\n            default:\n              isYieldFor = this.eatIf_(STAR);\n              expression = this.parseAssignmentExpression_(allowIn);\n          }\n        }\n        return new YieldExpression(this.getTreeLocation_(start), expression, isYieldFor);\n      },\n      parseWithStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        var withToken = this.eat_(WITH);\n        if (this.strictMode_) {\n          this.reportError_(withToken.location, 'Strict mode code may not include a with statement');\n        }\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseStatement_();\n        return new WithStatement(this.getTreeLocation_(start), expression, body);\n      },\n      parseSwitchStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(SWITCH);\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        this.eat_(OPEN_CURLY);\n        var caseClauses = this.parseCaseClauses_();\n        this.eat_(CLOSE_CURLY);\n        return new SwitchStatement(this.getTreeLocation_(start), expression, caseClauses);\n      },\n      parseCaseClauses_: function() {\n        var foundDefaultClause = false;\n        var result = [];\n        while (true) {\n          var start = this.getTreeStartLocation_();\n          switch (peekType()) {\n            case CASE:\n              {\n                nextToken();\n                var expression = this.parseExpression_(ALLOW_IN);\n                this.eat_(COLON);\n                var statements = this.parseCaseStatementsOpt_();\n                result.push(new CaseClause(this.getTreeLocation_(start), expression, statements));\n                break;\n              }\n            case DEFAULT:\n              {\n                var defaultToken = nextToken();\n                if (foundDefaultClause) {\n                  this.reportError_(defaultToken.location, 'Switch statements may have at most one \\'default\\' clause');\n                } else {\n                  foundDefaultClause = true;\n                }\n                this.eat_(COLON);\n                result.push(new DefaultClause(this.getTreeLocation_(start), this.parseCaseStatementsOpt_()));\n                break;\n              }\n            default:\n              return result;\n          }\n        }\n      },\n      parseCaseStatementsOpt_: function() {\n        var result = [];\n        var type;\n        while (true) {\n          switch (type = peekType()) {\n            case CASE:\n            case DEFAULT:\n            case CLOSE_CURLY:\n            case END_OF_FILE:\n              return result;\n          }\n          result.push(this.parseStatementListItem_(type));\n        }\n      },\n      parseThrowStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(THROW);\n        var value = null;\n        if (!this.peekImplicitSemiColon_()) {\n          value = this.parseExpression_(ALLOW_IN);\n        }\n        this.eatPossibleImplicitSemiColon_();\n        return new ThrowStatement(this.getTreeLocation_(start), value);\n      },\n      parseTryStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(TRY);\n        var body = this.parseBlock_();\n        var catchBlock = null;\n        if (peek(CATCH)) {\n          catchBlock = this.parseCatch_();\n        }\n        var finallyBlock = null;\n        if (peek(FINALLY)) {\n          finallyBlock = this.parseFinallyBlock_();\n        }\n        if (catchBlock === null && finallyBlock === null) {\n          var token = peekToken();\n          this.reportError_(token.location, \"'catch' or 'finally' expected.\");\n        }\n        return new TryStatement(this.getTreeLocation_(start), body, catchBlock, finallyBlock);\n      },\n      parseCatch_: function() {\n        var start = this.getTreeStartLocation_();\n        var catchBlock;\n        this.eat_(CATCH);\n        this.eat_(OPEN_PAREN);\n        var binding;\n        if (this.peekPattern_(peekType()))\n          binding = this.parseBindingPattern_();\n        else\n          binding = this.parseBindingIdentifier_();\n        this.eat_(CLOSE_PAREN);\n        var catchBody = this.parseBlock_();\n        catchBlock = new Catch(this.getTreeLocation_(start), binding, catchBody);\n        return catchBlock;\n      },\n      parseFinallyBlock_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FINALLY);\n        var finallyBlock = this.parseBlock_();\n        return new Finally(this.getTreeLocation_(start), finallyBlock);\n      },\n      parseDebuggerStatement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DEBUGGER);\n        this.eatPossibleImplicitSemiColon_();\n        return new DebuggerStatement(this.getTreeLocation_(start));\n      },\n      parsePrimaryExpression_: function() {\n        switch (peekType()) {\n          case CLASS:\n            return this.options_.classes ? this.parseClassExpression_() : this.parseUnexpectedReservedWord_(peekToken());\n          case THIS:\n            return this.parseThisExpression_();\n          case IDENTIFIER:\n            {\n              var identifier = this.parseIdentifierExpression_();\n              if (this.options_.asyncFunctions && identifier.identifierToken.value === ASYNC) {\n                var token$__6 = peekTokenNoLineTerminator();\n                if (token$__6 && token$__6.type === FUNCTION) {\n                  var asyncToken = identifier.identifierToken;\n                  return this.parseAsyncFunctionExpression_(asyncToken);\n                }\n              }\n              return identifier;\n            }\n          case NUMBER:\n          case STRING:\n          case TRUE:\n          case FALSE:\n          case NULL:\n            return this.parseLiteralExpression_();\n          case OPEN_SQUARE:\n            return this.parseArrayLiteral_();\n          case OPEN_CURLY:\n            return this.parseObjectLiteral_();\n          case OPEN_PAREN:\n            return this.parsePrimaryExpressionStartingWithParen_();\n          case SLASH:\n          case SLASH_EQUAL:\n            return this.parseRegularExpressionLiteral_();\n          case NO_SUBSTITUTION_TEMPLATE:\n          case TEMPLATE_HEAD:\n            if (this.options_.templateLiterals) {\n              return this.parseTemplateLiteral_(null);\n            }\n            break;\n          case IMPLEMENTS:\n          case INTERFACE:\n          case PACKAGE:\n          case PRIVATE:\n          case PROTECTED:\n          case PUBLIC:\n          case STATIC:\n          case YIELD:\n            if (this.strictMode_) {\n              this.reportReservedIdentifier_(nextToken());\n            }\n            return this.parseIdentifierExpression_();\n          case OPEN_ANGLE:\n            if (this.options_.jsx) {\n              return this.parseJsxElement_();\n            }\n            break;\n          case END_OF_FILE:\n            return this.parseSyntaxError_('Unexpected end of input');\n        }\n        var token = peekToken();\n        if (token.isKeyword()) {\n          return this.parseUnexpectedReservedWord_(token);\n        }\n        return this.parseUnexpectedToken_(token);\n      },\n      parseSuperExpression_: function(isNew) {\n        var start = this.getTreeStartLocation_();\n        var fs = this.functionState_;\n        while (fs && fs.isArrowFunction()) {\n          fs = fs.outer;\n        }\n        var superToken = this.eat_(SUPER);\n        if (!fs || !fs.isMethod()) {\n          this.reportError_(superToken.location, 'super is only allowed in methods');\n        }\n        var operand = new SuperExpression(this.getTreeLocation_(start));\n        var type = peekType();\n        if (isNew) {\n          if (type === OPEN_SQUARE) {\n            return this.parseMemberLookupExpression_(start, operand);\n          }\n          return this.parseMemberExpression_(start, operand);\n        }\n        switch (type) {\n          case OPEN_SQUARE:\n            return this.parseMemberLookupExpression_(start, operand);\n          case PERIOD:\n            return this.parseMemberExpression_(start, operand);\n          case OPEN_PAREN:\n            {\n              var superCall = this.parseCallExpression_(start, operand);\n              if (!fs.isDerivedConstructor()) {\n                this.reportError_(superToken.location, 'super call is only allowed in derived constructor');\n              }\n              return superCall;\n            }\n        }\n        return this.parseUnexpectedToken_();\n      },\n      parseThisExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(THIS);\n        return new ThisExpression(this.getTreeLocation_(start));\n      },\n      peekBindingIdentifier_: function(type) {\n        return this.peekId_(type);\n      },\n      parseBindingIdentifier_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatId_();\n        return new BindingIdentifier(this.getTreeLocation_(start), identifier);\n      },\n      parseIdentifierExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatId_();\n        return new IdentifierExpression(this.getTreeLocation_(start), identifier);\n      },\n      parseIdentifierNameExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var identifier = this.eatIdName_();\n        return new IdentifierExpression(this.getTreeLocation_(start), identifier);\n      },\n      parseLiteralExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var literal = this.nextLiteralToken_();\n        return new LiteralExpression(this.getTreeLocation_(start), literal);\n      },\n      nextLiteralToken_: function() {\n        return nextToken();\n      },\n      parseRegularExpressionLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var literal = nextRegularExpressionLiteralToken();\n        return new LiteralExpression(this.getTreeLocation_(start), literal);\n      },\n      peekSpread_: function(type) {\n        return type === DOT_DOT_DOT && this.options_.spread;\n      },\n      parseArrayLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression;\n        var elements = [];\n        this.eat_(OPEN_SQUARE);\n        var type = peekType();\n        if (type === FOR && this.options_.arrayComprehension)\n          return this.parseArrayComprehension_(start);\n        while (true) {\n          type = peekType();\n          if (type === COMMA) {\n            expression = null;\n          } else if (this.peekSpread_(type)) {\n            expression = this.parseSpreadExpression_();\n          } else if (type === CLOSE_SQUARE || type === END_OF_FILE) {\n            break;\n          } else {\n            expression = this.parseAssignmentExpression_(ALLOW_IN);\n          }\n          elements.push(expression);\n          type = peekType();\n          if (type !== CLOSE_SQUARE)\n            this.eat_(COMMA);\n        }\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayLiteral(this.getTreeLocation_(start), elements);\n      },\n      parseArrayComprehension_: function(start) {\n        var list = this.parseComprehensionList_();\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayComprehension(this.getTreeLocation_(start), list, expression);\n      },\n      parseComprehensionList_: function() {\n        var list = [this.parseComprehensionFor_()];\n        while (true) {\n          var type = peekType();\n          switch (type) {\n            case FOR:\n              list.push(this.parseComprehensionFor_());\n              break;\n            case IF:\n              list.push(this.parseComprehensionIf_());\n              break;\n            default:\n              return list;\n          }\n        }\n      },\n      parseComprehensionFor_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(FOR);\n        this.eat_(OPEN_PAREN);\n        var left = this.parseForBinding_();\n        this.eatId_(OF);\n        var iterator = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new ComprehensionFor(this.getTreeLocation_(start), left, iterator);\n      },\n      parseComprehensionIf_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(IF);\n        this.eat_(OPEN_PAREN);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new ComprehensionIf(this.getTreeLocation_(start), expression);\n      },\n      parseObjectLiteral_: function() {\n        var start = this.getTreeStartLocation_();\n        var result = [];\n        this.eat_(OPEN_CURLY);\n        while (this.peekPropertyDefinition_(peekType())) {\n          var propertyDefinition = this.parsePropertyDefinition_();\n          result.push(propertyDefinition);\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectLiteral(this.getTreeLocation_(start), result);\n      },\n      parsePropertyDefinition: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_SCRIPT);\n        var result = this.parsePropertyDefinition_();\n        this.popFunctionState_(fs);\n        return result;\n      },\n      parsePropertyDefinition_: function() {\n        var start = this.getTreeStartLocation_();\n        var functionKind = null;\n        var isStatic = false;\n        if (this.options_.generators && this.options_.propertyMethods && peek(STAR)) {\n          var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR);\n          var m = this.parseGeneratorMethod_(start, isStatic, []);\n          this.popFunctionState_(fs);\n          return m;\n        }\n        if (this.options_.spreadProperties && peek(DOT_DOT_DOT)) {\n          return this.parseSpreadExpression_();\n        }\n        var token = peekToken();\n        var name = this.parsePropertyName_();\n        if (this.options_.propertyMethods && peek(OPEN_PAREN)) {\n          var fs$__7 = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n          var m$__8 = this.parseMethod_(start, isStatic, functionKind, name, []);\n          this.popFunctionState_(fs$__7);\n          return m$__8;\n        }\n        if (this.eatIf_(COLON)) {\n          var value = this.parseAssignmentExpression_(ALLOW_IN);\n          return new PropertyNameAssignment(this.getTreeLocation_(start), name, value);\n        }\n        var type = peekType();\n        if (name.type === LITERAL_PROPERTY_NAME) {\n          var nameLiteral = name.literalToken;\n          if (nameLiteral.value === GET && this.peekPropertyName_(type)) {\n            return this.parseGetAccessor_(start, isStatic, []);\n          }\n          if (nameLiteral.value === SET && this.peekPropertyName_(type)) {\n            return this.parseSetAccessor_(start, isStatic, []);\n          }\n          if (this.options_.asyncFunctions && nameLiteral.value === ASYNC && (this.peekPropertyName_(type) || this.peekAsyncStar_())) {\n            var async = nameLiteral;\n            var kind = FUNCTION_STATE_METHOD | FUNCTION_STATE_ASYNC;\n            if (this.peekAsyncStar_()) {\n              kind |= FUNCTION_STATE_GENERATOR;\n              this.eat_(STAR);\n              async = new IdentifierToken(async.location, ASYNC_STAR);\n            }\n            var name$__9 = this.parsePropertyName_();\n            var fs$__10 = this.pushFunctionState_(kind);\n            var m$__11 = this.parseMethod_(start, isStatic, async, name$__9, []);\n            this.popFunctionState_(fs$__10);\n            return m$__11;\n          }\n          if (this.options_.propertyNameShorthand && (nameLiteral.type === IDENTIFIER || nameLiteral.isStrictKeyword() && !this.strictMode_ || nameLiteral.type === YIELD && this.allowYield_)) {\n            if (peek(EQUAL)) {\n              token = nextToken();\n              var coverInitializedNameCount = this.coverInitializedNameCount_;\n              var expr = this.parseAssignmentExpression_(ALLOW_IN);\n              this.ensureNoCoverInitializedNames_(expr, coverInitializedNameCount);\n              this.coverInitializedNameCount_++;\n              return new CoverInitializedName(this.getTreeLocation_(start), nameLiteral, token, expr);\n            }\n            return new PropertyNameShorthand(this.getTreeLocation_(start), nameLiteral);\n          }\n          if (this.strictMode_ && nameLiteral.isStrictKeyword())\n            this.reportReservedIdentifier_(nameLiteral);\n        }\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          token = peekToken();\n        return this.parseUnexpectedToken_(token);\n      },\n      parseClassElement_: function(derivedClass) {\n        var start = this.getTreeStartLocation_();\n        var annotations = this.parseAnnotations_();\n        var type = peekType();\n        var isStatic = false,\n            functionKind = null;\n        switch (type) {\n          case STATIC:\n            {\n              var staticToken = nextToken();\n              type = peekType();\n              switch (type) {\n                case OPEN_PAREN:\n                  {\n                    var location = this.getTreeLocation_(start);\n                    var name = new LiteralPropertyName(location, staticToken);\n                    var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n                    var m = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n                    this.popFunctionState_(fs);\n                    return m;\n                  }\n                default:\n                  isStatic = true;\n                  if (type === STAR && this.options_.generators)\n                    return this.parseGeneratorMethod_(start, true, annotations);\n                  return this.parseClassElement2_(start, isStatic, annotations, derivedClass);\n              }\n              break;\n            }\n          case STAR:\n            return this.parseGeneratorMethod_(start, isStatic, annotations);\n          default:\n            return this.parseClassElement2_(start, isStatic, annotations, derivedClass);\n        }\n      },\n      parseGeneratorMethod_: function(start, isStatic, annotations) {\n        var functionKind = this.eat_(STAR);\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD | FUNCTION_STATE_GENERATOR);\n        var m = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n        this.popFunctionState_(fs);\n        return m;\n      },\n      parseMethod_: function(start, isStatic, functionKind, name, annotations) {\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(parameterList);\n        return new Method(this.getTreeLocation_(start), isStatic, functionKind, name, parameterList, typeAnnotation, annotations, body, null);\n      },\n      parsePropertyVariableDeclaration_: function(start, isStatic, name, annotations) {\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        this.eat_(SEMI_COLON);\n        return new PropertyVariableDeclaration(this.getTreeLocation_(start), isStatic, name, typeAnnotation, annotations, initializer);\n      },\n      parseClassElement2_: function(start, isStatic, annotations, derivedClass) {\n        var functionKind = null;\n        var name = this.parsePropertyName_();\n        var type = peekType();\n        if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === GET && this.peekPropertyName_(type)) {\n          return this.parseGetAccessor_(start, isStatic, annotations);\n        }\n        if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === SET && this.peekPropertyName_(type)) {\n          return this.parseSetAccessor_(start, isStatic, annotations);\n        }\n        if (this.options_.asyncFunctions && name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === ASYNC && (this.peekPropertyName_(type) || this.peekAsyncStar_())) {\n          var async = name.literalToken;\n          var kind = FUNCTION_STATE_METHOD | FUNCTION_STATE_ASYNC;\n          if (this.peekAsyncStar_()) {\n            kind |= FUNCTION_STATE_GENERATOR;\n            this.eat_(STAR);\n            async = new IdentifierToken(async.location, ASYNC_STAR);\n          }\n          name = this.parsePropertyName_();\n          var fs = this.pushFunctionState_(kind);\n          var m = this.parseMethod_(start, isStatic, async, name, annotations);\n          this.popFunctionState_(fs);\n          return m;\n        }\n        if (!this.options_.memberVariables || type === OPEN_PAREN) {\n          var kind$__12 = FUNCTION_STATE_METHOD;\n          var isDerivedConstructor = derivedClass && !isStatic && functionKind === null && name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === CONSTRUCTOR;\n          if (isDerivedConstructor) {\n            kind$__12 |= FUNCTION_STATE_DERIVED_CONSTRUCTOR;\n          }\n          var fs$__13 = this.pushFunctionState_(kind$__12);\n          var m$__14 = this.parseMethod_(start, isStatic, functionKind, name, annotations);\n          this.popFunctionState_(fs$__13);\n          if (isDerivedConstructor) {\n            validateConstructor(m$__14, this.errorReporter_);\n          }\n          return m$__14;\n        }\n        return this.parsePropertyVariableDeclaration_(start, isStatic, name, annotations);\n      },\n      parseGetAccessor_: function(start, isStatic, annotations) {\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n        this.eat_(OPEN_PAREN);\n        this.eat_(CLOSE_PAREN);\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var body = this.parseFunctionBody_(null);\n        this.popFunctionState_(fs);\n        return new GetAccessor(this.getTreeLocation_(start), isStatic, name, typeAnnotation, annotations, body);\n      },\n      parseSetAccessor_: function(start, isStatic, annotations) {\n        var name = this.parsePropertyName_();\n        var fs = this.pushFunctionState_(FUNCTION_STATE_METHOD);\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parsePropertySetParameterList_();\n        this.eat_(CLOSE_PAREN);\n        var body = this.parseFunctionBody_(parameterList);\n        this.popFunctionState_(fs);\n        return new SetAccessor(this.getTreeLocation_(start), isStatic, name, parameterList, annotations, body);\n      },\n      peekPropertyDefinition_: function(type) {\n        return this.peekPropertyName_(type) || type === STAR && this.options_.propertyMethods && this.options_.generators || type === DOT_DOT_DOT && this.options_.spreadProperties;\n      },\n      peekPropertyName_: function(type) {\n        switch (type) {\n          case IDENTIFIER:\n          case STRING:\n          case NUMBER:\n            return true;\n          case OPEN_SQUARE:\n            return this.options_.computedPropertyNames;\n          default:\n            return peekToken().isKeyword();\n        }\n      },\n      peekPredefinedString_: function(string) {\n        var token = peekToken();\n        return token.type === IDENTIFIER && token.value === string;\n      },\n      parsePropertySetParameterList_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding;\n        this.pushAnnotations_();\n        if (this.peekPattern_(peekType()))\n          binding = this.parseBindingPattern_();\n        else\n          binding = this.parseBindingIdentifier_();\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        var parameter = new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, null), typeAnnotation, this.popAnnotations_());\n        return new FormalParameterList(parameter.location, [parameter]);\n      },\n      parsePrimaryExpressionStartingWithParen_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_PAREN);\n        if (peek(FOR) && this.options_.generatorComprehension)\n          return this.parseGeneratorComprehension_(start);\n        return this.parseCoverFormals_(start);\n      },\n      parseSyntaxError_: function(message) {\n        var token = nextToken();\n        this.reportError_(token.location, message);\n        return new SyntaxErrorTree(token.location, token, message);\n      },\n      parseUnexpectedToken_: function() {\n        var token = arguments[0] !== (void 0) ? arguments[0] : peekToken();\n        if (token.type === NO_SUBSTITUTION_TEMPLATE) {\n          return this.parseSyntaxError_('Unexpected token `');\n        }\n        return this.parseSyntaxError_((\"Unexpected token \" + token));\n      },\n      parseUnexpectedReservedWord_: function(token) {\n        return this.parseSyntaxError_((\"Unexpected reserved word \" + token));\n      },\n      parseExpression_: function(allowIn) {\n        var coverInitializedNameCount = this.coverInitializedNameCount_;\n        var expression = this.parseExpressionAllowPattern_(allowIn);\n        this.ensureNoCoverInitializedNames_(expression, coverInitializedNameCount);\n        return expression;\n      },\n      parseExpression: function() {\n        var fs = this.pushFunctionState_(FUNCTION_STATE_LENIENT);\n        var expression = this.parseExpression_(ALLOW_IN);\n        this.popFunctionState_(fs);\n        return expression;\n      },\n      parseExpressionAllowPattern_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var expression = this.parseAssignmentExpression_(allowIn);\n        if (peek(COMMA)) {\n          var expressions = [expression];\n          while (this.eatIf_(COMMA)) {\n            expressions.push(this.parseAssignmentExpression_(allowIn));\n          }\n          return new CommaExpression(this.getTreeLocation_(start), expressions);\n        }\n        return expression;\n      },\n      parseAssignmentExpression_: function(allowIn) {\n        if (this.allowYield_ && peek(YIELD))\n          return this.parseYieldExpression_(allowIn);\n        var start = this.getTreeStartLocation_();\n        var validAsyncParen = false;\n        if (this.options_.asyncFunctions && this.peekPredefinedString_(ASYNC)) {\n          var asyncToken = peekToken();\n          var maybeOpenParenToken = peekTokenLookahead();\n          validAsyncParen = maybeOpenParenToken.type === OPEN_PAREN && asyncToken.location.end.line === maybeOpenParenToken.location.start.line;\n        }\n        var left = this.parseConditional_(allowIn);\n        var type = peekType();\n        if (this.options_.asyncFunctions && left.type === IDENTIFIER_EXPRESSION && left.identifierToken.value === ASYNC && type === IDENTIFIER) {\n          if (peekTokenNoLineTerminator() !== null) {\n            var bindingIdentifier = this.parseBindingIdentifier_();\n            var asyncToken$__15 = left.identifierToken;\n            return this.parseArrowFunction_(start, bindingIdentifier, asyncToken$__15);\n          }\n        }\n        if (type === ARROW && peekTokenNoLineTerminator() !== null) {\n          if (left.type === COVER_FORMALS || left.type === IDENTIFIER_EXPRESSION)\n            return this.parseArrowFunction_(start, left, null);\n          if (validAsyncParen && left.type === CALL_EXPRESSION) {\n            var asyncToken$__16 = left.operand.identifierToken;\n            return this.parseArrowFunction_(start, left.args, asyncToken$__16);\n          }\n        }\n        left = this.coverFormalsToParenExpression_(left);\n        if (this.peekAssignmentOperator_(type)) {\n          if (type === EQUAL)\n            left = this.transformLeftHandSideExpression_(left);\n          this.validateAssignmentTarget_(left, 'assignment');\n          var operator = nextToken();\n          var right = this.parseAssignmentExpression_(allowIn);\n          return new BinaryExpression(this.getTreeLocation_(start), left, operator, right);\n        }\n        return left;\n      },\n      transformLeftHandSideExpression_: function(tree) {\n        switch (tree.type) {\n          case ARRAY_LITERAL:\n          case OBJECT_LITERAL:\n            resetScanner(tree.location.start.offset);\n            return this.parseAssignmentPattern_();\n        }\n        return tree;\n      },\n      peekAssignmentOperator_: function(type) {\n        return isAssignmentOperator(type);\n      },\n      parseConditional_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var condition = this.parseBinaryExpression_(allowIn);\n        if (this.eatIf_(QUESTION)) {\n          condition = this.toPrimaryExpression_(condition);\n          var left = this.parseAssignmentExpression_(ALLOW_IN);\n          this.eat_(COLON);\n          var right = this.parseAssignmentExpression_(allowIn);\n          return new ConditionalExpression(this.getTreeLocation_(start), condition, left, right);\n        }\n        return condition;\n      },\n      getPrecedence_: function(type, allowIn) {\n        switch (type) {\n          case OR:\n            return 1;\n          case AND:\n            return 2;\n          case BAR:\n            return 3;\n          case CARET:\n            return 4;\n          case AMPERSAND:\n            return 5;\n          case EQUAL_EQUAL:\n          case EQUAL_EQUAL_EQUAL:\n          case NOT_EQUAL:\n          case NOT_EQUAL_EQUAL:\n            return 6;\n          case CLOSE_ANGLE:\n          case GREATER_EQUAL:\n          case INSTANCEOF:\n          case LESS_EQUAL:\n          case OPEN_ANGLE:\n            return 7;\n          case IN:\n            return allowIn ? 7 : 0;\n          case LEFT_SHIFT:\n          case RIGHT_SHIFT:\n          case UNSIGNED_RIGHT_SHIFT:\n            return 8;\n          case MINUS:\n          case PLUS:\n            return 9;\n          case SLASH:\n          case STAR:\n          case PERCENT:\n            return 10;\n          case STAR_STAR:\n            return this.options_.exponentiation ? 11 : 0;\n          default:\n            return 0;\n        }\n      },\n      parseBinaryExpression_: function(allowIn) {\n        var start = this.getTreeStartLocation_();\n        var left = this.parseUnaryExpression_();\n        return this.parseBinaryExpressionHelper_(start, left, -1, allowIn);\n      },\n      parseBinaryExpressionHelper_: function(start, left, minPrec, allowIn) {\n        var type = peekType();\n        var prec = this.getPrecedence_(type, allowIn);\n        if (prec === 0) {\n          return left;\n        }\n        var leftToRight = type !== STAR_STAR;\n        if (leftToRight ? prec > minPrec : prec >= minPrec) {\n          var token = nextToken();\n          var rightStart = this.getTreeStartLocation_();\n          var rightUnary = this.parseUnaryExpression_();\n          var right = this.parseBinaryExpressionHelper_(rightStart, rightUnary, prec, allowIn);\n          left = this.toPrimaryExpression_(left);\n          right = this.toPrimaryExpression_(right);\n          var node = new BinaryExpression(this.getTreeLocation_(start), left, token, right);\n          return this.parseBinaryExpressionHelper_(start, node, minPrec, allowIn);\n        }\n        return left;\n      },\n      parseUnaryExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        if (this.allowAwait_ && this.peekPredefinedString_(AWAIT)) {\n          this.eatId_();\n          var operand;\n          if (this.allowYield_ && peek(YIELD)) {\n            operand = this.parseYieldExpression_(ALLOW_IN);\n          } else {\n            operand = this.parseUnaryExpression_();\n            operand = this.toPrimaryExpression_(operand);\n          }\n          return new AwaitExpression(this.getTreeLocation_(start), operand);\n        }\n        if (this.peekUnaryOperator_(peekType())) {\n          var operator = nextToken();\n          var operand$__17 = this.parseUnaryExpression_();\n          operand$__17 = this.toPrimaryExpression_(operand$__17);\n          if (operand$__17.type !== SYNTAX_ERROR_TREE) {\n            switch (operator.type) {\n              case PLUS_PLUS:\n              case MINUS_MINUS:\n                this.validateAssignmentTarget_(operand$__17, 'prefix operation');\n            }\n          }\n          return new UnaryExpression(this.getTreeLocation_(start), operator, operand$__17);\n        }\n        return this.parsePostfixExpression_();\n      },\n      peekUnaryOperator_: function(type) {\n        switch (type) {\n          case DELETE:\n          case VOID:\n          case TYPEOF:\n          case PLUS_PLUS:\n          case MINUS_MINUS:\n          case PLUS:\n          case MINUS:\n          case TILDE:\n          case BANG:\n            return true;\n          default:\n            return false;\n        }\n      },\n      parsePostfixExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand = this.parseLeftHandSideExpression_();\n        while (this.peekPostfixOperator_(peekType())) {\n          operand = this.toPrimaryExpression_(operand);\n          var operator = nextToken();\n          this.validateAssignmentTarget_(operand, 'postfix operation');\n          operand = new PostfixExpression(this.getTreeLocation_(start), operand, operator);\n        }\n        return operand;\n      },\n      peekPostfixOperator_: function(type) {\n        switch (type) {\n          case PLUS_PLUS:\n          case MINUS_MINUS:\n            {\n              var token = peekTokenNoLineTerminator();\n              return token !== null;\n            }\n        }\n        return false;\n      },\n      parseLeftHandSideExpression_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand = this.parseNewExpression_();\n        if (!(operand instanceof NewExpression) || operand.args !== null) {\n          loop: while (true) {\n            switch (peekType()) {\n              case OPEN_PAREN:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseCallExpression_(start, operand);\n                break;\n              case OPEN_SQUARE:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseMemberLookupExpression_(start, operand);\n                break;\n              case PERIOD:\n                operand = this.toPrimaryExpression_(operand);\n                operand = this.parseMemberExpression_(start, operand);\n                break;\n              case NO_SUBSTITUTION_TEMPLATE:\n              case TEMPLATE_HEAD:\n                if (!this.options_.templateLiterals)\n                  break loop;\n                operand = this.toPrimaryExpression_(operand);\n                if (this.options_.templateLiterals) {\n                  operand = this.parseTemplateLiteral_(operand);\n                }\n                break;\n              default:\n                break loop;\n            }\n          }\n        }\n        return operand;\n      },\n      parseMemberExpressionNoNew_: function() {\n        var start = this.getTreeStartLocation_();\n        var operand;\n        if (peekType() === FUNCTION) {\n          operand = this.parseFunctionExpression_();\n        } else {\n          operand = this.parsePrimaryExpression_();\n        }\n        loop: while (true) {\n          switch (peekType()) {\n            case OPEN_SQUARE:\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseMemberLookupExpression_(start, operand);\n              break;\n            case PERIOD:\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseMemberExpression_(start, operand);\n              break;\n            case NO_SUBSTITUTION_TEMPLATE:\n            case TEMPLATE_HEAD:\n              if (!this.options_.templateLiterals)\n                break loop;\n              operand = this.toPrimaryExpression_(operand);\n              operand = this.parseTemplateLiteral_(operand);\n              break;\n            default:\n              break loop;\n          }\n        }\n        return operand;\n      },\n      parseMemberExpression_: function(start, operand) {\n        this.eat_(PERIOD);\n        var name = this.eatIdName_();\n        return new MemberExpression(this.getTreeLocation_(start), operand, name);\n      },\n      parseMemberLookupExpression_: function(start, operand) {\n        this.eat_(OPEN_SQUARE);\n        var member = this.parseExpression_(ALLOW_IN);\n        this.eat_(CLOSE_SQUARE);\n        return new MemberLookupExpression(this.getTreeLocation_(start), operand, member);\n      },\n      parseCallExpression_: function(start, operand) {\n        var args = this.parseArguments_();\n        return new CallExpression(this.getTreeLocation_(start), operand, args);\n      },\n      parseNewExpression_: function() {\n        var operand,\n            start;\n        switch (peekType()) {\n          case NEW:\n            {\n              start = this.getTreeStartLocation_();\n              this.eat_(NEW);\n              if (peek(SUPER)) {\n                operand = this.parseSuperExpression_(true);\n              } else {\n                operand = this.toPrimaryExpression_(this.parseNewExpression_());\n              }\n              var args = null;\n              if (peek(OPEN_PAREN)) {\n                args = this.parseArguments_();\n              }\n              return new NewExpression(this.getTreeLocation_(start), operand, args);\n            }\n          case SUPER:\n            return this.parseSuperExpression_(false);\n          default:\n            return this.parseMemberExpressionNoNew_();\n        }\n      },\n      parseArguments_: function() {\n        var start = this.getTreeStartLocation_();\n        var args = [];\n        this.eat_(OPEN_PAREN);\n        if (!peek(CLOSE_PAREN)) {\n          args.push(this.parseArgument_());\n          while (this.eatIf_(COMMA)) {\n            args.push(this.parseArgument_());\n          }\n        }\n        this.eat_(CLOSE_PAREN);\n        return new ArgumentList(this.getTreeLocation_(start), args);\n      },\n      parseArgument_: function() {\n        if (this.peekSpread_(peekType()))\n          return this.parseSpreadExpression_();\n        return this.parseAssignmentExpression_(ALLOW_IN);\n      },\n      parseArrowFunction_: function(start, tree, asyncToken) {\n        var $__3 = this;\n        var formals;\n        var kind = FUNCTION_STATE_ARROW;\n        if (asyncToken && asyncToken.value === ASYNC) {\n          kind |= FUNCTION_STATE_ASYNC;\n        }\n        var fs = this.pushFunctionState_(kind);\n        var makeFormals = function(tree) {\n          return new FormalParameterList($__3.getTreeLocation_(start), [new FormalParameter(tree.location, new BindingElement(tree.location, tree, null), null, [])]);\n        };\n        switch (tree.type) {\n          case IDENTIFIER_EXPRESSION:\n            formals = makeFormals(new BindingIdentifier(tree.location, tree.identifierToken));\n            break;\n          case BINDING_IDENTIFIER:\n            formals = makeFormals(tree);\n            break;\n          case FORMAL_PARAMETER_LIST:\n            formals = tree;\n            break;\n          default:\n            formals = this.toFormalParameters_(start, tree, asyncToken);\n        }\n        this.eat_(ARROW);\n        var body = this.parseConciseBody_(formals);\n        this.popFunctionState_(fs);\n        return new ArrowFunction(this.getTreeLocation_(start), asyncToken, formals, body);\n      },\n      parseCoverFormals_: function(start) {\n        var expressions = [];\n        if (!peek(CLOSE_PAREN)) {\n          do {\n            var type = peekType();\n            if (this.peekRest_(type)) {\n              expressions.push(this.parseRestParameter_());\n              break;\n            } else {\n              expressions.push(this.parseAssignmentExpression_(ALLOW_IN));\n            }\n            if (this.eatIf_(COMMA))\n              continue;\n          } while (!peek(CLOSE_PAREN) && !isAtEnd());\n        }\n        this.eat_(CLOSE_PAREN);\n        return new CoverFormals(this.getTreeLocation_(start), expressions);\n      },\n      ensureNoCoverInitializedNames_: function(tree, coverInitializedNameCount) {\n        if (coverInitializedNameCount === this.coverInitializedNameCount_)\n          return;\n        var finder = new ValidateObjectLiteral();\n        finder.visitAny(tree);\n        if (finder.found) {\n          var token = finder.errorToken;\n          this.reportError_(token.location, (\"Unexpected token \" + token));\n        }\n      },\n      toPrimaryExpression_: function(tree) {\n        if (tree.type === COVER_FORMALS)\n          return this.coverFormalsToParenExpression_(tree);\n        return tree;\n      },\n      validateCoverFormalsAsParenExpression_: function(tree) {\n        for (var i = 0; i < tree.expressions.length; i++) {\n          if (tree.expressions[i].type === REST_PARAMETER) {\n            var token = new Token(DOT_DOT_DOT, tree.expressions[i].location);\n            this.reportError_(token.location, (\"Unexpected token \" + token));\n            return;\n          }\n        }\n      },\n      coverFormalsToParenExpression_: function(tree) {\n        if (tree.type === COVER_FORMALS) {\n          var expressions = tree.expressions;\n          if (expressions.length === 0) {\n            var message = 'Unexpected token )';\n            this.reportError_(tree.location, message);\n          } else {\n            this.validateCoverFormalsAsParenExpression_(tree);\n            var expression;\n            if (expressions.length > 1)\n              expression = new CommaExpression(expressions[0].location, expressions);\n            else\n              expression = expressions[0];\n            return new ParenExpression(tree.location, expression);\n          }\n        }\n        return tree;\n      },\n      toFormalParameters_: function(start, tree, asyncToken) {\n        resetScanner(start.offset);\n        return this.parseArrowFormalParameters_(asyncToken);\n      },\n      parseArrowFormalParameters_: function(asyncToken) {\n        if (asyncToken)\n          this.eat_(IDENTIFIER);\n        this.eat_(OPEN_PAREN);\n        var parameters = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        return parameters;\n      },\n      peekArrow_: function(type) {\n        return type === ARROW && this.options_.arrowFunctions;\n      },\n      parseConciseBody_: function(params) {\n        if (peek(OPEN_CURLY))\n          return this.parseFunctionBody_(params);\n        validateParameters(params, this.strictMode_, this.errorReporter_);\n        return this.parseAssignmentExpression_(ALLOW_IN);\n      },\n      parseGeneratorComprehension_: function(start) {\n        var comprehensionList = this.parseComprehensionList_();\n        var expression = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eat_(CLOSE_PAREN);\n        return new GeneratorComprehension(this.getTreeLocation_(start), comprehensionList, expression);\n      },\n      parseForBinding_: function() {\n        if (this.peekPattern_(peekType()))\n          return this.parseBindingPattern_();\n        return this.parseBindingIdentifier_();\n      },\n      peekPattern_: function(type) {\n        return this.options_.destructuring && (this.peekObjectPattern_(type) || this.peekArrayPattern_(type));\n      },\n      peekArrayPattern_: function(type) {\n        return type === OPEN_SQUARE;\n      },\n      peekObjectPattern_: function(type) {\n        return type === OPEN_CURLY;\n      },\n      parseBindingPattern_: function() {\n        return this.parsePattern_(true);\n      },\n      parsePattern_: function(useBinding) {\n        if (this.peekArrayPattern_(peekType()))\n          return this.parseArrayPattern_(useBinding);\n        return this.parseObjectPattern_(useBinding);\n      },\n      parseArrayBindingPattern_: function() {\n        return this.parseArrayPattern_(true);\n      },\n      parsePatternElement_: function(useBinding) {\n        return useBinding ? this.parseBindingElement_() : this.parseAssignmentElement_();\n      },\n      parsePatternRestElement_: function(useBinding) {\n        return useBinding ? this.parseBindingRestElement_() : this.parseAssignmentRestElement_();\n      },\n      parseArrayPattern_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var elements = [];\n        this.eat_(OPEN_SQUARE);\n        while (true) {\n          var type = peekType();\n          if (type === COMMA) {\n            elements.push(null);\n          } else if (this.peekSpread_(type)) {\n            elements.push(this.parsePatternRestElement_(useBinding));\n            break;\n          } else if (type === CLOSE_SQUARE || type === END_OF_FILE) {\n            break;\n          } else {\n            elements.push(this.parsePatternElement_(useBinding));\n          }\n          type = peekType();\n          if (type !== CLOSE_SQUARE) {\n            this.eat_(COMMA);\n          }\n        }\n        this.eat_(CLOSE_SQUARE);\n        return new ArrayPattern(this.getTreeLocation_(start), elements);\n      },\n      parseBindingElementList_: function(elements) {\n        this.parseElisionOpt_(elements);\n        elements.push(this.parseBindingElement_());\n        while (this.eatIf_(COMMA)) {\n          this.parseElisionOpt_(elements);\n          elements.push(this.parseBindingElement_());\n        }\n      },\n      parseElisionOpt_: function(elements) {\n        while (this.eatIf_(COMMA)) {\n          elements.push(null);\n        }\n      },\n      peekBindingElement_: function(type) {\n        return this.peekBindingIdentifier_(type) || this.peekPattern_(type);\n      },\n      parseBindingElement_: function() {\n        var start = this.getTreeStartLocation_();\n        var binding = this.parseBindingElementBinding_();\n        var initializer = this.parseBindingElementInitializer_(INITIALIZER_OPTIONAL);\n        return new BindingElement(this.getTreeLocation_(start), binding, initializer);\n      },\n      parseBindingElementBinding_: function() {\n        if (this.peekPattern_(peekType()))\n          return this.parseBindingPattern_();\n        return this.parseBindingIdentifier_();\n      },\n      parseBindingElementInitializer_: function(initializerRequired) {\n        if (peek(EQUAL) || initializerRequired) {\n          return this.parseInitializer_(ALLOW_IN);\n        }\n        return null;\n      },\n      parseBindingRestElement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var identifier = this.parseBindingIdentifier_();\n        return new SpreadPatternElement(this.getTreeLocation_(start), identifier);\n      },\n      parseObjectPattern_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var elements = [];\n        this.eat_(OPEN_CURLY);\n        var type;\n        while ((type = peekType()) !== CLOSE_CURLY && type !== END_OF_FILE) {\n          elements.push(this.parsePatternProperty_(useBinding));\n          if (!this.eatIf_(COMMA))\n            break;\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectPattern(this.getTreeLocation_(start), elements);\n      },\n      parsePatternProperty_: function(useBinding) {\n        var start = this.getTreeStartLocation_();\n        var name = this.parsePropertyName_();\n        var requireColon = name.type !== LITERAL_PROPERTY_NAME || !name.literalToken.isStrictKeyword() && name.literalToken.type !== IDENTIFIER;\n        if (requireColon || peek(COLON)) {\n          this.eat_(COLON);\n          var element = this.parsePatternElement_(useBinding);\n          return new ObjectPatternField(this.getTreeLocation_(start), name, element);\n        }\n        var token = name.literalToken;\n        if (this.strictMode_ && token.isStrictKeyword())\n          this.reportReservedIdentifier_(token);\n        if (useBinding) {\n          var binding = new BindingIdentifier(name.location, token);\n          var initializer$__18 = this.parseInitializerOpt_(ALLOW_IN);\n          return new BindingElement(this.getTreeLocation_(start), binding, initializer$__18);\n        }\n        var assignment = new IdentifierExpression(name.location, token);\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        return new AssignmentElement(this.getTreeLocation_(start), assignment, initializer);\n      },\n      parseAssignmentPattern_: function() {\n        return this.parsePattern_(false);\n      },\n      parseArrayAssignmentPattern_: function() {\n        return this.parseArrayPattern_(false);\n      },\n      parseAssignmentElement_: function() {\n        var start = this.getTreeStartLocation_();\n        var assignment = this.parseDestructuringAssignmentTarget_();\n        var initializer = this.parseInitializerOpt_(ALLOW_IN);\n        return new AssignmentElement(this.getTreeLocation_(start), assignment, initializer);\n      },\n      parseDestructuringAssignmentTarget_: function() {\n        switch (peekType()) {\n          case OPEN_SQUARE:\n            return this.parseArrayAssignmentPattern_();\n          case OPEN_CURLY:\n            return this.parseObjectAssignmentPattern_();\n        }\n        var expression = this.parseLeftHandSideExpression_();\n        expression = this.coverFormalsToParenExpression_(expression);\n        this.validateAssignmentTarget_(expression, 'assignment');\n        return expression;\n      },\n      parseAssignmentRestElement_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(DOT_DOT_DOT);\n        var id = this.parseDestructuringAssignmentTarget_();\n        return new SpreadPatternElement(this.getTreeLocation_(start), id);\n      },\n      parseObjectAssignmentPattern_: function() {\n        return this.parseObjectPattern_(false);\n      },\n      parseAssignmentProperty_: function() {\n        return this.parsePatternProperty_(false);\n      },\n      parseTemplateLiteral_: function(operand) {\n        var start = operand ? operand.location.start : this.getTreeStartLocation_();\n        var token = nextToken();\n        var elements = [new TemplateLiteralPortion(token.location, token)];\n        if (token.type === NO_SUBSTITUTION_TEMPLATE) {\n          return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);\n        }\n        var expression = this.parseExpression_(ALLOW_IN);\n        elements.push(new TemplateSubstitution(expression.location, expression));\n        while (expression.type !== SYNTAX_ERROR_TREE) {\n          token = nextTemplateLiteralToken();\n          if (token.type === ERROR || token.type === END_OF_FILE)\n            break;\n          elements.push(new TemplateLiteralPortion(token.location, token));\n          if (token.type === TEMPLATE_TAIL)\n            break;\n          expression = this.parseExpression_(ALLOW_IN);\n          elements.push(new TemplateSubstitution(expression.location, expression));\n        }\n        return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);\n      },\n      parseTypeAnnotationOpt_: function() {\n        if (this.options_.types && this.eatOpt_(COLON)) {\n          return this.parseType_();\n        }\n        return null;\n      },\n      parseType_: function() {\n        switch (peekType()) {\n          case NEW:\n            return this.parseConstructorType_();\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n            return this.parseFunctionType_();\n        }\n        var start = this.getTreeStartLocation_();\n        var elementType = this.parsePrimaryType_();\n        return this.parseUnionTypeSuffix_(start, elementType);\n      },\n      parsePrimaryType_: function() {\n        var start = this.getTreeStartLocation_();\n        var elementType,\n            token;\n        switch (peekType()) {\n          case VOID:\n            token = nextToken();\n            elementType = new PredefinedType(this.getTreeLocation_(start), token);\n            break;\n          case IDENTIFIER:\n            switch (peekToken().value) {\n              case 'any':\n              case 'boolean':\n              case 'number':\n              case 'string':\n              case 'symbol':\n                token = nextToken();\n                elementType = new PredefinedType(this.getTreeLocation_(start), token);\n                break;\n              default:\n                elementType = this.parseTypeReference_();\n            }\n            break;\n          case TYPEOF:\n            elementType = this.parseTypeQuery_(start);\n            break;\n          case OPEN_CURLY:\n            elementType = this.parseObjectType_();\n            break;\n          default:\n            return this.parseUnexpectedToken_();\n        }\n        return this.parseArrayTypeSuffix_(start, elementType);\n      },\n      parseTypeReference_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeName = this.parseTypeName_();\n        var args = null;\n        if (peek(OPEN_ANGLE)) {\n          var args$__19 = this.parseTypeArguments_();\n          return new TypeReference(this.getTreeLocation_(start), typeName, args$__19);\n        }\n        return typeName;\n      },\n      parseUnionTypeSuffix_: function(start, elementType) {\n        if (peek(BAR)) {\n          var types = [elementType];\n          this.eat_(BAR);\n          while (true) {\n            types.push(this.parsePrimaryType_());\n            if (!this.eatIf_(BAR)) {\n              break;\n            }\n          }\n          return new UnionType(this.getTreeLocation_(start), types);\n        }\n        return elementType;\n      },\n      parseArrayTypeSuffix_: function(start, elementType) {\n        var token = peekTokenNoLineTerminator();\n        if (token && token.type === OPEN_SQUARE) {\n          this.eat_(OPEN_SQUARE);\n          this.eat_(CLOSE_SQUARE);\n          elementType = new ArrayType(this.getTreeLocation_(start), elementType);\n          return this.parseArrayTypeSuffix_(start, elementType);\n        }\n        return elementType;\n      },\n      parseTypeArguments_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_ANGLE);\n        var args = [this.parseType_()];\n        while (peek(COMMA)) {\n          this.eat_(COMMA);\n          args.push(this.parseType_());\n        }\n        var token = nextCloseAngle();\n        if (token.type !== CLOSE_ANGLE) {\n          return this.parseUnexpectedToken_(token);\n        }\n        return new TypeArguments(this.getTreeLocation_(start), args);\n      },\n      parseConstructorType_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(NEW);\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        this.eat_(ARROW);\n        var returnType = this.parseType_();\n        return new ConstructorType(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseObjectType_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeMembers = [];\n        this.eat_(OPEN_CURLY);\n        var type;\n        while (this.peekTypeMember_(type = peekType())) {\n          typeMembers.push(this.parseTypeMember_(type));\n          if (!this.eatIf_(SEMI_COLON)) {\n            break;\n          }\n        }\n        this.eat_(CLOSE_CURLY);\n        return new ObjectType(this.getTreeLocation_(start), typeMembers);\n      },\n      peekTypeMember_: function(type) {\n        switch (type) {\n          case NEW:\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n          case OPEN_SQUARE:\n          case IDENTIFIER:\n          case STRING:\n          case NUMBER:\n            return true;\n          default:\n            return peekToken().isKeyword();\n        }\n      },\n      parseTypeMember_: function(type) {\n        switch (type) {\n          case NEW:\n            return this.parseConstructSignature_();\n          case OPEN_PAREN:\n          case OPEN_ANGLE:\n            return this.parseCallSignature_();\n          case OPEN_SQUARE:\n            return this.parseIndexSignature_();\n        }\n        var start = this.getTreeStartLocation_();\n        var propertyName = this.parseLiteralPropertyName_();\n        var isOpt = this.eatIf_(QUESTION);\n        type = peekType();\n        if (type === OPEN_ANGLE || type === OPEN_PAREN) {\n          var callSignature = this.parseCallSignature_();\n          return new MethodSignature(this.getTreeLocation_(start), propertyName, isOpt, callSignature);\n        }\n        var typeAnnotation = this.parseTypeAnnotationOpt_();\n        return new PropertySignature(this.getTreeLocation_(start), propertyName, isOpt, typeAnnotation);\n      },\n      parseCallSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var returnType = this.parseTypeAnnotationOpt_();\n        return new CallSignature(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseConstructSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(NEW);\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        var returnType = this.parseTypeAnnotationOpt_();\n        return new ConstructSignature(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseIndexSignature_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_SQUARE);\n        var id = this.eatId_();\n        this.eat_(COLON);\n        var typeName;\n        var typeStart = this.getTreeStartLocation_();\n        if (this.peekPredefinedString_('string')) {\n          typeName = this.eatId_('string');\n        } else {\n          typeName = this.eatId_('number');\n        }\n        var indexType = new PredefinedType(this.getTreeLocation_(typeStart), typeName);\n        this.eat_(CLOSE_SQUARE);\n        this.eat_(COLON);\n        var typeAnnotation = this.parseType_();\n        return new IndexSignature(this.getTreeLocation_(start), id, indexType, typeAnnotation);\n      },\n      parseFunctionType_: function() {\n        var start = this.getTreeStartLocation_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        this.eat_(OPEN_PAREN);\n        var parameterList = this.parseFormalParameters_();\n        this.eat_(CLOSE_PAREN);\n        this.eat_(ARROW);\n        var returnType = this.parseType_();\n        return new FunctionType(this.getTreeLocation_(start), typeParameters, parameterList, returnType);\n      },\n      parseTypeQuery_: function(start) {\n        throw 'NYI';\n      },\n      peekTypeParameters_: function() {\n        return peek(OPEN_ANGLE);\n      },\n      parseTypeParametersOpt_: function() {\n        if (peek(OPEN_ANGLE)) {\n          return this.parseTypeParameters_();\n        }\n        return null;\n      },\n      parseTypeParameters_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(OPEN_ANGLE);\n        var parameters = [this.parseTypeParameter_()];\n        while (peek(COMMA)) {\n          this.eat_(COMMA);\n          parameters.push(this.parseTypeParameter_());\n        }\n        this.eat_(CLOSE_ANGLE);\n        return new TypeParameters(this.getTreeLocation_(start), parameters);\n      },\n      parseTypeParameter_: function() {\n        var start = this.getTreeStartLocation_();\n        var id = this.eatId_();\n        var extendsType = null;\n        if (this.eatIf_(EXTENDS)) {\n          extendsType = this.parseType_();\n        }\n        return new TypeParameter(this.getTreeLocation_(start), id, extendsType);\n      },\n      parseNamedOrPredefinedType_: function() {\n        var start = this.getTreeStartLocation_();\n        switch (peekToken().value) {\n          case 'any':\n          case 'number':\n          case 'boolean':\n          case 'string':\n            {\n              var token = nextToken();\n              return new PredefinedType(this.getTreeLocation_(start), token);\n            }\n          default:\n            return this.parseTypeName_();\n        }\n      },\n      parseTypeName_: function() {\n        var start = this.getTreeStartLocation_();\n        var id = this.eatId_();\n        var typeName = new TypeName(this.getTreeLocation_(start), null, id);\n        while (this.eatIf_(PERIOD)) {\n          var memberName = this.eatIdName_();\n          typeName = new TypeName(this.getTreeLocation_(start), typeName, memberName);\n        }\n        return typeName;\n      },\n      parseInterfaceDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eat_(INTERFACE);\n        var name = this.eatId_();\n        var typeParameters = this.parseTypeParametersOpt_();\n        var extendsClause;\n        if (this.eatIf_(EXTENDS)) {\n          extendsClause = this.parseInterfaceExtendsClause_();\n        } else {\n          extendsClause = [];\n        }\n        var objectType = this.parseObjectType_();\n        return new InterfaceDeclaration(this.getTreeLocation_(start), name, typeParameters, extendsClause, objectType);\n      },\n      parseInterfaceExtendsClause_: function() {\n        var result = [this.parseTypeReference_()];\n        while (this.eatIf_(COMMA)) {\n          result.push(this.parseTypeReference_());\n        }\n        return result;\n      },\n      parseAnnotatedDeclarations_: function(parsingModuleItem) {\n        this.pushAnnotations_();\n        var declaration;\n        var type = peekType();\n        if (parsingModuleItem) {\n          declaration = this.parseModuleItem_(type);\n        } else {\n          declaration = this.parseStatementListItem_(type);\n        }\n        if (this.annotations_.length > 0) {\n          this.reportError_(this.annotations_[0].location, 'Unsupported annotated expression');\n        }\n        return declaration;\n      },\n      parseAnnotations_: function() {\n        var annotations = [];\n        while (this.eatIf_(AT)) {\n          annotations.push(this.parseAnnotation_());\n        }\n        return annotations;\n      },\n      pushAnnotations_: function() {\n        this.annotations_ = this.parseAnnotations_();\n      },\n      popAnnotations_: function() {\n        var annotations = this.annotations_;\n        this.annotations_ = [];\n        return annotations;\n      },\n      parseAnnotation_: function() {\n        var start = this.getTreeStartLocation_();\n        var expression = this.parseMemberExpressionNoNew_();\n        var args = null;\n        if (peek(OPEN_PAREN))\n          args = this.parseArguments_();\n        return new Annotation(this.getTreeLocation_(start), expression, args);\n      },\n      parseTypeAliasDeclaration_: function() {\n        var start = this.getTreeStartLocation_();\n        this.eatId_(TYPE);\n        var name = this.eatId_();\n        this.eat_(EQUAL);\n        var type = this.parseType_();\n        this.eatPossibleImplicitSemiColon_();\n        return new TypeAliasDeclaration(this.getTreeLocation_(start), name, type);\n      },\n      parseJsxElement_: function() {\n        var token = this.eatJsx_(OPEN_ANGLE);\n        return this.parseJsxElementContinuation_(token.location.start);\n      },\n      parseJsxElementContinuation_: function(start) {\n        var name = this.parseJsxElementName_();\n        var attrs = this.parseJsxAttributes_();\n        var children = [];\n        switch (peekJsxToken().type) {\n          case SLASH:\n            nextJsxToken();\n            this.eat_(CLOSE_ANGLE);\n            break;\n          case CLOSE_ANGLE:\n            {\n              nextJsxTextToken();\n              loop: while (true) {\n                var token = nextJsxTextToken();\n                switch (token.type) {\n                  case STRING:\n                    {\n                      children.push(new JsxText(token.location, token));\n                      continue;\n                    }\n                  case OPEN_CURLY:\n                    {\n                      var start$__20 = token.location.start;\n                      var expression = null;\n                      if (!peek(CLOSE_CURLY)) {\n                        expression = this.parseAssignmentExpression_(ALLOW_IN);\n                      }\n                      this.eatJsx_(CLOSE_CURLY);\n                      var placeHolder = new JsxPlaceholder(this.getTreeLocation_(start$__20), expression);\n                      children.push(placeHolder);\n                      continue;\n                    }\n                  case OPEN_ANGLE:\n                    {\n                      var start$__21 = token.location.start;\n                      if (peekJsxToken().type === SLASH) {\n                        nextJsxToken();\n                        break loop;\n                      }\n                      var subElement = this.parseJsxElementContinuation_(start$__21);\n                      children.push(subElement);\n                      resetScanner(subElement.location.end.offset);\n                      continue;\n                    }\n                  default:\n                    return this.parseSyntaxError_('Unexpected token');\n                }\n              }\n              var closeName = this.parseJsxElementName_();\n              if (!jsxNamesEqual(name, closeName)) {\n                this.reportError_(closeName.location, (\"Non matching JSX closing tag. Expected \" + jsxNameToString(name) + \", found \" + jsxNameToString(closeName)));\n              }\n              this.eat_(CLOSE_ANGLE);\n              break;\n            }\n          default:\n            return this.parseSyntaxError_('Unexpected token');\n        }\n        var element = new JsxElement(this.getTreeLocation_(start), name, attrs, children);\n        return element;\n      },\n      parseJsxElementName_: function() {\n        var tokens = [];\n        var id = this.eatJsx_(JSX_IDENTIFIER);\n        var start = id.location.start;\n        tokens.push(id);\n        while (peekJsxToken().type === PERIOD) {\n          nextJsxToken();\n          var id$__22 = this.eatJsx_(JSX_IDENTIFIER);\n          tokens.push(id$__22);\n        }\n        return new JsxElementName(this.getTreeLocation_(start), tokens);\n      },\n      parseJsxAttributes_: function() {\n        var attributes = [];\n        loop: while (true) {\n          switch (peekJsxToken().type) {\n            case JSX_IDENTIFIER:\n              attributes.push(this.parseJsxAttribute_());\n              break;\n            case OPEN_CURLY:\n              attributes.push(this.parseJsxSpreadAttribute_());\n              break;\n            default:\n              break loop;\n          }\n        }\n        return attributes;\n      },\n      parseJsxAttribute_: function() {\n        var name = this.eatJsx_(JSX_IDENTIFIER);\n        var start = name.location.start;\n        var value = null;\n        if (peekJsxToken().type === EQUAL) {\n          this.eatJsx_(EQUAL);\n          value = this.parseJsxAttributeValue_();\n        }\n        return new JsxAttribute(this.getTreeLocation_(start), name, value);\n      },\n      parseJsxAttributeValue_: function() {\n        var token = peekJsxToken();\n        var start = token.location.start;\n        switch (token.type) {\n          case STRING:\n            nextJsxToken();\n            return new LiteralExpression(this.getTreeLocation_(start), token);\n          case OPEN_CURLY:\n            {\n              nextJsxToken();\n              var expr = this.parseAssignmentExpression_(ALLOW_IN);\n              this.eatJsx_(CLOSE_CURLY);\n              return new JsxPlaceholder(this.getTreeLocation_(start), expr);\n            }\n          case OPEN_ANGLE:\n            return this.parseJsxElement_();\n        }\n        return this.parseSyntaxError_('Unexpected token');\n      },\n      parseJsxSpreadAttribute_: function() {\n        var token = peekJsxToken();\n        var start = token.location.start;\n        nextJsxToken();\n        this.eatJsx_(DOT_DOT_DOT);\n        var expr = this.parseAssignmentExpression_(ALLOW_IN);\n        this.eatJsx_(CLOSE_CURLY);\n        return new JsxSpreadAttribute(this.getTreeLocation_(start), expr);\n      },\n      eatPossibleImplicitSemiColon_: function() {\n        var token = peekTokenNoLineTerminator();\n        if (!token)\n          return;\n        switch (token.type) {\n          case SEMI_COLON:\n            nextToken();\n            return;\n          case END_OF_FILE:\n          case CLOSE_CURLY:\n            return;\n        }\n        this.reportError_(token.location, 'Semi-colon expected');\n      },\n      peekImplicitSemiColon_: function() {\n        switch (peekType()) {\n          case SEMI_COLON:\n          case CLOSE_CURLY:\n          case END_OF_FILE:\n            return true;\n        }\n        var token = peekTokenNoLineTerminator();\n        return token === null;\n      },\n      eatOpt_: function(expectedTokenType) {\n        if (peek(expectedTokenType))\n          return nextToken();\n        return null;\n      },\n      eatIdOpt_: function() {\n        return peek(IDENTIFIER) ? this.eatId_() : null;\n      },\n      eatId_: function() {\n        var expected = arguments[0];\n        var token = nextToken();\n        if (token.type === IDENTIFIER) {\n          if (expected && token.value !== expected)\n            this.reportExpectedError_(token, expected);\n          return token;\n        }\n        if (token.isStrictKeyword()) {\n          if (this.strictMode_) {\n            this.reportReservedIdentifier_(token);\n          } else {\n            return new IdentifierToken(token.location, token.type);\n          }\n        } else {\n          this.reportExpectedError_(token, expected || 'identifier');\n        }\n        return token;\n      },\n      eatIdName_: function() {\n        var t = nextToken();\n        if (t.type !== IDENTIFIER) {\n          if (!t.isKeyword()) {\n            this.reportExpectedError_(t, 'identifier');\n            return null;\n          }\n          return new IdentifierToken(t.location, t.type);\n        }\n        return t;\n      },\n      eat_: function(expectedTokenType) {\n        return this.isExpectedToken_(nextToken(), expectedTokenType);\n      },\n      eatIf_: function(expectedTokenType) {\n        if (peek(expectedTokenType)) {\n          nextToken();\n          return true;\n        }\n        return false;\n      },\n      eatJsx_: function(expectedTokenType) {\n        return this.isExpectedToken_(nextJsxToken(), expectedTokenType);\n      },\n      isExpectedToken_: function(token, expectedTokenType) {\n        if (token.type !== expectedTokenType) {\n          this.reportExpectedError_(token, expectedTokenType);\n        }\n        return token;\n      },\n      reportExpectedError_: function(token, expected) {\n        this.reportError_(token.location, (\"Unexpected token \" + token));\n      },\n      getTreeStartLocation_: function() {\n        return peekLocation().start;\n      },\n      getTreeEndLocation_: function() {\n        return getLastToken().location.end;\n      },\n      getTreeLocation_: function(start) {\n        return new SourceRange(start, this.getTreeEndLocation_());\n      },\n      handleComment: function(range) {},\n      isAtEnd: function() {\n        return isAtEnd();\n      },\n      reportError_: function(location, message) {\n        this.errorReporter_.reportError(location, message);\n      },\n      reportReservedIdentifier_: function(token) {\n        this.reportError_(token.location, (token.type + \" is a reserved identifier\"));\n      },\n      validateAssignmentTarget_: function(tree, operation) {\n        if (!tree.isPattern() && !isValidSimpleAssignmentTarget(tree, this.strictMode_)) {\n          this.reportError_(tree.location, (\"Invalid left-hand side expression in \" + operation));\n        }\n      }\n    }, {});\n  }();\n  function jsxNamesEqual(name, other) {\n    if (name.names.length !== other.names.length) {\n      return false;\n    }\n    for (var i = 0; i < name.names.length; i++) {\n      if (name.names[i].value !== other.names[i].value) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function jsxNameToString(name) {\n    return name.names.join('.');\n  }\n  return {get Parser() {\n      return Parser;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/SourcePosition.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/SourcePosition.js\";\n  var SourcePosition = function() {\n    function SourcePosition(source, offset) {\n      this.source = source;\n      this.offset = offset;\n      this.line_ = -1;\n      this.column_ = -1;\n    }\n    return ($traceurRuntime.createClass)(SourcePosition, {\n      get line() {\n        if (this.line_ === -1)\n          this.line_ = this.source.lineNumberTable.getLine(this.offset);\n        return this.line_;\n      },\n      get column() {\n        if (this.column_ === -1)\n          this.column_ = this.source.lineNumberTable.getColumn(this.offset);\n        return this.column_;\n      },\n      toString: function() {\n        var name = this.source ? this.source.name : '';\n        return (name + \":\" + (this.line + 1) + \":\" + (this.column + 1));\n      }\n    }, {});\n  }();\n  return {get SourcePosition() {\n      return SourcePosition;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/LineNumberTable.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/LineNumberTable.js\";\n  var SourcePosition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/SourcePosition.js\", \"traceur@0.0.111/src/syntax/LineNumberTable.js\")).SourcePosition;\n  var SourceRange = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/SourceRange.js\", \"traceur@0.0.111/src/syntax/LineNumberTable.js\")).SourceRange;\n  var isLineTerminator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Scanner.js\", \"traceur@0.0.111/src/syntax/LineNumberTable.js\")).isLineTerminator;\n  var MAX_INT_REPRESENTATION = 9007199254740992;\n  function computeLineStartOffsets(source) {\n    var lineStartOffsets = [0];\n    var k = 1;\n    for (var index = 0; index < source.length; index++) {\n      var code = source.charCodeAt(index);\n      if (isLineTerminator(code)) {\n        if (code === 13 && source.charCodeAt(index + 1) === 10) {\n          index++;\n        }\n        lineStartOffsets[k++] = index + 1;\n      }\n    }\n    lineStartOffsets[k++] = MAX_INT_REPRESENTATION;\n    return lineStartOffsets;\n  }\n  var LineNumberTable = function() {\n    function LineNumberTable(sourceFile) {\n      this.sourceFile_ = sourceFile;\n      this.lineStartOffsets_ = null;\n      this.lastLine_ = 0;\n      this.lastOffset_ = -1;\n    }\n    return ($traceurRuntime.createClass)(LineNumberTable, {\n      ensureLineStartOffsets_: function() {\n        if (!this.lineStartOffsets_) {\n          this.lineStartOffsets_ = computeLineStartOffsets(this.sourceFile_.contents);\n        }\n      },\n      getSourcePosition: function(offset) {\n        return new SourcePosition(this.sourceFile_, offset);\n      },\n      getLine: function(offset) {\n        if (offset === this.lastOffset_)\n          return this.lastLine_;\n        this.ensureLineStartOffsets_();\n        if (offset < 0)\n          return 0;\n        var line;\n        if (offset < this.lastOffset_) {\n          for (var i = this.lastLine_; i >= 0; i--) {\n            if (this.lineStartOffsets_[i] <= offset) {\n              line = i;\n              break;\n            }\n          }\n        } else {\n          for (var i$__1 = this.lastLine_; true; i$__1++) {\n            if (this.lineStartOffsets_[i$__1] > offset) {\n              line = i$__1 - 1;\n              break;\n            }\n          }\n        }\n        this.lastLine_ = line;\n        this.lastOffset_ = offset;\n        return line;\n      },\n      offsetOfLine: function(line) {\n        this.ensureLineStartOffsets_();\n        return this.lineStartOffsets_[line];\n      },\n      getColumn: function(offset) {\n        var line = this.getLine(offset);\n        return offset - this.lineStartOffsets_[line];\n      },\n      getSourceRange: function(startOffset, endOffset) {\n        return new SourceRange(this.getSourcePosition(startOffset), this.getSourcePosition(endOffset));\n      }\n    }, {});\n  }();\n  return {get LineNumberTable() {\n      return LineNumberTable;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/SourceFile.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/SourceFile.js\";\n  var LineNumberTable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LineNumberTable.js\", \"traceur@0.0.111/src/syntax/SourceFile.js\")).LineNumberTable;\n  var SourceFile = function() {\n    function SourceFile(name, contents) {\n      this.name = name;\n      this.contents = contents;\n      this.lineNumberTable = new LineNumberTable(this);\n    }\n    return ($traceurRuntime.createClass)(SourceFile, {}, {});\n  }();\n  return {get SourceFile() {\n      return SourceFile;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")),\n      ARGUMENT_LIST = $__2.ARGUMENT_LIST,\n      BLOCK = $__2.BLOCK,\n      EXPRESSION_STATEMENT = $__2.EXPRESSION_STATEMENT,\n      FUNCTION_BODY = $__2.FUNCTION_BODY,\n      IDENTIFIER_EXPRESSION = $__2.IDENTIFIER_EXPRESSION;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/IdentifierToken.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).IdentifierToken;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).LiteralToken;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/CollectingErrorReporter.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).CollectingErrorReporter;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Options.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).Options;\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTree.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).ParseTree;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).ParseTreeTransformer;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Parser.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).Parser;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")),\n      LiteralExpression = $__10.LiteralExpression,\n      LiteralPropertyName = $__10.LiteralPropertyName,\n      TypeName = $__10.TypeName;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/SourceFile.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).SourceFile;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")).IDENTIFIER;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/PlaceholderParser.js\")),\n      createArrayLiteral = $__13.createArrayLiteral,\n      createBindingIdentifier = $__13.createBindingIdentifier,\n      createBlock = $__13.createBlock,\n      createBooleanLiteral = $__13.createBooleanLiteral,\n      createCommaExpression = $__13.createCommaExpression,\n      createExpressionStatement = $__13.createExpressionStatement,\n      createFunctionBody = $__13.createFunctionBody,\n      createIdentifierExpression = $__13.createIdentifierExpression,\n      createIdentifierToken = $__13.createIdentifierToken,\n      createMemberExpression = $__13.createMemberExpression,\n      createNullLiteral = $__13.createNullLiteral,\n      createNumberLiteral = $__13.createNumberLiteral,\n      createParenExpression = $__13.createParenExpression,\n      createStringLiteral = $__13.createStringLiteral,\n      createVoid0 = $__13.createVoid0;\n  var NOT_FOUND = {};\n  function makeParseFunction(doParse) {\n    var cache = new Map();\n    return function(sourceLiterals) {\n      for (var values = [],\n          $__1 = 1; $__1 < arguments.length; $__1++)\n        values[$__1 - 1] = arguments[$__1];\n      return parse(sourceLiterals, values, doParse, cache);\n    };\n  }\n  var parseExpression = makeParseFunction(function(p) {\n    return p.parseExpression();\n  });\n  var parseStatement = makeParseFunction(function(p) {\n    return p.parseStatement();\n  });\n  var parseModule = makeParseFunction(function(p) {\n    return p.parseModule();\n  });\n  var parseScript = makeParseFunction(function(p) {\n    return p.parseScript();\n  });\n  var parseStatements = makeParseFunction(function(p) {\n    return p.parseStatements();\n  });\n  var parsePropertyDefinition = makeParseFunction(function(p) {\n    return p.parsePropertyDefinition();\n  });\n  function parse(sourceLiterals, values, doParse, cache) {\n    var tree = cache.get(sourceLiterals);\n    if (!tree) {\n      var source = insertPlaceholderIdentifiers(sourceLiterals);\n      var errorReporter = new CollectingErrorReporter();\n      var parser = getParser(source, errorReporter);\n      tree = doParse(parser);\n      if (errorReporter.hadError() || !tree || !parser.isAtEnd()) {\n        throw new Error((\"Internal error trying to parse:\\n\\n\" + source + \"\\n\\n\" + errorReporter.errorsAsString()));\n      }\n      cache.set(sourceLiterals, tree);\n    }\n    if (!values.length)\n      return tree;\n    if (tree instanceof ParseTree)\n      return new PlaceholderTransformer(values).transformAny(tree);\n    return new PlaceholderTransformer(values).transformList(tree);\n  }\n  var PREFIX = '$__placeholder__';\n  function insertPlaceholderIdentifiers(sourceLiterals) {\n    var source = sourceLiterals[0];\n    for (var i = 1; i < sourceLiterals.length; i++) {\n      source += PREFIX + String(i - 1) + sourceLiterals[i];\n    }\n    return source;\n  }\n  var counter = 0;\n  function getParser(source, errorReporter) {\n    var file = new SourceFile(null, source);\n    var options = new Options();\n    options.experimental = true;\n    return new Parser(file, errorReporter, options);\n  }\n  function convertValueToExpression(value) {\n    if (value instanceof ParseTree)\n      return value;\n    if (value instanceof IdentifierToken)\n      return createIdentifierExpression(value);\n    if (value instanceof LiteralToken)\n      return new LiteralExpression(value.location, value);\n    if (Array.isArray(value)) {\n      if (value[0] instanceof ParseTree) {\n        if (value.length === 1)\n          return value[0];\n        if (value[0].isStatement())\n          return createBlock(value);\n        else\n          return createParenExpression(createCommaExpression(value));\n      }\n      return createArrayLiteral(value.map(convertValueToExpression));\n    }\n    if (value === null)\n      return createNullLiteral();\n    if (value === undefined)\n      return createVoid0();\n    switch (typeof value) {\n      case 'string':\n        return createStringLiteral(value);\n      case 'boolean':\n        return createBooleanLiteral(value);\n      case 'number':\n        return createNumberLiteral(value);\n    }\n    throw new Error('Not implemented');\n  }\n  function convertValueToIdentifierToken(value) {\n    if (value instanceof IdentifierToken)\n      return value;\n    return createIdentifierToken(value);\n  }\n  function convertValueToType(value) {\n    if (value === null)\n      return null;\n    if (value instanceof ParseTree)\n      return value;\n    if (typeof value === 'string') {\n      return new TypeName(null, null, convertValueToIdentifierToken(value));\n    }\n    if (value instanceof IdentifierToken) {\n      return new TypeName(null, null, value);\n    }\n    throw new Error('Not implemented');\n  }\n  var PlaceholderTransformer = function($__super) {\n    function PlaceholderTransformer(values) {\n      $traceurRuntime.superConstructor(PlaceholderTransformer).call(this);\n      this.values = values;\n    }\n    return ($traceurRuntime.createClass)(PlaceholderTransformer, {\n      getValueAt: function(index) {\n        return this.values[index];\n      },\n      getValue_: function(str) {\n        if (str.indexOf(PREFIX) !== 0)\n          return NOT_FOUND;\n        return this.getValueAt(Number(str.slice(PREFIX.length)));\n      },\n      transformIdentifierExpression: function(tree) {\n        var value = this.getValue_(tree.identifierToken.value);\n        if (value === NOT_FOUND)\n          return tree;\n        return convertValueToExpression(value);\n      },\n      transformBindingIdentifier: function(tree) {\n        var value = this.getValue_(tree.identifierToken.value);\n        if (value === NOT_FOUND)\n          return tree;\n        return createBindingIdentifier(value);\n      },\n      transformExpressionStatement: function(tree) {\n        if (tree.expression.type === IDENTIFIER_EXPRESSION) {\n          var transformedExpression = this.transformIdentifierExpression(tree.expression);\n          if (transformedExpression === tree.expression)\n            return tree;\n          if (transformedExpression.isStatementListItem() || transformedExpression.type === FUNCTION_BODY) {\n            return transformedExpression;\n          }\n          return createExpressionStatement(transformedExpression);\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformExpressionStatement\").call(this, tree);\n      },\n      transformBlock: function(tree) {\n        if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {\n          var transformedStatement = this.transformExpressionStatement(tree.statements[0]);\n          if (transformedStatement === tree.statements[0])\n            return tree;\n          if (transformedStatement.type === BLOCK)\n            return transformedStatement;\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformBlock\").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {\n          var transformedStatement = this.transformExpressionStatement(tree.statements[0]);\n          if (transformedStatement.type === FUNCTION_BODY)\n            return transformedStatement;\n          if (transformedStatement === tree.statements[0])\n            return tree;\n          if (transformedStatement.type === BLOCK)\n            return createFunctionBody(transformedStatement.statements);\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n      },\n      transformMemberExpression: function(tree) {\n        var value = this.getValue_(tree.memberName.value);\n        if (value === NOT_FOUND)\n          return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformMemberExpression\").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        return createMemberExpression(operand, value);\n      },\n      transformLiteralPropertyName: function(tree) {\n        if (tree.literalToken.type === IDENTIFIER) {\n          var value = this.getValue_(tree.literalToken.value);\n          if (value !== NOT_FOUND) {\n            return new LiteralPropertyName(null, convertValueToIdentifierToken(value));\n          }\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformLiteralPropertyName\").call(this, tree);\n      },\n      transformArgumentList: function(tree) {\n        if (tree.args.length === 1 && tree.args[0].type === IDENTIFIER_EXPRESSION) {\n          var arg0 = this.transformAny(tree.args[0]);\n          if (arg0 === tree.args[0])\n            return tree;\n          if (arg0.type === ARGUMENT_LIST)\n            return arg0;\n        }\n        return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformArgumentList\").call(this, tree);\n      },\n      transformTypeName: function(tree) {\n        var value = this.getValue_(tree.name.value);\n        if (value === NOT_FOUND)\n          return $traceurRuntime.superGet(this, PlaceholderTransformer.prototype, \"transformTypeName\").call(this, tree);\n        var moduleName = this.transformAny(tree.moduleName);\n        if (moduleName !== null) {\n          return new TypeName(null, moduleName, convertValueToIdentifierToken(value));\n        }\n        return convertValueToType(value);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {\n    get parseExpression() {\n      return parseExpression;\n    },\n    get parseStatement() {\n      return parseStatement;\n    },\n    get parseModule() {\n      return parseModule;\n    },\n    get parseScript() {\n      return parseScript;\n    },\n    get parseStatements() {\n      return parseStatements;\n    },\n    get parsePropertyDefinition() {\n      return parsePropertyDefinition;\n    },\n    get PlaceholderTransformer() {\n      return PlaceholderTransformer;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/PrependStatements.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/PrependStatements.js\";\n  function prependStatements(statements) {\n    var $__1;\n    for (var statementsToPrepend = [],\n        $__0 = 1; $__0 < arguments.length; $__0++)\n      statementsToPrepend[$__0 - 1] = arguments[$__0];\n    if (!statements.length)\n      return statementsToPrepend;\n    if (!statementsToPrepend.length)\n      return statements;\n    var transformed = [];\n    var inProlog = true;\n    statements.forEach(function(statement) {\n      var $__1;\n      if (inProlog && !statement.isDirectivePrologue()) {\n        ($__1 = transformed).push.apply($__1, $traceurRuntime.spread(statementsToPrepend));\n        inProlog = false;\n      }\n      transformed.push(statement);\n    });\n    if (inProlog) {\n      ($__1 = transformed).push.apply($__1, $traceurRuntime.spread(statementsToPrepend));\n    }\n    return transformed;\n  }\n  return {get prependStatements() {\n      return prependStatements;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")),\n      CONST = $__5.CONST,\n      VAR = $__5.VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")),\n      ImportDeclaration = $__6.ImportDeclaration,\n      ImportedBinding = $__6.ImportedBinding,\n      ImportSpecifier = $__6.ImportSpecifier,\n      ImportSpecifierSet = $__6.ImportSpecifierSet,\n      Module = $__6.Module,\n      ModuleSpecifier = $__6.ModuleSpecifier,\n      Script = $__6.Script;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")).StringSet;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")),\n      createBindingIdentifier = $__8.createBindingIdentifier,\n      createIdentifierToken = $__8.createIdentifierToken,\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createMemberExpression = $__8.createMemberExpression,\n      createStringLiteral = $__8.createStringLiteral,\n      createStringLiteralToken = $__8.createStringLiteralToken,\n      createVariableStatement = $__8.createVariableStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/ImportRuntimeTrait.js\")).prependStatements;\n  function toTempName(name) {\n    return (\"$__\" + name);\n  }\n  function getDeclarationType(options) {\n    return options.parseOptions.blockBinding && !options.transformOptions.blockBinding ? CONST : VAR;\n  }\n  function ImportRuntimeTrait(ParseTreeTransformerClass) {\n    return function($__super) {\n      function $__0() {\n        var $__4;\n        for (var args = [],\n            $__3 = 0; $__3 < arguments.length; $__3++)\n          args[$__3] = arguments[$__3];\n        ($__4 = $traceurRuntime.superConstructor($__0)).call.apply($__4, $traceurRuntime.spread([this], args));\n        this.importedNames = new StringSet();\n        this._existingImports = new StringSet();\n      }\n      return ($traceurRuntime.createClass)($__0, {\n        getRuntimeExpression: function(name) {\n          if (this.options.importRuntime) {\n            this.addImportedName(name);\n            return createIdentifierExpression(toTempName(name));\n          }\n          return createMemberExpression('$traceurRuntime', name);\n        },\n        get requiredNames() {\n          return this.importedNames;\n        },\n        addImportedName: function(name) {\n          this.importedNames.add(name);\n        },\n        transformScript: function(tree) {\n          var transformed = $traceurRuntime.superGet(this, $__0.prototype, \"transformScript\").call(this, tree);\n          if (tree === transformed) {\n            return tree;\n          }\n          if (!this.options.importRuntime) {\n            return transformed;\n          }\n          var scriptItemList = this.addRuntimeImports(transformed.scriptItemList);\n          return new Script(tree.location, scriptItemList, tree.moduleName);\n        },\n        transformModule: function(tree) {\n          var transformed = $traceurRuntime.superGet(this, $__0.prototype, \"transformModule\").call(this, tree);\n          if (tree === transformed) {\n            return tree;\n          }\n          if (!this.options.importRuntime) {\n            return transformed;\n          }\n          var scriptItemList = this.addRuntimeImports(transformed.scriptItemList);\n          return new Module(tree.location, scriptItemList, tree.moduleName);\n        },\n        transformImportedBinding: function(tree) {\n          this._existingImports.add(tree.binding.getStringValue());\n          return $traceurRuntime.superGet(this, $__0.prototype, \"transformImportedBinding\").call(this, tree);\n        },\n        _getModuleSpecifier: function(name) {\n          var base = 'traceur/dist/commonjs';\n          if (this.options.modules === 'parse') {\n            base = 'traceur/src';\n          }\n          var moduleId = createStringLiteralToken((base + \"/runtime/modules/\" + name + \".js\"));\n          return new ModuleSpecifier(null, moduleId);\n        },\n        getRuntimeImports: function() {\n          var $__2 = this;\n          return this.importedNames.valuesAsArray().filter(function(name) {\n            return !$__2._existingImports.has(toTempName(name));\n          }).map(function(name) {\n            var def = createIdentifierToken('default');\n            var binding = new ImportedBinding(null, createBindingIdentifier(toTempName(name)));\n            var specifier = new ImportSpecifier(null, binding, def);\n            return new ImportDeclaration(null, new ImportSpecifierSet(null, [specifier]), $__2._getModuleSpecifier(name));\n          });\n        },\n        addRuntimeImports: function(scriptItemList) {\n          var runtimeImports = this.getRuntimeImports();\n          return prependStatements.apply((void 0), $traceurRuntime.spread([scriptItemList], runtimeImports));\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformerClass);\n  }\n  return {get default() {\n      return ImportRuntimeTrait;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")).ParseTreeTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")),\n      Module = $__6.Module,\n      Script = $__6.Script;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")).ARGUMENTS;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")).StringSet;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")),\n      LET = $__9.LET,\n      VAR = $__9.VAR;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")),\n      createFunctionBody = $__10.createFunctionBody,\n      createThisExpression = $__10.createThisExpression,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createVariableDeclaration = $__10.createVariableDeclaration,\n      createVariableDeclarationList = $__10.createVariableDeclarationList,\n      createVariableStatement = $__10.createVariableStatement;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/TempVarTransformer.js\")).prependStatements;\n  var TempVarStatement = function() {\n    function TempVarStatement(name, initializer) {\n      this.name = name;\n      this.initializer = initializer;\n    }\n    return ($traceurRuntime.createClass)(TempVarStatement, {}, {});\n  }();\n  var TempScope = function() {\n    function TempScope() {\n      this.identifiers = [];\n    }\n    return ($traceurRuntime.createClass)(TempScope, {\n      push: function(identifier) {\n        this.identifiers.push(identifier);\n      },\n      pop: function() {\n        return this.identifiers.pop();\n      },\n      release: function(obj) {\n        for (var i = this.identifiers.length - 1; i >= 0; i--) {\n          obj.releaseTempName(this.identifiers[i]);\n        }\n      }\n    }, {});\n  }();\n  var VarScope = function() {\n    function VarScope(options) {\n      this.thisName = null;\n      this.argumentName = null;\n      this.tempVarStatements = [];\n      this.declarationType_ = options.blockBinding && !options.transformOptions.blockBinding ? LET : VAR;\n    }\n    return ($traceurRuntime.createClass)(VarScope, {\n      push: function(tempVarStatement) {\n        this.tempVarStatements.push(tempVarStatement);\n      },\n      pop: function() {\n        return this.tempVarStatements.pop();\n      },\n      release: function(obj) {\n        for (var i = this.tempVarStatements.length - 1; i >= 0; i--) {\n          obj.releaseTempName(this.tempVarStatements[i].name);\n        }\n      },\n      isEmpty: function() {\n        return !this.tempVarStatements.length;\n      },\n      createVariableStatement: function() {\n        var declarations = [];\n        var seenNames = new StringSet();\n        for (var i = 0; i < this.tempVarStatements.length; i++) {\n          var $__4 = this.tempVarStatements[i],\n              name = $__4.name,\n              initializer = $__4.initializer;\n          if (seenNames.has(name)) {\n            if (initializer)\n              throw new Error('Invalid use of TempVarTransformer');\n            continue;\n          }\n          seenNames.add(name);\n          declarations.push(createVariableDeclaration(name, initializer));\n        }\n        return createVariableStatement(createVariableDeclarationList(this.declarationType_, declarations));\n      }\n    }, {});\n  }();\n  var TempVarTransformer = function($__super) {\n    function TempVarTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(TempVarTransformer).call(this);\n      this.identifierGenerator = identifierGenerator;\n      this.reporter = reporter;\n      this.options = options;\n      this.tempVarStack_ = [new VarScope(this.options)];\n      this.tempScopeStack_ = [new TempScope()];\n      this.namePool_ = [];\n    }\n    return ($traceurRuntime.createClass)(TempVarTransformer, {\n      transformStatements_: function(statements) {\n        this.tempVarStack_.push(new VarScope(this.options));\n        var transformedStatements = this.transformList(statements);\n        var vars = this.tempVarStack_.pop();\n        if (vars.isEmpty())\n          return transformedStatements;\n        var variableStatement = vars.createVariableStatement();\n        vars.release(this);\n        return prependStatements(transformedStatements, variableStatement);\n      },\n      transformScript: function(tree) {\n        var scriptItemList = this.transformStatements_(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Script(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformModule: function(tree) {\n        var scriptItemList = this.transformStatements_(tree.scriptItemList);\n        if (scriptItemList === tree.scriptItemList) {\n          return tree;\n        }\n        return new Module(tree.location, scriptItemList, tree.moduleName);\n      },\n      transformFunctionBody: function(tree) {\n        this.pushTempScope();\n        var statements = this.transformStatements_(tree.statements);\n        this.popTempScope();\n        if (statements === tree.statements)\n          return tree;\n        return createFunctionBody(statements);\n      },\n      getTempIdentifier: function() {\n        var name = this.getName_();\n        this.tempScopeStack_[this.tempScopeStack_.length - 1].push(name);\n        return name;\n      },\n      getName_: function() {\n        return this.namePool_.length ? this.namePool_.pop() : this.identifierGenerator.generateUniqueIdentifier();\n      },\n      addTempVar: function() {\n        var initializer = arguments[0] !== (void 0) ? arguments[0] : null;\n        var vars = this.tempVarStack_[this.tempVarStack_.length - 1];\n        var name = this.getName_();\n        vars.push(new TempVarStatement(name, initializer));\n        return name;\n      },\n      registerTempVarName: function(name) {\n        var vars = this.tempVarStack_[this.tempVarStack_.length - 1];\n        vars.push(new TempVarStatement(name, null));\n      },\n      addTempVarForThis: function() {\n        var varScope = this.tempVarStack_[this.tempVarStack_.length - 1];\n        return varScope.thisName || (varScope.thisName = this.addTempVar(createThisExpression()));\n      },\n      addTempVarForArguments: function() {\n        var varScope = this.tempVarStack_[this.tempVarStack_.length - 1];\n        return varScope.argumentName || (varScope.argumentName = this.addTempVar(createIdentifierExpression(ARGUMENTS)));\n      },\n      pushTempScope: function() {\n        this.tempScopeStack_.push(new TempScope());\n      },\n      popTempScope: function() {\n        this.tempScopeStack_.pop().release(this);\n      },\n      releaseTempName: function(name) {\n        this.namePool_.push(name);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TempVarTransformer() {\n      return TempVarTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js\";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js\")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/semantics/bindingsInDestructuringPattern.js\")).StringSet;\n  var BindingsInDestructuringPatternVisitor = function($__super) {\n    function BindingsInDestructuringPatternVisitor() {\n      $traceurRuntime.superConstructor(BindingsInDestructuringPatternVisitor).call(this);\n      this.bindings = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(BindingsInDestructuringPatternVisitor, {\n      visitBindingIdentifier: function(tree) {\n        this.bindings.add(tree.getStringValue());\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  function bindingsInDestructuringPattern(tree) {\n    var v = new BindingsInDestructuringPatternVisitor();\n    v.visitAny(tree);\n    return v.bindings;\n  }\n  return {get default() {\n      return bindingsInDestructuringPattern;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\";\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")),\n      ARRAY_LITERAL = $__8.ARRAY_LITERAL,\n      ARRAY_PATTERN = $__8.ARRAY_PATTERN,\n      ASSIGNMENT_ELEMENT = $__8.ASSIGNMENT_ELEMENT,\n      BINDING_ELEMENT = $__8.BINDING_ELEMENT,\n      BINDING_IDENTIFIER = $__8.BINDING_IDENTIFIER,\n      BLOCK = $__8.BLOCK,\n      CALL_EXPRESSION = $__8.CALL_EXPRESSION,\n      COMPUTED_PROPERTY_NAME = $__8.COMPUTED_PROPERTY_NAME,\n      IDENTIFIER_EXPRESSION = $__8.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__8.LITERAL_EXPRESSION,\n      MEMBER_EXPRESSION = $__8.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__8.MEMBER_LOOKUP_EXPRESSION,\n      OBJECT_LITERAL = $__8.OBJECT_LITERAL,\n      OBJECT_PATTERN_FIELD = $__8.OBJECT_PATTERN_FIELD,\n      OBJECT_PATTERN = $__8.OBJECT_PATTERN,\n      PAREN_EXPRESSION = $__8.PAREN_EXPRESSION,\n      VARIABLE_DECLARATION_LIST = $__8.VARIABLE_DECLARATION_LIST,\n      VARIABLE_STATEMENT = $__8.VARIABLE_STATEMENT;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")),\n      AnonBlock = $__9.AnonBlock,\n      AssignmentElement = $__9.AssignmentElement,\n      BindingElement = $__9.BindingElement,\n      Catch = $__9.Catch,\n      ExportDeclaration = $__9.ExportDeclaration,\n      ForInStatement = $__9.ForInStatement,\n      ForOfStatement = $__9.ForOfStatement,\n      ForOnStatement = $__9.ForOnStatement,\n      VariableDeclarationList = $__9.VariableDeclarationList,\n      VariableStatement = $__9.VariableStatement;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")).TempVarTransformer;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")),\n      EQUAL = $__12.EQUAL,\n      LET = $__12.LET,\n      VAR = $__12.VAR;\n  var bindingsInDestructuringPattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/bindingsInDestructuringPattern.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")).default;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")),\n      createAssignmentExpression = $__14.createAssignmentExpression,\n      createBindingIdentifier = $__14.createBindingIdentifier,\n      createBlock = $__14.createBlock,\n      createCommaExpression = $__14.createCommaExpression,\n      createExpressionStatement = $__14.createExpressionStatement,\n      createFunctionBody = $__14.createFunctionBody,\n      createIdentifierExpression = $__14.createIdentifierExpression,\n      createMemberExpression = $__14.createMemberExpression,\n      createMemberLookupExpression = $__14.createMemberLookupExpression,\n      createParenExpression = $__14.createParenExpression,\n      createVariableDeclaration = $__14.createVariableDeclaration,\n      createVariableDeclarationList = $__14.createVariableDeclarationList,\n      createVariableStatement = $__14.createVariableStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/DestructuringTransformer.js\")).prependStatements;\n  var Desugaring = function() {\n    function Desugaring(rvalue) {\n      this.rvalue = rvalue;\n      this.expressions = [];\n      this.pendingExpressions = [];\n    }\n    return ($traceurRuntime.createClass)(Desugaring, {\n      createIterator: function(iterId) {\n        this.pendingExpressions.push(parseExpression($traceurRuntime.getTemplateObject([\"\", \" = \", \"[Symbol.iterator]()\"]), iterId, this.rvalue));\n      },\n      createInitializer: function(expression) {\n        if (this.pendingExpressions.length === 0)\n          return expression;\n        var expressions = this.pendingExpressions;\n        this.pendingExpressions = [];\n        expressions.push(expression);\n        return createParenExpression(createCommaExpression(expressions));\n      },\n      skipHole: function(iterId) {\n        this.pendingExpressions.push(parseExpression($traceurRuntime.getTemplateObject([\"\", \".next()\"]), iterId));\n      }\n    }, {});\n  }();\n  var AssignmentExpressionDesugaring = function($__super) {\n    function AssignmentExpressionDesugaring(rvalue) {\n      $traceurRuntime.superConstructor(AssignmentExpressionDesugaring).call(this, rvalue);\n    }\n    return ($traceurRuntime.createClass)(AssignmentExpressionDesugaring, {\n      assign: function(lvalue, rvalue) {\n        lvalue = lvalue instanceof AssignmentElement ? lvalue.assignment : lvalue;\n        rvalue = this.createInitializer(rvalue);\n        this.expressions.push(createAssignmentExpression(lvalue, rvalue));\n      },\n      createAssignmentExpression: function(tempId, rvalue) {\n        var $__6;\n        var expressions = this.expressions;\n        expressions.unshift(createAssignmentExpression(tempId, rvalue));\n        ($__6 = expressions).push.apply($__6, $traceurRuntime.spread(this.pendingExpressions, [tempId]));\n        return createParenExpression(createCommaExpression(expressions));\n      }\n    }, {}, $__super);\n  }(Desugaring);\n  var VariableDeclarationDesugaring = function($__super) {\n    function VariableDeclarationDesugaring(rvalue) {\n      $traceurRuntime.superConstructor(VariableDeclarationDesugaring).call(this, rvalue);\n    }\n    return ($traceurRuntime.createClass)(VariableDeclarationDesugaring, {\n      assign: function(lvalue, rvalue) {\n        var binding = lvalue instanceof BindingElement ? lvalue.binding : createBindingIdentifier(lvalue);\n        rvalue = this.createInitializer(rvalue);\n        this.expressions.push(createVariableDeclaration(binding, rvalue));\n      },\n      get declarations() {\n        return this.expressions;\n      }\n    }, {}, $__super);\n  }(Desugaring);\n  var DestructuringTransformer = function($__super) {\n    function DestructuringTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(DestructuringTransformer).call(this, identifierGenerator, reporter, options);\n      this.parameterDeclarations = null;\n    }\n    return ($traceurRuntime.createClass)(DestructuringTransformer, {\n      transformArrayPattern: function(tree) {\n        throw new Error('unreachable');\n      },\n      transformObjectPattern: function(tree) {\n        throw new Error('unreachable');\n      },\n      transformBinaryExpression: function(tree) {\n        this.pushTempScope();\n        var rv;\n        if (tree.operator.type === EQUAL && tree.left.isPattern()) {\n          rv = this.transformAny(this.desugarAssignment_(tree.left, tree.right));\n        } else {\n          rv = $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformBinaryExpression\").call(this, tree);\n        }\n        this.popTempScope();\n        return rv;\n      },\n      desugarAssignment_: function(lvalue, rvalue) {\n        var tempId = createIdentifierExpression(this.addTempVar());\n        var desugaring = new AssignmentExpressionDesugaring(tempId);\n        this.desugarPattern_(desugaring, lvalue);\n        return desugaring.createAssignmentExpression(tempId, rvalue);\n      },\n      transformVariableDeclarationList: function(tree) {\n        var $__4 = this;\n        if (!hasDestructuring(tree)) {\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformVariableDeclarationList\").call(this, tree);\n        }\n        var desugaredDeclarations = [];\n        tree.declarations.forEach(function(declaration) {\n          var $__6;\n          if (declaration.lvalue.isPattern()) {\n            ($__6 = desugaredDeclarations).push.apply($__6, $traceurRuntime.spread($__4.desugarVariableDeclaration_(declaration)));\n          } else {\n            desugaredDeclarations.push(declaration);\n          }\n        });\n        var transformedTree = this.transformVariableDeclarationList(createVariableDeclarationList(tree.declarationType, desugaredDeclarations));\n        return transformedTree;\n      },\n      transformForInStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformForInStatement\"), ForInStatement);\n      },\n      transformForOfStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformForOfStatement\"), ForOfStatement);\n      },\n      transformForOnStatement: function(tree) {\n        return this.transformForInOrOfOrOn_(tree, $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformForOnStatement\"), ForOnStatement);\n      },\n      transformForInOrOfOrOn_: function(tree, superMethod, constr) {\n        var $__6;\n        if (!tree.initializer.isPattern() && (tree.initializer.type !== VARIABLE_DECLARATION_LIST || !hasDestructuring(tree.initializer))) {\n          return superMethod.call(this, tree);\n        }\n        this.pushTempScope();\n        var declarationType,\n            lvalue;\n        if (tree.initializer.isPattern()) {\n          declarationType = null;\n          lvalue = tree.initializer;\n        } else {\n          declarationType = tree.initializer.declarationType;\n          lvalue = tree.initializer.declarations[0].lvalue;\n        }\n        var statements = [];\n        var binding = this.desugarBinding_(lvalue, statements, declarationType);\n        var initializer = createVariableDeclarationList(VAR, binding, null);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformAny(tree.body);\n        if (body.type === BLOCK)\n          ($__6 = statements).push.apply($__6, $traceurRuntime.spread(body.statements));\n        else\n          statements.push(body);\n        body = createBlock(statements);\n        this.popTempScope();\n        return new constr(tree.location, initializer, collection, body);\n      },\n      transformAssignmentElement: function(tree) {\n        throw new Error('unreachable');\n      },\n      transformBindingElement: function(tree) {\n        if (!tree.binding.isPattern() || tree.initializer)\n          return tree;\n        if (this.parameterDeclarations === null) {\n          this.parameterDeclarations = [];\n          this.pushTempScope();\n        }\n        var varName = this.getTempIdentifier();\n        var binding = createBindingIdentifier(varName);\n        var initializer = createIdentifierExpression(varName);\n        var decl = createVariableDeclaration(tree.binding, initializer);\n        this.parameterDeclarations.push(decl);\n        return new BindingElement(null, binding, null);\n      },\n      transformFunctionBody: function(tree) {\n        if (this.parameterDeclarations === null)\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n        var list = createVariableDeclarationList(VAR, this.parameterDeclarations);\n        var statement = createVariableStatement(list);\n        var statements = prependStatements(tree.statements, statement);\n        var newBody = createFunctionBody(statements);\n        this.parameterDeclarations = null;\n        var result = $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformFunctionBody\").call(this, newBody);\n        this.popTempScope();\n        return result;\n      },\n      transformCatch: function(tree) {\n        var $__6;\n        if (!tree.binding.isPattern())\n          return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformCatch\").call(this, tree);\n        var body = this.transformAny(tree.catchBody);\n        var statements = [];\n        var kind = this.options.blockBinding ? LET : VAR;\n        var binding = this.desugarBinding_(tree.binding, statements, kind);\n        ($__6 = statements).push.apply($__6, $traceurRuntime.spread(body.statements));\n        return new Catch(tree.location, binding, createBlock(statements));\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === VARIABLE_STATEMENT && hasDestructuring(tree.declaration.declarations)) {\n          var names = bindingsInDestructuringPattern(tree.declaration.declarations);\n          var declaration = this.transformAny(tree.declaration);\n          var statements = [];\n          var $__5 = declaration.declarations,\n              declarations = $__5.declarations,\n              declarationType = $__5.declarationType;\n          for (var i = 0; i < declarations.length; i++) {\n            var declaration$__7 = declarations[i];\n            var statement = new VariableStatement(declaration$__7.location, new VariableDeclarationList(declaration$__7.location, declarationType, [declaration$__7]));\n            if (names.has(declarations[i].lvalue.getStringValue())) {\n              statement = new ExportDeclaration(statement.location, statement, []);\n            }\n            statements.push(statement);\n          }\n          return new AnonBlock(null, statements);\n        }\n        return $traceurRuntime.superGet(this, DestructuringTransformer.prototype, \"transformExportDeclaration\").call(this, tree);\n      },\n      desugarBinding_: function(bindingTree, statements, declarationType) {\n        var varName = this.getTempIdentifier();\n        var binding = createBindingIdentifier(varName);\n        var idExpr = createIdentifierExpression(varName);\n        var desugaring;\n        if (declarationType === null)\n          desugaring = new AssignmentExpressionDesugaring(idExpr);\n        else\n          desugaring = new VariableDeclarationDesugaring(idExpr);\n        this.desugarPattern_(desugaring, bindingTree);\n        if (declarationType === null) {\n          statements.push(createExpressionStatement(createCommaExpression(desugaring.expressions)));\n        } else {\n          statements.push(createVariableStatement(this.transformVariableDeclarationList(createVariableDeclarationList(declarationType, desugaring.declarations))));\n        }\n        return binding;\n      },\n      desugarVariableDeclaration_: function(tree) {\n        var tempRValueName = this.getTempIdentifier();\n        var tempRValueIdent = createIdentifierExpression(tempRValueName);\n        var desugaring;\n        var initializer;\n        switch (tree.initializer.type) {\n          case ARRAY_LITERAL:\n          case CALL_EXPRESSION:\n          case IDENTIFIER_EXPRESSION:\n          case LITERAL_EXPRESSION:\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n          case OBJECT_LITERAL:\n          case PAREN_EXPRESSION:\n            initializer = tree.initializer;\n        }\n        desugaring = new VariableDeclarationDesugaring(tempRValueIdent);\n        desugaring.assign(desugaring.rvalue, tree.initializer);\n        var initializerFound = this.desugarPattern_(desugaring, tree.lvalue);\n        if (initializerFound || desugaring.declarations.length > 2) {\n          return desugaring.declarations;\n        }\n        if (!initializer) {\n          initializer = createParenExpression(tree.initializer);\n        }\n        desugaring = new VariableDeclarationDesugaring(initializer);\n        this.desugarPattern_(desugaring, tree.lvalue);\n        return desugaring.declarations;\n      },\n      desugarPattern_: function(desugaring, tree) {\n        var $__4 = this;\n        var initializerFound = false;\n        var pattern;\n        switch (tree.type) {\n          case ARRAY_PATTERN:\n            {\n              pattern = tree;\n              this.pushTempScope();\n              var iterId = createIdentifierExpression(this.addTempVar());\n              var iterObjectId = createIdentifierExpression(this.addTempVar());\n              desugaring.createIterator(iterId);\n              for (var i = 0; i < pattern.elements.length; i++) {\n                var lvalue = pattern.elements[i];\n                if (lvalue === null) {\n                  desugaring.skipHole(iterId);\n                  continue;\n                } else if (lvalue.isSpreadPatternElement()) {\n                  var iteratorToArray = this.getRuntimeExpression('iteratorToArray');\n                  desugaring.assign(lvalue.lvalue, parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), iteratorToArray, iterId));\n                } else {\n                  if (lvalue.initializer) {\n                    initializerFound = true;\n                  }\n                  desugaring.assign(lvalue, this.createConditionalIterExpression(iterObjectId, iterId, lvalue.initializer));\n                }\n              }\n              this.popTempScope();\n              break;\n            }\n          case OBJECT_PATTERN:\n            {\n              pattern = tree;\n              var elementHelper = function(lvalue, initializer) {\n                if (initializer)\n                  initializerFound = true;\n                var lookup = $__4.createConditionalMemberExpression(desugaring.rvalue, lvalue, initializer);\n                desugaring.assign(lvalue, lookup);\n              };\n              pattern.fields.forEach(function(field) {\n                var lookup;\n                switch (field.type) {\n                  case ASSIGNMENT_ELEMENT:\n                    elementHelper(field.assignment, field.initializer);\n                    break;\n                  case BINDING_ELEMENT:\n                    elementHelper(field.binding, field.initializer);\n                    break;\n                  case OBJECT_PATTERN_FIELD:\n                    {\n                      if (field.element.initializer)\n                        initializerFound = true;\n                      var name = field.name;\n                      lookup = $__4.createConditionalMemberExpression(desugaring.rvalue, name, field.element.initializer);\n                      desugaring.assign(field.element, lookup);\n                      break;\n                    }\n                  default:\n                    throw Error('unreachable');\n                }\n              });\n              break;\n            }\n          case PAREN_EXPRESSION:\n            return this.desugarPattern_(desugaring, tree.expression);\n          default:\n            throw new Error('unreachable');\n        }\n        if (desugaring instanceof VariableDeclarationDesugaring && desugaring.declarations.length === 0) {\n          desugaring.assign(createBindingIdentifier(this.getTempIdentifier()), desugaring.rvalue);\n        }\n        return initializerFound;\n      },\n      createConditionalMemberExpression: function(rvalue, name, initializer) {\n        if (name.type === COMPUTED_PROPERTY_NAME) {\n          return this.createConditionalMemberLookupExpression(rvalue, name.expression, initializer);\n        }\n        var token;\n        switch (name.type) {\n          case BINDING_IDENTIFIER:\n          case IDENTIFIER_EXPRESSION:\n            token = name.identifierToken;\n            break;\n          default:\n            token = name.literalToken;\n        }\n        if (!initializer)\n          return createMemberExpression(rvalue, token);\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject([\"(\", \" = \", \".\", \") === void 0 ?\\n        \", \" : \", \"\"]), tempIdent, rvalue, token, initializer, tempIdent);\n      },\n      createConditionalMemberLookupExpression: function(rvalue, index, initializer) {\n        if (!initializer)\n          return createMemberLookupExpression(rvalue, index);\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject([\"(\", \" = \", \"[\", \"]) === void 0 ?\\n        \", \" : \", \"\"]), tempIdent, rvalue, index, initializer, tempIdent);\n      },\n      createConditionalIterExpression: function(iterObjectId, iterId, initializer) {\n        var expr = parseExpression($traceurRuntime.getTemplateObject([\"(\", \" =\\n        \", \".next()).done ? void 0 : \", \".value\"]), iterObjectId, iterId, iterObjectId);\n        if (!initializer) {\n          return expr;\n        }\n        var tempIdent = createIdentifierExpression(this.addTempVar());\n        return parseExpression($traceurRuntime.getTemplateObject([\"(\", \" = \", \") === void 0 ?\\n        \", \" : \", \"\"]), tempIdent, expr, initializer, tempIdent);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  function hasDestructuring(tree) {\n    return tree.declarations.some(function(declaration) {\n      return declaration.lvalue.isPattern();\n    });\n  }\n  return {get DestructuringTransformer() {\n      return DestructuringTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js\";\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/StringMap.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js\")).StringMap;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/assert.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleSymbol.js\")).assert;\n  var ExportsList = function() {\n    function ExportsList(normalizedName) {\n      this.exports_ = new StringMap();\n      if (normalizedName !== null)\n        this.normalizedName = normalizedName.replace(/\\\\/g, '/');\n      else\n        this.normalizedName = null;\n    }\n    return ($traceurRuntime.createClass)(ExportsList, {\n      addExport: function(name, tree) {\n        assert(!this.exports_.has(name));\n        this.exports_.set(name, tree);\n      },\n      getExport: function(name) {\n        return this.exports_.get(name);\n      },\n      getExports: function() {\n        return this.exports_.keysAsArray();\n      },\n      addExportsFromModule: function(module) {\n        var $__2 = this;\n        Object.getOwnPropertyNames(module).forEach(function(name) {\n          $__2.addExport(name, true);\n        });\n      }\n    }, {});\n  }();\n  var ModuleSymbol = function($__super) {\n    function ModuleSymbol(tree, normalizedName) {\n      $traceurRuntime.superConstructor(ModuleSymbol).call(this, normalizedName);\n      this.tree = tree;\n      this.imports_ = new StringMap();\n    }\n    return ($traceurRuntime.createClass)(ModuleSymbol, {\n      addImport: function(name, tree) {\n        assert(!this.imports_.has(name));\n        this.imports_.set(name, tree);\n      },\n      getImport: function(name) {\n        return this.imports_.get(name);\n      }\n    }, {}, $__super);\n  }(ExportsList);\n  return {\n    get ExportsList() {\n      return ExportsList;\n    },\n    get ModuleSymbol() {\n      return ModuleSymbol;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js\";\n  var ExportsList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleSymbol.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js\")).ExportsList;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js\")).ParseTreeVisitor;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleVisitor.js\")),\n      EXPORT_DECLARATION = $__3.EXPORT_DECLARATION,\n      IMPORT_DECLARATION = $__3.IMPORT_DECLARATION;\n  var ModuleVisitor = function($__super) {\n    function ModuleVisitor(reporter, loader, moduleSymbol) {\n      $traceurRuntime.superConstructor(ModuleVisitor).call(this);\n      this.reporter = reporter;\n      this.loader_ = loader;\n      this.moduleSymbol = moduleSymbol;\n    }\n    return ($traceurRuntime.createClass)(ModuleVisitor, {\n      getExportsListForModuleSpecifier: function(name) {\n        var referrer = this.moduleSymbol.normalizedName;\n        return this.loader_.getExportsListForModuleSpecifier(name, referrer);\n      },\n      visitFunctionDeclaration: function(tree) {},\n      visitFunctionExpression: function(tree) {},\n      visitFunctionBody: function(tree) {},\n      visitBlock: function(tree) {},\n      visitClassDeclaration: function(tree) {},\n      visitClassExpression: function(tree) {},\n      visitModuleElement_: function(element) {\n        switch (element.type) {\n          case EXPORT_DECLARATION:\n          case IMPORT_DECLARATION:\n            this.visitAny(element);\n        }\n      },\n      visitScript: function(tree) {\n        tree.scriptItemList.forEach(this.visitModuleElement_, this);\n      },\n      visitModule: function(tree) {\n        tree.scriptItemList.forEach(this.visitModuleElement_, this);\n      },\n      reportError: function(tree, message) {\n        this.reporter.reportError(tree.location, message);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ModuleVisitor() {\n      return ModuleVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ExportVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ExportVisitor.js\";\n  var ModuleVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ExportVisitor.js\")).ModuleVisitor;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/assert.js\", \"traceur@0.0.111/src/codegeneration/module/ExportVisitor.js\")).assert;\n  var ExportVisitor = function($__super) {\n    function ExportVisitor(reporter, loader, moduleSymbol) {\n      $traceurRuntime.superConstructor(ExportVisitor).call(this, reporter, loader, moduleSymbol);\n      this.inExport_ = false;\n      this.moduleSpecifier = null;\n    }\n    return ($traceurRuntime.createClass)(ExportVisitor, {\n      addExport_: function(name, tree) {\n        assert(typeof name === 'string');\n        if (this.inExport_)\n          this.addExport(name, tree);\n      },\n      addExport: function(name, tree) {\n        var moduleSymbol = this.moduleSymbol;\n        var existingExport = moduleSymbol.getExport(name);\n        if (existingExport) {\n          this.reportError(tree, (\"Duplicate export. '\" + name + \"' was previously \") + (\"exported at \" + existingExport.location.start));\n        } else {\n          moduleSymbol.addExport(name, tree);\n        }\n      },\n      visitClassDeclaration: function(tree) {\n        this.addExport_(tree.name.identifierToken.value, tree);\n      },\n      visitExportDeclaration: function(tree) {\n        this.inExport_ = true;\n        this.visitAny(tree.declaration);\n        this.inExport_ = false;\n      },\n      visitNamedExport: function(tree) {\n        this.moduleSpecifier = tree.moduleSpecifier;\n        this.visitAny(tree.exportClause);\n        this.moduleSpecifier = null;\n      },\n      visitExportDefault: function(tree) {\n        this.addExport_('default', tree);\n      },\n      visitExportSpecifier: function(tree) {\n        this.addExport_((tree.rhs || tree.lhs).value, tree);\n      },\n      visitExportStar: function(tree) {\n        var $__1 = this;\n        var name = this.moduleSpecifier.token.processedValue;\n        var exportList = this.getExportsListForModuleSpecifier(name);\n        if (exportList) {\n          exportList.getExports().forEach(function(name) {\n            return $__1.addExport(name, tree);\n          });\n        }\n      },\n      visitNameSpaceExport: function(tree) {\n        this.addExport_(tree.name.value, tree);\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.addExport_(tree.name.value, tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.addExport_(tree.name.getStringValue(), tree);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.addExport_(tree.getStringValue(), tree);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.addExport(tree.name.value, tree);\n      }\n    }, {}, $__super);\n  }(ModuleVisitor);\n  return {get ExportVisitor() {\n      return ExportVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js\";\n  var ExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ExportVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js\")).ExportVisitor;\n  var TYPE_ALIAS_DECLARATION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/module/DirectExportVisitor.js\")).TYPE_ALIAS_DECLARATION;\n  var DirectExportVisitor = function($__super) {\n    function DirectExportVisitor() {\n      $traceurRuntime.superConstructor(DirectExportVisitor).call(this, null, null, null);\n      this.namedExports = [];\n      this.starExports = [];\n    }\n    return ($traceurRuntime.createClass)(DirectExportVisitor, {\n      addExport: function(name, tree) {\n        this.namedExports.push({\n          name: name,\n          tree: tree,\n          moduleSpecifier: this.moduleSpecifier\n        });\n      },\n      visitExportStar: function(tree) {\n        this.starExports.push(this.moduleSpecifier);\n      },\n      hasExports: function() {\n        return this.namedExports.length !== 0 || this.starExports.length !== 0;\n      },\n      getNonTypeNamedExports: function() {\n        return this.namedExports.filter(function(exp) {\n          return exp.tree.type !== TYPE_ALIAS_DECLARATION;\n        });\n      }\n    }, {}, $__super);\n  }(ExportVisitor);\n  return {get DirectExportVisitor() {\n      return DirectExportVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\")),\n      AnonBlock = $__5.AnonBlock,\n      ImportDeclaration = $__5.ImportDeclaration,\n      ImportSpecifier = $__5.ImportSpecifier,\n      ImportSpecifierSet = $__5.ImportSpecifierSet,\n      Module = $__5.Module;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\")).ParseTreeTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\")),\n      ANON_BLOCK = $__7.ANON_BLOCK,\n      IMPORT_CLAUSE_PAIR = $__7.IMPORT_CLAUSE_PAIR,\n      IMPORT_DECLARATION = $__7.IMPORT_DECLARATION,\n      IMPORT_SPECIFIER_SET = $__7.IMPORT_SPECIFIER_SET,\n      IMPORTED_BINDING = $__7.IMPORTED_BINDING,\n      NAME_SPACE_IMPORT = $__7.NAME_SPACE_IMPORT;\n  var createIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ImportSimplifyingTransformer.js\")).createIdentifierToken;\n  var ImportSimplifyingTransformer = function($__super) {\n    function ImportSimplifyingTransformer() {\n      $traceurRuntime.superConstructor(ImportSimplifyingTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ImportSimplifyingTransformer, {\n      transformModule: function(tree) {\n        var $__2;\n        var statements = [];\n        for (var i = 0; i < tree.scriptItemList.length; i++) {\n          var item = tree.scriptItemList[i];\n          switch (item.type) {\n            case IMPORT_DECLARATION:\n              {\n                var transformed = this.transformAny(item);\n                if (transformed.type === ANON_BLOCK) {\n                  ($__2 = statements).push.apply($__2, $traceurRuntime.spread(transformed.statements));\n                } else {\n                  statements.push(transformed);\n                }\n                break;\n              }\n            default:\n              statements.push(item);\n          }\n        }\n        return new Module(tree.location, statements, tree.moduleName);\n      },\n      transformImportDeclaration: function(tree) {\n        var importClause = tree.importClause;\n        if (importClause === null) {\n          var set = new ImportSpecifierSet(null, []);\n          return new ImportDeclaration(tree.location, set, tree.moduleSpecifier);\n        }\n        if (importClause.type === NAME_SPACE_IMPORT) {\n          return tree;\n        }\n        if (importClause.type === IMPORTED_BINDING) {\n          var specifier = this.transformAny(importClause);\n          var set$__3 = new ImportSpecifierSet(null, [specifier]);\n          return new ImportDeclaration(tree.location, set$__3, tree.moduleSpecifier);\n        }\n        if (importClause.type === IMPORT_CLAUSE_PAIR) {\n          var $__1 = importClause,\n              first = $__1.first,\n              second = $__1.second;\n          if (second.type === IMPORT_SPECIFIER_SET) {\n            var defaultSpecifier = this.transformAny(first);\n            var specifiers = $traceurRuntime.spread([defaultSpecifier], second.specifiers);\n            var set$__4 = new ImportSpecifierSet(first.location, specifiers);\n            return new ImportDeclaration(tree.location, set$__4, tree.moduleSpecifier);\n          }\n          var firstImport = new ImportDeclaration(tree.location, first, tree.moduleSpecifier);\n          firstImport = this.transformAny(firstImport);\n          var secondImport = new ImportDeclaration(tree.location, second, tree.moduleSpecifier);\n          return new AnonBlock(null, [firstImport, secondImport]);\n        }\n        return $traceurRuntime.superGet(this, ImportSimplifyingTransformer.prototype, \"transformImportDeclaration\").call(this, tree);\n      },\n      transformImportSpecifier: function(tree) {\n        return tree;\n      },\n      transformImportedBinding: function(tree) {\n        var name = createIdentifierToken('default');\n        return new ImportSpecifier(tree.location, tree, name);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ImportSimplifyingTransformer() {\n      return ImportSimplifyingTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/util/url.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/util/url.js\";\n  var canonicalizeUrl = $traceurRuntime.canonicalizeUrl;\n  var isAbsolute = $traceurRuntime.isAbsolute;\n  var removeDotSegments = $traceurRuntime.removeDotSegments;\n  var resolveUrl = $traceurRuntime.resolveUrl;\n  return {\n    get canonicalizeUrl() {\n      return canonicalizeUrl;\n    },\n    get isAbsolute() {\n      return isAbsolute;\n    },\n    get removeDotSegments() {\n      return removeDotSegments;\n    },\n    get resolveUrl() {\n      return resolveUrl;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/SkipFunctionsTransformerTrait.js\")),\n      ArrowFunction = $__1.ArrowFunction,\n      FunctionDeclaration = $__1.FunctionDeclaration,\n      FunctionExpression = $__1.FunctionExpression,\n      GetAccessor = $__1.GetAccessor,\n      Method = $__1.Method,\n      SetAccessor = $__1.SetAccessor;\n  function SkipFunctionsTransformerTrait(ParseTreeTransformer) {\n    return function($__super) {\n      function SkipFunctionsTransformer() {\n        $traceurRuntime.superConstructor(SkipFunctionsTransformer).apply(this, arguments);\n      }\n      return ($traceurRuntime.createClass)(SkipFunctionsTransformer, {\n        transformFunctionDeclaration: function(tree) {\n          var annotations = this.transformList(tree.annotations);\n          if (annotations === tree.annotations) {\n            return tree;\n          }\n          return new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, annotations, tree.body);\n        },\n        transformFunctionExpression: function(tree) {\n          var annotations = this.transformList(tree.annotations);\n          if (annotations === tree.annotations) {\n            return tree;\n          }\n          return new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, annotations, tree.body);\n        },\n        transformSetAccessor: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new SetAccessor(tree.location, tree.isStatic, name, tree.parameterList, annotations, tree.body);\n        },\n        transformGetAccessor: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new GetAccessor(tree.location, tree.isStatic, name, annotations, tree.body);\n        },\n        transformMethod: function(tree) {\n          var name = this.transformAny(tree.name);\n          var annotations = this.transformList(tree.annotations);\n          if (name === tree.name && annotations === tree.annotations) {\n            return tree;\n          }\n          return new Method(tree.location, tree.isStatic, tree.functionKind, name, tree.parameterList, tree.typeAnnotation, annotations, tree.body, tree.debugName);\n        },\n        transformArrowFunction: function(tree) {\n          return tree;\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformer);\n  }\n  return {get default() {\n      return SkipFunctionsTransformerTrait;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\";\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")),\n      AnonBlock = $__8.AnonBlock,\n      BindingElement = $__8.BindingElement,\n      EmptyStatement = $__8.EmptyStatement,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      Module = $__8.Module,\n      ObjectPattern = $__8.ObjectPattern,\n      ObjectPatternField = $__8.ObjectPatternField,\n      Script = $__8.Script;\n  var DestructuringTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./DestructuringTransformer.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).DestructuringTransformer;\n  var DirectExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./module/DirectExportVisitor.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).DirectExportVisitor;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).default;\n  var ImportSimplifyingTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportSimplifyingTransformer.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).ImportSimplifyingTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).TempVarTransformer;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")),\n      CLASS_DECLARATION = $__14.CLASS_DECLARATION,\n      EXPORT_DEFAULT = $__14.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__14.EXPORT_SPECIFIER,\n      FORWARD_DEFAULT_EXPORT = $__14.FORWARD_DEFAULT_EXPORT,\n      FUNCTION_DECLARATION = $__14.FUNCTION_DECLARATION,\n      IMPORT_SPECIFIER_SET = $__14.IMPORT_SPECIFIER_SET,\n      IMPORT_TYPE_CLAUSE = $__14.IMPORT_TYPE_CLAUSE,\n      NAME_SPACE_EXPORT = $__14.NAME_SPACE_EXPORT;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).VAR;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).assert;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/url.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")),\n      resolveUrl = $__17.resolveUrl,\n      canonicalizeUrl = $__17.canonicalizeUrl;\n  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")),\n      createArgumentList = $__18.createArgumentList,\n      createExpressionStatement = $__18.createExpressionStatement,\n      createIdentifierExpression = $__18.createIdentifierExpression,\n      createIdentifierToken = $__18.createIdentifierToken,\n      createMemberExpression = $__18.createMemberExpression,\n      createObjectLiteral = $__18.createObjectLiteral,\n      createUseStrictDirective = $__18.createUseStrictDirective,\n      createVariableStatement = $__18.createVariableStatement,\n      createVoid0 = $__18.createVoid0;\n  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")),\n      parseExpression = $__19.parseExpression,\n      parsePropertyDefinition = $__19.parsePropertyDefinition,\n      parseStatement = $__19.parseStatement,\n      parseStatements = $__19.parseStatements;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SkipFunctionsTransformerTrait.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).default;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).ParseTreeTransformer;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/ModuleTransformer.js\")).prependStatements;\n  function removeUseStrictDirectives(tree) {\n    var result = tree.scriptItemList.filter(function(tree) {\n      return !tree.isUseStrictDirective();\n    });\n    return new Module(tree.location, result, tree.moduleName);\n  }\n  var DestructImportVarStatement = function($__super) {\n    function DestructImportVarStatement() {\n      $traceurRuntime.superConstructor(DestructImportVarStatement).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(DestructImportVarStatement, {createGuardedExpression: function(tree) {\n        return tree;\n      }}, {}, $__super);\n  }(DestructuringTransformer);\n  var ModuleTransformer = function($__super) {\n    function ModuleTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.exportVisitor = new DirectExportVisitor();\n      this.importSimplifier_ = new ImportSimplifyingTransformer();\n      this.moduleName = null;\n    }\n    return ($traceurRuntime.createClass)(ModuleTransformer, {\n      getTempVarNameForModuleName: function(moduleName) {\n        return '$__' + moduleName.replace(/[^a-zA-Z0-9$]/g, function(c) {\n          return '_' + String(c.charCodeAt(0)) + '_';\n        }) + '__';\n      },\n      getModuleName: function(tree) {\n        return tree.moduleName;\n      },\n      getTempVarNameForModuleSpecifier: function(moduleSpecifier) {\n        var name = moduleSpecifier.token.processedValue;\n        if (name[0] === '.' && this.moduleName) {\n          name = resolveUrl(this.moduleName, name);\n        } else {\n          name = canonicalizeUrl(name);\n        }\n        return this.getTempVarNameForModuleName(name);\n      },\n      transformScript: function(tree) {\n        this.moduleName = tree.moduleName;\n        return $traceurRuntime.superGet(this, ModuleTransformer.prototype, \"transformScript\").call(this, tree);\n      },\n      transformModule: function(tree) {\n        tree = removeUseStrictDirectives(tree);\n        tree = this.importSimplifier_.transformModule(tree);\n        var replaceThis = new ReplaceThis();\n        tree = replaceThis.transformAny(tree);\n        this.moduleName = this.getModuleName(tree);\n        this.pushTempScope();\n        var statements = this.transformList(tree.scriptItemList);\n        statements = this.addExportStatement(statements);\n        var runtimeImports = this.transformList(this.getRuntimeImports());\n        statements = prependStatements.apply((void 0), $traceurRuntime.spread([statements], runtimeImports));\n        this.popTempScope();\n        statements = this.wrapModule(this.moduleProlog().concat(statements));\n        return new Script(tree.location, statements, null);\n      },\n      moduleProlog: function() {\n        var statements = [createUseStrictDirective()];\n        if (this.moduleName) {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"var __moduleName = \", \";\"]), this.moduleName));\n        }\n        return statements;\n      },\n      wrapModule: function(statements) {\n        var functionExpression;\n        if (this.options.transformOptions.require) {\n          functionExpression = parseExpression($traceurRuntime.getTemplateObject([\"function(require) {\\n        \", \"\\n      }\"]), statements);\n        } else {\n          functionExpression = parseExpression($traceurRuntime.getTemplateObject([\"function() {\\n        \", \"\\n      }\"]), statements);\n        }\n        if (this.moduleName === null) {\n          return parseStatements($traceurRuntime.getTemplateObject([\"$traceurRuntime.ModuleStore.getAnonymousModule(\\n              \", \");\"]), functionExpression);\n        }\n        return parseStatements($traceurRuntime.getTemplateObject([\"$traceurRuntime.registerModule(\", \", [], \", \");\"]), this.moduleName, functionExpression);\n      },\n      getGetterExport: function(exp) {\n        var returnExpression = this.getGetterExportReturnExpression(exp);\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject([\"get \", \"() { return \", \"; }\"]), exp.name, returnExpression);\n      },\n      getGetterExportReturnExpression: function($__4) {\n        var $__5 = $__4,\n            name = $__5.name,\n            tree = $__5.tree,\n            moduleSpecifier = $__5.moduleSpecifier;\n        var returnExpression;\n        switch (tree.type) {\n          case EXPORT_DEFAULT:\n            switch (tree.expression.type) {\n              case CLASS_DECLARATION:\n              case FUNCTION_DECLARATION:\n                return createIdentifierExpression(tree.expression.name);\n              default:\n                return createIdentifierExpression('$__default');\n            }\n            break;\n          case EXPORT_SPECIFIER:\n            if (moduleSpecifier) {\n              var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createMemberExpression(idName, tree.lhs);\n            }\n            return createIdentifierExpression(tree.lhs);\n          case NAME_SPACE_EXPORT:\n            {\n              var idName$__6 = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createIdentifierExpression(idName$__6);\n            }\n          case FORWARD_DEFAULT_EXPORT:\n            {\n              var idName$__7 = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              return createMemberExpression(idName$__7, 'default');\n            }\n          default:\n            return createIdentifierExpression(name);\n        }\n      },\n      getExportProperties: function() {\n        var $__3 = this;\n        return this.exportVisitor.getNonTypeNamedExports().map(function(exp) {\n          return $__3.getGetterExport(exp);\n        }).concat(this.exportVisitor.namedExports.map(function(exp) {\n          return $__3.getSetterExport(exp);\n        })).filter(function(e) {\n          return e;\n        });\n      },\n      getSetterExport: function($__4) {\n        var $__5 = $__4,\n            name = $__5.name,\n            tree = $__5.tree,\n            moduleSpecifier = $__5.moduleSpecifier;\n        return null;\n      },\n      getExportObject: function() {\n        var exportObject = createObjectLiteral(this.getExportProperties());\n        if (this.hasStarExports()) {\n          return this.getExportStar(exportObject);\n        }\n        return exportObject;\n      },\n      getExportStar: function(exportObject) {\n        var $__3 = this;\n        var starExports = this.exportVisitor.starExports;\n        var starIdents = starExports.map(function(moduleSpecifier) {\n          return createIdentifierExpression($__3.getTempVarNameForModuleSpecifier(moduleSpecifier));\n        });\n        var args = createArgumentList($traceurRuntime.spread([exportObject], starIdents));\n        var runtime = this.getRuntimeExpression('exportStar');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), runtime, args);\n      },\n      addExportStatement: function(statements) {\n        var exportObject = this.getExportObject();\n        statements.push(parseStatement($traceurRuntime.getTemplateObject([\"return \", \"\"]), exportObject));\n        return statements;\n      },\n      hasExports: function() {\n        return this.exportVisitor.hasExports();\n      },\n      hasStarExports: function() {\n        return this.exportVisitor.starExports.length > 0;\n      },\n      transformExportDeclaration: function(tree) {\n        this.exportVisitor.visitAny(tree);\n        return this.transformAny(tree.declaration);\n      },\n      transformExportDefault: function(tree) {\n        switch (tree.expression.type) {\n          case CLASS_DECLARATION:\n          case FUNCTION_DECLARATION:\n            return tree.expression;\n        }\n        return parseStatement($traceurRuntime.getTemplateObject([\"var $__default = \", \"\"]), tree.expression);\n      },\n      transformNamedExport: function(tree) {\n        var moduleSpecifier = tree.moduleSpecifier;\n        if (moduleSpecifier) {\n          var expression = this.transformAny(moduleSpecifier);\n          var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n          return createVariableStatement(VAR, idName, expression);\n        }\n        return new AnonBlock(null, []);\n      },\n      transformModuleSpecifier: function(tree) {\n        assert(this.moduleName);\n        var name = tree.token.processedValue;\n        return parseExpression($traceurRuntime.getTemplateObject([\"$traceurRuntime.getModule(\\n      $traceurRuntime.normalizeModuleName(\", \", \", \"));\"]), name, this.moduleName);\n      },\n      transformImportDeclaration: function(tree) {\n        if (tree.importClause.type === IMPORT_TYPE_CLAUSE) {\n          return new AnonBlock(null, []);\n        }\n        if (tree.importClause.type === IMPORT_SPECIFIER_SET && tree.importClause.specifiers.length === 0) {\n          return createExpressionStatement(this.transformAny(tree.moduleSpecifier));\n        }\n        var binding = this.transformAny(tree.importClause);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        var varStatement = createVariableStatement(VAR, binding, initializer);\n        if (this.options.transformOptions.destructuring || !this.options.parseOptions.destructuring) {\n          var destructuringTransformer = new DestructImportVarStatement(this.identifierGenerator, this.reporter, this.options);\n          varStatement = varStatement.transform(destructuringTransformer);\n        }\n        return varStatement;\n      },\n      transformImportSpecifierSet: function(tree) {\n        var fields = this.transformList(tree.specifiers);\n        return new ObjectPattern(null, fields);\n      },\n      transformNameSpaceImport: function(tree) {\n        return tree.binding.binding;\n      },\n      transformImportSpecifier: function(tree) {\n        var binding = tree.binding.binding;\n        var bindingElement = new BindingElement(binding.location, binding, null);\n        if (tree.name) {\n          var name = new LiteralPropertyName(tree.name.location, tree.name);\n          return new ObjectPatternField(tree.location, name, bindingElement);\n        }\n        return bindingElement;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  var ReplaceThis = function($__super) {\n    function ReplaceThis() {\n      $traceurRuntime.superConstructor(ReplaceThis).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ReplaceThis, {transformThisExpression: function(tree) {\n        return createVoid0();\n      }}, {}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get ModuleTransformer() {\n      return ModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/globalThis.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/globalThis.js\";\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/globalThis.js\")).parseExpression;\n  var expr;\n  function globalThis() {\n    if (!expr)\n      expr = parseExpression($traceurRuntime.getTemplateObject([\"Reflect.global\"]));\n    return expr;\n  }\n  var $__default = globalThis;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AmdTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\")).ModuleTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\")),\n      createIdentifierExpression = $__3.createIdentifierExpression,\n      createFormalParameter = $__3.createFormalParameter,\n      createStringLiteralToken = $__3.createStringLiteralToken;\n  var globalThis = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./globalThis.js\", \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\")).default;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\")),\n      parseExpression = $__5.parseExpression,\n      parseStatement = $__5.parseStatement,\n      parseStatements = $__5.parseStatements,\n      parsePropertyDefinition = $__5.parsePropertyDefinition;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AmdTransformer.js\")),\n      FormalParameterList = $__6.FormalParameterList,\n      FunctionBody = $__6.FunctionBody,\n      FunctionExpression = $__6.FunctionExpression;\n  var AmdTransformer = function($__super) {\n    function AmdTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(AmdTransformer).call(this, identifierGenerator, reporter, options);\n      this.dependencies = [];\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n    }\n    return ($traceurRuntime.createClass)(AmdTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      getExportProperties: function() {\n        var properties = $traceurRuntime.superGet(this, AmdTransformer.prototype, \"getExportProperties\").call(this);\n        if (this.exportVisitor.hasExports())\n          properties.push(parsePropertyDefinition($traceurRuntime.getTemplateObject([\"__esModule: true\"])));\n        return properties;\n      },\n      moduleProlog: function() {\n        var locals = this.dependencies.map(function(dep) {\n          var local = createIdentifierExpression(dep.local);\n          return parseStatement($traceurRuntime.getTemplateObject([\"if (!\", \" || !\", \".__esModule)\\n            \", \" = {default: \", \"}\"]), local, local, local, local);\n        });\n        return $traceurRuntime.superGet(this, AmdTransformer.prototype, \"moduleProlog\").call(this).concat(locals);\n      },\n      wrapModule: function(statements) {\n        var depPaths = this.dependencies.map(function(dep) {\n          return dep.path;\n        });\n        var formals = this.dependencies.map(function(dep) {\n          return createFormalParameter(dep.local);\n        });\n        var parameterList = new FormalParameterList(null, formals);\n        var body = new FunctionBody(null, statements);\n        var func = new FunctionExpression(null, null, null, parameterList, null, [], body);\n        if (this.moduleName) {\n          return parseStatements($traceurRuntime.getTemplateObject([\"define(\", \", \", \", \", \");\"]), this.moduleName, depPaths, func);\n        } else {\n          return parseStatements($traceurRuntime.getTemplateObject([\"define(\", \", \", \");\"]), depPaths, func);\n        }\n      },\n      transformModuleSpecifier: function(tree) {\n        var localName = this.getTempIdentifier();\n        var value = tree.token.processedValue;\n        var stringLiteral = createStringLiteralToken(value.replace(/\\.js$/, ''));\n        this.dependencies.push({\n          path: stringLiteral,\n          local: localName\n        });\n        return createIdentifierExpression(localName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get AmdTransformer() {\n      return AmdTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/staticsemantics/PropName.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/staticsemantics/PropName.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/staticsemantics/PropName.js\")),\n      COMPUTED_PROPERTY_NAME = $__0.COMPUTED_PROPERTY_NAME,\n      GET_ACCESSOR = $__0.GET_ACCESSOR,\n      LITERAL_PROPERTY_NAME = $__0.LITERAL_PROPERTY_NAME,\n      METHOD = $__0.METHOD,\n      PROPERTY_NAME_ASSIGNMENT = $__0.PROPERTY_NAME_ASSIGNMENT,\n      PROPERTY_NAME_SHORTHAND = $__0.PROPERTY_NAME_SHORTHAND,\n      SET_ACCESSOR = $__0.SET_ACCESSOR;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/staticsemantics/PropName.js\")).IDENTIFIER;\n  function propName(tree) {\n    switch (tree.type) {\n      case LITERAL_PROPERTY_NAME:\n        {\n          var token = tree.literalToken;\n          if (token.isKeyword() || token.type === IDENTIFIER)\n            return token.toString();\n          return String(tree.literalToken.processedValue);\n        }\n      case COMPUTED_PROPERTY_NAME:\n        return '';\n      case PROPERTY_NAME_SHORTHAND:\n        return tree.name.toString();\n      case METHOD:\n      case PROPERTY_NAME_ASSIGNMENT:\n      case GET_ACCESSOR:\n      case SET_ACCESSOR:\n        return propName(tree.name);\n    }\n  }\n  return {get propName() {\n      return propName;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")).ParseTreeTransformer;\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")).CONSTRUCTOR;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")).STRING;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")),\n      AnonBlock = $__8.AnonBlock,\n      ClassDeclaration = $__8.ClassDeclaration,\n      ExportDeclaration = $__8.ExportDeclaration,\n      FormalParameter = $__8.FormalParameter,\n      FunctionDeclaration = $__8.FunctionDeclaration,\n      GetAccessor = $__8.GetAccessor,\n      LiteralExpression = $__8.LiteralExpression,\n      Method = $__8.Method,\n      SetAccessor = $__8.SetAccessor;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../staticsemantics/PropName.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")).propName;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")),\n      createArgumentList = $__10.createArgumentList,\n      createArrayLiteral = $__10.createArrayLiteral,\n      createAssignmentStatement = $__10.createAssignmentStatement,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createNewExpression = $__10.createNewExpression,\n      createStringLiteralToken = $__10.createStringLiteralToken;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/AnnotationsTransformer.js\")),\n      parseExpression = $__11.parseExpression,\n      parseStatement = $__11.parseStatement;\n  var AnnotationsScope = function() {\n    function AnnotationsScope() {\n      this.className = null;\n      this.isExport = false;\n      this.constructorParameters = [];\n      this.annotations = [];\n      this.metadata = [];\n    }\n    return ($traceurRuntime.createClass)(AnnotationsScope, {get inClassScope() {\n        return this.className !== null;\n      }}, {});\n  }();\n  var AnnotationsTransformer = function($__super) {\n    function AnnotationsTransformer() {\n      $traceurRuntime.superConstructor(AnnotationsTransformer).call(this);\n      this.stack_ = [new AnnotationsScope()];\n    }\n    return ($traceurRuntime.createClass)(AnnotationsTransformer, {\n      transformExportDeclaration: function(tree) {\n        var $__3;\n        var scope = this.pushAnnotationScope_();\n        scope.isExport = true;\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(tree.annotations));\n        var declaration = this.transformAny(tree.declaration);\n        if (declaration !== tree.declaration || tree.annotations.length > 0)\n          tree = new ExportDeclaration(tree.location, declaration, []);\n        return this.appendMetadata_(tree);\n      },\n      transformClassDeclaration: function(tree) {\n        var $__3,\n            $__4;\n        var elementsChanged = false;\n        var exportAnnotations = this.scope.isExport ? this.scope.annotations : [];\n        var scope = this.pushAnnotationScope_();\n        scope.className = tree.name;\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(exportAnnotations, tree.annotations));\n        tree = $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformClassDeclaration\").call(this, tree);\n        ($__4 = scope.metadata).unshift.apply($__4, $traceurRuntime.spread(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, scope.constructorParameters)));\n        if (tree.annotations.length > 0) {\n          tree = new ClassDeclaration(tree.location, tree.name, tree.superClass, tree.elements, [], null);\n        }\n        return this.appendMetadata_(tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var $__3,\n            $__4;\n        var exportAnnotations = this.scope.isExport ? this.scope.annotations : [];\n        var scope = this.pushAnnotationScope_();\n        ($__3 = scope.annotations).push.apply($__3, $traceurRuntime.spread(exportAnnotations, tree.annotations));\n        ($__4 = scope.metadata).push.apply($__4, $traceurRuntime.spread(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, tree.parameterList.parameters)));\n        tree = $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n        if (tree.annotations.length > 0) {\n          tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, [], tree.body);\n        }\n        return this.appendMetadata_(tree);\n      },\n      transformFormalParameter: function(tree) {\n        if (tree.annotations.length > 0) {\n          tree = new FormalParameter(tree.location, tree.parameter, tree.typeAnnotation, []);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformFormalParameter\").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        var $__3;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformGetAccessor\").call(this, tree);\n        ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, 'get'), tree.annotations, [])));\n        if (tree.annotations.length > 0) {\n          tree = new GetAccessor(tree.location, tree.isStatic, tree.name, tree.typeAnnotation, [], tree.body);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformGetAccessor\").call(this, tree);\n      },\n      transformSetAccessor: function(tree) {\n        var $__3;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformSetAccessor\").call(this, tree);\n        ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, 'set'), tree.annotations, tree.parameterList.parameters)));\n        var parameterList = this.transformAny(tree.parameterList);\n        if (parameterList !== tree.parameterList || tree.annotations.length > 0) {\n          tree = new SetAccessor(tree.location, tree.isStatic, tree.name, parameterList, [], tree.body);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformSetAccessor\").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        var $__3,\n            $__4;\n        if (!this.scope.inClassScope)\n          return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformMethod\").call(this, tree);\n        if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {\n          ($__3 = this.scope.annotations).push.apply($__3, $traceurRuntime.spread(tree.annotations));\n          this.scope.constructorParameters = tree.parameterList.parameters;\n        } else {\n          ($__4 = this.scope.metadata).push.apply($__4, $traceurRuntime.spread(this.transformMetadata_(this.transformPropertyMethod_(tree, this.scope.className), tree.annotations, tree.parameterList.parameters)));\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        if (parameterList !== tree.parameterList || tree.annotations.length > 0) {\n          tree = new Method(tree.location, tree.isStatic, tree.functionKind, tree.name, parameterList, tree.typeAnnotation, [], tree.body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, AnnotationsTransformer.prototype, \"transformMethod\").call(this, tree);\n      },\n      appendMetadata_: function(tree) {\n        var $__3;\n        var metadata = this.stack_.pop().metadata;\n        if (metadata.length > 0) {\n          if (this.scope.isExport) {\n            ($__3 = this.scope.metadata).push.apply($__3, $traceurRuntime.spread(metadata));\n          } else {\n            tree = new AnonBlock(null, $traceurRuntime.spread([tree], metadata));\n          }\n        }\n        return tree;\n      },\n      transformClassReference_: function(tree, className) {\n        var parent = createIdentifierExpression(className);\n        if (!tree.isStatic)\n          parent = createMemberExpression(parent, 'prototype');\n        return parent;\n      },\n      transformPropertyMethod_: function(tree, className) {\n        return createMemberExpression(this.transformClassReference_(tree, className), tree.name.literalToken);\n      },\n      transformAccessor_: function(tree, className, accessor) {\n        var args = createArgumentList([this.transformClassReference_(tree, className), this.createLiteralStringExpression_(tree.name)]);\n        var descriptor = parseExpression($traceurRuntime.getTemplateObject([\"Object.getOwnPropertyDescriptor(\", \")\"]), args);\n        return createMemberExpression(descriptor, accessor);\n      },\n      transformParameters_: function(parameters) {\n        var $__2 = this;\n        var hasParameterMetadata = false;\n        parameters = parameters.map(function(param) {\n          var $__3;\n          var metadata = [];\n          if (param.typeAnnotation)\n            metadata.push($__2.transformAny(param.typeAnnotation));\n          if (param.annotations && param.annotations.length > 0)\n            ($__3 = metadata).push.apply($__3, $traceurRuntime.spread($__2.transformAnnotations_(param.annotations)));\n          if (metadata.length > 0) {\n            hasParameterMetadata = true;\n            return createArrayLiteral(metadata);\n          }\n          return createArrayLiteral([]);\n        });\n        return hasParameterMetadata ? parameters : [];\n      },\n      transformAnnotations_: function(annotations) {\n        return annotations.map(function(annotation) {\n          return createNewExpression(annotation.name, annotation.args);\n        });\n      },\n      transformMetadata_: function(target, annotations, parameters) {\n        var metadataStatements = [];\n        if (annotations !== null) {\n          annotations = this.transformAnnotations_(annotations);\n          if (annotations.length > 0) {\n            metadataStatements.push(this.createDefinePropertyStatement_(target, 'annotations', createArrayLiteral(annotations)));\n          }\n        }\n        if (parameters !== null) {\n          parameters = this.transformParameters_(parameters);\n          if (parameters.length > 0) {\n            metadataStatements.push(this.createDefinePropertyStatement_(target, 'parameters', createArrayLiteral(parameters)));\n          }\n        }\n        return metadataStatements;\n      },\n      createDefinePropertyStatement_: function(target, property, value) {\n        return parseStatement($traceurRuntime.getTemplateObject([\"Object.defineProperty(\", \", \", \",\\n        {get: function() {return \", \"}});\"]), target, property, value);\n      },\n      createLiteralStringExpression_: function(tree) {\n        var token = tree.literalToken;\n        if (tree.literalToken.type !== STRING)\n          token = createStringLiteralToken(tree.literalToken.value);\n        return new LiteralExpression(null, token);\n      },\n      get scope() {\n        return this.stack_[this.stack_.length - 1];\n      },\n      pushAnnotationScope_: function() {\n        var scope = new AnnotationsScope();\n        this.stack_.push(scope);\n        return scope;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get AnnotationsTransformer() {\n      return AnnotationsTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FindInFunctionScope.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FindInFunctionScope.js\";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindVisitor.js\", \"traceur@0.0.111/src/codegeneration/FindInFunctionScope.js\")).FindVisitor;\n  var FindInFunctionScope = function($__super) {\n    function FindInFunctionScope() {\n      $traceurRuntime.superConstructor(FindInFunctionScope).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindInFunctionScope, {\n      visitFunctionDeclaration: function(tree) {\n        this.visitList(tree.annotations);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitList(tree.annotations);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n        this.visitList(tree.annotations);\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get FindInFunctionScope() {\n      return FindInFunctionScope;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/util.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/util.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/util.js\")),\n      IDENTIFIER_EXPRESSION = $__0.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__0.LITERAL_EXPRESSION,\n      PAREN_EXPRESSION = $__0.PAREN_EXPRESSION,\n      UNARY_EXPRESSION = $__0.UNARY_EXPRESSION;\n  var UNDEFINED = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/semantics/util.js\")).UNDEFINED;\n  var VOID = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/util.js\")).VOID;\n  function hasUseStrict(list) {\n    for (var i = 0; i < list.length; i++) {\n      if (!list[i].isDirectivePrologue())\n        return false;\n      if (list[i].isUseStrictDirective())\n        return true;\n    }\n    return false;\n  }\n  function isUndefined(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isUndefined(tree.expression);\n    return tree.type === IDENTIFIER_EXPRESSION && tree.identifierToken.value === UNDEFINED;\n  }\n  function isVoidExpression(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isVoidExpression(tree.expression);\n    return tree.type === UNARY_EXPRESSION && tree.operator.type === VOID && isLiteralExpression(tree.operand);\n  }\n  function isLiteralExpression(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return isLiteralExpression(tree.expression);\n    return tree.type === LITERAL_EXPRESSION;\n  }\n  return {\n    get hasUseStrict() {\n      return hasUseStrict;\n    },\n    get isUndefined() {\n      return isUndefined;\n    },\n    get isVoidExpression() {\n      return isVoidExpression;\n    },\n    get isLiteralExpression() {\n      return isLiteralExpression;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/isTreeStrict.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/isTreeStrict.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/isTreeStrict.js\")),\n      ARROW_FUNCTION = $__0.ARROW_FUNCTION,\n      CLASS_DECLARATION = $__0.CLASS_DECLARATION,\n      CLASS_EXPRESSION = $__0.CLASS_EXPRESSION,\n      FUNCTION_BODY = $__0.FUNCTION_BODY,\n      FUNCTION_DECLARATION = $__0.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__0.FUNCTION_EXPRESSION,\n      GET_ACCESSOR = $__0.GET_ACCESSOR,\n      METHOD = $__0.METHOD,\n      MODULE = $__0.MODULE,\n      SCRIPT = $__0.SCRIPT,\n      SET_ACCESSOR = $__0.SET_ACCESSOR;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util.js\", \"traceur@0.0.111/src/semantics/isTreeStrict.js\")).hasUseStrict;\n  function isTreeStrict(tree) {\n    switch (tree.type) {\n      case CLASS_DECLARATION:\n      case CLASS_EXPRESSION:\n      case MODULE:\n        return true;\n      case FUNCTION_BODY:\n        return hasUseStrict(tree.statements);\n      case FUNCTION_EXPRESSION:\n      case FUNCTION_DECLARATION:\n      case METHOD:\n        return isTreeStrict(tree.body);\n      case ARROW_FUNCTION:\n        if (tree.body.type === FUNCTION_BODY) {\n          return isTreeStrict(tree.body);\n        }\n        return false;\n      case GET_ACCESSOR:\n      case SET_ACCESSOR:\n        return isTreeStrict(tree.body);\n      case SCRIPT:\n        return hasUseStrict(tree.scriptItemList);\n      default:\n        return false;\n    }\n  }\n  return {get isTreeStrict() {\n      return isTreeStrict;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/Scope.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/Scope.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/Scope.js\")),\n      BLOCK = $__2.BLOCK,\n      CATCH = $__2.CATCH,\n      FUNCTION_EXPRESSION = $__2.FUNCTION_EXPRESSION;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringMap.js\", \"traceur@0.0.111/src/semantics/Scope.js\")).StringMap;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/Scope.js\")).VAR;\n  var isTreeStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./isTreeStrict.js\", \"traceur@0.0.111/src/semantics/Scope.js\")).isTreeStrict;\n  function reportDuplicateVar(reporter, tree, name) {\n    reporter.reportError(tree.location, (\"Duplicate declaration, \" + name));\n  }\n  var Scope = function() {\n    function Scope(parent, tree) {\n      this.parent = parent;\n      this.tree = tree;\n      this.variableDeclarations_ = new StringMap();\n      this.lexicalDeclarations_ = new StringMap();\n      this.strictMode = parent && parent.strictMode || isTreeStrict(tree);\n      this.inGenerator = parent ? parent.inGenerator || false : false;\n    }\n    return ($traceurRuntime.createClass)(Scope, {\n      addBinding: function(tree, type, reporter) {\n        if (type === VAR) {\n          this.addVar(tree, reporter);\n        } else {\n          this.addDeclaration(tree, type, reporter);\n        }\n      },\n      addVar: function(tree, reporter) {\n        var name = tree.getStringValue();\n        if (this.lexicalDeclarations_.has(name) && !this.isFunctionExpressionName(name)) {\n          reportDuplicateVar(reporter, tree, name);\n          return;\n        }\n        this.variableDeclarations_.set(name, {\n          type: VAR,\n          tree: tree,\n          scope: this\n        });\n        if (!this.isVarScope && this.parent) {\n          this.parent.addVar(tree, reporter);\n        }\n      },\n      addDeclaration: function(tree, type, reporter) {\n        var name = tree.getStringValue();\n        if ((this.lexicalDeclarations_.has(name) || this.variableDeclarations_.has(name)) && !this.isFunctionExpressionName(name)) {\n          reportDuplicateVar(reporter, tree, name);\n          return;\n        }\n        this.lexicalDeclarations_.set(name, {\n          type: type,\n          tree: tree,\n          scope: this\n        });\n      },\n      renameBinding: function(oldName, newTree, newType, reporter) {\n        var name = newTree.getStringValue();\n        if (newType === VAR) {\n          if (this.lexicalDeclarations_.has(oldName)) {\n            this.lexicalDeclarations_.delete(oldName);\n            this.addVar(newTree, reporter);\n          }\n        } else if (this.variableDeclarations_.has(oldName)) {\n          this.variableDeclarations_.delete(oldName);\n          this.addDeclaration(newTree, newType, reporter);\n          if (!this.isVarScope && this.parent) {\n            this.parent.renameBinding(oldName, newTree, newType);\n          }\n        }\n      },\n      get isVarScope() {\n        switch (this.tree.type) {\n          case BLOCK:\n          case CATCH:\n            return false;\n        }\n        return true;\n      },\n      getVarScope: function() {\n        if (this.isVarScope) {\n          return this;\n        }\n        if (this.parent) {\n          return this.parent.getVarScope();\n        }\n        return null;\n      },\n      isFunctionExpressionName: function(name) {\n        var b = this.getBindingByName(name);\n        return b && b.scope.tree.type === FUNCTION_EXPRESSION && b.scope.tree.name === b.tree;\n      },\n      getBinding: function(tree) {\n        var name = tree.getStringValue();\n        return this.getBindingByName(name);\n      },\n      getBindingByName: function(name) {\n        var b = this.variableDeclarations_.get(name);\n        if (b && this.isVarScope) {\n          return b;\n        }\n        b = this.lexicalDeclarations_.get(name);\n        if (b) {\n          return b;\n        }\n        if (this.parent) {\n          return this.parent.getBindingByName(name);\n        }\n        return null;\n      },\n      getAllBindingNames: function() {\n        var names = this.variableDeclarations_.keysAsSet();\n        this.lexicalDeclarations_.forEach(function(name) {\n          return names.add(name);\n        });\n        return names;\n      },\n      getVariableBindingNames: function() {\n        return this.variableDeclarations_.keysAsSet();\n      },\n      getLexicalBindingNames: function() {\n        return this.lexicalDeclarations_.keysAsSet();\n      },\n      hasBindingName: function(name) {\n        return this.lexicalDeclarations_.has(name) || this.variableDeclarations_.has(name);\n      },\n      hasLexicalBindingName: function(name) {\n        return this.lexicalDeclarations_.has(name);\n      },\n      hasVariableBindingName: function(name) {\n        return this.variableDeclarations_.has(name);\n      }\n    }, {});\n  }();\n  return {get Scope() {\n      return Scope;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ScopeVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ScopeVisitor.js\";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/semantics/ScopeVisitor.js\")).ParseTreeVisitor;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/ScopeVisitor.js\")).VAR;\n  var Scope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Scope.js\", \"traceur@0.0.111/src/semantics/ScopeVisitor.js\")).Scope;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/ScopeVisitor.js\")),\n      COMPREHENSION_FOR = $__6.COMPREHENSION_FOR,\n      VARIABLE_DECLARATION_LIST = $__6.VARIABLE_DECLARATION_LIST;\n  var ScopeVisitor = function($__super) {\n    function ScopeVisitor() {\n      $traceurRuntime.superConstructor(ScopeVisitor).call(this);\n      this.map_ = new Map();\n      this.scope = null;\n      this.withBlockCounter_ = 0;\n    }\n    return ($traceurRuntime.createClass)(ScopeVisitor, {\n      getScopeForTree: function(tree) {\n        return this.map_.get(tree);\n      },\n      createScope: function(tree) {\n        return new Scope(this.scope, tree);\n      },\n      pushScope: function(tree) {\n        var scope = this.createScope(tree);\n        this.map_.set(tree, scope);\n        return this.scope = scope;\n      },\n      popScope: function(scope) {\n        if (this.scope !== scope) {\n          throw new Error('ScopeVisitor scope mismatch');\n        }\n        this.scope = scope.parent;\n      },\n      visitScript: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, \"visitScript\").call(this, tree);\n        this.popScope(scope);\n      },\n      visitModule: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, \"visitModule\").call(this, tree);\n        this.popScope(scope);\n      },\n      visitBlock: function(tree) {\n        var scope = this.pushScope(tree);\n        $traceurRuntime.superGet(this, ScopeVisitor.prototype, \"visitBlock\").call(this, tree);\n        this.popScope(scope);\n      },\n      visitCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        this.visitAny(tree.binding);\n        this.visitList(tree.catchBody.statements);\n        this.popScope(scope);\n      },\n      visitFunctionBodyForScope: function(tree) {\n        var parameterList = arguments[1] !== (void 0) ? arguments[1] : tree.parameterList;\n        var scope = this.pushScope(tree);\n        this.visitAny(parameterList);\n        scope.inGenerator = tree.functionKind && tree.isGenerator();\n        this.visitAny(tree.body);\n        this.popScope(scope);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitAny(tree.name);\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitArrowFunction: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitFunctionBodyForScope(tree, null);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitMethod: function(tree) {\n        this.visitFunctionBodyForScope(tree);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope = this.pushScope(tree);\n        this.visitAny(tree.name);\n        this.visitList(tree.elements);\n        this.popScope(scope);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope;\n        if (tree.name) {\n          scope = this.pushScope(tree);\n          this.visitAny(tree.name);\n        }\n        this.visitList(tree.elements);\n        if (tree.name) {\n          this.popScope(scope);\n        }\n      },\n      visitWithStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.withBlockCounter_++;\n        this.visitAny(tree.body);\n        this.withBlockCounter_--;\n      },\n      get inWithBlock() {\n        return this.withBlockCounter_ > 0;\n      },\n      visitLoop_: function(tree, func) {\n        if (tree.initializer.type !== VARIABLE_DECLARATION_LIST || tree.initializer.declarationType === VAR) {\n          func();\n          return;\n        }\n        var scope = this.pushScope(tree);\n        func();\n        this.popScope(scope);\n      },\n      visitForInStatement: function(tree) {\n        var $__1 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, \"visitForInStatement\").call($__1, tree);\n        });\n      },\n      visitForOfStatement: function(tree) {\n        var $__1 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, \"visitForOfStatement\").call($__1, tree);\n        });\n      },\n      visitForStatement: function(tree) {\n        var $__1 = this;\n        if (!tree.initializer) {\n          $traceurRuntime.superGet(this, ScopeVisitor.prototype, \"visitForStatement\").call(this, tree);\n        } else {\n          this.visitLoop_(tree, function() {\n            return $traceurRuntime.superGet($__1, ScopeVisitor.prototype, \"visitForStatement\").call($__1, tree);\n          });\n        }\n      },\n      visitComprehension_: function(tree) {\n        var scopes = [];\n        for (var i = 0; i < tree.comprehensionList.length; i++) {\n          var scope = null;\n          if (tree.comprehensionList[i].type === COMPREHENSION_FOR) {\n            scope = this.pushScope(tree.comprehensionList[i]);\n          }\n          scopes.push(scope);\n          this.visitAny(tree.comprehensionList[i]);\n        }\n        this.visitAny(tree.expression);\n        for (var i$__2 = scopes.length - 1; i$__2 >= 0; i$__2--) {\n          if (scopes[i$__2]) {\n            this.popScope(scopes[i$__2]);\n          }\n        }\n      },\n      visitArrayComprehension: function(tree) {\n        this.visitComprehension_(tree);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.visitComprehension_(tree);\n      },\n      visitPredefinedType: function(tree) {},\n      visitTypeArguments: function(tree) {},\n      visitFunctionType: function(tree) {}\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ScopeVisitor() {\n      return ScopeVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ScopeChainBuilder.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ScopeChainBuilder.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilder.js\")),\n      CONST = $__1.CONST,\n      LET = $__1.LET,\n      VAR = $__1.VAR;\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeVisitor.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilder.js\")).ScopeVisitor;\n  var ScopeChainBuilder = function($__super) {\n    function ScopeChainBuilder(reporter) {\n      $traceurRuntime.superConstructor(ScopeChainBuilder).call(this);\n      this.reporter = reporter;\n      this.declarationType_ = null;\n    }\n    return ($traceurRuntime.createClass)(ScopeChainBuilder, {\n      visitCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        this.declarationType_ = LET;\n        this.visitAny(tree.binding);\n        this.visitList(tree.catchBody.statements);\n        this.popScope(scope);\n      },\n      visitImportedBinding: function(tree) {\n        this.declarationType_ = CONST;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, \"visitImportedBinding\").call(this, tree);\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.declarationType_ = tree.declarationType;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, \"visitVariableDeclarationList\").call(this, tree);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.declareVariable(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        var scope = this.pushScope(tree);\n        if (tree.name) {\n          this.declarationType_ = CONST;\n          this.visitAny(tree.name);\n        }\n        this.visitAny(tree.parameterList);\n        scope.inGenerator = tree.isGenerator();\n        this.visitAny(tree.body);\n        this.popScope(scope);\n      },\n      visitFormalParameter: function(tree) {\n        this.declarationType_ = VAR;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, \"visitFormalParameter\").call(this, tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        if (this.scope) {\n          if (this.scope.isVarScope) {\n            this.declarationType_ = VAR;\n            this.visitAny(tree.name);\n          } else {\n            if (!this.scope.strictMode) {\n              var varScope = this.scope.getVarScope();\n              if (varScope) {\n                varScope.addVar(tree.name, this.reporter);\n              }\n            }\n            this.declarationType_ = LET;\n            this.visitAny(tree.name);\n          }\n        }\n        this.visitFunctionBodyForScope(tree, tree.parameterList, tree.body);\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitAny(tree.superClass);\n        this.declarationType_ = LET;\n        this.visitAny(tree.name);\n        var scope = this.pushScope(tree);\n        this.declarationType_ = CONST;\n        this.visitAny(tree.name);\n        this.visitList(tree.elements);\n        this.popScope(scope);\n      },\n      visitClassExpression: function(tree) {\n        this.visitAny(tree.superClass);\n        var scope;\n        if (tree.name) {\n          scope = this.pushScope(tree);\n          this.declarationType_ = CONST;\n          this.visitAny(tree.name);\n        }\n        this.visitList(tree.elements);\n        if (tree.name) {\n          this.popScope(scope);\n        }\n      },\n      visitComprehensionFor: function(tree) {\n        this.declarationType_ = LET;\n        $traceurRuntime.superGet(this, ScopeChainBuilder.prototype, \"visitComprehensionFor\").call(this, tree);\n      },\n      declareVariable: function(tree) {\n        this.scope.addBinding(tree, this.declarationType_, this.reporter);\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  return {get ScopeChainBuilder() {\n      return ScopeChainBuilder;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/VariableBinder.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/VariableBinder.js\";\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeChainBuilder.js\", \"traceur@0.0.111/src/semantics/VariableBinder.js\")).ScopeChainBuilder;\n  function variablesInBlock(tree) {\n    var includeFunctionScope = arguments[1];\n    var builder = new ScopeChainBuilder(null);\n    builder.visitAny(tree);\n    var scope = builder.getScopeForTree(tree);\n    var names = scope.getLexicalBindingNames();\n    if (!includeFunctionScope) {\n      return names;\n    }\n    var variableBindingNames = scope.getVariableBindingNames();\n    variableBindingNames.forEach(function(name) {\n      return names.add(name);\n    });\n    return names;\n  }\n  function variablesInFunction(tree) {\n    var builder = new ScopeChainBuilder(null);\n    builder.visitAny(tree);\n    var scope = builder.getScopeForTree(tree);\n    return scope.getAllBindingNames();\n  }\n  return {\n    get variablesInBlock() {\n      return variablesInBlock;\n    },\n    get variablesInFunction() {\n      return variablesInFunction;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")),\n      ARGUMENTS = $__4.ARGUMENTS,\n      THIS = $__4.THIS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")).FindInFunctionScope;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")).ParseTreeTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")),\n      FunctionDeclaration = $__7.FunctionDeclaration,\n      FunctionExpression = $__7.FunctionExpression,\n      GetAccessor = $__7.GetAccessor,\n      Method = $__7.Method,\n      SetAccessor = $__7.SetAccessor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")).StringSet;\n  var VARIABLE_DECLARATION_LIST = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")).VARIABLE_DECLARATION_LIST;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")).VAR;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/VariableBinder.js\", \"traceur@0.0.111/src/codegeneration/ScopeTransformer.js\")),\n      variablesInBlock = $__11.variablesInBlock,\n      variablesInFunction = $__11.variablesInFunction;\n  var FindNames = function($__super) {\n    function FindNames(names) {\n      $traceurRuntime.superConstructor(FindNames).call(this);\n      this.names = names;\n    }\n    return ($traceurRuntime.createClass)(FindNames, {visitBindingIdentifier: function(tree) {\n        this.names.add(tree.getStringValue());\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function getLexicalBindingNames(tree) {\n    var names = new StringSet();\n    if (tree !== null && tree.type === VARIABLE_DECLARATION_LIST && tree.declarationType !== VAR) {\n      var visitor = new FindNames(names);\n      for (var i = 0; i < tree.declarations.length; i++) {\n        visitor.visitAny(tree.declarations[i].lvalue);\n      }\n    }\n    return names;\n  }\n  var ScopeTransformer = function($__super) {\n    function ScopeTransformer(varName) {\n      $traceurRuntime.superConstructor(ScopeTransformer).call(this);\n      this.varName_ = varName;\n    }\n    return ($traceurRuntime.createClass)(ScopeTransformer, {\n      transformBlock: function(tree) {\n        if (variablesInBlock(tree).has(this.varName_)) {\n          return tree;\n        }\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformBlock\").call(this, tree);\n      },\n      sameTreeIfNameInLoopInitializer_: function(tree) {\n        var names = getLexicalBindingNames(tree.initializer);\n        if (names.has(this.varName_)) {\n          return tree;\n        }\n        return null;\n      },\n      transformForStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformForStatement\").call(this, tree);\n      },\n      transformForInStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformForInStatement\").call(this, tree);\n      },\n      transformForOfStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformForOfStatement\").call(this, tree);\n      },\n      transformForOnStatement: function(tree) {\n        return this.sameTreeIfNameInLoopInitializer_(tree) || $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformForOnStatement\").call(this, tree);\n      },\n      transformThisExpression: function(tree) {\n        if (this.varName_ !== THIS)\n          return tree;\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformThisExpression\").call(this, tree);\n      },\n      transformParameterListAndBody_: function(tree) {\n        if (this.getDoNotRecurse(tree))\n          return tree;\n        return {\n          parameterList: this.transformAny(tree.parameterList),\n          body: this.transformAny(tree.body)\n        };\n      },\n      transformFunctionDeclaration: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionDeclaration(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformFunctionExpression: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && parameterList === tree.parameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new FunctionExpression(tree.location, name, tree.functionKind, parameterList, typeAnnotation, annotations, body);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, typeAnnotation, annotations, body, tree.debugName);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.getDoNotRecurse(tree) ? tree.body : this.transformAny(tree.body);\n        if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, typeAnnotation, annotations, body);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var annotations = this.transformList(tree.annotations);\n        var $__3 = this.transformParameterListAndBody_(tree),\n            parameterList = $__3.parameterList,\n            body = $__3.body;\n        if (name === tree.name && annotations === tree.annotations && parameterList === tree.parameterList && body === tree.body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, annotations, body);\n      },\n      getDoNotRecurse: function(tree) {\n        return this.varName_ === ARGUMENTS || this.varName_ === THIS || variablesInFunction(tree).has(this.varName_);\n      },\n      transformCatch: function(tree) {\n        if (!tree.binding.isPattern() && this.varName_ === tree.binding.identifierToken.value) {\n          return tree;\n        }\n        return $traceurRuntime.superGet(this, ScopeTransformer.prototype, \"transformCatch\").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ScopeTransformer() {\n      return ScopeTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\";\n  var ScopeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeTransformer.js\", \"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\")).ScopeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\")),\n      FunctionDeclaration = $__2.FunctionDeclaration,\n      FunctionExpression = $__2.FunctionExpression;\n  var THIS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\")).THIS;\n  var createIdentifierExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AlphaRenamer.js\")).createIdentifierExpression;\n  var AlphaRenamer = function($__super) {\n    function AlphaRenamer(varName, newName) {\n      $traceurRuntime.superConstructor(AlphaRenamer).call(this, varName);\n      this.newName_ = newName;\n    }\n    return ($traceurRuntime.createClass)(AlphaRenamer, {\n      transformIdentifierExpression: function(tree) {\n        if (this.varName_ === tree.identifierToken.value) {\n          return createIdentifierExpression(this.newName_);\n        } else {\n          return tree;\n        }\n      },\n      transformThisExpression: function(tree) {\n        if (this.varName_ !== THIS)\n          return tree;\n        return createIdentifierExpression(this.newName_);\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.varName_ === tree.name) {\n          tree = new FunctionDeclaration(tree.location, this.newName_, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, AlphaRenamer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (this.varName_ === tree.name) {\n          tree = new FunctionExpression(tree.location, this.newName_, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, AlphaRenamer.prototype, \"transformFunctionExpression\").call(this, tree);\n      }\n    }, {rename: function(tree, varName, newName) {\n        return new AlphaRenamer(varName, newName).transformAny(tree);\n      }}, $__super);\n  }(ScopeTransformer);\n  return {get AlphaRenamer() {\n      return AlphaRenamer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FindThisOrArguments.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FindThisOrArguments.js\";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/FindThisOrArguments.js\")).ARGUMENTS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/FindThisOrArguments.js\")).FindInFunctionScope;\n  var FindThisOrArguments = function($__super) {\n    function FindThisOrArguments() {\n      $traceurRuntime.superConstructor(FindThisOrArguments).call(this);\n      this.foundThis = false;\n      this.foundArguments = false;\n    }\n    return ($traceurRuntime.createClass)(FindThisOrArguments, {\n      visitThisExpression: function(tree) {\n        this.foundThis = true;\n        this.found = this.foundArguments;\n      },\n      visitIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === ARGUMENTS) {\n          this.foundArguments = true;\n          this.found = this.foundThis;\n        }\n      }\n    }, {}, $__super);\n  }(FindInFunctionScope);\n  return {get FindThisOrArguments() {\n      return FindThisOrArguments;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js\")),\n      ARGUMENTS = $__0.ARGUMENTS,\n      THIS = $__0.THIS;\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AlphaRenamer.js\", \"traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js\")).AlphaRenamer;\n  var FindThisOrArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindThisOrArguments.js\", \"traceur@0.0.111/src/codegeneration/alphaRenameThisAndArguments.js\")).FindThisOrArguments;\n  function alphaRenameThisAndArguments(tempVarTransformer, tree) {\n    var finder = new FindThisOrArguments();\n    finder.visitAny(tree);\n    if (finder.foundArguments) {\n      var argumentsTempName = tempVarTransformer.addTempVarForArguments();\n      tree = AlphaRenamer.rename(tree, ARGUMENTS, argumentsTempName);\n    }\n    if (finder.foundThis) {\n      var thisTempName = tempVarTransformer.addTempVarForThis();\n      tree = AlphaRenamer.rename(tree, THIS, thisTempName);\n    }\n    return tree;\n  }\n  return {get default() {\n      return alphaRenameThisAndArguments;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\";\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./alphaRenameThisAndArguments.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")).default;\n  var FunctionExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")).FunctionExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")).TempVarTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")),\n      LET = $__4.LET,\n      STAR = $__4.STAR,\n      VAR = $__4.VAR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")),\n      COMPREHENSION_FOR = $__5.COMPREHENSION_FOR,\n      COMPREHENSION_IF = $__5.COMPREHENSION_IF;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Token.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")).Token;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ComprehensionTransformer.js\")),\n      createCallExpression = $__7.createCallExpression,\n      createEmptyParameterList = $__7.createEmptyParameterList,\n      createForOfStatement = $__7.createForOfStatement,\n      createFunctionBody = $__7.createFunctionBody,\n      createIfStatement = $__7.createIfStatement,\n      createParenExpression = $__7.createParenExpression,\n      createVariableDeclarationList = $__7.createVariableDeclarationList;\n  var ComprehensionTransformer = function($__super) {\n    function ComprehensionTransformer() {\n      $traceurRuntime.superConstructor(ComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ComprehensionTransformer, {transformComprehension: function(tree, statement, isGenerator) {\n        var prefix = arguments[3];\n        var suffix = arguments[4];\n        var bindingKind = isGenerator || !this.options.blockBinding ? VAR : LET;\n        var statements = prefix ? [prefix] : [];\n        for (var i = tree.comprehensionList.length - 1; i >= 0; i--) {\n          var item = tree.comprehensionList[i];\n          switch (item.type) {\n            case COMPREHENSION_IF:\n              {\n                var expression = this.transformAny(item.expression);\n                statement = createIfStatement(expression, statement);\n                break;\n              }\n            case COMPREHENSION_FOR:\n              {\n                var left = this.transformAny(item.left);\n                var iterator = this.transformAny(item.iterator);\n                var initializer = createVariableDeclarationList(bindingKind, left, null);\n                statement = createForOfStatement(initializer, iterator, statement);\n                break;\n              }\n            default:\n              throw new Error('Unreachable.');\n          }\n        }\n        statement = alphaRenameThisAndArguments(this, statement);\n        statements.push(statement);\n        if (suffix)\n          statements.push(suffix);\n        var functionKind = isGenerator ? new Token(STAR, null) : null;\n        var func = new FunctionExpression(null, null, functionKind, createEmptyParameterList(), null, [], createFunctionBody(statements));\n        return createParenExpression(createCallExpression(func));\n      }}, {}, $__super);\n  }(TempVarTransformer);\n  return {get ComprehensionTransformer() {\n      return ComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js\";\n  var ComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ComprehensionTransformer.js\", \"traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js\")).ComprehensionTransformer;\n  var createIdentifierExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js\")).createIdentifierExpression;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ArrayComprehensionTransformer.js\")).parseStatement;\n  var ArrayComprehensionTransformer = function($__super) {\n    function ArrayComprehensionTransformer() {\n      $traceurRuntime.superConstructor(ArrayComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ArrayComprehensionTransformer, {transformArrayComprehension: function(tree) {\n        this.pushTempScope();\n        var expression = this.transformAny(tree.expression);\n        var index = createIdentifierExpression(this.getTempIdentifier());\n        var result = createIdentifierExpression(this.getTempIdentifier());\n        var tempVarsStatatement = parseStatement($traceurRuntime.getTemplateObject([\"var \", \" = 0, \", \" = [];\"]), index, result);\n        var statement = parseStatement($traceurRuntime.getTemplateObject([\"\", \"[\", \"++] = \", \";\"]), result, index, expression);\n        var returnStatement = parseStatement($traceurRuntime.getTemplateObject([\"return \", \";\"]), result);\n        var functionKind = null;\n        result = this.transformComprehension(tree, statement, functionKind, tempVarsStatatement, returnStatement);\n        this.popTempScope();\n        return result;\n      }}, {}, $__super);\n  }(ComprehensionTransformer);\n  return {get ArrayComprehensionTransformer() {\n      return ArrayComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ParenTrait.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ParenTrait.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ParenTrait.js\")),\n      ArgumentList = $__2.ArgumentList,\n      ArrayLiteral = $__2.ArrayLiteral,\n      BinaryExpression = $__2.BinaryExpression,\n      ConditionalExpression = $__2.ConditionalExpression,\n      ExpressionStatement = $__2.ExpressionStatement,\n      NewExpression = $__2.NewExpression,\n      ParenExpression = $__2.ParenExpression,\n      PropertyNameAssignment = $__2.PropertyNameAssignment,\n      VariableDeclaration = $__2.VariableDeclaration;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ParenTrait.js\")),\n      CALL_EXPRESSION = $__3.CALL_EXPRESSION,\n      COMMA_EXPRESSION = $__3.COMMA_EXPRESSION,\n      FUNCTION_EXPRESSION = $__3.FUNCTION_EXPRESSION,\n      OBJECT_LITERAL = $__3.OBJECT_LITERAL,\n      OBJECT_PATTERN = $__3.OBJECT_PATTERN,\n      TEMPLATE_LITERAL_EXPRESSION = $__3.TEMPLATE_LITERAL_EXPRESSION,\n      YIELD_EXPRESSION = $__3.YIELD_EXPRESSION;\n  function wrap(tree) {\n    return new ParenExpression(tree.location, tree);\n  }\n  function ParenTrait(ParseTreeTransformerClass) {\n    return function($__super) {\n      function $__0() {\n        $traceurRuntime.superConstructor($__0).apply(this, arguments);\n      }\n      return ($traceurRuntime.createClass)($__0, {\n        transformVariableDeclaration: function(tree) {\n          var lvalue = this.transformAny(tree.lvalue);\n          var typeAnnotation = this.transformAny(tree.typeAnnotation);\n          var initializer = this.transformAny(tree.initializer);\n          if (initializer !== null && initializer.type === COMMA_EXPRESSION) {\n            initializer = wrap(initializer);\n          } else if (tree.lvalue === lvalue && tree.typeAnnotation === typeAnnotation && tree.initializer === initializer) {\n            return tree;\n          }\n          return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initializer);\n        },\n        transformExpressionStatement: function(tree) {\n          var expression = this.transformAny(tree.expression);\n          switch (expression.type) {\n            case OBJECT_LITERAL:\n            case OBJECT_PATTERN:\n            case FUNCTION_EXPRESSION:\n              expression = wrap(expression);\n              break;\n          }\n          if (tree.expression === expression) {\n            return tree;\n          }\n          return new ExpressionStatement(tree.location, expression);\n        },\n        transformNewExpression: function(tree) {\n          var operand = this.transformAny(tree.operand);\n          var args = this.transformAny(tree.args);\n          switch (operand.type) {\n            case CALL_EXPRESSION:\n            case TEMPLATE_LITERAL_EXPRESSION:\n              operand = wrap(operand);\n          }\n          if (operand === tree.operand && args === tree.args) {\n            return tree;\n          }\n          return new NewExpression(tree.location, operand, args);\n        },\n        transformExpressionList_: function(list) {\n          var expressions = this.transformList(list);\n          var newList = null;\n          for (var i = 0; i < list.length; i++) {\n            var expression = expressions[i];\n            if (expression !== null && expression.type === COMMA_EXPRESSION) {\n              expression = wrap(expression);\n              if (newList === null) {\n                newList = expressions.slice(0, i);\n              }\n              newList.push(expression);\n            } else if (newList !== null) {\n              newList.push(expression);\n            }\n          }\n          if (newList !== null) {\n            return newList;\n          }\n          return expressions;\n        },\n        transformArgumentList: function(tree) {\n          var args = this.transformExpressionList_(tree.args);\n          if (tree.args === args) {\n            return tree;\n          }\n          return new ArgumentList(tree.location, args);\n        },\n        transformArrayLiteral: function(tree) {\n          var elements = this.transformExpressionList_(tree.elements);\n          if (tree.elements === elements) {\n            return tree;\n          }\n          return new ArrayLiteral(tree.location, elements);\n        },\n        transformPropertyNameAssignment: function(tree) {\n          var name = this.transformAny(tree.name);\n          var value = this.transformAny(tree.value);\n          if (value.type === COMMA_EXPRESSION) {\n            value = wrap(value);\n          } else if (name === tree.name && value === tree.value) {\n            return tree;\n          }\n          return new PropertyNameAssignment(tree.location, name, value);\n        },\n        transformBinaryExpression: function(tree) {\n          var left = this.transformAny(tree.left);\n          var right = this.transformAny(tree.right);\n          if (commaOrYield(left.type)) {\n            left = wrap(left);\n          }\n          if (commaOrYield(right.type)) {\n            right = wrap(right);\n          }\n          if (left === tree.left && right === tree.right) {\n            return tree;\n          }\n          return new BinaryExpression(tree.location, left, tree.operator, right);\n        },\n        transformConditionalExpression: function(tree) {\n          var condition = this.transformAny(tree.condition);\n          var left = this.transformAny(tree.left);\n          var right = this.transformAny(tree.right);\n          if (commaOrYield(condition.type)) {\n            condition = wrap(condition);\n          }\n          if (left.type == COMMA_EXPRESSION) {\n            left = wrap(left);\n          }\n          if (right.type == COMMA_EXPRESSION) {\n            right = wrap(right);\n          }\n          if (condition === tree.condition && left === tree.left && right === tree.right) {\n            return tree;\n          }\n          return new ConditionalExpression(tree.location, condition, left, right);\n        }\n      }, {}, $__super);\n    }(ParseTreeTransformerClass);\n  }\n  function commaOrYield(type) {\n    return type === COMMA_EXPRESSION || type == YIELD_EXPRESSION;\n  }\n  return {get ParenTrait() {\n      return ParenTrait;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")),\n      ARGUMENTS = $__1.ARGUMENTS,\n      CONSTRUCTOR = $__1.CONSTRUCTOR,\n      THIS = $__1.THIS;\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AlphaRenamer.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).AlphaRenamer;\n  var FunctionExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).FunctionExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).TempVarTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParenTrait.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).ParenTrait;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./alphaRenameThisAndArguments.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).default;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")),\n      FUNCTION_BODY = $__7.FUNCTION_BODY,\n      LITERAL_PROPERTY_NAME = $__7.LITERAL_PROPERTY_NAME;\n  var FindThisOrArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindThisOrArguments.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")).FindThisOrArguments;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ArrowFunctionTransformer.js\")),\n      createAssignmentExpression = $__9.createAssignmentExpression,\n      createCommaExpression = $__9.createCommaExpression,\n      createFunctionBody = $__9.createFunctionBody,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createReturnStatement = $__9.createReturnStatement,\n      createThisExpression = $__9.createThisExpression;\n  function convertConciseBody(tree) {\n    if (tree.type !== FUNCTION_BODY)\n      return createFunctionBody([createReturnStatement(tree)]);\n    return tree;\n  }\n  var ArrowFunctionTransformer = function($__super) {\n    function ArrowFunctionTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ArrowFunctionTransformer).call(this, identifierGenerator, reporter, options);\n      this.inDerivedClass_ = false;\n      this.inConstructor_ = false;\n    }\n    return ($traceurRuntime.createClass)(ArrowFunctionTransformer, {\n      transformArrowFunction: function(tree) {\n        if (this.inDerivedClass_ && this.inConstructor_) {\n          return this.transformUsingCommaExpression_(tree);\n        }\n        return this.transformUsingTempVar_(tree);\n      },\n      transformUsingCommaExpression_: function(tree) {\n        var finder = new FindThisOrArguments();\n        var argumentsTempName,\n            thisTempName;\n        finder.visitAny(tree);\n        if (finder.foundArguments) {\n          argumentsTempName = this.addTempVar();\n          tree = AlphaRenamer.rename(tree, ARGUMENTS, argumentsTempName);\n        }\n        if (finder.foundThis) {\n          thisTempName = this.addTempVar();\n          tree = AlphaRenamer.rename(tree, THIS, thisTempName);\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        body = convertConciseBody(body);\n        var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, parameterList, null, [], body);\n        var expressions = [];\n        if (argumentsTempName) {\n          expressions.push(createAssignmentExpression(createIdentifierExpression(argumentsTempName), createIdentifierExpression(ARGUMENTS)));\n        }\n        if (thisTempName) {\n          expressions.push(createAssignmentExpression(createIdentifierExpression(thisTempName), createThisExpression()));\n        }\n        if (expressions.length === 0) {\n          return functionExpression;\n        }\n        expressions.push(functionExpression);\n        return createCommaExpression(expressions);\n      },\n      transformUsingTempVar_: function(tree) {\n        var alphaRenamed = alphaRenameThisAndArguments(this, tree);\n        var parameterList = this.transformAny(alphaRenamed.parameterList);\n        var body = this.transformAny(alphaRenamed.body);\n        body = convertConciseBody(body);\n        var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, parameterList, null, [], body);\n        return functionExpression;\n      },\n      transformClassExpression: function(tree) {\n        var inDerivedClass = this.inDerivedClass_;\n        this.inDerivedClass_ = tree.superClass !== null;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, \"transformClassExpression\").call(this, tree);\n        this.inDerivedClass_ = inDerivedClass;\n        return result;\n      },\n      transformClassDeclaration: function(tree) {\n        var inDerivedClass = this.inDerivedClass_;\n        this.inDerivedClass_ = tree.superClass !== null;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, \"transformClassDeclaration\").call(this, tree);\n        this.inDerivedClass_ = inDerivedClass;\n        return result;\n      },\n      transformMethod: function(tree) {\n        var inConstructor = this.inConstructor_;\n        this.inConstructor_ = !tree.isStatic && tree.functionKind === null && tree.name.type === LITERAL_PROPERTY_NAME && tree.name.literalToken.value === CONSTRUCTOR;\n        var result = $traceurRuntime.superGet(this, ArrowFunctionTransformer.prototype, \"transformMethod\").call(this, tree);\n        this.inConstructor_ = inConstructor;\n        return result;\n      }\n    }, {transform: function(tempVarTransformer, tree) {\n        tree = alphaRenameThisAndArguments(tempVarTransformer, tree);\n        var body = convertConciseBody(tree.body);\n        return new FunctionExpression(tree.location, null, tree.functionKind, tree.parameterList, null, [], body);\n      }}, $__super);\n  }(ParenTrait(TempVarTransformer));\n  return {get ArrowFunctionTransformer() {\n      return ArrowFunctionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\";\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./alphaRenameThisAndArguments.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).default;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")),\n      createArgumentList = $__2.createArgumentList,\n      createBlock = $__2.createBlock,\n      createFunctionBody = $__2.createFunctionBody,\n      id = $__2.createIdentifierExpression,\n      createMemberExpression = $__2.createMemberExpression,\n      createThisExpression = $__2.createThisExpression,\n      createVariableDeclaration = $__2.createVariableDeclaration,\n      createVariableDeclarationList = $__2.createVariableDeclarationList,\n      createVariableStatement = $__2.createVariableStatement;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).parseStatement;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")),\n      AwaitExpression = $__6.AwaitExpression,\n      Block = $__6.Block,\n      CallExpression = $__6.CallExpression,\n      Catch = $__6.Catch;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SkipFunctionsTransformerTrait.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).default;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).ARGUMENTS;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformer.js\")).VAR;\n  var AsyncGeneratorTransformer = function($__super) {\n    function AsyncGeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncGeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.variableDeclarations_ = [];\n      this.ctx_ = id(this.getTempIdentifier());\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorTransformer, {\n      transformYieldExpression: function(tree) {\n        var argList = createArgumentList([tree.expression]);\n        if (tree.isYieldFor) {\n          return new AwaitExpression(tree.location, new CallExpression(null, createMemberExpression(this.ctx_, 'yieldFor'), argList));\n        }\n        return new CallExpression(tree.location, createMemberExpression(this.ctx_, 'yield'), argList);\n      },\n      transformCatch: function(tree) {\n        var body = tree.catchBody;\n        body = new Block(body.location, $traceurRuntime.spread([parseStatement($traceurRuntime.getTemplateObject([\"\\n        if (\", \".inReturn) {\\n          throw undefined;\\n        }\"]), this.ctx_)], body.statements));\n        return new Catch(tree.location, tree.binding, body);\n      },\n      transformAsyncGeneratorBody_: function(tree, name) {\n        tree = this.transformAny(tree);\n        tree = alphaRenameThisAndArguments(this, tree);\n        var statements = [];\n        if (this.variableDeclarations_.length > 0) {\n          statements.push(createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)));\n        }\n        var body = createBlock(tree.statements);\n        var createAsyncGeneratorInstance = this.getRuntimeExpression('createAsyncGeneratorInstance');\n        statements.push(parseStatement($traceurRuntime.getTemplateObject([\"\\n        return \", \"(\\n            async function (\", \") {\\n                \", \"\\n            }, \", \");\"]), createAsyncGeneratorInstance, this.ctx_, body, name));\n        return createFunctionBody(statements);\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.getTempIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, id(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.getTempIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      }\n    }, {transformAsyncGeneratorBody: function(identifierGenerator, reporter, options, body, name) {\n        return new AsyncGeneratorTransformer(identifierGenerator, reporter, options).transformAsyncGeneratorBody_(body, name);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ImportRuntimeTrait(TempVarTransformer)));\n  return {get AsyncGeneratorTransformer() {\n      return AsyncGeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\";\n  var AsyncGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AsyncGeneratorTransformer.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")).AsyncGeneratorTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")).TempVarTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")),\n      AnonBlock = $__3.AnonBlock,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")).default;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")),\n      createBindingIdentifier = $__5.createBindingIdentifier,\n      id = $__5.createIdentifierExpression,\n      createIdentifierToken = $__5.createIdentifierToken;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/AsyncGeneratorTransformPass.js\")),\n      parseExpression = $__6.parseExpression,\n      parseStatement = $__6.parseStatement;\n  var AsyncGeneratorTransformPass = function($__super) {\n    function AsyncGeneratorTransformPass(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncGeneratorTransformPass).call(this, identifierGenerator, reporter, options);\n      this.transformOptions_ = options.transformOptions;\n      this.inBlock_ = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncGeneratorTransformPass, {\n      needsTransform_: function(tree) {\n        return this.transformOptions_.asyncGenerators && tree.isAsyncGenerator();\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (!this.needsTransform_(tree))\n          return $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, \"transformFunctionDeclaration\").call(this, tree);\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initAsyncGeneratorFunction = this.getRuntimeExpression('initAsyncGeneratorFunction');\n        var setupPrototypeExpression = parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initAsyncGeneratorFunction, nameIdExpression);\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupPrototypeExpression));\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration, tmpVar);\n        if (!this.inBlock_)\n          return funcDecl;\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject([\"var \", \" = \", \"\"]), tmpVar, setupPrototypeExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        if (!this.needsTransform_(tree)) {\n          return $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, \"transformFunctionExpression\").call(this, tree);\n        }\n        var name;\n        if (!tree.name) {\n          name = createIdentifierToken(this.getTempIdentifier());\n          tree = new FunctionExpression(tree.location, createBindingIdentifier(name), tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        } else {\n          name = tree.name.identifierToken;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression, id(name));\n        var initAsyncGeneratorFunction = this.getRuntimeExpression('initAsyncGeneratorFunction');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initAsyncGeneratorFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor, nameExpression) {\n        var body = $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, \"transformAny\").call(this, tree.body);\n        body = AsyncGeneratorTransformer.transformAsyncGeneratorBody(this.identifierGenerator, this.reporter, this.options, body, nameExpression);\n        var functionKind = null;\n        return new constructor(tree.location, tree.name, functionKind, tree.parameterList, tree.typeAnnotation || null, tree.annotations || null, body);\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, AsyncGeneratorTransformPass.prototype, \"transformBlock\").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get AsyncGeneratorTransformPass() {\n      return AsyncGeneratorTransformPass;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FindArguments.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FindArguments.js\";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/FindArguments.js\")).ARGUMENTS;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/FindArguments.js\")).FindInFunctionScope;\n  var FindArguments = function($__super) {\n    function FindArguments() {\n      $traceurRuntime.superConstructor(FindArguments).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindArguments, {visitIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === ARGUMENTS) {\n          this.found = true;\n        }\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  return {get default() {\n      return FindArguments;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\";\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).ARGUMENTS;\n  var FindArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindArguments.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).default;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")),\n      FunctionBody = $__3.FunctionBody,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression,\n      Method = $__3.Method,\n      YieldExpression = $__3.YieldExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).default;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParenTrait.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).ParenTrait;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).parseStatement;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")).TempVarTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/AsyncToGeneratorTransformer.js\")),\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createNullLiteral = $__8.createNullLiteral;\n  var AsyncToGeneratorTransformer = function($__super) {\n    function AsyncToGeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(AsyncToGeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.inAsyncFunction_ = false;\n    }\n    return ($traceurRuntime.createClass)(AsyncToGeneratorTransformer, {\n      transformFunctionDeclaration: function(tree) {\n        if (tree.isAsyncFunction()) {\n          return this.transformFunctionShared_(tree, FunctionDeclaration);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (tree.isAsyncFunction()) {\n          return this.transformFunctionShared_(tree, FunctionExpression);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, \"transformFunctionExpression\").call(this, tree);\n      },\n      transformFunctionShared_: function(tree, ctor) {\n        var parameterList = this.transformAny(tree.parameterList);\n        var typeAnnotation = this.transformAny(tree.typeAnnotation);\n        var annotations = this.transformList(tree.annotations);\n        var body = this.transformAsyncBody_(tree.body);\n        return new ctor(tree.location, tree.name, null, parameterList, typeAnnotation, annotations, body);\n      },\n      transformAsyncBody_: function(body) {\n        var inAsyncFunction = this.inAsyncFunction_;\n        this.inAsyncFunction_ = true;\n        body = this.transformFunctionBody(body);\n        var spawn = this.getRuntimeExpression('spawn');\n        body = wrapBodyInSpawn(body, spawn);\n        this.inAsyncFunction_ = inAsyncFunction;\n        return body;\n      },\n      transformMethod: function(tree) {\n        if (tree.isAsyncFunction()) {\n          var name = this.transformAny(tree.name);\n          var parameterList = this.transformAny(tree.parameterList);\n          var typeAnnotation = this.transformAny(tree.typeAnnotation);\n          var annotations = this.transformList(tree.annotations);\n          var body = this.transformAsyncBody_(tree.body);\n          return new Method(tree.location, tree.isStatic, null, name, parameterList, typeAnnotation, annotations, body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, \"transformMethod\").call(this, tree);\n      },\n      transformAwaitExpression: function(tree) {\n        if (this.inAsyncFunction_) {\n          var expression = this.transformAny(tree.expression);\n          return new YieldExpression(tree.location, expression, false);\n        }\n        return $traceurRuntime.superGet(this, AsyncToGeneratorTransformer.prototype, \"transformAwaitExpression\").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(TempVarTransformer)));\n  function wrapBodyInSpawn(body, spawn) {\n    var visitor = new FindArguments();\n    visitor.visitAny(body);\n    var argExpr = visitor.found ? createIdentifierExpression(ARGUMENTS) : createNullLiteral();\n    var statement = parseStatement($traceurRuntime.getTemplateObject([\"return \", \"(this, \", \", function*() { \", \" });\"]), spawn, argExpr, body);\n    return new FunctionBody(body.location, [statement]);\n  }\n  return {get AsyncToGeneratorTransformer() {\n      return AsyncToGeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FindIdentifiers.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FindIdentifiers.js\";\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/ScopeVisitor.js\", \"traceur@0.0.111/src/codegeneration/FindIdentifiers.js\")).ScopeVisitor;\n  var FindIdentifiers = function($__super) {\n    function FindIdentifiers(tree, filterFunction) {\n      $traceurRuntime.superConstructor(FindIdentifiers).call(this);\n      this.filterFunction_ = filterFunction;\n      this.found_ = false;\n      this.visitAny(tree);\n    }\n    return ($traceurRuntime.createClass)(FindIdentifiers, {\n      visitIdentifierExpression: function(tree) {\n        if (this.filterFunction_(tree.identifierToken.value, this.scope.tree)) {\n          this.found = true;\n        }\n      },\n      get found() {\n        return this.found_;\n      },\n      set found(v) {\n        if (v) {\n          this.found_ = true;\n        }\n      },\n      visitAny: function(tree) {\n        !this.found_ && tree && tree.visit(this);\n      },\n      visitList: function(list) {\n        if (list) {\n          for (var i = 0; !this.found_ && i < list.length; i++) {\n            this.visitAny(list[i]);\n          }\n        }\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  return {get FindIdentifiers() {\n      return FindIdentifiers;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).ParseTreeTransformer;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./alphaRenameThisAndArguments.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).default;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).parseStatement;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")),\n      AnonBlock = $__6.AnonBlock,\n      BreakStatement = $__6.BreakStatement,\n      ContinueStatement = $__6.ContinueStatement,\n      FormalParameterList = $__6.FormalParameterList,\n      FunctionExpression = $__6.FunctionExpression,\n      ReturnStatement = $__6.ReturnStatement,\n      YieldExpression = $__6.YieldExpression;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")),\n      createArgumentList = $__7.createArgumentList,\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createAssignmentExpression = $__7.createAssignmentExpression,\n      createBlock = $__7.createBlock,\n      createCallExpression = $__7.createCallExpression,\n      createCaseClause = $__7.createCaseClause,\n      createDefaultClause = $__7.createDefaultClause,\n      createExpressionStatement = $__7.createExpressionStatement,\n      createFunctionBody = $__7.createFunctionBody,\n      createFunctionExpression = $__7.createFunctionExpression,\n      createIdentifierExpression = $__7.createIdentifierExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createObjectLiteralForDescriptor = $__7.createObjectLiteralForDescriptor,\n      createSwitchStatement = $__7.createSwitchStatement,\n      createThisExpression = $__7.createThisExpression,\n      createVariableDeclaration = $__7.createVariableDeclaration,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVariableStatement = $__7.createVariableStatement,\n      createVoid0 = $__7.createVoid0;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).ARGUMENTS;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SkipFunctionsTransformerTrait.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).default;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).StringSet;\n  var Token = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Token.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")).Token;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/FnExtractAbruptCompletions.js\")),\n      STAR = $__12.STAR,\n      VAR = $__12.VAR;\n  var FnExtractAbruptCompletions = function($__super) {\n    function FnExtractAbruptCompletions(idGenerator, requestParentLabel) {\n      $traceurRuntime.superConstructor(FnExtractAbruptCompletions).call(this);\n      this.idGenerator_ = idGenerator;\n      this.inLoop_ = 0;\n      this.inBreakble_ = 0;\n      this.variableDeclarations_ = [];\n      this.extractedStatements_ = [];\n      this.requestParentLabel_ = requestParentLabel;\n      this.labelledStatements_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(FnExtractAbruptCompletions, {\n      createIIFE: function(body, paramList, argsList, inGenerator) {\n        body = this.transformAny(body);\n        body = alphaRenameThisAndArguments(this, body);\n        var tmpFnName = this.idGenerator_.generateUniqueIdentifier();\n        var functionKind = inGenerator ? new Token(STAR, null) : null;\n        var functionExpression = new FunctionExpression(null, null, functionKind, new FormalParameterList(null, paramList), null, [], createFunctionBody(body.statements || [body]));\n        this.variableDeclarations_.push(createVariableDeclaration(tmpFnName, functionExpression));\n        var functionCall = createCallExpression(createIdentifierExpression(tmpFnName), createArgumentList(argsList));\n        if (inGenerator) {\n          functionCall = new YieldExpression(null, functionCall, true);\n        }\n        var loopBody = null;\n        if (this.extractedStatements_.length || this.hasReturns) {\n          var tmpVarName = createIdentifierExpression(this.idGenerator_.generateUniqueIdentifier());\n          this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, null));\n          var maybeReturn;\n          if (this.hasReturns) {\n            maybeReturn = parseStatement($traceurRuntime.getTemplateObject([\"if (typeof \", \" === \\\"object\\\")\\n            return \", \".v;\"]), tmpVarName, tmpVarName);\n          }\n          if (this.extractedStatements_.length) {\n            var caseClauses = this.extractedStatements_.map(function(statement, index) {\n              return createCaseClause(createNumberLiteral(index), [statement]);\n            });\n            if (maybeReturn) {\n              caseClauses.push(createDefaultClause([maybeReturn]));\n            }\n            loopBody = createBlock([createExpressionStatement(createAssignmentExpression(tmpVarName, functionCall)), createSwitchStatement(tmpVarName, caseClauses)]);\n          } else {\n            loopBody = createBlock([createExpressionStatement(createAssignmentExpression(tmpVarName, functionCall)), maybeReturn]);\n          }\n        } else {\n          loopBody = createBlock([createExpressionStatement(functionCall)]);\n        }\n        return {\n          variableStatements: createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)),\n          loopBody: loopBody\n        };\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createIdentifierExpression(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      },\n      transformAny: function(tree) {\n        if (tree) {\n          if (tree.isBreakableStatement())\n            this.inBreakble_++;\n          if (tree.isIterationStatement())\n            this.inLoop_++;\n          tree = $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformAny\").call(this, tree);\n          if (tree.isBreakableStatement())\n            this.inBreakble_--;\n          if (tree.isIterationStatement())\n            this.inLoop_--;\n        }\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        this.hasReturns = true;\n        return new ReturnStatement(tree.location, createObjectLiteralForDescriptor({v: tree.expression || createVoid0()}));\n      },\n      transformAbruptCompletion_: function(tree) {\n        this.extractedStatements_.push(tree);\n        var index = this.extractedStatements_.length - 1;\n        return parseStatement($traceurRuntime.getTemplateObject([\"return \", \";\"]), index);\n      },\n      transformBreakStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inBreakble_) {\n            return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformBreakStatement\").call(this, tree);\n          } else {\n            tree = new BreakStatement(tree.location, this.requestParentLabel_());\n          }\n        } else if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformBreakStatement\").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformContinueStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inLoop_) {\n            return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformContinueStatement\").call(this, tree);\n          } else {\n            tree = new ContinueStatement(tree.location, this.requestParentLabel_());\n          }\n        } else if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformContinueStatement\").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformLabelledStatement: function(tree) {\n        this.labelledStatements_.add(tree.name.value);\n        return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformLabelledStatement\").call(this, tree);\n      },\n      transformVariableStatement: function(tree) {\n        var $__2 = this;\n        if (tree.declarations.declarationType === VAR) {\n          var assignments = [];\n          tree.declarations.declarations.forEach(function(variableDeclaration) {\n            var variableName = variableDeclaration.lvalue.getStringValue();\n            var initializer = $traceurRuntime.superGet($__2, FnExtractAbruptCompletions.prototype, \"transformAny\").call($__2, variableDeclaration.initializer);\n            $__2.variableDeclarations_.push(createVariableDeclaration(variableName, null));\n            assignments.push(createAssignmentStatement(createIdentifierExpression(variableName), initializer));\n          });\n          return new AnonBlock(null, assignments);\n        }\n        return $traceurRuntime.superGet(this, FnExtractAbruptCompletions.prototype, \"transformVariableStatement\").call(this, tree);\n      }\n    }, {createIIFE: function(idGenerator, body, paramList, argsList, requestParentLabel, inGenerator) {\n        return new FnExtractAbruptCompletions(idGenerator, requestParentLabel).createIIFE(body, paramList, argsList, inGenerator);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get FnExtractAbruptCompletions() {\n      return FnExtractAbruptCompletions;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ScopeReferences.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ScopeReferences.js\";\n  var Scope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Scope.js\", \"traceur@0.0.111/src/semantics/ScopeReferences.js\")).Scope;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/semantics/ScopeReferences.js\")).StringSet;\n  var ScopeReferences = function($__super) {\n    function ScopeReferences(parent, tree) {\n      $traceurRuntime.superConstructor(ScopeReferences).call(this, parent, tree);\n      this.freeVars_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(ScopeReferences, {\n      addReference: function(name) {\n        this.freeVars_.add(name);\n      },\n      hasFreeVariable: function(name) {\n        return this.freeVars_.has(name);\n      }\n    }, {}, $__super);\n  }(Scope);\n  return {get ScopeReferences() {\n      return ScopeReferences;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\";\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeChainBuilder.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\")).ScopeChainBuilder;\n  var ScopeReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeReferences.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\")).ScopeReferences;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\")),\n      FUNCTION_DECLARATION = $__3.FUNCTION_DECLARATION,\n      FUNCTION_EXPRESSION = $__3.FUNCTION_EXPRESSION,\n      GET_ACCESSOR = $__3.GET_ACCESSOR,\n      IDENTIFIER_EXPRESSION = $__3.IDENTIFIER_EXPRESSION,\n      METHOD = $__3.METHOD,\n      MODULE = $__3.MODULE,\n      SET_ACCESSOR = $__3.SET_ACCESSOR;\n  var TYPEOF = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/ScopeChainBuilderWithReferences.js\")).TYPEOF;\n  function hasArgumentsInScope(scope) {\n    for (; scope; scope = scope.parent) {\n      switch (scope.tree.type) {\n        case FUNCTION_DECLARATION:\n        case FUNCTION_EXPRESSION:\n        case GET_ACCESSOR:\n        case METHOD:\n        case SET_ACCESSOR:\n          return true;\n      }\n    }\n    return false;\n  }\n  function inModuleScope(scope) {\n    for (; scope; scope = scope.parent) {\n      if (scope.tree.type === MODULE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var ScopeChainBuilderWithReferences = function($__super) {\n    function ScopeChainBuilderWithReferences() {\n      $traceurRuntime.superConstructor(ScopeChainBuilderWithReferences).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ScopeChainBuilderWithReferences, {\n      createScope: function(tree) {\n        return new ScopeReferences(this.scope, tree);\n      },\n      visitIdentifierExpression: function(tree) {\n        if (this.inWithBlock) {\n          return;\n        }\n        var scope = this.scope;\n        var name = tree.getStringValue();\n        if (name === 'arguments' && hasArgumentsInScope(scope)) {\n          return;\n        }\n        if (name === '__moduleName' && inModuleScope(scope)) {\n          return;\n        }\n        this.referenceFound(tree, name);\n      },\n      visitUnaryExpression: function(tree) {\n        if (tree.operator.type === TYPEOF && tree.operand.type === IDENTIFIER_EXPRESSION) {\n          var scope = this.scope;\n          var binding = scope.getBinding(tree.operand);\n          if (!binding) {\n            scope.addVar(tree.operand, this.reporter);\n          }\n        } else {\n          $traceurRuntime.superGet(this, ScopeChainBuilderWithReferences.prototype, \"visitUnaryExpression\").call(this, tree);\n        }\n      },\n      referenceFound: function(tree, name) {\n        this.scope.addReference(name);\n      }\n    }, {}, $__super);\n  }(ScopeChainBuilder);\n  return {get ScopeChainBuilderWithReferences() {\n      return ScopeChainBuilderWithReferences;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\";\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AlphaRenamer.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).AlphaRenamer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")),\n      ANON_BLOCK = $__7.ANON_BLOCK,\n      BINDING_IDENTIFIER = $__7.BINDING_IDENTIFIER,\n      FOR_IN_STATEMENT = $__7.FOR_IN_STATEMENT,\n      FOR_OF_STATEMENT = $__7.FOR_OF_STATEMENT,\n      VARIABLE_DECLARATION_LIST = $__7.VARIABLE_DECLARATION_LIST;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")),\n      AnonBlock = $__8.AnonBlock,\n      BindingElement = $__8.BindingElement,\n      BindingIdentifier = $__8.BindingIdentifier,\n      Block = $__8.Block,\n      Catch = $__8.Catch,\n      DoWhileStatement = $__8.DoWhileStatement,\n      ForInStatement = $__8.ForInStatement,\n      ForStatement = $__8.ForStatement,\n      FormalParameter = $__8.FormalParameter,\n      FunctionBody = $__8.FunctionBody,\n      FunctionExpression = $__8.FunctionExpression,\n      LabelledStatement = $__8.LabelledStatement,\n      LiteralPropertyName = $__8.LiteralPropertyName,\n      Module = $__8.Module,\n      ObjectPatternField = $__8.ObjectPatternField,\n      Script = $__8.Script,\n      VariableDeclaration = $__8.VariableDeclaration,\n      VariableDeclarationList = $__8.VariableDeclarationList,\n      VariableStatement = $__8.VariableStatement,\n      WhileStatement = $__8.WhileStatement;\n  var IdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/IdentifierToken.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).IdentifierToken;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).ParseTreeTransformer;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).VAR;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")),\n      createBindingIdentifier = $__12.createBindingIdentifier,\n      createIdentifierExpression = $__12.createIdentifierExpression,\n      createIdentifierToken = $__12.createIdentifierToken;\n  var FindIdentifiers = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindIdentifiers.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).FindIdentifiers;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindVisitor.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).FindVisitor;\n  var FnExtractAbruptCompletions = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FnExtractAbruptCompletions.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).FnExtractAbruptCompletions;\n  var ScopeChainBuilderWithReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/ScopeChainBuilderWithReferences.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).ScopeChainBuilderWithReferences;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/BlockBindingTransformer.js\")).prependStatements;\n  function varNeedsInitializer(tree, loopTree) {\n    if (loopTree === null)\n      return false;\n    var type = loopTree.type;\n    if (type !== FOR_IN_STATEMENT && type !== FOR_OF_STATEMENT)\n      return true;\n    return loopTree.initializer.declarations[0] !== tree;\n  }\n  var BlockBindingTransformer = function($__super) {\n    function BlockBindingTransformer(idGenerator, reporter, tree) {\n      var scopeBuilder = arguments[3];\n      var latestScope = arguments[4];\n      $traceurRuntime.superConstructor(BlockBindingTransformer).call(this);\n      this.idGenerator_ = idGenerator;\n      this.reporter_ = reporter;\n      if (!scopeBuilder) {\n        scopeBuilder = new ScopeChainBuilderWithReferences(reporter);\n        scopeBuilder.visitAny(tree);\n      }\n      this.scopeBuilder_ = scopeBuilder;\n      this.labelledLoops_ = new Map();\n      this.prependStatement_ = [];\n      this.prependBlockStatement_ = [];\n      this.blockRenames_ = [];\n      this.rootTree_ = tree;\n      if (latestScope) {\n        this.scope_ = latestScope;\n      } else {\n        this.pushScope(tree);\n      }\n      this.usedVars_ = this.scope_.getAllBindingNames();\n      this.maybeRename_ = false;\n      this.inObjectPattern_ = false;\n      this.currentLoopTree_ = null;\n    }\n    return ($traceurRuntime.createClass)(BlockBindingTransformer, {\n      getVariableName_: function(variable) {\n        var lvalue = variable.lvalue;\n        if (lvalue.type === BINDING_IDENTIFIER) {\n          return lvalue.getStringValue();\n        }\n        throw new Error('Unexpected destructuring declaration found.');\n      },\n      flushRenames: function(tree) {\n        tree = renameAll(this.blockRenames_, tree);\n        this.blockRenames_.length = 0;\n        return tree;\n      },\n      pushScope: function(tree) {\n        var scope = this.scopeBuilder_.getScopeForTree(tree);\n        if (!scope)\n          throw new Error('BlockBindingTransformer tree with no scope');\n        if (this.scope_)\n          this.scope_.blockBindingRenames = this.blockRenames_;\n        this.scope_ = scope;\n        this.blockRenames_ = [];\n        return scope;\n      },\n      popScope: function(scope) {\n        if (this.scope_ !== scope) {\n          throw new Error('BlockBindingTransformer scope mismatch');\n        }\n        this.scope_ = scope.parent;\n        this.blockRenames_ = this.scope_ && this.scope_.blockBindingRenames || [];\n      },\n      revisitTreeForScopes: function(tree) {\n        this.scopeBuilder_.scope = this.scope_;\n        this.scopeBuilder_.visitAny(tree);\n        this.scopeBuilder_.scope = null;\n      },\n      needsRename_: function(name) {\n        if (this.usedVars_.has(name))\n          return true;\n        var scope = this.scope_;\n        var parent = scope.parent;\n        if (!parent || scope.isVarScope)\n          return false;\n        var varScope = scope.getVarScope();\n        if (varScope && varScope.hasFreeVariable(name)) {\n          return true;\n        }\n        var parentBinding = parent.getBindingByName(name);\n        if (!parentBinding)\n          return false;\n        var currentBinding = scope.getBindingByName(name);\n        if (currentBinding.tree === parentBinding.tree)\n          return false;\n        return true;\n      },\n      newNameFromOrig: function(origName, renames) {\n        var newName;\n        if (this.needsRename_(origName)) {\n          newName = origName + this.idGenerator_.generateUniqueIdentifier();\n          renames.push(new Rename(origName, newName));\n        } else {\n          this.usedVars_.add(origName);\n          newName = origName;\n        }\n        return newName;\n      },\n      transformFunctionBody: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var statements = prependStatements.apply((void 0), $traceurRuntime.spread([tree.statements], this.prependStatement_));\n            tree = new FunctionBody(tree.location, statements);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_, this.scope_);\n          var functionBodyTree = functionTransform.transformAny(tree);\n          if (functionBodyTree === tree) {\n            return tree;\n          }\n          tree = new FunctionBody(tree.location, functionBodyTree.statements);\n        }\n        return tree;\n      },\n      transformScript: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformScript\").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var scriptItemList = prependStatements.apply((void 0), $traceurRuntime.spread([tree.scriptItemList], this.prependStatement_));\n            tree = new Script(tree.location, scriptItemList, tree.moduleName);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_);\n          var newTree = functionTransform.transformAny(tree);\n          if (newTree === tree) {\n            return tree;\n          }\n          tree = new Script(tree.location, newTree.scriptItemList, tree.moduleName);\n        }\n        return tree;\n      },\n      transformModule: function(tree) {\n        if (tree === this.rootTree_ || !this.rootTree_) {\n          tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformModule\").call(this, tree);\n          if (this.prependStatement_.length || this.blockRenames_.length) {\n            var scriptItemList = prependStatements.apply((void 0), $traceurRuntime.spread([tree.scriptItemList], this.prependStatement_));\n            tree = new Module(tree.location, scriptItemList, tree.moduleName);\n            tree = this.flushRenames(tree);\n          }\n        } else {\n          var functionTransform = new BlockBindingTransformer(this.idGenerator_, this.reporter_, tree, this.scopeBuilder_);\n          var newTree = functionTransform.transformAny(tree);\n          if (newTree === tree) {\n            return tree;\n          }\n          tree = new Module(tree.location, newTree.scriptItemList, tree.moduleName);\n        }\n        return tree;\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations.type === ANON_BLOCK) {\n          return declarations;\n        }\n        if (declarations === tree.declarations) {\n          return tree;\n        }\n        return new VariableStatement(tree.location, declarations);\n      },\n      transformVariableDeclarationList: function(tree) {\n        if (tree.declarationType === VAR) {\n          return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformVariableDeclarationList\").call(this, tree);\n        }\n        this.maybeRename_ = !this.scope_.isVarScope;\n        var declarations = this.transformList(tree.declarations);\n        this.maybeRename_ = false;\n        return new VariableDeclarationList(tree.location, VAR, declarations);\n      },\n      transformVariableDeclaration: function(tree) {\n        var maybeRename = this.maybeRename_;\n        var lvalue = this.transformAny(tree.lvalue);\n        this.maybeRename_ = false;\n        var initializer = null;\n        if (tree.initializer) {\n          initializer = this.transformAny(tree.initializer);\n        } else if (varNeedsInitializer(tree, this.currentLoopTree_)) {\n          initializer = parseExpression($traceurRuntime.getTemplateObject([\"void 0\"]));\n        }\n        this.maybeRename_ = maybeRename;\n        if (tree.lvalue === lvalue && tree.initializer === initializer) {\n          return tree;\n        }\n        return new VariableDeclaration(tree.location, lvalue, tree.typeAnnotation, initializer);\n      },\n      transformBindingIdentifier: function(tree) {\n        if (this.maybeRename_) {\n          var origName = tree.getStringValue();\n          var newName = this.newNameFromOrig(origName, this.blockRenames_);\n          if (origName === newName) {\n            return tree;\n          }\n          var newToken = new IdentifierToken(tree.location, newName);\n          var bindingIdentifier = new BindingIdentifier(tree.location, newToken);\n          this.scope_.renameBinding(origName, bindingIdentifier, VAR, this.reporter_);\n          return bindingIdentifier;\n        }\n        return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformBindingIdentifier\").call(this, tree);\n      },\n      transformBindingElement: function(tree) {\n        var maybeRename = this.maybeRename_;\n        var inObjectPattern = this.inObjectPattern_;\n        var binding = this.transformAny(tree.binding);\n        this.maybeRename_ = false;\n        this.inObjectPattern_ = false;\n        var initializer = this.transformAny(tree.initializer);\n        this.maybeRename_ = maybeRename;\n        this.inObjectPattern_ = inObjectPattern;\n        if (tree.binding === binding && tree.initializer === initializer) {\n          return tree;\n        }\n        var bindingElement = new BindingElement(tree.location, binding, initializer);\n        if (this.inObjectPattern_ && tree.binding !== binding && tree.binding.type === BINDING_IDENTIFIER) {\n          return new ObjectPatternField(tree.location, new LiteralPropertyName(tree.location, tree.binding.identifierToken), bindingElement);\n        }\n        return bindingElement;\n      },\n      transformObjectPattern: function(tree) {\n        var inObjectPattern = this.inObjectPattern_;\n        this.inObjectPattern_ = true;\n        var transformed = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformObjectPattern\").call(this, tree);\n        this.inObjectPattern_ = inObjectPattern;\n        return transformed;\n      },\n      transformObjectPatternField: function(tree) {\n        var name = this.transformAny(tree.name);\n        this.inObjectPattern_ = false;\n        var element = this.transformAny(tree.element);\n        this.inObjectPattern_ = true;\n        if (tree.name === name && tree.element === element) {\n          return tree;\n        }\n        return new ObjectPatternField(tree.location, name, element);\n      },\n      transformBlock: function(tree) {\n        var scope = this.pushScope(tree);\n        var outerPrepends = this.prependBlockStatement_;\n        this.prependBlockStatement_ = [];\n        tree = $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformBlock\").call(this, tree);\n        if (this.prependBlockStatement_.length) {\n          tree = new Block(tree.location, prependStatements.apply((void 0), $traceurRuntime.spread([tree.statements], this.prependBlockStatement_)));\n        }\n        this.prependBlockStatement_ = outerPrepends;\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformCatch: function(tree) {\n        var scope = this.pushScope(tree);\n        var binding = this.transformAny(tree.binding);\n        var statements = this.transformList(tree.catchBody.statements);\n        if (binding !== tree.binding || statements !== tree.catchBody.statements) {\n          tree = new Catch(tree.location, binding, new Block(tree.catchBody.location, statements));\n        }\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformFunctionForScope_: function(func, tree) {\n        var scope = this.pushScope(tree);\n        tree = func();\n        tree = this.flushRenames(tree);\n        this.popScope(scope);\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformGetAccessor\").call($__3, tree);\n        }, tree);\n      },\n      transformSetAccessor: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformSetAccessor\").call($__3, tree);\n        }, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        var $__3 = this;\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformFunctionExpression\").call($__3, tree);\n        }, tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        var $__3 = this;\n        if (!this.scope_.isVarScope) {\n          var origName = tree.name.getStringValue();\n          var newName = this.newNameFromOrig(origName, this.blockRenames_);\n          var functionExpression = new FunctionExpression(tree.location, null, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n          this.revisitTreeForScopes(functionExpression);\n          functionExpression = this.transformAny(functionExpression);\n          var bindingIdentifier = createBindingIdentifier(newName);\n          var statement = new VariableStatement(tree.location, new VariableDeclarationList(tree.location, VAR, [new VariableDeclaration(tree.location, bindingIdentifier, null, functionExpression)]));\n          this.scope_.renameBinding(origName, bindingIdentifier, VAR, this.reporter_);\n          this.prependBlockStatement_.push(statement);\n          return new AnonBlock(null, []);\n        }\n        return this.transformFunctionForScope_(function() {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformFunctionDeclaration\").call($__3, tree);\n        }, tree);\n      },\n      transformLoop_: function(func, tree, loopFactory) {\n        var $__3 = this;\n        var scope,\n            initializerIsBlockBinding;\n        if (tree.initializer && tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarationType !== VAR) {\n          initializerIsBlockBinding = true;\n        }\n        if (initializerIsBlockBinding) {\n          scope = this.pushScope(tree);\n        }\n        var finder = new FindBlockBindingInLoop(tree, this.scopeBuilder_);\n        finder.visitAny(tree);\n        if (!finder.found) {\n          var callFunc = function() {\n            var currentLoopTree = $__3.currentLoopTree_;\n            $__3.currentLoopTree_ = tree;\n            var rv = func(tree);\n            $__3.currentLoopTree_ = currentLoopTree;\n            return rv;\n          };\n          if (!initializerIsBlockBinding) {\n            return callFunc();\n          }\n          var renames = [];\n          var initializer = new VariableDeclarationList(null, VAR, tree.initializer.declarations.map(function(declaration) {\n            var origName = $__3.getVariableName_(declaration);\n            var newName = $__3.newNameFromOrig(origName, renames);\n            var bindingIdentifier = createBindingIdentifier(newName);\n            $__3.scope_.renameBinding(origName, bindingIdentifier, VAR, $__3.reporter_);\n            return new VariableDeclaration(null, bindingIdentifier, null, declaration.initializer);\n          }));\n          initializer = renameAll(renames, initializer);\n          tree = loopFactory(initializer, renames, renameAll(renames, tree.body));\n          this.revisitTreeForScopes(tree);\n          tree = callFunc();\n        } else {\n          var iifeParameterList = [];\n          var iifeArgumentList = [];\n          var renames$__4 = [];\n          var initializer$__5 = null;\n          if (tree.initializer) {\n            if (tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarationType !== VAR) {\n              initializer$__5 = new VariableDeclarationList(null, VAR, tree.initializer.declarations.map(function(declaration) {\n                var origName = $__3.getVariableName_(declaration);\n                var newName = $__3.newNameFromOrig(origName, renames$__4);\n                iifeArgumentList.push(createIdentifierExpression(newName));\n                iifeParameterList.push(new FormalParameter(null, new BindingElement(null, createBindingIdentifier(origName), null), null, []));\n                var bindingIdentifier = createBindingIdentifier(newName);\n                $__3.scope_.renameBinding(origName, bindingIdentifier, VAR, $__3.reporter_);\n                return new VariableDeclaration(null, bindingIdentifier, null, declaration.initializer);\n              }));\n              initializer$__5 = renameAll(renames$__4, initializer$__5);\n            } else {\n              initializer$__5 = this.transformAny(tree.initializer);\n            }\n          }\n          var loopLabel = this.labelledLoops_.get(tree);\n          var iifeInfo = FnExtractAbruptCompletions.createIIFE(this.idGenerator_, tree.body, iifeParameterList, iifeArgumentList, function() {\n            return loopLabel = loopLabel || createIdentifierToken($__3.idGenerator_.generateUniqueIdentifier());\n          }, this.scope_.inGenerator);\n          tree = loopFactory(initializer$__5, renames$__4, iifeInfo.loopBody);\n          if (loopLabel) {\n            tree = new LabelledStatement(tree.location, loopLabel, tree);\n          }\n          tree = new AnonBlock(tree.location, [iifeInfo.variableStatements, tree]);\n          this.revisitTreeForScopes(tree);\n          tree = this.transformAny(tree);\n        }\n        if (initializerIsBlockBinding) {\n          tree = this.flushRenames(tree);\n          this.popScope(scope);\n        }\n        return tree;\n      },\n      transformForInStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformForInStatement\").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new ForInStatement(tree.location, initializer, renameAll(renames, tree.collection), body);\n        });\n      },\n      transformForStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformForStatement\").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new ForStatement(tree.location, initializer, renameAll(renames, tree.condition), renameAll(renames, tree.increment), body);\n        });\n      },\n      transformWhileStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformWhileStatement\").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new WhileStatement(tree.location, renameAll(renames, tree.condition), body);\n        });\n      },\n      transformDoWhileStatement: function(tree) {\n        var $__3 = this;\n        return this.transformLoop_(function(t) {\n          return $traceurRuntime.superGet($__3, BlockBindingTransformer.prototype, \"transformDoWhileStatement\").call($__3, t);\n        }, tree, function(initializer, renames, body) {\n          return new DoWhileStatement(tree.location, body, renameAll(renames, tree.condition));\n        });\n      },\n      transformLabelledStatement: function(tree) {\n        if (tree.statement.isIterationStatement()) {\n          this.labelledLoops_.set(tree.statement, tree.name.value);\n          var statement = this.transformAny(tree.statement);\n          if (!statement.isStatement()) {\n            return statement;\n          }\n          if (statement === tree.statement) {\n            return tree;\n          }\n          return new LabelledStatement(tree.location, tree.name, statement);\n        }\n        return $traceurRuntime.superGet(this, BlockBindingTransformer.prototype, \"transformLabelledStatement\").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  var Rename = function() {\n    function Rename(oldName, newName) {\n      this.oldName = oldName;\n      this.newName = newName;\n    }\n    return ($traceurRuntime.createClass)(Rename, {}, {});\n  }();\n  function renameAll(renames, tree) {\n    renames.forEach(function(rename) {\n      tree = AlphaRenamer.rename(tree, rename.oldName, rename.newName);\n    });\n    return tree;\n  }\n  var FindBlockBindingInLoop = function($__super) {\n    function FindBlockBindingInLoop(tree, scopeBuilder) {\n      $traceurRuntime.superConstructor(FindBlockBindingInLoop).call(this);\n      this.scopeBuilder_ = scopeBuilder;\n      this.topScope_ = scopeBuilder.getScopeForTree(tree) || scopeBuilder.getScopeForTree(tree.body);\n      this.outOfScope_ = null;\n      this.acceptLoop_ = tree.isIterationStatement();\n    }\n    return ($traceurRuntime.createClass)(FindBlockBindingInLoop, {\n      visitForInStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, \"visitForInStatement\").call($__3, tree);\n        });\n      },\n      visitForStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, \"visitForStatement\").call($__3, tree);\n        });\n      },\n      visitWhileStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, \"visitWhileStatement\").call($__3, tree);\n        });\n      },\n      visitDoWhileStatement: function(tree) {\n        var $__3 = this;\n        this.visitLoop_(tree, function() {\n          return $traceurRuntime.superGet($__3, FindBlockBindingInLoop.prototype, \"visitDoWhileStatement\").call($__3, tree);\n        });\n      },\n      visitLoop_: function(tree, func) {\n        if (this.acceptLoop_) {\n          this.acceptLoop_ = false;\n        } else if (!this.outOfScope_) {\n          this.outOfScope_ = this.scopeBuilder_.getScopeForTree(tree) || this.scopeBuilder_.getScopeForTree(tree.body);\n        }\n        func();\n      },\n      visitArrowFunction: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitGetAccessor: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitMethod: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitSetAccessor: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        var $__3 = this;\n        this.found = new FindIdentifiers(tree, function(identifierToken, identScope) {\n          identScope = $__3.scopeBuilder_.getScopeForTree(identScope);\n          var fnScope = $__3.outOfScope_ || $__3.scopeBuilder_.getScopeForTree(tree);\n          if (identScope.hasLexicalBindingName(identifierToken)) {\n            return false;\n          }\n          while (identScope !== fnScope && (identScope = identScope.parent)) {\n            if (identScope.hasLexicalBindingName(identifierToken)) {\n              return false;\n            }\n          }\n          while (fnScope = fnScope.parent) {\n            if (fnScope.hasLexicalBindingName(identifierToken)) {\n              return true;\n            }\n            if (fnScope.hasVariableBindingName(identifierToken)) {\n              return false;\n            }\n            if (fnScope === $__3.topScope_)\n              break;\n          }\n          return false;\n        }).found;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get BlockBindingTransformer() {\n      return BlockBindingTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\")),\n      FunctionBody = $__1.FunctionBody,\n      Script = $__1.Script;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\")).ParseTreeTransformer;\n  var createUseStrictDirective = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\")).createUseStrictDirective;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/util.js\", \"traceur@0.0.111/src/codegeneration/MakeStrictTransformer.js\")).hasUseStrict;\n  function prepend(statements) {\n    return $traceurRuntime.spread([createUseStrictDirective()], statements);\n  }\n  var MakeStrictTransformer = function($__super) {\n    function MakeStrictTransformer() {\n      $traceurRuntime.superConstructor(MakeStrictTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MakeStrictTransformer, {\n      transformScript: function(tree) {\n        if (hasUseStrict(tree.scriptItemList))\n          return tree;\n        return new Script(tree.location, prepend(tree.scriptItemList), tree.moduleName);\n      },\n      transformFunctionBody: function(tree) {\n        if (hasUseStrict(tree.statements))\n          return tree;\n        return new FunctionBody(tree.location, prepend(tree.statements));\n      }\n    }, {transformTree: function(tree) {\n        return new MakeStrictTransformer().transformAny(tree);\n      }}, $__super);\n  }(ParseTreeTransformer);\n  return {get MakeStrictTransformer() {\n      return MakeStrictTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ClassTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\";\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).CONSTRUCTOR;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")),\n      AnonBlock = $__3.AnonBlock,\n      ClassExpression = $__3.ClassExpression,\n      ExportDeclaration = $__3.ExportDeclaration,\n      ExportSpecifier = $__3.ExportSpecifier,\n      ExportSpecifierSet = $__3.ExportSpecifierSet,\n      FunctionDeclaration = $__3.FunctionDeclaration,\n      FunctionExpression = $__3.FunctionExpression,\n      GetAccessor = $__3.GetAccessor,\n      Method = $__3.Method,\n      NamedExport = $__3.NamedExport,\n      SetAccessor = $__3.SetAccessor;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")),\n      CLASS_DECLARATION = $__4.CLASS_DECLARATION,\n      COMPUTED_PROPERTY_NAME = $__4.COMPUTED_PROPERTY_NAME,\n      EXPORT_DEFAULT = $__4.EXPORT_DEFAULT,\n      GET_ACCESSOR = $__4.GET_ACCESSOR,\n      LITERAL_PROPERTY_NAME = $__4.LITERAL_PROPERTY_NAME,\n      METHOD = $__4.METHOD,\n      SET_ACCESSOR = $__4.SET_ACCESSOR;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")),\n      CONST = $__6.CONST,\n      LET = $__6.LET,\n      VAR = $__6.VAR,\n      STRING = $__6.STRING;\n  var MakeStrictTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MakeStrictTransformer.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).MakeStrictTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParenTrait.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).ParenTrait;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).default;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")),\n      createBindingIdentifier = $__10.createBindingIdentifier,\n      id = $__10.createIdentifierExpression,\n      createIdentifierToken = $__10.createIdentifierToken,\n      createObjectLiteral = $__10.createObjectLiteral,\n      createVariableStatement = $__10.createVariableStatement;\n  var hasUseStrict = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/util.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")).hasUseStrict;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ClassTransformer.js\")),\n      parseExpression = $__12.parseExpression,\n      parsePropertyDefinition = $__12.parsePropertyDefinition,\n      parseStatement = $__12.parseStatement;\n  function methodNameFromTree(tree) {\n    if (tree.type === COMPUTED_PROPERTY_NAME) {\n      return '';\n    }\n    if (tree.literalToken && tree.literalToken.type === STRING) {\n      return tree.getStringValue().substr(1, -1);\n    }\n    return tree.getStringValue();\n  }\n  function classMethodDebugName(className, methodName, isStatic) {\n    if (isStatic) {\n      return createBindingIdentifier('$__' + className + '_' + methodName);\n    }\n    return createBindingIdentifier('$__' + className + '_prototype_' + methodName);\n  }\n  function functionExpressionToDeclaration(tree, name) {\n    if (tree.name === null) {\n      name = createBindingIdentifier(name);\n    } else {\n      name = tree.name;\n    }\n    return new FunctionDeclaration(tree.location, name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n  }\n  function removeStaticModifier(tree) {\n    switch (tree.type) {\n      case GET_ACCESSOR:\n        return new GetAccessor(tree.location, false, tree.name, tree.typeAnnotation, tree.annotations, tree.body);\n      case SET_ACCESSOR:\n        return new SetAccessor(tree.location, false, tree.name, tree.parameterList, tree.annotations, tree.body);\n      case METHOD:\n        return new Method(tree.location, false, tree.functionKind, tree.name, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body, tree.debugName);\n      default:\n        throw new Error('unreachable');\n    }\n  }\n  function isConstructor(tree) {\n    if (tree.type !== METHOD || tree.isStatic || tree.functionKind !== null) {\n      return false;\n    }\n    var name = tree.name;\n    return name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === CONSTRUCTOR;\n  }\n  var ClassTransformer = function($__super) {\n    function ClassTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ClassTransformer).call(this, identifierGenerator, reporter, options);\n      this.strictCount_ = 0;\n      this.state_ = null;\n    }\n    return ($traceurRuntime.createClass)(ClassTransformer, {\n      transformModule: function(tree) {\n        this.strictCount_ = 1;\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, \"transformModule\").call(this, tree);\n      },\n      transformScript: function(tree) {\n        this.strictCount_ = hasUseStrict(tree.scriptItemList) ? 1 : 0;\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, \"transformScript\").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        var useStrict = hasUseStrict(tree.statements) ? 1 : 0;\n        this.strictCount_ += useStrict;\n        var result = $traceurRuntime.superGet(this, ClassTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n        this.strictCount_ -= useStrict;\n        return result;\n      },\n      makeStrict_: function(tree) {\n        if (this.strictCount_)\n          return tree;\n        return MakeStrictTransformer.transformTree(tree);\n      },\n      transformClassDeclaration: function(tree) {\n        var classExpression = new ClassExpression(tree.location, tree.name, tree.superClass, tree.elements, tree.annotations, tree.typeParameters);\n        var transformed = this.transformClassExpression(classExpression);\n        var useLet = !this.options.transformOptions.blockBinding && this.options.parseOptions.blockBinding;\n        return createVariableStatement(useLet ? LET : VAR, tree.name, transformed);\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var elements = this.transformList(tree.elements);\n        var annotations = this.transformList(tree.annotations);\n        var constructor = null;\n        var protoElements = elements.filter(function(tree) {\n          if (tree.isStatic)\n            return false;\n          if (isConstructor(tree)) {\n            constructor = tree;\n            return false;\n          }\n          return true;\n        });\n        var staticElements = elements.filter(function(tree) {\n          return tree.isStatic;\n        }).map(removeStaticModifier);\n        var protoObject = createObjectLiteral(protoElements);\n        var staticObject = createObjectLiteral(staticElements);\n        if (!constructor) {\n          constructor = this.getDefaultConstructor_(tree);\n        }\n        var func = new FunctionExpression(tree.location, tree.name, null, constructor.parameterList, null, annotations, constructor.body);\n        var expression;\n        var createClass = this.getRuntimeExpression('createClass');\n        if (tree.name) {\n          var functionStatement;\n          var name = tree.name.identifierToken;\n          var nameId = id((\"\" + name));\n          if (!this.options.transformOptions.blockBinding && this.options.parseOptions.blockBinding) {\n            functionStatement = createVariableStatement(CONST, tree.name, func);\n          } else {\n            functionStatement = functionExpressionToDeclaration(func, name);\n          }\n          if (superClass) {\n            expression = parseExpression($traceurRuntime.getTemplateObject([\"function($__super) {\\n          \", \";\\n          return (\", \")(\", \", \", \",\\n                                  \", \", $__super);\\n        }(\", \")\"]), functionStatement, createClass, nameId, protoObject, staticObject, superClass);\n          } else {\n            expression = parseExpression($traceurRuntime.getTemplateObject([\"function() {\\n          \", \";\\n          return (\", \")(\", \", \", \", \", \");\\n        }()\"]), functionStatement, createClass, nameId, protoObject, staticObject);\n          }\n        } else {\n          if (superClass) {\n            expression = parseExpression($traceurRuntime.getTemplateObject([\"(\", \")(\", \", \", \", \", \", \", \")\"]), createClass, func, protoObject, staticObject, superClass);\n          } else {\n            expression = parseExpression($traceurRuntime.getTemplateObject([\"(\", \")(\", \", \", \", \", \")\"]), createClass, func, protoObject, staticObject);\n          }\n        }\n        return this.makeStrict_(expression);\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === EXPORT_DEFAULT && tree.declaration.expression.type === CLASS_DECLARATION) {\n          return this.transformExportDefaultClass_(tree.declaration);\n        }\n        return $traceurRuntime.superGet(this, ClassTransformer.prototype, \"transformExportDeclaration\").call(this, tree);\n      },\n      transformExportDefaultClass_: function(tree) {\n        var name = tree.expression.name.identifierToken;\n        var specifier = new ExportSpecifier(name.location, name, createIdentifierToken('default'));\n        var exportTree = new ExportSpecifierSet(name.location, [specifier]);\n        var named = new NamedExport(name.location, exportTree, null);\n        var exp = new ExportDeclaration(name.location, named, []);\n        var classTree = this.transformAny(tree.expression);\n        return new AnonBlock(null, [classTree, exp]);\n      },\n      getDefaultConstructor_: function(tree) {\n        if (tree.superClass) {\n          var name = id(tree.name.identifierToken);\n          var superConstructor = this.getRuntimeExpression('superConstructor');\n          return parsePropertyDefinition($traceurRuntime.getTemplateObject([\"constructor() {\\n        \", \"(\", \").apply(this, arguments)\\n      }\"]), superConstructor, name);\n        }\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject([\"constructor() {}\"]));\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(TempVarTransformer)));\n  return {get ClassTransformer() {\n      return ClassTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\")).ModuleTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\")),\n      createIdentifierExpression = $__4.createIdentifierExpression,\n      createMemberExpression = $__4.createMemberExpression,\n      createPropertyNameAssignment = $__4.createPropertyNameAssignment;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\")),\n      EXPORT_DEFAULT = $__5.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__5.EXPORT_SPECIFIER;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\")),\n      parseExpression = $__6.parseExpression,\n      parseStatement = $__6.parseStatement,\n      parseStatements = $__6.parseStatements;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/ClosureModuleTransformer.js\")).prependStatements;\n  var ClosureModuleTransformer = function($__super) {\n    function ClosureModuleTransformer() {\n      $traceurRuntime.superConstructor(ClosureModuleTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ClosureModuleTransformer, {\n      moduleProlog: function() {\n        if (!this.moduleName) {\n          throw new Error('Closure modules (goog.module) require a moduleName');\n        }\n        return parseStatements($traceurRuntime.getTemplateObject([\"goog.module(\", \");\"]), this.moduleName);\n      },\n      wrapModule: function(statements) {\n        if (this.hasStarExports()) {\n          throw new Error('Closure modules (goog.module) do not support \"export *\"');\n        }\n        return statements;\n      },\n      addExportStatement: function(statements) {\n        if (!this.hasExports())\n          return statements;\n        var exportObject = this.getExportObject();\n        statements.push(parseStatement($traceurRuntime.getTemplateObject([\"exports = \", \"\"]), exportObject));\n        return statements;\n      },\n      getGetterExport: function($__1) {\n        var $__2 = $__1,\n            name = $__2.name,\n            tree = $__2.tree,\n            moduleSpecifier = $__2.moduleSpecifier;\n        var expression;\n        switch (tree.type) {\n          case EXPORT_DEFAULT:\n            expression = createIdentifierExpression('$__default');\n            break;\n          case EXPORT_SPECIFIER:\n            if (moduleSpecifier) {\n              var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);\n              expression = createMemberExpression(idName, tree.lhs);\n            } else {\n              expression = createPropertyNameAssignment(name, tree.lhs);\n            }\n            break;\n          default:\n            expression = createIdentifierExpression(name);\n            break;\n        }\n        return createPropertyNameAssignment(name, expression);\n      },\n      transformModuleSpecifier: function(tree) {\n        var moduleName = tree.token.processedValue;\n        return parseExpression($traceurRuntime.getTemplateObject([\"goog.require(\", \")\"]), moduleName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get ClosureModuleTransformer() {\n      return ClosureModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\";\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")).ModuleTransformer;\n  var NAMED_EXPORT = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")).NAMED_EXPORT;\n  var AnonBlock = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")).AnonBlock;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")),\n      parseExpression = $__6.parseExpression,\n      parsePropertyDefinition = $__6.parsePropertyDefinition,\n      parseStatement = $__6.parseStatement;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")),\n      createExpressionStatement = $__7.createExpressionStatement,\n      createObjectLiteral = $__7.createObjectLiteral,\n      createObjectLiteralForDescriptor = $__7.createObjectLiteralForDescriptor,\n      createPropertyNameAssignment = $__7.createPropertyNameAssignment;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")).prependStatements;\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindVisitor.js\", \"traceur@0.0.111/src/codegeneration/CommonJsModuleTransformer.js\")).FindVisitor;\n  var CommonJsModuleTransformer = function($__super) {\n    function CommonJsModuleTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(CommonJsModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n      this.namedExportsWithModuleSpecifiers_ = [];\n      this.isImportingDefault_ = false;\n      this.needsInteropRequire_ = false;\n    }\n    return ($traceurRuntime.createClass)(CommonJsModuleTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      wrapModule: function(statements) {\n        if (this.needsInteropRequire_) {\n          var req = parseStatement($traceurRuntime.getTemplateObject([\"function $__interopRequire(id) {\\n        id = require(id);\\n        return id && id.__esModule && id || {default: id};\\n      }\"]));\n          return prependStatements(statements, req);\n        }\n        return statements;\n      },\n      addExportStatement: function(statements) {\n        if (!this.hasExports()) {\n          return statements;\n        }\n        var descr = this.getExportDescriptors();\n        var exportObject = parseExpression($traceurRuntime.getTemplateObject([\"Object.defineProperties(module.exports, \", \")\"]), descr);\n        if (this.hasStarExports()) {\n          exportObject = this.getExportStar(exportObject);\n        }\n        return prependStatements.apply((void 0), $traceurRuntime.spread([statements], this.namedExportsWithModuleSpecifiers_, [createExpressionStatement(exportObject)]));\n      },\n      getExportDescriptors: function() {\n        var $__2 = this;\n        var properties = this.exportVisitor.getNonTypeNamedExports().map(function(exp) {\n          var f = parseExpression($traceurRuntime.getTemplateObject([\"function() { return \", \"; }\"]), $__2.getGetterExportReturnExpression(exp));\n          return createPropertyNameAssignment(exp.name, createObjectLiteralForDescriptor({\n            enumerable: true,\n            get: f\n          }));\n        });\n        properties.unshift(parsePropertyDefinition($traceurRuntime.getTemplateObject([\"__esModule: {value: true}\"])));\n        return createObjectLiteral(properties);\n      },\n      transformExportDeclaration: function(tree) {\n        this.checkForDefaultImport_(tree);\n        this.exportVisitor.visitAny(tree);\n        var transformed = this.transformAny(tree.declaration);\n        if (tree.declaration.type == NAMED_EXPORT && tree.declaration.moduleSpecifier !== null) {\n          this.namedExportsWithModuleSpecifiers_.push(transformed);\n          return new AnonBlock(null, []);\n        }\n        return transformed;\n      },\n      transformImportDeclaration: function(tree) {\n        this.checkForDefaultImport_(tree);\n        return $traceurRuntime.superGet(this, CommonJsModuleTransformer.prototype, \"transformImportDeclaration\").call(this, tree);\n      },\n      checkForDefaultImport_: function(tree) {\n        var finder = new FindDefault();\n        finder.visitAny(tree);\n        this.isImportingDefault_ = finder.found;\n      },\n      transformModuleSpecifier: function(tree) {\n        var moduleName = tree.token.processedValue;\n        if (this.isImportingDefault_) {\n          this.needsInteropRequire_ = true;\n          return parseExpression($traceurRuntime.getTemplateObject([\"$__interopRequire(\", \")\"]), moduleName);\n        }\n        return parseExpression($traceurRuntime.getTemplateObject([\"require(\", \")\"]), moduleName);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  var FindDefault = function($__super) {\n    function FindDefault() {\n      $traceurRuntime.superConstructor(FindDefault).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FindDefault, {\n      visitImportSpecifier: function(tree) {\n        this.found = tree.name !== null && tree.name.value === 'default';\n      },\n      visitNameSpaceImport: function(tree) {\n        this.found = true;\n      },\n      visitNameSpaceExport: function(tree) {\n        this.found = true;\n      },\n      visitExportSpecifier: function(tree) {\n        this.found = tree.lhs !== null && tree.lhs.value === 'default';\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  return {get CommonJsModuleTransformer() {\n      return CommonJsModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ParameterTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ParameterTransformer.js\";\n  var FunctionBody = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ParameterTransformer.js\")).FunctionBody;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ParameterTransformer.js\")).TempVarTransformer;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/ParameterTransformer.js\")).prependStatements;\n  var stack = [];\n  var ParameterTransformer = function($__super) {\n    function ParameterTransformer() {\n      $traceurRuntime.superConstructor(ParameterTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ParameterTransformer, {\n      transformArrowFunction: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformArrowFunction\").call(this, tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformFunctionExpression\").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformGetAccessor\").call(this, tree);\n      },\n      transformSetAccessor: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformSetAccessor\").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        stack.push([]);\n        return $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformMethod\").call(this, tree);\n      },\n      transformFunctionBody: function(tree) {\n        var transformedTree = $traceurRuntime.superGet(this, ParameterTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n        var statements = stack.pop();\n        if (!statements.length)\n          return transformedTree;\n        statements = prependStatements.apply((void 0), $traceurRuntime.spread([transformedTree.statements], statements));\n        return new FunctionBody(transformedTree.location, statements);\n      },\n      get parameterStatements() {\n        return stack[stack.length - 1];\n      },\n      transformConstructorType: function(tree) {\n        return tree;\n      },\n      transformFunctionType: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ParameterTransformer() {\n      return ParameterTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/util.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")),\n      isUndefined = $__1.isUndefined,\n      isVoidExpression = $__1.isVoidExpression;\n  var FormalParameterList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")).FormalParameterList;\n  var ParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParameterTransformer.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")).ParameterTransformer;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")).ARGUMENTS;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")),\n      NOT_EQUAL_EQUAL = $__5.NOT_EQUAL_EQUAL,\n      VAR = $__5.VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/DefaultParametersTransformer.js\")),\n      createBinaryExpression = $__6.createBinaryExpression,\n      createConditionalExpression = $__6.createConditionalExpression,\n      createIdentifierExpression = $__6.createIdentifierExpression,\n      createMemberLookupExpression = $__6.createMemberLookupExpression,\n      createNumberLiteral = $__6.createNumberLiteral,\n      createOperatorToken = $__6.createOperatorToken,\n      createVariableStatement = $__6.createVariableStatement,\n      createVoid0 = $__6.createVoid0;\n  function createDefaultAssignment(index, binding, initializer) {\n    var argumentsExpression = createMemberLookupExpression(createIdentifierExpression(ARGUMENTS), createNumberLiteral(index));\n    var assignmentExpression;\n    if (initializer === null || isUndefined(initializer) || isVoidExpression(initializer)) {\n      assignmentExpression = argumentsExpression;\n    } else {\n      assignmentExpression = createConditionalExpression(createBinaryExpression(argumentsExpression, createOperatorToken(NOT_EQUAL_EQUAL), createVoid0()), argumentsExpression, initializer);\n    }\n    return createVariableStatement(VAR, binding, assignmentExpression);\n  }\n  var DefaultParametersTransformer = function($__super) {\n    function DefaultParametersTransformer() {\n      $traceurRuntime.superConstructor(DefaultParametersTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(DefaultParametersTransformer, {transformFormalParameterList: function(tree) {\n        var parameters = [];\n        var changed = false;\n        var defaultToUndefined = false;\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var param = this.transformAny(tree.parameters[i]);\n          if (param !== tree.parameters[i])\n            changed = true;\n          if (param.isRestParameter() || !param.parameter.initializer && !defaultToUndefined) {\n            parameters.push(param);\n          } else {\n            defaultToUndefined = true;\n            changed = true;\n            this.parameterStatements.push(createDefaultAssignment(i, param.parameter.binding, param.parameter.initializer));\n          }\n        }\n        if (!changed)\n          return tree;\n        return new FormalParameterList(tree.location, parameters);\n      }}, {}, $__super);\n  }(ParameterTransformer);\n  return {get DefaultParametersTransformer() {\n      return DefaultParametersTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js\";\n  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/assignmentOperatorToBinaryOperator.js\")),\n      AMPERSAND = $__0.AMPERSAND,\n      AMPERSAND_EQUAL = $__0.AMPERSAND_EQUAL,\n      BAR = $__0.BAR,\n      BAR_EQUAL = $__0.BAR_EQUAL,\n      CARET = $__0.CARET,\n      CARET_EQUAL = $__0.CARET_EQUAL,\n      LEFT_SHIFT = $__0.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__0.LEFT_SHIFT_EQUAL,\n      MINUS = $__0.MINUS,\n      MINUS_EQUAL = $__0.MINUS_EQUAL,\n      PERCENT = $__0.PERCENT,\n      PERCENT_EQUAL = $__0.PERCENT_EQUAL,\n      PLUS = $__0.PLUS,\n      PLUS_EQUAL = $__0.PLUS_EQUAL,\n      RIGHT_SHIFT = $__0.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__0.RIGHT_SHIFT_EQUAL,\n      SLASH = $__0.SLASH,\n      SLASH_EQUAL = $__0.SLASH_EQUAL,\n      STAR = $__0.STAR,\n      STAR_EQUAL = $__0.STAR_EQUAL,\n      STAR_STAR = $__0.STAR_STAR,\n      STAR_STAR_EQUAL = $__0.STAR_STAR_EQUAL,\n      UNSIGNED_RIGHT_SHIFT = $__0.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__0.UNSIGNED_RIGHT_SHIFT_EQUAL;\n  function assignmentOperatorToBinaryOperator(type) {\n    switch (type) {\n      case STAR_EQUAL:\n        return STAR;\n      case STAR_STAR_EQUAL:\n        return STAR_STAR;\n      case SLASH_EQUAL:\n        return SLASH;\n      case PERCENT_EQUAL:\n        return PERCENT;\n      case PLUS_EQUAL:\n        return PLUS;\n      case MINUS_EQUAL:\n        return MINUS;\n      case LEFT_SHIFT_EQUAL:\n        return LEFT_SHIFT;\n      case RIGHT_SHIFT_EQUAL:\n        return RIGHT_SHIFT;\n      case UNSIGNED_RIGHT_SHIFT_EQUAL:\n        return UNSIGNED_RIGHT_SHIFT;\n      case AMPERSAND_EQUAL:\n        return AMPERSAND;\n      case CARET_EQUAL:\n        return CARET;\n      case BAR_EQUAL:\n        return BAR;\n      default:\n        throw Error('unreachable');\n    }\n  }\n  var $__default = assignmentOperatorToBinaryOperator;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")).ParseTreeTransformer;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")),\n      createAssignmentExpression = $__13.createAssignmentExpression,\n      createCommaExpression = $__13.createCommaExpression,\n      id = $__13.createIdentifierExpression,\n      createMemberExpression = $__13.createMemberExpression,\n      createNumberLiteral = $__13.createNumberLiteral,\n      createOperatorToken = $__13.createOperatorToken,\n      createParenExpression = $__13.createParenExpression;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")),\n      AND = $__14.AND,\n      EQUAL = $__14.EQUAL,\n      MINUS = $__14.MINUS,\n      MINUS_EQUAL = $__14.MINUS_EQUAL,\n      MINUS_MINUS = $__14.MINUS_MINUS,\n      OR = $__14.OR,\n      PLUS = $__14.PLUS,\n      PLUS_EQUAL = $__14.PLUS_EQUAL,\n      PLUS_PLUS = $__14.PLUS_PLUS;\n  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")),\n      COMMA_EXPRESSION = $__15.COMMA_EXPRESSION,\n      IDENTIFIER_EXPRESSION = $__15.IDENTIFIER_EXPRESSION,\n      MEMBER_EXPRESSION = $__15.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__15.MEMBER_LOOKUP_EXPRESSION,\n      PROPERTY_NAME_ASSIGNMENT = $__15.PROPERTY_NAME_ASSIGNMENT,\n      SPREAD_EXPRESSION = $__15.SPREAD_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__15.TEMPLATE_LITERAL_PORTION;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")),\n      ArgumentList = $__16.ArgumentList,\n      ArrayLiteral = $__16.ArrayLiteral,\n      AwaitExpression = $__16.AwaitExpression,\n      BinaryExpression = $__16.BinaryExpression,\n      CallExpression = $__16.CallExpression,\n      ClassExpression = $__16.ClassExpression,\n      ConditionalExpression = $__16.ConditionalExpression,\n      MemberExpression = $__16.MemberExpression,\n      MemberLookupExpression = $__16.MemberLookupExpression,\n      NewExpression = $__16.NewExpression,\n      ObjectLiteral = $__16.ObjectLiteral,\n      PropertyNameAssignment = $__16.PropertyNameAssignment,\n      SpreadExpression = $__16.SpreadExpression,\n      TemplateLiteralExpression = $__16.TemplateLiteralExpression,\n      TemplateSubstitution = $__16.TemplateSubstitution,\n      UnaryExpression = $__16.UnaryExpression,\n      YieldExpression = $__16.YieldExpression;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")).assert;\n  var assignmentOperatorToBinaryOperator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./assignmentOperatorToBinaryOperator.js\", \"traceur@0.0.111/src/codegeneration/ExplodeExpressionTransformer.js\")).default;\n  var CommaExpressionBuilder = function() {\n    function CommaExpressionBuilder(tempVar) {\n      this.tempVar = tempVar;\n      this.expressions = [];\n    }\n    return ($traceurRuntime.createClass)(CommaExpressionBuilder, {\n      add: function(tree) {\n        var $__2;\n        if (tree.type === COMMA_EXPRESSION)\n          ($__2 = this.expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(tree)));\n        return this;\n      },\n      build: function(tree) {\n        var tempVar = this.tempVar;\n        this.expressions.push(createAssignmentExpression(tempVar, tree), tempVar);\n        return createCommaExpression(this.expressions);\n      }\n    }, {});\n  }();\n  function getResult(tree) {\n    if (tree.type === COMMA_EXPRESSION)\n      return tree.expressions[tree.expressions.length - 1];\n    return tree;\n  }\n  function getExpressions(tree) {\n    if (tree.type === COMMA_EXPRESSION)\n      return tree.expressions.slice(0, -1);\n    return [];\n  }\n  var ExplodeExpressionTransformer = function($__super) {\n    function ExplodeExpressionTransformer(tempVarTransformer) {\n      $traceurRuntime.superConstructor(ExplodeExpressionTransformer).call(this);\n      this.tempVarTransformer_ = tempVarTransformer;\n    }\n    return ($traceurRuntime.createClass)(ExplodeExpressionTransformer, {\n      addTempVar: function() {\n        var tmpId = this.tempVarTransformer_.addTempVar();\n        return id(tmpId);\n      },\n      transformUnaryExpression: function(tree) {\n        if (tree.operator.type === PLUS_PLUS)\n          return this.transformUnaryNumeric_(tree, PLUS_EQUAL);\n        if (tree.operator.type === MINUS_MINUS)\n          return this.transformUnaryNumeric_(tree, MINUS_EQUAL);\n        var operand = this.transformAny(tree.operand);\n        if (operand === tree.operand)\n          return tree;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [new UnaryExpression(tree.location, tree.operator, getResult(operand))]);\n        return createCommaExpression(expressions);\n      },\n      transformUnaryNumeric_: function(tree, operator) {\n        return this.transformAny(new BinaryExpression(tree.location, tree.operand, createOperatorToken(operator), createNumberLiteral(1)));\n      },\n      transformPostfixExpression: function(tree) {\n        if (tree.operand.type === MEMBER_EXPRESSION)\n          return this.transformPostfixMemberExpression_(tree);\n        if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformPostfixMemberLookupExpression_(tree);\n        assert(tree.operand.type === IDENTIFIER_EXPRESSION);\n        var operand = tree.operand;\n        var tmp = this.addTempVar();\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = [createAssignmentExpression(tmp, operand), createAssignmentExpression(operand, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp];\n        return createCommaExpression(expressions);\n      },\n      transformPostfixMemberExpression_: function(tree) {\n        var memberName = tree.operand.memberName;\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberExpression = new MemberExpression(tree.operand.location, getResult(operand), memberName);\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [createAssignmentExpression(tmp, memberExpression), createAssignmentExpression(memberExpression, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformPostfixMemberLookupExpression_: function(tree) {\n        var memberExpression = this.transformAny(tree.operand.memberExpression);\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberLookupExpression = new MemberLookupExpression(null, getResult(operand), getResult(memberExpression));\n        var operator = tree.operator.type === PLUS_PLUS ? PLUS : MINUS;\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), [createAssignmentExpression(tmp, memberLookupExpression), createAssignmentExpression(memberLookupExpression, new BinaryExpression(tree.location, tmp, createOperatorToken(operator), createNumberLiteral(1))), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformYieldExpression: function(tree) {\n        if (tree.expression === null) {\n          return this.createCommaExpressionBuilder_().build(new YieldExpression(tree.location, null, false));\n        }\n        var expression = this.transformAny(tree.expression);\n        return this.createCommaExpressionBuilder_().add(expression).build(new YieldExpression(tree.location, getResult(expression), tree.isYieldFor));\n      },\n      transformAwaitExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        return this.createCommaExpressionBuilder_().add(expression).build(new AwaitExpression(tree.location, getResult(expression)));\n      },\n      transformParenExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression)\n          return tree;\n        var result = getResult(expression);\n        if (result.type === IDENTIFIER_EXPRESSION)\n          return expression;\n        return this.createCommaExpressionBuilder_().add(expression).build(result);\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = this.transformList(tree.expressions);\n        if (expressions === tree.expressions)\n          return tree;\n        var builder = new CommaExpressionBuilder(null);\n        for (var i = 0; i < expressions.length; i++) {\n          builder.add(expressions[i]);\n        }\n        return createCommaExpression($traceurRuntime.spread(builder.expressions, [getResult(expressions[expressions.length - 1])]));\n      },\n      transformMemberExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        return this.createCommaExpressionBuilder_().add(operand).build(new MemberExpression(tree.location, getResult(operand), tree.memberName));\n      },\n      transformMemberLookupExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var memberExpression = this.transformAny(tree.memberExpression);\n        return this.createCommaExpressionBuilder_().add(operand).add(memberExpression).build(new MemberLookupExpression(tree.location, getResult(operand), getResult(memberExpression)));\n      },\n      transformBinaryExpression: function(tree) {\n        if (tree.operator.isAssignmentOperator())\n          return this.transformAssignmentExpression_(tree);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left === tree.left && right === tree.right)\n          return tree;\n        if (tree.operator.type === OR)\n          return this.transformOr_(left, right);\n        if (tree.operator.type === AND)\n          return this.transformAnd_(left, right);\n        var expressions = $traceurRuntime.spread(getExpressions(left), getExpressions(right), [new BinaryExpression(tree.location, getResult(left), tree.operator, getResult(right))]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignmentExpression_: function(tree) {\n        var left = tree.left;\n        if (left.type === MEMBER_EXPRESSION)\n          return this.transformAssignMemberExpression_(tree);\n        if (left.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformAssignMemberLookupExpression_(tree);\n        assert(tree.left.type === IDENTIFIER_EXPRESSION);\n        if (tree.operator.type === EQUAL) {\n          left = this.transformAny(left);\n          var right$__3 = this.transformAny(tree.right);\n          var expressions$__4 = $traceurRuntime.spread(getExpressions(right$__3), [createAssignmentExpression(left, getResult(right$__3)), getResult(right$__3)]);\n          return createCommaExpression(expressions$__4);\n        }\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(tmp, new BinaryExpression(tree.location, left, binop, getResult(right))), createAssignmentExpression(left, tmp), tmp]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignMemberExpression_: function(tree) {\n        var left = tree.left;\n        if (tree.operator.type === EQUAL) {\n          var operand$__5 = this.transformAny(left.operand);\n          var right$__6 = this.transformAny(tree.right);\n          var expressions$__7 = $traceurRuntime.spread(getExpressions(operand$__5), getExpressions(right$__6), [new BinaryExpression(tree.location, new MemberExpression(left.location, getResult(operand$__5), left.memberName), tree.operator, getResult(right$__6)), getResult(right$__6)]);\n          return createCommaExpression(expressions$__7);\n        }\n        var operand = this.transformAny(left.operand);\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var memberExpression = new MemberExpression(left.location, getResult(operand), left.memberName);\n        var tmp2 = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(right), [createAssignmentExpression(tmp, memberExpression), createAssignmentExpression(tmp2, new BinaryExpression(tree.location, tmp, binop, getResult(right))), createAssignmentExpression(memberExpression, tmp2), tmp2]);\n        return createCommaExpression(expressions);\n      },\n      transformAssignMemberLookupExpression_: function(tree) {\n        var left = tree.left;\n        if (tree.operator.type === EQUAL) {\n          var operand$__8 = this.transformAny(left.operand);\n          var memberExpression$__9 = this.transformAny(left.memberExpression);\n          var right$__10 = this.transformAny(tree.right);\n          var expressions$__11 = $traceurRuntime.spread(getExpressions(operand$__8), getExpressions(memberExpression$__9), getExpressions(right$__10), [new BinaryExpression(tree.location, new MemberLookupExpression(left.location, getResult(operand$__8), getResult(memberExpression$__9)), tree.operator, getResult(right$__10)), getResult(right$__10)]);\n          return createCommaExpression(expressions$__11);\n        }\n        var operand = this.transformAny(left.operand);\n        var memberExpression = this.transformAny(left.memberExpression);\n        var right = this.transformAny(tree.right);\n        var tmp = this.addTempVar();\n        var memberLookupExpression = new MemberLookupExpression(left.location, getResult(operand), getResult(memberExpression));\n        var tmp2 = this.addTempVar();\n        var binop = createOperatorToken(assignmentOperatorToBinaryOperator(tree.operator.type));\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), getExpressions(right), [createAssignmentExpression(tmp, memberLookupExpression), createAssignmentExpression(tmp2, new BinaryExpression(tree.location, tmp, binop, getResult(right))), createAssignmentExpression(memberLookupExpression, tmp2), tmp2]);\n        return createCommaExpression(expressions);\n      },\n      transformArrayLiteral: function(tree) {\n        var elements = this.transformList(tree.elements);\n        if (elements === tree.elements)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        var results = [];\n        for (var i = 0; i < elements.length; i++) {\n          builder.add(elements[i]);\n          results.push(getResult(elements[i]));\n        }\n        return builder.build(new ArrayLiteral(tree.location, results));\n      },\n      transformObjectLiteral: function(tree) {\n        var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);\n        if (propertyNameAndValues === tree.propertyNameAndValues)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        var results = [];\n        for (var i = 0; i < propertyNameAndValues.length; i++) {\n          if (propertyNameAndValues[i].type === PROPERTY_NAME_ASSIGNMENT) {\n            builder.add(propertyNameAndValues[i].value);\n            results.push(new PropertyNameAssignment(propertyNameAndValues[i].location, propertyNameAndValues[i].name, getResult(propertyNameAndValues[i].value)));\n          } else {\n            results.push(propertyNameAndValues[i]);\n          }\n        }\n        return builder.build(new ObjectLiteral(tree.location, results));\n      },\n      transformTemplateLiteralExpression: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var elements = this.transformList(tree.elements);\n        if (!operand && operand === tree.operand && elements === tree.elements)\n          return tree;\n        var builder = this.createCommaExpressionBuilder_();\n        if (operand)\n          builder.add(operand);\n        var results = [];\n        for (var i = 0; i < elements.length; i++) {\n          if (elements[i].type === TEMPLATE_LITERAL_PORTION) {\n            results.push(elements[i]);\n          } else {\n            var expression = elements[i].expression;\n            builder.add(expression);\n            var result = getResult(expression);\n            results.push(new TemplateSubstitution(expression.location, result));\n          }\n        }\n        return builder.build(new TemplateLiteralExpression(tree.location, operand && getResult(operand), results));\n      },\n      transformCallExpression: function(tree) {\n        if (tree.operand.type === MEMBER_EXPRESSION)\n          return this.transformCallMemberExpression_(tree);\n        if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION)\n          return this.transformCallMemberLookupExpression_(tree);\n        return this.transformCallAndNew_(tree, CallExpression);\n      },\n      transformNewExpression: function(tree) {\n        return this.transformCallAndNew_(tree, NewExpression);\n      },\n      transformCallAndNew_: function(tree, ctor) {\n        var operand = this.transformAny(tree.operand);\n        var args = this.transformAny(tree.args);\n        var builder = this.createCommaExpressionBuilder_().add(operand);\n        var argResults = [];\n        args.args.forEach(function(arg) {\n          builder.add(arg);\n          argResults.push(getResult(arg));\n        });\n        return builder.build(new ctor(tree.location, getResult(operand), new ArgumentList(args.location, argResults)));\n      },\n      transformCallMemberExpression_: function(tree) {\n        var memberName = tree.operand.memberName;\n        var operand = this.transformAny(tree.operand.operand);\n        var tmp = this.addTempVar();\n        var memberExpresssion = new MemberExpression(tree.operand.location, getResult(operand), memberName);\n        var args = this.transformAny(tree.args);\n        var expressions = $traceurRuntime.spread(getExpressions(operand), [createAssignmentExpression(tmp, memberExpresssion)]);\n        var argResults = [getResult(operand)];\n        args.args.forEach(function(arg) {\n          var $__2;\n          ($__2 = expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(arg)));\n          argResults.push(getResult(arg));\n        });\n        var callExpression = new CallExpression(tree.location, createMemberExpression(tmp, 'call'), new ArgumentList(args.location, argResults));\n        var tmp2 = this.addTempVar();\n        expressions.push(createAssignmentExpression(tmp2, callExpression), tmp2);\n        return createCommaExpression(expressions);\n      },\n      transformCallMemberLookupExpression_: function(tree) {\n        var operand = this.transformAny(tree.operand.operand);\n        var memberExpression = this.transformAny(tree.operand.memberExpression);\n        var tmp = this.addTempVar();\n        var lookupExpresssion = new MemberLookupExpression(tree.operand.location, getResult(operand), getResult(memberExpression));\n        var args = this.transformAny(tree.args);\n        var expressions = $traceurRuntime.spread(getExpressions(operand), getExpressions(memberExpression), [createAssignmentExpression(tmp, lookupExpresssion)]);\n        var argResults = [getResult(operand)];\n        args.args.forEach(function(arg, i) {\n          var $__2;\n          ($__2 = expressions).push.apply($__2, $traceurRuntime.spread(getExpressions(arg)));\n          var result = getResult(arg);\n          if (tree.args.args[i].type === SPREAD_EXPRESSION)\n            result = new SpreadExpression(arg.location, result);\n          argResults.push(result);\n        });\n        var callExpression = new CallExpression(tree.location, createMemberExpression(tmp, 'call'), new ArgumentList(args.location, argResults));\n        var tmp2 = this.addTempVar();\n        expressions.push(createAssignmentExpression(tmp2, callExpression), tmp2);\n        return createCommaExpression(expressions);\n      },\n      transformConditionalExpression: function(tree) {\n        var condition = this.transformAny(tree.condition);\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (condition === tree.condition && left === tree.left && right === tree.right)\n          return tree;\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression($traceurRuntime.spread(getExpressions(left), [createAssignmentExpression(res, getResult(left))]));\n        var rightTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var expressions = $traceurRuntime.spread(getExpressions(condition), [new ConditionalExpression(tree.location, getResult(condition), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformOr_: function(left, right) {\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression([createAssignmentExpression(res, getResult(left))]);\n        var rightTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var expressions = $traceurRuntime.spread(getExpressions(left), [new ConditionalExpression(left.location, getResult(left), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformAnd_: function(left, right) {\n        var res = this.addTempVar();\n        var leftTree = createCommaExpression($traceurRuntime.spread(getExpressions(right), [createAssignmentExpression(res, getResult(right))]));\n        var rightTree = createCommaExpression([createAssignmentExpression(res, getResult(left))]);\n        var expressions = $traceurRuntime.spread(getExpressions(left), [new ConditionalExpression(left.location, getResult(left), createParenExpression(leftTree), createParenExpression(rightTree)), res]);\n        return createCommaExpression(expressions);\n      },\n      transformSpreadExpression: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        if (expression === tree.expression)\n          return tree;\n        var result = getResult(expression);\n        if (result.type !== SPREAD_EXPRESSION)\n          result = new SpreadExpression(result.location, result);\n        var expressions = $traceurRuntime.spread(getExpressions(expression), [result]);\n        return createCommaExpression(expressions);\n      },\n      transformFunctionExpression: function(tree) {\n        return this.createCommaExpressionBuilder_().build(tree);\n      },\n      transformArrowFunction: function(tree) {\n        return this.createCommaExpressionBuilder_().build(tree);\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        if (superClass === tree.superClass) {\n          return this.createCommaExpressionBuilder_().build(tree);\n        }\n        var builder = this.createCommaExpressionBuilder_();\n        builder.add(superClass);\n        return builder.build(new ClassExpression(tree.location, tree.name, getResult(superClass), tree.elements, tree.annotations, tree.typeParameters));\n      },\n      transformFunctionBody: function(tree) {\n        return tree;\n      },\n      createCommaExpressionBuilder_: function() {\n        return new CommaExpressionBuilder(this.addTempVar());\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get ExplodeExpressionTransformer() {\n      return ExplodeExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\";\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ExplodeExpressionTransformer.js\", \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\")).ExplodeExpressionTransformer;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\")).TempVarTransformer;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParenTrait.js\", \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\")).ParenTrait;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\")),\n      STAR_STAR = $__4.STAR_STAR,\n      STAR_STAR_EQUAL = $__4.STAR_STAR_EQUAL;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ExponentiationTransformer.js\")).parseExpression;\n  var ExponentiationTransformer = function($__super) {\n    function ExponentiationTransformer() {\n      $traceurRuntime.superConstructor(ExponentiationTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ExponentiationTransformer, {transformBinaryExpression: function(tree) {\n        switch (tree.operator.type) {\n          case STAR_STAR:\n            {\n              var left = this.transformAny(tree.left);\n              var right = this.transformAny(tree.right);\n              return parseExpression($traceurRuntime.getTemplateObject([\"Math.pow(\", \", \", \")\"]), left, right);\n            }\n          case STAR_STAR_EQUAL:\n            {\n              var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n              return this.transformAny(exploded);\n            }\n        }\n        return $traceurRuntime.superGet(this, ExponentiationTransformer.prototype, \"transformBinaryExpression\").call(this, tree);\n      }}, {}, $__super);\n  }(ParenTrait(TempVarTransformer));\n  return {get ExponentiationTransformer() {\n      return ExponentiationTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\")),\n      FOR_OF_STATEMENT = $__1.FOR_OF_STATEMENT,\n      VARIABLE_DECLARATION_LIST = $__1.VARIABLE_DECLARATION_LIST,\n      LABELLED_STATEMENT = $__1.LABELLED_STATEMENT;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\")).TempVarTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\")),\n      id = $__3.createIdentifierExpression,\n      createMemberExpression = $__3.createMemberExpression,\n      createVariableStatement = $__3.createVariableStatement;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\")),\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ForOfTransformer.js\")),\n      AnonBlock = $__5.AnonBlock,\n      LabelledStatement = $__5.LabelledStatement;\n  var ForOfTransformer = function($__super) {\n    function ForOfTransformer() {\n      $traceurRuntime.superConstructor(ForOfTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForOfTransformer, {\n      transformForOfStatement: function(original) {\n        return this.transformForOfStatement_(original, []);\n      },\n      transformForOfStatement_: function(original, labelSet) {\n        var tree = $traceurRuntime.superGet(this, ForOfTransformer.prototype, \"transformForOfStatement\").call(this, original);\n        var iter = id(this.getTempIdentifier());\n        var result = id(this.getTempIdentifier());\n        var label = id(this.getTempIdentifier());\n        var normalCompletion = id(this.getTempIdentifier());\n        var throwCompletion = id(this.getTempIdentifier());\n        var exception = id(this.getTempIdentifier());\n        var ex = id(this.getTempIdentifier());\n        var labelledStatement;\n        var innerStatement;\n        var assignment;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          assignment = createVariableStatement(tree.initializer.declarationType, tree.initializer.declarations[0].lvalue, createMemberExpression(result, 'value'));\n        } else {\n          assignment = parseStatement($traceurRuntime.getTemplateObject([\"\", \" = \", \".value;\"]), tree.initializer, result);\n        }\n        innerStatement = parseStatement($traceurRuntime.getTemplateObject([\"\\n        for (var \", \",\\n                 \", \" = (\", \")[Symbol.iterator]();\\n             !(\", \" = (\", \" = \", \".next()).done);\\n             \", \" = true) {\\n          \", \"\\n          \", \"\\n        }\"]), result, iter, tree.collection, normalCompletion, result, iter, normalCompletion, assignment, tree.body);\n        while (labelledStatement = labelSet.pop()) {\n          innerStatement = new LabelledStatement(labelledStatement.location, labelledStatement.name, innerStatement);\n        }\n        return new AnonBlock(null, parseStatements($traceurRuntime.getTemplateObject([\"\\n        var \", \" = true;\\n        var \", \" = false;\\n        var \", \" = undefined;\\n        try {\\n          \", \"\\n        } catch (\", \") {\\n          \", \" = true;\\n          \", \" = \", \";\\n        } finally {\\n          try {\\n            if (!\", \" && \", \".return != null) {\\n              \", \".return();\\n            }\\n          } finally {\\n            if (\", \") {\\n              throw \", \";\\n            }\\n          }\\n        }\"]), normalCompletion, throwCompletion, exception, innerStatement, ex, throwCompletion, exception, ex, normalCompletion, iter, iter, throwCompletion, exception));\n      },\n      transformLabelledStatement: function(tree) {\n        var labelSet = [tree];\n        var statement = tree.statement;\n        while (statement.type === LABELLED_STATEMENT) {\n          labelSet.push(statement);\n          statement = statement.statement;\n        }\n        if (statement.type !== FOR_OF_STATEMENT) {\n          return $traceurRuntime.superGet(this, ForOfTransformer.prototype, \"transformLabelledStatement\").call(this, tree);\n        }\n        return this.transformForOfStatement_(statement, labelSet);\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ForOfTransformer() {\n      return ForOfTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).ParseTreeTransformer;\n  var alphaRenameThisAndArguments = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./alphaRenameThisAndArguments.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).default;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")),\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")),\n      AnonBlock = $__5.AnonBlock,\n      Block = $__5.Block,\n      ContinueStatement = $__5.ContinueStatement,\n      LabelledStatement = $__5.LabelledStatement,\n      ReturnStatement = $__5.ReturnStatement;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).StringSet;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")),\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createCaseClause = $__7.createCaseClause,\n      createDefaultClause = $__7.createDefaultClause,\n      id = $__7.createIdentifierExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createSwitchStatement = $__7.createSwitchStatement,\n      createThisExpression = $__7.createThisExpression,\n      createVariableStatement = $__7.createVariableStatement,\n      createVariableDeclaration = $__7.createVariableDeclaration,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVoid0 = $__7.createVoid0;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SkipFunctionsTransformerTrait.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).default;\n  var ARGUMENTS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).ARGUMENTS;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")).VAR;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/InnerForOnTransformer.js\")),\n      VARIABLE_DECLARATION_LIST = $__11.VARIABLE_DECLARATION_LIST,\n      BLOCK = $__11.BLOCK;\n  var InnerForOnTransformer = function($__super) {\n    function InnerForOnTransformer(tempIdGenerator, labelSet, options) {\n      var $__1;\n      $traceurRuntime.superConstructor(InnerForOnTransformer).call(this);\n      this.idGenerator_ = tempIdGenerator;\n      this.inLoop_ = 0;\n      this.inBreakble_ = 0;\n      this.variableDeclarations_ = [];\n      this.extractedStatements_ = [];\n      this.labelSet_ = labelSet;\n      this.labelledStatements_ = new StringSet();\n      this.observer_ = id(this.idGenerator_.getTempIdentifier());\n      this.result_ = id(this.idGenerator_.getTempIdentifier());\n      this.parentLabels_ = new StringSet();\n      this.labelSet_.forEach(($__1 = this, function(tree) {\n        $__1.parentLabels_.add(tree.name.value);\n      }));\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(InnerForOnTransformer, {\n      transform: function(tree) {\n        var value = id(this.idGenerator_.getTempIdentifier());\n        var assignment;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          assignment = createVariableStatement(tree.initializer.declarationType, tree.initializer.declarations[0].lvalue, value);\n        } else {\n          assignment = parseStatement($traceurRuntime.getTemplateObject([\"\\n          \", \" = \", \";\"]), tree.initializer, value);\n        }\n        var body;\n        if (tree.body.type === BLOCK) {\n          body = new Block(tree.body.location, $traceurRuntime.spread([assignment], tree.body.statements));\n        } else {\n          body = new Block(null, [assignment, tree.body]);\n        }\n        body = this.transformAny(body);\n        body = alphaRenameThisAndArguments(this, body);\n        this.variableDeclarations_.push(createVariableDeclaration(this.result_, createVoid0()));\n        var caseClauses = this.extractedStatements_.map(function(statement, index) {\n          return createCaseClause(createNumberLiteral(index), [statement]);\n        });\n        caseClauses.push(createCaseClause(createVoid0(), [new ContinueStatement(null, null)]));\n        caseClauses.push(createDefaultClause(parseStatements($traceurRuntime.getTemplateObject([\"\\n        return \", \".v;\"]), this.result_)));\n        var switchStatement = createSwitchStatement(this.result_, caseClauses);\n        var observeForEach = this.idGenerator_.getRuntimeExpression('observeForEach');\n        var statement = parseStatement($traceurRuntime.getTemplateObject([\"\\n        do {\\n          \", \"\\n            await \", \"(\\n              \", \"[Symbol.observer].bind(\", \"),\\n              async function (\", \") {\\n                var \", \" = this;\\n                try {\\n                  \", \"\\n                } catch (e) {\\n                  \", \".throw(e);\\n                }\\n              });\\n          \", \"\\n        } while (false);\"]), createVariableStatement(createVariableDeclarationList(VAR, this.variableDeclarations_)), observeForEach, tree.observable, tree.observable, value, this.observer_, body, this.observer_, switchStatement);\n        var labelledStatement;\n        while (labelledStatement = this.labelSet_.pop()) {\n          statement = new LabelledStatement(labelledStatement.location, labelledStatement.name, statement);\n        }\n        return statement;\n      },\n      addTempVarForArguments: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, id(ARGUMENTS)));\n        return tmpVarName;\n      },\n      addTempVarForThis: function() {\n        var tmpVarName = this.idGenerator_.generateUniqueIdentifier();\n        this.variableDeclarations_.push(createVariableDeclaration(tmpVarName, createThisExpression()));\n        return tmpVarName;\n      },\n      transformAny: function(tree) {\n        if (tree) {\n          if (tree.isBreakableStatement())\n            this.inBreakble_++;\n          if (tree.isIterationStatement())\n            this.inLoop_++;\n          tree = $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformAny\").call(this, tree);\n          if (tree.isBreakableStatement())\n            this.inBreakble_--;\n          if (tree.isIterationStatement())\n            this.inLoop_--;\n        }\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        return new AnonBlock(tree.location, parseStatements($traceurRuntime.getTemplateObject([\"\\n        \", \".return();\\n        \", \" = {v: \", \"};\\n        return;\"]), this.observer_, this.result_, (tree.expression || createVoid0())));\n      },\n      transformAbruptCompletion_: function(tree) {\n        this.extractedStatements_.push(tree);\n        var index = this.extractedStatements_.length - 1;\n        return new AnonBlock(null, parseStatements($traceurRuntime.getTemplateObject([\"\\n        \", \".return();\\n        \", \" = \", \";\\n        return;\"]), this.observer_, this.result_, index));\n      },\n      transformBreakStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inBreakble_) {\n            return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformBreakStatement\").call(this, tree);\n          }\n          return this.transformAbruptCompletion_(new ContinueStatement(tree.location, null));\n        }\n        if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformBreakStatement\").call(this, tree);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformContinueStatement: function(tree) {\n        if (!tree.name) {\n          if (this.inLoop_) {\n            return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformContinueStatement\").call(this, tree);\n          }\n          return new ReturnStatement(tree.location, null);\n        }\n        if (this.labelledStatements_.has(tree.name.value)) {\n          return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformContinueStatement\").call(this, tree);\n        }\n        if (this.parentLabels_.has(tree.name.value)) {\n          return new ReturnStatement(tree.location, null);\n        }\n        return this.transformAbruptCompletion_(tree);\n      },\n      transformLabelledStatement: function(tree) {\n        this.labelledStatements_.add(tree.name.value);\n        return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformLabelledStatement\").call(this, tree);\n      },\n      transformVariableStatement: function(tree) {\n        var $__1 = this;\n        if (tree.declarations.declarationType === VAR) {\n          var assignments = [];\n          tree.declarations.declarations.forEach(function(variableDeclaration) {\n            var variableName = variableDeclaration.lvalue.getStringValue();\n            var initializer = $traceurRuntime.superGet($__1, InnerForOnTransformer.prototype, \"transformAny\").call($__1, variableDeclaration.initializer);\n            $__1.variableDeclarations_.push(createVariableDeclaration(variableName, null));\n            assignments.push(createAssignmentStatement(id(variableName), initializer));\n          });\n          return new AnonBlock(null, assignments);\n        }\n        return $traceurRuntime.superGet(this, InnerForOnTransformer.prototype, \"transformVariableStatement\").call(this, tree);\n      }\n    }, {transform: function(tempIdGenerator, tree, labelSet) {\n        return new InnerForOnTransformer(tempIdGenerator, labelSet).transform(tree);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get InnerForOnTransformer() {\n      return InnerForOnTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\")),\n      FOR_ON_STATEMENT = $__1.FOR_ON_STATEMENT,\n      LABELLED_STATEMENT = $__1.LABELLED_STATEMENT;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\")).TempVarTransformer;\n  var InnerForOnTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InnerForOnTransformer.js\", \"traceur@0.0.111/src/codegeneration/ForOnTransformer.js\")).InnerForOnTransformer;\n  var ForOnTransformer = function($__super) {\n    function ForOnTransformer() {\n      $traceurRuntime.superConstructor(ForOnTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForOnTransformer, {\n      transformForOnStatement: function(original) {\n        return this.transformForOnStatement_(original, []);\n      },\n      transformForOnStatement_: function(original, labelSet) {\n        return InnerForOnTransformer.transform(this, $traceurRuntime.superGet(this, ForOnTransformer.prototype, \"transformForOnStatement\").call(this, original), labelSet);\n      },\n      transformLabelledStatement: function(tree) {\n        var labelSet = [tree];\n        var statement;\n        for (statement = tree.statement; statement.type === LABELLED_STATEMENT; statement = statement.statement) {\n          labelSet.push(statement);\n        }\n        if (statement.type !== FOR_ON_STATEMENT) {\n          return $traceurRuntime.superGet(this, ForOnTransformer.prototype, \"transformLabelledStatement\").call(this, tree);\n        }\n        return this.transformForOnStatement_(statement, labelSet);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get ForOnTransformer() {\n      return ForOnTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js\";\n  var ComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ComprehensionTransformer.js\", \"traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js\")).ComprehensionTransformer;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/GeneratorComprehensionTransformer.js\")).parseStatement;\n  var GeneratorComprehensionTransformer = function($__super) {\n    function GeneratorComprehensionTransformer() {\n      $traceurRuntime.superConstructor(GeneratorComprehensionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(GeneratorComprehensionTransformer, {transformGeneratorComprehension: function(tree) {\n        var expression = this.transformAny(tree.expression);\n        var statement = parseStatement($traceurRuntime.getTemplateObject([\"yield \", \"\"]), expression);\n        var isGenerator = true;\n        return this.transformComprehension(tree, statement, isGenerator);\n      }}, {}, $__super);\n  }(ComprehensionTransformer);\n  return {get GeneratorComprehensionTransformer() {\n      return GeneratorComprehensionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/State.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/State.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/State.js\")),\n      createAssignStateStatement = $__1.createAssignStateStatement,\n      createBreakStatement = $__1.createBreakStatement,\n      createCaseClause = $__1.createCaseClause,\n      createNumberLiteral = $__1.createNumberLiteral;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/State.js\")).parseStatement;\n  var State = function() {\n    function State(id) {\n      this.id = id;\n    }\n    return ($traceurRuntime.createClass)(State, {\n      transformMachineState: function(enclosingFinally, machineEndState, reporter) {\n        return createCaseClause(createNumberLiteral(this.id), this.transform(enclosingFinally, machineEndState, reporter));\n      },\n      transformBreak: function(labelSet, breakState) {\n        return this;\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        return this;\n      }\n    }, {});\n  }();\n  State.START_STATE = 0;\n  State.INVALID_STATE = -1;\n  State.END_STATE = -2;\n  State.RETHROW_STATE = -3;\n  State.generateJump = function(enclosingFinally, fallThroughState) {\n    return $traceurRuntime.spread(State.generateAssignState(enclosingFinally, fallThroughState), [createBreakStatement()]);\n  };\n  State.generateAssignState = function(enclosingFinally, fallThroughState) {\n    var assignState;\n    if (State.isFinallyExit(enclosingFinally, fallThroughState)) {\n      assignState = generateAssignStateOutOfFinally(enclosingFinally, fallThroughState);\n    } else {\n      assignState = [createAssignStateStatement(fallThroughState)];\n    }\n    return assignState;\n  };\n  State.isFinallyExit = function(enclosingFinally, destination) {\n    return !!enclosingFinally && enclosingFinally.tryStates.indexOf(destination) < 0;\n  };\n  function generateAssignStateOutOfFinally(enclosingFinally, destination) {\n    var finallyState = enclosingFinally.finallyState;\n    return [createAssignStateStatement(finallyState), parseStatement($traceurRuntime.getTemplateObject([\"$ctx.finallyFallThrough = \", \"\"]), destination)];\n  }\n  State.replaceStateList = function(oldStates, oldState, newState) {\n    var states = [];\n    for (var i = 0; i < oldStates.length; i++) {\n      states.push(State.replaceStateId(oldStates[i], oldState, newState));\n    }\n    return states;\n  };\n  State.replaceStateId = function(current, oldState, newState) {\n    return current === oldState ? newState : current;\n  };\n  State.replaceAllStates = function(exceptionBlocks, oldState, newState) {\n    var result = [];\n    for (var i = 0; i < exceptionBlocks.length; i++) {\n      result.push(exceptionBlocks[i].replaceState(oldState, newState));\n    }\n    return result;\n  };\n  return {get State() {\n      return State;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/AwaitState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/AwaitState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/AwaitState.js\")).State;\n  var parseStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/AwaitState.js\")).parseStatements;\n  var AwaitState = function($__super) {\n    function AwaitState(id, callbackState, expression) {\n      $traceurRuntime.superConstructor(AwaitState).call(this, id), this.callbackState = callbackState;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(AwaitState, {\n      replaceState: function(oldState, newState) {\n        return new AwaitState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.callbackState, oldState, newState), this.expression);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        var $__1;\n        var stateId,\n            statements;\n        if (State.isFinallyExit(enclosingFinally, this.callbackState)) {\n          stateId = enclosingFinally.finallyState;\n          statements = parseStatements($traceurRuntime.getTemplateObject([\"$ctx.finallyFallThrough = \", \"\"]), this.callbackState);\n        } else {\n          stateId = this.callbackState;\n          statements = [];\n        }\n        ($__1 = statements).push.apply($__1, $traceurRuntime.spread(parseStatements($traceurRuntime.getTemplateObject([\"Promise.resolve(\", \").then(\\n          $ctx.createCallback(\", \"), $ctx.errback);\\n          return;\"]), this.expression, stateId)));\n        return statements;\n      }\n    }, {}, $__super);\n  }(State);\n  return {get AwaitState() {\n      return AwaitState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/FallThroughState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/FallThroughState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/FallThroughState.js\")).State;\n  var FallThroughState = function($__super) {\n    function FallThroughState(id, fallThroughState, statements) {\n      $traceurRuntime.superConstructor(FallThroughState).call(this, id);\n      this.fallThroughState = fallThroughState;\n      this.statements = statements;\n    }\n    return ($traceurRuntime.createClass)(FallThroughState, {\n      replaceState: function(oldState, newState) {\n        return new FallThroughState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.statements);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return $traceurRuntime.spread(this.statements, State.generateJump(enclosingFinally, this.fallThroughState));\n      }\n    }, {}, $__super);\n  }(State);\n  return {get FallThroughState() {\n      return FallThroughState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/BreakState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/BreakState.js\";\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FallThroughState.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakState.js\")).FallThroughState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakState.js\")).State;\n  var BreakState = function($__super) {\n    function BreakState(id, label) {\n      $traceurRuntime.superConstructor(BreakState).call(this, id);\n      this.label = label;\n    }\n    return ($traceurRuntime.createClass)(BreakState, {\n      replaceState: function(oldState, newState) {\n        return new BreakState(State.replaceStateId(this.id, oldState, newState), this.label);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error('These should be removed before the transform step');\n      },\n      transformBreak: function(labelSet) {\n        var breakState = arguments[1];\n        if (this.label === null)\n          return new FallThroughState(this.id, breakState, []);\n        if (labelSet.has(this.label)) {\n          return new FallThroughState(this.id, labelSet.get(this.label).fallThroughState, []);\n        }\n        return this;\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        return this.transformBreak(labelSet, breakState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get BreakState() {\n      return BreakState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/ContinueState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/ContinueState.js\";\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FallThroughState.js\", \"traceur@0.0.111/src/codegeneration/generator/ContinueState.js\")).FallThroughState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/ContinueState.js\")).State;\n  var ContinueState = function($__super) {\n    function ContinueState(id, label) {\n      $traceurRuntime.superConstructor(ContinueState).call(this, id);\n      this.label = label;\n    }\n    return ($traceurRuntime.createClass)(ContinueState, {\n      replaceState: function(oldState, newState) {\n        return new ContinueState(State.replaceStateId(this.id, oldState, newState), this.label);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error('These should be removed before the transform step');\n      },\n      transformBreakOrContinue: function(labelSet) {\n        var breakState = arguments[1];\n        var continueState = arguments[2];\n        if (this.label === null)\n          return new FallThroughState(this.id, continueState, []);\n        if (labelSet.has(this.label)) {\n          return new FallThroughState(this.id, labelSet.get(this.label).continueState, []);\n        }\n        return this;\n      }\n    }, {}, $__super);\n  }(State);\n  return {get ContinueState() {\n      return ContinueState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/TryState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/TryState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/TryState.js\")).State;\n  var Kind = {\n    CATCH: 'catch',\n    FINALLY: 'finally'\n  };\n  var TryState = function() {\n    function TryState(kind, tryStates, nestedTrys) {\n      this.kind = kind;\n      this.tryStates = tryStates;\n      this.nestedTrys = nestedTrys;\n    }\n    return ($traceurRuntime.createClass)(TryState, {\n      replaceAllStates: function(oldState, newState) {\n        return State.replaceStateList(this.tryStates, oldState, newState);\n      },\n      replaceNestedTrys: function(oldState, newState) {\n        var states = [];\n        for (var i = 0; i < this.nestedTrys.length; i++) {\n          states.push(this.nestedTrys[i].replaceState(oldState, newState));\n        }\n        return states;\n      }\n    }, {});\n  }();\n  TryState.Kind = Kind;\n  return {get TryState() {\n      return TryState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/trees/StateMachine.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/trees/StateMachine.js\";\n  var ParseTree = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTree.js\", \"traceur@0.0.111/src/syntax/trees/StateMachine.js\")).ParseTree;\n  var STATE_MACHINE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeType.js\", \"traceur@0.0.111/src/syntax/trees/StateMachine.js\")).STATE_MACHINE;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../codegeneration/generator/State.js\", \"traceur@0.0.111/src/syntax/trees/StateMachine.js\")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../codegeneration/generator/TryState.js\", \"traceur@0.0.111/src/syntax/trees/StateMachine.js\")).TryState;\n  function addCatchOrFinallyStates(kind, enclosingMap, tryStates) {\n    for (var i = 0; i < tryStates.length; i++) {\n      var tryState = tryStates[i];\n      if (tryState.kind === kind) {\n        for (var j = 0; j < tryState.tryStates.length; j++) {\n          var id = tryState.tryStates[j];\n          enclosingMap[id] = tryState;\n        }\n      }\n      addCatchOrFinallyStates(kind, enclosingMap, tryState.nestedTrys);\n    }\n  }\n  function addAllCatchStates(tryStates, catches) {\n    for (var i = 0; i < tryStates.length; i++) {\n      var tryState = tryStates[i];\n      if (tryState.kind === TryState.Kind.CATCH) {\n        catches.push(tryState);\n      }\n      addAllCatchStates(tryState.nestedTrys, catches);\n    }\n  }\n  var StateMachine = function($__super) {\n    function StateMachine(startState, fallThroughState, states, exceptionBlocks) {\n      $traceurRuntime.superConstructor(StateMachine).call(this, null);\n      this.startState = startState;\n      this.fallThroughState = fallThroughState;\n      this.states = states;\n      this.exceptionBlocks = exceptionBlocks;\n    }\n    return ($traceurRuntime.createClass)(StateMachine, {\n      get type() {\n        return STATE_MACHINE;\n      },\n      transform: function(transformer) {\n        return transformer.transformStateMachine(this);\n      },\n      visit: function(visitor) {\n        visitor.visitStateMachine(this);\n      },\n      getAllStateIDs: function() {\n        var result = [];\n        for (var i = 0; i < this.states.length; i++) {\n          result.push(this.states[i].id);\n        }\n        return result;\n      },\n      getEnclosingFinallyMap: function() {\n        var enclosingMap = Object.create(null);\n        addCatchOrFinallyStates(TryState.Kind.FINALLY, enclosingMap, this.exceptionBlocks);\n        return enclosingMap;\n      },\n      allCatchStates: function() {\n        var catches = [];\n        addAllCatchStates(this.exceptionBlocks, catches);\n        return catches;\n      },\n      replaceStateId: function(oldState, newState) {\n        return new StateMachine(State.replaceStateId(this.startState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), State.replaceAllStates(this.states, oldState, newState), State.replaceAllStates(this.exceptionBlocks, oldState, newState));\n      },\n      replaceStartState: function(newState) {\n        return this.replaceStateId(this.startState, newState);\n      },\n      replaceFallThroughState: function(newState) {\n        return this.replaceStateId(this.fallThroughState, newState);\n      },\n      append: function(nextMachine) {\n        var states = $traceurRuntime.spread(this.states);\n        for (var i = 0; i < nextMachine.states.length; i++) {\n          var otherState = nextMachine.states[i];\n          states.push(otherState.replaceState(nextMachine.startState, this.fallThroughState));\n        }\n        var exceptionBlocks = $traceurRuntime.spread(this.exceptionBlocks);\n        for (var i$__1 = 0; i$__1 < nextMachine.exceptionBlocks.length; i$__1++) {\n          var tryState = nextMachine.exceptionBlocks[i$__1];\n          exceptionBlocks.push(tryState.replaceState(nextMachine.startState, this.fallThroughState));\n        }\n        return new StateMachine(this.startState, nextMachine.fallThroughState, states, exceptionBlocks);\n      }\n    }, {}, $__super);\n  }(ParseTree);\n  return {get StateMachine() {\n      return StateMachine;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\";\n  var BreakState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./BreakState.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\")).BreakState;\n  var ContinueState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ContinueState.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\")).ContinueState;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\")).ParseTreeTransformer;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/StateMachine.js\", \"traceur@0.0.111/src/codegeneration/generator/BreakContinueTransformer.js\")).StateMachine;\n  function safeGetLabel(tree) {\n    return tree.name ? tree.name.value : null;\n  }\n  var BreakContinueTransformer = function($__super) {\n    function BreakContinueTransformer(stateAllocator) {\n      $traceurRuntime.superConstructor(BreakContinueTransformer).call(this);\n      this.transformBreaks_ = true;\n      this.stateAllocator_ = stateAllocator;\n    }\n    return ($traceurRuntime.createClass)(BreakContinueTransformer, {\n      allocateState_: function() {\n        return this.stateAllocator_.allocateState();\n      },\n      stateToStateMachine_: function(newState) {\n        var fallThroughState = this.allocateState_();\n        return new StateMachine(newState.id, fallThroughState, [newState], []);\n      },\n      transformBreakStatement: function(tree) {\n        return this.transformBreaks_ || tree.name ? this.stateToStateMachine_(new BreakState(this.allocateState_(), safeGetLabel(tree))) : tree;\n      },\n      transformContinueStatement: function(tree) {\n        return this.stateToStateMachine_(new ContinueState(this.allocateState_(), safeGetLabel(tree)));\n      },\n      transformDoWhileStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        return tree;\n      },\n      transformForOnStatement: function(tree) {\n        return tree;\n      },\n      transformForStatement: function(tree) {\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformStateMachine: function(tree) {\n        return tree;\n      },\n      transformSwitchStatement: function(tree) {\n        var oldState = this.transformBreaks_;\n        this.transformBreaks_ = false;\n        var result = $traceurRuntime.superGet(this, BreakContinueTransformer.prototype, \"transformSwitchStatement\").call(this, tree);\n        this.transformBreaks_ = oldState;\n        return result;\n      },\n      transformWhileStatement: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get BreakContinueTransformer() {\n      return BreakContinueTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/CatchState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/CatchState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/CatchState.js\")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TryState.js\", \"traceur@0.0.111/src/codegeneration/generator/CatchState.js\")).TryState;\n  var CatchState = function($__super) {\n    function CatchState(identifier, catchState, fallThroughState, allStates, nestedTrys) {\n      $traceurRuntime.superConstructor(CatchState).call(this, TryState.Kind.CATCH, allStates, nestedTrys);\n      this.identifier = identifier;\n      this.catchState = catchState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(CatchState, {replaceState: function(oldState, newState) {\n        return new CatchState(this.identifier, State.replaceStateId(this.catchState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));\n      }}, {}, $__super);\n  }(TryState);\n  return {get CatchState() {\n      return CatchState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/ConditionalState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/ConditionalState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/ConditionalState.js\")).State;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/ConditionalState.js\")),\n      createBlock = $__2.createBlock,\n      createIfStatement = $__2.createIfStatement;\n  var parseStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/ConditionalState.js\")).parseStatements;\n  var ConditionalState = function($__super) {\n    function ConditionalState(id, ifState, elseState, condition) {\n      $traceurRuntime.superConstructor(ConditionalState).call(this, id);\n      this.ifState = ifState;\n      this.elseState = elseState;\n      this.condition = condition;\n    }\n    return ($traceurRuntime.createClass)(ConditionalState, {\n      replaceState: function(oldState, newState) {\n        return new ConditionalState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.ifState, oldState, newState), State.replaceStateId(this.elseState, oldState, newState), this.condition);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        if (State.isFinallyExit(enclosingFinally, this.ifState) || State.isFinallyExit(enclosingFinally, this.elseState)) {\n          return [createIfStatement(this.condition, createBlock(State.generateJump(enclosingFinally, this.ifState)), createBlock(State.generateJump(enclosingFinally, this.elseState)))];\n        }\n        return parseStatements($traceurRuntime.getTemplateObject([\"$ctx.state = (\", \") ? \", \" : \", \";\\n        break\"]), this.condition, this.ifState, this.elseState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get ConditionalState() {\n      return ConditionalState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/FinallyFallThroughState.js\")).State;\n  var FinallyFallThroughState = function($__super) {\n    function FinallyFallThroughState() {\n      $traceurRuntime.superConstructor(FinallyFallThroughState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(FinallyFallThroughState, {\n      replaceState: function(oldState, newState) {\n        return new FinallyFallThroughState(State.replaceStateId(this.id, oldState, newState));\n      },\n      transformMachineState: function(enclosingFinally, machineEndState, reporter) {\n        return null;\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        throw new Error('these are generated in addFinallyFallThroughDispatches');\n      }\n    }, {}, $__super);\n  }(State);\n  return {get FinallyFallThroughState() {\n      return FinallyFallThroughState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/FinallyState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/FinallyState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/FinallyState.js\")).State;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TryState.js\", \"traceur@0.0.111/src/codegeneration/generator/FinallyState.js\")).TryState;\n  var FinallyState = function($__super) {\n    function FinallyState(finallyState, fallThroughState, allStates, nestedTrys) {\n      $traceurRuntime.superConstructor(FinallyState).call(this, TryState.Kind.FINALLY, allStates, nestedTrys);\n      this.finallyState = finallyState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(FinallyState, {replaceState: function(oldState, newState) {\n        return new FinallyState(State.replaceStateId(this.finallyState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));\n      }}, {}, $__super);\n  }(TryState);\n  return {get FinallyState() {\n      return FinallyState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/StateAllocator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/StateAllocator.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/StateAllocator.js\")).State;\n  var StateAllocator = function() {\n    function StateAllocator() {\n      this.nextState_ = State.START_STATE + 1;\n    }\n    return ($traceurRuntime.createClass)(StateAllocator, {allocateState: function() {\n        return this.nextState_++;\n      }}, {});\n  }();\n  return {get StateAllocator() {\n      return StateAllocator;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/SwitchState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/SwitchState.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/generator/SwitchState.js\")),\n      CaseClause = $__2.CaseClause,\n      DefaultClause = $__2.DefaultClause,\n      SwitchStatement = $__2.SwitchStatement;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/SwitchState.js\")).State;\n  var createBreakStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/SwitchState.js\")).createBreakStatement;\n  var SwitchClause = function() {\n    function SwitchClause(first, second) {\n      this.first = first;\n      this.second = second;\n    }\n    return ($traceurRuntime.createClass)(SwitchClause, {}, {});\n  }();\n  var SwitchState = function($__super) {\n    function SwitchState(id, expression, clauses) {\n      $traceurRuntime.superConstructor(SwitchState).call(this, id);\n      this.expression = expression;\n      this.clauses = clauses;\n    }\n    return ($traceurRuntime.createClass)(SwitchState, {\n      replaceState: function(oldState, newState) {\n        var clauses = this.clauses.map(function(clause) {\n          return new SwitchClause(clause.first, State.replaceStateId(clause.second, oldState, newState));\n        });\n        return new SwitchState(State.replaceStateId(this.id, oldState, newState), this.expression, clauses);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        var clauses = [];\n        for (var i = 0; i < this.clauses.length; i++) {\n          var clause = this.clauses[i];\n          if (clause.first === null) {\n            clauses.push(new DefaultClause(null, State.generateJump(enclosingFinally, clause.second)));\n          } else {\n            clauses.push(new CaseClause(null, clause.first, State.generateJump(enclosingFinally, clause.second)));\n          }\n        }\n        return [new SwitchStatement(null, this.expression, clauses), createBreakStatement()];\n      }\n    }, {}, $__super);\n  }(State);\n  return {\n    get SwitchClause() {\n      return SwitchClause;\n    },\n    get SwitchState() {\n      return SwitchState;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")),\n      AnonBlock = $__1.AnonBlock,\n      Catch = $__1.Catch,\n      FunctionBody = $__1.FunctionBody,\n      ForInStatement = $__1.ForInStatement,\n      ForOfStatement = $__1.ForOfStatement,\n      ForStatement = $__1.ForStatement,\n      VariableDeclarationList = $__1.VariableDeclarationList,\n      VariableStatement = $__1.VariableStatement;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")),\n      OBJECT_PATTERN = $__2.OBJECT_PATTERN,\n      VARIABLE_DECLARATION_LIST = $__2.VARIABLE_DECLARATION_LIST;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")).ParseTreeTransformer;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")).StringSet;\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")).VAR;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")),\n      createAssignmentExpression = $__6.createAssignmentExpression,\n      createCommaExpression = $__6.createCommaExpression,\n      createExpressionStatement = $__6.createExpressionStatement,\n      id = $__6.createIdentifierExpression,\n      createParenExpression = $__6.createParenExpression,\n      createVariableDeclaration = $__6.createVariableDeclaration;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/HoistVariablesTransformer.js\")).prependStatements;\n  var HoistVariablesTransformer = function($__super) {\n    function HoistVariablesTransformer() {\n      var shouldHoistFunctions = arguments[0] !== (void 0) ? arguments[0] : false;\n      $traceurRuntime.superConstructor(HoistVariablesTransformer).call(this);\n      this.hoistedFunctions_ = [];\n      this.hoistedVariables_ = new StringSet();\n      this.keepBindingIdentifiers_ = false;\n      this.inBlockOrFor_ = false;\n      this.shouldHoistFunctions_ = shouldHoistFunctions;\n    }\n    return ($traceurRuntime.createClass)(HoistVariablesTransformer, {\n      transformFunctionBody: function(tree) {\n        var statements = this.transformList(tree.statements);\n        if (statements === tree.statements)\n          return tree;\n        statements = this.prependVariables(statements);\n        statements = this.prependFunctions(statements);\n        return new FunctionBody(tree.location, statements);\n      },\n      addVariable: function(name) {\n        this.hoistedVariables_.add(name);\n      },\n      addFunctionDeclaration: function(tree) {\n        this.hoistedFunctions_.push(tree);\n      },\n      hasVariables: function() {\n        return !this.hoistedVariables_.isEmpty();\n      },\n      hasFunctions: function() {\n        return this.hoistedFunctions_.length > 0;\n      },\n      getVariableNames: function() {\n        return this.hoistedVariables_.valuesAsArray();\n      },\n      getVariableStatement: function() {\n        if (!this.hasVariables())\n          return new AnonBlock(null, []);\n        var declarations = this.getVariableNames().map(function(name) {\n          return createVariableDeclaration(name, null);\n        });\n        return new VariableStatement(null, new VariableDeclarationList(null, VAR, declarations));\n      },\n      getFunctions: function() {\n        return this.hoistedFunctions_;\n      },\n      prependVariables: function(statements) {\n        if (!this.hasVariables())\n          return statements;\n        return prependStatements(statements, this.getVariableStatement());\n      },\n      prependFunctions: function(statements) {\n        if (!this.hasFunctions())\n          return statements;\n        return prependStatements(statements, this.getFunctionDeclarations());\n      },\n      transformVariableStatement: function(tree) {\n        var declarations = this.transformAny(tree.declarations);\n        if (declarations === tree.declarations)\n          return tree;\n        if (declarations === null)\n          return new AnonBlock(null, []);\n        if (declarations.type === VARIABLE_DECLARATION_LIST)\n          return new VariableStatement(tree.location, declarations);\n        return createExpressionStatement(declarations);\n      },\n      transformVariableDeclaration: function(tree) {\n        var lvalue = this.transformAny(tree.lvalue);\n        var initializer = this.transformAny(tree.initializer);\n        if (initializer) {\n          var expression = createAssignmentExpression(lvalue, initializer);\n          if (lvalue.type === OBJECT_PATTERN)\n            expression = createParenExpression(expression);\n          return expression;\n        }\n        return null;\n      },\n      transformObjectPattern: function(tree) {\n        var keepBindingIdentifiers = this.keepBindingIdentifiers_;\n        this.keepBindingIdentifiers_ = true;\n        var transformed = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, \"transformObjectPattern\").call(this, tree);\n        this.keepBindingIdentifiers_ = keepBindingIdentifiers;\n        return transformed;\n      },\n      transformArrayPattern: function(tree) {\n        var keepBindingIdentifiers = this.keepBindingIdentifiers_;\n        this.keepBindingIdentifiers_ = true;\n        var transformed = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, \"transformArrayPattern\").call(this, tree);\n        this.keepBindingIdentifiers_ = keepBindingIdentifiers;\n        return transformed;\n      },\n      transformBindingIdentifier: function(tree) {\n        var idToken = tree.identifierToken;\n        this.addVariable(idToken.value);\n        if (this.keepBindingIdentifiers_)\n          return tree;\n        return id(idToken);\n      },\n      transformVariableDeclarationList: function(tree) {\n        if (tree.declarationType === VAR || !this.inBlockOrFor_) {\n          var expressions = this.transformList(tree.declarations);\n          expressions = expressions.filter(function(tree) {\n            return tree;\n          });\n          if (expressions.length === 0)\n            return null;\n          if (expressions.length === 1)\n            return expressions[0];\n          return createCommaExpression(expressions);\n        }\n        return tree;\n      },\n      transformCatch: function(tree) {\n        var catchBody = this.transformAny(tree.catchBody);\n        if (catchBody === tree.catchBody)\n          return tree;\n        return new Catch(tree.location, tree.binding, catchBody);\n      },\n      transformForInStatement: function(tree) {\n        return this.transformLoop_(tree, ForInStatement);\n      },\n      transformForOfStatement: function(tree) {\n        return this.transformLoop_(tree, ForOfStatement);\n      },\n      transformForOnStatement: function(tree) {\n        return this.transformLoop_(tree, ForOfStatement);\n      },\n      transformLoop_: function(tree, ctor) {\n        var initializer = this.transformLoopIninitaliser_(tree.initializer);\n        var collection = this.transformAny(tree.collection);\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && collection === tree.collection && body === tree.body) {\n          return tree;\n        }\n        return new ctor(tree.location, initializer, collection, body);\n      },\n      transformLoopIninitaliser_: function(tree) {\n        if (tree.type !== VARIABLE_DECLARATION_LIST || tree.declarationType !== VAR)\n          return tree;\n        return this.transformAny(tree.declarations[0].lvalue);\n      },\n      transformForStatement: function(tree) {\n        var inBlockOrFor = this.inBlockOrFor_;\n        this.inBlockOrFor_ = true;\n        var initializer = this.transformAny(tree.initializer);\n        this.inBlockOrFor_ = inBlockOrFor;\n        var condition = this.transformAny(tree.condition);\n        var increment = this.transformAny(tree.increment);\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        return new ForStatement(tree.location, initializer, condition, increment, body);\n      },\n      transformBlock: function(tree) {\n        var inBlockOrFor = this.inBlockOrFor_;\n        this.inBlockOrFor_ = true;\n        tree = $traceurRuntime.superGet(this, HoistVariablesTransformer.prototype, \"transformBlock\").call(this, tree);\n        this.inBlockOrFor_ = inBlockOrFor;\n        return tree;\n      },\n      addMachineVariable: function(name) {\n        this.machineVariables_[name] = true;\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.shouldHoistFunctions_) {\n          this.addFunctionDeclaration(tree);\n          return new AnonBlock(null, []);\n        }\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        return tree;\n      },\n      transformSetAccessor: function(tree) {\n        return tree;\n      },\n      transformMethod: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformComprehensionFor: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  var $__default = HoistVariablesTransformer;\n  return {get default() {\n      return $__default;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\";\n  var AlphaRenamer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../AlphaRenamer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).AlphaRenamer;\n  var BreakContinueTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./BreakContinueTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).BreakContinueTransformer;\n  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")),\n      BLOCK = $__19.BLOCK,\n      CASE_CLAUSE = $__19.CASE_CLAUSE,\n      CONDITIONAL_EXPRESSION = $__19.CONDITIONAL_EXPRESSION,\n      EXPRESSION_STATEMENT = $__19.EXPRESSION_STATEMENT,\n      PAREN_EXPRESSION = $__19.PAREN_EXPRESSION,\n      STATE_MACHINE = $__19.STATE_MACHINE;\n  var $__20 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")),\n      AnonBlock = $__20.AnonBlock,\n      Block = $__20.Block,\n      CaseClause = $__20.CaseClause,\n      IfStatement = $__20.IfStatement,\n      SwitchStatement = $__20.SwitchStatement;\n  var CatchState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./CatchState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).CatchState;\n  var ConditionalState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ConditionalState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).ConditionalState;\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ExplodeExpressionTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).ExplodeExpressionTransformer;\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FallThroughState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).FallThroughState;\n  var FinallyFallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FinallyFallThroughState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).FinallyFallThroughState;\n  var FinallyState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FinallyState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).FinallyState;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).FindInFunctionScope;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).ParseTreeTransformer;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/StringMap.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).StringMap;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).TempVarTransformer;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/assert.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).assert;\n  var $__32 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")),\n      parseExpression = $__32.parseExpression,\n      parseStatement = $__32.parseStatement,\n      parseStatements = $__32.parseStatements;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).State;\n  var StateAllocator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./StateAllocator.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).StateAllocator;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/StateMachine.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).StateMachine;\n  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SwitchState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")),\n      SwitchClause = $__36.SwitchClause,\n      SwitchState = $__36.SwitchState;\n  var TryState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TryState.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).TryState;\n  var $__38 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")),\n      createAssignStateStatement = $__38.createAssignStateStatement,\n      createBreakStatement = $__38.createBreakStatement,\n      createCaseClause = $__38.createCaseClause,\n      createDefaultClause = $__38.createDefaultClause,\n      createExpressionStatement = $__38.createExpressionStatement,\n      createFunctionBody = $__38.createFunctionBody,\n      id = $__38.createIdentifierExpression,\n      createMemberExpression = $__38.createMemberExpression,\n      createNumberLiteral = $__38.createNumberLiteral,\n      createSwitchStatement = $__38.createSwitchStatement;\n  var HoistVariablesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../HoistVariablesTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/CPSTransformer.js\")).default;\n  var LabelState = function() {\n    function LabelState(name, continueState, fallThroughState) {\n      this.name = name;\n      this.continueState = continueState;\n      this.fallThroughState = fallThroughState;\n    }\n    return ($traceurRuntime.createClass)(LabelState, {}, {});\n  }();\n  var NeedsStateMachine = function($__super) {\n    function NeedsStateMachine() {\n      $traceurRuntime.superConstructor(NeedsStateMachine).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NeedsStateMachine, {\n      visitBreakStatement: function(tree) {\n        this.found = true;\n      },\n      visitContinueStatement: function(tree) {\n        this.found = true;\n      },\n      visitStateMachine: function(tree) {\n        this.found = true;\n      },\n      visitYieldExpression: function(tee) {\n        this.found = true;\n      }\n    }, {}, $__super);\n  }(FindInFunctionScope);\n  function needsStateMachine(tree) {\n    var visitor = new NeedsStateMachine();\n    visitor.visitAny(tree);\n    return visitor.found;\n  }\n  var HoistVariables = function($__super) {\n    function HoistVariables() {\n      $traceurRuntime.superConstructor(HoistVariables).call(this, true);\n    }\n    return ($traceurRuntime.createClass)(HoistVariables, {\n      prependVariables: function(statements) {\n        return statements;\n      },\n      prependFunctions: function(statements) {\n        return statements;\n      }\n    }, {}, $__super);\n  }(HoistVariablesTransformer);\n  var CPSTransformer = function($__super) {\n    function CPSTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(CPSTransformer).call(this, identifierGenerator, reporter, options);\n      this.stateAllocator_ = new StateAllocator();\n      this.labelSet_ = new StringMap();\n      this.currentLabel_ = null;\n      this.hoistVariablesTransformer_ = new HoistVariables();\n    }\n    return ($traceurRuntime.createClass)(CPSTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        return false;\n      },\n      allocateState: function() {\n        return this.stateAllocator_.allocateState();\n      },\n      transformBlock: function(tree) {\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var transformedTree = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformBlock\").call(this, tree);\n        var machine = this.transformStatementList_(transformedTree.statements);\n        if (machine === null)\n          return transformedTree;\n        if (label) {\n          var states = [];\n          for (var i = 0; i < machine.states.length; i++) {\n            var state = machine.states[i];\n            states.push(state.transformBreakOrContinue(labels));\n          }\n          machine = new StateMachine(machine.startState, machine.fallThroughState, states, machine.exceptionBlocks);\n        }\n        return machine;\n      },\n      transformFunctionBody: function(tree) {\n        this.pushTempScope();\n        var oldLabels = this.clearLabels_();\n        var transformedTree = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformFunctionBody\").call(this, tree);\n        var machine = this.transformStatementList_(transformedTree.statements);\n        this.restoreLabels_(oldLabels);\n        this.popTempScope();\n        return machine === null ? transformedTree : machine;\n      },\n      transformStatementList_: function(trees) {\n        var groups = [];\n        var newMachine;\n        for (var i = 0; i < trees.length; i++) {\n          if (trees[i].type === STATE_MACHINE) {\n            groups.push(trees[i]);\n          } else if (needsStateMachine(trees[i])) {\n            newMachine = this.ensureTransformed_(trees[i]);\n            groups.push(newMachine);\n          } else {\n            var last = groups[groups.length - 1];\n            if (!(last instanceof Array))\n              groups.push(last = []);\n            last.push(trees[i]);\n          }\n        }\n        if (groups.length === 1 && groups[0] instanceof Array)\n          return null;\n        var machine = null;\n        for (var i$__11 = 0; i$__11 < groups.length; i$__11++) {\n          if (groups[i$__11] instanceof Array) {\n            newMachine = this.statementsToStateMachine_(groups[i$__11]);\n          } else {\n            newMachine = groups[i$__11];\n          }\n          if (i$__11 === 0)\n            machine = newMachine;\n          else\n            machine = machine.append(newMachine);\n        }\n        return machine;\n      },\n      needsStateMachine_: function(statements) {\n        if (statements instanceof Array) {\n          for (var i = 0; i < statements.length; i++) {\n            if (needsStateMachine(statements[i]))\n              return true;\n          }\n          return false;\n        }\n        assert(statements instanceof SwitchStatement);\n        return needsStateMachine(statements);\n      },\n      transformCaseClause: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformCaseClause\").call(this, tree);\n        var machine = this.transformStatementList_(result.statements);\n        return machine === null ? result : new CaseClause(null, result.expression, [machine]);\n      },\n      transformDoWhileStatement: function(tree) {\n        var $__8;\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var machine,\n            condition,\n            body;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          body = this.transformAny(tree.body);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformDoWhileStatement\").call(this, tree);\n          (($__7 = result, condition = $__7.condition, body = $__7.body, $__7));\n          if (body.type !== STATE_MACHINE)\n            return result;\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var startState = loopBodyMachine.startState;\n        var conditionState = loopBodyMachine.fallThroughState;\n        var fallThroughState = this.allocateState();\n        var states = [];\n        this.addLoopBodyStates_(loopBodyMachine, conditionState, fallThroughState, labels, states);\n        if (machine) {\n          machine = machine.replaceStartState(conditionState);\n          conditionState = machine.fallThroughState;\n          ($__8 = states).push.apply($__8, $traceurRuntime.spread(machine.states));\n        }\n        states.push(new ConditionalState(conditionState, startState, fallThroughState, condition));\n        machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(conditionState, label.continueState);\n        return machine;\n      },\n      addLoopBodyStates_: function(loopBodyMachine, continueState, breakState, labels, states) {\n        for (var i = 0; i < loopBodyMachine.states.length; i++) {\n          var state = loopBodyMachine.states[i];\n          states.push(state.transformBreakOrContinue(labels, breakState, continueState));\n        }\n      },\n      transformForStatement: function(tree) {\n        var $__8,\n            $__9,\n            $__10;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var tmp;\n        var initializer = null,\n            initializerMachine;\n        if (tree.initializer) {\n          if (this.expressionNeedsStateMachine(tree.initializer)) {\n            tmp = this.expressionToStateMachine(tree.initializer);\n            initializer = tmp.expression;\n            initializerMachine = tmp.machine;\n          } else {\n            initializer = this.transformAny(tree.initializer);\n          }\n        }\n        var condition = null,\n            conditionMachine;\n        if (tree.condition) {\n          if (this.expressionNeedsStateMachine(tree.condition)) {\n            tmp = this.expressionToStateMachine(tree.condition);\n            condition = tmp.expression;\n            conditionMachine = tmp.machine;\n          } else {\n            condition = this.transformAny(tree.condition);\n          }\n        }\n        var increment = null,\n            incrementMachine;\n        if (tree.increment) {\n          if (this.expressionNeedsStateMachine(tree.increment)) {\n            tmp = this.expressionToStateMachine(tree.increment);\n            increment = tmp.expression;\n            incrementMachine = tmp.machine;\n          } else {\n            increment = this.transformAny(tree.increment);\n          }\n        }\n        var body = this.transformAny(tree.body);\n        if (initializer === tree.initializer && condition === tree.condition && increment === tree.increment && body === tree.body) {\n          return tree;\n        }\n        if (!initializerMachine && !conditionMachine && !incrementMachine && body.type !== STATE_MACHINE) {\n          return new ForStatement(tree.location, initializer, condition, increment, body);\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var bodyFallThroughId = loopBodyMachine.fallThroughState;\n        var fallThroughId = this.allocateState();\n        var startId;\n        var initializerStartId = initializer ? this.allocateState() : State.INVALID_STATE;\n        var conditionStartId = increment ? this.allocateState() : bodyFallThroughId;\n        var loopStartId = loopBodyMachine.startState;\n        var incrementStartId = bodyFallThroughId;\n        var states = [];\n        if (initializer) {\n          startId = initializerStartId;\n          var initialiserFallThroughId;\n          if (condition)\n            initialiserFallThroughId = conditionStartId;\n          else\n            initialiserFallThroughId = loopStartId;\n          var tmpId = initializerStartId;\n          if (initializerMachine) {\n            initializerMachine = initializerMachine.replaceStartState(initializerStartId);\n            tmpId = initializerMachine.fallThroughState;\n            ($__8 = states).push.apply($__8, $traceurRuntime.spread(initializerMachine.states));\n          }\n          states.push(new FallThroughState(tmpId, initialiserFallThroughId, [createExpressionStatement(initializer)]));\n        }\n        if (condition) {\n          if (!initializer)\n            startId = conditionStartId;\n          var tmpId$__12 = conditionStartId;\n          if (conditionMachine) {\n            conditionMachine = conditionMachine.replaceStartState(conditionStartId);\n            tmpId$__12 = conditionMachine.fallThroughState;\n            ($__9 = states).push.apply($__9, $traceurRuntime.spread(conditionMachine.states));\n          }\n          states.push(new ConditionalState(tmpId$__12, loopStartId, fallThroughId, condition));\n        }\n        if (increment) {\n          var incrementFallThroughId;\n          if (condition)\n            incrementFallThroughId = conditionStartId;\n          else\n            incrementFallThroughId = loopStartId;\n          var tmpId$__13 = incrementStartId;\n          if (incrementMachine) {\n            incrementMachine = incrementMachine.replaceStartState(incrementStartId);\n            tmpId$__13 = incrementMachine.fallThroughState;\n            ($__10 = states).push.apply($__10, $traceurRuntime.spread(incrementMachine.states));\n          }\n          states.push(new FallThroughState(tmpId$__13, incrementFallThroughId, [createExpressionStatement(increment)]));\n        }\n        if (!initializer && !condition)\n          startId = loopStartId;\n        var continueId;\n        if (increment)\n          continueId = incrementStartId;\n        else if (condition)\n          continueId = conditionStartId;\n        else\n          continueId = loopStartId;\n        if (!increment && !condition) {\n          loopBodyMachine = loopBodyMachine.replaceFallThroughState(loopBodyMachine.startState);\n        }\n        this.addLoopBodyStates_(loopBodyMachine, continueId, fallThroughId, labels, states);\n        var machine = new StateMachine(startId, fallThroughId, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(continueId, label.continueState);\n        return machine;\n      },\n      transformForInStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        throw new Error('for of statements should be transformed before this pass');\n      },\n      transformIfStatement: function(tree) {\n        var $__8,\n            $__9,\n            $__10;\n        var $__6,\n            $__7;\n        var machine,\n            condition,\n            ifClause,\n            elseClause;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          ifClause = this.transformAny(tree.ifClause);\n          elseClause = this.transformAny(tree.elseClause);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformIfStatement\").call(this, tree);\n          (($__7 = result, condition = $__7.condition, ifClause = $__7.ifClause, elseClause = $__7.elseClause, $__7));\n          if (ifClause.type !== STATE_MACHINE && (elseClause === null || elseClause.type !== STATE_MACHINE)) {\n            return result;\n          }\n        }\n        ifClause = this.ensureTransformed_(ifClause);\n        elseClause = this.ensureTransformed_(elseClause);\n        var startState = this.allocateState();\n        var fallThroughState = ifClause.fallThroughState;\n        var ifState = ifClause.startState;\n        var elseState = elseClause === null ? fallThroughState : elseClause.startState;\n        var states = [];\n        var exceptionBlocks = [];\n        states.push(new ConditionalState(startState, ifState, elseState, condition));\n        ($__8 = states).push.apply($__8, $traceurRuntime.spread(ifClause.states));\n        ($__9 = exceptionBlocks).push.apply($__9, $traceurRuntime.spread(ifClause.exceptionBlocks));\n        if (elseClause !== null) {\n          this.replaceAndAddStates_(elseClause.states, elseClause.fallThroughState, fallThroughState, states);\n          ($__10 = exceptionBlocks).push.apply($__10, $traceurRuntime.spread(State.replaceAllStates(elseClause.exceptionBlocks, elseClause.fallThroughState, fallThroughState)));\n        }\n        var ifMachine = new StateMachine(startState, fallThroughState, states, exceptionBlocks);\n        if (machine)\n          ifMachine = machine.append(ifMachine);\n        return ifMachine;\n      },\n      removeEmptyStates: function(oldStates) {\n        var emptyStates = [],\n            newStates = [];\n        for (var i = 0; i < oldStates.length; i++) {\n          if (oldStates[i] instanceof FallThroughState && oldStates[i].statements.length === 0) {\n            emptyStates.push(oldStates[i]);\n          } else {\n            newStates.push(oldStates[i]);\n          }\n        }\n        for (var i$__14 = 0; i$__14 < newStates.length; i$__14++) {\n          newStates[i$__14] = emptyStates.reduce(function(state, $__6) {\n            var $__7 = $__6,\n                id = $__7.id,\n                fallThroughState = $__7.fallThroughState;\n            return state.replaceState(id, fallThroughState);\n          }, newStates[i$__14]);\n        }\n        return newStates;\n      },\n      replaceAndAddStates_: function(oldStates, oldState, newState, newStates) {\n        for (var i = 0; i < oldStates.length; i++) {\n          newStates.push(oldStates[i].replaceState(oldState, newState));\n        }\n      },\n      transformLabelledStatement: function(tree) {\n        var startState = this.allocateState();\n        var continueState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var label = new LabelState(tree.name.value, continueState, fallThroughState);\n        var oldLabels = this.addLabel_(label);\n        this.currentLabel_ = label;\n        var result = this.transformAny(tree.statement);\n        if (result === tree.statement) {\n          result = tree;\n        } else if (result.type === STATE_MACHINE) {\n          result = result.replaceStartState(startState);\n          result = result.replaceFallThroughState(fallThroughState);\n        }\n        this.restoreLabels_(oldLabels);\n        return result;\n      },\n      getLabels_: function() {\n        return this.labelSet_;\n      },\n      restoreLabels_: function(oldLabels) {\n        this.labelSet_ = oldLabels;\n      },\n      addLabel_: function(label) {\n        var $__5 = this;\n        var oldLabels = this.labelSet_;\n        var labelSet = new StringMap();\n        this.labelSet_.forEach(function(k) {\n          return labelSet[k] = $__5.labelSet_[k];\n        });\n        labelSet.set(label.name, label);\n        this.labelSet_ = labelSet;\n        return oldLabels;\n      },\n      clearLabels_: function() {\n        var result = this.labelSet_;\n        this.labelSet_ = new StringMap();\n        return result;\n      },\n      clearCurrentLabel_: function() {\n        var result = this.currentLabel_;\n        this.currentLabel_ = null;\n        return result;\n      },\n      transformSwitchStatement: function(tree) {\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var expression,\n            machine,\n            caseClauses;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__6 = this.expressionToStateMachine(tree.expression), expression = $__6.expression, machine = $__6.machine, $__6));\n          caseClauses = this.transformList(tree.caseClauses);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformSwitchStatement\").call(this, tree);\n          if (!needsStateMachine(result))\n            return result;\n          (($__7 = result, expression = $__7.expression, caseClauses = $__7.caseClauses, $__7));\n        }\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var nextState = fallThroughState;\n        var states = [];\n        var clauses = [];\n        var tryStates = [];\n        var hasDefault = false;\n        for (var index = caseClauses.length - 1; index >= 0; index--) {\n          var clause = caseClauses[index];\n          if (clause.type === CASE_CLAUSE) {\n            var caseClause = clause;\n            nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, caseClause.statements, states, tryStates);\n            clauses.push(new SwitchClause(caseClause.expression, nextState));\n          } else {\n            hasDefault = true;\n            var defaultClause = clause;\n            nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, defaultClause.statements, states, tryStates);\n            clauses.push(new SwitchClause(null, nextState));\n          }\n        }\n        if (!hasDefault) {\n          clauses.push(new SwitchClause(null, fallThroughState));\n        }\n        states.push(new SwitchState(startState, expression, clauses.reverse()));\n        var switchMachine = new StateMachine(startState, fallThroughState, states.reverse(), tryStates);\n        if (machine)\n          switchMachine = machine.append(switchMachine);\n        return switchMachine;\n      },\n      addSwitchClauseStates_: function(nextState, fallThroughState, labels, statements, states, tryStates) {\n        var $__8;\n        var machine = this.ensureTransformedList_(statements);\n        for (var i = 0; i < machine.states.length; i++) {\n          var state = machine.states[i];\n          var transformedState = state.transformBreak(labels, fallThroughState);\n          states.push(transformedState.replaceState(machine.fallThroughState, nextState));\n        }\n        ($__8 = tryStates).push.apply($__8, $traceurRuntime.spread(machine.exceptionBlocks));\n        return machine.startState;\n      },\n      transformTryStatement: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformTryStatement\").call(this, tree);\n        var $__6 = result,\n            body = $__6.body,\n            catchBlock = $__6.catchBlock,\n            finallyBlock = $__6.finallyBlock;\n        if (body.type !== STATE_MACHINE && (catchBlock === null || catchBlock.catchBody.type !== STATE_MACHINE) && (finallyBlock === null || finallyBlock.block.type !== STATE_MACHINE)) {\n          return result;\n        }\n        var outerCatchState = this.allocateState();\n        var outerFinallyState = this.allocateState();\n        var pushTryState = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject([\"$ctx.pushTry(\\n            \", \",\\n            \", \");\"]), (catchBlock && outerCatchState), (finallyBlock && outerFinallyState)));\n        var tryMachine = this.ensureTransformed_(body);\n        tryMachine = pushTryState.append(tryMachine);\n        if (catchBlock !== null) {\n          var popTry = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject([\"$ctx.popTry();\"])));\n          tryMachine = tryMachine.append(popTry);\n          var exceptionName = catchBlock.binding.identifierToken.value;\n          var catchMachine = this.ensureTransformed_(catchBlock.catchBody);\n          var catchStart = this.allocateState();\n          this.addMachineVariable(exceptionName);\n          var states = $traceurRuntime.spread(tryMachine.states, [new FallThroughState(catchStart, catchMachine.startState, parseStatements($traceurRuntime.getTemplateObject([\"\\n              $ctx.popTry();\\n              $ctx.maybeUncatchable(); // see RETURN_SENTINEL in runtime\\n              \", \" = $ctx.storedException;\"]), id(exceptionName)))]);\n          this.replaceAndAddStates_(catchMachine.states, catchMachine.fallThroughState, tryMachine.fallThroughState, states);\n          tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states, [new CatchState(exceptionName, catchStart, tryMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);\n          tryMachine = tryMachine.replaceStateId(catchStart, outerCatchState);\n        }\n        if (finallyBlock !== null) {\n          var finallyMachine = this.ensureTransformed_(finallyBlock.block);\n          var popTry$__15 = this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject([\"$ctx.popTry();\"])));\n          finallyMachine = popTry$__15.append(finallyMachine);\n          var states$__16 = $traceurRuntime.spread(tryMachine.states, finallyMachine.states, [new FinallyFallThroughState(finallyMachine.fallThroughState)]);\n          tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states$__16, [new FinallyState(finallyMachine.startState, finallyMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);\n          tryMachine = tryMachine.replaceStateId(finallyMachine.startState, outerFinallyState);\n        }\n        return tryMachine;\n      },\n      transformWhileStatement: function(tree) {\n        var $__8;\n        var $__6,\n            $__7;\n        var labels = this.getLabels_();\n        var label = this.clearCurrentLabel_();\n        var condition,\n            machine,\n            body;\n        if (this.expressionNeedsStateMachine(tree.condition)) {\n          (($__6 = this.expressionToStateMachine(tree.condition), machine = $__6.machine, condition = $__6.expression, $__6));\n          body = this.transformAny(tree.body);\n        } else {\n          var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformWhileStatement\").call(this, tree);\n          (($__7 = result, condition = $__7.condition, body = $__7.body, $__7));\n          if (body.type !== STATE_MACHINE)\n            return result;\n        }\n        var loopBodyMachine = this.ensureTransformed_(body);\n        var startState = loopBodyMachine.fallThroughState;\n        var fallThroughState = this.allocateState();\n        var states = [];\n        var conditionStart = startState;\n        if (machine) {\n          machine = machine.replaceStartState(startState);\n          conditionStart = machine.fallThroughState;\n          ($__8 = states).push.apply($__8, $traceurRuntime.spread(machine.states));\n        }\n        states.push(new ConditionalState(conditionStart, loopBodyMachine.startState, fallThroughState, condition));\n        this.addLoopBodyStates_(loopBodyMachine, startState, fallThroughState, labels, states);\n        machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);\n        if (label)\n          machine = machine.replaceStateId(startState, label.continueState);\n        return machine;\n      },\n      transformWithStatement: function(tree) {\n        var result = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformWithStatement\").call(this, tree);\n        if (result.body.type !== STATE_MACHINE) {\n          return result;\n        }\n        throw new Error('Unreachable - with statement not allowed in strict mode/harmony');\n      },\n      generateMachineInnerFunction: function(machine) {\n        var enclosingFinallyState = machine.getEnclosingFinallyMap();\n        var SwitchStatement = createSwitchStatement(createMemberExpression('$ctx', 'state'), this.transformMachineStates(machine, State.END_STATE, State.RETHROW_STATE, enclosingFinallyState));\n        return parseExpression($traceurRuntime.getTemplateObject([\"function($ctx) {\\n      while (true) \", \"\\n    }\"]), SwitchStatement);\n      },\n      addTempVar: function() {\n        var name = this.getTempIdentifier();\n        this.addMachineVariable(name);\n        return name;\n      },\n      addMachineVariable: function(name) {\n        this.hoistVariablesTransformer_.addVariable(name);\n      },\n      transformCpsFunctionBody: function(tree, runtimeMethod) {\n        var $__8;\n        var functionRef = arguments[2];\n        var alphaRenamedTree = AlphaRenamer.rename(tree, 'arguments', '$arguments');\n        var hasArguments = alphaRenamedTree !== tree;\n        var hoistedTree = this.hoistVariablesTransformer_.transformAny(alphaRenamedTree);\n        var maybeMachine = this.transformAny(hoistedTree);\n        if (this.reporter.hadError())\n          return tree;\n        var machine;\n        if (maybeMachine.type !== STATE_MACHINE) {\n          machine = this.statementsToStateMachine_(maybeMachine.statements);\n        } else {\n          machine = new StateMachine(maybeMachine.startState, maybeMachine.fallThroughState, this.removeEmptyStates(maybeMachine.states), maybeMachine.exceptionBlocks);\n        }\n        machine = machine.replaceFallThroughState(State.END_STATE).replaceStartState(State.START_STATE);\n        var statements = [];\n        if (this.hoistVariablesTransformer_.hasFunctions())\n          ($__8 = statements).push.apply($__8, $traceurRuntime.spread(this.hoistVariablesTransformer_.getFunctions()));\n        if (this.hoistVariablesTransformer_.hasVariables())\n          statements.push(this.hoistVariablesTransformer_.getVariableStatement());\n        if (hasArguments)\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"var $arguments = arguments;\"])));\n        if (functionRef) {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"return \", \"(\\n              \", \",\\n              \", \", this);\"]), runtimeMethod, this.generateMachineInnerFunction(machine), functionRef));\n        } else {\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"return \", \"(\\n              \", \", this);\"]), runtimeMethod, this.generateMachineInnerFunction(machine)));\n        }\n        return createFunctionBody(statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformGetAccessor: function(tree) {\n        return tree;\n      },\n      transformSetAccessor: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformStateMachine: function(tree) {\n        return tree;\n      },\n      statementToStateMachine_: function(statement) {\n        var statements;\n        if (statement.type === BLOCK)\n          statements = statement.statements;\n        else\n          statements = [statement];\n        return this.statementsToStateMachine_(statements);\n      },\n      statementsToStateMachine_: function(statements) {\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        return this.stateToStateMachine_(new FallThroughState(startState, fallThroughState, statements), fallThroughState);\n      },\n      stateToStateMachine_: function(newState, fallThroughState) {\n        return new StateMachine(newState.id, fallThroughState, [newState], []);\n      },\n      transformMachineStates: function(machine, machineEndState, rethrowState, enclosingFinallyState) {\n        var cases = [];\n        for (var i = 0; i < machine.states.length; i++) {\n          var state = machine.states[i];\n          var stateCase = state.transformMachineState(enclosingFinallyState[state.id], machineEndState, this.reporter);\n          if (stateCase !== null) {\n            cases.push(stateCase);\n          }\n        }\n        this.addFinallyFallThroughDispatches(null, machine.exceptionBlocks, cases);\n        cases.push(createDefaultClause(parseStatements($traceurRuntime.getTemplateObject([\"return $ctx.end()\"]))));\n        return cases;\n      },\n      addFinallyFallThroughDispatches: function(enclosingFinallyState, tryStates, cases) {\n        for (var i = 0; i < tryStates.length; i++) {\n          var tryState = tryStates[i];\n          if (tryState.kind === TryState.Kind.FINALLY) {\n            var finallyState = tryState;\n            if (enclosingFinallyState !== null) {\n              var caseClauses = [];\n              var index = 0;\n              for (var j = 0; j < enclosingFinallyState.tryStates.length; j++) {\n                var destination = enclosingFinallyState.tryStates[j];\n                index++;\n                var statements = void 0;\n                if (index < enclosingFinallyState.tryStates.length) {\n                  statements = [];\n                } else {\n                  statements = parseStatements($traceurRuntime.getTemplateObject([\"\\n                  $ctx.state = $ctx.finallyFallThrough;\\n                  $ctx.finallyFallThrough = \", \";\\n                  break;\"]), State.INVALID_STATE);\n                }\n                caseClauses.push(createCaseClause(createNumberLiteral(destination), statements));\n              }\n              caseClauses.push(createDefaultClause([createAssignStateStatement(enclosingFinallyState.finallyState), createBreakStatement()]));\n              cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), [createSwitchStatement(createMemberExpression('$ctx', 'finallyFallThrough'), caseClauses), createBreakStatement()]));\n            } else {\n              cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), parseStatements($traceurRuntime.getTemplateObject([\"\\n                      $ctx.state = $ctx.finallyFallThrough;\\n                      break;\"]))));\n            }\n            this.addFinallyFallThroughDispatches(finallyState, finallyState.nestedTrys, cases);\n          } else {\n            this.addFinallyFallThroughDispatches(enclosingFinallyState, tryState.nestedTrys, cases);\n          }\n        }\n      },\n      transformVariableDeclarationList: function(tree) {\n        this.reporter.reportError(tree.location, 'Traceur: const/let declarations in a block containing a yield are ' + 'not yet implemented');\n        return tree;\n      },\n      maybeTransformStatement_: function(maybeTransformedStatement) {\n        var breakContinueTransformed = new BreakContinueTransformer(this.stateAllocator_).transformAny(maybeTransformedStatement);\n        if (breakContinueTransformed !== maybeTransformedStatement) {\n          breakContinueTransformed = this.transformAny(breakContinueTransformed);\n        }\n        return breakContinueTransformed;\n      },\n      ensureTransformed_: function(statement) {\n        if (statement === null) {\n          return null;\n        }\n        var maybeTransformed = this.maybeTransformStatement_(statement);\n        return maybeTransformed.type === STATE_MACHINE ? maybeTransformed : this.statementToStateMachine_(maybeTransformed);\n      },\n      ensureTransformedList_: function(statements) {\n        var maybeTransformedStatements = [];\n        var foundMachine = false;\n        for (var i = 0; i < statements.length; i++) {\n          var statement = statements[i];\n          var maybeTransformedStatement = this.maybeTransformStatement_(statement);\n          maybeTransformedStatements.push(maybeTransformedStatement);\n          if (maybeTransformedStatement.type === STATE_MACHINE) {\n            foundMachine = true;\n          }\n        }\n        if (!foundMachine) {\n          return this.statementsToStateMachine_(statements);\n        }\n        return this.transformStatementList_(maybeTransformedStatements);\n      },\n      expressionToStateMachine: function(tree) {\n        var commaExpression = new ExplodeExpressionTransformer(this).transformAny(tree);\n        var statements = new NormalizeCommaExpressionToStatementTransformer().transformAny(commaExpression).statements;\n        var lastStatement = statements.pop();\n        assert(lastStatement.type === EXPRESSION_STATEMENT);\n        var expression = lastStatement.expression;\n        statements = $traceurRuntime.superGet(this, CPSTransformer.prototype, \"transformList\").call(this, statements);\n        var machine = this.transformStatementList_(statements);\n        return {\n          expression: expression,\n          machine: machine\n        };\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  var NormalizeCommaExpressionToStatementTransformer = function($__super) {\n    function NormalizeCommaExpressionToStatementTransformer() {\n      $traceurRuntime.superConstructor(NormalizeCommaExpressionToStatementTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NormalizeCommaExpressionToStatementTransformer, {\n      transformCommaExpression: function(tree) {\n        var $__5 = this;\n        var statements = tree.expressions.map(function(expr) {\n          if (expr.type === CONDITIONAL_EXPRESSION)\n            return $__5.transformAny(expr);\n          return createExpressionStatement(expr);\n        });\n        return new AnonBlock(tree.location, statements);\n      },\n      transformConditionalExpression: function(tree) {\n        var ifBlock = this.transformAny(tree.left);\n        var elseBlock = this.transformAny(tree.right);\n        return new IfStatement(tree.location, tree.condition, anonBlockToBlock(ifBlock), anonBlockToBlock(elseBlock));\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  function anonBlockToBlock(tree) {\n    if (tree.type === PAREN_EXPRESSION)\n      return anonBlockToBlock(tree.expression);\n    return new Block(tree.location, tree.statements);\n  }\n  return {get CPSTransformer() {\n      return CPSTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/EndState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/EndState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/EndState.js\")).State;\n  var EndState = function($__super) {\n    function EndState() {\n      $traceurRuntime.superConstructor(EndState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(EndState, {\n      replaceState: function(oldState, newState) {\n        return new EndState(State.replaceStateId(this.id, oldState, newState));\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return State.generateJump(enclosingFinally, machineEndState);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get EndState() {\n      return EndState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\";\n  var AwaitState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AwaitState.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).AwaitState;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")),\n      BinaryExpression = $__4.BinaryExpression,\n      ExpressionStatement = $__4.ExpressionStatement;\n  var CPSTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./CPSTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).CPSTransformer;\n  var EndState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./EndState.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).EndState;\n  var FallThroughState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FallThroughState.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).FallThroughState;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")),\n      AWAIT_EXPRESSION = $__9.AWAIT_EXPRESSION,\n      BINARY_EXPRESSION = $__9.BINARY_EXPRESSION,\n      STATE_MACHINE = $__9.STATE_MACHINE;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")),\n      parseExpression = $__10.parseExpression,\n      parseStatement = $__10.parseStatement,\n      parseStatements = $__10.parseStatements;\n  var StateMachine = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/StateMachine.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).StateMachine;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).FindInFunctionScope;\n  var createUndefinedExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/AsyncTransformer.js\")).createUndefinedExpression;\n  function isAwaitAssign(tree) {\n    return tree.type === BINARY_EXPRESSION && tree.operator.isAssignmentOperator() && tree.right.type === AWAIT_EXPRESSION && tree.left.isLeftHandSideExpression();\n  }\n  var AwaitFinder = function($__super) {\n    function AwaitFinder() {\n      $traceurRuntime.superConstructor(AwaitFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(AwaitFinder, {visitAwaitExpression: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function scopeContainsAwait(tree) {\n    var visitor = new AwaitFinder();\n    visitor.visitAny(tree);\n    return visitor.found;\n  }\n  var AsyncTransformer = function($__super) {\n    function AsyncTransformer() {\n      $traceurRuntime.superConstructor(AsyncTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(AsyncTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        if (tree === null)\n          return false;\n        return scopeContainsAwait(tree);\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression.type === AWAIT_EXPRESSION)\n          return this.transformAwaitExpression_(expression);\n        if (isAwaitAssign(expression))\n          return this.transformAwaitAssign_(expression);\n        if (this.expressionNeedsStateMachine(expression)) {\n          return this.expressionToStateMachine(expression).machine;\n        }\n        return $traceurRuntime.superGet(this, AsyncTransformer.prototype, \"transformExpressionStatement\").call(this, tree);\n      },\n      transformAwaitExpression: function(tree) {\n        throw new Error('Internal error');\n      },\n      transformAwaitExpression_: function(tree) {\n        return this.transformAwait_(tree, tree.expression, null, null);\n      },\n      transformAwaitAssign_: function(tree) {\n        return this.transformAwait_(tree, tree.right.expression, tree.left, tree.operator);\n      },\n      transformAwait_: function(tree, inExpression, left, operator) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(inExpression)) {\n          (($__2 = this.expressionToStateMachine(inExpression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = this.transformAny(inExpression);\n        }\n        var createTaskState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var callbackState = left ? this.allocateState() : fallThroughState;\n        var states = [];\n        states.push(new AwaitState(createTaskState, callbackState, expression));\n        if (left) {\n          var statement = new ExpressionStatement(tree.location, new BinaryExpression(tree.location, left, operator, parseExpression($traceurRuntime.getTemplateObject([\"$ctx.value\"]))));\n          states.push(new FallThroughState(callbackState, fallThroughState, [statement]));\n        }\n        var awaitMachine = new StateMachine(createTaskState, fallThroughState, states, []);\n        if (machine) {\n          awaitMachine = machine.append(awaitMachine);\n        }\n        return awaitMachine;\n      },\n      transformFinally: function(tree) {\n        var result = $traceurRuntime.superGet(this, AsyncTransformer.prototype, \"transformFinally\").call(this, tree);\n        if (result.block.type !== STATE_MACHINE) {\n          return result;\n        }\n        this.reporter.reportError(tree.location, 'await not permitted within a finally block.');\n        return result;\n      },\n      transformReturnStatement: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = tree.expression || createUndefinedExpression();\n        }\n        var startState = this.allocateState();\n        var endState = this.allocateState();\n        var completeState = new FallThroughState(startState, endState, parseStatements($traceurRuntime.getTemplateObject([\"$ctx.returnValue = \", \"\"]), expression));\n        var end = new EndState(endState);\n        var returnMachine = new StateMachine(startState, this.allocateState(), [completeState, end], []);\n        if (machine)\n          returnMachine = machine.append(returnMachine);\n        return returnMachine;\n      },\n      createCompleteTask_: function(result) {\n        return parseStatement($traceurRuntime.getTemplateObject([\"$ctx.resolve(\", \")\"]), result);\n      },\n      transformAsyncBody: function(tree) {\n        var asyncWrap = this.getRuntimeExpression('asyncWrap');\n        return this.transformCpsFunctionBody(tree, asyncWrap);\n      }\n    }, {transformAsyncBody: function(identifierGenerator, reporter, options, body) {\n        return new AsyncTransformer(identifierGenerator, reporter, options).transformAsyncBody(body);\n      }}, $__super);\n  }(ImportRuntimeTrait(CPSTransformer));\n  ;\n  return {get AsyncTransformer() {\n      return AsyncTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\")),\n      BLOCK = $__3.BLOCK,\n      VARIABLE_DECLARATION_LIST = $__3.VARIABLE_DECLARATION_LIST,\n      IDENTIFIER_EXPRESSION = $__3.IDENTIFIER_EXPRESSION;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\")),\n      LENGTH = $__4.LENGTH,\n      PUSH = $__4.PUSH;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\")).TempVarTransformer;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\")),\n      BANG = $__6.BANG,\n      IN = $__6.IN,\n      OPEN_ANGLE = $__6.OPEN_ANGLE,\n      PLUS_PLUS = $__6.PLUS_PLUS,\n      VAR = $__6.VAR;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/ForInTransformPass.js\")),\n      createArgumentList = $__7.createArgumentList,\n      createAssignmentStatement = $__7.createAssignmentStatement,\n      createBinaryExpression = $__7.createBinaryExpression,\n      createBlock = $__7.createBlock,\n      createCallStatement = $__7.createCallStatement,\n      createContinueStatement = $__7.createContinueStatement,\n      createEmptyArrayLiteral = $__7.createEmptyArrayLiteral,\n      createForInStatement = $__7.createForInStatement,\n      createForStatement = $__7.createForStatement,\n      createIdentifierExpression = $__7.createIdentifierExpression,\n      createIfStatement = $__7.createIfStatement,\n      createMemberExpression = $__7.createMemberExpression,\n      createMemberLookupExpression = $__7.createMemberLookupExpression,\n      createNumberLiteral = $__7.createNumberLiteral,\n      createOperatorToken = $__7.createOperatorToken,\n      createParenExpression = $__7.createParenExpression,\n      createPostfixExpression = $__7.createPostfixExpression,\n      createUnaryExpression = $__7.createUnaryExpression,\n      createVariableDeclarationList = $__7.createVariableDeclarationList,\n      createVariableStatement = $__7.createVariableStatement;\n  var ForInTransformPass = function($__super) {\n    function ForInTransformPass() {\n      $traceurRuntime.superConstructor(ForInTransformPass).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForInTransformPass, {transformForInStatement: function(tree) {\n        var $__1,\n            $__2;\n        var bodyStatements = [];\n        var body = this.transformAny(tree.body);\n        if (body.type === BLOCK) {\n          ($__1 = bodyStatements).push.apply($__1, $traceurRuntime.spread(body.statements));\n        } else {\n          bodyStatements.push(body);\n        }\n        var elements = [];\n        var keys = this.getTempIdentifier();\n        elements.push(createVariableStatement(VAR, keys, createEmptyArrayLiteral()));\n        var collection = this.getTempIdentifier();\n        elements.push(createVariableStatement(VAR, collection, tree.collection));\n        var p = this.getTempIdentifier();\n        elements.push(createForInStatement(createVariableDeclarationList(VAR, p, null), createIdentifierExpression(collection), createCallStatement(createMemberExpression(keys, PUSH), createArgumentList([createIdentifierExpression(p)]))));\n        var i = this.getTempIdentifier();\n        var lookup = createMemberLookupExpression(createIdentifierExpression(keys), createIdentifierExpression(i));\n        var originalKey,\n            assignOriginalKey;\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          var decList = tree.initializer;\n          originalKey = createIdentifierExpression(decList.declarations[0].lvalue);\n          assignOriginalKey = createVariableStatement(decList.declarationType, originalKey.identifierToken, lookup);\n        } else if (tree.initializer.type === IDENTIFIER_EXPRESSION) {\n          originalKey = tree.initializer;\n          assignOriginalKey = createAssignmentStatement(tree.initializer, lookup);\n        } else {\n          throw new Error('Invalid left hand side of for in loop');\n        }\n        var innerBlock = [];\n        innerBlock.push(assignOriginalKey);\n        innerBlock.push(createIfStatement(createUnaryExpression(createOperatorToken(BANG), createParenExpression(createBinaryExpression(originalKey, createOperatorToken(IN), createIdentifierExpression(collection)))), createContinueStatement(), null));\n        ($__2 = innerBlock).push.apply($__2, $traceurRuntime.spread(bodyStatements));\n        elements.push(createForStatement(createVariableDeclarationList(VAR, i, createNumberLiteral(0)), createBinaryExpression(createIdentifierExpression(i), createOperatorToken(OPEN_ANGLE), createMemberExpression(keys, LENGTH)), createPostfixExpression(createIdentifierExpression(i), createOperatorToken(PLUS_PLUS)), createBlock(innerBlock)));\n        return createBlock(elements);\n      }}, {}, $__super);\n  }(TempVarTransformer);\n  return {get ForInTransformPass() {\n      return ForInTransformPass;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/YieldState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/YieldState.js\";\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/YieldState.js\")).State;\n  var createReturnStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/YieldState.js\")).createReturnStatement;\n  var YieldState = function($__super) {\n    function YieldState(id, fallThroughState, expression) {\n      $traceurRuntime.superConstructor(YieldState).call(this, id);\n      this.fallThroughState = fallThroughState;\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(YieldState, {\n      replaceState: function(oldState, newState) {\n        return new this.constructor(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.expression);\n      },\n      transform: function(enclosingFinally, machineEndState, reporter) {\n        return $traceurRuntime.spread(State.generateAssignState(enclosingFinally, this.fallThroughState), [createReturnStatement(this.expression)]);\n      }\n    }, {}, $__super);\n  }(State);\n  return {get YieldState() {\n      return YieldState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../semantics/util.js\", \"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\")),\n      isUndefined = $__2.isUndefined,\n      isVoidExpression = $__2.isVoidExpression;\n  var YieldState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./YieldState.js\", \"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\")).YieldState;\n  var State = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./State.js\", \"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\")).State;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/ReturnState.js\")).parseStatement;\n  var ReturnState = function($__super) {\n    function ReturnState() {\n      $traceurRuntime.superConstructor(ReturnState).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ReturnState, {transform: function(enclosingFinally, machineEndState, reporter) {\n        var $__1;\n        var e = this.expression;\n        var statements = [];\n        if (e && !isUndefined(e) && !isVoidExpression(e))\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"$ctx.returnValue = \", \"\"]), this.expression));\n        ($__1 = statements).push.apply($__1, $traceurRuntime.spread(State.generateJump(enclosingFinally, machineEndState)));\n        return statements;\n      }}, {}, $__super);\n  }(YieldState);\n  return {get ReturnState() {\n      return ReturnState;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\";\n  var CPSTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./CPSTransformer.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")).CPSTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")),\n      BINARY_EXPRESSION = $__4.BINARY_EXPRESSION,\n      YIELD_EXPRESSION = $__4.YIELD_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")),\n      BinaryExpression = $__5.BinaryExpression,\n      ExpressionStatement = $__5.ExpressionStatement;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")).FindInFunctionScope;\n  var ReturnState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ReturnState.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")).ReturnState;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")).default;\n  var YieldState = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./YieldState.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")).YieldState;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")),\n      id = $__10.createIdentifierExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createUndefinedExpression = $__10.createUndefinedExpression;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/generator/GeneratorTransformer.js\")),\n      parseExpression = $__11.parseExpression,\n      parseStatement = $__11.parseStatement,\n      parseStatements = $__11.parseStatements;\n  function isYieldAssign(tree) {\n    return tree.type === BINARY_EXPRESSION && tree.operator.isAssignmentOperator() && tree.right.type === YIELD_EXPRESSION && tree.left.isLeftHandSideExpression();\n  }\n  var YieldFinder = function($__super) {\n    function YieldFinder() {\n      $traceurRuntime.superConstructor(YieldFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(YieldFinder, {visitYieldExpression: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function scopeContainsYield(tree) {\n    var finder = new YieldFinder();\n    finder.visitAny(tree);\n    return finder.found;\n  }\n  var GeneratorTransformer = function($__super) {\n    function GeneratorTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(GeneratorTransformer).call(this, identifierGenerator, reporter, options);\n      this.shouldAppendThrowCloseState_ = true;\n    }\n    return ($traceurRuntime.createClass)(GeneratorTransformer, {\n      expressionNeedsStateMachine: function(tree) {\n        if (tree === null)\n          return false;\n        return scopeContainsYield(tree);\n      },\n      transformYieldExpression_: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression)) {\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        } else {\n          expression = this.transformAny(tree.expression);\n        }\n        if (tree.isYieldFor)\n          return this.transformYieldForExpression_(expression, machine);\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var yieldMachine = this.stateToStateMachine_(new YieldState(startState, fallThroughState, expression), fallThroughState);\n        if (machine)\n          yieldMachine = machine.append(yieldMachine);\n        if (this.shouldAppendThrowCloseState_)\n          yieldMachine = yieldMachine.append(this.createThrowCloseState_());\n        return yieldMachine;\n      },\n      transformYieldForExpression_: function(expression) {\n        var machine = arguments[1];\n        var gName = this.getTempIdentifier();\n        this.addMachineVariable(gName);\n        var g = id(gName);\n        var nextName = this.getTempIdentifier();\n        this.addMachineVariable(nextName);\n        var next = id(nextName);\n        var statements = parseStatements($traceurRuntime.getTemplateObject([\"\\n        \", \" = $ctx.wrapYieldStar(\", \"[Symbol.iterator]());\\n        // received = void 0;\\n        $ctx.sent = void 0;\\n        // send = true; // roughly equivalent\\n        $ctx.action = 'next';\\n\\n        for (;;) {\\n          \", \" = \", \"[$ctx.action]($ctx.sentIgnoreThrow);\\n          if (\", \".done) {\\n            $ctx.sent = \", \".value;\\n            break;\\n          }\\n          yield \", \".value;\\n        }\"]), g, expression, next, g, next, next, next);\n        var shouldAppendThrowCloseState = this.shouldAppendThrowCloseState_;\n        this.shouldAppendThrowCloseState_ = false;\n        statements = this.transformList(statements);\n        var yieldMachine = this.transformStatementList_(statements);\n        this.shouldAppendThrowCloseState_ = shouldAppendThrowCloseState;\n        if (machine)\n          yieldMachine = machine.append(yieldMachine);\n        return yieldMachine;\n      },\n      transformYieldExpression: function(tree) {\n        this.reporter.reportError(tree.location, 'Only \\'a = yield b\\' and \\'var a = yield b\\' currently supported.');\n        return tree;\n      },\n      transformYieldAssign_: function(tree) {\n        var shouldAppendThrowCloseState = this.shouldAppendThrowCloseState_;\n        this.shouldAppendThrowCloseState_ = false;\n        var machine = this.transformYieldExpression_(tree.right);\n        var left = this.transformAny(tree.left);\n        var sentExpression = tree.right.isYieldFor ? parseExpression($traceurRuntime.getTemplateObject([\"$ctx.sentIgnoreThrow\"])) : parseExpression($traceurRuntime.getTemplateObject([\"$ctx.sent\"]));\n        var statement = new ExpressionStatement(tree.location, new BinaryExpression(tree.location, left, tree.operator, sentExpression));\n        var assignMachine = this.statementToStateMachine_(statement);\n        this.shouldAppendThrowCloseState_ = shouldAppendThrowCloseState;\n        return machine.append(assignMachine);\n      },\n      createThrowCloseState_: function() {\n        return this.statementToStateMachine_(parseStatement($traceurRuntime.getTemplateObject([\"$ctx.maybeThrow()\"])));\n      },\n      transformExpressionStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression.type === YIELD_EXPRESSION)\n          return this.transformYieldExpression_(expression);\n        if (isYieldAssign(expression))\n          return this.transformYieldAssign_(expression);\n        if (this.expressionNeedsStateMachine(expression)) {\n          return this.expressionToStateMachine(expression).machine;\n        }\n        return $traceurRuntime.superGet(this, GeneratorTransformer.prototype, \"transformExpressionStatement\").call(this, tree);\n      },\n      transformAwaitStatement: function(tree) {\n        this.reporter.reportError(tree.location, 'Generator function may not have an await statement.');\n        return tree;\n      },\n      transformReturnStatement: function(tree) {\n        var $__2;\n        var expression,\n            machine;\n        if (this.expressionNeedsStateMachine(tree.expression))\n          (($__2 = this.expressionToStateMachine(tree.expression), expression = $__2.expression, machine = $__2.machine, $__2));\n        else\n          expression = tree.expression;\n        var startState = this.allocateState();\n        var fallThroughState = this.allocateState();\n        var returnMachine = this.stateToStateMachine_(new ReturnState(startState, fallThroughState, this.transformAny(expression)), fallThroughState);\n        if (machine)\n          return machine.append(returnMachine);\n        return returnMachine;\n      },\n      transformGeneratorBody: function(tree, name) {\n        var createGeneratorInstance = this.getRuntimeExpression('createGeneratorInstance');\n        return this.transformCpsFunctionBody(tree, createGeneratorInstance, name);\n      }\n    }, {transformGeneratorBody: function(identifierGenerator, reporter, options, body, name) {\n        return new GeneratorTransformer(identifierGenerator, reporter, options).transformGeneratorBody(body, name);\n      }}, $__super);\n  }(ImportRuntimeTrait(CPSTransformer));\n  ;\n  return {get GeneratorTransformer() {\n      return GeneratorTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\";\n  var ArrowFunctionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ArrowFunctionTransformer.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).ArrowFunctionTransformer;\n  var AsyncTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generator/AsyncTransformer.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).AsyncTransformer;\n  var ForInTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generator/ForInTransformPass.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).ForInTransformPass;\n  var GeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./generator/GeneratorTransformer.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).GeneratorTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")),\n      parseExpression = $__8.parseExpression,\n      parseStatement = $__8.parseStatement;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).TempVarTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).default;\n  var FindInFunctionScope = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindInFunctionScope.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")).FindInFunctionScope;\n  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")),\n      AnonBlock = $__12.AnonBlock,\n      FunctionDeclaration = $__12.FunctionDeclaration,\n      FunctionExpression = $__12.FunctionExpression;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/GeneratorTransformPass.js\")),\n      createBindingIdentifier = $__13.createBindingIdentifier,\n      id = $__13.createIdentifierExpression,\n      createIdentifierToken = $__13.createIdentifierToken;\n  var ForInFinder = function($__super) {\n    function ForInFinder() {\n      $traceurRuntime.superConstructor(ForInFinder).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ForInFinder, {visitForInStatement: function(tree) {\n        this.found = true;\n      }}, {}, $__super);\n  }(FindInFunctionScope);\n  function needsTransform(tree, transformOptions) {\n    return transformOptions.generators && tree.isGenerator() || transformOptions.asyncFunctions && tree.isAsyncFunction();\n  }\n  var GeneratorTransformPass = function($__super) {\n    function GeneratorTransformPass(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(GeneratorTransformPass).call(this, identifierGenerator, reporter, options);\n      this.tranformOptions_ = options.transformOptions;\n      this.inBlock_ = false;\n    }\n    return ($traceurRuntime.createClass)(GeneratorTransformPass, {\n      transformFunctionDeclaration: function(tree) {\n        if (!needsTransform(tree, this.tranformOptions_))\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, \"transformFunctionDeclaration\").call(this, tree);\n        if (tree.isGenerator())\n          return this.transformGeneratorDeclaration_(tree);\n        return this.transformFunction_(tree, FunctionDeclaration, null);\n      },\n      transformGeneratorDeclaration_: function(tree) {\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initGeneratorFunction = this.getRuntimeExpression('initGeneratorFunction');\n        var setupPrototypeExpression = parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initGeneratorFunction, nameIdExpression);\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupPrototypeExpression));\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration, tmpVar);\n        if (!this.inBlock_)\n          return funcDecl;\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject([\"var \", \" = \", \"\"]), tmpVar, setupPrototypeExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        if (!needsTransform(tree, this.tranformOptions_))\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, \"transformFunctionExpression\").call(this, tree);\n        if (tree.isGenerator())\n          return this.transformGeneratorExpression_(tree);\n        return this.transformFunction_(tree, FunctionExpression, null);\n      },\n      transformGeneratorExpression_: function(tree) {\n        var name;\n        if (!tree.name) {\n          name = createIdentifierToken(this.getTempIdentifier());\n          tree = new FunctionExpression(tree.location, createBindingIdentifier(name), tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, tree.body);\n        } else {\n          name = tree.name.identifierToken;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression, id(name));\n        var initGeneratorFunction = this.getRuntimeExpression('initGeneratorFunction');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initGeneratorFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor, nameExpression) {\n        var $__2 = this;\n        var body = $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, \"transformAny\").call(this, tree.body);\n        var finder = new ForInFinder();\n        finder.visitAny(body);\n        if (finder.found) {\n          body = new ForInTransformPass(this.identifierGenerator, this.reporter, this.options).transformAny(body);\n        }\n        if (this.tranformOptions_.generators && tree.isGenerator()) {\n          var transformer = new GeneratorTransformer(this.identifierGenerator, this.reporter, this.options);\n          body = transformer.transformGeneratorBody(body, nameExpression);\n          transformer.requiredNames.forEach(function(n) {\n            $__2.addImportedName(n);\n          });\n        } else if (this.tranformOptions_.asyncFunctions && tree.isAsyncFunction()) {\n          var transformer$__3 = new AsyncTransformer(this.identifierGenerator, this.reporter, this.options);\n          body = transformer$__3.transformAsyncBody(body, nameExpression);\n          transformer$__3.requiredNames.forEach(function(n) {\n            $__2.addImportedName(n);\n          });\n        }\n        var functionKind = null;\n        return new constructor(tree.location, tree.name, functionKind, tree.parameterList, tree.typeAnnotation || null, tree.annotations || null, body);\n      },\n      transformArrowFunction: function(tree) {\n        if (!tree.isAsyncFunction())\n          return $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, \"transformArrowFunction\").call(this, tree);\n        return this.transformAny(ArrowFunctionTransformer.transform(this, tree));\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, GeneratorTransformPass.prototype, \"transformBlock\").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get GeneratorTransformPass() {\n      return GeneratorTransformPass;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js\";\n  var VAR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js\")).VAR;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js\")).ModuleTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/InlineModuleTransformer.js\")),\n      createBindingIdentifier = $__3.createBindingIdentifier,\n      createEmptyStatement = $__3.createEmptyStatement,\n      createFunctionBody = $__3.createFunctionBody,\n      createImmediatelyInvokedFunctionExpression = $__3.createImmediatelyInvokedFunctionExpression,\n      createVariableStatement = $__3.createVariableStatement;\n  var anonInlineModules = 0;\n  var InlineModuleTransformer = function($__super) {\n    function InlineModuleTransformer() {\n      $traceurRuntime.superConstructor(InlineModuleTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(InlineModuleTransformer, {\n      wrapModule: function(statements) {\n        var seed = this.moduleName || 'anon_' + ++anonInlineModules;\n        var idName = this.getTempVarNameForModuleName(seed);\n        var body = createFunctionBody(statements);\n        var moduleExpression = createImmediatelyInvokedFunctionExpression(body);\n        return [createVariableStatement(VAR, idName, moduleExpression)];\n      },\n      transformNamedExport: function(tree) {\n        return createEmptyStatement();\n      },\n      transformModuleSpecifier: function(tree) {\n        return createBindingIdentifier(this.getTempVarNameForModuleSpecifier(tree));\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InlineModuleTransformer() {\n      return InlineModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\";\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")),\n      AnonBlock = $__10.AnonBlock,\n      ArrayLiteral = $__10.ArrayLiteral,\n      ClassExpression = $__10.ClassExpression,\n      CommaExpression = $__10.CommaExpression,\n      ExpressionStatement = $__10.ExpressionStatement,\n      VariableDeclaration = $__10.VariableDeclaration;\n  var $__11 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")),\n      ANON_BLOCK = $__11.ANON_BLOCK,\n      CLASS_DECLARATION = $__11.CLASS_DECLARATION,\n      FUNCTION_DECLARATION = $__11.FUNCTION_DECLARATION,\n      IDENTIFIER_EXPRESSION = $__11.IDENTIFIER_EXPRESSION,\n      IMPORT_SPECIFIER_SET = $__11.IMPORT_SPECIFIER_SET,\n      NAME_SPACE_IMPORT = $__11.NAME_SPACE_IMPORT;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")).ParseTreeVisitor;\n  var ScopeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeTransformer.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")).ScopeTransformer;\n  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")),\n      createEmptyParameterList = $__14.createEmptyParameterList,\n      createFunctionBody = $__14.createFunctionBody,\n      createFunctionExpression = $__14.createFunctionExpression,\n      id = $__14.createIdentifierExpression,\n      createObjectLiteralForDescriptor = $__14.createObjectLiteralForDescriptor,\n      createUseStrictDirective = $__14.createUseStrictDirective,\n      createVariableDeclarationList = $__14.createVariableDeclarationList,\n      createVariableStatement = $__14.createVariableStatement;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")).ModuleTransformer;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")),\n      MINUS_MINUS = $__16.MINUS_MINUS,\n      PLUS_PLUS = $__16.PLUS_PLUS,\n      VAR = $__16.VAR;\n  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")),\n      parseExpression = $__17.parseExpression,\n      parseStatement = $__17.parseStatement,\n      parseStatements = $__17.parseStatements;\n  var HoistVariablesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./HoistVariablesTransformer.js\", \"traceur@0.0.111/src/codegeneration/InstantiateModuleTransformer.js\")).default;\n  function flattenAnonBlocks(statements) {\n    var $__9;\n    var result = [];\n    for (var i = 0; i < statements.length; i++) {\n      var statement = statements[i];\n      if (statement.type === ANON_BLOCK) {\n        ($__9 = result).push.apply($__9, $traceurRuntime.spread(statement.statements));\n      } else {\n        result.push(statement);\n      }\n    }\n    return result;\n  }\n  var ExportBindingsVisitor = function($__super) {\n    function ExportBindingsVisitor() {\n      $traceurRuntime.superConstructor(ExportBindingsVisitor).call(this);\n      this.bindings = [];\n    }\n    return ($traceurRuntime.createClass)(ExportBindingsVisitor, {\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n      },\n      visitBindingIdentifier: function(tree) {\n        this.bindings.push(tree);\n      },\n      visitBindingElement: function(tree) {\n        this.visitAny(tree.binding);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  var DeclarationExtractionTransformer = function($__super) {\n    function DeclarationExtractionTransformer() {\n      $traceurRuntime.superConstructor(DeclarationExtractionTransformer).call(this);\n      this.declarations_ = [];\n    }\n    return ($traceurRuntime.createClass)(DeclarationExtractionTransformer, {\n      getDeclarationStatements: function() {\n        return flattenAnonBlocks($traceurRuntime.spread([this.getVariableStatement()], this.declarations_));\n      },\n      addDeclaration: function(tree) {\n        this.declarations_.push(tree);\n      },\n      transformFunctionDeclaration: function(tree) {\n        this.addDeclaration(tree);\n        return new AnonBlock(null, []);\n      },\n      transformClassDeclaration: function(tree) {\n        this.addVariable(tree.name.identifierToken.value);\n        tree = new ClassExpression(tree.location, tree.name, tree.superClass, tree.elements, tree.annotations, tree.typeParameters);\n        return parseStatement($traceurRuntime.getTemplateObject([\"\", \" = \", \"\"]), tree.name.identifierToken, tree);\n      }\n    }, {}, $__super);\n  }(HoistVariablesTransformer);\n  var ModuleNameIdentifierTransformer = function($__super) {\n    function ModuleNameIdentifierTransformer() {\n      $traceurRuntime.superConstructor(ModuleNameIdentifierTransformer).call(this, '__moduleName');\n      this.usesModuleName = false;\n    }\n    return ($traceurRuntime.createClass)(ModuleNameIdentifierTransformer, {transformIdentifierExpression: function(tree) {\n        if (tree.identifierToken.value === '__moduleName') {\n          this.usesModuleName = true;\n          return parseExpression($traceurRuntime.getTemplateObject([\"$__moduleContext.id\"]));\n        }\n        return $traceurRuntime.superGet(this, ModuleNameIdentifierTransformer.prototype, \"transformIdentifierExpression\").call(this, tree);\n      }}, {}, $__super);\n  }(ScopeTransformer);\n  var InsertBindingAssignmentTransformer = function($__super) {\n    function InsertBindingAssignmentTransformer(exportName, bindingName) {\n      $traceurRuntime.superConstructor(InsertBindingAssignmentTransformer).call(this, bindingName);\n      this.bindingName_ = bindingName;\n      this.exportName_ = exportName;\n    }\n    return ($traceurRuntime.createClass)(InsertBindingAssignmentTransformer, {\n      matchesBindingName_: function(binding) {\n        return binding.type === IDENTIFIER_EXPRESSION && binding.identifierToken.value === this.bindingName_;\n      },\n      transformUnaryExpression: function(tree) {\n        if (!this.matchesBindingName_(tree.operand))\n          return $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, \"transformUnaryExpression\").call(this, tree);\n        var operatorType = tree.operator.type;\n        if (operatorType !== PLUS_PLUS && operatorType !== MINUS_MINUS)\n          return $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, \"transformUnaryExpression\").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        if (operand !== tree.operand)\n          tree = new UnaryExpression(tree.location, tree.operator, operand);\n        return parseExpression($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \")\"]), this.exportName_, tree);\n      },\n      transformPostfixExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, \"transformPostfixExpression\").call(this, tree);\n        if (!this.matchesBindingName_(tree.operand))\n          return tree;\n        switch (tree.operator.type) {\n          case PLUS_PLUS:\n            return parseExpression($traceurRuntime.getTemplateObject([\"($__export(\", \", \", \" + 1), \", \")\"]), this.exportName_, tree.operand, tree);\n          case MINUS_MINUS:\n            return parseExpression($traceurRuntime.getTemplateObject([\"($__export(\", \", \", \" - 1), \", \")\"]), this.exportName_, tree.operand, tree);\n        }\n        return tree;\n      },\n      transformBinaryExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, InsertBindingAssignmentTransformer.prototype, \"transformBinaryExpression\").call(this, tree);\n        if (!tree.operator.isAssignmentOperator())\n          return tree;\n        if (!this.matchesBindingName_(tree.left))\n          return tree;\n        return parseExpression($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \")}\"]), this.exportName_, tree);\n      }\n    }, {}, $__super);\n  }(ScopeTransformer);\n  var InstantiateModuleTransformer = function($__super) {\n    function InstantiateModuleTransformer(identifierGenerator, reporter) {\n      var options = arguments[2];\n      $traceurRuntime.superConstructor(InstantiateModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.anonymousModule = options && !options.bundle && options.moduleName !== true;\n      this.usesModuleName = false;\n      this.inExport_ = false;\n      this.curDepIndex_ = null;\n      this.dependencies = [];\n      this.externalExportBindings = [];\n      this.importBindings = [];\n      this.localExportBindings = [];\n      this.functionDeclarations = [];\n      this.moduleBindings = [];\n      this.exportStarBindings = [];\n    }\n    return ($traceurRuntime.createClass)(InstantiateModuleTransformer, {\n      getModuleName: function(tree) {\n        if (this.anonymousModule)\n          return null;\n        return tree.moduleName;\n      },\n      moduleProlog: function() {\n        return [];\n      },\n      wrapModule: function(statements) {\n        var prolog = [createUseStrictDirective()];\n        statements = prolog.concat(statements);\n        if (this.usesModuleName) {\n          if (this.moduleName) {\n            return parseStatements($traceurRuntime.getTemplateObject([\"System.register(\", \",\\n            \", \", function($__export, $__moduleContext) {\\n              \", \"\\n            });\"]), this.moduleName, this.dependencies, statements);\n          }\n          return parseStatements($traceurRuntime.getTemplateObject([\"System.register(\", \", function($__export, $__moduleContext) {\\n            \", \"\\n          });\"]), this.dependencies, statements);\n        }\n        if (this.moduleName) {\n          return parseStatements($traceurRuntime.getTemplateObject([\"System.register(\", \",\\n          \", \", function($__export) {\\n            \", \"\\n          });\"]), this.moduleName, this.dependencies, statements);\n        }\n        return parseStatements($traceurRuntime.getTemplateObject([\"System.register(\", \", function($__export) {\\n          \", \"\\n        });\"]), this.dependencies, statements);\n      },\n      addExportStatement: function(statements) {\n        var $__6 = this;\n        var declarationExtractionTransformer = new DeclarationExtractionTransformer();\n        var moduleNameIdentifierTransformer = new ModuleNameIdentifierTransformer();\n        statements = moduleNameIdentifierTransformer.transformList(statements);\n        if (moduleNameIdentifierTransformer.usesModuleName)\n          this.usesModuleName = true;\n        this.localExportBindings.forEach(function(binding) {\n          statements = new InsertBindingAssignmentTransformer(binding.exportName, binding.localName).transformList(statements);\n        });\n        var executionStatements = declarationExtractionTransformer.transformList(statements);\n        var executionFunction = createFunctionExpression(createEmptyParameterList(), createFunctionBody(executionStatements));\n        var declarationStatements = declarationExtractionTransformer.getDeclarationStatements();\n        var setterFunctions = this.dependencies.map(function(dep, index) {\n          var importBindings = $__6.importBindings[index];\n          var externalExportBindings = $__6.externalExportBindings[index];\n          var exportStarBinding = $__6.exportStarBindings[index];\n          var moduleBinding = $__6.moduleBindings[index];\n          var setterStatements = [];\n          if (importBindings) {\n            importBindings.forEach(function(binding) {\n              setterStatements.push(parseStatement($traceurRuntime.getTemplateObject([\"\", \" = $__m.\", \";\"]), id(binding.variableName), binding.exportName));\n            });\n          }\n          if (externalExportBindings) {\n            var reexports = Object.create(null);\n            externalExportBindings.forEach(function($__7) {\n              var $__8 = $__7,\n                  exportName = $__8.exportName,\n                  importName = $__8.importName;\n              reexports[exportName] = importName === null ? parseExpression($traceurRuntime.getTemplateObject([\"$__m\"])) : parseExpression($traceurRuntime.getTemplateObject([\"$__m.\", \"\"]), importName);\n            });\n            setterStatements.push(parseStatement($traceurRuntime.getTemplateObject([\"$__export(\", \")\"]), createObjectLiteralForDescriptor(reexports)));\n          }\n          if (moduleBinding) {\n            setterStatements.push(parseStatement($traceurRuntime.getTemplateObject([\"\", \" = $__m;\"]), id(moduleBinding)));\n          }\n          if (exportStarBinding) {\n            setterStatements = setterStatements.concat(parseStatements($traceurRuntime.getTemplateObject([\"\\n          var exportObj = Object.create(null);\\n          Object.keys($__m).forEach(function(p) {\\n            if (p !== 'default' && !$__exportNames[p])\\n              exportObj[p] = $__m[p];\\n          });\\n          $__export(exportObj);\\n        \"])));\n            var exportNames = {};\n            $__6.localExportBindings.concat($__6.externalExportBindings).forEach(function(binding) {\n              exportNames[binding.exportName] = true;\n            });\n            declarationStatements.push(parseStatement($traceurRuntime.getTemplateObject([\"\\n          var $__exportNames = \", \";\\n        \"]), createObjectLiteralForDescriptor(exportNames)));\n          }\n          if (setterStatements.length) {\n            return parseExpression($traceurRuntime.getTemplateObject([\"function($__m) {\\n          \", \"\\n        }\"]), setterStatements);\n          }\n          return parseExpression($traceurRuntime.getTemplateObject([\"function($__m) {}\"]));\n        });\n        declarationStatements = declarationStatements.concat(this.functionDeclarations.map(function(binding) {\n          return parseStatement($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \")\"]), binding.exportName, id(binding.functionName));\n        }));\n        declarationStatements.push(parseStatement($traceurRuntime.getTemplateObject([\"return {\\n      setters: \", \",\\n      execute: \", \"\\n    }\"]), new ArrayLiteral(null, setterFunctions), executionFunction));\n        return declarationStatements;\n      },\n      addLocalExportBinding: function(exportName) {\n        var localName = arguments[1] !== (void 0) ? arguments[1] : exportName;\n        this.localExportBindings.push({\n          exportName: exportName,\n          localName: localName\n        });\n      },\n      addImportBinding: function(depIndex, variableName, exportName) {\n        this.importBindings[depIndex] = this.importBindings[depIndex] || [];\n        this.importBindings[depIndex].push({\n          variableName: variableName,\n          exportName: exportName\n        });\n      },\n      addExternalExportBinding: function(depIndex, exportName, importName) {\n        this.externalExportBindings[depIndex] = this.externalExportBindings[depIndex] || [];\n        this.externalExportBindings[depIndex].push({\n          exportName: exportName,\n          importName: importName\n        });\n      },\n      addExportStarBinding: function(depIndex) {\n        this.exportStarBindings[depIndex] = true;\n      },\n      addModuleBinding: function(depIndex, variableName) {\n        this.moduleBindings[depIndex] = variableName;\n      },\n      addExportFunction: function(exportName) {\n        var functionName = arguments[1] !== (void 0) ? arguments[1] : exportName;\n        this.functionDeclarations.push({\n          exportName: exportName,\n          functionName: functionName\n        });\n      },\n      getOrCreateDependencyIndex: function(moduleSpecifier) {\n        var name = moduleSpecifier.token.processedValue;\n        var depIndex = this.dependencies.indexOf(name);\n        if (depIndex === -1) {\n          depIndex = this.dependencies.length;\n          this.dependencies.push(name);\n        }\n        return depIndex;\n      },\n      transformExportDeclaration: function(tree) {\n        this.inExport_ = true;\n        if (tree.declaration.moduleSpecifier) {\n          this.curDepIndex_ = this.getOrCreateDependencyIndex(tree.declaration.moduleSpecifier);\n        } else {\n          this.curDepIndex_ = null;\n        }\n        var transformed = this.transformAny(tree.declaration);\n        this.inExport_ = false;\n        return transformed;\n      },\n      transformVariableStatement: function(tree) {\n        if (!this.inExport_)\n          return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, \"transformVariableStatement\").call(this, tree);\n        this.inExport_ = false;\n        var bindingVisitor = new ExportBindingsVisitor();\n        bindingVisitor.visitAny(tree);\n        var statements = [];\n        for (var i = 0; i < bindingVisitor.bindings.length; i++) {\n          var identifierToken = bindingVisitor.bindings[i].identifierToken;\n          var name = identifierToken.value;\n          this.addLocalExportBinding(name);\n          statements.push(parseStatement($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \")\"]), name, id(identifierToken)));\n        }\n        statements.unshift($traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, \"transformAny\").call(this, tree));\n        return new AnonBlock(null, statements);\n      },\n      transformExportStar: function(tree) {\n        this.inExport_ = false;\n        this.addExportStarBinding(this.curDepIndex_);\n        return new AnonBlock(null, []);\n      },\n      transformClassDeclaration: function(tree) {\n        if (!this.inExport_)\n          return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, \"transformClassDeclaration\").call(this, tree);\n        this.inExport_ = false;\n        var identifierToken = tree.name.identifierToken;\n        var name = identifierToken.value;\n        this.addLocalExportBinding(name);\n        var statements = [$traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, \"transformClassDeclaration\").call(this, tree), parseStatement($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \")\"]), name, id(identifierToken))];\n        return new AnonBlock(null, statements);\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (this.inExport_) {\n          var name = tree.name.getStringValue();\n          this.addLocalExportBinding(name);\n          this.addExportFunction(name);\n          this.inExport_ = false;\n        }\n        return $traceurRuntime.superGet(this, InstantiateModuleTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n      },\n      transformNamedExport: function(tree) {\n        this.transformAny(tree.moduleSpecifier);\n        var exportClause = this.transformAny(tree.exportClause);\n        if (this.curDepIndex_ === null) {\n          return exportClause;\n        }\n        return new AnonBlock(null, []);\n      },\n      transformImportDeclaration: function(tree) {\n        this.curDepIndex_ = this.getOrCreateDependencyIndex(tree.moduleSpecifier);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        if (!tree.importClause) {\n          return new AnonBlock(null, []);\n        }\n        var importClause = this.transformAny(tree.importClause);\n        if (tree.importClause.type === NAME_SPACE_IMPORT) {\n          var bindingIdentifier = tree.importClause.binding.binding;\n          var name = bindingIdentifier.getStringValue();\n          this.addModuleBinding(this.curDepIndex_, name);\n          return parseStatement($traceurRuntime.getTemplateObject([\"var \", \";\"]), bindingIdentifier);\n        }\n        if (tree.importClause.type === IMPORT_SPECIFIER_SET) {\n          return importClause;\n        }\n        var bindingName = tree.importClause.binding.getStringValue();\n        this.addImportBinding(this.curDepIndex_, bindingName, 'default');\n        return parseStatement($traceurRuntime.getTemplateObject([\"var \", \";\"]), bindingName);\n      },\n      transformImportSpecifierSet: function(tree) {\n        return createVariableStatement(createVariableDeclarationList(VAR, this.transformList(tree.specifiers)));\n      },\n      transformExportDefault: function(tree) {\n        this.inExport_ = false;\n        var expression = this.transformAny(tree.expression);\n        this.addLocalExportBinding('default');\n        if (expression.type === CLASS_DECLARATION) {\n          expression = new ClassExpression(expression.location, expression.name, expression.superClass, expression.elements, expression.annotations, expression.typeParameters);\n        }\n        if (expression.type === FUNCTION_DECLARATION) {\n          this.addExportFunction('default', expression.name.identifierToken.value);\n          return expression;\n        } else {\n          return parseStatement($traceurRuntime.getTemplateObject([\"$__export('default', \", \");\"]), expression);\n        }\n      },\n      transformExportSpecifier: function(tree) {\n        var exportName;\n        var bindingName;\n        if (tree.rhs) {\n          exportName = tree.rhs.value;\n          bindingName = tree.lhs.value;\n        } else {\n          exportName = tree.lhs.value;\n          bindingName = exportName;\n        }\n        if (this.curDepIndex_ !== null) {\n          this.addExternalExportBinding(this.curDepIndex_, exportName, bindingName);\n        } else {\n          this.addLocalExportBinding(exportName, bindingName);\n          return parseExpression($traceurRuntime.getTemplateObject([\"$__export(\", \", \", \");\"]), exportName, id(bindingName));\n        }\n      },\n      transformExportSpecifierSet: function(tree) {\n        var specifiers = this.transformList(tree.specifiers);\n        return new ExpressionStatement(tree.location, new CommaExpression(tree.location, specifiers.filter(function(specifier) {\n          return specifier;\n        })));\n      },\n      transformNameSpaceExport: function(tree) {\n        this.addExternalExportBinding(this.curDepIndex_, tree.name.value, null);\n        return tree;\n      },\n      transformForwardDefaultExport: function(tree) {\n        this.addExternalExportBinding(this.curDepIndex_, tree.name.value, 'default');\n        return tree;\n      },\n      transformImportSpecifier: function(tree) {\n        var localBinding = tree.binding.binding;\n        var localBindingToken = localBinding.identifierToken;\n        var importName = (tree.name || localBindingToken).value;\n        this.addImportBinding(this.curDepIndex_, localBindingToken.value, importName);\n        return new VariableDeclaration(tree.location, localBinding, null, null);\n      },\n      transformModuleSpecifier: function(tree) {\n        this.curDepIndex_ = this.getOrCreateDependencyIndex(tree);\n        return tree;\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InstantiateModuleTransformer() {\n      return InstantiateModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\";\n  var SPREAD_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\")).SPREAD_EXPRESSION;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\")),\n      createObjectLiteral = $__2.createObjectLiteral,\n      createArgumentList = $__2.createArgumentList;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\")).parseExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\")).default;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/SpreadPropertiesTransformer.js\")).ParseTreeTransformer;\n  function hasSpread(trees) {\n    return trees.some(function(tree) {\n      return tree && tree.type === SPREAD_EXPRESSION;\n    });\n  }\n  var SpreadPropertiesTransformer = function($__super) {\n    function SpreadPropertiesTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SpreadPropertiesTransformer).call(this, identifierGenerator, reporter, options);\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(SpreadPropertiesTransformer, {transformObjectLiteral: function(tree) {\n        if (!hasSpread(tree.propertyNameAndValues)) {\n          return $traceurRuntime.superGet(this, SpreadPropertiesTransformer.prototype, \"transformObjectLiteral\").call(this, tree);\n        }\n        var properties = this.transformList(tree.propertyNameAndValues);\n        return spreadProperties(properties, this);\n      }}, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  function spreadProperties(properties, self) {\n    var args = [];\n    var accummulatedProps = null;\n    for (var i = 0; i < properties.length; i++) {\n      var property = properties[i];\n      if (property.type === SPREAD_EXPRESSION) {\n        if (accummulatedProps) {\n          args.push(createObjectLiteral(accummulatedProps));\n          accummulatedProps = null;\n        }\n        args.push(property.expression);\n      } else {\n        if (!accummulatedProps) {\n          accummulatedProps = [];\n        }\n        accummulatedProps.push(property);\n      }\n    }\n    if (accummulatedProps) {\n      args.push(createObjectLiteral(accummulatedProps));\n    }\n    var runtime = self.getRuntimeExpression('spreadProperties');\n    return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), runtime, createArgumentList(args));\n  }\n  return {\n    get SpreadPropertiesTransformer() {\n      return SpreadPropertiesTransformer;\n    },\n    get spreadProperties() {\n      return spreadProperties;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/JsxTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")),\n      JSX_ELEMENT = $__4.JSX_ELEMENT,\n      JSX_PLACEHOLDER = $__4.JSX_PLACEHOLDER,\n      JSX_SPREAD_ATTRIBUTE = $__4.JSX_SPREAD_ATTRIBUTE,\n      JSX_TEXT = $__4.JSX_TEXT,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")),\n      JsxText = $__5.JsxText,\n      LiteralExpression = $__5.LiteralExpression,\n      LiteralPropertyName = $__5.LiteralPropertyName,\n      SpreadExpression = $__5.SpreadExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).LiteralToken;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).ParseTreeTransformer;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).STRING;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")),\n      createArgumentList = $__9.createArgumentList,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createIdentifierToken = $__9.createIdentifierToken,\n      createMemberExpression = $__9.createMemberExpression,\n      createNullLiteral = $__9.createNullLiteral,\n      createObjectLiteral = $__9.createObjectLiteral,\n      createPropertyNameAssignment = $__9.createPropertyNameAssignment,\n      createStringLiteral = $__9.createStringLiteral,\n      createStringLiteralToken = $__9.createStringLiteralToken,\n      createTrueLiteral = $__9.createTrueLiteral;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).parseExpression;\n  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SpreadPropertiesTransformer.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).spreadProperties;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/JsxTransformer.js\")).default;\n  var JsxTransformer = function($__super) {\n    function JsxTransformer(idGen, reporter, options) {\n      $traceurRuntime.superConstructor(JsxTransformer).call(this);\n      this.options = options;\n      this.jsxFunction_ = null;\n    }\n    return ($traceurRuntime.createClass)(JsxTransformer, {\n      getJsxFunction_: function() {\n        if (!this.jsxFunction_) {\n          var jsx = this.options.jsx;\n          if (typeof jsx === 'string') {\n            this.jsxFunction_ = parseExpression([jsx]);\n          } else {\n            this.jsxFunction_ = parseExpression($traceurRuntime.getTemplateObject([\"React.createElement\"]));\n          }\n        }\n        return this.jsxFunction_;\n      },\n      transformJsxElement: function(tree) {\n        var name = this.transformAny(tree.name);\n        var props = this.transformJsxAttributes_(tree);\n        var children = this.transformJsxChildren_(tree.children);\n        var args = createArgumentList($traceurRuntime.spread([name, props], children));\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), this.getJsxFunction_(), args);\n      },\n      transformJsxAttributes_: function(tree) {\n        var attrs = this.transformList(tree.attributes);\n        if (attrs.length === 0) {\n          return createNullLiteral();\n        }\n        if (tree.attributes.some(function(a) {\n          return a.type === JSX_SPREAD_ATTRIBUTE;\n        })) {\n          return spreadProperties(attrs, this);\n        }\n        return createObjectLiteral(attrs);\n      },\n      transformJsxElementName: function(tree) {\n        if (tree.names.length === 1) {\n          var value = tree.names[0].value;\n          if (value[0] === value[0].toUpperCase()) {\n            return createIdentifierExpression(value);\n            ;\n          }\n          return createStringLiteral(value);\n        }\n        var names = tree.names.map(jsxIdentifierToToken);\n        var operand = names[0];\n        if (operand.type === STRING) {\n          names[0] = new LiteralExpression(operand.location, operand);\n        }\n        return createMemberExpression.apply((void 0), $traceurRuntime.spread(names));\n      },\n      transformJsxAttribute: function(tree) {\n        var name = new LiteralPropertyName(tree.name.location, jsxIdentifierToToken(tree.name));\n        var value;\n        if (tree.value === null) {\n          value = createTrueLiteral();\n        } else if (tree.value.type === LITERAL_EXPRESSION) {\n          var literalToken = tree.value.literalToken;\n          var v = literalToken.value;\n          var location = literalToken.location;\n          var lit = new LiteralToken(STRING, normalizeAttributeValue(v), location);\n          value = new LiteralExpression(location, lit);\n        } else {\n          value = this.transformAny(tree.value);\n        }\n        return createPropertyNameAssignment(name, value);\n      },\n      transformJsxPlaceholder: function(tree) {\n        return this.transformAny(tree.expression);\n      },\n      transformJsxSpreadAttribute: function(tree) {\n        return new SpreadExpression(tree.location, this.transformAny(tree.expression));\n      },\n      transformJsxText: function(tree) {\n        return createStringLiteral(tree.value.value);\n      },\n      transformJsxChildren_: function(trees) {\n        var $__1 = this;\n        var rv = [];\n        trees.forEach(function(tree) {\n          var newTree;\n          switch (tree.type) {\n            case JSX_ELEMENT:\n              newTree = $__1.transformAny(tree);\n              break;\n            case JSX_PLACEHOLDER:\n              if (tree.expression === null) {\n                return;\n              }\n              newTree = $__1.transformAny(tree);\n              break;\n            case JSX_TEXT:\n              {\n                var s = tree.value.value;\n                s = s.replace(/\\t/g, ' ');\n                if (!/[\\n\\r]/.test(s)) {\n                  newTree = createStringLiteral(s);\n                } else {\n                  s = s.replace(/^[ \\t]*[\\n\\r]\\s*/, '');\n                  s = s.replace(/[ \\t]*[\\n\\r]\\s*$/, '');\n                  if (s === '') {\n                    return;\n                  }\n                  newTree = createStringLiteral(s);\n                }\n                break;\n              }\n          }\n          rv.push(newTree);\n        });\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  function jsxIdentifierToToken(token) {\n    var value = token.value;\n    if (value.indexOf('-') !== -1) {\n      return createStringLiteralToken(value);\n    }\n    return createIdentifierToken(value);\n  }\n  function normalizeAttributeValue(s) {\n    return JSON.stringify(s.slice(1, -1).replace(/\\n\\s+/g, ' '));\n  }\n  return {get JsxTransformer() {\n      return JsxTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\";\n  var Method = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\")).Method;\n  var SUPER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\")).SUPER_EXPRESSION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\")).ParseTreeTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\")),\n      createCommaExpression = $__4.createCommaExpression,\n      createExpressionStatement = $__4.createExpressionStatement,\n      createFunctionBody = $__4.createFunctionBody,\n      createParenExpression = $__4.createParenExpression,\n      createThisExpression = $__4.createThisExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableConstructorTransformer.js\")).prependStatements;\n  function transformConstructor(constructor, initExpression, superClass) {\n    if (superClass) {\n      var transformer = new SuperCallTransformer(initExpression);\n      return transformer.transformAny(constructor);\n    }\n    var statements = constructor.body.statements;\n    var initStatement = createExpressionStatement(initExpression);\n    statements = prependStatements(statements, initStatement);\n    return new Method(constructor.location, false, constructor.functionKind, constructor.name, constructor.parameterList, constructor.typeAnnotation, constructor.annotations, createFunctionBody(statements), constructor.debugName);\n  }\n  var SuperCallTransformer = function($__super) {\n    function SuperCallTransformer(expression) {\n      $traceurRuntime.superConstructor(SuperCallTransformer).call(this);\n      this.expression = expression;\n    }\n    return ($traceurRuntime.createClass)(SuperCallTransformer, {\n      transformCallExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          var thisExpression = createThisExpression();\n          return createParenExpression(createCommaExpression([tree, this.expression, thisExpression]));\n        }\n        return $traceurRuntime.superGet(this, SuperCallTransformer.prototype, \"transformCallExpression\").call(this, tree);\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get transformConstructor() {\n      return transformConstructor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\";\n  var CONSTRUCTOR = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).CONSTRUCTOR;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")),\n      AnonBlock = $__5.AnonBlock,\n      ClassDeclaration = $__5.ClassDeclaration,\n      ClassExpression = $__5.ClassExpression,\n      FormalParameterList = $__5.FormalParameterList,\n      IdentifierExpression = $__5.IdentifierExpression,\n      Method = $__5.Method,\n      ReturnStatement = $__5.ReturnStatement;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")),\n      GET_ACCESSOR = $__6.GET_ACCESSOR,\n      METHOD = $__6.METHOD,\n      PROPERTY_VARIABLE_DECLARATION = $__6.PROPERTY_VARIABLE_DECLARATION,\n      SET_ACCESSOR = $__6.SET_ACCESSOR;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).TempVarTransformer;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")),\n      createCommaExpression = $__8.createCommaExpression,\n      createFunctionBody = $__8.createFunctionBody,\n      createIdentifierToken = $__8.createIdentifierToken,\n      createImmediatelyInvokedFunctionExpression = $__8.createImmediatelyInvokedFunctionExpression,\n      createLiteralPropertyName = $__8.createLiteralPropertyName,\n      createRestParameter = $__8.createRestParameter;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")),\n      parsePropertyDefinition = $__9.parsePropertyDefinition,\n      parseStatement = $__9.parseStatement;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).parseExpression;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).prependStatements;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../staticsemantics/PropName.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).propName;\n  var transformConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MemberVariableConstructorTransformer.js\", \"traceur@0.0.111/src/codegeneration/MemberVariableTransformer.js\")).transformConstructor;\n  var MemberVariableTransformer = function($__super) {\n    function MemberVariableTransformer() {\n      $traceurRuntime.superConstructor(MemberVariableTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(MemberVariableTransformer, {\n      transformClassElements_: function(tree) {\n        var $__2 = this;\n        var elements = [];\n        var initInstanceVars = [],\n            initStaticVars = [];\n        var constructor;\n        var constructorIndex = 0;\n        tree.elements.forEach(function(tree) {\n          var initVars;\n          if (tree.isStatic) {\n            initVars = initStaticVars;\n          } else {\n            initVars = initInstanceVars;\n          }\n          switch (tree.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n              elements.push($__2.transformAny(tree));\n              break;\n            case METHOD:\n              if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {\n                constructor = tree;\n                constructorIndex = elements.length;\n              } else {\n                elements.push($__2.transformAny(tree));\n              }\n              break;\n            case PROPERTY_VARIABLE_DECLARATION:\n              tree = $__2.transformAny(tree);\n              if (tree.initializer !== null) {\n                initVars.push(tree);\n              }\n              break;\n            default:\n              throw new Error((\"Unexpected class element: \" + tree.type));\n          }\n        });\n        if (initInstanceVars.length > 0) {\n          var initExpression = getInstanceInitExpression(initInstanceVars);\n          if (!constructor) {\n            constructor = this.getDefaultConstructor_(tree);\n          }\n          constructor = transformConstructor(constructor, initExpression, tree.superClass);\n        }\n        if (constructor) {\n          elements.splice(constructorIndex, 0, constructor);\n        }\n        return {\n          elements: elements,\n          initStaticVars: initStaticVars\n        };\n      },\n      transformClassDeclaration: function(tree) {\n        var $__3 = this.transformClassElements_(tree),\n            elements = $__3.elements,\n            initStaticVars = $__3.initStaticVars;\n        var superClass = this.transformAny(tree.superClass);\n        var classDecl = new ClassDeclaration(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n        if (initStaticVars.length === 0) {\n          return classDecl;\n        }\n        var statements = createStaticInitializerStatements(tree.name.identifierToken, initStaticVars);\n        statements = prependStatements(statements, classDecl);\n        return new AnonBlock(null, statements);\n      },\n      transformClassExpression: function(tree) {\n        var $__3 = this.transformClassElements_(tree),\n            elements = $__3.elements,\n            initStaticVars = $__3.initStaticVars;\n        var superClass = this.transformAny(tree.superClass);\n        var classExpression = new ClassExpression(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n        if (initStaticVars.length === 0) {\n          return classExpression;\n        }\n        this.pushTempScope();\n        var id = this.getTempIdentifier();\n        var idToken = createIdentifierToken(id);\n        var idExpression = new IdentifierExpression(idToken.location, idToken);\n        var statements = $traceurRuntime.spread([parseStatement($traceurRuntime.getTemplateObject([\"let \", \" = \", \"\"]), id, classExpression)], createStaticInitializerStatements(idToken, initStaticVars), [new ReturnStatement(null, idExpression)]);\n        var body = createFunctionBody(statements);\n        this.popTempScope();\n        return createImmediatelyInvokedFunctionExpression(body);\n      },\n      getDefaultConstructor_: function(tree) {\n        if (tree.superClass) {\n          var param = createRestParameter(createIdentifierToken('args'));\n          var paramList = new FormalParameterList(null, [param]);\n          var body = createFunctionBody([parseStatement($traceurRuntime.getTemplateObject([\"super(...args)\"]))]);\n          var name = createLiteralPropertyName(CONSTRUCTOR);\n          return new Method(tree.location, false, null, name, paramList, null, [], body, null);\n        }\n        return parsePropertyDefinition($traceurRuntime.getTemplateObject([\"constructor() {}\"]));\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  function createStaticInitializerStatements(idToken, initStaticMemberVars) {\n    var className = new IdentifierExpression(idToken.location, idToken);\n    return initStaticMemberVars.map(function(mv) {\n      var propName = mv.name.literalToken.value;\n      return parseStatement($traceurRuntime.getTemplateObject([\"Object.defineProperty(\", \", \", \", {enumerable: true,\\n        configurable: true, value: \", \", writable: true})\"]), className, propName, mv.initializer);\n    });\n  }\n  function getInstanceInitExpression(initInstanceVars) {\n    var expressions = initInstanceVars.map(function(mv) {\n      var name = mv.name.literalToken;\n      return parseExpression($traceurRuntime.getTemplateObject([\"this.\", \" = \", \"\"]), name, mv.initializer);\n    });\n    return createCommaExpression(expressions);\n  }\n  return {get MemberVariableTransformer() {\n      return MemberVariableTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\";\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\")),\n      BLOCK = $__4.BLOCK,\n      CLASS_DECLARATION = $__4.CLASS_DECLARATION,\n      FUNCTION_DECLARATION = $__4.FUNCTION_DECLARATION,\n      IF_STATEMENT = $__4.IF_STATEMENT,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION,\n      POSTFIX_EXPRESSION = $__4.POSTFIX_EXPRESSION,\n      UNARY_EXPRESSION = $__4.UNARY_EXPRESSION;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\")).ParseTreeVisitor;\n  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\")),\n      AS = $__6.AS,\n      ASYNC = $__6.ASYNC,\n      AWAIT = $__6.AWAIT,\n      FROM = $__6.FROM,\n      GET = $__6.GET,\n      OF = $__6.OF,\n      ON = $__6.ON,\n      SET = $__6.SET,\n      TYPE = $__6.TYPE;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Scanner.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\")),\n      isIdentifierPart = $__7.isIdentifierPart,\n      isWhitespace = $__7.isWhitespace;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeWriter.js\")),\n      ARROW = $__8.ARROW,\n      AT = $__8.AT,\n      BACK_QUOTE = $__8.BACK_QUOTE,\n      BAR = $__8.BAR,\n      BREAK = $__8.BREAK,\n      CASE = $__8.CASE,\n      CATCH = $__8.CATCH,\n      CLASS = $__8.CLASS,\n      CLOSE_ANGLE = $__8.CLOSE_ANGLE,\n      CLOSE_CURLY = $__8.CLOSE_CURLY,\n      CLOSE_PAREN = $__8.CLOSE_PAREN,\n      CLOSE_SQUARE = $__8.CLOSE_SQUARE,\n      COLON = $__8.COLON,\n      COMMA = $__8.COMMA,\n      CONTINUE = $__8.CONTINUE,\n      DEBUGGER = $__8.DEBUGGER,\n      DEFAULT = $__8.DEFAULT,\n      DO = $__8.DO,\n      DOT_DOT_DOT = $__8.DOT_DOT_DOT,\n      ELSE = $__8.ELSE,\n      EQUAL = $__8.EQUAL,\n      EXPORT = $__8.EXPORT,\n      EXTENDS = $__8.EXTENDS,\n      FINALLY = $__8.FINALLY,\n      FOR = $__8.FOR,\n      FUNCTION = $__8.FUNCTION,\n      IF = $__8.IF,\n      IMPORT = $__8.IMPORT,\n      IN = $__8.IN,\n      INTERFACE = $__8.INTERFACE,\n      MINUS = $__8.MINUS,\n      MINUS_MINUS = $__8.MINUS_MINUS,\n      NEW = $__8.NEW,\n      NUMBER = $__8.NUMBER,\n      OPEN_ANGLE = $__8.OPEN_ANGLE,\n      OPEN_CURLY = $__8.OPEN_CURLY,\n      OPEN_PAREN = $__8.OPEN_PAREN,\n      OPEN_SQUARE = $__8.OPEN_SQUARE,\n      PERIOD = $__8.PERIOD,\n      PLUS = $__8.PLUS,\n      PLUS_PLUS = $__8.PLUS_PLUS,\n      QUESTION = $__8.QUESTION,\n      RETURN = $__8.RETURN,\n      SEMI_COLON = $__8.SEMI_COLON,\n      SLASH = $__8.SLASH,\n      STAR = $__8.STAR,\n      STATIC = $__8.STATIC,\n      SUPER = $__8.SUPER,\n      SWITCH = $__8.SWITCH,\n      THIS = $__8.THIS,\n      THROW = $__8.THROW,\n      TRY = $__8.TRY,\n      WHILE = $__8.WHILE,\n      WITH = $__8.WITH,\n      YIELD = $__8.YIELD;\n  var NEW_LINE = '\\n';\n  var LINE_LENGTH = 80;\n  var ParseTreeWriter = function($__super) {\n    function ParseTreeWriter() {\n      var $__3;\n      var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},\n          prettyPrint = ($__3 = $__2.prettyPrint) === void 0 ? true : $__3;\n      $traceurRuntime.superConstructor(ParseTreeWriter).call(this);\n      this.prettyPrint_ = prettyPrint;\n      this.result_ = '';\n      this.currentLine_ = '';\n      this.lastCode_ = -1;\n      this.indentDepth_ = 0;\n      this.currentParameterTypeAnnotation_ = null;\n    }\n    return ($traceurRuntime.createClass)(ParseTreeWriter, {\n      toString: function() {\n        if (this.currentLine_.length > 0) {\n          this.result_ += this.currentLine_;\n          this.currentLine_ = '';\n          this.lastCode_ = -1;\n        }\n        return this.result_;\n      },\n      visitAnnotation: function(tree) {\n        this.write_(AT);\n        this.visitAny(tree.name);\n        if (tree.args !== null) {\n          this.write_(OPEN_PAREN);\n          this.writeList_(tree.args.args, COMMA, false);\n          this.write_(CLOSE_PAREN);\n        }\n      },\n      visitArgumentList: function(tree) {\n        this.write_(OPEN_PAREN);\n        this.writeList_(tree.args, COMMA, false);\n        this.write_(CLOSE_PAREN);\n      },\n      visitArrayComprehension: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayLiteral: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeList_(tree.elements, COMMA, false);\n        if (tree.elements[tree.elements.length - 1] === null) {\n          this.write_(COMMA);\n          this.writeSpace_();\n        }\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayPattern: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeList_(tree.elements, COMMA, false);\n        if (tree.elements[tree.elements.length - 1] === null) {\n          this.write_(COMMA);\n          this.writeSpace_();\n        }\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrayType: function(tree) {\n        this.visitAny(tree.elementType);\n        this.write_(OPEN_SQUARE);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitArrowFunction: function(tree) {\n        if (tree.functionKind) {\n          this.writeToken_(tree.functionKind);\n          this.writeSpace_();\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.write_(ARROW);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitAssignmentElement: function(tree) {\n        this.visitAny(tree.assignment);\n        if (tree.initializer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitAwaitExpression: function(tree) {\n        this.write_(AWAIT);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n      },\n      visitBinaryExpression: function(tree) {\n        var left = tree.left;\n        this.visitAny(left);\n        var operator = tree.operator;\n        if (left.type === POSTFIX_EXPRESSION && requiresSpaceBetween(left.operator.type, operator.type)) {\n          this.writeRequiredSpace_();\n        } else {\n          this.writeSpace_();\n        }\n        this.writeToken_(operator);\n        var right = tree.right;\n        if (right.type === UNARY_EXPRESSION && requiresSpaceBetween(operator.type, right.operator.type)) {\n          this.writeRequiredSpace_();\n        } else {\n          this.writeSpace_();\n        }\n        this.visitAny(right);\n      },\n      visitBindingElement: function(tree) {\n        var typeAnnotation = this.currentParameterTypeAnnotation_;\n        this.currentParameterTypeAnnotation_ = null;\n        this.visitAny(tree.binding);\n        this.writeTypeAnnotation_(typeAnnotation);\n        if (tree.initializer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitBindingIdentifier: function(tree) {\n        this.writeToken_(tree.identifierToken);\n      },\n      visitBlock: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.statements, null);\n        this.writeCloseCurly_();\n      },\n      visitBreakStatement: function(tree) {\n        this.write_(BREAK);\n        if (tree.name !== null) {\n          this.writeSpace_();\n          this.writeToken_(tree.name);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitCallExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCallSignature: function(tree) {\n        if (tree.typeParameters) {\n          this.visitAny(tree.typeParameters);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeTypeAnnotation_(tree.returnType);\n      },\n      visitCaseClause: function(tree) {\n        this.write_(CASE);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n        this.write_(COLON);\n        this.indentDepth_++;\n        this.writelnList_(tree.statements, null);\n        this.indentDepth_--;\n      },\n      visitCatch: function(tree) {\n        this.write_(CATCH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.binding);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.catchBody);\n      },\n      visitClassShared_: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        this.write_(CLASS);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        if (tree.typeParameters !== null) {\n          this.visitAny(tree.typeParameters);\n        }\n        if (tree.superClass !== null) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.visitAny(tree.superClass);\n        }\n        this.writeSpace_();\n        this.writeOpenCurly_();\n        this.writelnList_(tree.elements, null);\n        this.writeCloseCurly_();\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassExpression: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitCommaExpression: function(tree) {\n        this.writeList_(tree.expressions, COMMA, false);\n      },\n      visitComprehensionFor: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.left);\n        this.writeSpace_();\n        this.write_(OF);\n        this.writeSpace_();\n        this.visitAny(tree.iterator);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n      },\n      visitComprehensionIf: function(tree) {\n        this.write_(IF);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n      },\n      visitComputedPropertyName: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitConstructSignature: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitCallSignature(tree);\n      },\n      visitConstructorType: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitFunctionType(tree);\n      },\n      visitConditionalExpression: function(tree) {\n        this.visitAny(tree.condition);\n        this.writeSpace_();\n        this.write_(QUESTION);\n        this.writeSpace_();\n        this.visitAny(tree.left);\n        this.writeSpace_();\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.right);\n      },\n      visitContinueStatement: function(tree) {\n        this.write_(CONTINUE);\n        if (tree.name !== null) {\n          this.writeSpace_();\n          this.writeToken_(tree.name);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitCoverInitializedName: function(tree) {\n        this.writeToken_(tree.name);\n        this.writeSpace_();\n        this.writeToken_(tree.equalToken);\n        this.writeSpace_();\n        this.visitAny(tree.initializer);\n      },\n      visitDebuggerStatement: function(tree) {\n        this.write_(DEBUGGER);\n        this.write_(SEMI_COLON);\n      },\n      visitDefaultClause: function(tree) {\n        this.write_(DEFAULT);\n        this.write_(COLON);\n        this.indentDepth_++;\n        this.writelnList_(tree.statements, null);\n        this.indentDepth_--;\n      },\n      visitDoWhileStatement: function(tree) {\n        this.write_(DO);\n        this.visitAnyBlockOrIndent_(tree.body);\n        this.writeSpace_();\n        this.write_(WHILE);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.write_(SEMI_COLON);\n      },\n      visitEmptyStatement: function(tree) {\n        this.write_(SEMI_COLON);\n      },\n      visitExportDeclaration: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        this.write_(EXPORT);\n        this.writeSpace_();\n        this.visitAny(tree.declaration);\n      },\n      visitExportDefault: function(tree) {\n        this.write_(DEFAULT);\n        this.writeSpace_();\n        this.visitAny(tree.expression);\n        switch (tree.expression.type) {\n          case CLASS_DECLARATION:\n          case FUNCTION_DECLARATION:\n            break;\n          default:\n            this.write_(SEMI_COLON);\n        }\n      },\n      visitNameSpaceExport: function(tree) {\n        this.write_(STAR);\n        this.writeSpace_();\n        this.write_(AS);\n        this.writeSpace_();\n        this.writeToken_(tree.name);\n      },\n      visitNameSpaceImport: function(tree) {\n        this.write_(STAR);\n        this.writeSpace_();\n        this.write_(AS);\n        this.writeSpace_();\n        this.visitAny(tree.binding);\n      },\n      visitNamedExport: function(tree) {\n        this.visitAny(tree.exportClause);\n        if (tree.moduleSpecifier) {\n          this.writeSpace_();\n          this.write_(FROM);\n          this.writeSpace_();\n          this.visitAny(tree.moduleSpecifier);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitExportSpecifier: function(tree) {\n        this.writeToken_(tree.lhs);\n        if (tree.rhs) {\n          this.writeSpace_();\n          this.write_(AS);\n          this.writeSpace_();\n          this.writeToken_(tree.rhs);\n        }\n      },\n      visitExportSpecifierSet: function(tree) {\n        this.writeOpenCurly_();\n        this.writeList_(tree.specifiers, COMMA, false);\n        this.writeCloseCurly_();\n      },\n      visitExportStar: function(tree) {\n        this.write_(STAR);\n      },\n      visitExpressionStatement: function(tree) {\n        this.visitAny(tree.expression);\n        this.write_(SEMI_COLON);\n      },\n      visitFinally: function(tree) {\n        this.write_(FINALLY);\n        this.writeSpace_();\n        this.visitAny(tree.block);\n      },\n      visitForOfStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(OF);\n        this.writeSpace_();\n        this.visitAny(tree.collection);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForOnStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(ON);\n        this.writeSpace_();\n        this.visitAny(tree.observable);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForInStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.writeSpace_();\n        this.write_(IN);\n        this.writeSpace_();\n        this.visitAny(tree.collection);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitForStatement: function(tree) {\n        this.write_(FOR);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.initializer);\n        this.write_(SEMI_COLON);\n        this.writeSpace_();\n        this.visitAny(tree.condition);\n        this.write_(SEMI_COLON);\n        this.writeSpace_();\n        this.visitAny(tree.increment);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitFormalParameterList: function(tree) {\n        var first = true;\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var parameter = tree.parameters[i];\n          if (first) {\n            first = false;\n          } else {\n            this.write_(COMMA);\n            this.writeSpace_();\n          }\n          this.visitAny(parameter);\n        }\n      },\n      visitFormalParameter: function(tree) {\n        this.writeAnnotations_(tree.annotations, false);\n        this.currentParameterTypeAnnotation_ = tree.typeAnnotation;\n        this.visitAny(tree.parameter);\n        this.currentParameterTypeAnnotation_ = null;\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.writeToken_(tree.name);\n      },\n      visitFunctionBody: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.statements, null);\n        this.writeCloseCurly_();\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isAsyncGenerator()) {\n          this.write_(ASYNC);\n        }\n        if (tree.isAsyncFunction())\n          this.writeToken_(tree.functionKind);\n        this.write_(FUNCTION);\n        if (tree.isAsyncGenerator()) {\n          this.write_(STAR);\n        }\n        if (tree.isGenerator())\n          this.writeToken_(tree.functionKind);\n        if (tree.name) {\n          this.writeSpace_();\n          this.visitAny(tree.name);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitFunctionType: function(tree) {\n        if (tree.typeParameters !== null) {\n          this.visitAny(tree.typeParameters);\n        }\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.write_(ARROW);\n        this.writeSpace_();\n        this.visitAny(tree.returnType);\n      },\n      visitGeneratorComprehension: function(tree) {\n        this.write_(OPEN_PAREN);\n        this.visitList(tree.comprehensionList);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n      },\n      visitGetAccessor: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.write_(GET);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.visitAny(tree.body);\n      },\n      visitIdentifierExpression: function(tree) {\n        this.writeToken_(tree.identifierToken);\n      },\n      visitIfStatement: function(tree) {\n        this.write_(IF);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.ifClause);\n        if (tree.elseClause) {\n          if (tree.ifClause.type === BLOCK)\n            this.writeSpace_();\n          this.write_(ELSE);\n          if (tree.elseClause.type === IF_STATEMENT) {\n            this.writeSpace_();\n            this.visitAny(tree.elseClause);\n          } else {\n            this.visitAnyBlockOrIndent_(tree.elseClause);\n          }\n        }\n      },\n      visitIndexSignature: function(tree) {\n        this.write_(OPEN_SQUARE);\n        this.writeToken_(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.indexType);\n        this.write_(CLOSE_SQUARE);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.write_(SEMI_COLON);\n      },\n      visitInterfaceDeclaration: function(tree) {\n        this.write_(INTERFACE);\n        this.writeSpace_();\n        this.writeToken_(tree.name);\n        if (tree.typeParameters) {\n          this.visitAny(tree.typeParameters);\n        }\n        if (tree.extendsClause.length > 0) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.writeList_(tree.extendsClause, COMMA, false);\n        }\n        this.writeSpace_();\n        this.visitAny(tree.objectType);\n      },\n      visitAnyBlockOrIndent_: function(tree) {\n        if (tree.type === BLOCK) {\n          this.writeSpace_();\n          this.visitAny(tree);\n        } else {\n          this.visitAnyIndented_(tree);\n        }\n      },\n      visitAnyIndented_: function(tree) {\n        var indent = arguments[1] !== (void 0) ? arguments[1] : 1;\n        if (this.prettyPrint_) {\n          this.indentDepth_ += indent;\n          this.writeln_();\n        }\n        this.visitAny(tree);\n        if (this.prettyPrint_) {\n          this.indentDepth_ -= indent;\n          this.writeln_();\n        }\n      },\n      visitImportClausePair: function(tree) {\n        this.visitAny(tree.first);\n        this.write_(COMMA);\n        this.writeSpace_();\n        this.visitAny(tree.second);\n      },\n      visitImportDeclaration: function(tree) {\n        this.write_(IMPORT);\n        this.writeSpace_();\n        if (tree.importClause) {\n          this.visitAny(tree.importClause);\n          this.writeSpace_();\n          this.write_(FROM);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.moduleSpecifier);\n        this.write_(SEMI_COLON);\n      },\n      visitImportSpecifier: function(tree) {\n        if (tree.name) {\n          this.writeToken_(tree.name);\n          this.writeSpace_();\n          this.write_(AS);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.binding);\n      },\n      visitImportSpecifierSet: function(tree) {\n        if (tree.specifiers.type === STAR) {\n          this.write_(STAR);\n        } else {\n          this.writeOpenCurly_();\n          this.writelnList_(tree.specifiers, COMMA);\n          this.writeCloseCurly_();\n        }\n      },\n      visitImportTypeClause: function(tree) {\n        this.write_(TYPE);\n        this.writeSpace_();\n        this.visitAny(tree.clause);\n      },\n      visitJsxAttribute: function(tree) {\n        this.writeToken_(tree.name);\n        if (tree.value !== null) {\n          this.write_(EQUAL);\n          this.visitAny(tree.value);\n        }\n      },\n      visitJsxElement: function(tree) {\n        this.write_(OPEN_ANGLE);\n        this.visitAny(tree.name);\n        for (var i = 0; i < tree.attributes.length; i++) {\n          this.writeSpace_();\n          this.visitAny(tree.attributes[i]);\n        }\n        if (tree.children.length === 0) {\n          this.write_(SLASH);\n          this.write_(CLOSE_ANGLE);\n        } else {\n          this.write_(CLOSE_ANGLE);\n          this.visitList(tree.children);\n          this.write_(OPEN_ANGLE);\n          this.write_(SLASH);\n          this.lastCode_ = -1;\n          this.visitAny(tree.name);\n          this.write_(CLOSE_ANGLE);\n        }\n      },\n      visitJsxElementName: function(tree) {\n        for (var i = 0; i < tree.names.length; i++) {\n          if (i > 0) {\n            this.write_(PERIOD);\n          }\n          this.writeToken_(tree.names[i]);\n        }\n      },\n      visitJsxPlaceholder: function(tree) {\n        this.write_(OPEN_CURLY);\n        if (tree.expression !== null) {\n          this.visitAny(tree.expression);\n        }\n        this.write_(CLOSE_CURLY);\n      },\n      visitJsxSpreadAttribute: function(tree) {\n        this.write_(OPEN_CURLY);\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_CURLY);\n      },\n      visitJsxText: function(tree) {\n        this.writeToken_(tree.value);\n      },\n      visitLabelledStatement: function(tree) {\n        this.writeToken_(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.statement);\n      },\n      visitLiteralExpression: function(tree) {\n        this.writeToken_(tree.literalToken);\n      },\n      visitLiteralPropertyName: function(tree) {\n        this.writeToken_(tree.literalToken);\n      },\n      visitMemberExpression: function(tree) {\n        this.visitAny(tree.operand);\n        if (tree.operand.type === LITERAL_EXPRESSION && tree.operand.literalToken.type === NUMBER) {\n          if (!/\\.|e|E/.test(tree.operand.literalToken.value))\n            this.writeRequiredSpace_();\n        }\n        this.write_(PERIOD);\n        this.writeToken_(tree.memberName);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.visitAny(tree.operand);\n        this.write_(OPEN_SQUARE);\n        this.visitAny(tree.memberExpression);\n        this.write_(CLOSE_SQUARE);\n      },\n      visitMethodSignature: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.optional) {\n          this.write_(QUESTION);\n        }\n        this.visitAny(tree.callSignature);\n        this.write_(SEMI_COLON);\n      },\n      visitSyntaxErrorTree: function(tree) {\n        this.write_('(function() {' + (\"throw SyntaxError(\" + JSON.stringify(tree.message) + \");\") + '})()');\n      },\n      visitModule: function(tree) {\n        this.writelnList_(tree.scriptItemList, null);\n      },\n      visitModuleSpecifier: function(tree) {\n        this.writeToken_(tree.token);\n      },\n      visitNewExpression: function(tree) {\n        this.write_(NEW);\n        this.writeSpace_();\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        this.writeOpenCurly_();\n        if (tree.propertyNameAndValues.length > 1)\n          this.writeln_();\n        this.writelnList_(tree.propertyNameAndValues, COMMA);\n        if (tree.propertyNameAndValues.length > 1)\n          this.writeln_();\n        this.writeCloseCurly_();\n      },\n      visitObjectPattern: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.fields, COMMA);\n        this.writeCloseCurly_();\n      },\n      visitObjectPatternField: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.element !== null) {\n          this.write_(COLON);\n          this.writeSpace_();\n          this.visitAny(tree.element);\n        }\n      },\n      visitObjectType: function(tree) {\n        this.writeOpenCurly_();\n        this.writelnList_(tree.typeMembers, null);\n        this.writeCloseCurly_();\n      },\n      visitParenExpression: function(tree) {\n        this.write_(OPEN_PAREN);\n        $traceurRuntime.superGet(this, ParseTreeWriter.prototype, \"visitParenExpression\").call(this, tree);\n        this.write_(CLOSE_PAREN);\n      },\n      visitPostfixExpression: function(tree) {\n        this.visitAny(tree.operand);\n        if (tree.operand.type === POSTFIX_EXPRESSION && tree.operand.operator.type === tree.operator.type) {\n          this.writeRequiredSpace_();\n        }\n        this.writeToken_(tree.operator);\n      },\n      visitPredefinedType: function(tree) {\n        this.writeToken_(tree.typeToken);\n      },\n      visitScript: function(tree) {\n        this.writelnList_(tree.scriptItemList, null);\n      },\n      visitMethod: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        if (tree.isAsyncFunction() || tree.isAsyncGenerator())\n          this.write_(ASYNC);\n        if (tree.isGenerator() || tree.isAsyncGenerator())\n          this.write_(STAR);\n        if (tree.isAsyncGenerator())\n          this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.visitAny(tree.body);\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.visitAny(tree.name);\n        this.write_(COLON);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n      },\n      visitPropertyNameShorthand: function(tree) {\n        this.writeToken_(tree.name);\n      },\n      visitPropertyVariableDeclaration: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.visitAny(tree.name);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        if (tree.initalizer) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitPropertySignature: function(tree) {\n        this.visitAny(tree.name);\n        if (tree.optional) {\n          this.write_(QUESTION);\n        }\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        this.write_(SEMI_COLON);\n      },\n      visitTemplateLiteralExpression: function(tree) {\n        if (tree.operand) {\n          this.visitAny(tree.operand);\n          this.writeSpace_();\n        }\n        this.writeRaw_(BACK_QUOTE);\n        this.visitList(tree.elements);\n        this.writeRaw_(BACK_QUOTE);\n      },\n      visitTemplateLiteralPortion: function(tree) {\n        this.writeToken_(tree.value);\n      },\n      visitTemplateSubstitution: function(tree) {\n        this.writeRaw_('$');\n        this.writeRaw_(OPEN_CURLY);\n        this.visitAny(tree.expression);\n        this.writeRaw_(CLOSE_CURLY);\n      },\n      visitReturnStatement: function(tree) {\n        this.write_(RETURN);\n        if (tree.expression) {\n          this.writeSpace_(tree.expression);\n          this.visitAny(tree.expression);\n        }\n        this.write_(SEMI_COLON);\n      },\n      visitRestParameter: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.identifier);\n      },\n      visitSetAccessor: function(tree) {\n        this.writeAnnotations_(tree.annotations);\n        if (tree.isStatic) {\n          this.write_(STATIC);\n          this.writeSpace_();\n        }\n        this.write_(SET);\n        this.writeSpace_();\n        this.visitAny(tree.name);\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.parameterList);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitSpreadExpression: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.expression);\n      },\n      visitSpreadPatternElement: function(tree) {\n        this.write_(DOT_DOT_DOT);\n        this.visitAny(tree.lvalue);\n      },\n      visitStateMachine: function(tree) {\n        throw new Error('State machines cannot be converted to source');\n      },\n      visitSuperExpression: function(tree) {\n        this.write_(SUPER);\n      },\n      visitSwitchStatement: function(tree) {\n        this.write_(SWITCH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.writeOpenCurly_();\n        this.writelnList_(tree.caseClauses, null);\n        this.writeCloseCurly_();\n      },\n      visitThisExpression: function(tree) {\n        this.write_(THIS);\n      },\n      visitThrowStatement: function(tree) {\n        this.write_(THROW);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n        this.write_(SEMI_COLON);\n      },\n      visitTryStatement: function(tree) {\n        this.write_(TRY);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n        if (tree.catchBlock) {\n          this.writeSpace_();\n          this.visitAny(tree.catchBlock);\n        }\n        if (tree.finallyBlock) {\n          this.writeSpace_();\n          this.visitAny(tree.finallyBlock);\n        }\n      },\n      visitTypeAliasDeclaration: function(tree) {\n        this.write_(TYPE);\n        this.writeRequiredSpace_();\n        this.writeToken_(tree.name);\n        this.writeSpace_();\n        this.write_(EQUAL);\n        this.writeSpace_();\n        this.visitAny(tree.value);\n        this.write_(SEMI_COLON);\n      },\n      visitTypeArguments: function(tree) {\n        this.write_(OPEN_ANGLE);\n        var args = tree.args;\n        this.visitAny(args[0]);\n        for (var i = 1; i < args.length; i++) {\n          this.write_(COMMA);\n          this.writeSpace_();\n          this.visitAny(args[i]);\n        }\n        this.write_(CLOSE_ANGLE);\n      },\n      visitTypeName: function(tree) {\n        if (tree.moduleName) {\n          this.visitAny(tree.moduleName);\n          this.write_(PERIOD);\n        }\n        this.writeToken_(tree.name);\n      },\n      visitTypeParameter: function(tree) {\n        this.writeToken_(tree.identifierToken);\n        if (tree.extendsType) {\n          this.writeSpace_();\n          this.write_(EXTENDS);\n          this.writeSpace_();\n          this.visitAny(tree.extendsType);\n        }\n      },\n      visitTypeParameters: function(tree) {\n        this.write_(OPEN_ANGLE);\n        this.writeList_(tree.parameters, COMMA, false);\n        this.write_(CLOSE_ANGLE);\n      },\n      visitUnaryExpression: function(tree) {\n        var op = tree.operator;\n        this.writeToken_(op);\n        var operand = tree.operand;\n        if (operand.type === UNARY_EXPRESSION && requiresSpaceBetween(op.type, operand.operator.type)) {\n          this.writeRequiredSpace_();\n        }\n        this.visitAny(operand);\n      },\n      visitUnionType: function(tree) {\n        this.visitAny(tree.types[0]);\n        for (var i = 1; i < tree.types.length; i++) {\n          this.writeSpace_();\n          this.write_(BAR);\n          this.writeSpace_();\n          this.visitAny(tree.types[i]);\n        }\n      },\n      visitVariableDeclarationList: function(tree) {\n        this.write_(tree.declarationType);\n        this.writeSpace_();\n        this.writeList_(tree.declarations, COMMA, true, 2);\n      },\n      visitVariableDeclaration: function(tree) {\n        this.visitAny(tree.lvalue);\n        this.writeTypeAnnotation_(tree.typeAnnotation);\n        if (tree.initializer !== null) {\n          this.writeSpace_();\n          this.write_(EQUAL);\n          this.writeSpace_();\n          this.visitAny(tree.initializer);\n        }\n      },\n      visitVariableStatement: function(tree) {\n        $traceurRuntime.superGet(this, ParseTreeWriter.prototype, \"visitVariableStatement\").call(this, tree);\n        this.write_(SEMI_COLON);\n      },\n      visitWhileStatement: function(tree) {\n        this.write_(WHILE);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.condition);\n        this.write_(CLOSE_PAREN);\n        this.visitAnyBlockOrIndent_(tree.body);\n      },\n      visitWithStatement: function(tree) {\n        this.write_(WITH);\n        this.writeSpace_();\n        this.write_(OPEN_PAREN);\n        this.visitAny(tree.expression);\n        this.write_(CLOSE_PAREN);\n        this.writeSpace_();\n        this.visitAny(tree.body);\n      },\n      visitYieldExpression: function(tree) {\n        this.write_(YIELD);\n        if (tree.isYieldFor)\n          this.write_(STAR);\n        if (tree.expression) {\n          this.writeSpace_();\n          this.visitAny(tree.expression);\n        }\n      },\n      writeCurrentln_: function() {\n        this.result_ += this.currentLine_ + NEW_LINE;\n      },\n      writeln_: function() {\n        if (this.currentLine_)\n          this.writeCurrentln_();\n        this.currentLine_ = '';\n        this.lastCode_ = -1;\n      },\n      writelnList_: function(list, delimiter) {\n        if (delimiter !== null) {\n          this.writeList_(list, delimiter, true);\n        } else {\n          if (list.length > 0)\n            this.writeln_();\n          this.writeList_(list, '', true);\n          if (list.length > 0)\n            this.writeln_();\n        }\n      },\n      writeList_: function(list, delimiter, writeNewLine) {\n        var indent = arguments[3] !== (void 0) ? arguments[3] : 0;\n        var first = true;\n        for (var i = 0; i < list.length; i++) {\n          if (first) {\n            first = false;\n          } else {\n            if (delimiter !== '') {\n              this.write_(delimiter);\n              if (!writeNewLine)\n                this.writeSpace_();\n            }\n            if (writeNewLine) {\n              if (i === 1)\n                this.indentDepth_ += indent;\n              this.writeln_();\n            }\n          }\n          this.visitAny(list[i]);\n        }\n        if (writeNewLine && list.length > 1)\n          this.indentDepth_ -= indent;\n      },\n      writeRaw_: function(value) {\n        this.currentLine_ += value;\n        this.lastCode_ = value.charCodeAt(value.length - 1);\n      },\n      writeToken_: function(token) {\n        this.write_(token.toString());\n      },\n      write_: function(value) {\n        if (this.prettyPrint_ && this.currentLine_.length === 0) {\n          for (var i = 0,\n              indent = this.indentDepth_; i < indent; i++) {\n            this.writeRaw_('  ');\n          }\n        }\n        if (this.needsSpace_(value)) {\n          this.writeRaw_(' ');\n        }\n        this.writeRaw_(value);\n      },\n      writeCloseCurly_: function() {\n        this.indentDepth_--;\n        this.write_(CLOSE_CURLY);\n      },\n      writeOpenCurly_: function() {\n        this.write_(OPEN_CURLY);\n        this.indentDepth_++;\n      },\n      writeSpace_: function() {\n        if (this.prettyPrint_ && !isWhitespace(this.lastCode_)) {\n          this.writeRaw_(' ');\n        }\n      },\n      writeRequiredSpace_: function() {\n        if (!isWhitespace(this.lastCode_)) {\n          this.writeRaw_(' ');\n        }\n      },\n      writeTypeAnnotation_: function(typeAnnotation) {\n        if (typeAnnotation !== null) {\n          this.write_(COLON);\n          this.writeSpace_();\n          this.visitAny(typeAnnotation);\n        }\n      },\n      writeAnnotations_: function(annotations) {\n        var writeNewLine = arguments[1] !== (void 0) ? arguments[1] : this.prettyPrint_;\n        if (annotations.length > 0) {\n          this.writeList_(annotations, '', writeNewLine);\n          if (writeNewLine)\n            this.writeln_();\n        }\n      },\n      needsSpace_: function(token) {\n        var lastCode = this.lastCode_;\n        if (isWhitespace(lastCode))\n          return false;\n        var firstCode = token.toString().charCodeAt(0);\n        return isIdentifierPart(firstCode) && (isIdentifierPart(lastCode) || lastCode === 47);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  function requiresSpaceBetween(first, second) {\n    return (first === MINUS || first === MINUS_MINUS) && (second === MINUS || second === MINUS_MINUS) || (first === PLUS || first === PLUS_PLUS) && (second === PLUS || second === PLUS_PLUS);\n  }\n  return {get ParseTreeWriter() {\n      return ParseTreeWriter;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js\";\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeWriter.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js\")).ParseTreeWriter;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringSet.js\", \"traceur@0.0.111/src/outputgeneration/ParseTreeMapWriter.js\")).StringSet;\n  var ParseTreeMapWriter = function($__super) {\n    function ParseTreeMapWriter(sourceMapConfiguration) {\n      var options = arguments[1];\n      $traceurRuntime.superConstructor(ParseTreeMapWriter).call(this, options);\n      this.sourceMapGenerator_ = sourceMapConfiguration.sourceMapGenerator;\n      this.lowResolution_ = sourceMapConfiguration.lowResolution;\n      this.basepath_ = sourceMapConfiguration.basepath;\n      this.outputLineCount_ = 1;\n      this.isFirstMapping_ = true;\n      this.sourcesInMap_ = new StringSet();\n      this.relativeSourceName_ = '';\n      this.generated_ = null;\n      this.original_ = null;\n      this.previousMapping_ = null;\n    }\n    return ($traceurRuntime.createClass)(ParseTreeMapWriter, {\n      visitAny: function(tree) {\n        if (tree === null) {\n          return;\n        }\n        if (tree.location !== null)\n          this.enterBranch(tree.location);\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, \"visitAny\").call(this, tree);\n        if (tree.location !== null)\n          this.exitBranch(tree.location);\n      },\n      writeCurrentln_: function() {\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, \"writeCurrentln_\").call(this);\n        this.flushMappings();\n        this.outputLineCount_++;\n        this.generated_ = {\n          line: this.outputLineCount_,\n          column: 0\n        };\n        this.flushMappings();\n      },\n      write_: function(value) {\n        this.generate();\n        $traceurRuntime.superGet(this, ParseTreeMapWriter.prototype, \"write_\").call(this, value);\n        this.generate();\n      },\n      generate: function() {\n        var length = this.currentLine_.length;\n        var column = length ? length - 1 : 0;\n        this.generated_ = {\n          line: this.outputLineCount_,\n          column: column\n        };\n        this.flushMappings();\n      },\n      enterBranch: function(location) {\n        var $__2 = location.start,\n            line = $__2.line,\n            column = $__2.column,\n            source = $__2.source;\n        this.originate(line, column, source);\n      },\n      exitBranch: function(location) {\n        var $__2 = location.end,\n            line = $__2.line,\n            column = $__2.column,\n            source = $__2.source;\n        this.originate(line, column ? column - 1 : 0, source);\n      },\n      originate: function(line, column, source) {\n        line++;\n        if (this.original_ && this.original_.line !== line)\n          this.flushMappings();\n        this.original_ = {\n          line: line,\n          column: column\n        };\n        var name = source.name;\n        if (name && !this.sourcesInMap_.has(name)) {\n          this.sourcesInMap_.add(name);\n          this.relativeSourceName_ = relativePath(name, this.basepath_);\n          this.sourceMapGenerator_.setSourceContent(this.relativeSourceName_, source.contents);\n        }\n        this.flushMappings();\n      },\n      flushMappings: function() {\n        if (this.original_ && this.generated_) {\n          this.addMapping();\n          this.original_ = null;\n          this.generated_ = null;\n        }\n      },\n      isSame: function(lhs, rhs) {\n        return lhs.line === rhs.line && lhs.column === rhs.column;\n      },\n      skipMapping: function() {\n        if (!this.previousMapping_)\n          return false;\n        if (this.lowResolution_ && this.previousMapping_.generated.line === this.generated_.line)\n          return true;\n        if (this.isSame(this.previousMapping_.generated, this.generated_) && this.isSame(this.previousMapping_.original, this.original_))\n          return true;\n      },\n      addMapping: function() {\n        if (this.skipMapping())\n          return;\n        var mapping = {\n          generated: this.generated_,\n          original: this.original_,\n          source: this.relativeSourceName_\n        };\n        this.sourceMapGenerator_.addMapping(mapping);\n        this.previousMapping_ = mapping;\n      }\n    }, {}, $__super);\n  }(ParseTreeWriter);\n  function relativePath(name, sourceRoot) {\n    var $__3;\n    if (!name || name[0] === '@')\n      return name;\n    if (!sourceRoot)\n      return name;\n    var nameSegments = name.split('/');\n    var rootSegments = sourceRoot.split('/');\n    if (rootSegments[rootSegments.length - 1]) {\n      throw new Error('rootPath must end in /');\n    }\n    var commonSegmentsLength = 0;\n    var uniqueSegments = [];\n    var foundUnique = false;\n    nameSegments.forEach(function(segment, index) {\n      if (!foundUnique && segment === rootSegments[index]) {\n        commonSegmentsLength++;\n        return;\n      }\n      foundUnique = true;\n      uniqueSegments.push(segment);\n    });\n    if (commonSegmentsLength < 1 || commonSegmentsLength === rootSegments.length)\n      return name;\n    var dotDotSegments = rootSegments.length - commonSegmentsLength - 1;\n    var segments = [];\n    while (dotDotSegments--) {\n      segments.push('..');\n    }\n    ($__3 = segments).push.apply($__3, $traceurRuntime.spread(uniqueSegments));\n    return segments.join('/');\n  }\n  return {\n    get ParseTreeMapWriter() {\n      return ParseTreeMapWriter;\n    },\n    get relativePath() {\n      return relativePath;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/SourceMapIntegration.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/SourceMapIntegration.js\";\n  function makeDefine(mapping, id) {\n    var require = function(id) {\n      return mapping[id];\n    };\n    var exports = mapping[id] = {};\n    var module = null;\n    return function(factory) {\n      factory(require, exports, module);\n    };\n  }\n  var define,\n      m = {};\n  define = makeDefine(m, './util');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    function getArg(aArgs, aName, aDefaultValue) {\n      if (aName in aArgs) {\n        return aArgs[aName];\n      } else if (arguments.length === 3) {\n        return aDefaultValue;\n      } else {\n        throw new Error('\"' + aName + '\" is a required argument.');\n      }\n    }\n    exports.getArg = getArg;\n    var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n    var dataUrlRegexp = /^data:.+\\,.+$/;\n    function urlParse(aUrl) {\n      var match = aUrl.match(urlRegexp);\n      if (!match) {\n        return null;\n      }\n      return {\n        scheme: match[1],\n        auth: match[2],\n        host: match[3],\n        port: match[4],\n        path: match[5]\n      };\n    }\n    exports.urlParse = urlParse;\n    function urlGenerate(aParsedUrl) {\n      var url = '';\n      if (aParsedUrl.scheme) {\n        url += aParsedUrl.scheme + ':';\n      }\n      url += '//';\n      if (aParsedUrl.auth) {\n        url += aParsedUrl.auth + '@';\n      }\n      if (aParsedUrl.host) {\n        url += aParsedUrl.host;\n      }\n      if (aParsedUrl.port) {\n        url += \":\" + aParsedUrl.port;\n      }\n      if (aParsedUrl.path) {\n        url += aParsedUrl.path;\n      }\n      return url;\n    }\n    exports.urlGenerate = urlGenerate;\n    function normalize(aPath) {\n      var path = aPath;\n      var url = urlParse(aPath);\n      if (url) {\n        if (!url.path) {\n          return aPath;\n        }\n        path = url.path;\n      }\n      var isAbsolute = (path.charAt(0) === '/');\n      var parts = path.split(/\\/+/);\n      for (var part = void 0,\n          up = 0,\n          i = parts.length - 1; i >= 0; i--) {\n        part = parts[i];\n        if (part === '.') {\n          parts.splice(i, 1);\n        } else if (part === '..') {\n          up++;\n        } else if (up > 0) {\n          if (part === '') {\n            parts.splice(i + 1, up);\n            up = 0;\n          } else {\n            parts.splice(i, 2);\n            up--;\n          }\n        }\n      }\n      path = parts.join('/');\n      if (path === '') {\n        path = isAbsolute ? '/' : '.';\n      }\n      if (url) {\n        url.path = path;\n        return urlGenerate(url);\n      }\n      return path;\n    }\n    exports.normalize = normalize;\n    function join(aRoot, aPath) {\n      if (aRoot === \"\") {\n        aRoot = \".\";\n      }\n      if (aPath === \"\") {\n        aPath = \".\";\n      }\n      var aPathUrl = urlParse(aPath);\n      var aRootUrl = urlParse(aRoot);\n      if (aRootUrl) {\n        aRoot = aRootUrl.path || '/';\n      }\n      if (aPathUrl && !aPathUrl.scheme) {\n        if (aRootUrl) {\n          aPathUrl.scheme = aRootUrl.scheme;\n        }\n        return urlGenerate(aPathUrl);\n      }\n      if (aPathUrl || aPath.match(dataUrlRegexp)) {\n        return aPath;\n      }\n      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n        aRootUrl.host = aPath;\n        return urlGenerate(aRootUrl);\n      }\n      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n      if (aRootUrl) {\n        aRootUrl.path = joined;\n        return urlGenerate(aRootUrl);\n      }\n      return joined;\n    }\n    exports.join = join;\n    function relative(aRoot, aPath) {\n      if (aRoot === \"\") {\n        aRoot = \".\";\n      }\n      aRoot = aRoot.replace(/\\/$/, '');\n      var url = urlParse(aRoot);\n      if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n        return aPath.slice(1);\n      }\n      return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n    }\n    exports.relative = relative;\n    function toSetString(aStr) {\n      return '$' + aStr;\n    }\n    exports.toSetString = toSetString;\n    function fromSetString(aStr) {\n      return aStr.substr(1);\n    }\n    exports.fromSetString = fromSetString;\n    function strcmp(aStr1, aStr2) {\n      var s1 = aStr1 || \"\";\n      var s2 = aStr2 || \"\";\n      return (s1 > s2) - (s1 < s2);\n    }\n    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n      var cmp;\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp || onlyCompareOriginal) {\n        return cmp;\n      }\n      cmp = strcmp(mappingA.name, mappingB.name);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp) {\n        return cmp;\n      }\n      return mappingA.generatedColumn - mappingB.generatedColumn;\n    }\n    ;\n    exports.compareByOriginalPositions = compareByOriginalPositions;\n    function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n      var cmp;\n      cmp = mappingA.generatedLine - mappingB.generatedLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n      if (cmp || onlyCompareGenerated) {\n        return cmp;\n      }\n      cmp = strcmp(mappingA.source, mappingB.source);\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalLine - mappingB.originalLine;\n      if (cmp) {\n        return cmp;\n      }\n      cmp = mappingA.originalColumn - mappingB.originalColumn;\n      if (cmp) {\n        return cmp;\n      }\n      return strcmp(mappingA.name, mappingB.name);\n    }\n    ;\n    exports.compareByGeneratedPositions = compareByGeneratedPositions;\n  });\n  define = makeDefine(m, './array-set');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require('./util');\n    function ArraySet() {\n      this._array = [];\n      this._set = {};\n    }\n    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n      var set = new ArraySet();\n      for (var i = 0,\n          len = aArray.length; i < len; i++) {\n        set.add(aArray[i], aAllowDuplicates);\n      }\n      return set;\n    };\n    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n      var isDuplicate = this.has(aStr);\n      var idx = this._array.length;\n      if (!isDuplicate || aAllowDuplicates) {\n        this._array.push(aStr);\n      }\n      if (!isDuplicate) {\n        this._set[util.toSetString(aStr)] = idx;\n      }\n    };\n    ArraySet.prototype.has = function ArraySet_has(aStr) {\n      return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));\n    };\n    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n      if (this.has(aStr)) {\n        return this._set[util.toSetString(aStr)];\n      }\n      throw new Error('\"' + aStr + '\" is not in the set.');\n    };\n    ArraySet.prototype.at = function ArraySet_at(aIdx) {\n      if (aIdx >= 0 && aIdx < this._array.length) {\n        return this._array[aIdx];\n      }\n      throw new Error('No element indexed by ' + aIdx);\n    };\n    ArraySet.prototype.toArray = function ArraySet_toArray() {\n      return this._array.slice();\n    };\n    exports.ArraySet = ArraySet;\n  });\n  define = makeDefine(m, './base64');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var charToIntMap = {};\n    var intToCharMap = {};\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function(ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n    exports.encode = function base64_encode(aNumber) {\n      if (aNumber in intToCharMap) {\n        return intToCharMap[aNumber];\n      }\n      throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n    };\n    exports.decode = function base64_decode(aChar) {\n      if (aChar in charToIntMap) {\n        return charToIntMap[aChar];\n      }\n      throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n    };\n  });\n  define = makeDefine(m, './base64-vlq');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var base64 = require('./base64');\n    var VLQ_BASE_SHIFT = 5;\n    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n    var VLQ_BASE_MASK = VLQ_BASE - 1;\n    var VLQ_CONTINUATION_BIT = VLQ_BASE;\n    function toVLQSigned(aValue) {\n      return aValue < 0 ? ((-aValue) << 1) + 1 : (aValue << 1) + 0;\n    }\n    function fromVLQSigned(aValue) {\n      var isNegative = (aValue & 1) === 1;\n      var shifted = aValue >> 1;\n      return isNegative ? -shifted : shifted;\n    }\n    exports.encode = function base64VLQ_encode(aValue) {\n      var encoded = \"\";\n      var digit;\n      var vlq = toVLQSigned(aValue);\n      do {\n        digit = vlq & VLQ_BASE_MASK;\n        vlq >>>= VLQ_BASE_SHIFT;\n        if (vlq > 0) {\n          digit |= VLQ_CONTINUATION_BIT;\n        }\n        encoded += base64.encode(digit);\n      } while (vlq > 0);\n      return encoded;\n    };\n    exports.decode = function base64VLQ_decode(aStr, aOutParam) {\n      var i = 0;\n      var strLen = aStr.length;\n      var result = 0;\n      var shift = 0;\n      var continuation,\n          digit;\n      do {\n        if (i >= strLen) {\n          throw new Error(\"Expected more digits in base 64 VLQ value.\");\n        }\n        digit = base64.decode(aStr.charAt(i++));\n        continuation = !!(digit & VLQ_CONTINUATION_BIT);\n        digit &= VLQ_BASE_MASK;\n        result = result + (digit << shift);\n        shift += VLQ_BASE_SHIFT;\n      } while (continuation);\n      aOutParam.value = fromVLQSigned(result);\n      aOutParam.rest = aStr.slice(i);\n    };\n  });\n  define = makeDefine(m, './binary-search');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n      var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n      var cmp = aCompare(aNeedle, aHaystack[mid], true);\n      if (cmp === 0) {\n        return mid;\n      } else if (cmp > 0) {\n        if (aHigh - mid > 1) {\n          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n        }\n        return mid;\n      } else {\n        if (mid - aLow > 1) {\n          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n        }\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n    exports.search = function search(aNeedle, aHaystack, aCompare) {\n      if (aHaystack.length === 0) {\n        return -1;\n      }\n      return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare);\n    };\n  });\n  define = makeDefine(m, './mapping-list');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require('./util');\n    function generatedPositionAfter(mappingA, mappingB) {\n      var lineA = mappingA.generatedLine;\n      var lineB = mappingB.generatedLine;\n      var columnA = mappingA.generatedColumn;\n      var columnB = mappingB.generatedColumn;\n      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositions(mappingA, mappingB) <= 0;\n    }\n    function MappingList() {\n      this._array = [];\n      this._sorted = true;\n      this._last = {\n        generatedLine: -1,\n        generatedColumn: 0\n      };\n    }\n    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n      this._array.forEach(aCallback, aThisArg);\n    };\n    MappingList.prototype.add = function MappingList_add(aMapping) {\n      var mapping;\n      if (generatedPositionAfter(this._last, aMapping)) {\n        this._last = aMapping;\n        this._array.push(aMapping);\n      } else {\n        this._sorted = false;\n        this._array.push(aMapping);\n      }\n    };\n    MappingList.prototype.toArray = function MappingList_toArray() {\n      if (!this._sorted) {\n        this._array.sort(util.compareByGeneratedPositions);\n        this._sorted = true;\n      }\n      return this._array;\n    };\n    exports.MappingList = MappingList;\n  });\n  define = makeDefine(m, './source-map-generator');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var base64VLQ = require('./base64-vlq');\n    var util = require('./util');\n    var ArraySet = require('./array-set').ArraySet;\n    var MappingList = require('./mapping-list').MappingList;\n    function SourceMapGenerator(aArgs) {\n      if (!aArgs) {\n        aArgs = {};\n      }\n      this._file = util.getArg(aArgs, 'file', null);\n      this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n      this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n      this._sources = new ArraySet();\n      this._names = new ArraySet();\n      this._mappings = new MappingList();\n      this._sourcesContents = null;\n    }\n    SourceMapGenerator.prototype._version = 3;\n    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function(mapping) {\n        var newMapping = {generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }};\n        if (mapping.source != null) {\n          newMapping.source = mapping.source;\n          if (sourceRoot != null) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n          if (mapping.name != null) {\n            newMapping.name = mapping.name;\n          }\n        }\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, 'generated');\n      var original = util.getArg(aArgs, 'original', null);\n      var source = util.getArg(aArgs, 'source', null);\n      var name = util.getArg(aArgs, 'name', null);\n      if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n      }\n      if (source != null && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n      if (name != null && !this._names.has(name)) {\n        this._names.add(name);\n      }\n      this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n      });\n    };\n    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n      }\n      if (aSourceContent != null) {\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else if (this._sourcesContents) {\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n      var sourceFile = aSourceFile;\n      if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n          throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n        }\n        sourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n      }\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n      this._mappings.unsortedForEach(function(mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          });\n          if (original.source != null) {\n            mapping.source = original.source;\n            if (aSourceMapPath != null) {\n              mapping.source = util.join(aSourceMapPath, mapping.source);\n            }\n            if (sourceRoot != null) {\n              mapping.source = util.relative(sourceRoot, mapping.source);\n            }\n            mapping.originalLine = original.line;\n            mapping.originalColumn = original.column;\n            if (original.name != null) {\n              mapping.name = original.name;\n            }\n          }\n        }\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n          newSources.add(source);\n        }\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n          newNames.add(name);\n        }\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aSourceMapPath != null) {\n            sourceFile = util.join(aSourceMapPath, sourceFile);\n          }\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n        return;\n      } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n        return;\n      } else {\n        throw new Error('Invalid mapping: ' + JSON.stringify({\n          generated: aGenerated,\n          source: aSource,\n          original: aOriginal,\n          name: aName\n        }));\n      }\n    };\n    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = '';\n      var mapping;\n      var mappings = this._mappings.toArray();\n      for (var i = 0,\n          len = mappings.length; i < len; i++) {\n        mapping = mappings[i];\n        if (mapping.generatedLine !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generatedLine !== previousGeneratedLine) {\n            result += ';';\n            previousGeneratedLine++;\n          }\n        } else {\n          if (i > 0) {\n            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {\n              continue;\n            }\n            result += ',';\n          }\n        }\n        result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n        if (mapping.source != null) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n          result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n          previousOriginalLine = mapping.originalLine - 1;\n          result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n          previousOriginalColumn = mapping.originalColumn;\n          if (mapping.name != null) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n      return result;\n    };\n    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n      return aSources.map(function(source) {\n        if (!this._sourcesContents) {\n          return null;\n        }\n        if (aSourceRoot != null) {\n          source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n      }, this);\n    };\n    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._file != null) {\n        map.file = this._file;\n      }\n      if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n      }\n      return map;\n    };\n    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n      return JSON.stringify(this);\n    };\n    exports.SourceMapGenerator = SourceMapGenerator;\n  });\n  define = makeDefine(m, './source-map-consumer');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var util = require('./util');\n    var binarySearch = require('./binary-search');\n    var ArraySet = require('./array-set').ArraySet;\n    var base64VLQ = require('./base64-vlq');\n    function SourceMapConsumer(aSourceMap) {\n      var sourceMap = aSourceMap;\n      if (typeof aSourceMap === 'string') {\n        sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n      }\n      var version = util.getArg(sourceMap, 'version');\n      var sources = util.getArg(sourceMap, 'sources');\n      var names = util.getArg(sourceMap, 'names', []);\n      var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n      var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n      var mappings = util.getArg(sourceMap, 'mappings');\n      var file = util.getArg(sourceMap, 'file', null);\n      if (version != this._version) {\n        throw new Error('Unsupported version: ' + version);\n      }\n      sources = sources.map(util.normalize);\n      this._names = ArraySet.fromArray(names, true);\n      this._sources = ArraySet.fromArray(sources, true);\n      this.sourceRoot = sourceRoot;\n      this.sourcesContent = sourcesContent;\n      this._mappings = mappings;\n      this.file = file;\n    }\n    SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(SourceMapConsumer.prototype);\n      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n      smc.file = aSourceMap._file;\n      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();\n      smc.__originalMappings = aSourceMap._mappings.toArray().slice().sort(util.compareByOriginalPositions);\n      return smc;\n    };\n    SourceMapConsumer.prototype._version = 3;\n    Object.defineProperty(SourceMapConsumer.prototype, 'sources', {get: function() {\n        return this._sources.toArray().map(function(s) {\n          return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n        }, this);\n      }});\n    SourceMapConsumer.prototype.__generatedMappings = null;\n    Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {get: function() {\n        if (!this.__generatedMappings) {\n          this.__generatedMappings = [];\n          this.__originalMappings = [];\n          this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__generatedMappings;\n      }});\n    SourceMapConsumer.prototype.__originalMappings = null;\n    Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {get: function() {\n        if (!this.__originalMappings) {\n          this.__generatedMappings = [];\n          this.__originalMappings = [];\n          this._parseMappings(this._mappings, this.sourceRoot);\n        }\n        return this.__originalMappings;\n      }});\n    SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n      var c = aStr.charAt(0);\n      return c === \";\" || c === \",\";\n    };\n    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var str = aStr;\n      var temp = {};\n      var mapping;\n      while (str.length > 0) {\n        if (str.charAt(0) === ';') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        } else if (str.charAt(0) === ',') {\n          str = str.slice(1);\n        } else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n          base64VLQ.decode(str, temp);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n            base64VLQ.decode(str, temp);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source, but no line and column');\n            }\n            base64VLQ.decode(str, temp);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source and line, but no column');\n            }\n            base64VLQ.decode(str, temp);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n              base64VLQ.decode(str, temp);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n          this.__generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            this.__originalMappings.push(mapping);\n          }\n        }\n      }\n      this.__generatedMappings.sort(util.compareByGeneratedPositions);\n      this.__originalMappings.sort(util.compareByOriginalPositions);\n    };\n    SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n      }\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n    SourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n      for (var index = 0; index < this._generatedMappings.length; ++index) {\n        var mapping = this._generatedMappings[index];\n        if (index + 1 < this._generatedMappings.length) {\n          var nextMapping = this._generatedMappings[index + 1];\n          if (mapping.generatedLine === nextMapping.generatedLine) {\n            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n            continue;\n          }\n        }\n        mapping.lastGeneratedColumn = Infinity;\n      }\n    };\n    SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n      var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositions);\n      if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, 'source', null);\n          if (source != null && this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, 'originalLine', null),\n            column: util.getArg(mapping, 'originalColumn', null),\n            name: util.getArg(mapping, 'name', null)\n          };\n        }\n      }\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n    SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n      if (this.sourceRoot != null) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n      var url;\n      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    };\n    SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n      var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    };\n    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: Infinity\n      };\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n      var mappings = [];\n      var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        while (mapping && mapping.originalLine === needle.originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n          mapping = this._originalMappings[--index];\n        }\n      }\n      return mappings.reverse();\n    };\n    SourceMapConsumer.GENERATED_ORDER = 1;\n    SourceMapConsumer.ORIGINAL_ORDER = 2;\n    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n      var mappings;\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          mappings = this._generatedMappings;\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          mappings = this._originalMappings;\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n      }\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function(mapping) {\n        var source = mapping.source;\n        if (source != null && sourceRoot != null) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n    exports.SourceMapConsumer = SourceMapConsumer;\n  });\n  define = makeDefine(m, './source-node');\n  if (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n  }\n  define(function(require, exports, module) {\n    var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n    var util = require('./util');\n    var REGEX_NEWLINE = /(\\r?\\n)/;\n    var NEWLINE_CODE = 10;\n    var isSourceNode = \"$$$isSourceNode$$$\";\n    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n      this.children = [];\n      this.sourceContents = {};\n      this.line = aLine == null ? null : aLine;\n      this.column = aColumn == null ? null : aColumn;\n      this.source = aSource == null ? null : aSource;\n      this.name = aName == null ? null : aName;\n      this[isSourceNode] = true;\n      if (aChunks != null)\n        this.add(aChunks);\n    }\n    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      var node = new SourceNode();\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        var newLine = remainingLines.shift() || \"\";\n        return lineContents + newLine;\n      };\n      var lastGeneratedLine = 1,\n          lastGeneratedColumn = 0;\n      var lastMapping = null;\n      aSourceMapConsumer.eachMapping(function(mapping) {\n        if (lastMapping !== null) {\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n          } else {\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            lastMapping = mapping;\n            return;\n          }\n        }\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        node.add(remainingLines.join(\"\"));\n      }\n      aSourceMapConsumer.sources.forEach(function(sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n      return node;\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n        }\n      }\n    };\n    SourceNode.prototype.add = function SourceNode_add(aChunk) {\n      if (Array.isArray(aChunk)) {\n        aChunk.forEach(function(chunk) {\n          this.add(chunk);\n        }, this);\n      } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        if (aChunk) {\n          this.children.push(aChunk);\n        }\n      } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n      }\n      return this;\n    };\n    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n      if (Array.isArray(aChunk)) {\n        for (var i = aChunk.length - 1; i >= 0; i--) {\n          this.prepend(aChunk[i]);\n        }\n      } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n        this.children.unshift(aChunk);\n      } else {\n        throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n      }\n      return this;\n    };\n    SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n      var chunk;\n      for (var i = 0,\n          len = this.children.length; i < len; i++) {\n        chunk = this.children[i];\n        if (chunk[isSourceNode]) {\n          chunk.walk(aFn);\n        } else {\n          if (chunk !== '') {\n            aFn(chunk, {\n              source: this.source,\n              line: this.line,\n              column: this.column,\n              name: this.name\n            });\n          }\n        }\n      }\n    };\n    SourceNode.prototype.join = function SourceNode_join(aSep) {\n      var newChildren;\n      var i;\n      var len = this.children.length;\n      if (len > 0) {\n        newChildren = [];\n        for (i = 0; i < len - 1; i++) {\n          newChildren.push(this.children[i]);\n          newChildren.push(aSep);\n        }\n        newChildren.push(this.children[i]);\n        this.children = newChildren;\n      }\n      return this;\n    };\n    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n      var lastChild = this.children[this.children.length - 1];\n      if (lastChild[isSourceNode]) {\n        lastChild.replaceRight(aPattern, aReplacement);\n      } else if (typeof lastChild === 'string') {\n        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n      } else {\n        this.children.push(''.replace(aPattern, aReplacement));\n      }\n      return this;\n    };\n    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0,\n          len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0,\n          len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n    SourceNode.prototype.toString = function SourceNode_toString() {\n      var str = \"\";\n      this.walk(function(chunk) {\n        str += chunk;\n      });\n      return str;\n    };\n    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n      var generated = {\n        code: \"\",\n        line: 1,\n        column: 0\n      };\n      var map = new SourceMapGenerator(aArgs);\n      var sourceMappingActive = false;\n      var lastOriginalSource = null;\n      var lastOriginalLine = null;\n      var lastOriginalColumn = null;\n      var lastOriginalName = null;\n      this.walk(function(chunk, original) {\n        generated.code += chunk;\n        if (original.source !== null && original.line !== null && original.column !== null) {\n          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n          lastOriginalSource = original.source;\n          lastOriginalLine = original.line;\n          lastOriginalColumn = original.column;\n          lastOriginalName = original.name;\n          sourceMappingActive = true;\n        } else if (sourceMappingActive) {\n          map.addMapping({generated: {\n              line: generated.line,\n              column: generated.column\n            }});\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        }\n        for (var idx = 0,\n            length = chunk.length; idx < length; idx++) {\n          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n            generated.line++;\n            generated.column = 0;\n            if (idx + 1 === length) {\n              lastOriginalSource = null;\n              sourceMappingActive = false;\n            } else if (sourceMappingActive) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n          } else {\n            generated.column++;\n          }\n        }\n      });\n      this.walkSourceContents(function(sourceFile, sourceContent) {\n        map.setSourceContent(sourceFile, sourceContent);\n      });\n      return {\n        code: generated.code,\n        map: map\n      };\n    };\n    exports.SourceNode = SourceNode;\n  });\n  var SourceMapGenerator = m['./source-map-generator'].SourceMapGenerator;\n  var SourceMapConsumer = m['./source-map-consumer'].SourceMapConsumer;\n  var SourceNode = m['./source-node'].SourceNode;\n  var join = m['./util'].join;\n  return {\n    get SourceMapGenerator() {\n      return SourceMapGenerator;\n    },\n    get SourceMapConsumer() {\n      return SourceMapConsumer;\n    },\n    get SourceNode() {\n      return SourceNode;\n    },\n    get join() {\n      return join;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/toSource.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/toSource.js\";\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeMapWriter.js\", \"traceur@0.0.111/src/outputgeneration/toSource.js\")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeWriter.js\", \"traceur@0.0.111/src/outputgeneration/toSource.js\")).ParseTreeWriter;\n  var SourceMapGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SourceMapIntegration.js\", \"traceur@0.0.111/src/outputgeneration/toSource.js\")).SourceMapGenerator;\n  function toSource(tree) {\n    var options = arguments[1];\n    var outputName = arguments[2] !== (void 0) ? arguments[2] : '<toSourceOutput>';\n    var sourceRoot = arguments[3];\n    var sourceMapGenerator = options && options.sourceMapGenerator;\n    var sourcemaps = options && options.sourceMaps;\n    if (!sourceMapGenerator && sourcemaps) {\n      sourceMapGenerator = new SourceMapGenerator({\n        file: outputName,\n        sourceRoot: sourceRoot,\n        skipValidation: true\n      });\n    }\n    var sourceMapConfiguration = {\n      sourceMapGenerator: sourceMapGenerator,\n      sourceRoot: sourceRoot,\n      lowResolution: options && options.lowResolutionSourceMap\n    };\n    var writer;\n    if (sourceMapGenerator)\n      writer = new ParseTreeMapWriter(sourceMapConfiguration, options);\n    else\n      writer = new ParseTreeWriter(options);\n    writer.visitAny(tree);\n    return [writer.toString(), sourceMapGenerator && sourceMapGenerator.toString()];\n  }\n  return {get toSource() {\n      return toSource;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/TreeWriter.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/TreeWriter.js\";\n  var toSource = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./toSource.js\", \"traceur@0.0.111/src/outputgeneration/TreeWriter.js\")).toSource;\n  function write(tree) {\n    var $__2,\n        $__3;\n    var options = arguments[1];\n    var outputName = arguments[2] !== (void 0) ? arguments[2] : '<TreeWriter-output>';\n    var sourceRoot = arguments[3];\n    var $__1 = toSource(tree, options, outputName, sourceRoot),\n        result = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),\n        sourceMap = ($__3 = $__2.next()).done ? void 0 : $__3.value;\n    if (sourceMap)\n      options.generatedSourceMap = sourceMap;\n    return result;\n  }\n  var TreeWriter = function() {\n    function TreeWriter() {}\n    return ($traceurRuntime.createClass)(TreeWriter, {}, {});\n  }();\n  TreeWriter.write = write;\n  return {\n    get write() {\n      return write;\n    },\n    get TreeWriter() {\n      return TreeWriter;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/syntax/ParseTreeValidator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\";\n  var NewExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")).NewExpression;\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeVisitor.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")).ParseTreeVisitor;\n  var TreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../outputgeneration/TreeWriter.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")).TreeWriter;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TokenType.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")),\n      AMPERSAND = $__7.AMPERSAND,\n      AMPERSAND_EQUAL = $__7.AMPERSAND_EQUAL,\n      AND = $__7.AND,\n      BAR = $__7.BAR,\n      BAR_EQUAL = $__7.BAR_EQUAL,\n      CARET = $__7.CARET,\n      CARET_EQUAL = $__7.CARET_EQUAL,\n      CLOSE_ANGLE = $__7.CLOSE_ANGLE,\n      EQUAL = $__7.EQUAL,\n      EQUAL_EQUAL = $__7.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__7.EQUAL_EQUAL_EQUAL,\n      GREATER_EQUAL = $__7.GREATER_EQUAL,\n      IDENTIFIER = $__7.IDENTIFIER,\n      IN = $__7.IN,\n      INSTANCEOF = $__7.INSTANCEOF,\n      LEFT_SHIFT = $__7.LEFT_SHIFT,\n      LEFT_SHIFT_EQUAL = $__7.LEFT_SHIFT_EQUAL,\n      LESS_EQUAL = $__7.LESS_EQUAL,\n      MINUS = $__7.MINUS,\n      MINUS_EQUAL = $__7.MINUS_EQUAL,\n      NOT_EQUAL = $__7.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__7.NOT_EQUAL_EQUAL,\n      NUMBER = $__7.NUMBER,\n      OPEN_ANGLE = $__7.OPEN_ANGLE,\n      OR = $__7.OR,\n      PERCENT = $__7.PERCENT,\n      PERCENT_EQUAL = $__7.PERCENT_EQUAL,\n      PLUS = $__7.PLUS,\n      PLUS_EQUAL = $__7.PLUS_EQUAL,\n      RIGHT_SHIFT = $__7.RIGHT_SHIFT,\n      RIGHT_SHIFT_EQUAL = $__7.RIGHT_SHIFT_EQUAL,\n      SLASH = $__7.SLASH,\n      SLASH_EQUAL = $__7.SLASH_EQUAL,\n      STAR = $__7.STAR,\n      STAR_EQUAL = $__7.STAR_EQUAL,\n      STAR_STAR = $__7.STAR_STAR,\n      STAR_STAR_EQUAL = $__7.STAR_STAR_EQUAL,\n      STRING = $__7.STRING,\n      UNSIGNED_RIGHT_SHIFT = $__7.UNSIGNED_RIGHT_SHIFT,\n      UNSIGNED_RIGHT_SHIFT_EQUAL = $__7.UNSIGNED_RIGHT_SHIFT_EQUAL,\n      YIELD = $__7.YIELD;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./trees/ParseTreeType.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")),\n      ARRAY_PATTERN = $__8.ARRAY_PATTERN,\n      ASSIGNMENT_ELEMENT = $__8.ASSIGNMENT_ELEMENT,\n      BINDING_ELEMENT = $__8.BINDING_ELEMENT,\n      BINDING_IDENTIFIER = $__8.BINDING_IDENTIFIER,\n      BLOCK = $__8.BLOCK,\n      CASE_CLAUSE = $__8.CASE_CLAUSE,\n      CATCH = $__8.CATCH,\n      CLASS_DECLARATION = $__8.CLASS_DECLARATION,\n      COMPUTED_PROPERTY_NAME = $__8.COMPUTED_PROPERTY_NAME,\n      DEFAULT_CLAUSE = $__8.DEFAULT_CLAUSE,\n      EXPORT_DEFAULT = $__8.EXPORT_DEFAULT,\n      EXPORT_SPECIFIER = $__8.EXPORT_SPECIFIER,\n      EXPORT_SPECIFIER_SET = $__8.EXPORT_SPECIFIER_SET,\n      EXPORT_STAR = $__8.EXPORT_STAR,\n      FINALLY = $__8.FINALLY,\n      FORMAL_PARAMETER = $__8.FORMAL_PARAMETER,\n      FORMAL_PARAMETER_LIST = $__8.FORMAL_PARAMETER_LIST,\n      FORWARD_DEFAULT_EXPORT = $__8.FORWARD_DEFAULT_EXPORT,\n      FUNCTION_BODY = $__8.FUNCTION_BODY,\n      FUNCTION_DECLARATION = $__8.FUNCTION_DECLARATION,\n      GET_ACCESSOR = $__8.GET_ACCESSOR,\n      IDENTIFIER_EXPRESSION = $__8.IDENTIFIER_EXPRESSION,\n      IMPORTED_BINDING = $__8.IMPORTED_BINDING,\n      IMPORT_CLAUSE_PAIR = $__8.IMPORT_CLAUSE_PAIR,\n      IMPORT_SPECIFIER_SET = $__8.IMPORT_SPECIFIER_SET,\n      IMPORT_TYPE_CLAUSE = $__8.IMPORT_TYPE_CLAUSE,\n      JSX_ATTRIBUTE = $__8.JSX_ATTRIBUTE,\n      JSX_ELEMENT_NAME = $__8.JSX_ELEMENT_NAME,\n      JSX_ELEMENT = $__8.JSX_ELEMENT,\n      JSX_PLACEHOLDER = $__8.JSX_PLACEHOLDER,\n      JSX_SPREAD_ATTRIBUTE = $__8.JSX_SPREAD_ATTRIBUTE,\n      JSX_TEXT = $__8.JSX_TEXT,\n      LITERAL_PROPERTY_NAME = $__8.LITERAL_PROPERTY_NAME,\n      METHOD = $__8.METHOD,\n      MODULE_SPECIFIER = $__8.MODULE_SPECIFIER,\n      NAMED_EXPORT = $__8.NAMED_EXPORT,\n      NAME_SPACE_EXPORT = $__8.NAME_SPACE_EXPORT,\n      NAME_SPACE_IMPORT = $__8.NAME_SPACE_IMPORT,\n      OBJECT_PATTERN = $__8.OBJECT_PATTERN,\n      OBJECT_PATTERN_FIELD = $__8.OBJECT_PATTERN_FIELD,\n      PROPERTY_NAME_ASSIGNMENT = $__8.PROPERTY_NAME_ASSIGNMENT,\n      PROPERTY_NAME_SHORTHAND = $__8.PROPERTY_NAME_SHORTHAND,\n      PROPERTY_VARIABLE_DECLARATION = $__8.PROPERTY_VARIABLE_DECLARATION,\n      REST_PARAMETER = $__8.REST_PARAMETER,\n      SET_ACCESSOR = $__8.SET_ACCESSOR,\n      SPREAD_EXPRESSION = $__8.SPREAD_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__8.TEMPLATE_LITERAL_PORTION,\n      TEMPLATE_SUBSTITUTION = $__8.TEMPLATE_SUBSTITUTION,\n      TYPE_ALIAS_DECLARATION = $__8.TYPE_ALIAS_DECLARATION,\n      TYPE_ARGUMENTS = $__8.TYPE_ARGUMENTS,\n      TYPE_NAME = $__8.TYPE_NAME,\n      TYPE_PARAMETER = $__8.TYPE_PARAMETER,\n      TYPE_PARAMETERS = $__8.TYPE_PARAMETERS,\n      VARIABLE_DECLARATION_LIST = $__8.VARIABLE_DECLARATION_LIST,\n      VARIABLE_STATEMENT = $__8.VARIABLE_STATEMENT;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/syntax/ParseTreeValidator.js\")).assert;\n  var ValidationError = function($__super) {\n    function ValidationError(tree, message) {\n      $traceurRuntime.superConstructor(ValidationError).call(this);\n      this.tree = tree;\n      this.message = message;\n    }\n    return ($traceurRuntime.createClass)(ValidationError, {}, {}, $__super);\n  }(Error);\n  var ParseTreeValidator = function($__super) {\n    function ParseTreeValidator() {\n      $traceurRuntime.superConstructor(ParseTreeValidator).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ParseTreeValidator, {\n      fail_: function(tree, message) {\n        throw new ValidationError(tree, message);\n      },\n      check_: function(condition, tree, message) {\n        if (!condition) {\n          this.fail_(tree, message);\n        }\n      },\n      checkVisit_: function(condition, tree, message) {\n        this.check_(condition, tree, message);\n        this.visitAny(tree);\n      },\n      checkType_: function(type, tree, message) {\n        this.checkVisit_(tree.type === type, tree, message);\n      },\n      visitArgumentList: function(tree) {\n        for (var i = 0; i < tree.args.length; i++) {\n          var argument = tree.args[i];\n          this.checkVisit_(argument.isAssignmentOrSpread(), argument, 'assignment or spread expected');\n        }\n      },\n      visitArrayLiteral: function(tree) {\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          this.checkVisit_(element === null || element.isAssignmentOrSpread(), element, 'assignment or spread expected');\n        }\n      },\n      visitArrayPattern: function(tree) {\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          this.checkVisit_(element === null || element.type === BINDING_ELEMENT || element.type === ASSIGNMENT_ELEMENT || element.isLeftHandSideExpression() || element.isPattern() || element.isSpreadPatternElement(), element, 'null, sub pattern, left hand side expression or spread expected');\n          if (element && element.isSpreadPatternElement()) {\n            this.check_(i === (tree.elements.length - 1), element, 'spread in array patterns must be the last element');\n          }\n        }\n      },\n      visitBinaryExpression: function(tree) {\n        switch (tree.operator.type) {\n          case EQUAL:\n          case STAR_EQUAL:\n          case STAR_STAR_EQUAL:\n          case SLASH_EQUAL:\n          case PERCENT_EQUAL:\n          case PLUS_EQUAL:\n          case MINUS_EQUAL:\n          case LEFT_SHIFT_EQUAL:\n          case RIGHT_SHIFT_EQUAL:\n          case UNSIGNED_RIGHT_SHIFT_EQUAL:\n          case AMPERSAND_EQUAL:\n          case CARET_EQUAL:\n          case BAR_EQUAL:\n            this.check_(tree.left.isLeftHandSideExpression() || tree.left.isPattern(), tree.left, 'left hand side expression or pattern expected');\n            this.check_(tree.right.isAssignmentExpression(), tree.right, 'assignment expression expected');\n            break;\n          case AND:\n          case OR:\n          case BAR:\n          case CARET:\n          case AMPERSAND:\n          case EQUAL_EQUAL:\n          case NOT_EQUAL:\n          case EQUAL_EQUAL_EQUAL:\n          case NOT_EQUAL_EQUAL:\n          case OPEN_ANGLE:\n          case CLOSE_ANGLE:\n          case GREATER_EQUAL:\n          case LESS_EQUAL:\n          case INSTANCEOF:\n          case IN:\n          case LEFT_SHIFT:\n          case RIGHT_SHIFT:\n          case UNSIGNED_RIGHT_SHIFT:\n          case PLUS:\n          case MINUS:\n          case STAR:\n          case SLASH:\n          case PERCENT:\n          case STAR_STAR:\n            this.check_(tree.left.isAssignmentExpression(), tree.left, 'assignment expression expected');\n            this.check_(tree.right.isAssignmentExpression(), tree.right, 'assignment expression expected');\n            break;\n          default:\n            this.fail_(tree, 'unexpected binary operator');\n        }\n        this.visitAny(tree.left);\n        this.visitAny(tree.right);\n      },\n      visitBindingElement: function(tree) {\n        var binding = tree.binding;\n        this.checkVisit_(binding.type === BINDING_IDENTIFIER || binding.type === OBJECT_PATTERN || binding.type === ARRAY_PATTERN, binding, 'expected valid binding element');\n        this.visitAny(tree.initializer);\n      },\n      visitAssignmentElement: function(tree) {\n        var assignment = tree.assignment;\n        this.checkVisit_(assignment.type === OBJECT_PATTERN || assignment.type === ARRAY_PATTERN || assignment.isLeftHandSideExpression(), assignment, 'expected valid assignment element');\n        this.visitAny(tree.initializer);\n      },\n      visitBlock: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, 'statement or function declaration expected');\n        }\n      },\n      visitCallExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, 'new args expected');\n        }\n        this.visitAny(tree.operand);\n        this.visitAny(tree.args);\n      },\n      visitCaseClause: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, 'statement expected');\n        }\n      },\n      visitCatch: function(tree) {\n        this.checkVisit_(tree.binding.isPattern() || tree.binding.type === BINDING_IDENTIFIER, tree.binding, 'binding identifier expected');\n        this.checkVisit_(tree.catchBody.type === BLOCK, tree.catchBody, 'block expected');\n      },\n      visitClassDeclaration: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassExpression: function(tree) {\n        this.visitClassShared_(tree);\n      },\n      visitClassShared_: function(tree) {\n        if (tree.typeParameters) {\n          this.checkVisit_(tree.typeParameters.type === TYPE_PARAMETERS, tree.typeParameters, 'type parameters expected');\n        }\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          switch (element.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n            case METHOD:\n            case PROPERTY_VARIABLE_DECLARATION:\n              break;\n            default:\n              this.fail_(element, 'class element expected');\n          }\n          this.visitAny(element);\n        }\n      },\n      visitCommaExpression: function(tree) {\n        for (var i = 0; i < tree.expressions.length; i++) {\n          var expression = tree.expressions[i];\n          this.checkVisit_(expression.isExpression(), expression, 'expression expected');\n        }\n      },\n      visitConditionalExpression: function(tree) {\n        this.checkVisit_(tree.condition.isAssignmentExpression(), tree.condition, 'expression expected');\n        this.checkVisit_(tree.left.isAssignmentExpression(), tree.left, 'expression expected');\n        this.checkVisit_(tree.right.isAssignmentExpression(), tree.right, 'expression expected');\n      },\n      visitCoverFormals: function(tree) {\n        this.fail_(tree, 'CoverFormals should have been removed');\n      },\n      visitCoverInitializedName: function(tree) {\n        this.fail_(tree, 'CoverInitializedName should have been removed');\n      },\n      visitDefaultClause: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, 'statement expected');\n        }\n      },\n      visitDoWhileStatement: function(tree) {\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');\n      },\n      visitExportDeclaration: function(tree) {\n        var declType = tree.declaration.type;\n        this.checkVisit_(declType === VARIABLE_STATEMENT || declType === FUNCTION_DECLARATION || declType === CLASS_DECLARATION || declType === NAMED_EXPORT || declType === EXPORT_DEFAULT || declType === TYPE_ALIAS_DECLARATION, tree.declaration, 'expected valid export tree');\n      },\n      visitNamedExport: function(tree) {\n        var specifierType = tree.exportClause.type;\n        this.checkVisit_(specifierType === EXPORT_SPECIFIER || specifierType === EXPORT_SPECIFIER_SET || specifierType === EXPORT_STAR || specifierType === FORWARD_DEFAULT_EXPORT || specifierType === NAME_SPACE_EXPORT, tree.exportClause, 'Invalid export clause');\n        if (tree.moduleSpecifier) {\n          this.checkVisit_(tree.moduleSpecifier.type === MODULE_SPECIFIER, tree.moduleSpecifier, 'module expression expected');\n        }\n      },\n      visitExportSpecifierSet: function(tree) {\n        this.check_(tree.specifiers.length > 0, tree, 'expected at least one identifier');\n        for (var i = 0; i < tree.specifiers.length; i++) {\n          var specifier = tree.specifiers[i];\n          this.checkVisit_(specifier.type === EXPORT_SPECIFIER || specifier.type === IDENTIFIER_EXPRESSION, specifier, 'expected valid export specifier');\n        }\n      },\n      visitExpressionStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n      },\n      visitFinally: function(tree) {\n        this.checkVisit_(tree.block.type === BLOCK, tree.block, 'block expected');\n      },\n      visitForOfStatement: function(tree) {\n        this.checkVisit_(tree.initializer.isPattern() || tree.initializer.type === IDENTIFIER_EXPRESSION || tree.initializer.type === VARIABLE_DECLARATION_LIST && tree.initializer.declarations.length === 1, tree.initializer, 'for-each statement may not have more than one variable declaration');\n        this.checkVisit_(tree.collection.isExpression(), tree.collection, 'expression expected');\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n      },\n      visitForInStatement: function(tree) {\n        if (tree.initializer.type === VARIABLE_DECLARATION_LIST) {\n          this.checkVisit_(tree.initializer.declarations.length <= 1, tree.initializer, 'for-in statement may not have more than one variable declaration');\n        } else {\n          this.checkVisit_(tree.initializer.isPattern() || tree.initializer.isExpression(), tree.initializer, 'variable declaration, expression or ' + 'pattern expected');\n        }\n        this.checkVisit_(tree.collection.isExpression(), tree.collection, 'expression expected');\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n      },\n      visitFormalParameterList: function(tree) {\n        for (var i = 0; i < tree.parameters.length; i++) {\n          var parameter = tree.parameters[i];\n          assert(parameter.type === FORMAL_PARAMETER);\n          parameter = parameter.parameter;\n          switch (parameter.type) {\n            case BINDING_ELEMENT:\n              break;\n            case REST_PARAMETER:\n              this.checkVisit_(i === tree.parameters.length - 1, parameter, 'rest parameters must be the last parameter in a parameter list');\n              this.checkType_(BINDING_IDENTIFIER, parameter.identifier, 'binding identifier expected');\n              break;\n            default:\n              this.fail_(parameter, 'parameters must be identifiers or rest' + (\" parameters. Found: \" + parameter.type));\n              break;\n          }\n          this.visitAny(parameter);\n        }\n      },\n      visitForStatement: function(tree) {\n        if (tree.initializer !== null) {\n          this.checkVisit_(tree.initializer.isExpression() || tree.initializer.type === VARIABLE_DECLARATION_LIST, tree.initializer, 'variable declaration list or expression expected');\n        }\n        if (tree.condition !== null) {\n          this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');\n        }\n        if (tree.increment !== null) {\n          this.checkVisit_(tree.increment.isExpression(), tree.increment, 'expression expected');\n        }\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n      },\n      visitFunctionBody: function(tree) {\n        for (var i = 0; i < tree.statements.length; i++) {\n          var statement = tree.statements[i];\n          this.checkVisit_(statement.isStatementListItem(), statement, 'statement expected');\n        }\n      },\n      visitFunctionDeclaration: function(tree) {\n        this.checkType_(BINDING_IDENTIFIER, tree.name, 'binding identifier expected');\n        this.visitFunction_(tree);\n      },\n      visitFunctionExpression: function(tree) {\n        if (tree.name !== null) {\n          this.checkType_(BINDING_IDENTIFIER, tree.name, 'binding identifier expected');\n        }\n        this.visitFunction_(tree);\n      },\n      visitFunction_: function(tree) {\n        this.checkType_(FORMAL_PARAMETER_LIST, tree.parameterList, 'formal parameters expected');\n        this.checkType_(FUNCTION_BODY, tree.body, 'function body expected');\n      },\n      visitGetAccessor: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkType_(FUNCTION_BODY, tree.body, 'function body expected');\n      },\n      visitIfStatement: function(tree) {\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');\n        this.checkVisit_(tree.ifClause.isStatement(), tree.ifClause, 'statement expected');\n        if (tree.elseClause !== null) {\n          this.checkVisit_(tree.elseClause.isStatement(), tree.elseClause, 'statement expected');\n        }\n      },\n      visitImportDeclaration: function(tree) {\n        if (tree.importClause !== null) {\n          this.check_(tree.importClause.type === NAME_SPACE_IMPORT || tree.importClause.type === IMPORTED_BINDING || tree.importClause.type === IMPORT_SPECIFIER_SET || tree.importClause.type === IMPORT_CLAUSE_PAIR || tree.importClause.type === IMPORT_TYPE_CLAUSE, tree.importClause, 'Invalid import clause');\n        }\n        this.checkType_(MODULE_SPECIFIER, tree.moduleSpecifier, 'module specifier expected');\n      },\n      visitImportSpecifier: function(tree) {\n        this.checkType_(IMPORTED_BINDING, tree.binding, 'ImportedBinding expected');\n      },\n      visitImportedBinding: function(tree) {\n        this.checkType_(BINDING_IDENTIFIER, tree.binding, 'binding identifier expected');\n      },\n      visitImportClausePair: function(tree) {\n        this.checkType_(IMPORTED_BINDING, tree.first, 'ImportedBinding expected');\n        this.check_(tree.second.type === NAME_SPACE_IMPORT || tree.second.type === IMPORT_SPECIFIER_SET, tree.second, 'Invalid import clause');\n      },\n      visitJsxElement: function(tree) {\n        this.checkType_(JSX_ELEMENT_NAME, tree.name, 'JSX Element Name expected');\n        for (var i = 0; i < tree.attributes.length; i++) {\n          var attr = tree.attributes[i];\n          this.checkVisit_(attr.type === JSX_ATTRIBUTE || attr.type === JSX_SPREAD_ATTRIBUTE, attr, 'JSX Attribute expected');\n        }\n        for (var i$__3 = 0; i$__3 < tree.children.length; i$__3++) {\n          var child = tree.children[i$__3];\n          this.checkVisit_(child.type === JSX_ELEMENT || child.type === JSX_PLACEHOLDER || child.type === JSX_TEXT, child, 'JSX child expected');\n        }\n      },\n      visitLabelledStatement: function(tree) {\n        this.checkVisit_(tree.statement.isStatement(), tree.statement, 'statement expected');\n      },\n      visitMemberExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, 'new args expected');\n        }\n        this.visitAny(tree.operand);\n      },\n      visitMemberLookupExpression: function(tree) {\n        this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');\n        if (tree.operand instanceof NewExpression) {\n          this.check_(tree.operand.args !== null, tree.operand, 'new args expected');\n        }\n        this.visitAny(tree.operand);\n      },\n      visitSyntaxErrorTree: function(tree) {\n        this.fail_(tree, (\"parse tree contains SyntaxError: \" + tree.message));\n      },\n      visitModuleSpecifier: function(tree) {\n        this.check_(tree.token.type === STRING, tree, 'string or identifier expected');\n      },\n      visitNewExpression: function(tree) {\n        this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');\n        this.visitAny(tree.args);\n      },\n      visitObjectLiteral: function(tree) {\n        for (var i = 0; i < tree.propertyNameAndValues.length; i++) {\n          var propertyNameAndValue = tree.propertyNameAndValues[i];\n          switch (propertyNameAndValue.type) {\n            case GET_ACCESSOR:\n            case SET_ACCESSOR:\n            case METHOD:\n              this.check_(!propertyNameAndValue.isStatic, propertyNameAndValue, 'static is not allowed in object literal expression');\n              break;\n            case PROPERTY_NAME_ASSIGNMENT:\n            case PROPERTY_NAME_SHORTHAND:\n            case SPREAD_EXPRESSION:\n              break;\n            default:\n              this.fail_(propertyNameAndValue, 'accessor, property name ' + 'assignment or property method assigment expected');\n          }\n          this.visitAny(propertyNameAndValue);\n        }\n      },\n      visitObjectPattern: function(tree) {\n        for (var i = 0; i < tree.fields.length; i++) {\n          var field = tree.fields[i];\n          this.checkVisit_(field.type === OBJECT_PATTERN_FIELD || field.type === ASSIGNMENT_ELEMENT || field.type === BINDING_ELEMENT, field, 'object pattern field expected');\n        }\n      },\n      visitObjectPatternField: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkVisit_(tree.element.type === ASSIGNMENT_ELEMENT || tree.element.type === BINDING_ELEMENT || tree.element.isPattern() || tree.element.isLeftHandSideExpression(), tree.element, 'binding element expected');\n      },\n      visitParenExpression: function(tree) {\n        if (tree.expression.isPattern()) {\n          this.visitAny(tree.expression);\n        } else {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        }\n      },\n      visitPostfixExpression: function(tree) {\n        this.checkVisit_(tree.operand.isAssignmentExpression(), tree.operand, 'assignment expression expected');\n      },\n      visitPredefinedType: function(tree) {},\n      visitScript: function(tree) {\n        for (var i = 0; i < tree.scriptItemList.length; i++) {\n          var scriptItemList = tree.scriptItemList[i];\n          this.checkVisit_(scriptItemList.isScriptElement(), scriptItemList, 'global script item expected');\n        }\n      },\n      checkPropertyName_: function(tree) {\n        this.checkVisit_(tree.type === LITERAL_PROPERTY_NAME || tree.type === COMPUTED_PROPERTY_NAME, tree, 'property name expected');\n      },\n      visitPropertyNameAssignment: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkVisit_(tree.value.isAssignmentExpression(), tree.value, 'assignment expression expected');\n      },\n      visitPropertyNameShorthand: function(tree) {\n        this.check_(tree.name.type === IDENTIFIER || tree.name.type === YIELD || tree.name.isStrictKeyword(), tree, 'identifier token expected');\n      },\n      visitLiteralPropertyName: function(tree) {\n        var type = tree.literalToken.type;\n        this.check_(tree.literalToken.isKeyword() || type === IDENTIFIER || type === NUMBER || type === STRING, tree, 'Unexpected token in literal property name');\n      },\n      visitTemplateLiteralExpression: function(tree) {\n        if (tree.operand) {\n          this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, 'member or call expression expected');\n        }\n        for (var i = 0; i < tree.elements.length; i++) {\n          var element = tree.elements[i];\n          if (i % 2) {\n            this.checkType_(TEMPLATE_SUBSTITUTION, element, 'Template literal substitution expected');\n          } else {\n            this.checkType_(TEMPLATE_LITERAL_PORTION, element, 'Template literal portion expected');\n          }\n        }\n      },\n      visitReturnStatement: function(tree) {\n        if (tree.expression !== null) {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        }\n      },\n      visitSetAccessor: function(tree) {\n        this.checkPropertyName_(tree.name);\n        this.checkType_(FUNCTION_BODY, tree.body, 'function body expected');\n      },\n      visitSpreadExpression: function(tree) {\n        this.checkVisit_(tree.expression.isAssignmentExpression(), tree.expression, 'assignment expression expected');\n      },\n      visitStateMachine: function(tree) {\n        this.fail_(tree, 'State machines are never valid outside of the ' + 'GeneratorTransformer pass.');\n      },\n      visitSwitchStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        var defaultCount = 0;\n        for (var i = 0; i < tree.caseClauses.length; i++) {\n          var caseClause = tree.caseClauses[i];\n          if (caseClause.type === DEFAULT_CLAUSE) {\n            ++defaultCount;\n            this.checkVisit_(defaultCount <= 1, caseClause, 'no more than one default clause allowed');\n          } else {\n            this.checkType_(CASE_CLAUSE, caseClause, 'case or default clause expected');\n          }\n        }\n      },\n      visitThrowStatement: function(tree) {\n        if (tree.value === null) {\n          return;\n        }\n        this.checkVisit_(tree.value.isExpression(), tree.value, 'expression expected');\n      },\n      visitTryStatement: function(tree) {\n        this.checkType_(BLOCK, tree.body, 'block expected');\n        if (tree.catchBlock !== null) {\n          this.checkType_(CATCH, tree.catchBlock, 'catch block expected');\n        }\n        if (tree.finallyBlock !== null) {\n          this.checkType_(FINALLY, tree.finallyBlock, 'finally block expected');\n        }\n        if (tree.catchBlock === null && tree.finallyBlock === null) {\n          this.fail_(tree, 'either catch or finally must be present');\n        }\n      },\n      visitTypeArguments: function(tree) {\n        var args = tree.args;\n        for (var i = 0; i < args.length; i++) {\n          this.checkVisit_(args[i].isType(), args[i], 'Type arguments must be type expressions');\n        }\n      },\n      visitTypeName: function(tree) {\n        this.checkVisit_(tree.moduleName === null || tree.moduleName.type === TYPE_NAME, tree.moduleName, 'moduleName must be null or a TypeName');\n        this.check_(tree.name.type === IDENTIFIER, tree, 'name must be an identifier');\n      },\n      visitTypeReference: function(tree) {\n        this.checkType_(TYPE_NAME, tree.typeName, 'typeName must be a TypeName');\n        this.checkType_(TYPE_ARGUMENTS, tree.args, 'args must be a TypeArguments');\n      },\n      visitTypeParameters: function(tree) {\n        var parameters = tree.parameters;\n        for (var i = 0; i < parameters.length; i++) {\n          this.checkType_(TYPE_PARAMETER, parameters[i], 'Type parameters must all be type parameters');\n        }\n      },\n      visitTypeParameter: function(tree) {\n        this.check_(tree.identifierToken.type === IDENTIFIER, tree, 'Type parameter must be an identifier token');\n        if (tree.extendsType) {\n          this.checkVisit_(tree.extendsType.isType(), tree.extendsType, 'extends type must be a type expression');\n        }\n      },\n      visitUnaryExpression: function(tree) {\n        this.checkVisit_(tree.operand.isAssignmentExpression(), tree.operand, 'assignment expression expected');\n      },\n      visitVariableDeclaration: function(tree) {\n        this.checkVisit_(tree.lvalue.isPattern() || tree.lvalue.type === BINDING_IDENTIFIER, tree.lvalue, 'binding identifier expected, found: ' + tree.lvalue.type);\n        if (tree.initializer !== null) {\n          this.checkVisit_(tree.initializer.isAssignmentExpression(), tree.initializer, 'assignment expression expected');\n        }\n      },\n      visitWhileStatement: function(tree) {\n        this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n      },\n      visitWithStatement: function(tree) {\n        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');\n      },\n      visitYieldExpression: function(tree) {\n        if (tree.expression !== null) {\n          this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');\n        }\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  ParseTreeValidator.validate = function(tree) {\n    var validator = new ParseTreeValidator();\n    try {\n      validator.visitAny(tree);\n    } catch (e) {\n      if (!(e instanceof ValidationError)) {\n        throw e;\n      }\n      var location = null;\n      if (e.tree !== null) {\n        location = e.tree.location;\n      }\n      if (location === null) {\n        location = tree.location;\n      }\n      var locationString = location !== null ? location.start.toString() : '(unknown)';\n      throw new Error((\"Parse tree validation failure '\" + e.message + \"' at \" + locationString + \":\") + (\"\\n\\n\" + TreeWriter.write(tree) + \"\\n\"));\n    }\n  };\n  return {get ParseTreeValidator() {\n      return ParseTreeValidator;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/MultiTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/MultiTransformer.js\";\n  var ParseTreeValidator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/ParseTreeValidator.js\", \"traceur@0.0.111/src/codegeneration/MultiTransformer.js\")).ParseTreeValidator;\n  var MultiTransformer = function() {\n    function MultiTransformer(reporter, validate) {\n      this.reporter_ = reporter;\n      this.validate_ = validate;\n      this.treeTransformers_ = [];\n    }\n    return ($traceurRuntime.createClass)(MultiTransformer, {\n      append: function(treeTransformer) {\n        this.treeTransformers_.push(treeTransformer);\n      },\n      transform: function(tree) {\n        var reporter = this.reporter_;\n        var validate = this.validate_;\n        this.treeTransformers_.every(function(transformTree) {\n          tree = transformTree(tree);\n          if (reporter.hadError())\n            return false;\n          if (validate)\n            ParseTreeValidator.validate(tree);\n          return true;\n        });\n        return tree;\n      }\n    }, {});\n  }();\n  return {get MultiTransformer() {\n      return MultiTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\")),\n      LiteralExpression = $__2.LiteralExpression,\n      LiteralPropertyName = $__2.LiteralPropertyName;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\")).LiteralToken;\n  var NUMBER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/NumericLiteralTransformer.js\")).NUMBER;\n  function needsTransform(token) {\n    return token.type === NUMBER && /^0[bBoO]/.test(token.value);\n  }\n  function transformToken(token) {\n    return new LiteralToken(NUMBER, String(token.processedValue), token.location);\n  }\n  var NumericLiteralTransformer = function($__super) {\n    function NumericLiteralTransformer() {\n      $traceurRuntime.superConstructor(NumericLiteralTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(NumericLiteralTransformer, {\n      transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token))\n          return new LiteralExpression(tree.location, transformToken(token));\n        return tree;\n      },\n      transformLiteralPropertyName: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token))\n          return new LiteralPropertyName(tree.location, transformToken(token));\n        return tree;\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get NumericLiteralTransformer() {\n      return NumericLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\";\n  var FindVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./FindVisitor.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")).FindVisitor;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")),\n      FunctionExpression = $__4.FunctionExpression,\n      IdentifierExpression = $__4.IdentifierExpression,\n      LiteralExpression = $__4.LiteralExpression;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")).TempVarTransformer;\n  var IDENTIFIER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")).IDENTIFIER;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")),\n      COMPUTED_PROPERTY_NAME = $__7.COMPUTED_PROPERTY_NAME,\n      LITERAL_PROPERTY_NAME = $__7.LITERAL_PROPERTY_NAME;\n  var StringMap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/StringMap.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")).StringMap;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")),\n      createAssignmentExpression = $__9.createAssignmentExpression,\n      createCommaExpression = $__9.createCommaExpression,\n      createDefineProperty = $__9.createDefineProperty,\n      createEmptyParameterList = $__9.createEmptyParameterList,\n      createFunctionExpression = $__9.createFunctionExpression,\n      createIdentifierExpression = $__9.createIdentifierExpression,\n      createObjectCreate = $__9.createObjectCreate,\n      createObjectLiteral = $__9.createObjectLiteral,\n      createParenExpression = $__9.createParenExpression,\n      createPropertyNameAssignment = $__9.createPropertyNameAssignment,\n      createStringLiteral = $__9.createStringLiteral;\n  var propName = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../staticsemantics/PropName.js\", \"traceur@0.0.111/src/codegeneration/ObjectLiteralTransformer.js\")).propName;\n  var FindAdvancedProperty = function($__super) {\n    function FindAdvancedProperty(transformOptions) {\n      $traceurRuntime.superConstructor(FindAdvancedProperty).call(this, true);\n      this.transformOptions_ = transformOptions;\n      this.protoExpression = null;\n    }\n    return ($traceurRuntime.createClass)(FindAdvancedProperty, {\n      visitPropertyNameAssignment: function(tree) {\n        if (isProtoName(tree.name))\n          this.protoExpression = tree.value;\n        else\n          this.visitAny(tree.name);\n      },\n      visitMethod: function(tree) {\n        this.visitAny(tree.name);\n      },\n      visitGetAccessor: function(tree) {\n        if (this.transformOptions_.properTailCalls) {\n          this.found = true;\n        } else {\n          this.visitAny(tree.name);\n        }\n      },\n      visitSetAccessor: function(tree) {\n        if (this.transformOptions_.properTailCalls) {\n          this.found = true;\n        } else {\n          this.visitAny(tree.name);\n        }\n      },\n      visitComputedPropertyName: function(tree) {\n        if (this.transformOptions_.computedPropertyNames)\n          this.found = true;\n      }\n    }, {}, $__super);\n  }(FindVisitor);\n  function isProtoName(tree) {\n    return propName(tree) === '__proto__';\n  }\n  var ObjectLiteralTransformer = function($__super) {\n    function ObjectLiteralTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ObjectLiteralTransformer).call(this, identifierGenerator, reporter, options);\n      this.transformOptions_ = options.transformOptions;\n      this.protoExpression = null;\n      this.needsAdvancedTransform = false;\n      this.seenAccessors = null;\n    }\n    return ($traceurRuntime.createClass)(ObjectLiteralTransformer, {\n      findSeenAccessor_: function(name) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return null;\n        var s = propName(name);\n        return this.seenAccessors.get(s);\n      },\n      removeSeenAccessor_: function(name) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return;\n        var s = propName(name);\n        this.seenAccessors.delete(s);\n      },\n      addSeenAccessor_: function(name, descr) {\n        if (name.type === COMPUTED_PROPERTY_NAME)\n          return;\n        var s = propName(name);\n        this.seenAccessors.set(s, descr);\n      },\n      createProperty_: function(name, descr) {\n        var expression;\n        if (name.type === LITERAL_PROPERTY_NAME) {\n          if (this.needsAdvancedTransform)\n            expression = this.getPropertyName_(name);\n          else\n            expression = name;\n        } else {\n          expression = name.expression;\n        }\n        if (descr.get || descr.set) {\n          var oldAccessor = this.findSeenAccessor_(name);\n          if (oldAccessor) {\n            oldAccessor.get = descr.get || oldAccessor.get;\n            oldAccessor.set = descr.set || oldAccessor.set;\n            this.removeSeenAccessor_(name);\n            return null;\n          } else {\n            this.addSeenAccessor_(name, descr);\n          }\n        }\n        return [expression, descr];\n      },\n      getPropertyName_: function(nameTree) {\n        var token = nameTree.literalToken;\n        switch (token.type) {\n          case IDENTIFIER:\n            return createStringLiteral(token.value);\n          default:\n            if (token.isKeyword())\n              return createStringLiteral(token.type);\n            return new LiteralExpression(token.location, token);\n        }\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformObjectLiteral: function(tree) {\n        var oldNeedsTransform = this.needsAdvancedTransform;\n        var oldSeenAccessors = this.seenAccessors;\n        var transformed = this.transformObjectLiteralInner_(tree);\n        this.needsAdvancedTransform = oldNeedsTransform;\n        this.seenAccessors = oldSeenAccessors;\n        return transformed;\n      },\n      transformObjectLiteralInner_: function(tree) {\n        var finder = new FindAdvancedProperty(this.transformOptions_);\n        finder.visitAny(tree);\n        if (!finder.found) {\n          this.needsAdvancedTransform = false;\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, \"transformObjectLiteral\").call(this, tree);\n        }\n        this.needsAdvancedTransform = true;\n        this.seenAccessors = new StringMap();\n        var properties = this.transformList(tree.propertyNameAndValues);\n        properties = properties.filter(function(tree) {\n          return tree;\n        });\n        var tempVar = this.addTempVar();\n        var tempVarIdentifierExpression = createIdentifierExpression(tempVar);\n        var expressions = properties.map(function(property) {\n          var expression = property[0];\n          var descr = property[1];\n          return createDefineProperty(tempVarIdentifierExpression, expression, descr);\n        });\n        var protoExpression = this.transformAny(finder.protoExpression);\n        var objectExpression;\n        if (protoExpression)\n          objectExpression = createObjectCreate(protoExpression);\n        else\n          objectExpression = createObjectLiteral([]);\n        expressions.unshift(createAssignmentExpression(tempVarIdentifierExpression, objectExpression));\n        expressions.push(tempVarIdentifierExpression);\n        return createParenExpression(createCommaExpression(expressions));\n      },\n      transformPropertyNameAssignment: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, \"transformPropertyNameAssignment\").call(this, tree);\n        if (isProtoName(tree.name))\n          return null;\n        return this.createProperty_(tree.name, {\n          value: this.transformAny(tree.value),\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      },\n      transformGetAccessor: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, \"transformGetAccessor\").call(this, tree);\n        var body = this.transformAny(tree.body);\n        var func = createFunctionExpression(createEmptyParameterList(), body);\n        return this.createProperty_(tree.name, {\n          get: func,\n          configurable: true,\n          enumerable: true\n        });\n      },\n      transformSetAccessor: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, \"transformSetAccessor\").call(this, tree);\n        var body = this.transformAny(tree.body);\n        var parameterList = this.transformAny(tree.parameterList);\n        var func = createFunctionExpression(parameterList, body);\n        return this.createProperty_(tree.name, {\n          set: func,\n          configurable: true,\n          enumerable: true\n        });\n      },\n      transformMethod: function(tree) {\n        var func = new FunctionExpression(tree.location, tree.debugName, tree.functionKind, this.transformAny(tree.parameterList), tree.typeAnnotation, [], this.transformAny(tree.body));\n        if (!this.needsAdvancedTransform) {\n          return createPropertyNameAssignment(tree.name, func);\n        }\n        var expression = this.transformAny(tree.name);\n        return this.createProperty_(tree.name, {\n          value: func,\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      },\n      transformPropertyNameShorthand: function(tree) {\n        if (!this.needsAdvancedTransform)\n          return $traceurRuntime.superGet(this, ObjectLiteralTransformer.prototype, \"transformPropertyNameShorthand\").call(this, tree);\n        var expression = this.transformAny(tree.name);\n        return this.createProperty_(tree.name, {\n          value: new IdentifierExpression(tree.location, tree.name.identifierToken),\n          configurable: true,\n          enumerable: false,\n          writable: true\n        });\n      }\n    }, {}, $__super);\n  }(TempVarTransformer);\n  return {get ObjectLiteralTransformer() {\n      return ObjectLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\")),\n      ArgumentList = $__2.ArgumentList,\n      BinaryExpression = $__2.BinaryExpression,\n      CallExpression = $__2.CallExpression,\n      ConditionalExpression = $__2.ConditionalExpression,\n      MemberExpression = $__2.MemberExpression,\n      MemberLookupExpression = $__2.MemberLookupExpression;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\")),\n      createArrayLiteral = $__3.createArrayLiteral,\n      createAssignmentExpression = $__3.createAssignmentExpression,\n      createCommaExpression = $__3.createCommaExpression,\n      createMemberExpression = $__3.createMemberExpression,\n      id = $__3.createIdentifierExpression,\n      createNullLiteral = $__3.createNullLiteral,\n      createParenExpression = $__3.createParenExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\")),\n      COMMA_EXPRESSION = $__4.COMMA_EXPRESSION,\n      MEMBER_EXPRESSION = $__4.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__4.MEMBER_LOOKUP_EXPRESSION,\n      IDENTIFIER_EXPRESSION = $__4.IDENTIFIER_EXPRESSION,\n      PAREN_EXPRESSION = $__4.PAREN_EXPRESSION,\n      THIS_EXPRESSION = $__4.THIS_EXPRESSION;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailExpressionsTransformer.js\")),\n      AND = $__5.AND,\n      OR = $__5.OR;\n  function createCall(tree, operand, thisArg, importRuntimeTransformer) {\n    var argList = tree.args;\n    var argArray = argList ? argList.args : [];\n    argArray = argArray.map(function(arg) {\n      if (arg.type === COMMA_EXPRESSION) {\n        return createParenExpression(arg.type);\n      }\n      return arg;\n    });\n    var continuation = importRuntimeTransformer.getRuntimeExpression('continuation');\n    return new CallExpression(tree.location, continuation, new ArgumentList(argList ? argList.location : null, [operand, thisArg, createArrayLiteral(argArray)]));\n  }\n  var RewriteTailExpressionsTransformer = function($__super) {\n    function RewriteTailExpressionsTransformer(bodyTransformer) {\n      $traceurRuntime.superConstructor(RewriteTailExpressionsTransformer).call(this);\n      this.bodyTransformer_ = bodyTransformer;\n    }\n    return ($traceurRuntime.createClass)(RewriteTailExpressionsTransformer, {\n      transformBinaryExpression: function(tree) {\n        var operator = tree.operator;\n        if (operator.type !== AND && operator.type !== OR) {\n          return tree;\n        }\n        var right = this.transformAny(tree.right);\n        if (right !== tree.right) {\n          return new BinaryExpression(tree.location, tree.left, operator, right);\n        }\n        return tree;\n      },\n      transformCallExpression: function(tree) {\n        var operand = tree.operand;\n        while (operand.type === PAREN_EXPRESSION) {\n          operand = operand.expression;\n        }\n        switch (operand.type) {\n          case IDENTIFIER_EXPRESSION:\n            return createCall(tree, operand, createNullLiteral(), this.bodyTransformer_);\n          case MEMBER_EXPRESSION:\n          case MEMBER_LOOKUP_EXPRESSION:\n            return this.transformMemberExpressionCall_(tree, operand);\n        }\n        return tree;\n      },\n      transformMemberExpressionCall_: function(tree, operand) {\n        var object = operand.operand;\n        var thisArg;\n        var assignment;\n        if (object.type === IDENTIFIER_EXPRESSION || object.type === THIS_EXPRESSION) {\n          thisArg = object;\n        } else {\n          thisArg = id(this.bodyTransformer_.addTempVar());\n          assignment = createAssignmentExpression(thisArg, operand.operand);\n        }\n        if (operand.type === MEMBER_EXPRESSION) {\n          operand = new MemberExpression(operand.location, thisArg, operand.memberName);\n        } else {\n          operand = new MemberLookupExpression(operand.location, thisArg, operand.memberExpression);\n        }\n        if (assignment) {\n          return createParenExpression(createCommaExpression([assignment, createCall(tree, operand, thisArg, this.bodyTransformer_)]));\n        } else {\n          return createCall(tree, operand, thisArg, this.bodyTransformer_);\n        }\n      },\n      transformCommaExpression: function(tree) {\n        var expressions = tree.expressions;\n        var expression = expressions[expressions.length - 1];\n        var transformedExpression = this.transformAny(expression);\n        if (expression !== transformedExpression) {\n          expressions = expressions.slice(0, -1);\n          expressions.push(transformedExpression);\n          return new CommaExpression(tree.location, expressions);\n        }\n        return tree;\n      },\n      transformConditionalExpression: function(tree) {\n        var left = this.transformAny(tree.left);\n        var right = this.transformAny(tree.right);\n        if (left !== tree.left || right !== tree.right) {\n          return new ConditionalExpression(tree.location, tree.condition, left, right);\n        }\n        return tree;\n      },\n      transformNewExpression: function(tree) {\n        var construct = this.bodyTransformer_.getRuntimeExpression('construct');\n        return createCall(tree, construct, tree.operand, this.bodyTransformer_);\n      },\n      transformArrayLiteral: function(tree) {\n        return tree;\n      },\n      transformArrowFunction: function(tree) {\n        return tree;\n      },\n      transformFunctionExpression: function(tree) {\n        return tree;\n      },\n      transformIdentifierExpression: function(tree) {\n        return tree;\n      },\n      transformLiteralExpression: function(tree) {\n        return tree;\n      },\n      transformMemberExpression: function(tree) {\n        return tree;\n      },\n      transformMemberLookupExpression: function(tree) {\n        return tree;\n      },\n      transformPostfixExpression: function(tree) {\n        return tree;\n      },\n      transformObjectLiteral: function(tree) {\n        return tree;\n      },\n      transformUnaryExpression: function(tree) {\n        return tree;\n      }\n    }, {transform: function(bodyTransformer, tree) {\n        return new RewriteTailExpressionsTransformer(bodyTransformer).transformAny(tree);\n      }}, $__super);\n  }(ParseTreeTransformer);\n  return {get RewriteTailExpressionsTransformer() {\n      return RewriteTailExpressionsTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\")).ParseTreeTransformer;\n  var RewriteTailExpressionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./RewriteTailExpressionsTransformer.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\")).RewriteTailExpressionsTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\")),\n      ReturnStatement = $__3.ReturnStatement,\n      TryStatement = $__3.TryStatement;\n  var SkipFunctionsTransformerTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SkipFunctionsTransformerTrait.js\", \"traceur@0.0.111/src/codegeneration/RewriteTailCallsTransformer.js\")).default;\n  var RewriteTailCallsTransformer = function($__super) {\n    function RewriteTailCallsTransformer(bodyTransformer) {\n      $traceurRuntime.superConstructor(RewriteTailCallsTransformer).call(this);\n      this.bodyTransformer_ = bodyTransformer;\n    }\n    return ($traceurRuntime.createClass)(RewriteTailCallsTransformer, {\n      transformReturnStatement: function(tree) {\n        var expression = tree.expression;\n        if (expression !== null) {\n          expression = RewriteTailExpressionsTransformer.transform(this.bodyTransformer_, expression);\n          if (expression !== tree.expression) {\n            return new ReturnStatement(tree.location, expression);\n          }\n        }\n        return tree;\n      },\n      transformTryStatement: function(tree) {\n        var block;\n        if (tree.finallyBlock !== null) {\n          block = this.transformAny(tree.finallyBlock);\n          if (block !== tree.finallyBlock) {\n            return new TryStatement(tree.location, tree.body, tree.catchBlock, block);\n          }\n        } else {\n          block = this.transformAny(tree.catchBlock);\n          if (block !== tree.catchBlock) {\n            return new TryStatement(tree.location, tree.body, block, tree.finallyBlock);\n          }\n        }\n        return tree;\n      },\n      transformForInStatement: function(tree) {\n        return tree;\n      },\n      transformForOfStatement: function(tree) {\n        return tree;\n      },\n      transformForOnStatement: function(tree) {\n        return tree;\n      },\n      transformClassDeclaration: function(tree) {\n        return tree;\n      },\n      transformClassExpression: function(tree) {\n        return tree;\n      },\n      transformExpressionStatement: function(tree) {\n        return tree;\n      },\n      transformComprehensionFor: function(tree) {\n        return tree;\n      },\n      transformVariableStatement: function(tree) {\n        return tree;\n      }\n    }, {transform: function(bodyTransformer, tree) {\n        return new RewriteTailCallsTransformer(bodyTransformer).transformAny(tree);\n      }}, $__super);\n  }(SkipFunctionsTransformerTrait(ParseTreeTransformer));\n  return {get RewriteTailCallsTransformer() {\n      return RewriteTailCallsTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\";\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")).TempVarTransformer;\n  var RewriteTailCallsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./RewriteTailCallsTransformer.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")).RewriteTailCallsTransformer;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")),\n      createFunctionBody = $__3.createFunctionBody,\n      createFunctionExpression = $__3.createFunctionExpression,\n      id = $__3.createIdentifierExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")),\n      parseExpression = $__4.parseExpression,\n      parseStatement = $__4.parseStatement,\n      parseStatements = $__4.parseStatements;\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")),\n      AnonBlock = $__5.AnonBlock,\n      FunctionDeclaration = $__5.FunctionDeclaration,\n      FunctionExpression = $__5.FunctionExpression;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/ProperTailCallTransformer.js\")).default;\n  var ProperTailCallTransformer = function($__super) {\n    function ProperTailCallTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(ProperTailCallTransformer).call(this, identifierGenerator, reporter, options);\n      this.inBlock_ = false;\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(ProperTailCallTransformer, {\n      transformFunctionDeclaration: function(tree) {\n        tree = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n        if (tree.functionKind !== null) {\n          return tree;\n        }\n        var nameIdExpression = id(tree.name.identifierToken);\n        var initTailRecursiveFunction = this.getRuntimeExpression('initTailRecursiveFunction');\n        var setupFlagExpression = parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initTailRecursiveFunction, nameIdExpression);\n        var funcDecl = this.transformFunction_(tree, FunctionDeclaration);\n        if (funcDecl === tree) {\n          return tree;\n        }\n        var tmpVar = id(this.inBlock_ ? this.getTempIdentifier() : this.addTempVar(setupFlagExpression));\n        if (!this.inBlock_) {\n          return funcDecl;\n        }\n        return new AnonBlock(null, [funcDecl, parseStatement($traceurRuntime.getTemplateObject([\"var \", \" = \", \";\"]), tmpVar, setupFlagExpression)]);\n      },\n      transformFunctionExpression: function(tree) {\n        tree = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, \"transformFunctionExpression\").call(this, tree);\n        if (tree.functionKind) {\n          return tree;\n        }\n        var functionExpression = this.transformFunction_(tree, FunctionExpression);\n        if (functionExpression === tree) {\n          return tree;\n        }\n        var initTailRecursiveFunction = this.getRuntimeExpression('initTailRecursiveFunction');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), initTailRecursiveFunction, functionExpression);\n      },\n      transformFunction_: function(tree, constructor) {\n        var body = RewriteTailCallsTransformer.transform(this, tree.body);\n        if (body === tree.body) {\n          return tree;\n        }\n        var func = id(this.getTempIdentifier());\n        var innerFunction = createFunctionExpression(tree.parameterList, body);\n        var call = this.getRuntimeExpression('call');\n        var outerBody = createFunctionBody(parseStatements($traceurRuntime.getTemplateObject([\"\\n        return \", \"(\", \", this, arguments);\"]), call, innerFunction));\n        return new constructor(tree.location, tree.name, tree.functionKind, tree.parameterList, tree.typeAnnotation, tree.annotations, outerBody);\n      },\n      transformBlock: function(tree) {\n        var inBlock = this.inBlock_;\n        this.inBlock_ = true;\n        var rv = $traceurRuntime.superGet(this, ProperTailCallTransformer.prototype, \"transformBlock\").call(this, tree);\n        this.inBlock_ = inBlock;\n        return rv;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get ProperTailCallTransformer() {\n      return ProperTailCallTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js\")),\n      IdentifierExpression = $__1.IdentifierExpression,\n      LiteralPropertyName = $__1.LiteralPropertyName,\n      PropertyNameAssignment = $__1.PropertyNameAssignment;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/PropertyNameShorthandTransformer.js\")).ParseTreeTransformer;\n  var PropertyNameShorthandTransformer = function($__super) {\n    function PropertyNameShorthandTransformer() {\n      $traceurRuntime.superConstructor(PropertyNameShorthandTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(PropertyNameShorthandTransformer, {transformPropertyNameShorthand: function(tree) {\n        return new PropertyNameAssignment(tree.location, new LiteralPropertyName(tree.location, tree.name), new IdentifierExpression(tree.location, tree.name));\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get PropertyNameShorthandTransformer() {\n      return PropertyNameShorthandTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/outputgeneration/regexpuRewritePattern.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/outputgeneration/regexpuRewritePattern.js\";\n  var modules = {};\n  var module = {};\n  var exports = module.exports = {};\n  var require = function(id) {\n    return modules[id];\n  };\n  ;\n  (function(root) {\n    var freeExports = typeof exports == 'object' && exports;\n    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;\n    var freeGlobal = typeof global == 'object' && global;\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n      root = freeGlobal;\n    }\n    var ERRORS = {\n      'rangeOrder': 'A range\\u2019s `stop` value must be greater than or equal ' + 'to the `start` value.',\n      'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'\n    };\n    var HIGH_SURROGATE_MIN = 0xD800;\n    var HIGH_SURROGATE_MAX = 0xDBFF;\n    var LOW_SURROGATE_MIN = 0xDC00;\n    var LOW_SURROGATE_MAX = 0xDFFF;\n    var regexNull = /\\\\x00([^0123456789]|$)/g;\n    var object = {};\n    var hasOwnProperty = object.hasOwnProperty;\n    var extend = function(destination, source) {\n      var key;\n      for (key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          destination[key] = source[key];\n        }\n      }\n      return destination;\n    };\n    var forEach = function(array, callback) {\n      var index = -1;\n      var length = array.length;\n      while (++index < length) {\n        callback(array[index], index);\n      }\n    };\n    var toString = object.toString;\n    var isArray = function(value) {\n      return toString.call(value) == '[object Array]';\n    };\n    var isNumber = function(value) {\n      return typeof value == 'number' || toString.call(value) == '[object Number]';\n    };\n    var zeroes = '0000';\n    var pad = function(number, totalCharacters) {\n      var string = String(number);\n      return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;\n    };\n    var hex = function(number) {\n      return Number(number).toString(16).toUpperCase();\n    };\n    var slice = [].slice;\n    var dataFromCodePoints = function(codePoints) {\n      var index = -1;\n      var length = codePoints.length;\n      var max = length - 1;\n      var result = [];\n      var isStart = true;\n      var tmp;\n      var previous = 0;\n      while (++index < length) {\n        tmp = codePoints[index];\n        if (isStart) {\n          result.push(tmp);\n          previous = tmp;\n          isStart = false;\n        } else {\n          if (tmp == previous + 1) {\n            if (index != max) {\n              previous = tmp;\n              continue;\n            } else {\n              isStart = true;\n              result.push(tmp + 1);\n            }\n          } else {\n            result.push(previous + 1, tmp);\n            previous = tmp;\n          }\n        }\n      }\n      if (!isStart) {\n        result.push(tmp + 1);\n      }\n      return result;\n    };\n    var dataRemove = function(data, codePoint) {\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          if (codePoint == start) {\n            if (end == start + 1) {\n              data.splice(index, 2);\n              return data;\n            } else {\n              data[index] = codePoint + 1;\n              return data;\n            }\n          } else if (codePoint == end - 1) {\n            data[index + 1] = codePoint;\n            return data;\n          } else {\n            data.splice(index, 2, start, codePoint, codePoint + 1, end);\n            return data;\n          }\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataRemoveRange = function(data, rangeStart, rangeEnd) {\n      if (rangeEnd < rangeStart) {\n        throw Error(ERRORS.rangeOrder);\n      }\n      var index = 0;\n      var start;\n      var end;\n      while (index < data.length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start > rangeEnd) {\n          return data;\n        }\n        if (rangeStart <= start && rangeEnd >= end) {\n          data.splice(index, 2);\n          continue;\n        }\n        if (rangeStart >= start && rangeEnd < end) {\n          if (rangeStart == start) {\n            data[index] = rangeEnd + 1;\n            data[index + 1] = end + 1;\n            return data;\n          }\n          data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);\n          return data;\n        }\n        if (rangeStart >= start && rangeStart <= end) {\n          data[index + 1] = rangeStart;\n        } else if (rangeEnd >= start && rangeEnd <= end) {\n          data[index] = rangeEnd + 1;\n          return data;\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataAdd = function(data, codePoint) {\n      var index = 0;\n      var start;\n      var end;\n      var lastIndex = null;\n      var length = data.length;\n      if (codePoint < 0x0 || codePoint > 0x10FFFF) {\n        throw RangeError(ERRORS.codePointRange);\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          return data;\n        }\n        if (codePoint == start - 1) {\n          data[index] = codePoint;\n          return data;\n        }\n        if (start > codePoint) {\n          data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);\n          return data;\n        }\n        if (codePoint == end) {\n          if (codePoint + 1 == data[index + 2]) {\n            data.splice(index, 4, start, data[index + 3]);\n            return data;\n          }\n          data[index + 1] = codePoint + 1;\n          return data;\n        }\n        lastIndex = index;\n        index += 2;\n      }\n      data.push(codePoint, codePoint + 1);\n      return data;\n    };\n    var dataAddData = function(dataA, dataB) {\n      var index = 0;\n      var start;\n      var end;\n      var data = dataA.slice();\n      var length = dataB.length;\n      while (index < length) {\n        start = dataB[index];\n        end = dataB[index + 1] - 1;\n        if (start == end) {\n          data = dataAdd(data, start);\n        } else {\n          data = dataAddRange(data, start, end);\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataRemoveData = function(dataA, dataB) {\n      var index = 0;\n      var start;\n      var end;\n      var data = dataA.slice();\n      var length = dataB.length;\n      while (index < length) {\n        start = dataB[index];\n        end = dataB[index + 1] - 1;\n        if (start == end) {\n          data = dataRemove(data, start);\n        } else {\n          data = dataRemoveRange(data, start, end);\n        }\n        index += 2;\n      }\n      return data;\n    };\n    var dataAddRange = function(data, rangeStart, rangeEnd) {\n      if (rangeEnd < rangeStart) {\n        throw Error(ERRORS.rangeOrder);\n      }\n      if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {\n        throw RangeError(ERRORS.codePointRange);\n      }\n      var index = 0;\n      var start;\n      var end;\n      var added = false;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (added) {\n          if (start == rangeEnd + 1) {\n            data.splice(index - 1, 2);\n            return data;\n          }\n          if (start > rangeEnd) {\n            return data;\n          }\n          if (start >= rangeStart && start <= rangeEnd) {\n            if (end > rangeStart && end - 1 <= rangeEnd) {\n              data.splice(index, 2);\n              index -= 2;\n            } else {\n              data.splice(index - 1, 2);\n              index -= 2;\n            }\n          }\n        } else if (start == rangeEnd + 1) {\n          data[index] = rangeStart;\n          return data;\n        } else if (start > rangeEnd) {\n          data.splice(index, 0, rangeStart, rangeEnd + 1);\n          return data;\n        } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {\n          return data;\n        } else if ((rangeStart >= start && rangeStart < end) || end == rangeStart) {\n          data[index + 1] = rangeEnd + 1;\n          added = true;\n        } else if (rangeStart <= start && rangeEnd + 1 >= end) {\n          data[index] = rangeStart;\n          data[index + 1] = rangeEnd + 1;\n          added = true;\n        }\n        index += 2;\n      }\n      if (!added) {\n        data.push(rangeStart, rangeEnd + 1);\n      }\n      return data;\n    };\n    var dataContains = function(data, codePoint) {\n      var index = 0;\n      var length = data.length;\n      var start = data[index];\n      var end = data[length - 1];\n      if (length >= 2) {\n        if (codePoint < start || codePoint > end) {\n          return false;\n        }\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        if (codePoint >= start && codePoint < end) {\n          return true;\n        }\n        index += 2;\n      }\n      return false;\n    };\n    var dataIntersection = function(data, codePoints) {\n      var index = 0;\n      var length = codePoints.length;\n      var codePoint;\n      var result = [];\n      while (index < length) {\n        codePoint = codePoints[index];\n        if (dataContains(data, codePoint)) {\n          result.push(codePoint);\n        }\n        ++index;\n      }\n      return dataFromCodePoints(result);\n    };\n    var dataIsEmpty = function(data) {\n      return !data.length;\n    };\n    var dataIsSingleton = function(data) {\n      return data.length == 2 && data[0] + 1 == data[1];\n    };\n    var dataToArray = function(data) {\n      var index = 0;\n      var start;\n      var end;\n      var result = [];\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1];\n        while (start < end) {\n          result.push(start);\n          ++start;\n        }\n        index += 2;\n      }\n      return result;\n    };\n    var floor = Math.floor;\n    var highSurrogate = function(codePoint) {\n      return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);\n    };\n    var lowSurrogate = function(codePoint) {\n      return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);\n    };\n    var stringFromCharCode = String.fromCharCode;\n    var codePointToString = function(codePoint) {\n      var string;\n      if (codePoint == 0x09) {\n        string = '\\\\t';\n      } else if (codePoint == 0x0A) {\n        string = '\\\\n';\n      } else if (codePoint == 0x0C) {\n        string = '\\\\f';\n      } else if (codePoint == 0x0D) {\n        string = '\\\\r';\n      } else if (codePoint == 0x5C) {\n        string = '\\\\\\\\';\n      } else if (codePoint == 0x24 || (codePoint >= 0x28 && codePoint <= 0x2B) || codePoint == 0x2D || codePoint == 0x2E || codePoint == 0x3F || (codePoint >= 0x5B && codePoint <= 0x5E) || (codePoint >= 0x7B && codePoint <= 0x7D)) {\n        string = '\\\\' + stringFromCharCode(codePoint);\n      } else if (codePoint >= 0x20 && codePoint <= 0x7E) {\n        string = stringFromCharCode(codePoint);\n      } else if (codePoint <= 0xFF) {\n        string = '\\\\x' + pad(hex(codePoint), 2);\n      } else {\n        string = '\\\\u' + pad(hex(codePoint), 4);\n      }\n      return string;\n    };\n    var symbolToCodePoint = function(symbol) {\n      var length = symbol.length;\n      var first = symbol.charCodeAt(0);\n      var second;\n      if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {\n        second = symbol.charCodeAt(1);\n        return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n      }\n      return first;\n    };\n    var createBMPCharacterClasses = function(data) {\n      var result = '';\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      if (dataIsSingleton(data)) {\n        return codePointToString(data[0]);\n      }\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start == end) {\n          result += codePointToString(start);\n        } else if (start + 1 == end) {\n          result += codePointToString(start) + codePointToString(end);\n        } else {\n          result += codePointToString(start) + '-' + codePointToString(end);\n        }\n        index += 2;\n      }\n      return '[' + result + ']';\n    };\n    var splitAtBMP = function(data) {\n      var loneHighSurrogates = [];\n      var loneLowSurrogates = [];\n      var bmp = [];\n      var astral = [];\n      var index = 0;\n      var start;\n      var end;\n      var length = data.length;\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        if (start < HIGH_SURROGATE_MIN) {\n          if (end < HIGH_SURROGATE_MIN) {\n            bmp.push(start, end + 1);\n          }\n          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);\n          }\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            bmp.push(start, HIGH_SURROGATE_MIN);\n            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {\n          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, end + 1);\n          }\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);\n            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {\n          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {\n            loneLowSurrogates.push(start, end + 1);\n          }\n          if (end > LOW_SURROGATE_MAX) {\n            loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);\n            if (end <= 0xFFFF) {\n              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);\n            } else {\n              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);\n              astral.push(0xFFFF + 1, end + 1);\n            }\n          }\n        } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {\n          if (end <= 0xFFFF) {\n            bmp.push(start, end + 1);\n          } else {\n            bmp.push(start, 0xFFFF + 1);\n            astral.push(0xFFFF + 1, end + 1);\n          }\n        } else {\n          astral.push(start, end + 1);\n        }\n        index += 2;\n      }\n      return {\n        'loneHighSurrogates': loneHighSurrogates,\n        'loneLowSurrogates': loneLowSurrogates,\n        'bmp': bmp,\n        'astral': astral\n      };\n    };\n    var optimizeSurrogateMappings = function(surrogateMappings) {\n      var result = [];\n      var tmpLow = [];\n      var addLow = false;\n      var mapping;\n      var nextMapping;\n      var highSurrogates;\n      var lowSurrogates;\n      var nextHighSurrogates;\n      var nextLowSurrogates;\n      var index = -1;\n      var length = surrogateMappings.length;\n      while (++index < length) {\n        mapping = surrogateMappings[index];\n        nextMapping = surrogateMappings[index + 1];\n        if (!nextMapping) {\n          result.push(mapping);\n          continue;\n        }\n        highSurrogates = mapping[0];\n        lowSurrogates = mapping[1];\n        nextHighSurrogates = nextMapping[0];\n        nextLowSurrogates = nextMapping[1];\n        tmpLow = lowSurrogates;\n        while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {\n          if (dataIsSingleton(nextLowSurrogates)) {\n            tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);\n          } else {\n            tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);\n          }\n          ++index;\n          mapping = surrogateMappings[index];\n          highSurrogates = mapping[0];\n          lowSurrogates = mapping[1];\n          nextMapping = surrogateMappings[index + 1];\n          nextHighSurrogates = nextMapping && nextMapping[0];\n          nextLowSurrogates = nextMapping && nextMapping[1];\n          addLow = true;\n        }\n        result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);\n        addLow = false;\n      }\n      return optimizeByLowSurrogates(result);\n    };\n    var optimizeByLowSurrogates = function(surrogateMappings) {\n      if (surrogateMappings.length == 1) {\n        return surrogateMappings;\n      }\n      var index = -1;\n      var innerIndex = -1;\n      while (++index < surrogateMappings.length) {\n        var mapping = surrogateMappings[index];\n        var lowSurrogates = mapping[1];\n        var lowSurrogateStart = lowSurrogates[0];\n        var lowSurrogateEnd = lowSurrogates[1];\n        innerIndex = index;\n        while (++innerIndex < surrogateMappings.length) {\n          var otherMapping = surrogateMappings[innerIndex];\n          var otherLowSurrogates = otherMapping[1];\n          var otherLowSurrogateStart = otherLowSurrogates[0];\n          var otherLowSurrogateEnd = otherLowSurrogates[1];\n          if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {\n            if (dataIsSingleton(otherMapping[0])) {\n              mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);\n            } else {\n              mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);\n            }\n            surrogateMappings.splice(innerIndex, 1);\n            --innerIndex;\n          }\n        }\n      }\n      return surrogateMappings;\n    };\n    var surrogateSet = function(data) {\n      if (!data.length) {\n        return [];\n      }\n      var index = 0;\n      var start;\n      var end;\n      var startHigh;\n      var startLow;\n      var prevStartHigh = 0;\n      var prevEndHigh = 0;\n      var tmpLow = [];\n      var endHigh;\n      var endLow;\n      var surrogateMappings = [];\n      var length = data.length;\n      var dataHigh = [];\n      while (index < length) {\n        start = data[index];\n        end = data[index + 1] - 1;\n        startHigh = highSurrogate(start);\n        startLow = lowSurrogate(start);\n        endHigh = highSurrogate(end);\n        endLow = lowSurrogate(end);\n        var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;\n        var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;\n        var complete = false;\n        if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {\n          surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);\n          complete = true;\n        } else {\n          surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);\n        }\n        if (!complete && startHigh + 1 < endHigh) {\n          if (endsWithHighestLowSurrogate) {\n            surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n            complete = true;\n          } else {\n            surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);\n          }\n        }\n        if (!complete) {\n          surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);\n        }\n        prevStartHigh = startHigh;\n        prevEndHigh = endHigh;\n        index += 2;\n      }\n      return optimizeSurrogateMappings(surrogateMappings);\n    };\n    var createSurrogateCharacterClasses = function(surrogateMappings) {\n      var result = [];\n      forEach(surrogateMappings, function(surrogateMapping) {\n        var highSurrogates = surrogateMapping[0];\n        var lowSurrogates = surrogateMapping[1];\n        result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));\n      });\n      return result.join('|');\n    };\n    var createCharacterClassesFromData = function(data, bmpOnly) {\n      var result = [];\n      var parts = splitAtBMP(data);\n      var loneHighSurrogates = parts.loneHighSurrogates;\n      var loneLowSurrogates = parts.loneLowSurrogates;\n      var bmp = parts.bmp;\n      var astral = parts.astral;\n      var hasAstral = !dataIsEmpty(parts.astral);\n      var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);\n      var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);\n      var surrogateMappings = surrogateSet(astral);\n      if (bmpOnly) {\n        bmp = dataAddData(bmp, loneHighSurrogates);\n        hasLoneHighSurrogates = false;\n        bmp = dataAddData(bmp, loneLowSurrogates);\n        hasLoneLowSurrogates = false;\n      }\n      if (!dataIsEmpty(bmp)) {\n        result.push(createBMPCharacterClasses(bmp));\n      }\n      if (surrogateMappings.length) {\n        result.push(createSurrogateCharacterClasses(surrogateMappings));\n      }\n      if (hasLoneHighSurrogates) {\n        result.push(createBMPCharacterClasses(loneHighSurrogates) + '(?![\\\\uDC00-\\\\uDFFF])');\n      }\n      if (hasLoneLowSurrogates) {\n        result.push('(?:[^\\\\uD800-\\\\uDBFF]|^)' + createBMPCharacterClasses(loneLowSurrogates));\n      }\n      return result.join('|');\n    };\n    var regenerate = function(value) {\n      if (arguments.length > 1) {\n        value = slice.call(arguments);\n      }\n      if (this instanceof regenerate) {\n        this.data = [];\n        return value ? this.add(value) : this;\n      }\n      return (new regenerate).add(value);\n    };\n    regenerate.version = '1.2.0';\n    var proto = regenerate.prototype;\n    extend(proto, {\n      'add': function(value) {\n        var $this = this;\n        if (value == null) {\n          return $this;\n        }\n        if (value instanceof regenerate) {\n          $this.data = dataAddData($this.data, value.data);\n          return $this;\n        }\n        if (arguments.length > 1) {\n          value = slice.call(arguments);\n        }\n        if (isArray(value)) {\n          forEach(value, function(item) {\n            $this.add(item);\n          });\n          return $this;\n        }\n        $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n        return $this;\n      },\n      'remove': function(value) {\n        var $this = this;\n        if (value == null) {\n          return $this;\n        }\n        if (value instanceof regenerate) {\n          $this.data = dataRemoveData($this.data, value.data);\n          return $this;\n        }\n        if (arguments.length > 1) {\n          value = slice.call(arguments);\n        }\n        if (isArray(value)) {\n          forEach(value, function(item) {\n            $this.remove(item);\n          });\n          return $this;\n        }\n        $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));\n        return $this;\n      },\n      'addRange': function(start, end) {\n        var $this = this;\n        $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));\n        return $this;\n      },\n      'removeRange': function(start, end) {\n        var $this = this;\n        var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);\n        var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);\n        $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);\n        return $this;\n      },\n      'intersection': function(argument) {\n        var $this = this;\n        var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;\n        $this.data = dataIntersection($this.data, array);\n        return $this;\n      },\n      'contains': function(codePoint) {\n        return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));\n      },\n      'clone': function() {\n        var set = new regenerate;\n        set.data = this.data.slice(0);\n        return set;\n      },\n      'toString': function(options) {\n        var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false);\n        return result.replace(regexNull, '\\\\0$1');\n      },\n      'toRegExp': function(flags) {\n        return RegExp(this.toString(), flags || '');\n      },\n      'valueOf': function() {\n        return dataToArray(this.data);\n      }\n    });\n    proto.toArray = proto.valueOf;\n    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n      define(function() {\n        return regenerate;\n      });\n    } else if (freeExports && !freeExports.nodeType) {\n      if (freeModule) {\n        freeModule.exports = regenerate;\n      } else {\n        freeExports.regenerate = regenerate;\n      }\n    } else {\n      root.regenerate = regenerate;\n    }\n  }((void 0)));\n  modules['regenerate'] = module.exports || window.regenerate;\n  ;\n  (function() {\n    'use strict';\n    var objectTypes = {\n      'function': true,\n      'object': true\n    };\n    var root = (objectTypes[typeof window] && window) || this;\n    var oldRoot = root;\n    var freeExports = objectTypes[typeof exports] && exports;\n    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n    var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n      root = freeGlobal;\n    }\n    var stringFromCharCode = String.fromCharCode;\n    var floor = Math.floor;\n    function fromCodePoint() {\n      var MAX_SIZE = 0x4000;\n      var codeUnits = [];\n      var highSurrogate;\n      var lowSurrogate;\n      var index = -1;\n      var length = arguments.length;\n      if (!length) {\n        return '';\n      }\n      var result = '';\n      while (++index < length) {\n        var codePoint = Number(arguments[index]);\n        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n          throw RangeError('Invalid code point: ' + codePoint);\n        }\n        if (codePoint <= 0xFFFF) {\n          codeUnits.push(codePoint);\n        } else {\n          codePoint -= 0x10000;\n          highSurrogate = (codePoint >> 10) + 0xD800;\n          lowSurrogate = (codePoint % 0x400) + 0xDC00;\n          codeUnits.push(highSurrogate, lowSurrogate);\n        }\n        if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n          result += stringFromCharCode.apply(null, codeUnits);\n          codeUnits.length = 0;\n        }\n      }\n      return result;\n    }\n    function assertType(type, expected) {\n      if (expected.indexOf('|') == -1) {\n        if (type == expected) {\n          return;\n        }\n        throw Error('Invalid node type: ' + type);\n      }\n      expected = assertType.hasOwnProperty(expected) ? assertType[expected] : (assertType[expected] = RegExp('^(?:' + expected + ')$'));\n      if (expected.test(type)) {\n        return;\n      }\n      throw Error('Invalid node type: ' + type);\n    }\n    function generate(node) {\n      var type = node.type;\n      if (generate.hasOwnProperty(type) && typeof generate[type] == 'function') {\n        return generate[type](node);\n      }\n      throw Error('Invalid node type: ' + type);\n    }\n    function generateAlternative(node) {\n      assertType(node.type, 'alternative');\n      var terms = node.body,\n          length = terms ? terms.length : 0;\n      if (length == 1) {\n        return generateTerm(terms[0]);\n      } else {\n        var i = -1,\n            result = '';\n        while (++i < length) {\n          result += generateTerm(terms[i]);\n        }\n        return result;\n      }\n    }\n    function generateAnchor(node) {\n      assertType(node.type, 'anchor');\n      switch (node.kind) {\n        case 'start':\n          return '^';\n        case 'end':\n          return '$';\n        case 'boundary':\n          return '\\\\b';\n        case 'not-boundary':\n          return '\\\\B';\n        default:\n          throw Error('Invalid assertion');\n      }\n    }\n    function generateAtom(node) {\n      assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');\n      return generate(node);\n    }\n    function generateCharacterClass(node) {\n      assertType(node.type, 'characterClass');\n      var classRanges = node.body,\n          length = classRanges ? classRanges.length : 0;\n      var i = -1,\n          result = '[';\n      if (node.negative) {\n        result += '^';\n      }\n      while (++i < length) {\n        result += generateClassAtom(classRanges[i]);\n      }\n      result += ']';\n      return result;\n    }\n    function generateCharacterClassEscape(node) {\n      assertType(node.type, 'characterClassEscape');\n      return '\\\\' + node.value;\n    }\n    function generateCharacterClassRange(node) {\n      assertType(node.type, 'characterClassRange');\n      var min = node.min,\n          max = node.max;\n      if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {\n        throw Error('Invalid character class range');\n      }\n      return generateClassAtom(min) + '-' + generateClassAtom(max);\n    }\n    function generateClassAtom(node) {\n      assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');\n      return generate(node);\n    }\n    function generateDisjunction(node) {\n      assertType(node.type, 'disjunction');\n      var body = node.body,\n          length = body ? body.length : 0;\n      if (length == 0) {\n        throw Error('No body');\n      } else if (length == 1) {\n        return generate(body[0]);\n      } else {\n        var i = -1,\n            result = '';\n        while (++i < length) {\n          if (i != 0) {\n            result += '|';\n          }\n          result += generate(body[i]);\n        }\n        return result;\n      }\n    }\n    function generateDot(node) {\n      assertType(node.type, 'dot');\n      return '.';\n    }\n    function generateGroup(node) {\n      assertType(node.type, 'group');\n      var result = '(';\n      switch (node.behavior) {\n        case 'normal':\n          break;\n        case 'ignore':\n          result += '?:';\n          break;\n        case 'lookahead':\n          result += '?=';\n          break;\n        case 'negativeLookahead':\n          result += '?!';\n          break;\n        default:\n          throw Error('Invalid behaviour: ' + node.behaviour);\n      }\n      var body = node.body,\n          length = body ? body.length : 0;\n      if (length == 1) {\n        result += generate(body[0]);\n      } else {\n        var i = -1;\n        while (++i < length) {\n          result += generate(body[i]);\n        }\n      }\n      result += ')';\n      return result;\n    }\n    function generateQuantifier(node) {\n      assertType(node.type, 'quantifier');\n      var quantifier = '',\n          min = node.min,\n          max = node.max;\n      switch (max) {\n        case undefined:\n        case null:\n          switch (min) {\n            case 0:\n              quantifier = '*';\n              break;\n            case 1:\n              quantifier = '+';\n              break;\n            default:\n              quantifier = '{' + min + ',}';\n              break;\n          }\n          break;\n        default:\n          if (min == max) {\n            quantifier = '{' + min + '}';\n          } else if (min == 0 && max == 1) {\n            quantifier = '?';\n          } else {\n            quantifier = '{' + min + ',' + max + '}';\n          }\n          break;\n      }\n      if (!node.greedy) {\n        quantifier += '?';\n      }\n      return generateAtom(node.body[0]) + quantifier;\n    }\n    function generateReference(node) {\n      assertType(node.type, 'reference');\n      return '\\\\' + node.matchIndex;\n    }\n    function generateTerm(node) {\n      assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|value');\n      return generate(node);\n    }\n    function generateValue(node) {\n      assertType(node.type, 'value');\n      var kind = node.kind,\n          codePoint = node.codePoint;\n      switch (kind) {\n        case 'controlLetter':\n          return '\\\\c' + fromCodePoint(codePoint + 64);\n        case 'hexadecimalEscape':\n          return '\\\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);\n        case 'identifier':\n          return '\\\\' + fromCodePoint(codePoint);\n        case 'null':\n          return '\\\\' + codePoint;\n        case 'octal':\n          return '\\\\' + codePoint.toString(8);\n        case 'singleEscape':\n          switch (codePoint) {\n            case 0x0008:\n              return '\\\\b';\n            case 0x009:\n              return '\\\\t';\n            case 0x00A:\n              return '\\\\n';\n            case 0x00B:\n              return '\\\\v';\n            case 0x00C:\n              return '\\\\f';\n            case 0x00D:\n              return '\\\\r';\n            default:\n              throw Error('Invalid codepoint: ' + codePoint);\n          }\n        case 'symbol':\n          return fromCodePoint(codePoint);\n        case 'unicodeEscape':\n          return '\\\\u' + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);\n        case 'unicodeCodePointEscape':\n          return '\\\\u{' + codePoint.toString(16).toUpperCase() + '}';\n        default:\n          throw Error('Unsupported node kind: ' + kind);\n      }\n    }\n    generate.alternative = generateAlternative;\n    generate.anchor = generateAnchor;\n    generate.characterClass = generateCharacterClass;\n    generate.characterClassEscape = generateCharacterClassEscape;\n    generate.characterClassRange = generateCharacterClassRange;\n    generate.disjunction = generateDisjunction;\n    generate.dot = generateDot;\n    generate.group = generateGroup;\n    generate.quantifier = generateQuantifier;\n    generate.reference = generateReference;\n    generate.value = generateValue;\n    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n      define(function() {\n        return {'generate': generate};\n      });\n    } else if (freeExports && freeModule) {\n      freeExports.generate = generate;\n    } else {\n      root.regjsgen = {'generate': generate};\n    }\n  }.call((void 0)));\n  modules['regjsgen'] = {generate: exports.generate || window.regjsgen};\n  (function() {\n    function parse(str, flags) {\n      function addRaw(node) {\n        node.raw = str.substring(node.range[0], node.range[1]);\n        return node;\n      }\n      function updateRawStart(node, start) {\n        node.range[0] = start;\n        return addRaw(node);\n      }\n      function createAnchor(kind, rawLength) {\n        return addRaw({\n          type: 'anchor',\n          kind: kind,\n          range: [pos - rawLength, pos]\n        });\n      }\n      function createValue(kind, codePoint, from, to) {\n        return addRaw({\n          type: 'value',\n          kind: kind,\n          codePoint: codePoint,\n          range: [from, to]\n        });\n      }\n      function createEscaped(kind, codePoint, value, fromOffset) {\n        fromOffset = fromOffset || 0;\n        return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);\n      }\n      function createCharacter(matches) {\n        var _char = matches[0];\n        var first = _char.charCodeAt(0);\n        if (hasUnicodeFlag) {\n          var second;\n          if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {\n            second = lookahead().charCodeAt(0);\n            if (second >= 0xDC00 && second <= 0xDFFF) {\n              pos++;\n              return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);\n            }\n          }\n        }\n        return createValue('symbol', first, pos - 1, pos);\n      }\n      function createDisjunction(alternatives, from, to) {\n        return addRaw({\n          type: 'disjunction',\n          body: alternatives,\n          range: [from, to]\n        });\n      }\n      function createDot() {\n        return addRaw({\n          type: 'dot',\n          range: [pos - 1, pos]\n        });\n      }\n      function createCharacterClassEscape(value) {\n        return addRaw({\n          type: 'characterClassEscape',\n          value: value,\n          range: [pos - 2, pos]\n        });\n      }\n      function createReference(matchIndex) {\n        return addRaw({\n          type: 'reference',\n          matchIndex: parseInt(matchIndex, 10),\n          range: [pos - 1 - matchIndex.length, pos]\n        });\n      }\n      function createGroup(behavior, disjunction, from, to) {\n        return addRaw({\n          type: 'group',\n          behavior: behavior,\n          body: disjunction,\n          range: [from, to]\n        });\n      }\n      function createQuantifier(min, max, from, to) {\n        if (to == null) {\n          from = pos - 1;\n          to = pos;\n        }\n        return addRaw({\n          type: 'quantifier',\n          min: min,\n          max: max,\n          greedy: true,\n          body: null,\n          range: [from, to]\n        });\n      }\n      function createAlternative(terms, from, to) {\n        return addRaw({\n          type: 'alternative',\n          body: terms,\n          range: [from, to]\n        });\n      }\n      function createCharacterClass(classRanges, negative, from, to) {\n        return addRaw({\n          type: 'characterClass',\n          body: classRanges,\n          negative: negative,\n          range: [from, to]\n        });\n      }\n      function createClassRange(min, max, from, to) {\n        if (min.codePoint > max.codePoint) {\n          bail('invalid range in character class', min.raw + '-' + max.raw, from, to);\n        }\n        return addRaw({\n          type: 'characterClassRange',\n          min: min,\n          max: max,\n          range: [from, to]\n        });\n      }\n      function flattenBody(body) {\n        if (body.type === 'alternative') {\n          return body.body;\n        } else {\n          return [body];\n        }\n      }\n      function isEmpty(obj) {\n        return obj.type === 'empty';\n      }\n      function incr(amount) {\n        amount = (amount || 1);\n        var res = str.substring(pos, pos + amount);\n        pos += (amount || 1);\n        return res;\n      }\n      function skip(value) {\n        if (!match(value)) {\n          bail('character', value);\n        }\n      }\n      function match(value) {\n        if (str.indexOf(value, pos) === pos) {\n          return incr(value.length);\n        }\n      }\n      function lookahead() {\n        return str[pos];\n      }\n      function current(value) {\n        return str.indexOf(value, pos) === pos;\n      }\n      function next(value) {\n        return str[pos + 1] === value;\n      }\n      function matchReg(regExp) {\n        var subStr = str.substring(pos);\n        var res = subStr.match(regExp);\n        if (res) {\n          res.range = [];\n          res.range[0] = pos;\n          incr(res[0].length);\n          res.range[1] = pos;\n        }\n        return res;\n      }\n      function parseDisjunction() {\n        var res = [],\n            from = pos;\n        res.push(parseAlternative());\n        while (match('|')) {\n          res.push(parseAlternative());\n        }\n        if (res.length === 1) {\n          return res[0];\n        }\n        return createDisjunction(res, from, pos);\n      }\n      function parseAlternative() {\n        var res = [],\n            from = pos;\n        var term;\n        while (term = parseTerm()) {\n          res.push(term);\n        }\n        if (res.length === 1) {\n          return res[0];\n        }\n        return createAlternative(res, from, pos);\n      }\n      function parseTerm() {\n        if (pos >= str.length || current('|') || current(')')) {\n          return null;\n        }\n        var anchor = parseAnchor();\n        if (anchor) {\n          return anchor;\n        }\n        var atom = parseAtom();\n        if (!atom) {\n          bail('Expected atom');\n        }\n        var quantifier = parseQuantifier() || false;\n        if (quantifier) {\n          quantifier.body = flattenBody(atom);\n          updateRawStart(quantifier, atom.range[0]);\n          return quantifier;\n        }\n        return atom;\n      }\n      function parseGroup(matchA, typeA, matchB, typeB) {\n        var type = null,\n            from = pos;\n        if (match(matchA)) {\n          type = typeA;\n        } else if (match(matchB)) {\n          type = typeB;\n        } else {\n          return false;\n        }\n        var body = parseDisjunction();\n        if (!body) {\n          bail('Expected disjunction');\n        }\n        skip(')');\n        var group = createGroup(type, flattenBody(body), from, pos);\n        if (type == 'normal') {\n          if (firstIteration) {\n            closedCaptureCounter++;\n          }\n        }\n        return group;\n      }\n      function parseAnchor() {\n        var res,\n            from = pos;\n        if (match('^')) {\n          return createAnchor('start', 1);\n        } else if (match('$')) {\n          return createAnchor('end', 1);\n        } else if (match('\\\\b')) {\n          return createAnchor('boundary', 2);\n        } else if (match('\\\\B')) {\n          return createAnchor('not-boundary', 2);\n        } else {\n          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');\n        }\n      }\n      function parseQuantifier() {\n        var res,\n            from = pos;\n        var quantifier;\n        var min,\n            max;\n        if (match('*')) {\n          quantifier = createQuantifier(0);\n        } else if (match('+')) {\n          quantifier = createQuantifier(1);\n        } else if (match('?')) {\n          quantifier = createQuantifier(0, 1);\n        } else if (res = matchReg(/^\\{([0-9]+)\\}/)) {\n          min = parseInt(res[1], 10);\n          quantifier = createQuantifier(min, min, res.range[0], res.range[1]);\n        } else if (res = matchReg(/^\\{([0-9]+),\\}/)) {\n          min = parseInt(res[1], 10);\n          quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);\n        } else if (res = matchReg(/^\\{([0-9]+),([0-9]+)\\}/)) {\n          min = parseInt(res[1], 10);\n          max = parseInt(res[2], 10);\n          if (min > max) {\n            bail('numbers out of order in {} quantifier', '', from, pos);\n          }\n          quantifier = createQuantifier(min, max, res.range[0], res.range[1]);\n        }\n        if (quantifier) {\n          if (match('?')) {\n            quantifier.greedy = false;\n            quantifier.range[1] += 1;\n          }\n        }\n        return quantifier;\n      }\n      function parseAtom() {\n        var res;\n        if (res = matchReg(/^[^^$\\\\.*+?(){[|]/)) {\n          return createCharacter(res);\n        } else if (match('.')) {\n          return createDot();\n        } else if (match('\\\\')) {\n          res = parseAtomEscape();\n          if (!res) {\n            bail('atomEscape');\n          }\n          return res;\n        } else if (res = parseCharacterClass()) {\n          return res;\n        } else {\n          return parseGroup('(?:', 'ignore', '(', 'normal');\n        }\n      }\n      function parseUnicodeSurrogatePairEscape(firstEscape) {\n        if (hasUnicodeFlag) {\n          var first,\n              second;\n          if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\\\') && next('u')) {\n            var prevPos = pos;\n            pos++;\n            var secondEscape = parseClassEscape();\n            if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {\n              firstEscape.range[1] = secondEscape.range[1];\n              firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n              firstEscape.type = 'value';\n              firstEscape.kind = 'unicodeCodePointEscape';\n              addRaw(firstEscape);\n            } else {\n              pos = prevPos;\n            }\n          }\n        }\n        return firstEscape;\n      }\n      function parseClassEscape() {\n        return parseAtomEscape(true);\n      }\n      function parseAtomEscape(insideCharacterClass) {\n        var res,\n            from = pos;\n        res = parseDecimalEscape();\n        if (res) {\n          return res;\n        }\n        if (insideCharacterClass) {\n          if (match('b')) {\n            return createEscaped('singleEscape', 0x0008, '\\\\b');\n          } else if (match('B')) {\n            bail('\\\\B not possible inside of CharacterClass', '', from);\n          }\n        }\n        res = parseCharacterEscape();\n        return res;\n      }\n      function parseDecimalEscape() {\n        var res,\n            match;\n        if (res = matchReg(/^(?!0)\\d+/)) {\n          match = res[0];\n          var refIdx = parseInt(res[0], 10);\n          if (refIdx <= closedCaptureCounter) {\n            return createReference(res[0]);\n          } else {\n            backrefDenied.push(refIdx);\n            incr(-res[0].length);\n            if (res = matchReg(/^[0-7]{1,3}/)) {\n              return createEscaped('octal', parseInt(res[0], 8), res[0], 1);\n            } else {\n              res = createCharacter(matchReg(/^[89]/));\n              return updateRawStart(res, res.range[0] - 1);\n            }\n          }\n        } else if (res = matchReg(/^[0-7]{1,3}/)) {\n          match = res[0];\n          if (/^0{1,3}$/.test(match)) {\n            return createEscaped('null', 0x0000, '0', match.length + 1);\n          } else {\n            return createEscaped('octal', parseInt(match, 8), match, 1);\n          }\n        } else if (res = matchReg(/^[dDsSwW]/)) {\n          return createCharacterClassEscape(res[0]);\n        }\n        return false;\n      }\n      function parseCharacterEscape() {\n        var res;\n        if (res = matchReg(/^[fnrtv]/)) {\n          var codePoint = 0;\n          switch (res[0]) {\n            case 't':\n              codePoint = 0x009;\n              break;\n            case 'n':\n              codePoint = 0x00A;\n              break;\n            case 'v':\n              codePoint = 0x00B;\n              break;\n            case 'f':\n              codePoint = 0x00C;\n              break;\n            case 'r':\n              codePoint = 0x00D;\n              break;\n          }\n          return createEscaped('singleEscape', codePoint, '\\\\' + res[0]);\n        } else if (res = matchReg(/^c([a-zA-Z])/)) {\n          return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);\n        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {\n          return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);\n        } else if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {\n          return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));\n        } else if (hasUnicodeFlag && (res = matchReg(/^u\\{([0-9a-fA-F]+)\\}/))) {\n          return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);\n        } else {\n          return parseIdentityEscape();\n        }\n      }\n      function isIdentifierPart(ch) {\n        var NonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]');\n        return (ch === 36) || (ch === 95) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122) || (ch >= 48 && ch <= 57) || (ch === 92) || ((ch >= 0x80) && NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n      }\n      function parseIdentityEscape() {\n        var ZWJ = '\\u200C';\n        var ZWNJ = '\\u200D';\n        var tmp;\n        if (!isIdentifierPart(lookahead())) {\n          tmp = incr();\n          return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);\n        }\n        if (match(ZWJ)) {\n          return createEscaped('identifier', 0x200C, ZWJ);\n        } else if (match(ZWNJ)) {\n          return createEscaped('identifier', 0x200D, ZWNJ);\n        }\n        return null;\n      }\n      function parseCharacterClass() {\n        var res,\n            from = pos;\n        if (res = matchReg(/^\\[\\^/)) {\n          res = parseClassRanges();\n          skip(']');\n          return createCharacterClass(res, true, from, pos);\n        } else if (match('[')) {\n          res = parseClassRanges();\n          skip(']');\n          return createCharacterClass(res, false, from, pos);\n        }\n        return null;\n      }\n      function parseClassRanges() {\n        var res;\n        if (current(']')) {\n          return [];\n        } else {\n          res = parseNonemptyClassRanges();\n          if (!res) {\n            bail('nonEmptyClassRanges');\n          }\n          return res;\n        }\n      }\n      function parseHelperClassRanges(atom) {\n        var from,\n            to,\n            res;\n        if (current('-') && !next(']')) {\n          skip('-');\n          res = parseClassAtom();\n          if (!res) {\n            bail('classAtom');\n          }\n          to = pos;\n          var classRanges = parseClassRanges();\n          if (!classRanges) {\n            bail('classRanges');\n          }\n          from = atom.range[0];\n          if (classRanges.type === 'empty') {\n            return [createClassRange(atom, res, from, to)];\n          }\n          return [createClassRange(atom, res, from, to)].concat(classRanges);\n        }\n        res = parseNonemptyClassRangesNoDash();\n        if (!res) {\n          bail('nonEmptyClassRangesNoDash');\n        }\n        return [atom].concat(res);\n      }\n      function parseNonemptyClassRanges() {\n        var atom = parseClassAtom();\n        if (!atom) {\n          bail('classAtom');\n        }\n        if (current(']')) {\n          return [atom];\n        }\n        return parseHelperClassRanges(atom);\n      }\n      function parseNonemptyClassRangesNoDash() {\n        var res = parseClassAtom();\n        if (!res) {\n          bail('classAtom');\n        }\n        if (current(']')) {\n          return res;\n        }\n        return parseHelperClassRanges(res);\n      }\n      function parseClassAtom() {\n        if (match('-')) {\n          return createCharacter('-');\n        } else {\n          return parseClassAtomNoDash();\n        }\n      }\n      function parseClassAtomNoDash() {\n        var res;\n        if (res = matchReg(/^[^\\\\\\]-]/)) {\n          return createCharacter(res[0]);\n        } else if (match('\\\\')) {\n          res = parseClassEscape();\n          if (!res) {\n            bail('classEscape');\n          }\n          return parseUnicodeSurrogatePairEscape(res);\n        }\n      }\n      function bail(message, details, from, to) {\n        from = from == null ? pos : from;\n        to = to == null ? from : to;\n        var contextStart = Math.max(0, from - 10);\n        var contextEnd = Math.min(to + 10, str.length);\n        var context = '    ' + str.substring(contextStart, contextEnd);\n        var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';\n        throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\\n' + context + '\\n' + pointer);\n      }\n      var backrefDenied = [];\n      var closedCaptureCounter = 0;\n      var firstIteration = true;\n      var hasUnicodeFlag = (flags || \"\").indexOf(\"u\") !== -1;\n      var pos = 0;\n      str = String(str);\n      if (str === '') {\n        str = '(?:)';\n      }\n      var result = parseDisjunction();\n      if (result.range[1] !== str.length) {\n        bail('Could not parse entire input - got stuck', '', result.range[1]);\n      }\n      for (var i = 0; i < backrefDenied.length; i++) {\n        if (backrefDenied[i] <= closedCaptureCounter) {\n          pos = 0;\n          firstIteration = false;\n          return parseDisjunction();\n        }\n      }\n      return result;\n    }\n    var regjsparser = {parse: parse};\n    if (typeof module !== 'undefined' && module.exports) {\n      module.exports = regjsparser;\n    } else {\n      window.regjsparser = regjsparser;\n    }\n  }());\n  modules['regjsparser'] = module.exports || window.regjsparser;\n  modules['./data/iu-mappings.json'] = ({\n    \"75\": 8490,\n    \"83\": 383,\n    \"107\": 8490,\n    \"115\": 383,\n    \"181\": 924,\n    \"197\": 8491,\n    \"383\": 83,\n    \"452\": 453,\n    \"453\": 452,\n    \"455\": 456,\n    \"456\": 455,\n    \"458\": 459,\n    \"459\": 458,\n    \"497\": 498,\n    \"498\": 497,\n    \"837\": 8126,\n    \"914\": 976,\n    \"917\": 1013,\n    \"920\": 1012,\n    \"921\": 8126,\n    \"922\": 1008,\n    \"924\": 181,\n    \"928\": 982,\n    \"929\": 1009,\n    \"931\": 962,\n    \"934\": 981,\n    \"937\": 8486,\n    \"962\": 931,\n    \"976\": 914,\n    \"977\": 1012,\n    \"981\": 934,\n    \"982\": 928,\n    \"1008\": 922,\n    \"1009\": 929,\n    \"1012\": [920, 977],\n    \"1013\": 917,\n    \"7776\": 7835,\n    \"7835\": 7776,\n    \"8126\": [837, 921],\n    \"8486\": 937,\n    \"8490\": 75,\n    \"8491\": 197,\n    \"66560\": 66600,\n    \"66561\": 66601,\n    \"66562\": 66602,\n    \"66563\": 66603,\n    \"66564\": 66604,\n    \"66565\": 66605,\n    \"66566\": 66606,\n    \"66567\": 66607,\n    \"66568\": 66608,\n    \"66569\": 66609,\n    \"66570\": 66610,\n    \"66571\": 66611,\n    \"66572\": 66612,\n    \"66573\": 66613,\n    \"66574\": 66614,\n    \"66575\": 66615,\n    \"66576\": 66616,\n    \"66577\": 66617,\n    \"66578\": 66618,\n    \"66579\": 66619,\n    \"66580\": 66620,\n    \"66581\": 66621,\n    \"66582\": 66622,\n    \"66583\": 66623,\n    \"66584\": 66624,\n    \"66585\": 66625,\n    \"66586\": 66626,\n    \"66587\": 66627,\n    \"66588\": 66628,\n    \"66589\": 66629,\n    \"66590\": 66630,\n    \"66591\": 66631,\n    \"66592\": 66632,\n    \"66593\": 66633,\n    \"66594\": 66634,\n    \"66595\": 66635,\n    \"66596\": 66636,\n    \"66597\": 66637,\n    \"66598\": 66638,\n    \"66599\": 66639,\n    \"66600\": 66560,\n    \"66601\": 66561,\n    \"66602\": 66562,\n    \"66603\": 66563,\n    \"66604\": 66564,\n    \"66605\": 66565,\n    \"66606\": 66566,\n    \"66607\": 66567,\n    \"66608\": 66568,\n    \"66609\": 66569,\n    \"66610\": 66570,\n    \"66611\": 66571,\n    \"66612\": 66572,\n    \"66613\": 66573,\n    \"66614\": 66574,\n    \"66615\": 66575,\n    \"66616\": 66576,\n    \"66617\": 66577,\n    \"66618\": 66578,\n    \"66619\": 66579,\n    \"66620\": 66580,\n    \"66621\": 66581,\n    \"66622\": 66582,\n    \"66623\": 66583,\n    \"66624\": 66584,\n    \"66625\": 66585,\n    \"66626\": 66586,\n    \"66627\": 66587,\n    \"66628\": 66588,\n    \"66629\": 66589,\n    \"66630\": 66590,\n    \"66631\": 66591,\n    \"66632\": 66592,\n    \"66633\": 66593,\n    \"66634\": 66594,\n    \"66635\": 66595,\n    \"66636\": 66596,\n    \"66637\": 66597,\n    \"66638\": 66598,\n    \"66639\": 66599,\n    \"71840\": 71872,\n    \"71841\": 71873,\n    \"71842\": 71874,\n    \"71843\": 71875,\n    \"71844\": 71876,\n    \"71845\": 71877,\n    \"71846\": 71878,\n    \"71847\": 71879,\n    \"71848\": 71880,\n    \"71849\": 71881,\n    \"71850\": 71882,\n    \"71851\": 71883,\n    \"71852\": 71884,\n    \"71853\": 71885,\n    \"71854\": 71886,\n    \"71855\": 71887,\n    \"71856\": 71888,\n    \"71857\": 71889,\n    \"71858\": 71890,\n    \"71859\": 71891,\n    \"71860\": 71892,\n    \"71861\": 71893,\n    \"71862\": 71894,\n    \"71863\": 71895,\n    \"71864\": 71896,\n    \"71865\": 71897,\n    \"71866\": 71898,\n    \"71867\": 71899,\n    \"71868\": 71900,\n    \"71869\": 71901,\n    \"71870\": 71902,\n    \"71871\": 71903,\n    \"71872\": 71840,\n    \"71873\": 71841,\n    \"71874\": 71842,\n    \"71875\": 71843,\n    \"71876\": 71844,\n    \"71877\": 71845,\n    \"71878\": 71846,\n    \"71879\": 71847,\n    \"71880\": 71848,\n    \"71881\": 71849,\n    \"71882\": 71850,\n    \"71883\": 71851,\n    \"71884\": 71852,\n    \"71885\": 71853,\n    \"71886\": 71854,\n    \"71887\": 71855,\n    \"71888\": 71856,\n    \"71889\": 71857,\n    \"71890\": 71858,\n    \"71891\": 71859,\n    \"71892\": 71860,\n    \"71893\": 71861,\n    \"71894\": 71862,\n    \"71895\": 71863,\n    \"71896\": 71864,\n    \"71897\": 71865,\n    \"71898\": 71866,\n    \"71899\": 71867,\n    \"71900\": 71868,\n    \"71901\": 71869,\n    \"71902\": 71870,\n    \"71903\": 71871\n  });\n  var regenerate = require('regenerate');\n  exports.REGULAR = {\n    'd': regenerate().addRange(0x30, 0x39),\n    'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF),\n    's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF),\n    'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)\n  };\n  exports.UNICODE = {\n    'd': regenerate().addRange(0x30, 0x39),\n    'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),\n    's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),\n    'w': regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    'W': regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)\n  };\n  exports.UNICODE_IGNORE_CASE = {\n    'd': regenerate().addRange(0x30, 0x39),\n    'D': regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF),\n    's': regenerate(0x20, 0xA0, 0x1680, 0x180E, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029),\n    'S': regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x180D).addRange(0x180F, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF),\n    'w': regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A),\n    'W': regenerate(0x4B, 0x53, 0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)\n  };\n  modules['./data/character-class-escape-sets.js'] = {\n    REGULAR: exports.REGULAR,\n    UNICODE: exports.UNICODE,\n    UNICODE_IGNORE_CASE: exports.UNICODE_IGNORE_CASE\n  };\n  var generate = require('regjsgen').generate;\n  var parse = require('regjsparser').parse;\n  var regenerate = require('regenerate');\n  var iuMappings = require('./data/iu-mappings.json');\n  var ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n  function getCharacterClassEscapeSet(character) {\n    if (unicode) {\n      if (ignoreCase) {\n        return ESCAPE_SETS.UNICODE_IGNORE_CASE[character];\n      }\n      return ESCAPE_SETS.UNICODE[character];\n    }\n    return ESCAPE_SETS.REGULAR[character];\n  }\n  var object = {};\n  var hasOwnProperty = object.hasOwnProperty;\n  function has(object, property) {\n    return hasOwnProperty.call(object, property);\n  }\n  var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n  var BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n  var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);\n  var DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);\n  regenerate.prototype.iuAddRange = function(min, max) {\n    var $this = this;\n    do {\n      var folded = caseFold(min);\n      if (folded) {\n        $this.add(folded);\n      }\n    } while (++min <= max);\n    return $this;\n  };\n  function assign(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  function update(item, pattern) {\n    var tree = parse(pattern, '');\n    switch (tree.type) {\n      case 'characterClass':\n      case 'group':\n      case 'value':\n        break;\n      default:\n        tree = wrap(tree, pattern);\n    }\n    assign(item, tree);\n  }\n  function wrap(tree, pattern) {\n    return {\n      'type': 'group',\n      'behavior': 'ignore',\n      'body': [tree],\n      'raw': '(?:' + pattern + ')'\n    };\n  }\n  function caseFold(codePoint) {\n    return has(iuMappings, codePoint) ? iuMappings[codePoint] : false;\n  }\n  var ignoreCase = false;\n  var unicode = false;\n  function processCharacterClass(characterClassItem) {\n    var set = regenerate();\n    var body = characterClassItem.body.forEach(function(item) {\n      switch (item.type) {\n        case 'value':\n          set.add(item.codePoint);\n          if (ignoreCase && unicode) {\n            var folded = caseFold(item.codePoint);\n            if (folded) {\n              set.add(folded);\n            }\n          }\n          break;\n        case 'characterClassRange':\n          var min = item.min.codePoint;\n          var max = item.max.codePoint;\n          set.addRange(min, max);\n          if (ignoreCase && unicode) {\n            set.iuAddRange(min, max);\n          }\n          break;\n        case 'characterClassEscape':\n          set.add(getCharacterClassEscapeSet(item.value));\n          break;\n        default:\n          throw Error('Unknown term type: ' + item.type);\n      }\n    });\n    if (characterClassItem.negative) {\n      set = (unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n    }\n    update(characterClassItem, set.toString());\n    return characterClassItem;\n  }\n  function processTerm(item) {\n    switch (item.type) {\n      case 'dot':\n        update(item, (unicode ? DOT_SET_UNICODE : DOT_SET).toString());\n        break;\n      case 'characterClass':\n        item = processCharacterClass(item);\n        break;\n      case 'characterClassEscape':\n        update(item, getCharacterClassEscapeSet(item.value).toString());\n        break;\n      case 'alternative':\n      case 'disjunction':\n      case 'group':\n      case 'quantifier':\n        item.body = item.body.map(processTerm);\n        break;\n      case 'value':\n        var codePoint = item.codePoint;\n        var set = regenerate(codePoint);\n        if (ignoreCase && unicode) {\n          var folded = caseFold(codePoint);\n          if (folded) {\n            set.add(folded);\n          }\n        }\n        update(item, set.toString());\n        break;\n      case 'anchor':\n      case 'empty':\n      case 'group':\n      case 'reference':\n        break;\n      default:\n        throw Error('Unknown term type: ' + item.type);\n    }\n    return item;\n  }\n  ;\n  module.exports = function(pattern, flags) {\n    var tree = parse(pattern, flags);\n    ignoreCase = flags ? flags.indexOf('i') > -1 : false;\n    unicode = flags ? flags.indexOf('u') > -1 : false;\n    assign(tree, processTerm(tree));\n    return generate(tree);\n  };\n  var regexpuRewritePattern = module.exports;\n  return {get regexpuRewritePattern() {\n      return regexpuRewritePattern;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\")).ParseTreeTransformer;\n  var LiteralExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\")).LiteralExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\")).LiteralToken;\n  var REGULAR_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\")).REGULAR_EXPRESSION;\n  var regexpuRewritePattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../outputgeneration/regexpuRewritePattern.js\", \"traceur@0.0.111/src/codegeneration/RegularExpressionTransformer.js\")).regexpuRewritePattern;\n  var RegularExpressionTransformer = function($__super) {\n    function RegularExpressionTransformer() {\n      $traceurRuntime.superConstructor(RegularExpressionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(RegularExpressionTransformer, {transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (token.type === REGULAR_EXPRESSION) {\n          var value = token.value;\n          var lastIndex = value.lastIndexOf('/');\n          var pattern = value.slice(1, lastIndex);\n          var flags = value.slice(lastIndex + 1);\n          if (flags.indexOf('u') !== -1) {\n            var result = '/' + regexpuRewritePattern(pattern, flags) + '/' + flags.replace('u', '');\n            return new LiteralExpression(tree.location, new LiteralToken(REGULAR_EXPRESSION, result, token.location));\n          }\n        }\n        return tree;\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get RegularExpressionTransformer() {\n      return RegularExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\";\n  var FormalParameterList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\")).FormalParameterList;\n  var ParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParameterTransformer.js\", \"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\")).ParameterTransformer;\n  var createIdentifierToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\")).createIdentifierToken;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/RestParameterTransformer.js\")).parseStatement;\n  function hasRestParameter(parameterList) {\n    var parameters = parameterList.parameters;\n    return parameters.length > 0 && parameters[parameters.length - 1].isRestParameter();\n  }\n  function getRestParameterLiteralToken(parameterList) {\n    var parameters = parameterList.parameters;\n    return parameters[parameters.length - 1].parameter.identifier.identifierToken;\n  }\n  var RestParameterTransformer = function($__super) {\n    function RestParameterTransformer() {\n      $traceurRuntime.superConstructor(RestParameterTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(RestParameterTransformer, {transformFormalParameterList: function(tree) {\n        var transformed = $traceurRuntime.superGet(this, RestParameterTransformer.prototype, \"transformFormalParameterList\").call(this, tree);\n        if (hasRestParameter(transformed)) {\n          var parametersWithoutRestParam = new FormalParameterList(transformed.location, transformed.parameters.slice(0, -1));\n          var startIndex = transformed.parameters.length - 1;\n          var i = createIdentifierToken(this.getTempIdentifier());\n          var name = getRestParameterLiteralToken(transformed);\n          var loop;\n          if (startIndex) {\n            loop = parseStatement($traceurRuntime.getTemplateObject([\"\\n            for (var \", \" = [], \", \" = \", \";\\n                 \", \" < arguments.length; \", \"++)\\n              \", \"[\", \" - \", \"] = arguments[\", \"];\"]), name, i, startIndex, i, i, name, i, startIndex, i);\n          } else {\n            loop = parseStatement($traceurRuntime.getTemplateObject([\"\\n            for (var \", \" = [], \", \" = 0;\\n                 \", \" < arguments.length; \", \"++)\\n              \", \"[\", \"] = arguments[\", \"];\"]), name, i, i, i, name, i, i);\n          }\n          this.parameterStatements.push(loop);\n          return parametersWithoutRestParam;\n        }\n        return transformed;\n      }}, {}, $__super);\n  }(ParameterTransformer);\n  return {get RestParameterTransformer() {\n      return RestParameterTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/PredefinedName.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")),\n      APPLY = $__3.APPLY,\n      BIND = $__3.BIND,\n      FUNCTION = $__3.FUNCTION,\n      PROTOTYPE = $__3.PROTOTYPE;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")),\n      MEMBER_EXPRESSION = $__4.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__4.MEMBER_LOOKUP_EXPRESSION,\n      SPREAD_EXPRESSION = $__4.SPREAD_EXPRESSION;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")).Script;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")).TempVarTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")).default;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")),\n      createArgumentList = $__8.createArgumentList,\n      createArrayLiteral = $__8.createArrayLiteral,\n      createAssignmentExpression = $__8.createAssignmentExpression,\n      createCallExpression = $__8.createCallExpression,\n      createEmptyArgumentList = $__8.createEmptyArgumentList,\n      createIdentifierExpression = $__8.createIdentifierExpression,\n      createMemberExpression = $__8.createMemberExpression,\n      createMemberLookupExpression = $__8.createMemberLookupExpression,\n      createNewExpression = $__8.createNewExpression,\n      createNullLiteral = $__8.createNullLiteral,\n      createParenExpression = $__8.createParenExpression,\n      createVoid0 = $__8.createVoid0;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")),\n      parseExpression = $__9.parseExpression,\n      parseStatement = $__9.parseStatement;\n  var prependStatements = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PrependStatements.js\", \"traceur@0.0.111/src/codegeneration/SpreadTransformer.js\")).prependStatements;\n  function hasSpreadMember(trees) {\n    return trees.some(function(tree) {\n      return tree && tree.type === SPREAD_EXPRESSION;\n    });\n  }\n  var SpreadTransformer = function($__super) {\n    function SpreadTransformer() {\n      $traceurRuntime.superConstructor(SpreadTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(SpreadTransformer, {\n      createArrayFromElements_: function(elements) {\n        var length = elements.length;\n        var args = [];\n        var lastArray;\n        for (var i = 0; i < length; i++) {\n          if (elements[i] && elements[i].type === SPREAD_EXPRESSION) {\n            if (lastArray) {\n              args.push(createArrayLiteral(lastArray));\n              lastArray = null;\n            }\n            args.push(this.transformAny(elements[i].expression));\n          } else {\n            if (!lastArray)\n              lastArray = [];\n            lastArray.push(this.transformAny(elements[i]));\n          }\n        }\n        if (lastArray)\n          args.push(createArrayLiteral(lastArray));\n        var spread = this.getRuntimeExpression('spread');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), spread, createArgumentList(args));\n      },\n      desugarCallSpread_: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        var functionObject,\n            contextObject;\n        this.pushTempScope();\n        if (operand.type === MEMBER_EXPRESSION) {\n          var tempIdent = createIdentifierExpression(this.addTempVar());\n          var parenExpression = createParenExpression(createAssignmentExpression(tempIdent, operand.operand));\n          var memberName = operand.memberName;\n          contextObject = tempIdent;\n          functionObject = createMemberExpression(parenExpression, memberName);\n        } else if (tree.operand.type === MEMBER_LOOKUP_EXPRESSION) {\n          var tempIdent$__1 = createIdentifierExpression(this.addTempVar());\n          var parenExpression$__2 = createParenExpression(createAssignmentExpression(tempIdent$__1, operand.operand));\n          var memberExpression = this.transformAny(operand.memberExpression);\n          contextObject = tempIdent$__1;\n          functionObject = createMemberLookupExpression(parenExpression$__2, memberExpression);\n        } else {\n          contextObject = createVoid0();\n          functionObject = operand;\n        }\n        this.popTempScope();\n        var arrayExpression = this.createArrayFromElements_(tree.args.args);\n        return createCallExpression(createMemberExpression(functionObject, APPLY), createArgumentList([contextObject, arrayExpression]));\n      },\n      desugarNewSpread_: function(tree) {\n        var arrayExpression = $traceurRuntime.spread([createNullLiteral()], tree.args.args);\n        arrayExpression = this.createArrayFromElements_(arrayExpression);\n        return createNewExpression(createParenExpression(createCallExpression(createMemberExpression(FUNCTION, PROTOTYPE, BIND, APPLY), createArgumentList([this.transformAny(tree.operand), arrayExpression]))), createEmptyArgumentList());\n      },\n      transformArrayLiteral: function(tree) {\n        if (hasSpreadMember(tree.elements)) {\n          return this.createArrayFromElements_(tree.elements);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, \"transformArrayLiteral\").call(this, tree);\n      },\n      transformCallExpression: function(tree) {\n        if (hasSpreadMember(tree.args.args)) {\n          return this.desugarCallSpread_(tree);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, \"transformCallExpression\").call(this, tree);\n      },\n      transformNewExpression: function(tree) {\n        if (tree.args !== null && hasSpreadMember(tree.args.args)) {\n          return this.desugarNewSpread_(tree);\n        }\n        return $traceurRuntime.superGet(this, SpreadTransformer.prototype, \"transformNewExpression\").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get SpreadTransformer() {\n      return SpreadTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/SuperTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\";\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")).default;\n  var TempVarTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TempVarTransformer.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")).TempVarTransformer;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")),\n      ArgumentList = $__7.ArgumentList,\n      ClassDeclaration = $__7.ClassDeclaration,\n      ClassExpression = $__7.ClassExpression,\n      GetAccessor = $__7.GetAccessor,\n      MemberExpression = $__7.MemberExpression,\n      Method = $__7.Method,\n      SetAccessor = $__7.SetAccessor;\n  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")),\n      MEMBER_EXPRESSION = $__8.MEMBER_EXPRESSION,\n      MEMBER_LOOKUP_EXPRESSION = $__8.MEMBER_LOOKUP_EXPRESSION,\n      SUPER_EXPRESSION = $__8.SUPER_EXPRESSION;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")),\n      EQUAL = $__9.EQUAL,\n      MINUS_MINUS = $__9.MINUS_MINUS,\n      PLUS_PLUS = $__9.PLUS_PLUS;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")),\n      createAssignmentExpression = $__10.createAssignmentExpression,\n      createBindingIdentifier = $__10.createBindingIdentifier,\n      createIdentifierExpression = $__10.createIdentifierExpression,\n      createIdentifierToken = $__10.createIdentifierToken,\n      createParenExpression = $__10.createParenExpression,\n      createStringLiteral = $__10.createStringLiteral,\n      createThisExpression = $__10.createThisExpression;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")).parseExpression;\n  var ExplodeExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ExplodeExpressionTransformer.js\", \"traceur@0.0.111/src/codegeneration/SuperTransformer.js\")).ExplodeExpressionTransformer;\n  function hasSuperMemberExpression(tree) {\n    return (tree.type === MEMBER_EXPRESSION || tree.type === MEMBER_LOOKUP_EXPRESSION) && tree.operand.type === SUPER_EXPRESSION;\n  }\n  var State = function() {\n    function State(transformer, home) {\n      this.transformer = transformer;\n      this.home_ = home;\n      this.tempName = home ? null : transformer.getTempIdentifier();\n      this.hasSuper = false;\n    }\n    return ($traceurRuntime.createClass)(State, {get home() {\n        this.hasSuper = true;\n        if (this.home_ === null) {\n          this.home_ = createIdentifierExpression(createIdentifierToken(this.tempName));\n        }\n        return this.home_;\n      }}, {});\n  }();\n  var ClassState = function($__super) {\n    function ClassState(transformer, tree) {\n      var home = null;\n      if (tree.name !== null) {\n        home = createIdentifierExpression(tree.name.identifierToken);\n      }\n      $traceurRuntime.superConstructor(ClassState).call(this, transformer, home);\n      this.name_ = tree.name;\n    }\n    return ($traceurRuntime.createClass)(ClassState, {get name() {\n        if (this.name_ !== null)\n          return this.name_;\n        if (this.hasSuper) {\n          return createBindingIdentifier(this.home.identifierToken);\n        }\n        return null;\n      }}, {}, $__super);\n  }(State);\n  var PrototypeState = function($__super) {\n    function PrototypeState(transformer, classState) {\n      $traceurRuntime.superConstructor(PrototypeState).call(this, transformer, null);\n      this.classState = classState;\n    }\n    return ($traceurRuntime.createClass)(PrototypeState, {get home() {\n        var ident = this.classState.home;\n        return new MemberExpression(null, ident, createIdentifierToken('prototype'));\n      }}, {}, $__super);\n  }(State);\n  var SuperTransformer = function($__super) {\n    function SuperTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SuperTransformer).call(this, identifierGenerator, reporter, options);\n      this.stateStack_ = [];\n    }\n    return ($traceurRuntime.createClass)(SuperTransformer, {\n      pushState: function(state) {\n        this.stateStack_.push(state);\n      },\n      popState: function() {\n        return this.stateStack_.pop();\n      },\n      peekState: function() {\n        return this.stateStack_[this.stateStack_.length - 1];\n      },\n      transformObjectLiteral: function(tree) {\n        var state = new State(this, null);\n        this.pushState(state);\n        this.pushState(state);\n        var result = $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformObjectLiteral\").call(this, tree);\n        this.popState();\n        this.popState();\n        if (state.hasSuper) {\n          this.registerTempVarName(state.tempName);\n          return createAssignmentExpression(state.home, result);\n        }\n        this.releaseTempName(state.tempName);\n        return result;\n      },\n      transformClassExpression: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var annotations = this.transformList(tree.annotations);\n        var classState = new ClassState(this, tree);\n        var prototypeState = new PrototypeState(this, classState);\n        this.pushState(classState);\n        this.pushState(prototypeState);\n        var elements = this.transformList(tree.elements);\n        this.popState();\n        this.popState();\n        if (tree.name === null && tree.superClass !== null) {\n          classState.home;\n        } else if (tree.superClass === superClass && tree.elements === elements && tree.annotations === annotations) {\n          return tree;\n        }\n        return new ClassExpression(tree.location, classState.name, superClass, elements, tree.annotations, tree.typeParameters);\n      },\n      transformClassDeclaration: function(tree) {\n        var superClass = this.transformAny(tree.superClass);\n        var annotations = this.transformList(tree.annotations);\n        var classState = new ClassState(this, tree);\n        var prototypeState = new PrototypeState(this, classState);\n        this.pushState(classState);\n        this.pushState(prototypeState);\n        var elements = this.transformList(tree.elements);\n        this.popState();\n        this.popState();\n        if (tree.superClass === superClass && tree.elements === elements && tree.annotations === annotations) {\n          return tree;\n        }\n        return new ClassDeclaration(tree.location, tree.name, superClass, elements, tree.annotations, tree.typeParameters);\n      },\n      transformMethod: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.parameterList === parameterList && tree.body === body) {\n          return tree;\n        }\n        return new Method(tree.location, tree.isStatic, tree.functionKind, name, parameterList, tree.typeAnnotation, tree.annotations, body, tree.debugName);\n      },\n      transformGetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.body === body) {\n          return tree;\n        }\n        return new GetAccessor(tree.location, tree.isStatic, name, tree.typeAnnotation, tree.annotations, body);\n      },\n      transformSetAccessor: function(tree) {\n        var name = this.transformAny(tree.name);\n        var prototypeState;\n        if (tree.isStatic) {\n          prototypeState = this.popState();\n        }\n        var parameterList = this.transformAny(tree.parameterList);\n        var body = this.transformAny(tree.body);\n        if (tree.isStatic) {\n          this.pushState(prototypeState);\n        }\n        if (tree.name === name && tree.parameterList === parameterList && tree.body === body) {\n          return tree;\n        }\n        return new SetAccessor(tree.location, tree.isStatic, name, parameterList, tree.annotations, body);\n      },\n      transformComputedPropertyName: function(tree) {\n        var s1 = this.popState();\n        var s2 = this.popState();\n        var result = $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformComputedPropertyName\").call(this, tree);\n        this.pushState(s2);\n        this.pushState(s1);\n        return result;\n      },\n      transformSuperExpression: function(tree) {\n        throw new Error('unreachable');\n      },\n      transformMemberShared_: function(name) {\n        var home = this.peekState().home;\n        var superGet = this.getRuntimeExpression('superGet');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(this, \", \", \", \")\"]), superGet, home, name);\n      },\n      transformMemberExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          return this.transformMemberShared_(tree.memberName.value);\n        }\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformMemberExpression\").call(this, tree);\n      },\n      transformMemberLookupExpression: function(tree) {\n        if (tree.operand.type === SUPER_EXPRESSION)\n          return this.transformMemberShared_(tree.memberExpression);\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformMemberLookupExpression\").call(this, tree);\n      },\n      transformCallExpression: function(tree) {\n        var operand,\n            args;\n        if (tree.operand.type === SUPER_EXPRESSION) {\n          args = this.transformAny(tree.args);\n          args = new ArgumentList(tree.location, $traceurRuntime.spread([createThisExpression()], args.args));\n          var home = this.stateStack_[this.stateStack_.length - 2].home;\n          var superConstructor = this.getRuntimeExpression('superConstructor');\n          operand = parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), superConstructor, home);\n        } else if (hasSuperMemberExpression(tree.operand)) {\n          operand = this.transformAny(tree.operand);\n          args = this.transformAny(tree.args);\n          args = new ArgumentList(args.location, $traceurRuntime.spread([createThisExpression()], args.args));\n        } else {\n          return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformCallExpression\").call(this, tree);\n        }\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \".call(\", \")\"]), operand, args);\n      },\n      transformBinaryExpression: function(tree) {\n        if (tree.operator.isAssignmentOperator() && hasSuperMemberExpression(tree.left)) {\n          if (tree.operator.type !== EQUAL) {\n            var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n            return this.transformAny(createParenExpression(exploded));\n          }\n          var name = tree.left.type === MEMBER_LOOKUP_EXPRESSION ? tree.left.memberExpression : createStringLiteral(tree.left.memberName.value);\n          var right = this.transformAny(tree.right);\n          var home = this.peekState().home;\n          var superSet = this.getRuntimeExpression('superSet');\n          return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(this, \", \", \", \", \", \")\"]), superSet, home, name, right);\n        }\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformBinaryExpression\").call(this, tree);\n      },\n      transformUnaryExpression: function(tree) {\n        var transformed = this.transformIncrementDecrement_(tree);\n        if (transformed)\n          return transformed;\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformUnaryExpression\").call(this, tree);\n      },\n      transformPostfixExpression: function(tree) {\n        var transformed = this.transformIncrementDecrement_(tree);\n        if (transformed)\n          return transformed;\n        return $traceurRuntime.superGet(this, SuperTransformer.prototype, \"transformPostfixExpression\").call(this, tree);\n      },\n      transformIncrementDecrement_: function(tree) {\n        var operator = tree.operator;\n        var operand = tree.operand;\n        if ((operator.type === PLUS_PLUS || operator.type === MINUS_MINUS) && hasSuperMemberExpression(operand)) {\n          var exploded = new ExplodeExpressionTransformer(this).transformAny(tree);\n          if (exploded !== tree)\n            exploded = createParenExpression(exploded);\n          return this.transformAny(exploded);\n        }\n        return null;\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(TempVarTransformer));\n  return {get SuperTransformer() {\n      return SuperTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")),\n      BinaryExpression = $__3.BinaryExpression,\n      UnaryExpression = $__3.UnaryExpression;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")),\n      IDENTIFIER_EXPRESSION = $__4.IDENTIFIER_EXPRESSION,\n      LITERAL_EXPRESSION = $__4.LITERAL_EXPRESSION,\n      UNARY_EXPRESSION = $__4.UNARY_EXPRESSION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")).ParseTreeTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")).default;\n  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")),\n      EQUAL_EQUAL = $__7.EQUAL_EQUAL,\n      EQUAL_EQUAL_EQUAL = $__7.EQUAL_EQUAL_EQUAL,\n      NOT_EQUAL = $__7.NOT_EQUAL,\n      NOT_EQUAL_EQUAL = $__7.NOT_EQUAL_EQUAL,\n      TYPEOF = $__7.TYPEOF;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/SymbolTransformer.js\")).parseExpression;\n  function isEqualityExpression(tree) {\n    switch (tree.operator.type) {\n      case EQUAL_EQUAL:\n      case EQUAL_EQUAL_EQUAL:\n      case NOT_EQUAL:\n      case NOT_EQUAL_EQUAL:\n        return true;\n    }\n    return false;\n  }\n  function isTypeof(tree) {\n    return tree.type === UNARY_EXPRESSION && tree.operator.type === TYPEOF;\n  }\n  function isSafeTypeofString(tree) {\n    if (tree.type !== LITERAL_EXPRESSION)\n      return false;\n    var value = tree.literalToken.processedValue;\n    switch (value) {\n      case 'symbol':\n      case 'object':\n        return false;\n    }\n    return true;\n  }\n  var SymbolTransformer = function($__super) {\n    function SymbolTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(SymbolTransformer).call(this);\n      this.identifierGenerator = identifierGenerator;\n      this.reporter = reporter;\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(SymbolTransformer, {\n      transformTypeofOperand_: function(tree) {\n        var operand = this.transformAny(tree.operand);\n        return new UnaryExpression(tree.location, tree.operator, operand);\n      },\n      transformBinaryExpression: function(tree) {\n        if (isEqualityExpression(tree)) {\n          if (isTypeof(tree.left) && isSafeTypeofString(tree.right)) {\n            var left = this.transformTypeofOperand_(tree.left);\n            var right = tree.right;\n            return new BinaryExpression(tree.location, left, tree.operator, right);\n          }\n          if (isTypeof(tree.right) && isSafeTypeofString(tree.left)) {\n            var left$__1 = tree.left;\n            var right$__2 = this.transformTypeofOperand_(tree.right);\n            return new BinaryExpression(tree.location, left$__1, tree.operator, right$__2);\n          }\n        }\n        return $traceurRuntime.superGet(this, SymbolTransformer.prototype, \"transformBinaryExpression\").call(this, tree);\n      },\n      transformUnaryExpression: function(tree) {\n        if (tree.operator.type !== TYPEOF)\n          return $traceurRuntime.superGet(this, SymbolTransformer.prototype, \"transformUnaryExpression\").call(this, tree);\n        var operand = this.transformAny(tree.operand);\n        var expression = this.getRuntimeTypeof(operand);\n        if (operand.type === IDENTIFIER_EXPRESSION) {\n          return parseExpression($traceurRuntime.getTemplateObject([\"(typeof \", \" === 'undefined' ?\\n          'undefined' : \", \")\"]), operand, expression);\n        }\n        return expression;\n      },\n      getRuntimeTypeof: function(operand) {\n        var typeOf = this.getRuntimeExpression('typeof');\n        return parseExpression($traceurRuntime.getTemplateObject([\"\", \"(\", \")\"]), typeOf, operand);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParseTreeTransformer));\n  return {get SymbolTransformer() {\n      return SymbolTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\";\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")),\n      BINARY_EXPRESSION = $__3.BINARY_EXPRESSION,\n      COMMA_EXPRESSION = $__3.COMMA_EXPRESSION,\n      CONDITIONAL_EXPRESSION = $__3.CONDITIONAL_EXPRESSION,\n      TEMPLATE_LITERAL_PORTION = $__3.TEMPLATE_LITERAL_PORTION,\n      TEMPLATE_LITERAL_EXPRESSION = $__3.TEMPLATE_LITERAL_EXPRESSION;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")),\n      LiteralExpression = $__4.LiteralExpression,\n      NewExpression = $__4.NewExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")).LiteralToken;\n  var ParenTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParenTrait.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")).ParenTrait;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")).ParseTreeTransformer;\n  var ImportRuntimeTrait = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ImportRuntimeTrait.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")).default;\n  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")),\n      PERCENT = $__9.PERCENT,\n      PLUS = $__9.PLUS,\n      SLASH = $__9.SLASH,\n      STAR = $__9.STAR,\n      STRING = $__9.STRING;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/TemplateLiteralTransformer.js\")),\n      createArgumentList = $__10.createArgumentList,\n      createArrayLiteral = $__10.createArrayLiteral,\n      createBinaryExpression = $__10.createBinaryExpression,\n      createCallExpression = $__10.createCallExpression,\n      createMemberExpression = $__10.createMemberExpression,\n      createOperatorToken = $__10.createOperatorToken,\n      createParenExpression = $__10.createParenExpression;\n  function createStringLiteralExpression(loc, str) {\n    return new LiteralExpression(loc, new LiteralToken(STRING, str, loc));\n  }\n  function createGetTemplateObject(elements, getTemplateObject) {\n    var cooked = [];\n    var raw = [];\n    var same = true;\n    for (var i = 0; i < elements.length; i += 2) {\n      var loc = elements[i].location;\n      var str = elements[i].value.value;\n      var cookedStr = toCookedString(str);\n      var rawStr = toRawString(str);\n      var cookedLiteral$__1 = createStringLiteralExpression(loc, cookedStr);\n      cooked.push(cookedLiteral$__1);\n      if (cookedStr !== rawStr) {\n        same = false;\n        var rawLiteral = createStringLiteralExpression(loc, rawStr);\n        raw.push(rawLiteral);\n      } else {\n        raw.push(cookedLiteral$__1);\n      }\n    }\n    maybeAddEmptyStringAtEnd(elements, cooked);\n    var cookedLiteral = createArrayLiteral(cooked);\n    var args = [cookedLiteral];\n    if (!same) {\n      maybeAddEmptyStringAtEnd(elements, raw);\n      var rawLiteral$__2 = createArrayLiteral(raw);\n      args.unshift(rawLiteral$__2);\n    }\n    return createCallExpression(getTemplateObject, createArgumentList(args));\n  }\n  function maybeAddEmptyStringAtEnd(elements, items) {\n    var length = elements.length;\n    if (!length || elements[length - 1].type !== TEMPLATE_LITERAL_PORTION) {\n      items.push(createStringLiteralExpression(null, '\"\"'));\n    }\n  }\n  function toRawString(str) {\n    str = str.replace(/\\r\\n?/g, '\\n');\n    str = JSON.stringify(str);\n    return str.replace(/\\u2028|\\u2029/g, function(c) {\n      switch (c) {\n        case '\\u2028':\n          return '\\\\u2028';\n        case '\\u2029':\n          return '\\\\u2029';\n        default:\n          throw Error('Not reachable');\n      }\n    });\n  }\n  function toCookedString(s) {\n    var sb = ['\"'];\n    var i = 0,\n        k = 1,\n        c,\n        c2;\n    while (i < s.length) {\n      c = s[i++];\n      switch (c) {\n        case '\\\\':\n          c2 = s[i++];\n          switch (c2) {\n            case '\\n':\n            case '\\u2028':\n            case '\\u2029':\n              break;\n            case '\\r':\n              if (s[i + 1] === '\\n') {\n                i++;\n              }\n              break;\n            default:\n              sb[k++] = c;\n              sb[k++] = c2;\n          }\n          break;\n        case '\"':\n          sb[k++] = '\\\\\"';\n          break;\n        case '\\n':\n          sb[k++] = '\\\\n';\n          break;\n        case '\\r':\n          if (s[i] === '\\n')\n            i++;\n          sb[k++] = '\\\\n';\n          break;\n        case '\\t':\n          sb[k++] = '\\\\t';\n          break;\n        case '\\f':\n          sb[k++] = '\\\\f';\n          break;\n        case '\\b':\n          sb[k++] = '\\\\b';\n          break;\n        case '\\u2028':\n          sb[k++] = '\\\\u2028';\n          break;\n        case '\\u2029':\n          sb[k++] = '\\\\u2029';\n          break;\n        default:\n          sb[k++] = c;\n      }\n    }\n    sb[k++] = '\"';\n    return sb.join('');\n  }\n  var TemplateLiteralTransformer = function($__super) {\n    function TemplateLiteralTransformer(identifierGenerator, reporter, options) {\n      $traceurRuntime.superConstructor(TemplateLiteralTransformer).call(this);\n      this.options = options;\n    }\n    return ($traceurRuntime.createClass)(TemplateLiteralTransformer, {\n      transformTemplateLiteralExpression: function(tree) {\n        if (!tree.operand) {\n          return this.createDefaultTemplateLiteral(tree);\n        }\n        var operand = this.transformAny(tree.operand);\n        var elements = tree.elements;\n        var getTemplateObject = this.getRuntimeExpression('getTemplateObject');\n        var args = [createGetTemplateObject(tree.elements, getTemplateObject)];\n        for (var i = 1; i < elements.length; i += 2) {\n          args.push(this.transformAny(elements[i]));\n        }\n        return createCallExpression(operand, createArgumentList(args));\n      },\n      transformTemplateSubstitution: function(tree) {\n        var transformedTree = this.transformAny(tree.expression);\n        switch (transformedTree.type) {\n          case BINARY_EXPRESSION:\n            switch (transformedTree.operator.type) {\n              case STAR:\n              case PERCENT:\n              case SLASH:\n                return transformedTree;\n            }\n            return createParenExpression(transformedTree);\n          case COMMA_EXPRESSION:\n          case CONDITIONAL_EXPRESSION:\n            return createParenExpression(transformedTree);\n        }\n        return transformedTree;\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        var str = toCookedString(tree.value.value);\n        return createStringLiteralExpression(tree.location, str);\n      },\n      createDefaultTemplateLiteral: function(tree) {\n        var elements = tree.elements;\n        var length = elements.length;\n        if (length === 0) {\n          return createStringLiteralExpression(tree.location, '\"\"');\n        }\n        var firstNonEmpty = elements[0].value.value === '';\n        var binaryExpression = this.transformAny(elements[0]);\n        if (length === 1)\n          return binaryExpression;\n        var plusToken = createOperatorToken(PLUS);\n        for (var i = 1; i < length; i++) {\n          var element = elements[i];\n          if (element.type === TEMPLATE_LITERAL_PORTION) {\n            if (element.value.value === '') {\n              continue;\n            }\n            if (firstNonEmpty && i === 2) {\n              binaryExpression = binaryExpression.right;\n            }\n          }\n          var transformedTree = this.transformAny(elements[i]);\n          binaryExpression = createBinaryExpression(binaryExpression, plusToken, transformedTree);\n        }\n        return new createParenExpression(binaryExpression);\n      }\n    }, {}, $__super);\n  }(ImportRuntimeTrait(ParenTrait(ParseTreeTransformer)));\n  return {get TemplateLiteralTransformer() {\n      return TemplateLiteralTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js\")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js\")),\n      ArgumentList = $__2.ArgumentList,\n      IdentifierExpression = $__2.IdentifierExpression,\n      MemberExpression = $__2.MemberExpression;\n  var parseExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/TypeToExpressionTransformer.js\")).parseExpression;\n  var TypeToExpressionTransformer = function($__super) {\n    function TypeToExpressionTransformer() {\n      $traceurRuntime.superConstructor(TypeToExpressionTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(TypeToExpressionTransformer, {\n      transformTypeName: function(tree) {\n        if (tree.moduleName) {\n          var operand = this.transformAny(tree.moduleName);\n          return new MemberExpression(tree.location, operand, tree.name);\n        }\n        return new IdentifierExpression(tree.location, tree.name);\n      },\n      transformPredefinedType: function(tree) {\n        return parseExpression($traceurRuntime.getTemplateObject([\"$traceurRuntime.type.\", \")\"]), tree.typeToken);\n      },\n      transformTypeReference: function(tree) {\n        var typeName = this.transformAny(tree.typeName);\n        var args = this.transformAny(tree.args);\n        var argumentList = new ArgumentList(tree.location, $traceurRuntime.spread([typeName], args));\n        return parseExpression($traceurRuntime.getTemplateObject([\"$traceurRuntime.genericType(\", \")\"]), argumentList);\n      },\n      transformTypeArguments: function(tree) {\n        return this.transformList(tree.args);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TypeToExpressionTransformer() {\n      return TypeToExpressionTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/TypeTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/TypeTransformer.js\";\n  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/TypeTransformer.js\")),\n      AnonBlock = $__1.AnonBlock,\n      FormalParameter = $__1.FormalParameter,\n      FunctionDeclaration = $__1.FunctionDeclaration,\n      FunctionExpression = $__1.FunctionExpression,\n      GetAccessor = $__1.GetAccessor,\n      Method = $__1.Method,\n      VariableDeclaration = $__1.VariableDeclaration;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/TypeTransformer.js\")),\n      IMPORT_TYPE_CLAUSE = $__2.IMPORT_TYPE_CLAUSE,\n      TYPE_ALIAS_DECLARATION = $__2.TYPE_ALIAS_DECLARATION;\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/TypeTransformer.js\")).ParseTreeTransformer;\n  var TypeTransformer = function($__super) {\n    function TypeTransformer() {\n      $traceurRuntime.superConstructor(TypeTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(TypeTransformer, {\n      transformVariableDeclaration: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new VariableDeclaration(tree.location, tree.lvalue, null, tree.initializer);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformVariableDeclaration\").call(this, tree);\n      },\n      transformFormalParameter: function(tree) {\n        if (tree.typeAnnotation !== null)\n          return new FormalParameter(tree.location, tree.parameter, null, []);\n        return tree;\n      },\n      transformFunctionDeclaration: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new FunctionDeclaration(tree.location, tree.name, tree.functionKind, tree.parameterList, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformFunctionDeclaration\").call(this, tree);\n      },\n      transformFunctionExpression: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new FunctionExpression(tree.location, tree.name, tree.functionKind, tree.parameterList, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformFunctionExpression\").call(this, tree);\n      },\n      transformMethod: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new Method(tree.location, tree.isStatic, tree.functionKind, tree.name, tree.parameterList, null, tree.annotations, tree.body, tree.debugName);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformMethod\").call(this, tree);\n      },\n      transformGetAccessor: function(tree) {\n        if (tree.typeAnnotation) {\n          tree = new GetAccessor(tree.location, tree.isStatic, tree.name, null, tree.annotations, tree.body);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformGetAccessor\").call(this, tree);\n      },\n      transformInterfaceDeclaration: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      transformExportDeclaration: function(tree) {\n        if (tree.declaration.type === TYPE_ALIAS_DECLARATION) {\n          return new AnonBlock(null, []);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformExportDeclaration\").call(this, tree);\n      },\n      transformTypeAliasDeclaration: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      transformImportDeclaration: function(tree) {\n        if (!tree.importClause || tree.importClause.type === IMPORT_TYPE_CLAUSE) {\n          return new AnonBlock(null, []);\n        }\n        return $traceurRuntime.superGet(this, TypeTransformer.prototype, \"transformImportDeclaration\").call(this, tree);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get TypeTransformer() {\n      return TypeTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\")).ParseTreeTransformer;\n  var LiteralExpression = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\")).LiteralExpression;\n  var LiteralToken = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/LiteralToken.js\", \"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\")).LiteralToken;\n  var STRING = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/UnicodeEscapeSequenceTransformer.js\")).STRING;\n  var re = /(\\\\*)\\\\u{([0-9a-fA-F]+)}/g;\n  function zeroPad(value) {\n    return '0000'.slice(value.length) + value;\n  }\n  function needsTransform(token) {\n    return token.type === STRING && re.test(token.value);\n  }\n  function transformToken(token) {\n    return token.value.replace(re, function(match, backslashes, hexDigits) {\n      var backslashIsEscaped = backslashes.length % 2 === 1;\n      if (backslashIsEscaped) {\n        return match;\n      }\n      var codePoint = parseInt(hexDigits, 16);\n      var value;\n      if (codePoint <= 0xFFFF) {\n        value = '\\\\u' + zeroPad(codePoint.toString(16).toUpperCase());\n      } else {\n        var high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;\n        var low = (codePoint - 0x10000) % 0x400 + 0xDC00;\n        value = '\\\\u' + high.toString(16).toUpperCase() + '\\\\u' + low.toString(16).toUpperCase();\n      }\n      return backslashes + value;\n    });\n  }\n  var UnicodeEscapeSequenceTransformer = function($__super) {\n    function UnicodeEscapeSequenceTransformer() {\n      $traceurRuntime.superConstructor(UnicodeEscapeSequenceTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(UnicodeEscapeSequenceTransformer, {transformLiteralExpression: function(tree) {\n        var token = tree.literalToken;\n        if (needsTransform(token)) {\n          var value = transformToken(token);\n          return new LiteralExpression(tree.location, new LiteralToken(STRING, value, token.location));\n        }\n        return tree;\n      }}, {}, $__super);\n  }(ParseTreeTransformer);\n  return {get UnicodeEscapeSequenceTransformer() {\n      return UnicodeEscapeSequenceTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/UniqueIdentifierGenerator.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/UniqueIdentifierGenerator.js\";\n  var UniqueIdentifierGenerator = function() {\n    function UniqueIdentifierGenerator() {\n      this.identifierIndex = 0;\n    }\n    return ($traceurRuntime.createClass)(UniqueIdentifierGenerator, {generateUniqueIdentifier: function() {\n        return (\"$__\" + this.identifierIndex++);\n      }}, {});\n  }();\n  return {get UniqueIdentifierGenerator() {\n      return UniqueIdentifierGenerator;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/ConstChecker.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/ConstChecker.js\";\n  var IDENTIFIER_EXPRESSION = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/semantics/ConstChecker.js\")).IDENTIFIER_EXPRESSION;\n  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/semantics/ConstChecker.js\")),\n      CONST = $__3.CONST,\n      MINUS_MINUS = $__3.MINUS_MINUS,\n      PLUS_PLUS = $__3.PLUS_PLUS;\n  var ScopeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeVisitor.js\", \"traceur@0.0.111/src/semantics/ConstChecker.js\")).ScopeVisitor;\n  var ScopeChainBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeChainBuilder.js\", \"traceur@0.0.111/src/semantics/ConstChecker.js\")).ScopeChainBuilder;\n  var ConstChecker = function($__super) {\n    function ConstChecker(scopeBuilder, reporter) {\n      $traceurRuntime.superConstructor(ConstChecker).call(this);\n      this.scopeBuilder_ = scopeBuilder;\n      this.reporter_ = reporter;\n    }\n    return ($traceurRuntime.createClass)(ConstChecker, {\n      pushScope: function(tree) {\n        return this.scope = this.scopeBuilder_.getScopeForTree(tree);\n      },\n      visitUnaryExpression: function(tree) {\n        if (tree.operand.type === IDENTIFIER_EXPRESSION && (tree.operator.type === PLUS_PLUS || tree.operator.type === MINUS_MINUS)) {\n          this.validateMutation_(tree.operand);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, \"visitUnaryExpression\").call(this, tree);\n      },\n      visitPostfixExpression: function(tree) {\n        if (tree.operand.type === IDENTIFIER_EXPRESSION) {\n          this.validateMutation_(tree.operand);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, \"visitPostfixExpression\").call(this, tree);\n      },\n      visitBinaryExpression: function(tree) {\n        if (tree.left.type === IDENTIFIER_EXPRESSION && tree.operator.isAssignmentOperator()) {\n          this.validateMutation_(tree.left);\n        }\n        $traceurRuntime.superGet(this, ConstChecker.prototype, \"visitBinaryExpression\").call(this, tree);\n      },\n      validateMutation_: function(identifierExpression) {\n        if (this.inWithBlock) {\n          return;\n        }\n        var binding = this.scope.getBinding(identifierExpression);\n        if (binding === null) {\n          return;\n        }\n        var $__1 = binding,\n            type = $__1.type,\n            tree = $__1.tree;\n        if (type === CONST) {\n          this.reportError_(identifierExpression.location, (tree.getStringValue() + \" is read-only\"));\n        }\n      },\n      reportError_: function(location, message) {\n        this.reporter_.reportError(location, message);\n      }\n    }, {}, $__super);\n  }(ScopeVisitor);\n  function validate(tree, reporter) {\n    var builder = new ScopeChainBuilder(reporter);\n    builder.visitAny(tree);\n    var checker = new ConstChecker(builder, reporter);\n    checker.visitAny(tree);\n  }\n  return {\n    get ConstChecker() {\n      return ConstChecker;\n    },\n    get validate() {\n      return validate;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/semantics/FreeVariableChecker.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/semantics/FreeVariableChecker.js\";\n  var ScopeChainBuilderWithReferences = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ScopeChainBuilderWithReferences.js\", \"traceur@0.0.111/src/semantics/FreeVariableChecker.js\")).ScopeChainBuilderWithReferences;\n  var FreeVariableChecker = function($__super) {\n    function FreeVariableChecker(reporter, global) {\n      $traceurRuntime.superConstructor(FreeVariableChecker).call(this, reporter);\n      this.global_ = global;\n    }\n    return ($traceurRuntime.createClass)(FreeVariableChecker, {referenceFound: function(tree, name) {\n        if (this.scope.getBinding(tree))\n          return;\n        if (!(name in this.global_)) {\n          this.reporter.reportError(tree.location, (name + \" is not defined\"));\n        }\n      }}, {}, $__super);\n  }(ScopeChainBuilderWithReferences);\n  function validate(tree, reporter) {\n    var global = arguments[2] !== (void 0) ? arguments[2] : Reflect.global;\n    var checker = new FreeVariableChecker(reporter, global);\n    checker.visitAny(tree);\n  }\n  return {get validate() {\n      return validate;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\";\n  var AmdTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AmdTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).AmdTransformer;\n  var AnnotationsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AnnotationsTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).AnnotationsTransformer;\n  var ArrayComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ArrayComprehensionTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ArrayComprehensionTransformer;\n  var ArrowFunctionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ArrowFunctionTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ArrowFunctionTransformer;\n  var AsyncGeneratorTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AsyncGeneratorTransformPass.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).AsyncGeneratorTransformPass;\n  var AsyncToGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AsyncToGeneratorTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).AsyncToGeneratorTransformer;\n  var BlockBindingTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./BlockBindingTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).BlockBindingTransformer;\n  var ClassTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ClassTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ClassTransformer;\n  var ClosureModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ClosureModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ClosureModuleTransformer;\n  var CommonJsModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./CommonJsModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).CommonJsModuleTransformer;\n  var DefaultParametersTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./DefaultParametersTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).DefaultParametersTransformer;\n  var DestructuringTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./DestructuringTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).DestructuringTransformer;\n  var ExponentiationTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ExponentiationTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ExponentiationTransformer;\n  var ForOfTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ForOfTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ForOfTransformer;\n  var ForOnTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ForOnTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ForOnTransformer;\n  var GeneratorComprehensionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./GeneratorComprehensionTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).GeneratorComprehensionTransformer;\n  var GeneratorTransformPass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./GeneratorTransformPass.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).GeneratorTransformPass;\n  var InlineModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InlineModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).InlineModuleTransformer;\n  var InstantiateModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InstantiateModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).InstantiateModuleTransformer;\n  var JsxTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./JsxTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).JsxTransformer;\n  var MemberVariableTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MemberVariableTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).MemberVariableTransformer;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ModuleTransformer;\n  var MultiTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MultiTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).MultiTransformer;\n  var NumericLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./NumericLiteralTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).NumericLiteralTransformer;\n  var ObjectLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ObjectLiteralTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ObjectLiteralTransformer;\n  var ProperTailCallTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ProperTailCallTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).ProperTailCallTransformer;\n  var PropertyNameShorthandTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PropertyNameShorthandTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).PropertyNameShorthandTransformer;\n  var RegularExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./RegularExpressionTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).RegularExpressionTransformer;\n  var RestParameterTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./RestParameterTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).RestParameterTransformer;\n  var SpreadPropertiesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SpreadPropertiesTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).SpreadPropertiesTransformer;\n  var SpreadTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SpreadTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).SpreadTransformer;\n  var SuperTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SuperTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).SuperTransformer;\n  var SymbolTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SymbolTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).SymbolTransformer;\n  var TemplateLiteralTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TemplateLiteralTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).TemplateLiteralTransformer;\n  var TypeToExpressionTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TypeToExpressionTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).TypeToExpressionTransformer;\n  var TypeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TypeTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).TypeTransformer;\n  var UnicodeEscapeSequenceTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./UnicodeEscapeSequenceTransformer.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).UnicodeEscapeSequenceTransformer;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./UniqueIdentifierGenerator.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).UniqueIdentifierGenerator;\n  var validateConst = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/ConstChecker.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).validate;\n  var validateFreeVariables = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/FreeVariableChecker.js\", \"traceur@0.0.111/src/codegeneration/FromOptionsTransformer.js\")).validate;\n  var FromOptionsTransformer = function($__super) {\n    function FromOptionsTransformer(reporter, options) {\n      var $__1;\n      $traceurRuntime.superConstructor(FromOptionsTransformer).call(this, reporter, options.validate);\n      var transformOptions = options.transformOptions;\n      var idGenerator = new UniqueIdentifierGenerator();\n      var append = ($__1 = this, function(transformer) {\n        $__1.append(function(tree) {\n          return new transformer(idGenerator, reporter, options).transformAny(tree);\n        });\n      });\n      if (transformOptions.blockBinding) {\n        this.append(function(tree) {\n          validateConst(tree, reporter);\n          return tree;\n        });\n      }\n      if (options.freeVariableChecker) {\n        this.append(function(tree) {\n          validateFreeVariables(tree, reporter);\n          return tree;\n        });\n      }\n      if (transformOptions.exponentiation)\n        append(ExponentiationTransformer);\n      if (transformOptions.numericLiterals)\n        append(NumericLiteralTransformer);\n      if (transformOptions.unicodeExpressions)\n        append(RegularExpressionTransformer);\n      if (transformOptions.jsx) {\n        append(JsxTransformer);\n      }\n      if (transformOptions.templateLiterals)\n        append(TemplateLiteralTransformer);\n      if (transformOptions.types && transformOptions.annotations) {\n        append(TypeToExpressionTransformer);\n      }\n      if (transformOptions.unicodeEscapeSequences)\n        append(UnicodeEscapeSequenceTransformer);\n      if (transformOptions.annotations)\n        append(AnnotationsTransformer);\n      if (transformOptions.propertyNameShorthand)\n        append(PropertyNameShorthandTransformer);\n      if (transformOptions.memberVariables) {\n        append(MemberVariableTransformer);\n      }\n      if (transformOptions.classes) {\n        append(SuperTransformer);\n      }\n      if (transformOptions.arrowFunctions) {\n        append(ArrowFunctionTransformer);\n      }\n      if (transformOptions.classes) {\n        append(ClassTransformer);\n      }\n      if (transformOptions.spreadProperties) {\n        append(SpreadPropertiesTransformer);\n      }\n      if (transformOptions.propertyMethods || transformOptions.computedPropertyNames || transformOptions.properTailCalls) {\n        append(ObjectLiteralTransformer);\n      }\n      if (transformOptions.generatorComprehension)\n        append(GeneratorComprehensionTransformer);\n      if (transformOptions.arrayComprehension)\n        append(ArrayComprehensionTransformer);\n      if (transformOptions.forOf)\n        append(ForOfTransformer);\n      if (transformOptions.asyncGenerators) {\n        append(AsyncGeneratorTransformPass);\n      }\n      if (transformOptions.forOn)\n        append(ForOnTransformer);\n      if (transformOptions.restParameters)\n        append(RestParameterTransformer);\n      if (transformOptions.defaultParameters)\n        append(DefaultParametersTransformer);\n      if (transformOptions.destructuring)\n        append(DestructuringTransformer);\n      if (transformOptions.types)\n        append(TypeTransformer);\n      if (transformOptions.spread)\n        append(SpreadTransformer);\n      if (transformOptions.blockBinding) {\n        this.append(function(tree) {\n          var transformer = new BlockBindingTransformer(idGenerator, reporter, tree);\n          return transformer.transformAny(tree);\n        });\n      }\n      if (transformOptions.asyncFunctions && options.generators === 'parse') {\n        append(AsyncToGeneratorTransformer);\n      } else if (transformOptions.generators || transformOptions.asyncFunctions) {\n        append(GeneratorTransformPass);\n      }\n      if (transformOptions.symbols)\n        append(SymbolTransformer);\n      if (transformOptions.properTailCalls) {\n        append(ProperTailCallTransformer);\n      }\n      if (transformOptions.modules) {\n        switch (transformOptions.modules) {\n          case 'commonjs':\n            append(CommonJsModuleTransformer);\n            break;\n          case 'amd':\n            append(AmdTransformer);\n            break;\n          case 'closure':\n            append(ClosureModuleTransformer);\n            break;\n          case 'inline':\n            append(InlineModuleTransformer);\n            break;\n          case 'instantiate':\n            append(InstantiateModuleTransformer);\n            break;\n          case 'bootstrap':\n            append(ModuleTransformer);\n            break;\n          case 'parse':\n            break;\n          default:\n            throw new Error('Invalid modules transform option');\n        }\n      }\n    }\n    return ($traceurRuntime.createClass)(FromOptionsTransformer, {}, {}, $__super);\n  }(MultiTransformer);\n  return {get FromOptionsTransformer() {\n      return FromOptionsTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\";\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/TokenType.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")),\n      CONST = $__2.CONST,\n      LET = $__2.LET;\n  var ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")).ModuleTransformer;\n  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeFactory.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")),\n      createAssignmentStatement = $__4.createAssignmentStatement,\n      createArgumentList = $__4.createArgumentList,\n      createBindingIdentifier = $__4.createBindingIdentifier,\n      createCallExpression = $__4.createCallExpression,\n      createExpressionStatement = $__4.createExpressionStatement,\n      createForInStatement = $__4.createForInStatement,\n      createFunctionBody = $__4.createFunctionBody,\n      createIfStatement = $__4.createIfStatement,\n      createImmediatelyInvokedFunctionExpression = $__4.createImmediatelyInvokedFunctionExpression,\n      createIdentifierExpression = $__4.createIdentifierExpression,\n      createMemberLookupExpression = $__4.createMemberLookupExpression,\n      createMemberExpression = $__4.createMemberExpression,\n      createObjectLiteral = $__4.createObjectLiteral,\n      createReturnStatement = $__4.createReturnStatement,\n      createUseStrictDirective = $__4.createUseStrictDirective,\n      createVariableDeclarationList = $__4.createVariableDeclarationList,\n      createVariableStatement = $__4.createVariableStatement;\n  var IMPORT_SPECIFIER_SET = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTreeType.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")).IMPORT_SPECIFIER_SET;\n  var AnonBlock = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")).AnonBlock;\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/InlineES6ModuleTransformer.js\")).parseStatement;\n  var anonInlineModules = 0;\n  var InlineES6ModuleTransformer = function($__super) {\n    function InlineES6ModuleTransformer(identifierGenerator, reporter, options, metadata) {\n      $traceurRuntime.superConstructor(InlineES6ModuleTransformer).call(this, identifierGenerator, reporter, options);\n      this.metadata_ = metadata;\n    }\n    return ($traceurRuntime.createClass)(InlineES6ModuleTransformer, {\n      moduleProlog: function() {\n        return [createUseStrictDirective()];\n      },\n      wrapModule: function(statements) {\n        var seed = this.moduleName || 'anon_' + ++anonInlineModules;\n        var idName = this.getTempVarNameForModuleName(seed);\n        if (this.isRootModule) {\n          statements.pop();\n          return statements;\n        }\n        var body = createFunctionBody(statements);\n        var moduleExpression = createImmediatelyInvokedFunctionExpression(body);\n        return [createVariableStatement(CONST, idName, moduleExpression)];\n      },\n      transformExportDeclaration: function(tree) {\n        if (this.isRootModule)\n          return tree;\n        this.exportVisitor.visitAny(tree);\n        return this.transformAny(tree.declaration);\n      },\n      transformImportDeclaration: function(tree) {\n        if (!tree.importClause || (tree.importClause.type === IMPORT_SPECIFIER_SET && tree.importClause.specifiers.length === 0)) {\n          return createExpressionStatement(this.transformAny(tree.moduleSpecifier));\n        }\n        var binding = this.transformAny(tree.importClause);\n        var initializer = this.transformAny(tree.moduleSpecifier);\n        return createVariableStatement(CONST, binding, initializer);\n      },\n      transformNamedExport: function(tree) {\n        return new AnonBlock(null, []);\n      },\n      addExportStatement: function(statements) {\n        var $__1 = this;\n        var exportProperties = this.getExportProperties();\n        var exportObject = createObjectLiteral(exportProperties);\n        if (this.exportVisitor.starExports.length) {\n          var starExports = this.exportVisitor.starExports;\n          var starIdents = starExports.map(function(moduleSpecifier) {\n            return createIdentifierExpression($__1.getTempVarNameForModuleSpecifier(moduleSpecifier));\n          });\n          if (exportProperties.length)\n            starIdents.push(exportObject);\n          var exports = this.getTempIdentifier();\n          statements.push(createVariableStatement(LET, exports, createObjectLiteral(\"\")));\n          var key = this.getTempIdentifier();\n          starIdents.forEach(function(starIdent) {\n            statements.push(createForInStatement(createVariableDeclarationList(LET, key, null), starIdent, createIfStatement(createCallExpression(createMemberExpression(starIdent, 'hasOwnProperty'), createArgumentList([createIdentifierExpression(key)])), createAssignmentStatement(createMemberLookupExpression(createIdentifierExpression(exports), createIdentifierExpression(key)), createMemberLookupExpression(starIdent, createIdentifierExpression(key))))));\n          });\n          statements.push(createReturnStatement(createIdentifierExpression(exports)));\n          return statements;\n        }\n        statements.push(parseStatement($traceurRuntime.getTemplateObject([\"return \", \"\"]), exportObject));\n        return statements;\n      },\n      transformModuleSpecifier: function(tree) {\n        return createBindingIdentifier(this.getTempVarNameForModuleSpecifier(tree));\n      },\n      get isRootModule() {\n        return this.moduleName === (this.metadata_ && this.metadata_.rootModule);\n      }\n    }, {}, $__super);\n  }(ModuleTransformer);\n  return {get InlineES6ModuleTransformer() {\n      return InlineES6ModuleTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\";\n  var AnnotationsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AnnotationsTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).AnnotationsTransformer;\n  var AsyncToGeneratorTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./AsyncToGeneratorTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).AsyncToGeneratorTransformer;\n  var InlineES6ModuleTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InlineES6ModuleTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).InlineES6ModuleTransformer;\n  var JsxTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./JsxTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).JsxTransformer;\n  var MemberVariableTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MemberVariableTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).MemberVariableTransformer;\n  var MultiTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./MultiTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).MultiTransformer;\n  var SpreadPropertiesTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./SpreadPropertiesTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).SpreadPropertiesTransformer;\n  var TypeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TypeTransformer.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).TypeTransformer;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./UniqueIdentifierGenerator.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).UniqueIdentifierGenerator;\n  var validateFreeVariables = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../semantics/FreeVariableChecker.js\", \"traceur@0.0.111/src/codegeneration/PureES6Transformer.js\")).validate;\n  var PureES6Transformer = function($__super) {\n    function PureES6Transformer(reporter, options, metadata) {\n      var $__1;\n      $traceurRuntime.superConstructor(PureES6Transformer).call(this, reporter, options.validate);\n      var idGenerator = new UniqueIdentifierGenerator();\n      var append = ($__1 = this, function(transformer) {\n        $__1.append(function(tree) {\n          return new transformer(idGenerator, reporter, options, metadata).transformAny(tree);\n        });\n      });\n      if (options.freeVariableChecker) {\n        this.append(function(tree) {\n          validateFreeVariables(tree, reporter);\n          return tree;\n        });\n      }\n      if (options.jsx) {\n        append(JsxTransformer);\n      }\n      if (options.spreadProperties) {\n        append(SpreadPropertiesTransformer);\n      }\n      if (options.memberVariables) {\n        append(MemberVariableTransformer);\n      }\n      append(AnnotationsTransformer);\n      append(TypeTransformer);\n      append(AsyncToGeneratorTransformer);\n      if (options.modules === 'inline') {\n        append(InlineES6ModuleTransformer);\n      }\n    }\n    return ($traceurRuntime.createClass)(PureES6Transformer, {}, {}, $__super);\n  }(MultiTransformer);\n  return {get PureES6Transformer() {\n      return PureES6Transformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/Compiler.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/Compiler.js\";\n  var AttachModuleNameTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/module/AttachModuleNameTransformer.js\", \"traceur@0.0.111/src/Compiler.js\")).AttachModuleNameTransformer;\n  var FromOptionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/FromOptionsTransformer.js\", \"traceur@0.0.111/src/Compiler.js\")).FromOptionsTransformer;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./syntax/Parser.js\", \"traceur@0.0.111/src/Compiler.js\")).Parser;\n  var PureES6Transformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/PureES6Transformer.js\", \"traceur@0.0.111/src/Compiler.js\")).PureES6Transformer;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./syntax/SourceFile.js\", \"traceur@0.0.111/src/Compiler.js\")).SourceFile;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util/CollectingErrorReporter.js\", \"traceur@0.0.111/src/Compiler.js\")).CollectingErrorReporter;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Options.js\", \"traceur@0.0.111/src/Compiler.js\")),\n      Options = $__10.Options,\n      versionLockedOptions = $__10.versionLockedOptions;\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/ParseTreeMapWriter.js\", \"traceur@0.0.111/src/Compiler.js\")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/ParseTreeWriter.js\", \"traceur@0.0.111/src/Compiler.js\")).ParseTreeWriter;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/SourceMapIntegration.js\", \"traceur@0.0.111/src/Compiler.js\")),\n      SourceMapConsumer = $__13.SourceMapConsumer,\n      SourceMapGenerator = $__13.SourceMapGenerator;\n  function merge() {\n    for (var srcs = [],\n        $__2 = 0; $__2 < arguments.length; $__2++)\n      srcs[$__2] = arguments[$__2];\n    var dest = Object.create(null);\n    srcs.forEach(function(src) {\n      Object.keys(src).forEach(function(key) {\n        dest[key] = src[key];\n      });\n      var srcModules = src.modules;\n      if (typeof srcModules !== 'undefined') {\n        dest.modules = srcModules;\n      }\n    });\n    return dest;\n  }\n  function basePath(name) {\n    if (!name)\n      return null;\n    var lastSlash = name.lastIndexOf('/');\n    if (lastSlash < 0)\n      return null;\n    return name.substring(0, lastSlash + 1);\n  }\n  var Compiler = function() {\n    function Compiler() {\n      var overridingOptions = arguments[0] !== (void 0) ? arguments[0] : {};\n      this.options_ = new Options(this.defaultOptions());\n      this.options_.setFromObject(overridingOptions);\n      this.sourceMapConfiguration_ = null;\n      this.sourceMapInfo_ = null;\n      this.sourceMapCache_ = null;\n    }\n    return ($traceurRuntime.createClass)(Compiler, {\n      compile: function(content) {\n        var sourceName = arguments[1] !== (void 0) ? arguments[1] : '<compileSource>';\n        var outputName = arguments[2] !== (void 0) ? arguments[2] : '<compileOutput>';\n        var sourceRoot = arguments[3];\n        sourceName = this.normalize(sourceName);\n        outputName = this.normalize(outputName);\n        var tree = this.parse(content, sourceName);\n        tree = this.transform(tree, sourceName);\n        var sourceURL = sourceName !== outputName ? sourceName : undefined;\n        if (sourceRoot === undefined)\n          sourceRoot = this.options_.sourceRoot;\n        return this.write(tree, outputName, sourceRoot, sourceURL);\n      },\n      throwIfErrors: function(errorReporter) {\n        if (errorReporter.hadError())\n          throw errorReporter.toError();\n      },\n      parse: function(content) {\n        var sourceName = arguments[1] !== (void 0) ? arguments[1] : '<compiler-parse-input>';\n        sourceName = this.normalize(sourceName);\n        this.sourceMapCache_ = null;\n        this.sourceMapConfiguration_ = null;\n        var errorReporter = new CollectingErrorReporter();\n        var sourceFile = new SourceFile(sourceName, content);\n        var parser = new Parser(sourceFile, errorReporter, this.options_);\n        var tree = this.options_.script ? parser.parseScript() : parser.parseModule();\n        this.throwIfErrors(errorReporter);\n        return tree;\n      },\n      transform: function(tree) {\n        var candidateModuleName = arguments[1];\n        var metadata = arguments[2];\n        var transformer;\n        if (candidateModuleName) {\n          var transformer$__3 = new AttachModuleNameTransformer(candidateModuleName);\n          tree = transformer$__3.transformAny(tree);\n        }\n        var errorReporter = new CollectingErrorReporter();\n        if (this.options_.outputLanguage.toLowerCase() === 'es6') {\n          transformer = new PureES6Transformer(errorReporter, this.options_, metadata);\n        } else {\n          transformer = new FromOptionsTransformer(errorReporter, this.options_);\n        }\n        var transformedTree = transformer.transform(tree);\n        this.throwIfErrors(errorReporter);\n        return transformedTree;\n      },\n      createSourceMapConfiguration_: function(outputName) {\n        var sourceRoot = arguments[1];\n        var sourceURL = arguments[2];\n        if (this.options_.sourceMaps) {\n          return {\n            sourceMapGenerator: new SourceMapGenerator({\n              file: outputName,\n              sourceRoot: sourceRoot,\n              skipValidation: true\n            }),\n            basepath: basePath(outputName),\n            inputSourceMap: this.options_.inputSourceMap,\n            sourceURL: sourceURL,\n            outputName: outputName\n          };\n        }\n      },\n      getSourceMap: function() {\n        if (this.sourceMapCache_) {\n          return this.sourceMapCache_;\n        }\n        if (this.sourceMapConfiguration_) {\n          var sourceMap = this.sourceMapConfiguration_.sourceMapGenerator.toString();\n          var inputSourceMap = this.sourceMapConfiguration_.inputSourceMap;\n          if (inputSourceMap) {\n            var generator = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));\n            generator.applySourceMap(new SourceMapConsumer(inputSourceMap));\n            sourceMap = generator.toJSON();\n          }\n          this.sourceMapCache_ = sourceMap;\n          return sourceMap;\n        }\n      },\n      get sourceMapInfo() {\n        if (!this.sourceMapInfo_ && this.sourceMapConfiguration_) {\n          var sourceMap = this.getSourceMap();\n          this.sourceMapInfo_ = {\n            url: this.sourceMapConfiguration_.sourceURL,\n            outputName: this.sourceMapConfiguration_.outputName,\n            map: sourceMap\n          };\n        }\n        return this.sourceMapInfo_;\n      },\n      write: function(tree) {\n        var outputName = arguments[1];\n        var sourceRoot = arguments[2];\n        var sourceURL = arguments[3];\n        outputName = this.normalize(outputName);\n        if (sourceRoot === undefined)\n          sourceRoot = this.options_.sourceRoot;\n        if (sourceRoot === true)\n          sourceRoot = basePath(outputName);\n        else if (!sourceRoot)\n          sourceRoot = undefined;\n        else\n          sourceRoot = this.normalize(sourceRoot);\n        var writer;\n        this.sourceMapCache_ = null;\n        this.sourceMapConfiguration_ = this.createSourceMapConfiguration_(outputName, sourceRoot, sourceURL);\n        if (this.sourceMapConfiguration_) {\n          this.sourceMapConfiguration_.lowResolution = this.options_.lowResolutionSourceMap;\n          writer = new ParseTreeMapWriter(this.sourceMapConfiguration_, this.options_);\n        } else {\n          writer = new ParseTreeWriter(this.options_);\n        }\n        writer.visitAny(tree);\n        var compiledCode = writer.toString();\n        var link = this.debuggerLink(sourceURL, outputName);\n        if (link) {\n          compiledCode += link;\n        }\n        return compiledCode;\n      },\n      debuggerLink: function(sourceURL, outputName) {\n        if (this.sourceMapConfiguration_) {\n          if (this.options_.sourceMaps === 'memory') {\n            return;\n          }\n          var sourceMappingURL = this.sourceMappingURL(sourceURL || outputName || 'unnamed.js');\n          return '//# sourceMappingURL=' + sourceMappingURL + '\\n';\n        } else {\n          if (sourceURL) {\n            return '//# sourceURL=' + sourceURL + '\\n';\n          }\n        }\n      },\n      sourceName: function(filename) {\n        return filename;\n      },\n      sourceMappingURL: function(path) {\n        if (this.options_.sourceMaps === 'inline') {\n          if (Reflect.global.btoa) {\n            return 'data:application/json;base64,' + btoa(unescape(encodeURIComponent(this.getSourceMap())));\n          }\n        }\n        path = path || 'unamed.js';\n        path = path.split('/').pop();\n        return path + '.map';\n      },\n      sourceNameFromTree: function(tree) {\n        return tree.location.start.source.name;\n      },\n      defaultOptions: function() {\n        return versionLockedOptions;\n      },\n      normalize: function(name) {\n        return name && name.replace(/\\\\/g, '/');\n      }\n    }, {\n      script: function(content) {\n        var options = arguments[1] !== (void 0) ? arguments[1] : {};\n        options = new Options(options);\n        options.script = true;\n        return new Compiler(options).compile(content);\n      },\n      module: function(content) {\n        var options = arguments[1] !== (void 0) ? arguments[1] : {};\n        options = new Options(options);\n        options.modules = 'bootstrap';\n        return new Compiler(options).compile(content);\n      },\n      amdOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var amdOptions = {\n          modules: 'amd',\n          sourceMaps: false,\n          moduleName: false\n        };\n        return merge(amdOptions, options);\n      },\n      closureOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var closureOptions = {\n          modules: 'closure',\n          sourceMaps: false,\n          moduleName: true\n        };\n        return merge(closureOptions, options);\n      },\n      commonJSOptions: function() {\n        var options = arguments[0] !== (void 0) ? arguments[0] : {};\n        var commonjsOptions = {\n          modules: 'commonjs',\n          sourceMaps: false,\n          moduleName: false\n        };\n        return merge(commonjsOptions, options);\n      }\n    });\n  }();\n  return {get Compiler() {\n      return Compiler;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js\";\n  var ParseTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ParseTreeTransformer.js\", \"traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js\")).ParseTreeTransformer;\n  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/codegeneration/CloneTreeTransformer.js\")),\n      BindingIdentifier = $__2.BindingIdentifier,\n      BreakStatement = $__2.BreakStatement,\n      ContinueStatement = $__2.ContinueStatement,\n      DebuggerStatement = $__2.DebuggerStatement,\n      EmptyStatement = $__2.EmptyStatement,\n      ExportSpecifier = $__2.ExportSpecifier,\n      ExportStar = $__2.ExportStar,\n      IdentifierExpression = $__2.IdentifierExpression,\n      LiteralExpression = $__2.LiteralExpression,\n      ModuleSpecifier = $__2.ModuleSpecifier,\n      PredefinedType = $__2.PredefinedType,\n      PropertyNameShorthand = $__2.PropertyNameShorthand,\n      TemplateLiteralPortion = $__2.TemplateLiteralPortion,\n      SuperExpression = $__2.SuperExpression,\n      ThisExpression = $__2.ThisExpression;\n  var CloneTreeTransformer = function($__super) {\n    function CloneTreeTransformer() {\n      $traceurRuntime.superConstructor(CloneTreeTransformer).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(CloneTreeTransformer, {\n      transformBindingIdentifier: function(tree) {\n        return new BindingIdentifier(tree.location, tree.identifierToken);\n      },\n      transformBreakStatement: function(tree) {\n        return new BreakStatement(tree.location, tree.name);\n      },\n      transformContinueStatement: function(tree) {\n        return new ContinueStatement(tree.location, tree.name);\n      },\n      transformDebuggerStatement: function(tree) {\n        return new DebuggerStatement(tree.location);\n      },\n      transformEmptyStatement: function(tree) {\n        return new EmptyStatement(tree.location);\n      },\n      transformExportSpecifier: function(tree) {\n        return new ExportSpecifier(tree.location, tree.lhs, tree.rhs);\n      },\n      transformExportStar: function(tree) {\n        return new ExportStar(tree.location);\n      },\n      transformIdentifierExpression: function(tree) {\n        return new IdentifierExpression(tree.location, tree.identifierToken);\n      },\n      transformList: function(list) {\n        if (!list) {\n          return null;\n        } else if (list.length === 0) {\n          return [];\n        } else {\n          return $traceurRuntime.superGet(this, CloneTreeTransformer.prototype, \"transformList\").call(this, list);\n        }\n      },\n      transformLiteralExpression: function(tree) {\n        return new LiteralExpression(tree.location, tree.literalToken);\n      },\n      transformModuleSpecifier: function(tree) {\n        return new ModuleSpecifier(tree.location, tree.token);\n      },\n      transformPredefinedType: function(tree) {\n        return new PredefinedType(tree.location, tree.typeToken);\n      },\n      transformPropertyNameShorthand: function(tree) {\n        return new PropertyNameShorthand(tree.location, tree.name);\n      },\n      transformTemplateLiteralPortion: function(tree) {\n        return new TemplateLiteralPortion(tree.location, tree.value);\n      },\n      transformSuperExpression: function(tree) {\n        return new SuperExpression(tree.location);\n      },\n      transformThisExpression: function(tree) {\n        return new ThisExpression(tree.location);\n      }\n    }, {}, $__super);\n  }(ParseTreeTransformer);\n  CloneTreeTransformer.cloneTree = function(tree) {\n    return new CloneTreeTransformer().transformAny(tree);\n  };\n  return {get CloneTreeTransformer() {\n      return CloneTreeTransformer;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js\";\n  var parseStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../PlaceholderParser.js\", \"traceur@0.0.111/src/codegeneration/module/createModuleEvaluationStatement.js\")).parseStatement;\n  function createModuleEvaluationStatement(normalizedName) {\n    return parseStatement($traceurRuntime.getTemplateObject([\"$traceurRuntime.getModule(\", \" +'')\"]), normalizedName);\n  }\n  return {get createModuleEvaluationStatement() {\n      return createModuleEvaluationStatement;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/compiler-imports.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/compiler-imports.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_Compiler_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Compiler.js\", \"traceur@0.0.111/src/compiler-imports.js\"));\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./syntax/Parser.js\", \"traceur@0.0.111/src/compiler-imports.js\")).Parser;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/compiler-imports.js\")).Script;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./syntax/SourceFile.js\", \"traceur@0.0.111/src/compiler-imports.js\")).SourceFile;\n  var syntax = {\n    Parser: Parser,\n    SourceFile: SourceFile,\n    trees: {Script: Script}\n  };\n  var ParseTreeMapWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/ParseTreeMapWriter.js\", \"traceur@0.0.111/src/compiler-imports.js\")).ParseTreeMapWriter;\n  var ParseTreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/ParseTreeWriter.js\", \"traceur@0.0.111/src/compiler-imports.js\")).ParseTreeWriter;\n  var regexpuRewritePattern = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/regexpuRewritePattern.js\", \"traceur@0.0.111/src/compiler-imports.js\")).regexpuRewritePattern;\n  var SourceMapConsumer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/SourceMapIntegration.js\", \"traceur@0.0.111/src/compiler-imports.js\")).SourceMapConsumer;\n  var SourceMapGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/SourceMapIntegration.js\", \"traceur@0.0.111/src/compiler-imports.js\")).SourceMapGenerator;\n  var TreeWriter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./outputgeneration/TreeWriter.js\", \"traceur@0.0.111/src/compiler-imports.js\")).TreeWriter;\n  var outputgeneration = {\n    ParseTreeMapWriter: ParseTreeMapWriter,\n    ParseTreeWriter: ParseTreeWriter,\n    regexpuRewritePattern: regexpuRewritePattern,\n    SourceMapConsumer: SourceMapConsumer,\n    SourceMapGenerator: SourceMapGenerator,\n    TreeWriter: TreeWriter\n  };\n  var AttachModuleNameTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/module/AttachModuleNameTransformer.js\", \"traceur@0.0.111/src/compiler-imports.js\")).AttachModuleNameTransformer;\n  var CloneTreeTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/CloneTreeTransformer.js\", \"traceur@0.0.111/src/compiler-imports.js\")).CloneTreeTransformer;\n  var FromOptionsTransformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/FromOptionsTransformer.js\", \"traceur@0.0.111/src/compiler-imports.js\")).FromOptionsTransformer;\n  var PureES6Transformer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/PureES6Transformer.js\", \"traceur@0.0.111/src/compiler-imports.js\")).PureES6Transformer;\n  var createModuleEvaluationStatement = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/module/createModuleEvaluationStatement.js\", \"traceur@0.0.111/src/compiler-imports.js\")).createModuleEvaluationStatement;\n  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./codegeneration/PlaceholderParser.js\", \"traceur@0.0.111/src/compiler-imports.js\")),\n      parseExpression = $__16.parseExpression,\n      parseModule = $__16.parseModule,\n      parseScript = $__16.parseScript,\n      parseStatement = $__16.parseStatement;\n  var codegeneration = {\n    CloneTreeTransformer: CloneTreeTransformer,\n    FromOptionsTransformer: FromOptionsTransformer,\n    PureES6Transformer: PureES6Transformer,\n    parseExpression: parseExpression,\n    parseModule: parseModule,\n    parseScript: parseScript,\n    parseStatement: parseStatement,\n    module: {\n      AttachModuleNameTransformer: AttachModuleNameTransformer,\n      createModuleEvaluationStatement: createModuleEvaluationStatement\n    }\n  };\n  return {\n    get Compiler() {\n      return $__traceur_64_0_46_0_46_111_47_src_47_Compiler_46_js__.Compiler;\n    },\n    get syntax() {\n      return syntax;\n    },\n    get outputgeneration() {\n      return outputgeneration;\n    },\n    get codegeneration() {\n      return codegeneration;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js\";\n  var ModuleVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ModuleVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ValidationVisitor.js\")).ModuleVisitor;\n  var ValidationVisitor = function($__super) {\n    function ValidationVisitor() {\n      $traceurRuntime.superConstructor(ValidationVisitor).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(ValidationVisitor, {\n      checkExport_: function(tree, name) {\n        var description = this.validatingModuleDescription_;\n        if (description && !description.getExport(name)) {\n          var moduleName = description.normalizedName;\n          this.reportError(tree, (\"'\" + name + \"' is not exported by '\" + moduleName + \"'\"));\n        }\n      },\n      checkImport_: function(tree, name) {\n        var existingImport = this.moduleSymbol.getImport(name);\n        if (existingImport) {\n          this.reportError(tree, (\"'\" + name + \"' was previously imported at \" + existingImport.location.start));\n        } else {\n          this.moduleSymbol.addImport(name, tree);\n        }\n      },\n      visitAndValidate_: function(moduleDescription, tree) {\n        var validatingModuleDescription = this.validatingModuleDescription_;\n        this.validatingModuleDescription_ = moduleDescription;\n        this.visitAny(tree);\n        this.validatingModuleDescription_ = validatingModuleDescription;\n      },\n      visitNamedExport: function(tree) {\n        if (tree.moduleSpecifier) {\n          var name = tree.moduleSpecifier.token.processedValue;\n          var moduleDescription = this.getExportsListForModuleSpecifier(name);\n          this.visitAndValidate_(moduleDescription, tree.exportClause);\n        }\n      },\n      visitExportSpecifier: function(tree) {\n        this.checkExport_(tree, tree.lhs.value);\n      },\n      visitForwardDefaultExport: function(tree) {\n        this.checkExport_(tree, 'default');\n      },\n      visitImportDeclaration: function(tree) {\n        var name = tree.moduleSpecifier.token.processedValue;\n        var moduleDescription = this.getExportsListForModuleSpecifier(name);\n        this.visitAndValidate_(moduleDescription, tree.importClause);\n      },\n      visitImportSpecifier: function(tree) {\n        var importName = tree.binding.getStringValue();\n        var exportName = tree.name ? tree.name.value : importName;\n        this.checkImport_(tree, importName);\n        this.checkExport_(tree, exportName);\n      },\n      visitImportedBinding: function(tree) {\n        var importName = tree.binding.getStringValue();\n        this.checkImport_(tree, importName);\n        this.checkExport_(tree, 'default');\n      },\n      visitNameSpaceImport: function(tree) {\n        var importName = tree.binding.binding.getStringValue();\n        this.checkImport_(tree, importName);\n      }\n    }, {}, $__super);\n  }(ModuleVisitor);\n  return {get ValidationVisitor() {\n      return ValidationVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js\";\n  var ExportVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ExportVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js\")).ExportVisitor;\n  var ValidationVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./ValidationVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ExportListBuilder.js\")).ValidationVisitor;\n  function buildExportList(deps, loader, reporter) {\n    function doVisit(ctor) {\n      for (var i = 0; i < deps.length; i++) {\n        var visitor = new ctor(reporter, loader, deps[i]);\n        visitor.visitAny(deps[i].tree);\n      }\n    }\n    function reverseVisit(ctor) {\n      for (var i = deps.length - 1; i >= 0; i--) {\n        var visitor = new ctor(reporter, loader, deps[i]);\n        visitor.visitAny(deps[i].tree);\n      }\n    }\n    reverseVisit(ExportVisitor);\n    doVisit(ValidationVisitor);\n  }\n  return {get buildExportList() {\n      return buildExportList;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js\";\n  var ParseTreeVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../syntax/ParseTreeVisitor.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js\")).ParseTreeVisitor;\n  var StringSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../../util/StringSet.js\", \"traceur@0.0.111/src/codegeneration/module/ModuleSpecifierVisitor.js\")).StringSet;\n  var ModuleSpecifierVisitor = function($__super) {\n    function ModuleSpecifierVisitor(options) {\n      $traceurRuntime.superConstructor(ModuleSpecifierVisitor).call(this);\n      this.options_ = options;\n      this.moduleSpecifiers_ = new StringSet();\n    }\n    return ($traceurRuntime.createClass)(ModuleSpecifierVisitor, {\n      get moduleSpecifiers() {\n        return this.moduleSpecifiers_.valuesAsArray();\n      },\n      visitModuleSpecifier: function(tree) {\n        this.moduleSpecifiers_.add(tree.token.processedValue);\n      }\n    }, {}, $__super);\n  }(ParseTreeVisitor);\n  return {get ModuleSpecifierVisitor() {\n      return ModuleSpecifierVisitor;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/system-map.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/system-map.js\";\n  function prefixMatchLength(name, prefix) {\n    var prefixParts = prefix.split('/');\n    var nameParts = name.split('/');\n    if (prefixParts.length > nameParts.length)\n      return 0;\n    for (var i = 0; i < prefixParts.length; i++) {\n      if (nameParts[i] != prefixParts[i])\n        return 0;\n    }\n    return prefixParts.length;\n  }\n  function applyMap(map, name, parentName) {\n    var curMatch,\n        curMatchLength = 0;\n    var curParent,\n        curParentMatchLength = 0;\n    if (parentName) {\n      var mappedName;\n      Object.getOwnPropertyNames(map).some(function(p) {\n        var curMap = map[p];\n        if (curMap && typeof curMap === 'object') {\n          if (prefixMatchLength(parentName, p) <= curParentMatchLength)\n            return;\n          Object.getOwnPropertyNames(curMap).forEach(function(q) {\n            if (prefixMatchLength(name, q) > curMatchLength) {\n              curMatch = q;\n              curMatchLength = q.split('/').length;\n              curParent = p;\n              curParentMatchLength = p.split('/').length;\n            }\n          });\n        }\n        if (curMatch) {\n          var subPath = name.split('/').splice(curMatchLength).join('/');\n          mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath : '');\n          return mappedName;\n        }\n      });\n    }\n    if (mappedName)\n      return mappedName;\n    Object.getOwnPropertyNames(map).forEach(function(p) {\n      var curMap = map[p];\n      if (curMap && typeof curMap === 'string') {\n        if (prefixMatchLength(name, p) > curMatchLength) {\n          curMatch = p;\n          curMatchLength = p.split('/').length;\n        }\n      }\n    });\n    if (!curMatch)\n      return name;\n    var subPath = name.split('/').splice(curMatchLength).join('/');\n    return map[curMatch] + (subPath ? '/' + subPath : '');\n  }\n  var systemjs = {applyMap: applyMap};\n  return {get systemjs() {\n      return systemjs;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/LoaderCompiler.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/LoaderCompiler.js\";\n  var buildExportList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/module/ExportListBuilder.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).buildExportList;\n  var CollectingErrorReporter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/CollectingErrorReporter.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).CollectingErrorReporter;\n  var Compiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Compiler.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).Compiler;\n  var ModuleSpecifierVisitor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/module/ModuleSpecifierVisitor.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).ModuleSpecifierVisitor;\n  var ModuleSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/module/ModuleSymbol.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).ModuleSymbol;\n  var Parser = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/Parser.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).Parser;\n  var SourceFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/SourceFile.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).SourceFile;\n  var systemjs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./system-map.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).systemjs;\n  var UniqueIdentifierGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/UniqueIdentifierGenerator.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).UniqueIdentifierGenerator;\n  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/url.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")),\n      isAbsolute = $__10.isAbsolute,\n      resolveUrl = $__10.resolveUrl;\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/loader/LoaderCompiler.js\")).assert;\n  var NOT_STARTED = 0;\n  var LOADING = 1;\n  var LOADED = 2;\n  var PARSED = 3;\n  var TRANSFORMING = 4;\n  var TRANSFORMED = 5;\n  var COMPLETE = 6;\n  var ERROR = 7;\n  var identifierGenerator = new UniqueIdentifierGenerator();\n  var anonymousSourcesSeen = 0;\n  var LoaderCompiler = function() {\n    function LoaderCompiler() {}\n    return ($traceurRuntime.createClass)(LoaderCompiler, {\n      getModuleSpecifiers: function(codeUnit) {\n        this.parse(codeUnit);\n        var moduleSpecifierVisitor = new ModuleSpecifierVisitor(codeUnit.metadata.traceurOptions);\n        moduleSpecifierVisitor.visit(codeUnit.metadata.tree);\n        return moduleSpecifierVisitor.moduleSpecifiers;\n      },\n      parse: function(codeUnit) {\n        assert(!codeUnit.metadata.tree);\n        var metadata = codeUnit.metadata;\n        var options = metadata.traceurOptions;\n        if (codeUnit.type === 'script')\n          options.script = true;\n        metadata.compiler = new Compiler(options);\n        var sourceName = codeUnit.metadata.sourceName = codeUnit.address || codeUnit.normalizedName || '(unnamed)#' + String(++anonymousSourcesSeen);\n        metadata.tree = metadata.compiler.parse(codeUnit.source, sourceName);\n      },\n      transform: function(codeUnit) {\n        var metadata = codeUnit.metadata;\n        metadata.transformedTree = metadata.compiler.transform(metadata.tree, codeUnit.normalizedName, metadata);\n      },\n      write: function(codeUnit) {\n        var metadata = codeUnit.metadata;\n        var outputName = metadata.outputName || metadata.sourceName || '<loaderOutput>';\n        var sourceRoot = metadata.sourceRoot;\n        var sourceURL = metadata.sourceName || codeUnit.normalizedName || codeUnit.address;\n        metadata.transcoded = metadata.compiler.write(metadata.transformedTree, outputName, undefined, sourceURL);\n      },\n      evaluateCodeUnit: function(codeUnit) {\n        var result = ('global', eval)(codeUnit.metadata.transcoded);\n        codeUnit.metadata.transformedTree = null;\n        return result;\n      },\n      analyzeDependencies: function(dependencies, loader) {\n        var deps = [];\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          assert(codeUnit.state >= PARSED);\n          if (codeUnit.state == PARSED) {\n            var symbol = codeUnit.metadata.moduleSymbol = new ModuleSymbol(codeUnit.metadata.tree, codeUnit.normalizedName);\n            deps.push(symbol);\n          }\n        }\n        this.checkForErrors(function(reporter) {\n          return buildExportList(deps, loader, reporter);\n        });\n      },\n      checkForErrors: function(fncOfReporter) {\n        var reporter = new CollectingErrorReporter();\n        var result = fncOfReporter(reporter);\n        if (reporter.hadError())\n          throw reporter.toError();\n        return result;\n      }\n    }, {});\n  }();\n  return {get LoaderCompiler() {\n      return LoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/InternalLoader.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/InternalLoader.js\";\n  var assert = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/assert.js\", \"traceur@0.0.111/src/loader/InternalLoader.js\")).assert;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LoaderCompiler.js\", \"traceur@0.0.111/src/loader/InternalLoader.js\")).LoaderCompiler;\n  var ExportsList = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../codegeneration/module/ModuleSymbol.js\", \"traceur@0.0.111/src/loader/InternalLoader.js\")).ExportsList;\n  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/url.js\", \"traceur@0.0.111/src/loader/InternalLoader.js\")),\n      isAbsolute = $__13.isAbsolute,\n      resolveUrl = $__13.resolveUrl;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Options.js\", \"traceur@0.0.111/src/loader/InternalLoader.js\")).Options;\n  var NOT_STARTED = 0;\n  var LOADING = 1;\n  var LOADED = 2;\n  var PARSED = 3;\n  var TRANSFORMING = 4;\n  var TRANSFORMED = 5;\n  var COMPLETE = 6;\n  var ERROR = 7;\n  function mapToValues(map) {\n    var array = [];\n    map.forEach(function(v) {\n      array.push(v);\n    });\n    return array;\n  }\n  var LoaderError = function($__super) {\n    function LoaderError(msg, tree) {\n      $traceurRuntime.superConstructor(LoaderError).call(this);\n      this.message = msg;\n      this.tree = tree;\n      this.name = 'LoaderError';\n    }\n    return ($traceurRuntime.createClass)(LoaderError, {}, {}, $__super);\n  }(Error);\n  var CodeUnit = function() {\n    function CodeUnit(loaderCompiler, normalizedName, type, state, name, referrerName, address) {\n      var $__8 = this;\n      this.promise = new Promise(function(res, rej) {\n        $__8.loaderCompiler = loaderCompiler;\n        $__8.normalizedName = normalizedName;\n        $__8.type = type;\n        $__8.name_ = name;\n        $__8.referrerName_ = referrerName;\n        $__8.address = address;\n        $__8.state_ = state || NOT_STARTED;\n        $__8.error = null;\n        $__8.result = null;\n        $__8.metadata_ = {};\n        $__8.dependencies = [];\n        $__8.resolve = res;\n        $__8.reject = rej;\n      });\n    }\n    return ($traceurRuntime.createClass)(CodeUnit, {\n      get state() {\n        return this.state_;\n      },\n      set state(value) {\n        if (value < this.state_) {\n          throw new Error('Invalid state change');\n        }\n        this.state_ = value;\n      },\n      get metadata() {\n        return this.metadata_;\n      },\n      set metadata(value) {\n        assert(value);\n        this.metadata_ = value;\n      },\n      nameTrace: function() {\n        var trace = this.specifiedAs();\n        if (isAbsolute(this.name_)) {\n          return trace + 'An absolute name.\\n';\n        }\n        if (this.referrerName_) {\n          return trace + this.importedBy() + this.normalizesTo();\n        }\n        return trace + this.normalizesTo();\n      },\n      specifiedAs: function() {\n        return (\"Specified as \" + this.name_ + \".\\n\");\n      },\n      importedBy: function() {\n        return (\"Imported by \" + this.referrerName_ + \".\\n\");\n      },\n      normalizesTo: function() {\n        return 'Normalizes to ' + this.normalizedName + '\\n';\n      }\n    }, {});\n  }();\n  var PreCompiledCodeUnit = function($__super) {\n    function PreCompiledCodeUnit(loaderCompiler, normalizedName, name, referrerName, address, module) {\n      $traceurRuntime.superConstructor(PreCompiledCodeUnit).call(this, loaderCompiler, normalizedName, 'module', COMPLETE, name, referrerName, address);\n      this.result = module;\n      this.resolve(this.result);\n    }\n    return ($traceurRuntime.createClass)(PreCompiledCodeUnit, {}, {}, $__super);\n  }(CodeUnit);\n  var BundledCodeUnit = function($__super) {\n    function BundledCodeUnit(loaderCompiler, normalizedName, name, referrerName, address, deps, execute, setModule) {\n      $traceurRuntime.superConstructor(BundledCodeUnit).call(this, loaderCompiler, normalizedName, 'module', TRANSFORMED, name, referrerName, address);\n      this.deps = deps;\n      this.execute = execute;\n    }\n    return ($traceurRuntime.createClass)(BundledCodeUnit, {\n      getModuleSpecifiers: function() {\n        return this.deps;\n      },\n      evaluate: function() {\n        var $__8 = this;\n        var normalizedNames = this.deps.map(function(name) {\n          return $__8.loader_.normalize(name);\n        });\n        var module = this.execute.apply(Reflect.global, normalizedNames);\n        setModule(this.normalizedName, module);\n        return module;\n      }\n    }, {}, $__super);\n  }(CodeUnit);\n  var HookedCodeUnit = function($__super) {\n    function HookedCodeUnit() {\n      $traceurRuntime.superConstructor(HookedCodeUnit).apply(this, arguments);\n    }\n    return ($traceurRuntime.createClass)(HookedCodeUnit, {\n      getModuleSpecifiers: function() {\n        return this.loaderCompiler.getModuleSpecifiers(this);\n      },\n      evaluate: function() {\n        return this.loaderCompiler.evaluateCodeUnit(this);\n      }\n    }, {}, $__super);\n  }(CodeUnit);\n  var LoadCodeUnit = function($__super) {\n    function LoadCodeUnit(loaderCompiler, normalizedName, name, referrerName, address) {\n      $traceurRuntime.superConstructor(LoadCodeUnit).call(this, loaderCompiler, normalizedName, 'module', NOT_STARTED, name, referrerName, address);\n    }\n    return ($traceurRuntime.createClass)(LoadCodeUnit, {}, {}, $__super);\n  }(HookedCodeUnit);\n  var EvalCodeUnit = function($__super) {\n    function EvalCodeUnit(loaderCompiler, code) {\n      var type = arguments[2] !== (void 0) ? arguments[2] : 'script';\n      var normalizedName = arguments[3];\n      var referrerName = arguments[4];\n      var address = arguments[5];\n      $traceurRuntime.superConstructor(EvalCodeUnit).call(this, loaderCompiler, normalizedName, type, LOADED, null, referrerName, address);\n      this.source = code;\n    }\n    return ($traceurRuntime.createClass)(EvalCodeUnit, {}, {}, $__super);\n  }(HookedCodeUnit);\n  var uniqueNameCount = 0;\n  var InternalLoader = function() {\n    function InternalLoader(loader, loaderCompiler) {\n      assert(loaderCompiler);\n      this.loader_ = loader;\n      this.loaderCompiler = loaderCompiler;\n      this.cache = new Map();\n      this.urlToKey = Object.create(null);\n      this.sync_ = false;\n      this.sourceMapsByURL_ = Object.create(null);\n      this.sourceMapsByOutputName_ = Object.create(null);\n    }\n    return ($traceurRuntime.createClass)(InternalLoader, {\n      defaultMetadata_: function() {\n        var metadata = arguments[0] !== (void 0) ? arguments[0] : {};\n        var incoming = metadata.traceurOptions;\n        if (incoming && !(incoming instanceof Options)) {\n          var unknown = Options.listUnknownOptions(incoming);\n          if (unknown.length) {\n            console.warn('Unknown metadata.traceurOptions ignored: ' + unknown.join(','));\n          }\n        }\n        metadata.traceurOptions = incoming || new Options();\n        return metadata;\n      },\n      defaultModuleMetadata_: function() {\n        var metadata = arguments[0] !== (void 0) ? arguments[0] : {};\n        var metadata = this.defaultMetadata_(metadata);\n        metadata.traceurOptions.script = false;\n        return metadata;\n      },\n      getSourceMap: function(url) {\n        return this.sourceMapsByURL_[url] || this.sourceMapsByOutputName_[url];\n      },\n      load: function(name) {\n        var referrerName = arguments[1] !== (void 0) ? arguments[1] : this.loader_.baseURL;\n        var address = arguments[2];\n        var metadata = arguments[3] !== (void 0) ? arguments[3] : {};\n        metadata = this.defaultMetadata_(metadata);\n        var codeUnit = this.getOrCreateCodeUnit_(name, referrerName, address, metadata);\n        this.load_(codeUnit);\n        return codeUnit.promise.then(function() {\n          return codeUnit;\n        });\n      },\n      load_: function(codeUnit) {\n        var $__8 = this;\n        if (codeUnit.state === ERROR) {\n          return codeUnit;\n        }\n        if (codeUnit.state === TRANSFORMED) {\n          this.handleCodeUnitLoaded(codeUnit);\n        } else {\n          if (codeUnit.state !== NOT_STARTED)\n            return codeUnit;\n          codeUnit.state = LOADING;\n          codeUnit.address = this.loader_.locate(codeUnit);\n          this.loader_.fetch(codeUnit).then(function(text) {\n            codeUnit.source = text;\n            return codeUnit;\n          }).then(function(load) {\n            return $__8.loader_.translate(load);\n          }).then(function(source) {\n            codeUnit.source = source;\n            codeUnit.state = LOADED;\n            $__8.handleCodeUnitLoaded(codeUnit);\n            return codeUnit;\n          }).catch(function(err) {\n            try {\n              codeUnit.state = ERROR;\n              codeUnit.error = err;\n              $__8.handleCodeUnitLoadError(codeUnit);\n            } catch (ex) {\n              console.error('Internal Error ' + (ex.stack || ex));\n            }\n          });\n        }\n        return codeUnit;\n      },\n      module: function(code, referrerName, address, metadata) {\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, 'module', null, referrerName, address);\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set({}, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      define: function(normalizedName, code, address, metadata) {\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, 'module', normalizedName, null, address);\n        var key = this.getKey(normalizedName, 'module');\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set(key, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      script: function(code, name, referrerName, address, metadata) {\n        var normalizedName = this.loader_.normalize(name || '', referrerName, address);\n        var codeUnit = new EvalCodeUnit(this.loaderCompiler, code, 'script', normalizedName, referrerName, address);\n        var key = {};\n        if (name)\n          key = this.getKey(normalizedName, 'script');\n        codeUnit.metadata = this.defaultMetadata_(metadata);\n        this.cache.set(key, codeUnit);\n        this.handleCodeUnitLoaded(codeUnit);\n        return codeUnit.promise;\n      },\n      getKey: function(url, type) {\n        var combined = type + ':' + url;\n        if (combined in this.urlToKey) {\n          return this.urlToKey[combined];\n        }\n        return this.urlToKey[combined] = {};\n      },\n      getCodeUnit_: function(normalizedName, type) {\n        var key = this.getKey(normalizedName, type);\n        var codeUnit = this.cache.get(key);\n        return {\n          key: key,\n          codeUnit: codeUnit\n        };\n      },\n      getOrCreateCodeUnit_: function(name, referrerName, address, metadata) {\n        var normalizedName = this.loader_.normalize(name, referrerName, address);\n        var type = 'module';\n        if (metadata && metadata.traceurOptions && metadata.traceurOptions.script)\n          type = 'script';\n        var $__9 = this.getCodeUnit_(normalizedName, type),\n            key = $__9.key,\n            codeUnit = $__9.codeUnit;\n        if (!codeUnit) {\n          assert(metadata && metadata.traceurOptions);\n          var module = this.loader_.get(normalizedName);\n          if (module) {\n            codeUnit = new PreCompiledCodeUnit(this.loaderCompiler, normalizedName, name, referrerName, address, module);\n            codeUnit.type = 'module';\n          } else {\n            codeUnit = new LoadCodeUnit(this.loaderCompiler, normalizedName, name, referrerName, address);\n            codeUnit.type = type;\n          }\n          codeUnit.metadata = {\n            traceurOptions: metadata.traceurOptions,\n            outputName: metadata.outputName,\n            rootModule: metadata.rootModule\n          };\n          this.cache.set(key, codeUnit);\n        }\n        return codeUnit;\n      },\n      areAll: function(state) {\n        return mapToValues(this.cache).every(function(codeUnit) {\n          return codeUnit.state >= state;\n        });\n      },\n      getCodeUnitForModuleSpecifier: function(name, referrerName) {\n        var normalizedName = this.loader_.normalize(name, referrerName);\n        return this.getCodeUnit_(normalizedName, 'module').codeUnit;\n      },\n      getExportsListForModuleSpecifier: function(name, referrer) {\n        var codeUnit = this.getCodeUnitForModuleSpecifier(name, referrer);\n        var exportsList = codeUnit.metadata.moduleSymbol;\n        if (!exportsList) {\n          if (codeUnit.result) {\n            exportsList = new ExportsList(codeUnit.normalizedName);\n            exportsList.addExportsFromModule(codeUnit.result);\n          } else {\n            throw new Error((\"InternalError: \" + name + \" is not a module, required by \" + referrer));\n          }\n        }\n        return exportsList;\n      },\n      handleCodeUnitLoaded: function(codeUnit) {\n        var $__8 = this;\n        var referrerName = codeUnit.normalizedName;\n        try {\n          var moduleSpecifiers = codeUnit.getModuleSpecifiers();\n          codeUnit.state = PARSED;\n          if (!moduleSpecifiers) {\n            this.abortAll((\"No module specifiers in \" + referrerName));\n            return;\n          }\n          codeUnit.dependencies = moduleSpecifiers.map(function(name) {\n            return $__8.getOrCreateCodeUnit_(name, referrerName, null, $__8.defaultModuleMetadata_(codeUnit.metadata));\n          });\n        } catch (error) {\n          this.rejectOneAndAll(codeUnit, error);\n          return;\n        }\n        codeUnit.dependencies.forEach(function(dependency) {\n          $__8.load_(dependency);\n        });\n        if (this.areAll(PARSED)) {\n          try {\n            if (codeUnit.type === 'module')\n              this.analyze();\n            this.transform();\n            this.evaluate();\n          } catch (error) {\n            this.rejectOneAndAll(codeUnit, error);\n          }\n        }\n      },\n      rejectOneAndAll: function(codeUnit, error) {\n        codeUnit.state.ERROR;\n        codeUnit.error = error;\n        codeUnit.reject(error);\n        this.abortAll(error);\n      },\n      handleCodeUnitLoadError: function(codeUnit) {\n        var message = codeUnit.error ? String(codeUnit.error) + '\\n' : (\"Failed to load '\" + codeUnit.address + \"'.\\n\");\n        message += codeUnit.nameTrace() + this.loader_.nameTrace(codeUnit);\n        this.rejectOneAndAll(codeUnit, new Error(message));\n      },\n      abortAll: function(errorMessage) {\n        this.cache.forEach(function(codeUnit) {\n          if (codeUnit.state !== ERROR)\n            codeUnit.reject(errorMessage);\n        });\n      },\n      analyze: function() {\n        this.loaderCompiler.analyzeDependencies(mapToValues(this.cache), this);\n      },\n      transform: function() {\n        this.transformDependencies_(mapToValues(this.cache));\n      },\n      transformDependencies_: function(dependencies, dependentName) {\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= TRANSFORMED) {\n            continue;\n          }\n          if (codeUnit.state === TRANSFORMING) {\n            var cir = codeUnit.normalizedName;\n            var cle = dependentName;\n            this.rejectOneAndAll(codeUnit, new Error((\"Unsupported circular dependency between \" + cir + \" and \" + cle)));\n            return;\n          }\n          codeUnit.state = TRANSFORMING;\n          try {\n            this.transformCodeUnit_(codeUnit);\n          } catch (error) {\n            this.rejectOneAndAll(codeUnit, error);\n            return;\n          }\n        }\n      },\n      transformCodeUnit_: function(codeUnit) {\n        this.transformDependencies_(codeUnit.dependencies, codeUnit.normalizedName);\n        if (codeUnit.state === ERROR)\n          return;\n        this.loaderCompiler.transform(codeUnit);\n        codeUnit.state = TRANSFORMED;\n        this.loaderCompiler.write(codeUnit);\n        var info = codeUnit.metadata.compiler.sourceMapInfo;\n        if (info) {\n          this.sourceMapsByURL_[info.url] = info.map;\n          this.sourceMapsByOutputName_[info.outputName] = info.map;\n        }\n        this.loader_.instantiate(codeUnit);\n      },\n      orderDependencies: function() {\n        var visited = new Map();\n        var ordered = [];\n        function orderCodeUnits(codeUnit) {\n          if (visited.has(codeUnit)) {\n            return;\n          }\n          visited.set(codeUnit, true);\n          codeUnit.dependencies.forEach(orderCodeUnits);\n          ordered.push(codeUnit);\n        }\n        this.cache.forEach(orderCodeUnits);\n        return ordered;\n      },\n      evaluate: function() {\n        var dependencies = this.orderDependencies();\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= COMPLETE) {\n            continue;\n          }\n          var result = void 0;\n          try {\n            result = codeUnit.evaluate();\n          } catch (ex) {\n            this.rejectOneAndAll(codeUnit, ex);\n            return;\n          }\n          codeUnit.result = result;\n          codeUnit.source = null;\n        }\n        for (var i = 0; i < dependencies.length; i++) {\n          var codeUnit = dependencies[i];\n          if (codeUnit.state >= COMPLETE) {\n            continue;\n          }\n          codeUnit.state = COMPLETE;\n          codeUnit.resolve(codeUnit.result);\n        }\n      }\n    }, {});\n  }();\n  var internals = {\n    CodeUnit: CodeUnit,\n    EvalCodeUnit: EvalCodeUnit,\n    LoadCodeUnit: LoadCodeUnit,\n    LoaderCompiler: LoaderCompiler\n  };\n  return {\n    get InternalLoader() {\n      return InternalLoader;\n    },\n    get internals() {\n      return internals;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/Loader.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/Loader.js\";\n  var InternalLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InternalLoader.js\", \"traceur@0.0.111/src/loader/Loader.js\")).InternalLoader;\n  function throwAbstractMethod() {\n    throw new Error('Unimplemented Loader function, see extended class');\n  }\n  var Loader = function() {\n    function Loader(loaderCompiler) {\n      this.internalLoader_ = new InternalLoader(this, loaderCompiler);\n      this.loaderCompiler_ = loaderCompiler;\n    }\n    return ($traceurRuntime.createClass)(Loader, {\n      import: function(name) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return this.internalLoader_.load(name, referrerName, address, metadata).then(function(codeUnit) {\n          return $__2.get(codeUnit.normalizedName);\n        });\n      },\n      module: function(source) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.module(source, referrerName, address, metadata);\n      },\n      define: function(normalizedName, source) {\n        var $__3 = arguments[2] !== (void 0) ? arguments[2] : {},\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.define(normalizedName, source, address, metadata);\n      },\n      get: function(normalizedName) {\n        throwAbstractMethod();\n      },\n      set: function(normalizedName, module) {\n        throwAbstractMethod();\n      },\n      normalize: function(name, referrerName, referrerAddress) {\n        throwAbstractMethod();\n      },\n      locate: function(load) {\n        throwAbstractMethod();\n      },\n      fetch: function(load) {\n        throwAbstractMethod();\n      },\n      translate: function(load) {\n        throwAbstractMethod();\n      },\n      instantiate: function(load) {\n        throwAbstractMethod();\n      }\n    }, {});\n  }();\n  return {\n    get throwAbstractMethod() {\n      return throwAbstractMethod;\n    },\n    get Loader() {\n      return Loader;\n    },\n    get LoaderCompiler() {\n      return LoaderCompiler;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/version.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/version.js\";\n  var version = '0.0.111';\n  return {get version() {\n      return version;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/TraceurLoader.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/TraceurLoader.js\";\n  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../util/url.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")),\n      isAbsolute = $__5.isAbsolute,\n      resolveUrl = $__5.resolveUrl;\n  var Loader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Loader.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).Loader;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LoaderCompiler.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).LoaderCompiler;\n  var Options = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../Options.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).Options;\n  var systemjs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./system-map.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).systemjs;\n  var webLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./webLoader.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).webLoader;\n  var version = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./version.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).version;\n  var WebPageTranscoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../WebPageTranscoder.js\", \"traceur@0.0.111/src/loader/TraceurLoader.js\")).WebPageTranscoder;\n  var uniqueNameCount = 0;\n  var TraceurLoader = function($__super) {\n    function TraceurLoader(fileLoader, baseURL) {\n      var loaderCompiler = arguments[2] !== (void 0) ? arguments[2] : new LoaderCompiler();\n      $traceurRuntime.superConstructor(TraceurLoader).call(this, loaderCompiler);\n      this.fileLoader_ = fileLoader;\n      this.baseURL_ = baseURL && String(baseURL);\n      this.moduleStore_ = $traceurRuntime.ModuleStore;\n    }\n    return ($traceurRuntime.createClass)(TraceurLoader, {\n      get baseURL() {\n        return this.baseURL_;\n      },\n      set baseURL(value) {\n        this.baseURL_ = String(value);\n      },\n      get: function(normalizedName) {\n        return this.moduleStore_.get(normalizedName);\n      },\n      set: function(normalizedName, module) {\n        this.moduleStore_.set(normalizedName, module);\n      },\n      normalize: function(name, referrerName, referrerAddress) {\n        var normalizedName = this.moduleStore_.normalize(name, referrerName, referrerAddress);\n        if (typeof systemjs !== 'undefined' && System.map)\n          return systemjs.applyMap(System.map, normalizedName, referrerName);\n        return normalizedName;\n      },\n      locate: function(load) {\n        load.metadata.traceurOptions = load.metadata.traceurOptions || {};\n        var url = load.normalizedName;\n        var options = load.metadata.traceurOptions;\n        var baseURL = load.metadata && load.metadata.baseURL;\n        baseURL = baseURL || this.baseURL;\n        var referrer = options && options.referrer;\n        if (referrer) {\n          var minChars = Math.min(referrer.length, baseURL.length);\n          var commonChars = 0;\n          for (var i = 0; i < minChars; i++) {\n            var aChar = referrer[referrer.length - 1 - i];\n            if (aChar === baseURL[baseURL.length - 1 - i])\n              commonChars++;\n            else\n              break;\n          }\n          if (commonChars) {\n            var packageName = referrer.slice(0, -commonChars);\n            var rootDirectory = baseURL.slice(0, -commonChars);\n            if (url.indexOf(packageName) === 0) {\n              url = url.replace(packageName, rootDirectory);\n            }\n          }\n        }\n        if (!isAbsolute(url)) {\n          if (baseURL) {\n            load.metadata.baseURL = baseURL;\n            url = resolveUrl(baseURL, url);\n          }\n        }\n        return url;\n      },\n      sourceName: function(load) {\n        var options = load.metadata.traceurOptions;\n        var sourceName = load.address;\n        if (options.sourceMaps) {\n          var sourceRoot = this.baseURL;\n          if (sourceName) {\n            if (sourceRoot && sourceName.indexOf(sourceRoot) === 0) {\n              sourceName = sourceName.substring(sourceRoot.length);\n            }\n          } else {\n            sourceName = this.baseURL + String(uniqueNameCount++);\n          }\n        }\n        return sourceName;\n      },\n      nameTrace: function(load) {\n        var trace = '';\n        if (load.metadata.locateMap) {\n          trace += this.locateMapTrace(load);\n        }\n        var base = load.metadata.baseURL || this.baseURL;\n        if (base) {\n          trace += this.baseURLTrace(base);\n        } else {\n          trace += 'No baseURL\\n';\n        }\n        return trace;\n      },\n      locateMapTrace: function(load) {\n        var map = load.metadata.locateMap;\n        return (\"locate found \\'\" + map.pattern + \"\\' -> \\'\" + map.replacement + \"\\'\\n\");\n      },\n      baseURLTrace: function(base) {\n        return 'locate resolved against base \\'' + base + '\\'\\n';\n      },\n      fetch: function(load) {\n        var $__2 = this;\n        return new Promise(function(resolve, reject) {\n          if (!load)\n            reject(new TypeError('fetch requires argument object'));\n          else if (!load.address || typeof load.address !== 'string')\n            reject(new TypeError('fetch({address}) missing required string.'));\n          else\n            $__2.fileLoader_.load(load.address, resolve, reject);\n        });\n      },\n      translate: function(load) {\n        return load.source;\n      },\n      instantiate: function($__3) {\n        var $__4 = $__3,\n            name = $__4.name,\n            metadata = $__4.metadata,\n            address = $__4.address,\n            source = $__4.source,\n            sourceMap = $__4.sourceMap;\n        return new Promise(function(resolve, reject) {\n          resolve(undefined);\n        });\n      },\n      bundledModule: function(name) {\n        return this.moduleStore_.bundleStore[name];\n      },\n      importAll: function(names) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return Promise.all(names.map(function(name) {\n          return $__2.import(name, {\n            referrerName: referrerName,\n            address: address,\n            metadata: metadata\n          });\n        }));\n      },\n      loadAsScript: function(name) {\n        var $__4;\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = ($__4 = $__3.metadata) === void 0 ? {} : $__4;\n        metadata.traceurOptions = metadata.traceurOptions || {};\n        metadata.traceurOptions.script = true;\n        return this.internalLoader_.load(name, referrerName, address, metadata).then(function(load) {\n          return load.result;\n        });\n      },\n      loadAsScriptAll: function(names) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        var $__2 = this;\n        return Promise.all(names.map(function(name) {\n          return $__2.loadAsScript(name, {\n            referrerName: referrerName,\n            address: address,\n            metadata: metadata\n          });\n        }));\n      },\n      script: function(source) {\n        var $__3 = arguments[1] !== (void 0) ? arguments[1] : {},\n            name = $__3.name,\n            referrerName = $__3.referrerName,\n            address = $__3.address,\n            metadata = $__3.metadata;\n        return this.internalLoader_.script(source, name, referrerName, address, metadata);\n      },\n      semVerRegExp_: function() {\n        return /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+[0-9A-Za-z-]+)?$/;\n      },\n      semverMap: function(normalizedName) {\n        var slash = normalizedName.indexOf('/');\n        if (slash < 0) {\n          slash = normalizedName.length;\n        }\n        var versionPart = normalizedName.slice(0, slash);\n        var at = versionPart.indexOf('@');\n        if (at !== -1) {\n          var semver = versionPart.slice(at + 1);\n          var m = this.semVerRegExp_().exec(semver);\n          if (m) {\n            var major = m[1];\n            var minor = m[2];\n            var packageName = versionPart.slice(0, at);\n            var map = Object.create(null);\n            map[packageName] = versionPart;\n            map[packageName + '@' + major] = versionPart;\n            map[packageName + '@' + major + '.' + minor] = versionPart;\n            return map;\n          }\n          throw new Error('semverMap found no matching semver regexp in ' + semver);\n        }\n        throw new Error('semverMap expected name@semver, got ' + versionPart + ' ' + normalizedName);\n      },\n      get version() {\n        return version;\n      },\n      getSourceMap: function(filename) {\n        return this.internalLoader_.getSourceMap(filename);\n      },\n      register: function(normalizedName, deps, factoryFunction) {\n        $traceurRuntime.ModuleStore.register(normalizedName, deps, factoryFunction);\n      },\n      registerModule: function(normalizedName, deps, factoryFunction) {\n        $traceurRuntime.ModuleStore.registerModule(normalizedName, deps, factoryFunction);\n      },\n      dirname: function(filename) {\n        var lastSlash = filename.lastIndexOf('/');\n        if (lastSlash === -1)\n          return '.';\n        if (lastSlash === 0)\n          return '/';\n        return filename.slice(0, lastSlash);\n      }\n    }, {}, $__super);\n  }(Loader);\n  var BrowserTraceurLoader = function($__super) {\n    function BrowserTraceurLoader() {\n      $traceurRuntime.superConstructor(BrowserTraceurLoader).call(this, webLoader, window.location.href, new LoaderCompiler());\n    }\n    return ($traceurRuntime.createClass)(BrowserTraceurLoader, {loadScriptTypeModule: function() {\n        var traceurOptions = arguments[0] !== (void 0) ? arguments[0] : new Options();\n        new traceur.WebPageTranscoder(document.location.href, traceurOptions).run();\n      }}, {}, $__super);\n  }(TraceurLoader);\n  return {\n    get TraceurLoader() {\n      return TraceurLoader;\n    },\n    get BrowserTraceurLoader() {\n      return BrowserTraceurLoader;\n    }\n  };\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/node/NodeLoaderCompiler.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/node/NodeLoaderCompiler.js\";\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../loader/LoaderCompiler.js\", \"traceur@0.0.111/src/node/NodeLoaderCompiler.js\")).LoaderCompiler;\n  var NodeLoaderCompiler = function($__super) {\n    function NodeLoaderCompiler() {\n      $traceurRuntime.superConstructor(NodeLoaderCompiler).call(this);\n      this.sourceMapsInMemory_ = false;\n    }\n    return ($traceurRuntime.createClass)(NodeLoaderCompiler, {\n      evaluateCodeUnit: function(codeUnit) {\n        var runInThisContext = require('vm').runInThisContext;\n        var semver = require('semver');\n        var content = codeUnit.metadata.transcoded;\n        var filename = codeUnit.address || codeUnit.normalizedName;\n        if (codeUnit.metadata.traceurOptions.sourceMaps === 'memory') {\n          this.enableMemorySourceMaps_();\n        }\n        var options;\n        if (semver.gte(process.version, '0.12.0')) {\n          options = {filename: filename};\n        } else {\n          options = filename;\n        }\n        var result = runInThisContext(content, options);\n        codeUnit.metadata.transformedTree = null;\n        return result;\n      },\n      enableMemorySourceMaps_: function() {\n        if (this.sourceMapsInMemory_) {\n          return;\n        }\n        require('source-map-support').install({retrieveSourceMap: function(url) {\n            try {\n              var map = System.getSourceMap(url);\n              if (map) {\n                return {\n                  url: url,\n                  map: map\n                };\n              }\n            } catch (ex) {\n              console.error('retrieveSourceMap FAILED ', ex);\n            }\n          }});\n        this.sourceMapsInMemory_ = true;\n      }\n    }, {}, $__super);\n  }(LoaderCompiler);\n  return {get NodeLoaderCompiler() {\n      return NodeLoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/InlineLoaderCompiler.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/InlineLoaderCompiler.js\";\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LoaderCompiler.js\", \"traceur@0.0.111/src/loader/InlineLoaderCompiler.js\")).LoaderCompiler;\n  var Script = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../syntax/trees/ParseTrees.js\", \"traceur@0.0.111/src/loader/InlineLoaderCompiler.js\")).Script;\n  var InlineLoaderCompiler = function($__super) {\n    function InlineLoaderCompiler(elements) {\n      $traceurRuntime.superConstructor(InlineLoaderCompiler).call(this);\n      this.elements = elements;\n    }\n    return ($traceurRuntime.createClass)(InlineLoaderCompiler, {\n      write: function() {},\n      evaluateCodeUnit: function(codeUnit) {\n        var $__1;\n        var tree = codeUnit.metadata.transformedTree;\n        ($__1 = this.elements).push.apply($__1, $traceurRuntime.spread(tree.scriptItemList));\n      },\n      toTree: function() {\n        return new Script(null, this.elements, null);\n      }\n    }, {}, $__super);\n  }(LoaderCompiler);\n  return {get InlineLoaderCompiler() {\n      return InlineLoaderCompiler;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/NodeTraceurLoader.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/NodeTraceurLoader.js\";\n  var TraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TraceurLoader.js\", \"traceur@0.0.111/src/loader/NodeTraceurLoader.js\")).TraceurLoader;\n  var NodeLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../node/NodeLoaderCompiler.js\", \"traceur@0.0.111/src/loader/NodeTraceurLoader.js\")).NodeLoaderCompiler;\n  var NodeTraceurLoader = function($__super) {\n    function NodeTraceurLoader() {\n      var path = require('path');\n      var fileloader = require('../node/nodeLoader.js');\n      var url = (path.resolve('./') + '/').replace(/\\\\/g, '/');\n      $traceurRuntime.superConstructor(NodeTraceurLoader).call(this, fileloader, url, new NodeLoaderCompiler());\n      this.traceurMap_ = null;\n    }\n    return ($traceurRuntime.createClass)(NodeTraceurLoader, {getSourceMap: function(filename) {\n        var map = $traceurRuntime.superGet(this, NodeTraceurLoader.prototype, \"getSourceMap\").call(this, filename);\n        if (!map && filename.replace(/\\\\/g, '/').endsWith('/bin/traceur.js')) {\n          if (!this.traceurMap_) {\n            var fs = require('fs');\n            this.traceurMap_ = fs.readFileSync(filename + '.map', 'utf8');\n          }\n          map = this.traceurMap_;\n        }\n        return map;\n      }}, {}, $__super);\n  }(TraceurLoader);\n  return {get NodeTraceurLoader() {\n      return NodeTraceurLoader;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/loader/loader-imports.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/loader/loader-imports.js\";\n  var Loader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./Loader.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).Loader;\n  var LoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./LoaderCompiler.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).LoaderCompiler;\n  var BrowserTraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TraceurLoader.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).BrowserTraceurLoader;\n  var NodeLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"../node/NodeLoaderCompiler.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).NodeLoaderCompiler;\n  var InlineLoaderCompiler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./InlineLoaderCompiler.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).InlineLoaderCompiler;\n  var NodeTraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./NodeTraceurLoader.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).NodeTraceurLoader;\n  var TraceurLoader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./TraceurLoader.js\", \"traceur@0.0.111/src/loader/loader-imports.js\")).TraceurLoader;\n  var loader = {\n    BrowserTraceurLoader: BrowserTraceurLoader,\n    InlineLoaderCompiler: InlineLoaderCompiler,\n    Loader: Loader,\n    LoaderCompiler: LoaderCompiler,\n    NodeLoaderCompiler: NodeLoaderCompiler,\n    NodeTraceurLoader: NodeTraceurLoader,\n    TraceurLoader: TraceurLoader\n  };\n  return {get loader() {\n      return loader;\n    }};\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/traceur.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/traceur.js\";\n  var $__traceur_64_0_46_0_46_111_47_src_47_util_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./util-imports.js\", \"traceur@0.0.111/src/traceur.js\"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_compiler_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./compiler-imports.js\", \"traceur@0.0.111/src/traceur.js\"));\n  var $__traceur_64_0_46_0_46_111_47_src_47_loader_47_loader_45_imports_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./loader/loader-imports.js\", \"traceur@0.0.111/src/traceur.js\"));\n  return $traceurRuntime.exportStar({}, $__traceur_64_0_46_0_46_111_47_src_47_util_45_imports_46_js__, $__traceur_64_0_46_0_46_111_47_src_47_compiler_45_imports_46_js__, $__traceur_64_0_46_0_46_111_47_src_47_loader_47_loader_45_imports_46_js__);\n});\n$traceurRuntime.registerModule(\"traceur@0.0.111/src/traceur-import.js\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur@0.0.111/src/traceur-import.js\";\n  var traceur = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName(\"./traceur.js\", \"traceur@0.0.111/src/traceur-import.js\"));\n  Reflect.global.traceur = traceur;\n  $traceurRuntime.ModuleStore.set('traceur@', traceur);\n  return {};\n});\n$traceurRuntime.getModule(\"traceur@0.0.111/src/traceur-import.js\" + '');\n//# sourceMappingURL=traceur.js.map\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = traceur;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXhwb3J0cy1sb2FkZXIvaW5kZXguanM/dHJhY2V1ciEuL25vZGVfbW9kdWxlcy90cmFjZXVyL2Jpbi90cmFjZXVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RyYWNldXIvYmluL3RyYWNldXIuanM/NjkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKGdsb2JhbC4kdHJhY2V1clJ1bnRpbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gc2V0dXBHbG9iYWxzKGdsb2JhbCkge1xuICAgIGdsb2JhbC5SZWZsZWN0ID0gZ2xvYmFsLlJlZmxlY3QgfHwge307XG4gICAgZ2xvYmFsLlJlZmxlY3QuZ2xvYmFsID0gZ2xvYmFsLlJlZmxlY3QuZ2xvYmFsIHx8IGdsb2JhbDtcbiAgfVxuICBzZXR1cEdsb2JhbHMoZ2xvYmFsKTtcbiAgdmFyIHR5cGVPZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHg7XG4gIH07XG4gIGdsb2JhbC4kdHJhY2V1clJ1bnRpbWUgPSB7XG4gICAgb3B0aW9uczoge30sXG4gICAgc2V0dXBHbG9iYWxzOiBzZXR1cEdsb2JhbHMsXG4gICAgdHlwZW9mOiB0eXBlT2ZcbiAgfTtcbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGJ1aWxkRnJvbUVuY29kZWRQYXJ0cyhvcHRfc2NoZW1lLCBvcHRfdXNlckluZm8sIG9wdF9kb21haW4sIG9wdF9wb3J0LCBvcHRfcGF0aCwgb3B0X3F1ZXJ5RGF0YSwgb3B0X2ZyYWdtZW50KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGlmIChvcHRfc2NoZW1lKSB7XG4gICAgICBvdXQucHVzaChvcHRfc2NoZW1lLCAnOicpO1xuICAgIH1cbiAgICBpZiAob3B0X2RvbWFpbikge1xuICAgICAgb3V0LnB1c2goJy8vJyk7XG4gICAgICBpZiAob3B0X3VzZXJJbmZvKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF91c2VySW5mbywgJ0AnKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKG9wdF9kb21haW4pO1xuICAgICAgaWYgKG9wdF9wb3J0KSB7XG4gICAgICAgIG91dC5wdXNoKCc6Jywgb3B0X3BvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0X3BhdGgpIHtcbiAgICAgIG91dC5wdXNoKG9wdF9wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdF9xdWVyeURhdGEpIHtcbiAgICAgIG91dC5wdXNoKCc/Jywgb3B0X3F1ZXJ5RGF0YSk7XG4gICAgfVxuICAgIGlmIChvcHRfZnJhZ21lbnQpIHtcbiAgICAgIG91dC5wdXNoKCcjJywgb3B0X2ZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfVxuICB2YXIgc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICsgJyg/OicgKyAnKFteOi8/Iy5dKyknICsgJzopPycgKyAnKD86Ly8nICsgJyg/OihbXi8/I10qKUApPycgKyAnKFtcXFxcd1xcXFxkXFxcXC1cXFxcdTAxMDAtXFxcXHVmZmZmLiVdKiknICsgJyg/OjooWzAtOV0rKSk/JyArICcpPycgKyAnKFtePyNdKyk/JyArICcoPzpcXFxcPyhbXiNdKikpPycgKyAnKD86IyguKikpPycgKyAnJCcpO1xuICB2YXIgQ29tcG9uZW50SW5kZXggPSB7XG4gICAgU0NIRU1FOiAxLFxuICAgIFVTRVJfSU5GTzogMixcbiAgICBET01BSU46IDMsXG4gICAgUE9SVDogNCxcbiAgICBQQVRIOiA1LFxuICAgIFFVRVJZX0RBVEE6IDYsXG4gICAgRlJBR01FTlQ6IDdcbiAgfTtcbiAgZnVuY3Rpb24gc3BsaXQodXJpKSB7XG4gICAgcmV0dXJuICh1cmkubWF0Y2goc3BsaXRSZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKHBhdGgpIHtcbiAgICBpZiAocGF0aCA9PT0gJy8nKVxuICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnNsaWNlKC0xKSA9PT0gJy8nID8gJy8nIDogJyc7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgdXAgPSAwO1xuICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbcG9zXTtcbiAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgIGlmIChvdXQubGVuZ3RoKVxuICAgICAgICAgICAgb3V0LnBvcCgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbGVhZGluZ1NsYXNoKSB7XG4gICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICB9XG4gICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xuICB9XG4gIGZ1bmN0aW9uIGpvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIHBhdGggPSBwYXJ0c1tDb21wb25lbnRJbmRleC5QQVRIXSB8fCAnJztcbiAgICBwYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF0gPSBwYXRoO1xuICAgIHJldHVybiBidWlsZEZyb21FbmNvZGVkUGFydHMocGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXSwgcGFydHNbQ29tcG9uZW50SW5kZXguVVNFUl9JTkZPXSwgcGFydHNbQ29tcG9uZW50SW5kZXguRE9NQUlOXSwgcGFydHNbQ29tcG9uZW50SW5kZXguUE9SVF0sIHBhcnRzW0NvbXBvbmVudEluZGV4LlBBVEhdLCBwYXJ0c1tDb21wb25lbnRJbmRleC5RVUVSWV9EQVRBXSwgcGFydHNbQ29tcG9uZW50SW5kZXguRlJBR01FTlRdKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5vbmljYWxpemVVcmwodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gc3BsaXQodXJsKTtcbiAgICByZXR1cm4gam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIHBhcnRzID0gc3BsaXQodXJsKTtcbiAgICB2YXIgYmFzZVBhcnRzID0gc3BsaXQoYmFzZSk7XG4gICAgaWYgKHBhcnRzW0NvbXBvbmVudEluZGV4LlNDSEVNRV0pIHtcbiAgICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzW0NvbXBvbmVudEluZGV4LlNDSEVNRV0gPSBiYXNlUGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IENvbXBvbmVudEluZGV4LlNDSEVNRTsgaSA8PSBDb21wb25lbnRJbmRleC5QT1JUOyBpKyspIHtcbiAgICAgIGlmICghcGFydHNbaV0pIHtcbiAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tDb21wb25lbnRJbmRleC5QQVRIXVswXSA9PSAnLycpIHtcbiAgICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgfVxuICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW0NvbXBvbmVudEluZGV4LlBBVEhdO1xuICAgIHZhciBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpICsgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF07XG4gICAgcGFydHNbQ29tcG9uZW50SW5kZXguUEFUSF0gPSBwYXRoO1xuICAgIHJldHVybiBqb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBYnNvbHV0ZShuYW1lKSB7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYW1lWzBdID09PSAnLycpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgcGFydHMgPSBzcGxpdChuYW1lKTtcbiAgICBpZiAocGFydHNbQ29tcG9uZW50SW5kZXguU0NIRU1FXSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAkdHJhY2V1clJ1bnRpbWUuY2Fub25pY2FsaXplVXJsID0gY2Fub25pY2FsaXplVXJsO1xuICAkdHJhY2V1clJ1bnRpbWUuaXNBYnNvbHV0ZSA9IGlzQWJzb2x1dGU7XG4gICR0cmFjZXVyUnVudGltZS5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuICAkdHJhY2V1clJ1bnRpbWUucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG59KSgpO1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLFxuICAgICAgY2Fub25pY2FsaXplVXJsID0gJF9fMy5jYW5vbmljYWxpemVVcmwsXG4gICAgICByZXNvbHZlVXJsID0gJF9fMy5yZXNvbHZlVXJsLFxuICAgICAgaXNBYnNvbHV0ZSA9ICRfXzMuaXNBYnNvbHV0ZTtcbiAgdmFyIG1vZHVsZUluc3RhbnRpYXRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgYmFzZVVSTDtcbiAgaWYgKGdsb2JhbC5sb2NhdGlvbiAmJiBnbG9iYWwubG9jYXRpb24uaHJlZilcbiAgICBiYXNlVVJMID0gcmVzb2x2ZVVybChnbG9iYWwubG9jYXRpb24uaHJlZiwgJy4vJyk7XG4gIGVsc2VcbiAgICBiYXNlVVJMID0gJyc7XG4gIGZ1bmN0aW9uIFVuY29hdGVkTW9kdWxlRW50cnkodXJsLCB1bmNvYXRlZE1vZHVsZSkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudmFsdWVfID0gdW5jb2F0ZWRNb2R1bGU7XG4gIH1cbiAgZnVuY3Rpb24gTW9kdWxlRXZhbHVhdGlvbkVycm9yKGVycm9uZW91c01vZHVsZU5hbWUsIGNhdXNlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJzogJyArIHRoaXMuc3RyaXBDYXVzZShjYXVzZSkgKyAnIGluICcgKyBlcnJvbmVvdXNNb2R1bGVOYW1lO1xuICAgIGlmICghKGNhdXNlIGluc3RhbmNlb2YgTW9kdWxlRXZhbHVhdGlvbkVycm9yKSAmJiBjYXVzZS5zdGFjaylcbiAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0cmlwU3RhY2soY2F1c2Uuc3RhY2spO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICBNb2R1bGVFdmFsdWF0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBNb2R1bGVFdmFsdWF0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlRXZhbHVhdGlvbkVycm9yO1xuICBNb2R1bGVFdmFsdWF0aW9uRXJyb3IucHJvdG90eXBlLnN0cmlwRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvLipFcnJvcjovLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnOicpO1xuICB9O1xuICBNb2R1bGVFdmFsdWF0aW9uRXJyb3IucHJvdG90eXBlLnN0cmlwQ2F1c2UgPSBmdW5jdGlvbihjYXVzZSkge1xuICAgIGlmICghY2F1c2UpXG4gICAgICByZXR1cm4gJyc7XG4gICAgaWYgKCFjYXVzZS5tZXNzYWdlKVxuICAgICAgcmV0dXJuIGNhdXNlICsgJyc7XG4gICAgcmV0dXJuIHRoaXMuc3RyaXBFcnJvcihjYXVzZS5tZXNzYWdlKTtcbiAgfTtcbiAgTW9kdWxlRXZhbHVhdGlvbkVycm9yLnByb3RvdHlwZS5sb2FkZWRCeSA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUpIHtcbiAgICB0aGlzLnN0YWNrICs9ICdcXG4gbG9hZGVkIGJ5ICcgKyBtb2R1bGVOYW1lO1xuICB9O1xuICBNb2R1bGVFdmFsdWF0aW9uRXJyb3IucHJvdG90eXBlLnN0cmlwU3RhY2sgPSBmdW5jdGlvbihjYXVzZVN0YWNrKSB7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgY2F1c2VTdGFjay5zcGxpdCgnXFxuJykuc29tZShmdW5jdGlvbihmcmFtZSkge1xuICAgICAgaWYgKC9VbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvci8udGVzdChmcmFtZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgc3RhY2sucHVzaChmcmFtZSk7XG4gICAgfSk7XG4gICAgc3RhY2tbMF0gPSB0aGlzLnN0cmlwRXJyb3Ioc3RhY2tbMF0pO1xuICAgIHJldHVybiBzdGFjay5qb2luKCdcXG4nKTtcbiAgfTtcbiAgZnVuY3Rpb24gYmVmb3JlTGluZXMobGluZXMsIG51bWJlcikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZmlyc3QgPSBudW1iZXIgLSAzO1xuICAgIGlmIChmaXJzdCA8IDApXG4gICAgICBmaXJzdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0OyBpIDwgbnVtYmVyOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckxpbmVzKGxpbmVzLCBudW1iZXIpIHtcbiAgICB2YXIgbGFzdCA9IG51bWJlciArIDE7XG4gICAgaWYgKGxhc3QgPiBsaW5lcy5sZW5ndGggLSAxKVxuICAgICAgbGFzdCA9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBudW1iZXI7IGkgPD0gbGFzdDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gY29sdW1uU3BhY2luZyhjb2x1bW5zKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucyAtIDE7IGkrKykge1xuICAgICAgcmVzdWx0ICs9ICctJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcih1cmwsIGZ1bmMpIHtcbiAgICBVbmNvYXRlZE1vZHVsZUVudHJ5LmNhbGwodGhpcywgdXJsLCBudWxsKTtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICB9XG4gIFVuY29hdGVkTW9kdWxlSW5zdGFudGlhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVW5jb2F0ZWRNb2R1bGVFbnRyeS5wcm90b3R5cGUpO1xuICBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvci5wcm90b3R5cGUuZ2V0VW5jb2F0ZWRNb2R1bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgJF9fMiA9IHRoaXM7XG4gICAgaWYgKHRoaXMudmFsdWVfKVxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVsYXRpdmVSZXF1aXJlO1xuICAgICAgaWYgKHR5cGVvZiAkdHJhY2V1clJ1bnRpbWUgIT09IHVuZGVmaW5lZCAmJiAkdHJhY2V1clJ1bnRpbWUucmVxdWlyZSkge1xuICAgICAgICByZWxhdGl2ZVJlcXVpcmUgPSAkdHJhY2V1clJ1bnRpbWUucmVxdWlyZS5iaW5kKG51bGwsIHRoaXMudXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyA9IHRoaXMuZnVuYy5jYWxsKGdsb2JhbCwgcmVsYXRpdmVSZXF1aXJlKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgTW9kdWxlRXZhbHVhdGlvbkVycm9yKSB7XG4gICAgICAgIGV4LmxvYWRlZEJ5KHRoaXMudXJsKTtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9XG4gICAgICBpZiAoZXguc3RhY2spIHtcbiAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5mdW5jLnRvU3RyaW5nKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgZXZhbGVkID0gW107XG4gICAgICAgIGV4LnN0YWNrLnNwbGl0KCdcXG4nKS5zb21lKGZ1bmN0aW9uKGZyYW1lLCBpbmRleCkge1xuICAgICAgICAgIGlmIChmcmFtZS5pbmRleE9mKCdVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvci5nZXRVbmNvYXRlZE1vZHVsZScpID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIHZhciBtID0gLyhhdFxcc1teXFxzXSpcXHMpLio+OihcXGQqKTooXFxkKilcXCkvLmV4ZWMoZnJhbWUpO1xuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHBhcnNlSW50KG1bMl0sIDEwKTtcbiAgICAgICAgICAgIGV2YWxlZCA9IGV2YWxlZC5jb25jYXQoYmVmb3JlTGluZXMobGluZXMsIGxpbmUpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICBldmFsZWQucHVzaChjb2x1bW5TcGFjaW5nKG1bM10pICsgJ14gJyArICRfXzIudXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV2YWxlZC5wdXNoKGNvbHVtblNwYWNpbmcobVszXSkgKyAnXicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZhbGVkID0gZXZhbGVkLmNvbmNhdChhZnRlckxpbmVzKGxpbmVzLCBsaW5lKSk7XG4gICAgICAgICAgICBldmFsZWQucHVzaCgnPSA9ID0gPSA9ID0gPSA9ID0nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZhbGVkLnB1c2goZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGV4LnN0YWNrID0gZXZhbGVkLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE1vZHVsZUV2YWx1YXRpb25FcnJvcih0aGlzLnVybCwgZXgpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0VW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3IobmFtZSkge1xuICAgIGlmICghbmFtZSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIgdXJsID0gTW9kdWxlU3RvcmUubm9ybWFsaXplKG5hbWUpO1xuICAgIHJldHVybiBtb2R1bGVJbnN0YW50aWF0b3JzW3VybF07XG4gIH1cbiAgO1xuICB2YXIgbW9kdWxlSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpdmVNb2R1bGVTZW50aW5lbCA9IHt9O1xuICBmdW5jdGlvbiBNb2R1bGUodW5jb2F0ZWRNb2R1bGUpIHtcbiAgICB2YXIgaXNMaXZlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb2F0ZWRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHVuY29hdGVkTW9kdWxlKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBnZXR0ZXIsXG4gICAgICAgICAgdmFsdWU7XG4gICAgICBpZiAoaXNMaXZlID09PSBsaXZlTW9kdWxlU2VudGluZWwpIHtcbiAgICAgICAgdmFyIGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih1bmNvYXRlZE1vZHVsZSwgbmFtZSk7XG4gICAgICAgIGlmIChkZXNjci5nZXQpXG4gICAgICAgICAgZ2V0dGVyID0gZGVzY3IuZ2V0O1xuICAgICAgfVxuICAgICAgaWYgKCFnZXR0ZXIpIHtcbiAgICAgICAgdmFsdWUgPSB1bmNvYXRlZE1vZHVsZVtuYW1lXTtcbiAgICAgICAgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvYXRlZE1vZHVsZSwgbmFtZSwge1xuICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGNvYXRlZE1vZHVsZSk7XG4gICAgcmV0dXJuIGNvYXRlZE1vZHVsZTtcbiAgfVxuICB2YXIgTW9kdWxlU3RvcmUgPSB7XG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihuYW1lLCByZWZlcmVyTmFtZSwgcmVmZXJlckFkZHJlc3MpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21vZHVsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcsIG5vdCAnICsgdHlwZW9mIG5hbWUpO1xuICAgICAgaWYgKGlzQWJzb2x1dGUobmFtZSkpXG4gICAgICAgIHJldHVybiBjYW5vbmljYWxpemVVcmwobmFtZSk7XG4gICAgICBpZiAoL1teXFwuXVxcL1xcLlxcLlxcLy8udGVzdChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZHVsZSBuYW1lIGVtYmVkcyAvLi4vOiAnICsgbmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZVswXSA9PT0gJy4nICYmIHJlZmVyZXJOYW1lKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVVybChyZWZlcmVyTmFtZSwgbmFtZSk7XG4gICAgICByZXR1cm4gY2Fub25pY2FsaXplVXJsKG5hbWUpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSkge1xuICAgICAgdmFyIG0gPSBnZXRVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcihub3JtYWxpemVkTmFtZSk7XG4gICAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbW9kdWxlSW5zdGFuY2UgPSBtb2R1bGVJbnN0YW5jZXNbbS51cmxdO1xuICAgICAgaWYgKG1vZHVsZUluc3RhbmNlKVxuICAgICAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2U7XG4gICAgICBtb2R1bGVJbnN0YW5jZSA9IE1vZHVsZShtLmdldFVuY29hdGVkTW9kdWxlKCksIGxpdmVNb2R1bGVTZW50aW5lbCk7XG4gICAgICByZXR1cm4gbW9kdWxlSW5zdGFuY2VzW20udXJsXSA9IG1vZHVsZUluc3RhbmNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgbW9kdWxlKSB7XG4gICAgICBub3JtYWxpemVkTmFtZSA9IFN0cmluZyhub3JtYWxpemVkTmFtZSk7XG4gICAgICBtb2R1bGVJbnN0YW50aWF0b3JzW25vcm1hbGl6ZWROYW1lXSA9IG5ldyBVbmNvYXRlZE1vZHVsZUluc3RhbnRpYXRvcihub3JtYWxpemVkTmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICB9KTtcbiAgICAgIG1vZHVsZUluc3RhbmNlc1tub3JtYWxpemVkTmFtZV0gPSBtb2R1bGU7XG4gICAgfSxcbiAgICBnZXQgYmFzZVVSTCgpIHtcbiAgICAgIHJldHVybiBiYXNlVVJMO1xuICAgIH0sXG4gICAgc2V0IGJhc2VVUkwodikge1xuICAgICAgYmFzZVVSTCA9IFN0cmluZyh2KTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyTW9kdWxlOiBmdW5jdGlvbihuYW1lLCBkZXBzLCBmdW5jKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBNb2R1bGVTdG9yZS5ub3JtYWxpemUobmFtZSk7XG4gICAgICBpZiAobW9kdWxlSW5zdGFudGlhdG9yc1tub3JtYWxpemVkTmFtZV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwbGljYXRlIG1vZHVsZSBuYW1lZCAnICsgbm9ybWFsaXplZE5hbWUpO1xuICAgICAgbW9kdWxlSW5zdGFudGlhdG9yc1tub3JtYWxpemVkTmFtZV0gPSBuZXcgVW5jb2F0ZWRNb2R1bGVJbnN0YW50aWF0b3Iobm9ybWFsaXplZE5hbWUsIGZ1bmMpO1xuICAgIH0sXG4gICAgYnVuZGxlU3RvcmU6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIGRlcHMsIGZ1bmMpIHtcbiAgICAgIGlmICghZGVwcyB8fCAhZGVwcy5sZW5ndGggJiYgIWZ1bmMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNb2R1bGUobmFtZSwgZGVwcywgZnVuYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1bmRsZVN0b3JlW25hbWVdID0ge1xuICAgICAgICAgIGRlcHM6IGRlcHMsXG4gICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJF9fMiA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBkZXBNYXAgPSB7fTtcbiAgICAgICAgICAgIGRlcHMuZm9yRWFjaChmdW5jdGlvbihkZXAsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXBNYXBbZGVwXSA9ICRfXzJbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVnaXN0cnlFbnRyeSA9IGZ1bmMuY2FsbCh0aGlzLCBkZXBNYXApO1xuICAgICAgICAgICAgcmVnaXN0cnlFbnRyeS5leGVjdXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0cnlFbnRyeS5leHBvcnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEFub255bW91c01vZHVsZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG5ldyBNb2R1bGUoZnVuYygpLCBsaXZlTW9kdWxlU2VudGluZWwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIG1vZHVsZVN0b3JlTW9kdWxlID0gbmV3IE1vZHVsZSh7TW9kdWxlU3RvcmU6IE1vZHVsZVN0b3JlfSk7XG4gIE1vZHVsZVN0b3JlLnNldCgnQHRyYWNldXIvc3JjL3J1bnRpbWUvTW9kdWxlU3RvcmUuanMnLCBtb2R1bGVTdG9yZU1vZHVsZSk7XG4gIHZhciBzZXR1cEdsb2JhbHMgPSAkdHJhY2V1clJ1bnRpbWUuc2V0dXBHbG9iYWxzO1xuICAkdHJhY2V1clJ1bnRpbWUuc2V0dXBHbG9iYWxzID0gZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgc2V0dXBHbG9iYWxzKGdsb2JhbCk7XG4gIH07XG4gICR0cmFjZXVyUnVudGltZS5Nb2R1bGVTdG9yZSA9IE1vZHVsZVN0b3JlO1xuICAkdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUgPSBNb2R1bGVTdG9yZS5yZWdpc3Rlck1vZHVsZS5iaW5kKE1vZHVsZVN0b3JlKTtcbiAgJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSA9IE1vZHVsZVN0b3JlLmdldDtcbiAgJHRyYWNldXJSdW50aW1lLnNldE1vZHVsZSA9IE1vZHVsZVN0b3JlLnNldDtcbiAgJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUgPSBNb2R1bGVTdG9yZS5ub3JtYWxpemU7XG59KSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL25ldy11bmlxdWUtc3RyaW5nLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9uZXctdW5pcXVlLXN0cmluZy5qc1wiO1xuICB2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG4gIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgZnVuY3Rpb24gbmV3VW5pcXVlU3RyaW5nKCkge1xuICAgIHJldHVybiAnX18kJyArIChyYW5kb20oKSAqIDFlOSA+Pj4gMSkgKyAnJCcgKyArK2NvdW50ZXIgKyAnJF9fJztcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIG5ld1VuaXF1ZVN0cmluZztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2hhcy1uYXRpdmUtc3ltYm9scy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvaGFzLW5hdGl2ZS1zeW1ib2xzLmpzXCI7XG4gIHZhciB2ID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG4gIGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbCgpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIGhhc05hdGl2ZVN5bWJvbDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3ltYm9scy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zeW1ib2xzLmpzXCI7XG4gIHZhciBuZXdVbmlxdWVTdHJpbmcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vbmV3LXVuaXF1ZS1zdHJpbmcuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zeW1ib2xzLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgaGFzTmF0aXZlU3ltYm9sID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL2hhcy1uYXRpdmUtc3ltYm9scy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3N5bWJvbHMuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbiAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyICRmcmVlemUgPSBPYmplY3QuZnJlZXplO1xuICB2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgdmFyICRrZXlzID0gT2JqZWN0LmtleXM7XG4gIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICBmdW5jdGlvbiBub25FbnVtKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICB9XG4gIHZhciBzeW1ib2xJbnRlcm5hbFByb3BlcnR5ID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gIHZhciBzeW1ib2xEZXNjcmlwdGlvblByb3BlcnR5ID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gIHZhciBzeW1ib2xEYXRhUHJvcGVydHkgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgdmFyIHN5bWJvbFZhbHVlcyA9ICRjcmVhdGUobnVsbCk7XG4gIHZhciBTeW1ib2xJbXBsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gbmV3IFN5bWJvbFZhbHVlKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ltYm9sSW1wbCkpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1N5bWJvbCBjYW5ub3QgYmUgbmV3XFwnZWQnKTtcbiAgfTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbEltcGwucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBub25FbnVtKFN5bWJvbEltcGwpKTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbEltcGwucHJvdG90eXBlLCAndG9TdHJpbmcnLCBub25FbnVtKGZ1bmN0aW9uKCkge1xuICAgIHZhciBzeW1ib2xWYWx1ZSA9IHRoaXNbc3ltYm9sRGF0YVByb3BlcnR5XTtcbiAgICByZXR1cm4gc3ltYm9sVmFsdWVbc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eV07XG4gIH0pKTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbEltcGwucHJvdG90eXBlLCAndmFsdWVPZicsIG5vbkVudW0oZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN5bWJvbFZhbHVlID0gdGhpc1tzeW1ib2xEYXRhUHJvcGVydHldO1xuICAgIGlmICghc3ltYm9sVmFsdWUpXG4gICAgICB0aHJvdyAkVHlwZUVycm9yKCdDb252ZXJzaW9uIGZyb20gc3ltYm9sIHRvIHN0cmluZycpO1xuICAgIHJldHVybiBzeW1ib2xWYWx1ZVtzeW1ib2xJbnRlcm5hbFByb3BlcnR5XTtcbiAgfSkpO1xuICBmdW5jdGlvbiBTeW1ib2xWYWx1ZShkZXNjcmlwdGlvbikge1xuICAgIHZhciBrZXkgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgICAkZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sRGF0YVByb3BlcnR5LCB7dmFsdWU6IHRoaXN9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eSwge3ZhbHVlOiBrZXl9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkodGhpcywgc3ltYm9sRGVzY3JpcHRpb25Qcm9wZXJ0eSwge3ZhbHVlOiBkZXNjcmlwdGlvbn0pO1xuICAgICRmcmVlemUodGhpcyk7XG4gICAgc3ltYm9sVmFsdWVzW2tleV0gPSB0aGlzO1xuICB9XG4gICRkZWZpbmVQcm9wZXJ0eShTeW1ib2xWYWx1ZS5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIG5vbkVudW0oU3ltYm9sSW1wbCkpO1xuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sVmFsdWUucHJvdG90eXBlLCAndG9TdHJpbmcnLCB7XG4gICAgdmFsdWU6IFN5bWJvbEltcGwucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sVmFsdWUucHJvdG90eXBlLCAndmFsdWVPZicsIHtcbiAgICB2YWx1ZTogU3ltYm9sSW1wbC5wcm90b3R5cGUudmFsdWVPZixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgJGZyZWV6ZShTeW1ib2xWYWx1ZS5wcm90b3R5cGUpO1xuICBmdW5jdGlvbiBpc1N5bWJvbFN0cmluZyhzKSB7XG4gICAgcmV0dXJuIHN5bWJvbFZhbHVlc1tzXTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVTeW1ib2xLZXlzKGFycmF5KSB7XG4gICAgdmFyIHJ2ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc1N5bWJvbFN0cmluZyhhcnJheVtpXSkpIHtcbiAgICAgICAgcnYucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICAgIHJldHVybiByZW1vdmVTeW1ib2xLZXlzKCRnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIHJlbW92ZVN5bWJvbEtleXMoJGtleXMob2JqZWN0KSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkge1xuICAgIHZhciBydiA9IFtdO1xuICAgIHZhciBuYW1lcyA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbFZhbHVlc1tuYW1lc1tpXV07XG4gICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIHJ2LnB1c2goc3ltYm9sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsU3ltYm9sKGdsb2JhbCkge1xuICAgIHZhciBPYmplY3QgPSBnbG9iYWwuT2JqZWN0O1xuICAgIGlmICghaGFzTmF0aXZlU3ltYm9sKCkpIHtcbiAgICAgIGdsb2JhbC5TeW1ib2wgPSBTeW1ib2xJbXBsO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgICAgT2JqZWN0LmtleXMgPSBrZXlzO1xuICAgICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2dldE93blByb3BlcnR5U3ltYm9scycsIG5vbkVudW0oZ2V0T3duUHJvcGVydHlTeW1ib2xzKSk7XG4gICAgfVxuICAgIGlmICghZ2xvYmFsLlN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgZ2xvYmFsLlN5bWJvbC5pdGVyYXRvciA9IGdsb2JhbC5TeW1ib2woJ1N5bWJvbC5pdGVyYXRvcicpO1xuICAgIH1cbiAgICBpZiAoIWdsb2JhbC5TeW1ib2wub2JzZXJ2ZXIpIHtcbiAgICAgIGdsb2JhbC5TeW1ib2wub2JzZXJ2ZXIgPSBnbG9iYWwuU3ltYm9sKCdTeW1ib2wub2JzZXJ2ZXInKTtcbiAgICB9XG4gIH1cbiAgdmFyIGcgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6ICh2b2lkIDApO1xuICBwb2x5ZmlsbFN5bWJvbChnKTtcbiAgdmFyIHR5cGVPZiA9IGhhc05hdGl2ZVN5bWJvbCgpID8gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeDtcbiAgfSA6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIFN5bWJvbFZhbHVlID8gJ3N5bWJvbCcgOiB0eXBlb2YgeDtcbiAgfTtcbiAgcmV0dXJuIHtnZXQgdHlwZW9mKCkge1xuICAgICAgcmV0dXJuIHR5cGVPZjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvdHlwZW9mLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3R5cGVvZi5qc1wiO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfc3ltYm9sc180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vc3ltYm9scy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3R5cGVvZi5qc1wiKSk7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfc3ltYm9sc180Nl9qc19fLnR5cGVvZjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3N5bWJvbHMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3N5bWJvbHMuanNcIjtcbiAgdmFyIHQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3R5cGVvZi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9zeW1ib2xzLmpzXCIpKS5kZWZhdWx0O1xuICAkdHJhY2V1clJ1bnRpbWUudHlwZW9mID0gdDtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVDbGFzcy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVDbGFzcy5qc1wiO1xuICB2YXIgJE9iamVjdCA9IE9iamVjdDtcbiAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIHZhciAkX18xID0gT2JqZWN0LFxuICAgICAgY3JlYXRlID0gJF9fMS5jcmVhdGUsXG4gICAgICBkZWZpbmVQcm9wZXJ0aWVzID0gJF9fMS5kZWZpbmVQcm9wZXJ0aWVzLFxuICAgICAgZGVmaW5lUHJvcGVydHkgPSAkX18xLmRlZmluZVByb3BlcnR5LFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gJF9fMS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gJF9fMS5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gJF9fMS5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4gIGZ1bmN0aW9uIGZvckVhY2hQcm9wZXJ0eUtleShvYmplY3QsIGYpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuZm9yRWFjaChmKTtcbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KS5mb3JFYWNoKGYpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXREZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3JFYWNoUHJvcGVydHlLZXkob2JqZWN0LCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleV0gPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpO1xuICAgICAgZGVzY3JpcHRvcnNba2V5XS5lbnVtZXJhYmxlID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIHZhciBub25FbnVtID0ge2VudW1lcmFibGU6IGZhbHNlfTtcbiAgZnVuY3Rpb24gbWFrZVByb3BlcnRpZXNOb25FbnVtZXJhYmxlKG9iamVjdCkge1xuICAgIGZvckVhY2hQcm9wZXJ0eUtleShvYmplY3QsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIG5vbkVudW0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKGN0b3IsIG9iamVjdCwgc3RhdGljT2JqZWN0LCBzdXBlckNsYXNzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY29uc3RydWN0b3InLCB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY3Rvci5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoZ2V0UHJvdG9QYXJlbnQoc3VwZXJDbGFzcyksIGdldERlc2NyaXB0b3JzKG9iamVjdCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlUHJvcGVydGllc05vbkVudW1lcmFibGUob2JqZWN0KTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gb2JqZWN0O1xuICAgIH1cbiAgICBkZWZpbmVQcm9wZXJ0eShjdG9yLCAncHJvdG90eXBlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzKGN0b3IsIGdldERlc2NyaXB0b3JzKHN0YXRpY09iamVjdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFByb3RvUGFyZW50KHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBwcm90b3R5cGUgPSBzdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICAgIGlmICgkT2JqZWN0KHByb3RvdHlwZSkgPT09IHByb3RvdHlwZSB8fCBwcm90b3R5cGUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBzdXBlckNsYXNzLnByb3RvdHlwZTtcbiAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCdzdXBlciBwcm90b3R5cGUgbXVzdCBiZSBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoc3VwZXJDbGFzcyA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKChcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyArIFwiLlwiKSk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDbGFzcztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3VwZXJDb25zdHJ1Y3Rvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zdXBlckNvbnN0cnVjdG9yLmpzXCI7XG4gIGZ1bmN0aW9uIHN1cGVyQ29uc3RydWN0b3IoY3Rvcikge1xuICAgIHJldHVybiBjdG9yLl9fcHJvdG9fXztcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIHN1cGVyQ29uc3RydWN0b3I7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3N1cGVyRGVzY3JpcHRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zdXBlckRlc2NyaXB0b3IuanNcIjtcbiAgdmFyICRfXzAgPSBPYmplY3QsXG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAkX18wLmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgIGdldFByb3RvdHlwZU9mID0gJF9fMC5nZXRQcm90b3R5cGVPZjtcbiAgZnVuY3Rpb24gc3VwZXJEZXNjcmlwdG9yKGhvbWVPYmplY3QsIG5hbWUpIHtcbiAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihob21lT2JqZWN0KTtcbiAgICBkbyB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBwcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9IHdoaWxlIChwcm90byk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIHN1cGVyRGVzY3JpcHRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3VwZXJHZXQuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3VwZXJHZXQuanNcIjtcbiAgdmFyIHN1cGVyRGVzY3JpcHRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N1cGVyRGVzY3JpcHRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3N1cGVyR2V0LmpzXCIpKS5kZWZhdWx0O1xuICBmdW5jdGlvbiBzdXBlckdldChzZWxmLCBob21lT2JqZWN0LCBuYW1lKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBzdXBlckRlc2NyaXB0b3IoaG9tZU9iamVjdCwgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICBpZiAodmFsdWUpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIGlmICghZGVzY3JpcHRvci5nZXQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5jYWxsKHNlbGYpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gc3VwZXJHZXQ7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3N1cGVyU2V0LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3N1cGVyU2V0LmpzXCI7XG4gIHZhciBzdXBlckRlc2NyaXB0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9zdXBlckRlc2NyaXB0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zdXBlclNldC5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIGZ1bmN0aW9uIHN1cGVyU2V0KHNlbGYsIGhvbWVPYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBzdXBlckRlc2NyaXB0b3IoaG9tZU9iamVjdCwgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwoc2VsZiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyAkVHlwZUVycm9yKChcInN1cGVyIGhhcyBubyBzZXR0ZXIgJ1wiICsgbmFtZSArIFwiJy5cIikpO1xuICB9XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gc3VwZXJTZXQ7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9jbGFzc2VzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9jbGFzc2VzLmpzXCI7XG4gIHZhciBjcmVhdGVDbGFzcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZXMvY3JlYXRlQ2xhc3MuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvY2xhc3Nlcy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIHN1cGVyQ29uc3RydWN0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3N1cGVyQ29uc3RydWN0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvY2xhc3Nlcy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIHN1cGVyR2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9zdXBlckdldC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9jbGFzc2VzLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgc3VwZXJTZXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3N1cGVyU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2NsYXNzZXMuanNcIikpLmRlZmF1bHQ7XG4gICR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvciA9IHN1cGVyQ29uc3RydWN0b3I7XG4gICR0cmFjZXVyUnVudGltZS5zdXBlckdldCA9IHN1cGVyR2V0O1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJTZXQgPSBzdXBlclNldDtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9leHBvcnRTdGFyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2V4cG9ydFN0YXIuanNcIjtcbiAgdmFyICRfXzEgPSBPYmplY3QsXG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9ICRfXzEuZGVmaW5lUHJvcGVydHksXG4gICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gJF9fMS5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBmdW5jdGlvbiBleHBvcnRTdGFyKG9iamVjdCkge1xuICAgIHZhciAkX18yID0gYXJndW1lbnRzLFxuICAgICAgICAkX18zID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHZhciBtb2QgPSAkX18yW2ldO1xuICAgICAgICAgIHZhciBuYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXMobW9kKTtcbiAgICAgICAgICB2YXIgJF9fNSA9IGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ19fZXNNb2R1bGUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RbbmFtZV07XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICRfXzY7XG4gICAgICAgICAgJF9fNDogZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgJF9fNiA9ICRfXzUoaik7XG4gICAgICAgICAgICBzd2l0Y2ggKCRfXzYpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlICRfXzQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAkX18zKGkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0U3RhcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2V4cG9ydFN0YXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2V4cG9ydFN0YXIuanNcIjtcbiAgdmFyIGV4cG9ydFN0YXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL2V4cG9ydFN0YXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvZXhwb3J0U3Rhci5qc1wiKSkuZGVmYXVsdDtcbiAgJHRyYWNldXJSdW50aW1lLmV4cG9ydFN0YXIgPSBleHBvcnRTdGFyO1xuICByZXR1cm4ge307XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcml2YXRlLXN5bWJvbC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcHJpdmF0ZS1zeW1ib2wuanNcIjtcbiAgdmFyIG5ld1VuaXF1ZVN0cmluZyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL25ldy11bmlxdWUtc3RyaW5nLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3ByaXZhdGUtc3ltYm9sLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgPyBTeW1ib2wgOiB1bmRlZmluZWQ7XG4gIHZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiAgdmFyICRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuICB2YXIgcHJpdmF0ZU5hbWVzID0gJGNyZWF0ZShudWxsKTtcbiAgZnVuY3Rpb24gaXNQcml2YXRlU3ltYm9sKHMpIHtcbiAgICByZXR1cm4gcHJpdmF0ZU5hbWVzW3NdO1xuICB9XG4gIDtcbiAgZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZVN5bWJvbCgpIHtcbiAgICB2YXIgcyA9ICgkU3ltYm9sIHx8IG5ld1VuaXF1ZVN0cmluZykoKTtcbiAgICBwcml2YXRlTmFtZXNbc10gPSB0cnVlO1xuICAgIHJldHVybiBzO1xuICB9XG4gIDtcbiAgZnVuY3Rpb24gaGFzUHJpdmF0ZShvYmosIHN5bSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ltKTtcbiAgfVxuICA7XG4gIGZ1bmN0aW9uIGRlbGV0ZVByaXZhdGUob2JqLCBzeW0pIHtcbiAgICBpZiAoIWhhc1ByaXZhdGUob2JqLCBzeW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBvYmpbc3ltXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICA7XG4gIGZ1bmN0aW9uIHNldFByaXZhdGUob2JqLCBzeW0sIHZhbCkge1xuICAgIG9ialtzeW1dID0gdmFsO1xuICB9XG4gIDtcbiAgZnVuY3Rpb24gZ2V0UHJpdmF0ZShvYmosIHN5bSkge1xuICAgIHZhciB2YWwgPSBvYmpbc3ltXTtcbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ltKSA/IHZhbCA6IHVuZGVmaW5lZDtcbiAgfVxuICA7XG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaWYgKCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSB7XG4gICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICB2YXIgc3ltYm9scyA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV07XG4gICAgICAgICAgaWYgKCFpc1ByaXZhdGVTeW1ib2woc3ltYm9sKSkge1xuICAgICAgICAgICAgcnYucHVzaChzeW1ib2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBpc1ByaXZhdGVTeW1ib2woKSB7XG4gICAgICByZXR1cm4gaXNQcml2YXRlU3ltYm9sO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVByaXZhdGVTeW1ib2woKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJpdmF0ZVN5bWJvbDtcbiAgICB9LFxuICAgIGdldCBoYXNQcml2YXRlKCkge1xuICAgICAgcmV0dXJuIGhhc1ByaXZhdGU7XG4gICAgfSxcbiAgICBnZXQgZGVsZXRlUHJpdmF0ZSgpIHtcbiAgICAgIHJldHVybiBkZWxldGVQcml2YXRlO1xuICAgIH0sXG4gICAgZ2V0IHNldFByaXZhdGUoKSB7XG4gICAgICByZXR1cm4gc2V0UHJpdmF0ZTtcbiAgICB9LFxuICAgIGdldCBnZXRQcml2YXRlKCkge1xuICAgICAgcmV0dXJuIGdldFByaXZhdGU7XG4gICAgfSxcbiAgICBnZXQgaW5pdCgpIHtcbiAgICAgIHJldHVybiBpbml0O1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3ByaXZhdGUtd2Vhay1tYXAuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3ByaXZhdGUtd2Vhay1tYXAuanNcIjtcbiAgdmFyICRXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogdW5kZWZpbmVkO1xuICBmdW5jdGlvbiBpc1ByaXZhdGVTeW1ib2wocykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQcml2YXRlU3ltYm9sKCkge1xuICAgIHJldHVybiBuZXcgJFdlYWtNYXAoKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNQcml2YXRlKG9iaiwgc3ltKSB7XG4gICAgcmV0dXJuIHN5bS5oYXMob2JqKTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVQcml2YXRlKG9iaiwgc3ltKSB7XG4gICAgcmV0dXJuIHN5bS5kZWxldGUob2JqKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRQcml2YXRlKG9iaiwgc3ltLCB2YWwpIHtcbiAgICBzeW0uc2V0KG9iaiwgdmFsKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRQcml2YXRlKG9iaiwgc3ltKSB7XG4gICAgcmV0dXJuIHN5bS5nZXQob2JqKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0KCkge31cbiAgcmV0dXJuIHtcbiAgICBnZXQgaXNQcml2YXRlU3ltYm9sKCkge1xuICAgICAgcmV0dXJuIGlzUHJpdmF0ZVN5bWJvbDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVQcml2YXRlU3ltYm9sKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVByaXZhdGVTeW1ib2w7XG4gICAgfSxcbiAgICBnZXQgaGFzUHJpdmF0ZSgpIHtcbiAgICAgIHJldHVybiBoYXNQcml2YXRlO1xuICAgIH0sXG4gICAgZ2V0IGRlbGV0ZVByaXZhdGUoKSB7XG4gICAgICByZXR1cm4gZGVsZXRlUHJpdmF0ZTtcbiAgICB9LFxuICAgIGdldCBzZXRQcml2YXRlKCkge1xuICAgICAgcmV0dXJuIHNldFByaXZhdGU7XG4gICAgfSxcbiAgICBnZXQgZ2V0UHJpdmF0ZSgpIHtcbiAgICAgIHJldHVybiBnZXRQcml2YXRlO1xuICAgIH0sXG4gICAgZ2V0IGluaXQoKSB7XG4gICAgICByZXR1cm4gaW5pdDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcml2YXRlLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcml2YXRlLmpzXCI7XG4gIHZhciBzeW0gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9wcml2YXRlLXN5bWJvbC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcml2YXRlLmpzXCIpKTtcbiAgdmFyIHdlYWsgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9wcml2YXRlLXdlYWstbWFwLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3ByaXZhdGUuanNcIikpO1xuICB2YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xuICB2YXIgbSA9IGhhc1dlYWtNYXAgPyB3ZWFrIDogc3ltO1xuICB2YXIgaXNQcml2YXRlU3ltYm9sID0gbS5pc1ByaXZhdGVTeW1ib2w7XG4gIHZhciBjcmVhdGVQcml2YXRlU3ltYm9sID0gbS5jcmVhdGVQcml2YXRlU3ltYm9sO1xuICB2YXIgaGFzUHJpdmF0ZSA9IG0uaGFzUHJpdmF0ZTtcbiAgdmFyIGRlbGV0ZVByaXZhdGUgPSBtLmRlbGV0ZVByaXZhdGU7XG4gIHZhciBzZXRQcml2YXRlID0gbS5zZXRQcml2YXRlO1xuICB2YXIgZ2V0UHJpdmF0ZSA9IG0uZ2V0UHJpdmF0ZTtcbiAgbS5pbml0KCk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGlzUHJpdmF0ZVN5bWJvbCgpIHtcbiAgICAgIHJldHVybiBpc1ByaXZhdGVTeW1ib2w7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlUHJpdmF0ZVN5bWJvbCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVQcml2YXRlU3ltYm9sO1xuICAgIH0sXG4gICAgZ2V0IGhhc1ByaXZhdGUoKSB7XG4gICAgICByZXR1cm4gaGFzUHJpdmF0ZTtcbiAgICB9LFxuICAgIGdldCBkZWxldGVQcml2YXRlKCkge1xuICAgICAgcmV0dXJuIGRlbGV0ZVByaXZhdGU7XG4gICAgfSxcbiAgICBnZXQgc2V0UHJpdmF0ZSgpIHtcbiAgICAgIHJldHVybiBzZXRQcml2YXRlO1xuICAgIH0sXG4gICAgZ2V0IGdldFByaXZhdGUoKSB7XG4gICAgICByZXR1cm4gZ2V0UHJpdmF0ZTtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3Byb3BlclRhaWxDYWxscy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9wcm9wZXJUYWlsQ2FsbHMuanNcIjtcbiAgdmFyICRfXzAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vcHJpdmF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3Byb3BlclRhaWxDYWxscy5qc1wiKSksXG4gICAgICBnZXRQcml2YXRlID0gJF9fMC5nZXRQcml2YXRlLFxuICAgICAgc2V0UHJpdmF0ZSA9ICRfXzAuc2V0UHJpdmF0ZSxcbiAgICAgIGNyZWF0ZVByaXZhdGVTeW1ib2wgPSAkX18wLmNyZWF0ZVByaXZhdGVTeW1ib2w7XG4gIHZhciAkYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSk7XG4gIHZhciBDT05USU5VQVRJT05fVFlQRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBpc1RhaWxSZWN1cnNpdmVOYW1lID0gbnVsbDtcbiAgZnVuY3Rpb24gY3JlYXRlQ29udGludWF0aW9uKG9wZXJhbmQsIHRoaXNBcmcsIGFyZ3NBcnJheSkge1xuICAgIHJldHVybiBbQ09OVElOVUFUSU9OX1RZUEUsIG9wZXJhbmQsIHRoaXNBcmcsIGFyZ3NBcnJheV07XG4gIH1cbiAgZnVuY3Rpb24gaXNDb250aW51YXRpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3RbMF0gPT09IENPTlRJTlVBVElPTl9UWVBFO1xuICB9XG4gIGZ1bmN0aW9uICRiaW5kKG9wZXJhbmQsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICB2YXIgYXJnQXJyYXkgPSBbdGhpc0FyZ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdBcnJheVtpICsgMV0gPSBhcmdzW2ldO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICRhcHBseShGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgb3BlcmFuZCwgYXJnQXJyYXkpO1xuICAgIHJldHVybiBmdW5jO1xuICB9XG4gIGZ1bmN0aW9uICRjb25zdHJ1Y3QoZnVuYywgYXJnQXJyYXkpIHtcbiAgICB2YXIgb2JqZWN0ID0gbmV3ICgkYmluZChmdW5jLCBudWxsLCBhcmdBcnJheSkpO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gaXNUYWlsUmVjdXJzaXZlKGZ1bmMpIHtcbiAgICByZXR1cm4gISFnZXRQcml2YXRlKGZ1bmMsIGlzVGFpbFJlY3Vyc2l2ZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRhaWxDYWxsKGZ1bmMsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiA9IGFyZ0FycmF5WzBdO1xuICAgIGlmIChpc0NvbnRpbnVhdGlvbihjb250aW51YXRpb24pKSB7XG4gICAgICBjb250aW51YXRpb24gPSAkYXBwbHkoZnVuYywgdGhpc0FyZywgY29udGludWF0aW9uWzNdKTtcbiAgICAgIHJldHVybiBjb250aW51YXRpb247XG4gICAgfVxuICAgIGNvbnRpbnVhdGlvbiA9IGNyZWF0ZUNvbnRpbnVhdGlvbihmdW5jLCB0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpc1RhaWxSZWN1cnNpdmUoZnVuYykpIHtcbiAgICAgICAgY29udGludWF0aW9uID0gJGFwcGx5KGZ1bmMsIGNvbnRpbnVhdGlvblsyXSwgW2NvbnRpbnVhdGlvbl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWF0aW9uID0gJGFwcGx5KGZ1bmMsIGNvbnRpbnVhdGlvblsyXSwgY29udGludWF0aW9uWzNdKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNDb250aW51YXRpb24oY29udGludWF0aW9uKSkge1xuICAgICAgICByZXR1cm4gY29udGludWF0aW9uO1xuICAgICAgfVxuICAgICAgZnVuYyA9IGNvbnRpbnVhdGlvblsxXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY29uc3RydWN0KCkge1xuICAgIHZhciBvYmplY3Q7XG4gICAgaWYgKGlzVGFpbFJlY3Vyc2l2ZSh0aGlzKSkge1xuICAgICAgb2JqZWN0ID0gJGNvbnN0cnVjdCh0aGlzLCBbY3JlYXRlQ29udGludWF0aW9uKG51bGwsIG51bGwsIGFyZ3VtZW50cyldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0ID0gJGNvbnN0cnVjdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIHNldHVwUHJvcGVyVGFpbENhbGxzKCkge1xuICAgIGlzVGFpbFJlY3Vyc2l2ZU5hbWUgPSBjcmVhdGVQcml2YXRlU3ltYm9sKCk7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwgPSBpbml0VGFpbFJlY3Vyc2l2ZUZ1bmN0aW9uKGZ1bmN0aW9uIGNhbGwodGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRhaWxDYWxsKGZ1bmN0aW9uKHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIGFyZ0FycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYXJnQXJyYXlbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250aW51YXRpb24gPSBjcmVhdGVDb250aW51YXRpb24odGhpcywgdGhpc0FyZywgYXJnQXJyYXkpO1xuICAgICAgICByZXR1cm4gY29udGludWF0aW9uO1xuICAgICAgfSwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5ID0gaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbihmdW5jdGlvbiBhcHBseSh0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRhaWxDYWxsKGZ1bmN0aW9uKHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICAgIHZhciBjb250aW51YXRpb24gPSBjcmVhdGVDb250aW51YXRpb24odGhpcywgdGhpc0FyZywgYXJnQXJyYXkpO1xuICAgICAgICByZXR1cm4gY29udGludWF0aW9uO1xuICAgICAgfSwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbihmdW5jKSB7XG4gICAgaWYgKGlzVGFpbFJlY3Vyc2l2ZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHNldHVwUHJvcGVyVGFpbENhbGxzKCk7XG4gICAgfVxuICAgIHNldFByaXZhdGUoZnVuYywgaXNUYWlsUmVjdXJzaXZlTmFtZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgY3JlYXRlQ29udGludWF0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRpbnVhdGlvbjtcbiAgICB9LFxuICAgIGdldCB0YWlsQ2FsbCgpIHtcbiAgICAgIHJldHVybiB0YWlsQ2FsbDtcbiAgICB9LFxuICAgIGdldCBjb25zdHJ1Y3QoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0O1xuICAgIH0sXG4gICAgZ2V0IGluaXRUYWlsUmVjdXJzaXZlRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbjtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2luaXRUYWlsUmVjdXJzaXZlRnVuY3Rpb24uanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbi5qc1wiO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfcHJvcGVyVGFpbENhbGxzXzQ2X2pzX18gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9wcm9wZXJUYWlsQ2FsbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9pbml0VGFpbFJlY3Vyc2l2ZUZ1bmN0aW9uLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19wcm9wZXJUYWlsQ2FsbHNfNDZfanNfXy5pbml0VGFpbFJlY3Vyc2l2ZUZ1bmN0aW9uO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jYWxsLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2NhbGwuanNcIjtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfcnVudGltZV80N19tb2R1bGVzXzQ3X3Byb3BlclRhaWxDYWxsc180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vcHJvcGVyVGFpbENhbGxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvY2FsbC5qc1wiKSk7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfcHJvcGVyVGFpbENhbGxzXzQ2X2pzX18udGFpbENhbGw7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2NvbnRpbnVhdGlvbi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jb250aW51YXRpb24uanNcIjtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfcnVudGltZV80N19tb2R1bGVzXzQ3X3Byb3BlclRhaWxDYWxsc180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vcHJvcGVyVGFpbENhbGxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvY29udGludWF0aW9uLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19wcm9wZXJUYWlsQ2FsbHNfNDZfanNfXy5jcmVhdGVDb250aW51YXRpb247XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2NvbnN0cnVjdC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jb25zdHJ1Y3QuanNcIjtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfcnVudGltZV80N19tb2R1bGVzXzQ3X3Byb3BlclRhaWxDYWxsc180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vcHJvcGVyVGFpbENhbGxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvY29uc3RydWN0LmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19wcm9wZXJUYWlsQ2FsbHNfNDZfanNfXy5jb25zdHJ1Y3Q7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcm9wZXJUYWlsQ2FsbHMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3Byb3BlclRhaWxDYWxscy5qc1wiO1xuICB2YXIgaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZXMvaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wcm9wZXJUYWlsQ2FsbHMuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBjYWxsID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9jYWxsLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3Byb3BlclRhaWxDYWxscy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIGNvbnRpbnVhdGlvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZXMvY29udGludWF0aW9uLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3Byb3BlclRhaWxDYWxscy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIGNvbnN0cnVjdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZXMvY29uc3RydWN0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3Byb3BlclRhaWxDYWxscy5qc1wiKSkuZGVmYXVsdDtcbiAgJHRyYWNldXJSdW50aW1lLmluaXRUYWlsUmVjdXJzaXZlRnVuY3Rpb24gPSBpbml0VGFpbFJlY3Vyc2l2ZUZ1bmN0aW9uO1xuICAkdHJhY2V1clJ1bnRpbWUuY2FsbCA9IGNhbGw7XG4gICR0cmFjZXVyUnVudGltZS5jb250aW51YXRpb24gPSBjb250aW51YXRpb247XG4gICR0cmFjZXVyUnVudGltZS5jb25zdHJ1Y3QgPSBjb25zdHJ1Y3Q7XG4gIHJldHVybiB7fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3JlbGF0aXZlUmVxdWlyZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcmVsYXRpdmVSZXF1aXJlLmpzXCI7XG4gIHZhciBwYXRoO1xuICBmdW5jdGlvbiByZWxhdGl2ZVJlcXVpcmUoY2FsbGVyUGF0aCwgcmVxdWlyZWRQYXRoKSB7XG4gICAgcGF0aCA9IHBhdGggfHwgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUoJ3BhdGgnKTtcbiAgICBmdW5jdGlvbiBpc0RpcmVjdG9yeShwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZSgtMSkgPT09ICcvJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aFswXSA9PT0gJy8nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoWzBdID09PSAnLic7XG4gICAgfVxuICAgIGlmIChpc0RpcmVjdG9yeShyZXF1aXJlZFBhdGgpIHx8IGlzQWJzb2x1dGUocmVxdWlyZWRQYXRoKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gaXNSZWxhdGl2ZShyZXF1aXJlZFBhdGgpID8gcmVxdWlyZShwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGNhbGxlclBhdGgpLCByZXF1aXJlZFBhdGgpKSA6IHJlcXVpcmUocmVxdWlyZWRQYXRoKTtcbiAgfVxuICAkdHJhY2V1clJ1bnRpbWUucmVxdWlyZSA9IHJlbGF0aXZlUmVxdWlyZTtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvY2hlY2tPYmplY3RDb2VyY2libGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2NoZWNrT2JqZWN0Q29lcmNpYmxlLmpzXCI7XG4gIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICBmdW5jdGlvbiBjaGVja09iamVjdENvZXJjaWJsZSh2KSB7XG4gICAgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcignVmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBPYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBjaGVja09iamVjdENvZXJjaWJsZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3ByZWFkLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3NwcmVhZC5qc1wiO1xuICB2YXIgY2hlY2tPYmplY3RDb2VyY2libGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY2hlY2tPYmplY3RDb2VyY2libGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zcHJlYWQuanNcIikpLmRlZmF1bHQ7XG4gIGZ1bmN0aW9uIHNwcmVhZCgpIHtcbiAgICB2YXIgcnYgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGl0ZXJSZXN1bHQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZVRvU3ByZWFkID0gY2hlY2tPYmplY3RDb2VyY2libGUoYXJndW1lbnRzW2ldKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVUb1NwcmVhZFtTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzcHJlYWQgbm9uLWl0ZXJhYmxlIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyID0gdmFsdWVUb1NwcmVhZFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICB3aGlsZSAoIShpdGVyUmVzdWx0ID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgcnZbaisrXSA9IGl0ZXJSZXN1bHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIHNwcmVhZDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3NwcmVhZC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvc3ByZWFkLmpzXCI7XG4gIHZhciBzcHJlYWQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3NwcmVhZC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9zcHJlYWQuanNcIikpLmRlZmF1bHQ7XG4gICR0cmFjZXVyUnVudGltZS5zcHJlYWQgPSBzcHJlYWQ7XG4gIHJldHVybiB7fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvaXRlcmF0b3JUb0FycmF5LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2l0ZXJhdG9yVG9BcnJheS5qc1wiO1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcikge1xuICAgIHZhciBydiA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdG1wO1xuICAgIHdoaWxlICghKHRtcCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICBydltpKytdID0gdG1wLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXk7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9kZXN0cnVjdHVyaW5nLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9kZXN0cnVjdHVyaW5nLmpzXCI7XG4gIHZhciBpdGVyYXRvclRvQXJyYXkgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL2l0ZXJhdG9yVG9BcnJheS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9kZXN0cnVjdHVyaW5nLmpzXCIpKS5kZWZhdWx0O1xuICAkdHJhY2V1clJ1bnRpbWUuaXRlcmF0b3JUb0FycmF5ID0gaXRlcmF0b3JUb0FycmF5O1xuICByZXR1cm4ge307XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2FzeW5jLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2FzeW5jLmpzXCI7XG4gIHZhciAkX18xMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9wcml2YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvYXN5bmMuanNcIikpLFxuICAgICAgY3JlYXRlUHJpdmF0ZVN5bWJvbCA9ICRfXzEyLmNyZWF0ZVByaXZhdGVTeW1ib2wsXG4gICAgICBnZXRQcml2YXRlID0gJF9fMTIuZ2V0UHJpdmF0ZSxcbiAgICAgIHNldFByaXZhdGUgPSAkX18xMi5zZXRQcml2YXRlO1xuICB2YXIgJF9fMTEgPSBPYmplY3QsXG4gICAgICBjcmVhdGUgPSAkX18xMS5jcmVhdGUsXG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9ICRfXzExLmRlZmluZVByb3BlcnR5O1xuICB2YXIgb2JzZXJ2ZU5hbWUgPSBjcmVhdGVQcml2YXRlU3ltYm9sKCk7XG4gIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBBc3luY0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBBc3luY0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBBc3luY0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNHZW5lcmF0b3JGdW5jdGlvbjtcbiAgZGVmaW5lUHJvcGVydHkoQXN5bmNHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywge2VudW1lcmFibGU6IGZhbHNlfSk7XG4gIHZhciBBc3luY0dlbmVyYXRvckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBBc3luY0dlbmVyYXRvckNvbnRleHQob2JzZXJ2ZXIpIHtcbiAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgIHRoaXMuZGVjb3JhdGVkT2JzZXJ2ZXIgPSBjcmVhdGVEZWNvcmF0ZWRHZW5lcmF0b3Iob2JzZXJ2ZXIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkX18yLmRvbmUgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5SZXR1cm4gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFzeW5jR2VuZXJhdG9yQ29udGV4dCwge1xuICAgICAgdGhyb3c6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmICghdGhpcy5pblJldHVybikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeWllbGQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmluUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLmRlY29yYXRlZE9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaW5SZXR1cm4gPSB0cnVlO1xuICAgICAgICAgIHRocm93IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHlpZWxkRm9yOiBmdW5jdGlvbihvYnNlcnZhYmxlKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzO1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZUZvckVhY2gob2JzZXJ2YWJsZVtTeW1ib2wub2JzZXJ2ZXJdLmJpbmQob2JzZXJ2YWJsZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGN0eC5kb25lKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVybigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjdHguZGVjb3JhdGVkT2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY3R4LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgY3R4LmRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgQXN5bmNHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGVbU3ltYm9sLm9ic2VydmVyXSA9IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgdmFyIG9ic2VydmUgPSBnZXRQcml2YXRlKHRoaXMsIG9ic2VydmVOYW1lKTtcbiAgICB2YXIgY3R4ID0gbmV3IEFzeW5jR2VuZXJhdG9yQ29udGV4dChvYnNlcnZlcik7XG4gICAgc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZShjdHgpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghY3R4LmRvbmUpIHtcbiAgICAgICAgY3R4LmRlY29yYXRlZE9ic2VydmVyLnJldHVybih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmICghY3R4LmRvbmUpIHtcbiAgICAgICAgY3R4LmRlY29yYXRlZE9ic2VydmVyLnRocm93KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3R4LmRlY29yYXRlZE9ic2VydmVyO1xuICB9O1xuICBkZWZpbmVQcm9wZXJ0eShBc3luY0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSwgU3ltYm9sLm9ic2VydmVyLCB7ZW51bWVyYWJsZTogZmFsc2V9KTtcbiAgZnVuY3Rpb24gaW5pdEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24oZnVuY3Rpb25PYmplY3QpIHtcbiAgICBmdW5jdGlvbk9iamVjdC5wcm90b3R5cGUgPSBjcmVhdGUoQXN5bmNHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUpO1xuICAgIGZ1bmN0aW9uT2JqZWN0Ll9fcHJvdG9fXyA9IEFzeW5jR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uT2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jR2VuZXJhdG9ySW5zdGFuY2Uob2JzZXJ2ZSwgZnVuY3Rpb25PYmplY3QpIHtcbiAgICBmb3IgKHZhciBhcmdzID0gW10sXG4gICAgICAgICRfXzEwID0gMjsgJF9fMTAgPCBhcmd1bWVudHMubGVuZ3RoOyAkX18xMCsrKVxuICAgICAgYXJnc1skX18xMCAtIDJdID0gYXJndW1lbnRzWyRfXzEwXTtcbiAgICB2YXIgb2JqZWN0ID0gY3JlYXRlKGZ1bmN0aW9uT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgc2V0UHJpdmF0ZShvYmplY3QsIG9ic2VydmVOYW1lLCBvYnNlcnZlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIG9ic2VydmVGb3JFYWNoKG9ic2VydmUsIG5leHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gb2JzZXJ2ZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQuY2FsbChnZW5lcmF0b3IsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3c6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV0dXJuOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzY2hlZHVsZShhc3luY0YpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luY0YpO1xuICB9XG4gIHZhciBnZW5lcmF0b3IgPSBTeW1ib2woKTtcbiAgdmFyIG9uRG9uZSA9IFN5bWJvbCgpO1xuICB2YXIgRGVjb3JhdGVkR2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRGVjb3JhdGVkR2VuZXJhdG9yKF9nZW5lcmF0b3IsIF9vbkRvbmUpIHtcbiAgICAgIHRoaXNbZ2VuZXJhdG9yXSA9IF9nZW5lcmF0b3I7XG4gICAgICB0aGlzW29uRG9uZV0gPSBfb25Eb25lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRGVjb3JhdGVkR2VuZXJhdG9yLCB7XG4gICAgICBuZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpc1tnZW5lcmF0b3JdLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICB0aGlzW29uRG9uZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRocm93OiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB0aGlzW29uRG9uZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbZ2VuZXJhdG9yXS50aHJvdyhlcnJvcik7XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzW29uRG9uZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbZ2VuZXJhdG9yXS5yZXR1cm4odmFsdWUpO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICBmdW5jdGlvbiBjcmVhdGVEZWNvcmF0ZWRHZW5lcmF0b3IoZ2VuZXJhdG9yLCBvbkRvbmUpIHtcbiAgICByZXR1cm4gbmV3IERlY29yYXRlZEdlbmVyYXRvcihnZW5lcmF0b3IsIG9uRG9uZSk7XG4gIH1cbiAgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5vYnNlcnZlcl0gPSBmdW5jdGlvbihvYnNlcnZlcikge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIGRlY29yYXRlZE9ic2VydmVyID0gY3JlYXRlRGVjb3JhdGVkR2VuZXJhdG9yKG9ic2VydmVyLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb25lID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB2YXIgJF9fNiA9IHRydWU7XG4gICAgdmFyICRfXzcgPSBmYWxzZTtcbiAgICB2YXIgJF9fOCA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgJF9fNCA9IHZvaWQgMCxcbiAgICAgICAgICAkX18zID0gKHRoaXMpW1N5bWJvbC5pdGVyYXRvcl0oKTsgISgkX182ID0gKCRfXzQgPSAkX18zLm5leHQoKSkuZG9uZSk7ICRfXzYgPSB0cnVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICRfXzQudmFsdWU7XG4gICAgICAgIHtcbiAgICAgICAgICBkZWNvcmF0ZWRPYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKCRfXzkpIHtcbiAgICAgICRfXzcgPSB0cnVlO1xuICAgICAgJF9fOCA9ICRfXzk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghJF9fNiAmJiAkX18zLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgJF9fMy5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKCRfXzcpIHtcbiAgICAgICAgICB0aHJvdyAkX184O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRlY29yYXRlZE9ic2VydmVyLnJldHVybigpO1xuICAgIHJldHVybiBkZWNvcmF0ZWRPYnNlcnZlcjtcbiAgfTtcbiAgZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCBTeW1ib2wub2JzZXJ2ZXIsIHtlbnVtZXJhYmxlOiBmYWxzZX0pO1xuICByZXR1cm4ge1xuICAgIGdldCBpbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jR2VuZXJhdG9ySW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXQgb2JzZXJ2ZUZvckVhY2goKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZUZvckVhY2g7XG4gICAgfSxcbiAgICBnZXQgc2NoZWR1bGUoKSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGU7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlRGVjb3JhdGVkR2VuZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRlZEdlbmVyYXRvcjtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2luaXRBc3luY0dlbmVyYXRvckZ1bmN0aW9uLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2luaXRBc3luY0dlbmVyYXRvckZ1bmN0aW9uLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYXN5bmMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9pbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbi5qc1wiKSk7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfYXN5bmNfNDZfanNfXy5pbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvY3JlYXRlQXN5bmNHZW5lcmF0b3JJbnN0YW5jZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYXN5bmMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fLmNyZWF0ZUFzeW5jR2VuZXJhdG9ySW5zdGFuY2U7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL29ic2VydmVGb3JFYWNoLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL29ic2VydmVGb3JFYWNoLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYXN5bmMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9vYnNlcnZlRm9yRWFjaC5qc1wiKSk7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfYXN5bmNfNDZfanNfXy5vYnNlcnZlRm9yRWFjaDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc2NoZWR1bGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc2NoZWR1bGUuanNcIjtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfcnVudGltZV80N19tb2R1bGVzXzQ3X2FzeW5jXzQ2X2pzX18gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hc3luYy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL3NjaGVkdWxlLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fLnNjaGVkdWxlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVEZWNvcmF0ZWRHZW5lcmF0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvY3JlYXRlRGVjb3JhdGVkR2VuZXJhdG9yLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19hc3luY180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYXN5bmMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVEZWNvcmF0ZWRHZW5lcmF0b3IuanNcIikpO1xuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfcnVudGltZV80N19tb2R1bGVzXzQ3X2FzeW5jXzQ2X2pzX18uY3JlYXRlRGVjb3JhdGVkR2VuZXJhdG9yO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvYXN5bmMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2FzeW5jLmpzXCI7XG4gIHZhciBpbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZXMvaW5pdEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvYXN5bmMuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBjcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9jcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2FzeW5jLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgb2JzZXJ2ZUZvckVhY2ggPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL29ic2VydmVGb3JFYWNoLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2FzeW5jLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgc2NoZWR1bGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3NjaGVkdWxlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2FzeW5jLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgY3JlYXRlRGVjb3JhdGVkR2VuZXJhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9jcmVhdGVEZWNvcmF0ZWRHZW5lcmF0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvYXN5bmMuanNcIikpLmRlZmF1bHQ7XG4gICR0cmFjZXVyUnVudGltZS5pbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbiA9IGluaXRBc3luY0dlbmVyYXRvckZ1bmN0aW9uO1xuICAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQXN5bmNHZW5lcmF0b3JJbnN0YW5jZSA9IGNyZWF0ZUFzeW5jR2VuZXJhdG9ySW5zdGFuY2U7XG4gICR0cmFjZXVyUnVudGltZS5vYnNlcnZlRm9yRWFjaCA9IG9ic2VydmVGb3JFYWNoO1xuICAkdHJhY2V1clJ1bnRpbWUuc2NoZWR1bGUgPSBzY2hlZHVsZTtcbiAgJHRyYWNldXJSdW50aW1lLmNyZWF0ZURlY29yYXRlZEdlbmVyYXRvciA9IGNyZWF0ZURlY29yYXRlZEdlbmVyYXRvcjtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9nZW5lcmF0b3JzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2dlbmVyYXRvcnMuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vcHJpdmF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2dlbmVyYXRvcnMuanNcIikpLFxuICAgICAgY3JlYXRlUHJpdmF0ZVN5bWJvbCA9ICRfXzIuY3JlYXRlUHJpdmF0ZVN5bWJvbCxcbiAgICAgIGdldFByaXZhdGUgPSAkX18yLmdldFByaXZhdGUsXG4gICAgICBzZXRQcml2YXRlID0gJF9fMi5zZXRQcml2YXRlO1xuICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgdmFyICRfXzEgPSBPYmplY3QsXG4gICAgICBjcmVhdGUgPSAkX18xLmNyZWF0ZSxcbiAgICAgIGRlZmluZVByb3BlcnRpZXMgPSAkX18xLmRlZmluZVByb3BlcnRpZXMsXG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9ICRfXzEuZGVmaW5lUHJvcGVydHk7XG4gIGZ1bmN0aW9uIG5vbkVudW0odmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gIH1cbiAgdmFyIFNUX05FV0JPUk4gPSAwO1xuICB2YXIgU1RfRVhFQ1VUSU5HID0gMTtcbiAgdmFyIFNUX1NVU1BFTkRFRCA9IDI7XG4gIHZhciBTVF9DTE9TRUQgPSAzO1xuICB2YXIgRU5EX1NUQVRFID0gLTI7XG4gIHZhciBSRVRIUk9XX1NUQVRFID0gLTM7XG4gIGZ1bmN0aW9uIGdldEludGVybmFsRXJyb3Ioc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdUcmFjZXVyIGNvbXBpbGVyIGJ1ZzogaW52YWxpZCBzdGF0ZSBpbiBzdGF0ZSBtYWNoaW5lOiAnICsgc3RhdGUpO1xuICB9XG4gIHZhciBSRVRVUk5fU0VOVElORUwgPSB7fTtcbiAgZnVuY3Rpb24gR2VuZXJhdG9yQ29udGV4dCgpIHtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLkdTdGF0ZSA9IFNUX05FV0JPUk47XG4gICAgdGhpcy5zdG9yZWRFeGNlcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5maW5hbGx5RmFsbFRocm91Z2ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZW50XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2xkUmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50cnlTdGFja18gPSBbXTtcbiAgfVxuICBHZW5lcmF0b3JDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBwdXNoVHJ5OiBmdW5jdGlvbihjYXRjaFN0YXRlLCBmaW5hbGx5U3RhdGUpIHtcbiAgICAgIGlmIChmaW5hbGx5U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZpbmFsbHlGYWxsVGhyb3VnaCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeVN0YWNrXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICh0aGlzLnRyeVN0YWNrX1tpXS5jYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmaW5hbGx5RmFsbFRocm91Z2ggPSB0aGlzLnRyeVN0YWNrX1tpXS5jYXRjaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUZhbGxUaHJvdWdoID09PSBudWxsKVxuICAgICAgICAgIGZpbmFsbHlGYWxsVGhyb3VnaCA9IFJFVEhST1dfU1RBVEU7XG4gICAgICAgIHRoaXMudHJ5U3RhY2tfLnB1c2goe1xuICAgICAgICAgIGZpbmFsbHk6IGZpbmFsbHlTdGF0ZSxcbiAgICAgICAgICBmaW5hbGx5RmFsbFRocm91Z2g6IGZpbmFsbHlGYWxsVGhyb3VnaFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXRjaFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudHJ5U3RhY2tfLnB1c2goe2NhdGNoOiBjYXRjaFN0YXRlfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3BUcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cnlTdGFja18ucG9wKCk7XG4gICAgfSxcbiAgICBtYXliZVVuY2F0Y2hhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0b3JlZEV4Y2VwdGlvbiA9PT0gUkVUVVJOX1NFTlRJTkVMKSB7XG4gICAgICAgIHRocm93IFJFVFVSTl9TRU5USU5FTDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBzZW50KCkge1xuICAgICAgdGhpcy5tYXliZVRocm93KCk7XG4gICAgICByZXR1cm4gdGhpcy5zZW50XztcbiAgICB9LFxuICAgIHNldCBzZW50KHYpIHtcbiAgICAgIHRoaXMuc2VudF8gPSB2O1xuICAgIH0sXG4gICAgZ2V0IHNlbnRJZ25vcmVUaHJvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbnRfO1xuICAgIH0sXG4gICAgbWF5YmVUaHJvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5hY3Rpb24gPT09ICd0aHJvdycpIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSAnbmV4dCc7XG4gICAgICAgIHRocm93IHRoaXMuc2VudF87XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgRU5EX1NUQVRFOlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjYXNlIFJFVEhST1dfU1RBVEU6XG4gICAgICAgICAgdGhyb3cgdGhpcy5zdG9yZWRFeGNlcHRpb247XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxFcnJvcih0aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUV4Y2VwdGlvbjogZnVuY3Rpb24oZXgpIHtcbiAgICAgIHRoaXMuR1N0YXRlID0gU1RfQ0xPU0VEO1xuICAgICAgdGhpcy5zdGF0ZSA9IEVORF9TVEFURTtcbiAgICAgIHRocm93IGV4O1xuICAgIH0sXG4gICAgd3JhcFlpZWxkU3RhcjogZnVuY3Rpb24oaXRlcmF0b3IpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KHYpO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvdzogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgaWYgKGUgPT09IFJFVFVSTl9TRU5USU5FTCkge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5yZXR1cm4oY3R4LnJldHVyblZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGN0eC5yZXR1cm5WYWx1ZSA9IGN0eC5vbGRSZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5yZXR1cm5WYWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRvci50aHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLnRocm93KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVyYXRvci5yZXR1cm4gJiYgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgdGhyb3cgJFR5cGVFcnJvcignSW5uZXIgaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gbmV4dE9yVGhyb3coY3R4LCBtb3ZlTmV4dCwgYWN0aW9uLCB4KSB7XG4gICAgc3dpdGNoIChjdHguR1N0YXRlKSB7XG4gICAgICBjYXNlIFNUX0VYRUNVVElORzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlxcXCJcIiArIGFjdGlvbiArIFwiXFxcIiBvbiBleGVjdXRpbmcgZ2VuZXJhdG9yXCIpKTtcbiAgICAgIGNhc2UgU1RfQ0xPU0VEOlxuICAgICAgICBpZiAoYWN0aW9uID09ICduZXh0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IFJFVFVSTl9TRU5USU5FTCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogY3R4LnJldHVyblZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgeDtcbiAgICAgIGNhc2UgU1RfTkVXQk9STjpcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgIGN0eC5HU3RhdGUgPSBTVF9DTE9TRUQ7XG4gICAgICAgICAgaWYgKHggPT09IFJFVFVSTl9TRU5USU5FTCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGN0eC5yZXR1cm5WYWx1ZSxcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93ICRUeXBlRXJyb3IoJ1NlbnQgdmFsdWUgdG8gbmV3Ym9ybiBnZW5lcmF0b3InKTtcbiAgICAgIGNhc2UgU1RfU1VTUEVOREVEOlxuICAgICAgICBjdHguR1N0YXRlID0gU1RfRVhFQ1VUSU5HO1xuICAgICAgICBjdHguYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBjdHguc2VudCA9IHg7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IG1vdmVOZXh0KGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgaWYgKGV4ID09PSBSRVRVUk5fU0VOVElORUwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY3R4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvbmUgPSB2YWx1ZSA9PT0gY3R4O1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICB2YWx1ZSA9IGN0eC5yZXR1cm5WYWx1ZTtcbiAgICAgICAgY3R4LkdTdGF0ZSA9IGRvbmUgPyBTVF9DTE9TRUQgOiBTVF9TVVNQRU5ERUQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdmFyIGN0eE5hbWUgPSBjcmVhdGVQcml2YXRlU3ltYm9sKCk7XG4gIHZhciBtb3ZlTmV4dE5hbWUgPSBjcmVhdGVQcml2YXRlU3ltYm9sKCk7XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIG5vbkVudW0oR2VuZXJhdG9yRnVuY3Rpb24pKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICBuZXh0OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gbmV4dE9yVGhyb3coZ2V0UHJpdmF0ZSh0aGlzLCBjdHhOYW1lKSwgZ2V0UHJpdmF0ZSh0aGlzLCBtb3ZlTmV4dE5hbWUpLCAnbmV4dCcsIHYpO1xuICAgIH0sXG4gICAgdGhyb3c6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBuZXh0T3JUaHJvdyhnZXRQcml2YXRlKHRoaXMsIGN0eE5hbWUpLCBnZXRQcml2YXRlKHRoaXMsIG1vdmVOZXh0TmFtZSksICd0aHJvdycsIHYpO1xuICAgIH0sXG4gICAgcmV0dXJuOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgY3R4ID0gZ2V0UHJpdmF0ZSh0aGlzLCBjdHhOYW1lKTtcbiAgICAgIGN0eC5vbGRSZXR1cm5WYWx1ZSA9IGN0eC5yZXR1cm5WYWx1ZTtcbiAgICAgIGN0eC5yZXR1cm5WYWx1ZSA9IHY7XG4gICAgICByZXR1cm4gbmV4dE9yVGhyb3coY3R4LCBnZXRQcml2YXRlKHRoaXMsIG1vdmVOZXh0TmFtZSksICd0aHJvdycsIFJFVFVSTl9TRU5USU5FTCk7XG4gICAgfVxuICB9O1xuICBkZWZpbmVQcm9wZXJ0aWVzKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7ZW51bWVyYWJsZTogZmFsc2V9LFxuICAgIG5leHQ6IHtlbnVtZXJhYmxlOiBmYWxzZX0sXG4gICAgdGhyb3c6IHtlbnVtZXJhYmxlOiBmYWxzZX0sXG4gICAgcmV0dXJuOiB7ZW51bWVyYWJsZTogZmFsc2V9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIG5vbkVudW0oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pKTtcbiAgZnVuY3Rpb24gY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UoaW5uZXJGdW5jdGlvbiwgZnVuY3Rpb25PYmplY3QsIHNlbGYpIHtcbiAgICB2YXIgbW92ZU5leHQgPSBnZXRNb3ZlTmV4dChpbm5lckZ1bmN0aW9uLCBzZWxmKTtcbiAgICB2YXIgY3R4ID0gbmV3IEdlbmVyYXRvckNvbnRleHQoKTtcbiAgICB2YXIgb2JqZWN0ID0gY3JlYXRlKGZ1bmN0aW9uT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgc2V0UHJpdmF0ZShvYmplY3QsIGN0eE5hbWUsIGN0eCk7XG4gICAgc2V0UHJpdmF0ZShvYmplY3QsIG1vdmVOZXh0TmFtZSwgbW92ZU5leHQpO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdEdlbmVyYXRvckZ1bmN0aW9uKGZ1bmN0aW9uT2JqZWN0KSB7XG4gICAgZnVuY3Rpb25PYmplY3QucHJvdG90eXBlID0gY3JlYXRlKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSk7XG4gICAgZnVuY3Rpb25PYmplY3QuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uT2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIEFzeW5jRnVuY3Rpb25Db250ZXh0KCkge1xuICAgIEdlbmVyYXRvckNvbnRleHQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVyciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICBjdHgucmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjdHgucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBjdHgucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG4gIEFzeW5jRnVuY3Rpb25Db250ZXh0LnByb3RvdHlwZSA9IGNyZWF0ZShHZW5lcmF0b3JDb250ZXh0LnByb3RvdHlwZSk7XG4gIEFzeW5jRnVuY3Rpb25Db250ZXh0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgRU5EX1NUQVRFOlxuICAgICAgICB0aGlzLnJlc29sdmUodGhpcy5yZXR1cm5WYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRVRIUk9XX1NUQVRFOlxuICAgICAgICB0aGlzLnJlamVjdCh0aGlzLnN0b3JlZEV4Y2VwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yZWplY3QoZ2V0SW50ZXJuYWxFcnJvcih0aGlzLnN0YXRlKSk7XG4gICAgfVxuICB9O1xuICBBc3luY0Z1bmN0aW9uQ29udGV4dC5wcm90b3R5cGUuaGFuZGxlRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFJFVEhST1dfU1RBVEU7XG4gIH07XG4gIGZ1bmN0aW9uIGFzeW5jV3JhcChpbm5lckZ1bmN0aW9uLCBzZWxmKSB7XG4gICAgdmFyIG1vdmVOZXh0ID0gZ2V0TW92ZU5leHQoaW5uZXJGdW5jdGlvbiwgc2VsZik7XG4gICAgdmFyIGN0eCA9IG5ldyBBc3luY0Z1bmN0aW9uQ29udGV4dCgpO1xuICAgIGN0eC5jcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY3R4LnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGN0eC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBtb3ZlTmV4dChjdHgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGN0eC5lcnJiYWNrID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBoYW5kbGVDYXRjaChjdHgsIGVycik7XG4gICAgICBtb3ZlTmV4dChjdHgpO1xuICAgIH07XG4gICAgbW92ZU5leHQoY3R4KTtcbiAgICByZXR1cm4gY3R4LnJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBnZXRNb3ZlTmV4dChpbm5lckZ1bmN0aW9uLCBzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGN0eCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gaW5uZXJGdW5jdGlvbi5jYWxsKHNlbGYsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgaGFuZGxlQ2F0Y2goY3R4LCBleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNhdGNoKGN0eCwgZXgpIHtcbiAgICBjdHguc3RvcmVkRXhjZXB0aW9uID0gZXg7XG4gICAgdmFyIGxhc3QgPSBjdHgudHJ5U3RhY2tfW2N0eC50cnlTdGFja18ubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICBjdHguaGFuZGxlRXhjZXB0aW9uKGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnN0YXRlID0gbGFzdC5jYXRjaCAhPT0gdW5kZWZpbmVkID8gbGFzdC5jYXRjaCA6IGxhc3QuZmluYWxseTtcbiAgICBpZiAobGFzdC5maW5hbGx5RmFsbFRocm91Z2ggIT09IHVuZGVmaW5lZClcbiAgICAgIGN0eC5maW5hbGx5RmFsbFRocm91Z2ggPSBsYXN0LmZpbmFsbHlGYWxsVGhyb3VnaDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBjcmVhdGVHZW5lcmF0b3JJbnN0YW5jZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVHZW5lcmF0b3JJbnN0YW5jZTtcbiAgICB9LFxuICAgIGdldCBpbml0R2VuZXJhdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5pdEdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGFzeW5jV3JhcCgpIHtcbiAgICAgIHJldHVybiBhc3luY1dyYXA7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9hc3luY1dyYXAuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvYXN5bmNXcmFwLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19nZW5lcmF0b3JzXzQ2X2pzX18gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9nZW5lcmF0b3JzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvYXN5bmNXcmFwLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19nZW5lcmF0b3JzXzQ2X2pzX18uYXN5bmNXcmFwO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9pbml0R2VuZXJhdG9yRnVuY3Rpb24uanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvaW5pdEdlbmVyYXRvckZ1bmN0aW9uLmpzXCI7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19nZW5lcmF0b3JzXzQ2X2pzX18gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9nZW5lcmF0b3JzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvaW5pdEdlbmVyYXRvckZ1bmN0aW9uLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19nZW5lcmF0b3JzXzQ2X2pzX18uaW5pdEdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVHZW5lcmF0b3JJbnN0YW5jZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9jcmVhdGVHZW5lcmF0b3JJbnN0YW5jZS5qc1wiO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19ydW50aW1lXzQ3X21vZHVsZXNfNDdfZ2VuZXJhdG9yc180Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vZ2VuZXJhdG9ycy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9tb2R1bGVzL2NyZWF0ZUdlbmVyYXRvckluc3RhbmNlLmpzXCIpKTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X3J1bnRpbWVfNDdfbW9kdWxlc180N19nZW5lcmF0b3JzXzQ2X2pzX18uY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2U7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9nZW5lcmF0b3JzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9nZW5lcmF0b3JzLmpzXCI7XG4gIHZhciBhc3luY1dyYXAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL2FzeW5jV3JhcC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9nZW5lcmF0b3JzLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgaW5pdEdlbmVyYXRvckZ1bmN0aW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9pbml0R2VuZXJhdG9yRnVuY3Rpb24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvZ2VuZXJhdG9ycy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIGNyZWF0ZUdlbmVyYXRvckluc3RhbmNlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9jcmVhdGVHZW5lcmF0b3JJbnN0YW5jZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9nZW5lcmF0b3JzLmpzXCIpKS5kZWZhdWx0O1xuICAkdHJhY2V1clJ1bnRpbWUuYXN5bmNXcmFwID0gYXN5bmNXcmFwO1xuICAkdHJhY2V1clJ1bnRpbWUuaW5pdEdlbmVyYXRvckZ1bmN0aW9uID0gaW5pdEdlbmVyYXRvckZ1bmN0aW9uO1xuICAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UgPSBjcmVhdGVHZW5lcmF0b3JJbnN0YW5jZTtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zcGF3bi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zcGF3bi5qc1wiO1xuICBmdW5jdGlvbiBzcGF3bihzZWxmLCBhcmdzLCBnZW4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsKHYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGVwKGdlbi5uZXh0KHYpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0ZXAoZ2VuLnRocm93KHYpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXMpIHtcbiAgICAgICAgaWYgKHJlcy5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXMudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShyZXMudmFsdWUpLnRoZW4oZnVsZmlsbCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGVwKChnZW4gPSBnZW4uYXBwbHkoc2VsZiwgYXJncykpLm5leHQoKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBzcGF3bjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3NwYXduLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9zcGF3bi5qc1wiO1xuICB2YXIgc3Bhd24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3NwYXduLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3NwYXduLmpzXCIpKS5kZWZhdWx0O1xuICAkdHJhY2V1clJ1bnRpbWUuc3Bhd24gPSBzcGF3bjtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9nZXRUZW1wbGF0ZU9iamVjdC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9nZXRUZW1wbGF0ZU9iamVjdC5qc1wiO1xuICB2YXIgJF9fMSA9IE9iamVjdCxcbiAgICAgIGRlZmluZVByb3BlcnR5ID0gJF9fMS5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgIGZyZWV6ZSA9ICRfXzEuZnJlZXplO1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBnZXRUZW1wbGF0ZU9iamVjdChyYXcpIHtcbiAgICB2YXIgY29va2VkID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBrZXkgPSByYXcuam9pbignJHt9Jyk7XG4gICAgdmFyIHRlbXBsYXRlT2JqZWN0ID0gbWFwW2tleV07XG4gICAgaWYgKHRlbXBsYXRlT2JqZWN0KVxuICAgICAgcmV0dXJuIHRlbXBsYXRlT2JqZWN0O1xuICAgIGlmICghY29va2VkKSB7XG4gICAgICBjb29rZWQgPSBzbGljZS5jYWxsKHJhdyk7XG4gICAgfVxuICAgIHJldHVybiBtYXBba2V5XSA9IGZyZWV6ZShkZWZpbmVQcm9wZXJ0eShjb29rZWQsICdyYXcnLCB7dmFsdWU6IGZyZWV6ZShyYXcpfSkpO1xuICB9XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gZ2V0VGVtcGxhdGVPYmplY3Q7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS90ZW1wbGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvdGVtcGxhdGUuanNcIjtcbiAgdmFyIGdldFRlbXBsYXRlT2JqZWN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vbW9kdWxlcy9nZXRUZW1wbGF0ZU9iamVjdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS90ZW1wbGF0ZS5qc1wiKSkuZGVmYXVsdDtcbiAgJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0ID0gZ2V0VGVtcGxhdGVPYmplY3Q7XG4gIHJldHVybiB7fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL21vZHVsZXMvc3ByZWFkUHJvcGVydGllcy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvbW9kdWxlcy9zcHJlYWRQcm9wZXJ0aWVzLmpzXCI7XG4gIHZhciAkX18xID0gT2JqZWN0LFxuICAgICAgZGVmaW5lUHJvcGVydHkgPSAkX18xLmRlZmluZVByb3BlcnR5LFxuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lcyA9ICRfXzEuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgIGdldE93blByb3BlcnR5U3ltYm9scyA9ICRfXzEuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSAkX18xLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBmdW5jdGlvbiBjcmVhdGVEYXRhUHJvcGVydHkobywgcCwgdikge1xuICAgIGRlZmluZVByb3BlcnR5KG8sIHAsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdixcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY29weURhdGFQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3B5ID0gZnVuY3Rpb24oa2V5cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBuZXh0S2V5KSkge1xuICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgY3JlYXRlRGF0YVByb3BlcnR5KHRhcmdldCwgbmV4dEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29weShnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSkpO1xuICAgIGNvcHkoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkpO1xuICB9XG4gIHZhciAkX19kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29weURhdGFQcm9wZXJ0aWVzKHRhcmdldCwgYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX19kZWZhdWx0O1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvanN4LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9qc3guanNcIjtcbiAgdmFyIHNwcmVhZFByb3BlcnRpZXMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9tb2R1bGVzL3NwcmVhZFByb3BlcnRpZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvanN4LmpzXCIpKS5kZWZhdWx0O1xuICAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkUHJvcGVydGllcyA9IHNwcmVhZFByb3BlcnRpZXM7XG4gIHJldHVybiB7fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3J1bnRpbWUtbW9kdWxlcy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCI7XG4gICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N5bWJvbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCIpKTtcbiAgJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vY2xhc3Nlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9ydW50aW1lLW1vZHVsZXMuanNcIikpO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9leHBvcnRTdGFyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3J1bnRpbWUtbW9kdWxlcy5qc1wiKSk7XG4gICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3Byb3BlclRhaWxDYWxscy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9ydW50aW1lLW1vZHVsZXMuanNcIikpO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9yZWxhdGl2ZVJlcXVpcmUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCIpKTtcbiAgJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vc3ByZWFkLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3J1bnRpbWUtbW9kdWxlcy5qc1wiKSk7XG4gICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2Rlc3RydWN0dXJpbmcuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCIpKTtcbiAgJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYXN5bmMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCIpKTtcbiAgJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vZ2VuZXJhdG9ycy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9ydW50aW1lLW1vZHVsZXMuanNcIikpO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9zcGF3bi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9ydW50aW1lLW1vZHVsZXMuanNcIikpO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi90ZW1wbGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9ydW50aW1lLW1vZHVsZXMuanNcIikpO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9qc3guanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcnVudGltZS1tb2R1bGVzLmpzXCIpKTtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3J1bnRpbWUtbW9kdWxlcy5qc1wiICsgJycpO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL2Zyb3plbi1kYXRhLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9mcm96ZW4tZGF0YS5qc1wiO1xuICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGFycltpXSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RnJvemVuKGFyciwga2V5LCB2YWwpIHtcbiAgICB2YXIgaSA9IGZpbmRJbmRleChhcnIsIGtleSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICBhcnIucHVzaChrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEZyb3plbihhcnIsIGtleSkge1xuICAgIHZhciBpID0gZmluZEluZGV4KGFyciwga2V5KTtcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBhcnJbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0Zyb3plbihhcnIsIGtleSkge1xuICAgIHJldHVybiBmaW5kSW5kZXgoYXJyLCBrZXkpICE9PSAtMTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVGcm96ZW4oYXJyLCBrZXkpIHtcbiAgICB2YXIgaSA9IGZpbmRJbmRleChhcnIsIGtleSk7XG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBzZXRGcm96ZW4oKSB7XG4gICAgICByZXR1cm4gc2V0RnJvemVuO1xuICAgIH0sXG4gICAgZ2V0IGdldEZyb3plbigpIHtcbiAgICAgIHJldHVybiBnZXRGcm96ZW47XG4gICAgfSxcbiAgICBnZXQgaGFzRnJvemVuKCkge1xuICAgICAgcmV0dXJuIGhhc0Zyb3plbjtcbiAgICB9LFxuICAgIGdldCBkZWxldGVGcm96ZW4oKSB7XG4gICAgICByZXR1cm4gZGVsZXRlRnJvemVuO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy91dGlscy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL3V0aWxzLmpzXCI7XG4gIHZhciAkY2VpbCA9IE1hdGguY2VpbDtcbiAgdmFyICRmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciAkaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgdmFyICRpc05hTiA9IGlzTmFOO1xuICB2YXIgJHBvdyA9IE1hdGgucG93O1xuICB2YXIgJG1pbiA9IE1hdGgubWluO1xuICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gIGZ1bmN0aW9uIHRvT2JqZWN0KHgpIHtcbiAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyAkVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiAkT2JqZWN0KHgpO1xuICB9XG4gIGZ1bmN0aW9uIHRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbiAgfVxuICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggJiYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYWxsYWJsZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIGZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInO1xuICB9XG4gIGZ1bmN0aW9uIHRvSW50ZWdlcih4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICgkaXNOYU4oeCkpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoeCA9PT0gMCB8fCAhJGlzRmluaXRlKHgpKVxuICAgICAgcmV0dXJuIHg7XG4gICAgcmV0dXJuIHggPiAwID8gJGZsb29yKHgpIDogJGNlaWwoeCk7XG4gIH1cbiAgdmFyIE1BWF9TQUZFX0xFTkdUSCA9ICRwb3coMiwgNTMpIC0gMTtcbiAgZnVuY3Rpb24gdG9MZW5ndGgoeCkge1xuICAgIHZhciBsZW4gPSB0b0ludGVnZXIoeCk7XG4gICAgcmV0dXJuIGxlbiA8IDAgPyAwIDogJG1pbihsZW4sIE1BWF9TQUZFX0xFTkdUSCk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tJdGVyYWJsZSh4KSB7XG4gICAgcmV0dXJuICFpc09iamVjdCh4KSA/IHVuZGVmaW5lZCA6IHhbU3ltYm9sLml0ZXJhdG9yXTtcbiAgfVxuICBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKHgpIHtcbiAgICByZXR1cm4gaXNDYWxsYWJsZSh4KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCh2YWx1ZSwgZG9uZSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBkb25lOiBkb25lXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZURlZmluZShvYmplY3QsIG5hbWUsIGRlc2NyKSB7XG4gICAgaWYgKCEobmFtZSBpbiBvYmplY3QpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBkZXNjcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlRGVmaW5lTWV0aG9kKG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBtYXliZURlZmluZShvYmplY3QsIG5hbWUsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZURlZmluZUNvbnN0KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBtYXliZURlZmluZShvYmplY3QsIG5hbWUsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlQWRkRnVuY3Rpb25zKG9iamVjdCwgZnVuY3Rpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBuYW1lID0gZnVuY3Rpb25zW2ldO1xuICAgICAgdmFyIHZhbHVlID0gZnVuY3Rpb25zW2kgKyAxXTtcbiAgICAgIG1heWJlRGVmaW5lTWV0aG9kKG9iamVjdCwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZUFkZENvbnN0cyhvYmplY3QsIGNvbnN0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgbmFtZSA9IGNvbnN0c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbnN0c1tpICsgMV07XG4gICAgICBtYXliZURlZmluZUNvbnN0KG9iamVjdCwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZUFkZEl0ZXJhdG9yKG9iamVjdCwgZnVuYywgU3ltYm9sKSB7XG4gICAgaWYgKCFTeW1ib2wgfHwgIVN5bWJvbC5pdGVyYXRvciB8fCBvYmplY3RbU3ltYm9sLml0ZXJhdG9yXSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAob2JqZWN0WydAQGl0ZXJhdG9yJ10pXG4gICAgICBmdW5jID0gb2JqZWN0WydAQGl0ZXJhdG9yJ107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgICB2YWx1ZTogZnVuYyxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICB2YXIgcG9seWZpbGxzID0gW107XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUG9seWZpbGwoZnVuYykge1xuICAgIHBvbHlmaWxscy5wdXNoKGZ1bmMpO1xuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsQWxsKGdsb2JhbCkge1xuICAgIHBvbHlmaWxscy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmKGdsb2JhbCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgdG9PYmplY3QoKSB7XG4gICAgICByZXR1cm4gdG9PYmplY3Q7XG4gICAgfSxcbiAgICBnZXQgdG9VaW50MzIoKSB7XG4gICAgICByZXR1cm4gdG9VaW50MzI7XG4gICAgfSxcbiAgICBnZXQgaXNPYmplY3QoKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3Q7XG4gICAgfSxcbiAgICBnZXQgaXNDYWxsYWJsZSgpIHtcbiAgICAgIHJldHVybiBpc0NhbGxhYmxlO1xuICAgIH0sXG4gICAgZ2V0IGlzTnVtYmVyKCkge1xuICAgICAgcmV0dXJuIGlzTnVtYmVyO1xuICAgIH0sXG4gICAgZ2V0IHRvSW50ZWdlcigpIHtcbiAgICAgIHJldHVybiB0b0ludGVnZXI7XG4gICAgfSxcbiAgICBnZXQgdG9MZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdG9MZW5ndGg7XG4gICAgfSxcbiAgICBnZXQgY2hlY2tJdGVyYWJsZSgpIHtcbiAgICAgIHJldHVybiBjaGVja0l0ZXJhYmxlO1xuICAgIH0sXG4gICAgZ2V0IGlzQ29uc3RydWN0b3IoKSB7XG4gICAgICByZXR1cm4gaXNDb25zdHJ1Y3RvcjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdDtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZSgpIHtcbiAgICAgIHJldHVybiBtYXliZURlZmluZTtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZU1ldGhvZCgpIHtcbiAgICAgIHJldHVybiBtYXliZURlZmluZU1ldGhvZDtcbiAgICB9LFxuICAgIGdldCBtYXliZURlZmluZUNvbnN0KCkge1xuICAgICAgcmV0dXJuIG1heWJlRGVmaW5lQ29uc3Q7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRGdW5jdGlvbnMoKSB7XG4gICAgICByZXR1cm4gbWF5YmVBZGRGdW5jdGlvbnM7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRDb25zdHMoKSB7XG4gICAgICByZXR1cm4gbWF5YmVBZGRDb25zdHM7XG4gICAgfSxcbiAgICBnZXQgbWF5YmVBZGRJdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiBtYXliZUFkZEl0ZXJhdG9yO1xuICAgIH0sXG4gICAgZ2V0IHJlZ2lzdGVyUG9seWZpbGwoKSB7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJQb2x5ZmlsbDtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbEFsbCgpIHtcbiAgICAgIHJldHVybiBwb2x5ZmlsbEFsbDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWFwLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWFwLmpzXCI7XG4gIHZhciAkX18xNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9wcml2YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXAuanNcIikpLFxuICAgICAgY3JlYXRlUHJpdmF0ZVN5bWJvbCA9ICRfXzE2LmNyZWF0ZVByaXZhdGVTeW1ib2wsXG4gICAgICBnZXRQcml2YXRlID0gJF9fMTYuZ2V0UHJpdmF0ZSxcbiAgICAgIHNldFByaXZhdGUgPSAkX18xNi5zZXRQcml2YXRlO1xuICB2YXIgJF9fMTcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vZnJvemVuLWRhdGEuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL01hcC5qc1wiKSksXG4gICAgICBkZWxldGVGcm96ZW4gPSAkX18xNy5kZWxldGVGcm96ZW4sXG4gICAgICBnZXRGcm96ZW4gPSAkX18xNy5nZXRGcm96ZW4sXG4gICAgICBzZXRGcm96ZW4gPSAkX18xNy5zZXRGcm96ZW47XG4gIHZhciAkX18xOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXAuanNcIikpLFxuICAgICAgaXNPYmplY3QgPSAkX18xOC5pc09iamVjdCxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX18xOC5yZWdpc3RlclBvbHlmaWxsO1xuICB2YXIgaGFzTmF0aXZlU3ltYm9sID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL2hhcy1uYXRpdmUtc3ltYm9scy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWFwLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fOSA9IE9iamVjdCxcbiAgICAgIGRlZmluZVByb3BlcnR5ID0gJF9fOS5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9ICRfXzkuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSAkX185Lmhhc093blByb3BlcnR5LFxuICAgICAgaXNFeHRlbnNpYmxlID0gJF9fOS5pc0V4dGVuc2libGU7XG4gIHZhciBkZWxldGVkU2VudGluZWwgPSB7fTtcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgaGFzaENvZGVOYW1lID0gY3JlYXRlUHJpdmF0ZVN5bWJvbCgpO1xuICBmdW5jdGlvbiBnZXRIYXNoQ29kZUZvck9iamVjdChvYmopIHtcbiAgICByZXR1cm4gZ2V0UHJpdmF0ZShvYmosIGhhc2hDb2RlTmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3JTZXRIYXNoQ29kZUZvck9iamVjdChvYmopIHtcbiAgICB2YXIgaGFzaCA9IGdldEhhc2hDb2RlRm9yT2JqZWN0KG9iaik7XG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICBoYXNoID0gY291bnRlcisrO1xuICAgICAgc2V0UHJpdmF0ZShvYmosIGhhc2hDb2RlTmFtZSwgaGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xuICB9XG4gIGZ1bmN0aW9uIGxvb2t1cEluZGV4KG1hcCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWFwLnN0cmluZ0luZGV4X1trZXldO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgaWYgKCFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICByZXR1cm4gZ2V0RnJvemVuKG1hcC5mcm96ZW5EYXRhXywga2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBoYyA9IGdldEhhc2hDb2RlRm9yT2JqZWN0KGtleSk7XG4gICAgICBpZiAoaGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcC5vYmplY3RJbmRleF9baGNdO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLnByaW1pdGl2ZUluZGV4X1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGluaXRNYXAobWFwKSB7XG4gICAgbWFwLmVudHJpZXNfID0gW107XG4gICAgbWFwLm9iamVjdEluZGV4XyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbWFwLnN0cmluZ0luZGV4XyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbWFwLnByaW1pdGl2ZUluZGV4XyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbWFwLmZyb3plbkRhdGFfID0gW107XG4gICAgbWFwLmRlbGV0ZWRDb3VudF8gPSAwO1xuICB9XG4gIHZhciBNYXAgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICB2YXIgJF9fMTEsXG4gICAgICAgICAgJF9fMTI7XG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoIWlzT2JqZWN0KHRoaXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNYXAgY2FsbGVkIG9uIGluY29tcGF0aWJsZSB0eXBlJyk7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnZW50cmllc18nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNYXAgY2FuIG5vdCBiZSByZWVudHJhbnRseSBpbml0aWFsaXNlZCcpO1xuICAgICAgfVxuICAgICAgaW5pdE1hcCh0aGlzKTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPT0gbnVsbCAmJiBpdGVyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciAkX181ID0gdHJ1ZTtcbiAgICAgICAgdmFyICRfXzYgPSBmYWxzZTtcbiAgICAgICAgdmFyICRfXzcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgJF9fMyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgJF9fMiA9IChpdGVyYWJsZSlbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKCRfXzUgPSAoJF9fMyA9ICRfXzIubmV4dCgpKS5kb25lKTsgJF9fNSA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciAkX18xMCA9ICRfXzMudmFsdWUsXG4gICAgICAgICAgICAgICAga2V5ID0gKCRfXzExID0gJF9fMTBbU3ltYm9sLml0ZXJhdG9yXSgpLCAoJF9fMTIgPSAkX18xMS5uZXh0KCkpLmRvbmUgPyB2b2lkIDAgOiAkX18xMi52YWx1ZSksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoJF9fMTIgPSAkX18xMS5uZXh0KCkpLmRvbmUgPyB2b2lkIDAgOiAkX18xMi52YWx1ZTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICgkX184KSB7XG4gICAgICAgICAgJF9fNiA9IHRydWU7XG4gICAgICAgICAgJF9fNyA9ICRfXzg7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghJF9fNSAmJiAkX18yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICRfXzIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgkX182KSB7XG4gICAgICAgICAgICAgIHRocm93ICRfXzc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNYXAsIHtcbiAgICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzXy5sZW5ndGggLyAyIC0gdGhpcy5kZWxldGVkQ291bnRfO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxvb2t1cEluZGV4KHRoaXMsIGtleSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc19baW5kZXggKyAxXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBsb29rdXBJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuZW50cmllc19baW5kZXggKyAxXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gdGhpcy5lbnRyaWVzXy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleF0gPSBrZXk7XG4gICAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleCArIDFdID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgICAgIGlmICghaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgICAgICAgc2V0RnJvemVuKHRoaXMuZnJvemVuRGF0YV8sIGtleSwgaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGhhc2ggPSBnZXRPclNldEhhc2hDb2RlRm9yT2JqZWN0KGtleSk7XG4gICAgICAgICAgICAgIHRoaXMub2JqZWN0SW5kZXhfW2hhc2hdID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdJbmRleF9ba2V5XSA9IGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByaW1pdGl2ZUluZGV4X1trZXldID0gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBsb29rdXBJbmRleCh0aGlzLCBrZXkpICE9PSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgZGVsZXRlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9va3VwSW5kZXgodGhpcywga2V5KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnRyaWVzX1tpbmRleF0gPSBkZWxldGVkU2VudGluZWw7XG4gICAgICAgIHRoaXMuZW50cmllc19baW5kZXggKyAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZWxldGVkQ291bnRfKys7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgaWYgKCFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICAgICAgZGVsZXRlRnJvemVuKHRoaXMuZnJvemVuRGF0YV8sIGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gZ2V0SGFzaENvZGVGb3JPYmplY3Qoa2V5KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9iamVjdEluZGV4X1toYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHJpbmdJbmRleF9ba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5wcmltaXRpdmVJbmRleF9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGluaXRNYXAodGhpcyk7XG4gICAgICB9LFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tGbikge1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXNfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHRoaXMuZW50cmllc19baV07XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5lbnRyaWVzX1tpICsgMV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gZGVsZXRlZFNlbnRpbmVsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FsbGJhY2tGbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW50cmllczogJHRyYWNldXJSdW50aW1lLmluaXRHZW5lcmF0b3JGdW5jdGlvbihmdW5jdGlvbiAkX18xMygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5jcmVhdGVHZW5lcmF0b3JJbnN0YW5jZShmdW5jdGlvbigkY3R4KSB7XG4gICAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgICBzd2l0Y2ggKCRjdHguc3RhdGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKGkgPCB0aGlzLmVudHJpZXNfLmxlbmd0aCkgPyA4IDogLTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5lbnRyaWVzX1tpXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50cmllc19baSArIDFdO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IChrZXkgPT09IGRlbGV0ZWRTZW50aW5lbCkgPyA0IDogNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAkY3R4Lm1heWJlVGhyb3coKTtcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJGN0eC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJF9fMTMsIHRoaXMpO1xuICAgICAgfSksXG4gICAgICBrZXlzOiAkdHJhY2V1clJ1bnRpbWUuaW5pdEdlbmVyYXRvckZ1bmN0aW9uKGZ1bmN0aW9uICRfXzE0KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlKGZ1bmN0aW9uKCRjdHgpIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAoJGN0eC5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAoaSA8IHRoaXMuZW50cmllc18ubGVuZ3RoKSA/IDggOiAtMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmVudHJpZXNfW2ldO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5lbnRyaWVzX1tpICsgMV07XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKGtleSA9PT0gZGVsZXRlZFNlbnRpbmVsKSA/IDQgOiA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICRjdHgubWF5YmVUaHJvdygpO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkY3R4LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAkX18xNCwgdGhpcyk7XG4gICAgICB9KSxcbiAgICAgIHZhbHVlczogJHRyYWNldXJSdW50aW1lLmluaXRHZW5lcmF0b3JGdW5jdGlvbihmdW5jdGlvbiAkX18xNSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5jcmVhdGVHZW5lcmF0b3JJbnN0YW5jZShmdW5jdGlvbigkY3R4KSB7XG4gICAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgICBzd2l0Y2ggKCRjdHguc3RhdGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKGkgPCB0aGlzLmVudHJpZXNfLmxlbmd0aCkgPyA4IDogLTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5lbnRyaWVzX1tpXTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZW50cmllc19baSArIDFdO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IChrZXkgPT09IGRlbGV0ZWRTZW50aW5lbCkgPyA0IDogNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICRjdHgubWF5YmVUaHJvdygpO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkY3R4LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAkX18xNSwgdGhpcyk7XG4gICAgICB9KVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICBkZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IE1hcC5wcm90b3R5cGUuZW50cmllc1xuICB9KTtcbiAgZnVuY3Rpb24gbmVlZHNQb2x5ZmlsbChnbG9iYWwpIHtcbiAgICB2YXIgJF9fMTAgPSBnbG9iYWwsXG4gICAgICAgIE1hcCA9ICRfXzEwLk1hcCxcbiAgICAgICAgU3ltYm9sID0gJF9fMTAuU3ltYm9sO1xuICAgIGlmICghTWFwIHx8ICFoYXNOYXRpdmVTeW1ib2woKSB8fCAhTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdIHx8ICFNYXAucHJvdG90eXBlLmVudHJpZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoW1tdXSkuc2l6ZSAhPT0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsTWFwKGdsb2JhbCkge1xuICAgIGlmIChuZWVkc1BvbHlmaWxsKGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbC5NYXAgPSBNYXA7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxNYXApO1xuICByZXR1cm4ge1xuICAgIGdldCBNYXAoKSB7XG4gICAgICByZXR1cm4gTWFwO1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsTWFwKCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsTWFwO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWFwLmpzXCIgKyAnJyk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1NldC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1NldC5qc1wiO1xuICB2YXIgJF9fMTggPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91dGlscy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU2V0LmpzXCIpKSxcbiAgICAgIGlzT2JqZWN0ID0gJF9fMTguaXNPYmplY3QsXG4gICAgICByZWdpc3RlclBvbHlmaWxsID0gJF9fMTgucmVnaXN0ZXJQb2x5ZmlsbDtcbiAgdmFyIE1hcCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL01hcC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU2V0LmpzXCIpKS5NYXA7XG4gIHZhciBoYXNOYXRpdmVTeW1ib2wgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vaGFzLW5hdGl2ZS1zeW1ib2xzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9TZXQuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBTZXQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTZXQoKSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoIWlzT2JqZWN0KHRoaXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSB0eXBlJyk7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnbWFwXycpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NldCBjYW4gbm90IGJlIHJlZW50cmFudGx5IGluaXRpYWxpc2VkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcF8gPSBuZXcgTWFwKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT09IG51bGwgJiYgaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgJF9fNiA9IHRydWU7XG4gICAgICAgIHZhciAkX183ID0gZmFsc2U7XG4gICAgICAgIHZhciAkX184ID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyICRfXzQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICRfXzMgPSAoaXRlcmFibGUpW1N5bWJvbC5pdGVyYXRvcl0oKTsgISgkX182ID0gKCRfXzQgPSAkX18zLm5leHQoKSkuZG9uZSk7ICRfXzYgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9ICRfXzQudmFsdWU7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoJF9fOSkge1xuICAgICAgICAgICRfXzcgPSB0cnVlO1xuICAgICAgICAgICRfXzggPSAkX185O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoISRfXzYgJiYgJF9fMy5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAkX18zLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoJF9fNykge1xuICAgICAgICAgICAgICB0aHJvdyAkX184O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2V0LCB7XG4gICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwXy5zaXplO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF8uaGFzKGtleSk7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5tYXBfLnNldChrZXksIGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcF8uZGVsZXRlKGtleSk7XG4gICAgICB9LFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBfLmNsZWFyKCk7XG4gICAgICB9LFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2tGbikge1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBfLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnLCBrZXksIGtleSwgJF9fMik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHZhbHVlczogJHRyYWNldXJSdW50aW1lLmluaXRHZW5lcmF0b3JGdW5jdGlvbihmdW5jdGlvbiAkX18xMigpIHtcbiAgICAgICAgdmFyICRfXzEzLFxuICAgICAgICAgICAgJF9fMTQ7XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UoZnVuY3Rpb24oJGN0eCkge1xuICAgICAgICAgIHdoaWxlICh0cnVlKVxuICAgICAgICAgICAgc3dpdGNoICgkY3R4LnN0YXRlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAkX18xMyA9ICRjdHgud3JhcFlpZWxkU3Rhcih0aGlzLm1hcF8ua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgICAgICAgICAgICAgJGN0eC5zZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICRjdHguYWN0aW9uID0gJ25leHQnO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAkX18xNCA9ICRfXzEzWyRjdHguYWN0aW9uXSgkY3R4LnNlbnRJZ25vcmVUaHJvdyk7XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gKCRfXzE0LmRvbmUpID8gMyA6IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAkY3R4LnNlbnQgPSAkX18xNC52YWx1ZTtcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gLTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRfXzE0LnZhbHVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkY3R4LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAkX18xMiwgdGhpcyk7XG4gICAgICB9KSxcbiAgICAgIGVudHJpZXM6ICR0cmFjZXVyUnVudGltZS5pbml0R2VuZXJhdG9yRnVuY3Rpb24oZnVuY3Rpb24gJF9fMTUoKSB7XG4gICAgICAgIHZhciAkX18xNixcbiAgICAgICAgICAgICRfXzE3O1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLmNyZWF0ZUdlbmVyYXRvckluc3RhbmNlKGZ1bmN0aW9uKCRjdHgpIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSlcbiAgICAgICAgICAgIHN3aXRjaCAoJGN0eC5zdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgJF9fMTYgPSAkY3R4LndyYXBZaWVsZFN0YXIodGhpcy5tYXBfLmVudHJpZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgICAgICAgICAgICAgICRjdHguc2VudCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAkY3R4LmFjdGlvbiA9ICduZXh0JztcbiAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgJF9fMTcgPSAkX18xNlskY3R4LmFjdGlvbl0oJGN0eC5zZW50SWdub3JlVGhyb3cpO1xuICAgICAgICAgICAgICAgICRjdHguc3RhdGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9ICgkX18xNy5kb25lKSA/IDMgOiAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgJGN0eC5zZW50ID0gJF9fMTcudmFsdWU7XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IC0yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiAkX18xNy52YWx1ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJGN0eC5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgJF9fMTUsIHRoaXMpO1xuICAgICAgfSlcbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogU2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCAna2V5cycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IFNldC5wcm90b3R5cGUudmFsdWVzXG4gIH0pO1xuICBmdW5jdGlvbiBuZWVkc1BvbHlmaWxsKGdsb2JhbCkge1xuICAgIHZhciAkX18xMSA9IGdsb2JhbCxcbiAgICAgICAgU2V0ID0gJF9fMTEuU2V0LFxuICAgICAgICBTeW1ib2wgPSAkX18xMS5TeW1ib2w7XG4gICAgaWYgKCFTZXQgfHwgIWhhc05hdGl2ZVN5bWJvbCgpIHx8ICFTZXQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gfHwgIVNldC5wcm90b3R5cGUudmFsdWVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgU2V0KFsxXSkuc2l6ZSAhPT0gMTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvbHlmaWxsU2V0KGdsb2JhbCkge1xuICAgIGlmIChuZWVkc1BvbHlmaWxsKGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbC5TZXQgPSBTZXQ7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxTZXQpO1xuICByZXR1cm4ge1xuICAgIGdldCBTZXQoKSB7XG4gICAgICByZXR1cm4gU2V0O1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsU2V0KCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsU2V0O1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU2V0LmpzXCIgKyAnJyk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvbm9kZV9tb2R1bGVzL3JzdnAvbGliL3JzdnAvYXNhcC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvbm9kZV9tb2R1bGVzL3JzdnAvbGliL3JzdnAvYXNhcC5qc1wiO1xuICB2YXIgbGVuID0gMDtcbiAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gIHZhciB2ZXJ0eE5leHQ7XG4gIGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgICBsZW4gKz0gMjtcbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG4gIHZhciBicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgdmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xuICB2YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICB2YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG4gIHZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG4gIGZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAgIHZhciBuZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUubWF0Y2goL14oPzooXFxkKylcXC4pPyg/OihcXGQrKVxcLik/KFxcKnxcXGQrKSQvKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2ZXJzaW9uKSAmJiB2ZXJzaW9uWzFdID09PSAnMCcgJiYgdmVyc2lvblsyXSA9PT0gJzEwJykge1xuICAgICAgbmV4dFRpY2sgPSBzZXRJbW1lZGlhdGU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmbHVzaCwgMSk7XG4gICAgfTtcbiAgfVxuICB2YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcbiAgICAgIGNhbGxiYWNrKGFyZyk7XG4gICAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGVuID0gMDtcbiAgfVxuICBmdW5jdGlvbiBhdHRlbXB0VmVydGV4KCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNjaGVkdWxlRmx1c2g7XG4gIGlmIChpc05vZGUpIHtcbiAgICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbiAgfSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgfSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnRleCgpO1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBhc2FwO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1Byb21pc2UuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9Qcm9taXNlLmpzXCI7XG4gIHZhciBhc3luYyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcnN2cC9saWIvcnN2cC9hc2FwLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9Qcm9taXNlLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fOSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9Qcm9taXNlLmpzXCIpKSxcbiAgICAgIGlzT2JqZWN0ID0gJF9fOS5pc09iamVjdCxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX185LnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9wcml2YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9Qcm9taXNlLmpzXCIpKSxcbiAgICAgIGNyZWF0ZVByaXZhdGVTeW1ib2wgPSAkX18xMC5jcmVhdGVQcml2YXRlU3ltYm9sLFxuICAgICAgZ2V0UHJpdmF0ZSA9ICRfXzEwLmdldFByaXZhdGUsXG4gICAgICBzZXRQcml2YXRlID0gJF9fMTAuc2V0UHJpdmF0ZTtcbiAgdmFyIHByb21pc2VSYXcgPSB7fTtcbiAgZnVuY3Rpb24gaXNQcm9taXNlKHgpIHtcbiAgICByZXR1cm4geCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeC5zdGF0dXNfICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaWRSZXNvbHZlSGFuZGxlcih4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgZnVuY3Rpb24gaWRSZWplY3RIYW5kbGVyKHgpIHtcbiAgICB0aHJvdyB4O1xuICB9XG4gIGZ1bmN0aW9uIGNoYWluKHByb21pc2UpIHtcbiAgICB2YXIgb25SZXNvbHZlID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IGlkUmVzb2x2ZUhhbmRsZXI7XG4gICAgdmFyIG9uUmVqZWN0ID0gYXJndW1lbnRzWzJdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1syXSA6IGlkUmVqZWN0SGFuZGxlcjtcbiAgICB2YXIgZGVmZXJyZWQgPSBnZXREZWZlcnJlZChwcm9taXNlLmNvbnN0cnVjdG9yKTtcbiAgICBzd2l0Y2ggKHByb21pc2Uuc3RhdHVzXykge1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHRocm93IFR5cGVFcnJvcjtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcHJvbWlzZS5vblJlc29sdmVfLnB1c2gob25SZXNvbHZlLCBkZWZlcnJlZCk7XG4gICAgICAgIHByb21pc2Uub25SZWplY3RfLnB1c2gob25SZWplY3QsIGRlZmVycmVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICsxOlxuICAgICAgICBwcm9taXNlRW5xdWV1ZShwcm9taXNlLnZhbHVlXywgW29uUmVzb2x2ZSwgZGVmZXJyZWRdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBwcm9taXNlRW5xdWV1ZShwcm9taXNlLnZhbHVlXywgW29uUmVqZWN0LCBkZWZlcnJlZF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGVmZXJyZWQoQykge1xuICAgIGlmICh0aGlzID09PSAkUHJvbWlzZSkge1xuICAgICAgdmFyIHByb21pc2UgPSBwcm9taXNlSW5pdChuZXcgJFByb21pc2UocHJvbWlzZVJhdykpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgcmVzb2x2ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHByb21pc2VSZXNvbHZlKHByb21pc2UsIHgpO1xuICAgICAgICB9LFxuICAgICAgICByZWplY3Q6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICBwcm9taXNlUmVqZWN0KHByb21pc2UsIHIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHQucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXN1bHQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHJlc3VsdC5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VTZXQocHJvbWlzZSwgc3RhdHVzLCB2YWx1ZSwgb25SZXNvbHZlLCBvblJlamVjdCkge1xuICAgIHByb21pc2Uuc3RhdHVzXyA9IHN0YXR1cztcbiAgICBwcm9taXNlLnZhbHVlXyA9IHZhbHVlO1xuICAgIHByb21pc2Uub25SZXNvbHZlXyA9IG9uUmVzb2x2ZTtcbiAgICBwcm9taXNlLm9uUmVqZWN0XyA9IG9uUmVqZWN0O1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VJbml0KHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVNldChwcm9taXNlLCAwLCB1bmRlZmluZWQsIFtdLCBbXSk7XG4gIH1cbiAgdmFyIFByb21pc2UgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICBpZiAocmVzb2x2ZXIgPT09IHByb21pc2VSYXcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VJbml0KHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHByb21pc2VSZXNvbHZlKHByb21pc2UsIHgpO1xuICAgICAgICB9LCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcHJvbWlzZVJlamVjdChwcm9taXNlLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQcm9taXNlLCB7XG4gICAgICBjYXRjaDogZnVuY3Rpb24ob25SZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0KTtcbiAgICAgIH0sXG4gICAgICB0aGVuOiBmdW5jdGlvbihvblJlc29sdmUsIG9uUmVqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG9uUmVzb2x2ZSA9IGlkUmVzb2x2ZUhhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgb25SZWplY3QgPSBpZFJlamVjdEhhbmRsZXI7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIGNoYWluKHRoaXMsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB4ID0gcHJvbWlzZUNvZXJjZShjb25zdHJ1Y3RvciwgeCk7XG4gICAgICAgICAgcmV0dXJuIHggPT09IHRoYXQgPyBvblJlamVjdChuZXcgVHlwZUVycm9yKSA6IGlzUHJvbWlzZSh4KSA/IHgudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KSA6IG9uUmVzb2x2ZSh4KTtcbiAgICAgICAgfSwgb25SZWplY3QpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHJlc29sdmU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09ICRQcm9taXNlKSB7XG4gICAgICAgICAgaWYgKGlzUHJvbWlzZSh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlU2V0KG5ldyAkUHJvbWlzZShwcm9taXNlUmF3KSwgKzEsIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWplY3Q6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09ICRQcm9taXNlKSB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2VTZXQobmV3ICRQcm9taXNlKHByb21pc2VSYXcpLCAtMSwgcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVqZWN0KHIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxsOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZ2V0RGVmZXJyZWQodGhpcyk7XG4gICAgICAgIHZhciByZXNvbHV0aW9ucyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBtYWtlQ291bnRkb3duRnVuY3Rpb24gPSBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICByZXNvbHV0aW9uc1tpXSA9IHg7XG4gICAgICAgICAgICAgIGlmICgtLWNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzb2x1dGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciAkX180ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgJF9fNSA9IGZhbHNlO1xuICAgICAgICAgIHZhciAkX182ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciAkX18yID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgICRfXzEgPSAodmFsdWVzKVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoJF9fNCA9ICgkX18yID0gJF9fMS5uZXh0KCkpLmRvbmUpOyAkX180ID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAkX18yLnZhbHVlO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ZG93bkZ1bmN0aW9uID0gbWFrZUNvdW50ZG93bkZ1bmN0aW9uKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSkudGhlbihjb3VudGRvd25GdW5jdGlvbiwgZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoJF9fNykge1xuICAgICAgICAgICAgJF9fNSA9IHRydWU7XG4gICAgICAgICAgICAkX182ID0gJF9fNztcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCEkX180ICYmICRfXzEucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkX18xLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoJF9fNSkge1xuICAgICAgICAgICAgICAgIHRocm93ICRfXzY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc29sdXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcmFjZTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGdldERlZmVycmVkKHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWVzW2ldKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh4KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KCk7XG4gIHZhciAkUHJvbWlzZSA9IFByb21pc2U7XG4gIHZhciAkUHJvbWlzZVJlamVjdCA9ICRQcm9taXNlLnJlamVjdDtcbiAgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmUocHJvbWlzZSwgeCkge1xuICAgIHByb21pc2VEb25lKHByb21pc2UsICsxLCB4LCBwcm9taXNlLm9uUmVzb2x2ZV8pO1xuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VSZWplY3QocHJvbWlzZSwgcikge1xuICAgIHByb21pc2VEb25lKHByb21pc2UsIC0xLCByLCBwcm9taXNlLm9uUmVqZWN0Xyk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvbWlzZURvbmUocHJvbWlzZSwgc3RhdHVzLCB2YWx1ZSwgcmVhY3Rpb25zKSB7XG4gICAgaWYgKHByb21pc2Uuc3RhdHVzXyAhPT0gMClcbiAgICAgIHJldHVybjtcbiAgICBwcm9taXNlRW5xdWV1ZSh2YWx1ZSwgcmVhY3Rpb25zKTtcbiAgICBwcm9taXNlU2V0KHByb21pc2UsIHN0YXR1cywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHByb21pc2VFbnF1ZXVlKHZhbHVlLCB0YXNrcykge1xuICAgIGFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXNrcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9taXNlSGFuZGxlKHZhbHVlLCB0YXNrc1tpXSwgdGFza3NbaSArIDFdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcm9taXNlSGFuZGxlKHZhbHVlLCBoYW5kbGVyLCBkZWZlcnJlZCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBkZWZlcnJlZC5wcm9taXNlKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgZWxzZSBpZiAoaXNQcm9taXNlKHJlc3VsdCkpXG4gICAgICAgIGNoYWluKHJlc3VsdCwgZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG4gIHZhciB0aGVuYWJsZVN5bWJvbCA9IGNyZWF0ZVByaXZhdGVTeW1ib2woKTtcbiAgZnVuY3Rpb24gcHJvbWlzZUNvZXJjZShjb25zdHJ1Y3RvciwgeCkge1xuICAgIGlmICghaXNQcm9taXNlKHgpICYmIGlzT2JqZWN0KHgpKSB7XG4gICAgICB2YXIgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoZW4gPSB4LnRoZW47XG4gICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gJFByb21pc2VSZWplY3QuY2FsbChjb25zdHJ1Y3Rvciwgcik7XG4gICAgICAgIHNldFByaXZhdGUoeCwgdGhlbmFibGVTeW1ib2wsIHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcCA9IGdldFByaXZhdGUoeCwgdGhlbmFibGVTeW1ib2wpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkZWZlcnJlZCA9IGdldERlZmVycmVkKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgICBzZXRQcml2YXRlKHgsIHRoZW5hYmxlU3ltYm9sLCBkZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHgsIGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBwb2x5ZmlsbFByb21pc2UoZ2xvYmFsKSB7XG4gICAgaWYgKCFnbG9iYWwuUHJvbWlzZSlcbiAgICAgIGdsb2JhbC5Qcm9taXNlID0gUHJvbWlzZTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsUHJvbWlzZSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IFByb21pc2UoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICB9LFxuICAgIGdldCBwb2x5ZmlsbFByb21pc2UoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxQcm9taXNlO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvUHJvbWlzZS5qc1wiICsgJycpO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9TdHJpbmdJdGVyYXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZ0l0ZXJhdG9yLmpzXCI7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZ0l0ZXJhdG9yLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUl0ZXJhdG9yUmVzdWx0T2JqZWN0ID0gJF9fMy5jcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCxcbiAgICAgIGlzT2JqZWN0ID0gJF9fMy5pc09iamVjdDtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGl0ZXJhdGVkU3RyaW5nID0gU3ltYm9sKCdpdGVyYXRlZFN0cmluZycpO1xuICB2YXIgc3RyaW5nSXRlcmF0b3JOZXh0SW5kZXggPSBTeW1ib2woJ3N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4Jyk7XG4gIHZhciBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciAkX18xO1xuICAgIGZ1bmN0aW9uIFN0cmluZ0l0ZXJhdG9yKCkge31cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3RyaW5nSXRlcmF0b3IsICgkX18xID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18xLCBcIm5leHRcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNPYmplY3QobykgfHwgIWhhc093blByb3BlcnR5LmNhbGwobywgaXRlcmF0ZWRTdHJpbmcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBtdXN0IGJlIGEgU3RyaW5nSXRlcmF0b3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBvW2l0ZXJhdGVkU3RyaW5nXTtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9bc3RyaW5nSXRlcmF0b3JOZXh0SW5kZXhdO1xuICAgICAgICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBsZW4pIHtcbiAgICAgICAgICBvW2l0ZXJhdGVkU3RyaW5nXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBzLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nO1xuICAgICAgICBpZiAoZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBsZW4pIHtcbiAgICAgICAgICByZXN1bHRTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGZpcnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2Vjb25kID0gcy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgaWYgKHNlY29uZCA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZmlyc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGZpcnN0KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoc2Vjb25kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb1tzdHJpbmdJdGVyYXRvck5leHRJbmRleF0gPSBwb3NpdGlvbiArIHJlc3VsdFN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdChyZXN1bHRTdHJpbmcsIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KCRfXzEsIFN5bWJvbC5pdGVyYXRvciwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KSwgJF9fMSksIHt9KTtcbiAgfSgpO1xuICBmdW5jdGlvbiBjcmVhdGVTdHJpbmdJdGVyYXRvcihzdHJpbmcpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhzdHJpbmcpO1xuICAgIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgICBpdGVyYXRvcltpdGVyYXRlZFN0cmluZ10gPSBzO1xuICAgIGl0ZXJhdG9yW3N0cmluZ0l0ZXJhdG9yTmV4dEluZGV4XSA9IDA7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiB7Z2V0IGNyZWF0ZVN0cmluZ0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0l0ZXJhdG9yO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiO1xuICB2YXIgY2hlY2tPYmplY3RDb2VyY2libGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY2hlY2tPYmplY3RDb2VyY2libGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIGNyZWF0ZVN0cmluZ0l0ZXJhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RyaW5nSXRlcmF0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiKSkuY3JlYXRlU3RyaW5nSXRlcmF0b3I7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1N0cmluZy5qc1wiKSksXG4gICAgICBtYXliZUFkZEZ1bmN0aW9ucyA9ICRfXzMubWF5YmVBZGRGdW5jdGlvbnMsXG4gICAgICBtYXliZUFkZEl0ZXJhdG9yID0gJF9fMy5tYXliZUFkZEl0ZXJhdG9yLFxuICAgICAgcmVnaXN0ZXJQb2x5ZmlsbCA9ICRfXzMucmVnaXN0ZXJQb2x5ZmlsbDtcbiAgdmFyICR0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciAkaW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZjtcbiAgdmFyICRsYXN0SW5kZXhPZiA9IFN0cmluZy5wcm90b3R5cGUubGFzdEluZGV4T2Y7XG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICBpZiAodGhpcyA9PSBudWxsIHx8ICR0b1N0cmluZy5jYWxsKHNlYXJjaCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG4gICAgaWYgKGlzTmFOKHBvcykpIHtcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XG4gICAgcmV0dXJuICRpbmRleE9mLmNhbGwoc3RyaW5nLCBzZWFyY2hTdHJpbmcsIHBvcykgPT0gc3RhcnQ7XG4gIH1cbiAgZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICBpZiAodGhpcyA9PSBudWxsIHx8ICR0b1N0cmluZy5jYWxsKHNlYXJjaCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IHN0cmluZ0xlbmd0aDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvcyA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG4gICAgICAgIGlmIChpc05hTihwb3MpKSB7XG4gICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZW5kID0gTWF0aC5taW4oTWF0aC5tYXgocG9zLCAwKSwgc3RyaW5nTGVuZ3RoKTtcbiAgICB2YXIgc3RhcnQgPSBlbmQgLSBzZWFyY2hMZW5ndGg7XG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gJGxhc3RJbmRleE9mLmNhbGwoc3RyaW5nLCBzZWFyY2hTdHJpbmcsIHN0YXJ0KSA9PSBzdGFydDtcbiAgfVxuICBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2gpIHtcbiAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICBpZiAoc2VhcmNoICYmICR0b1N0cmluZy5jYWxsKHNlYXJjaCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgdmFyIHNlYXJjaExlbmd0aCA9IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG4gICAgaWYgKHBvcyAhPSBwb3MpIHtcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XG4gICAgaWYgKHNlYXJjaExlbmd0aCArIHN0YXJ0ID4gc3RyaW5nTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAkaW5kZXhPZi5jYWxsKHN0cmluZywgc2VhcmNoU3RyaW5nLCBwb3MpICE9IC0xO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgIH1cbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgIHZhciBuID0gY291bnQgPyBOdW1iZXIoY291bnQpIDogMDtcbiAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgIG4gPSAwO1xuICAgIH1cbiAgICBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICAgIH1cbiAgICBpZiAobiA9PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAobi0tKSB7XG4gICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgdmFyIHNpemUgPSBzdHJpbmcubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG4gICAgaWYgKGlzTmFOKGluZGV4KSkge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgc2Vjb25kO1xuICAgIGlmIChmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIHNpemUgPiBpbmRleCArIDEpIHtcbiAgICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH1cbiAgZnVuY3Rpb24gcmF3KGNhbGxzaXRlKSB7XG4gICAgdmFyIHJhdyA9IGNhbGxzaXRlLnJhdztcbiAgICB2YXIgbGVuID0gcmF3Lmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAobGVuID09PSAwKVxuICAgICAgcmV0dXJuICcnO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzICs9IHJhd1tpXTtcbiAgICAgIGlmIChpICsgMSA9PT0gbGVuKVxuICAgICAgICByZXR1cm4gcztcbiAgICAgIHMgKz0gYXJndW1lbnRzWysraV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoXykge1xuICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgIHZhciBsb3dTdXJyb2dhdGU7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICBpZiAoIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgY29kZVBvaW50IDwgMCB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCBmbG9vcihjb2RlUG9pbnQpICE9IGNvZGVQb2ludCkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICBoaWdoU3Vycm9nYXRlID0gKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDA7XG4gICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nUHJvdG90eXBlSXRlcmF0b3IoKSB7XG4gICAgdmFyIG8gPSBjaGVja09iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICB2YXIgcyA9IFN0cmluZyhvKTtcbiAgICByZXR1cm4gY3JlYXRlU3RyaW5nSXRlcmF0b3Iocyk7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxTdHJpbmcoZ2xvYmFsKSB7XG4gICAgdmFyIFN0cmluZyA9IGdsb2JhbC5TdHJpbmc7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoU3RyaW5nLnByb3RvdHlwZSwgWydjb2RlUG9pbnRBdCcsIGNvZGVQb2ludEF0LCAnZW5kc1dpdGgnLCBlbmRzV2l0aCwgJ2luY2x1ZGVzJywgaW5jbHVkZXMsICdyZXBlYXQnLCByZXBlYXQsICdzdGFydHNXaXRoJywgc3RhcnRzV2l0aF0pO1xuICAgIG1heWJlQWRkRnVuY3Rpb25zKFN0cmluZywgWydmcm9tQ29kZVBvaW50JywgZnJvbUNvZGVQb2ludCwgJ3JhdycsIHJhd10pO1xuICAgIG1heWJlQWRkSXRlcmF0b3IoU3RyaW5nLnByb3RvdHlwZSwgc3RyaW5nUHJvdG90eXBlSXRlcmF0b3IsIFN5bWJvbCk7XG4gIH1cbiAgcmVnaXN0ZXJQb2x5ZmlsbChwb2x5ZmlsbFN0cmluZyk7XG4gIHJldHVybiB7XG4gICAgZ2V0IHN0YXJ0c1dpdGgoKSB7XG4gICAgICByZXR1cm4gc3RhcnRzV2l0aDtcbiAgICB9LFxuICAgIGdldCBlbmRzV2l0aCgpIHtcbiAgICAgIHJldHVybiBlbmRzV2l0aDtcbiAgICB9LFxuICAgIGdldCBpbmNsdWRlcygpIHtcbiAgICAgIHJldHVybiBpbmNsdWRlcztcbiAgICB9LFxuICAgIGdldCByZXBlYXQoKSB7XG4gICAgICByZXR1cm4gcmVwZWF0O1xuICAgIH0sXG4gICAgZ2V0IGNvZGVQb2ludEF0KCkge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludEF0O1xuICAgIH0sXG4gICAgZ2V0IHJhdygpIHtcbiAgICAgIHJldHVybiByYXc7XG4gICAgfSxcbiAgICBnZXQgZnJvbUNvZGVQb2ludCgpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50O1xuICAgIH0sXG4gICAgZ2V0IHN0cmluZ1Byb3RvdHlwZUl0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1Byb3RvdHlwZUl0ZXJhdG9yO1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsU3RyaW5nO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvU3RyaW5nLmpzXCIgKyAnJyk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5SXRlcmF0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9BcnJheUl0ZXJhdG9yLmpzXCI7XG4gIHZhciAkX18yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5SXRlcmF0b3IuanNcIikpLFxuICAgICAgdG9PYmplY3QgPSAkX18yLnRvT2JqZWN0LFxuICAgICAgdG9VaW50MzIgPSAkX18yLnRvVWludDMyLFxuICAgICAgY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QgPSAkX18yLmNyZWF0ZUl0ZXJhdG9yUmVzdWx0T2JqZWN0O1xuICB2YXIgQVJSQVlfSVRFUkFUT1JfS0lORF9LRVlTID0gMTtcbiAgdmFyIEFSUkFZX0lURVJBVE9SX0tJTkRfVkFMVUVTID0gMjtcbiAgdmFyIEFSUkFZX0lURVJBVE9SX0tJTkRfRU5UUklFUyA9IDM7XG4gIHZhciBBcnJheUl0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyICRfXzE7XG4gICAgZnVuY3Rpb24gQXJyYXlJdGVyYXRvcigpIHt9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycmF5SXRlcmF0b3IsICgkX18xID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18xLCBcIm5leHRcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0b09iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGFycmF5ID0gaXRlcmF0b3IuaXRlcmF0b3JPYmplY3RfO1xuICAgICAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IGlzIG5vdCBhbiBBcnJheUl0ZXJhdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gaXRlcmF0b3IuYXJyYXlJdGVyYXRvck5leHRJbmRleF87XG4gICAgICAgIHZhciBpdGVtS2luZCA9IGl0ZXJhdG9yLmFycmF5SXRlcmF0aW9uS2luZF87XG4gICAgICAgIHZhciBsZW5ndGggPSB0b1VpbnQzMihhcnJheS5sZW5ndGgpO1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgaXRlcmF0b3IuYXJyYXlJdGVyYXRvck5leHRJbmRleF8gPSBJbmZpbml0eTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvci5hcnJheUl0ZXJhdG9yTmV4dEluZGV4XyA9IGluZGV4ICsgMTtcbiAgICAgICAgaWYgKGl0ZW1LaW5kID09IEFSUkFZX0lURVJBVE9SX0tJTkRfVkFMVUVTKVxuICAgICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdChhcnJheVtpbmRleF0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGl0ZW1LaW5kID09IEFSUkFZX0lURVJBVE9SX0tJTkRfRU5UUklFUylcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3JSZXN1bHRPYmplY3QoW2luZGV4LCBhcnJheVtpbmRleF1dLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyYXRvclJlc3VsdE9iamVjdChpbmRleCwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoJF9fMSwgU3ltYm9sLml0ZXJhdG9yLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pLCAkX18xKSwge30pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoYXJyYXksIGtpbmQpIHtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoYXJyYXkpO1xuICAgIHZhciBpdGVyYXRvciA9IG5ldyBBcnJheUl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yLml0ZXJhdG9yT2JqZWN0XyA9IG9iamVjdDtcbiAgICBpdGVyYXRvci5hcnJheUl0ZXJhdG9yTmV4dEluZGV4XyA9IDA7XG4gICAgaXRlcmF0b3IuYXJyYXlJdGVyYXRpb25LaW5kXyA9IGtpbmQ7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9XG4gIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IodGhpcywgQVJSQVlfSVRFUkFUT1JfS0lORF9FTlRSSUVTKTtcbiAgfVxuICBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKHRoaXMsIEFSUkFZX0lURVJBVE9SX0tJTkRfS0VZUyk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKHRoaXMsIEFSUkFZX0lURVJBVE9SX0tJTkRfVkFMVUVTKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSxcbiAgICBnZXQga2V5cygpIHtcbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sXG4gICAgZ2V0IHZhbHVlcygpIHtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvQXJyYXkuanNcIjtcbiAgdmFyICRfXzkgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9BcnJheUl0ZXJhdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9BcnJheS5qc1wiKSksXG4gICAgICBlbnRyaWVzID0gJF9fOS5lbnRyaWVzLFxuICAgICAga2V5cyA9ICRfXzkua2V5cyxcbiAgICAgIGpzVmFsdWVzID0gJF9fOS52YWx1ZXM7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9BcnJheS5qc1wiKSksXG4gICAgICBjaGVja0l0ZXJhYmxlID0gJF9fMTAuY2hlY2tJdGVyYWJsZSxcbiAgICAgIGlzQ2FsbGFibGUgPSAkX18xMC5pc0NhbGxhYmxlLFxuICAgICAgaXNDb25zdHJ1Y3RvciA9ICRfXzEwLmlzQ29uc3RydWN0b3IsXG4gICAgICBtYXliZUFkZEZ1bmN0aW9ucyA9ICRfXzEwLm1heWJlQWRkRnVuY3Rpb25zLFxuICAgICAgbWF5YmVBZGRJdGVyYXRvciA9ICRfXzEwLm1heWJlQWRkSXRlcmF0b3IsXG4gICAgICByZWdpc3RlclBvbHlmaWxsID0gJF9fMTAucmVnaXN0ZXJQb2x5ZmlsbCxcbiAgICAgIHRvSW50ZWdlciA9ICRfXzEwLnRvSW50ZWdlcixcbiAgICAgIHRvTGVuZ3RoID0gJF9fMTAudG9MZW5ndGgsXG4gICAgICB0b09iamVjdCA9ICRfXzEwLnRvT2JqZWN0O1xuICBmdW5jdGlvbiBmcm9tKGFyckxpa2UpIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBpdGVtcyA9IHRvT2JqZWN0KGFyckxpa2UpO1xuICAgIHZhciBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgayA9IDA7XG4gICAgdmFyIGFycixcbiAgICAgICAgbGVuO1xuICAgIGlmIChtYXBwaW5nICYmICFpc0NhbGxhYmxlKG1hcEZuKSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIGlmIChjaGVja0l0ZXJhYmxlKGl0ZW1zKSkge1xuICAgICAgYXJyID0gaXNDb25zdHJ1Y3RvcihDKSA/IG5ldyBDKCkgOiBbXTtcbiAgICAgIHZhciAkX18zID0gdHJ1ZTtcbiAgICAgIHZhciAkX180ID0gZmFsc2U7XG4gICAgICB2YXIgJF9fNSA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyICRfXzEgPSB2b2lkIDAsXG4gICAgICAgICAgICAkX18wID0gKGl0ZW1zKVtTeW1ib2wuaXRlcmF0b3JdKCk7ICEoJF9fMyA9ICgkX18xID0gJF9fMC5uZXh0KCkpLmRvbmUpOyAkX18zID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBpdGVtID0gJF9fMS52YWx1ZTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgICAgICBhcnJba10gPSBtYXBGbi5jYWxsKHRoaXNBcmcsIGl0ZW0sIGspO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJyW2tdID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKCRfXzYpIHtcbiAgICAgICAgJF9fNCA9IHRydWU7XG4gICAgICAgICRfXzUgPSAkX182O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoISRfXzMgJiYgJF9fMC5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgJF9fMC5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKCRfXzQpIHtcbiAgICAgICAgICAgIHRocm93ICRfXzU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcnIubGVuZ3RoID0gaztcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGxlbiA9IHRvTGVuZ3RoKGl0ZW1zLmxlbmd0aCk7XG4gICAgYXJyID0gaXNDb25zdHJ1Y3RvcihDKSA/IG5ldyBDKGxlbikgOiBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBpZiAobWFwcGluZykge1xuICAgICAgICBhcnJba10gPSB0eXBlb2YgdGhpc0FyZyA9PT0gJ3VuZGVmaW5lZCcgPyBtYXBGbihpdGVtc1trXSwgaykgOiBtYXBGbi5jYWxsKHRoaXNBcmcsIGl0ZW1zW2tdLCBrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycltrXSA9IGl0ZW1zW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgZnVuY3Rpb24gb2YoKSB7XG4gICAgZm9yICh2YXIgaXRlbXMgPSBbXSxcbiAgICAgICAgJF9fNyA9IDA7ICRfXzcgPCBhcmd1bWVudHMubGVuZ3RoOyAkX183KyspXG4gICAgICBpdGVtc1skX183XSA9IGFyZ3VtZW50c1skX183XTtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgYXJyID0gaXNDb25zdHJ1Y3RvcihDKSA/IG5ldyBDKGxlbikgOiBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxlbjsgaysrKSB7XG4gICAgICBhcnJba10gPSBpdGVtc1trXTtcbiAgICB9XG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGZ1bmN0aW9uIGZpbGwodmFsdWUpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgob2JqZWN0Lmxlbmd0aCk7XG4gICAgdmFyIGZpbGxTdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgdmFyIGZpbGxFbmQgPSBlbmQgIT09IHVuZGVmaW5lZCA/IHRvSW50ZWdlcihlbmQpIDogbGVuO1xuICAgIGZpbGxTdGFydCA9IGZpbGxTdGFydCA8IDAgPyBNYXRoLm1heChsZW4gKyBmaWxsU3RhcnQsIDApIDogTWF0aC5taW4oZmlsbFN0YXJ0LCBsZW4pO1xuICAgIGZpbGxFbmQgPSBmaWxsRW5kIDwgMCA/IE1hdGgubWF4KGxlbiArIGZpbGxFbmQsIDApIDogTWF0aC5taW4oZmlsbEVuZCwgbGVuKTtcbiAgICB3aGlsZSAoZmlsbFN0YXJ0IDwgZmlsbEVuZCkge1xuICAgICAgb2JqZWN0W2ZpbGxTdGFydF0gPSB2YWx1ZTtcbiAgICAgIGZpbGxTdGFydCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlKSB7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGZpbmRIZWxwZXIodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGZpbmRIZWxwZXIodGhpcywgcHJlZGljYXRlLCB0aGlzQXJnLCB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kSGVscGVyKHNlbGYsIHByZWRpY2F0ZSkge1xuICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByZXR1cm5JbmRleCA9IGFyZ3VtZW50c1szXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3Qoc2VsZik7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKG9iamVjdC5sZW5ndGgpO1xuICAgIGlmICghaXNDYWxsYWJsZShwcmVkaWNhdGUpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5JbmRleCA/IGkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkluZGV4ID8gLTEgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxBcnJheShnbG9iYWwpIHtcbiAgICB2YXIgJF9fOCA9IGdsb2JhbCxcbiAgICAgICAgQXJyYXkgPSAkX184LkFycmF5LFxuICAgICAgICBPYmplY3QgPSAkX184Lk9iamVjdCxcbiAgICAgICAgU3ltYm9sID0gJF9fOC5TeW1ib2w7XG4gICAgdmFyIHZhbHVlcyA9IGpzVmFsdWVzO1xuICAgIGlmIChTeW1ib2wgJiYgU3ltYm9sLml0ZXJhdG9yICYmIEFycmF5LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICB9XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoQXJyYXkucHJvdG90eXBlLCBbJ2VudHJpZXMnLCBlbnRyaWVzLCAna2V5cycsIGtleXMsICd2YWx1ZXMnLCB2YWx1ZXMsICdmaWxsJywgZmlsbCwgJ2ZpbmQnLCBmaW5kLCAnZmluZEluZGV4JywgZmluZEluZGV4XSk7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoQXJyYXksIFsnZnJvbScsIGZyb20sICdvZicsIG9mXSk7XG4gICAgbWF5YmVBZGRJdGVyYXRvcihBcnJheS5wcm90b3R5cGUsIHZhbHVlcywgU3ltYm9sKTtcbiAgICBtYXliZUFkZEl0ZXJhdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXS52YWx1ZXMoKSksIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgU3ltYm9sKTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsQXJyYXkpO1xuICByZXR1cm4ge1xuICAgIGdldCBmcm9tKCkge1xuICAgICAgcmV0dXJuIGZyb207XG4gICAgfSxcbiAgICBnZXQgb2YoKSB7XG4gICAgICByZXR1cm4gb2Y7XG4gICAgfSxcbiAgICBnZXQgZmlsbCgpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH0sXG4gICAgZ2V0IGZpbmQoKSB7XG4gICAgICByZXR1cm4gZmluZDtcbiAgICB9LFxuICAgIGdldCBmaW5kSW5kZXgoKSB7XG4gICAgICByZXR1cm4gZmluZEluZGV4O1xuICAgIH0sXG4gICAgZ2V0IHBvbHlmaWxsQXJyYXkoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxBcnJheTtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL0FycmF5LmpzXCIgKyAnJyk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL2Fzc2lnbi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL2Fzc2lnbi5qc1wiO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuICBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YXIgcHJvcHMgPSBzb3VyY2UgPT0gbnVsbCA/IFtdIDoga2V5cyhzb3VyY2UpO1xuICAgICAgdmFyIHAgPSB2b2lkIDAsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgZm9yIChwID0gMDsgcCA8IGxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcHNbcF07XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIGFzc2lnbjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9PYmplY3QuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9PYmplY3QuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91dGlscy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvT2JqZWN0LmpzXCIpKSxcbiAgICAgIG1heWJlQWRkRnVuY3Rpb25zID0gJF9fMi5tYXliZUFkZEZ1bmN0aW9ucyxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX18yLnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciBhc3NpZ24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hc3NpZ24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL09iamVjdC5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyICRfXzAgPSBPYmplY3QsXG4gICAgICBkZWZpbmVQcm9wZXJ0eSA9ICRfXzAuZGVmaW5lUHJvcGVydHksXG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAkX18wLmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgIGdldE93blByb3BlcnR5TmFtZXMgPSAkX18wLmdldE93blByb3BlcnR5TmFtZXM7XG4gIGZ1bmN0aW9uIGlzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KVxuICAgICAgcmV0dXJuIGxlZnQgIT09IDAgfHwgMSAvIGxlZnQgPT09IDEgLyByaWdodDtcbiAgICByZXR1cm4gbGVmdCAhPT0gbGVmdCAmJiByaWdodCAhPT0gcmlnaHQ7XG4gIH1cbiAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSk7XG4gICAgdmFyIHAsXG4gICAgICAgIGRlc2NyaXB0b3IsXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICBmb3IgKHAgPSAwOyBwIDwgbGVuZ3RoOyBwKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHNbcF07XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgcHJvcHNbcF0pO1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wc1twXSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxPYmplY3QoZ2xvYmFsKSB7XG4gICAgdmFyIE9iamVjdCA9IGdsb2JhbC5PYmplY3Q7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoT2JqZWN0LCBbJ2Fzc2lnbicsIGFzc2lnbiwgJ2lzJywgaXMsICdtaXhpbicsIG1peGluXSk7XG4gIH1cbiAgcmVnaXN0ZXJQb2x5ZmlsbChwb2x5ZmlsbE9iamVjdCk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGFzc2lnbigpIHtcbiAgICAgIHJldHVybiBhc3NpZ247XG4gICAgfSxcbiAgICBnZXQgaXMoKSB7XG4gICAgICByZXR1cm4gaXM7XG4gICAgfSxcbiAgICBnZXQgbWl4aW4oKSB7XG4gICAgICByZXR1cm4gbWl4aW47XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxPYmplY3QoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxPYmplY3Q7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9PYmplY3QuanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTnVtYmVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTnVtYmVyLmpzXCI7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL051bWJlci5qc1wiKSksXG4gICAgICBpc051bWJlciA9ICRfXzEuaXNOdW1iZXIsXG4gICAgICBtYXliZUFkZENvbnN0cyA9ICRfXzEubWF5YmVBZGRDb25zdHMsXG4gICAgICBtYXliZUFkZEZ1bmN0aW9ucyA9ICRfXzEubWF5YmVBZGRGdW5jdGlvbnMsXG4gICAgICByZWdpc3RlclBvbHlmaWxsID0gJF9fMS5yZWdpc3RlclBvbHlmaWxsLFxuICAgICAgdG9JbnRlZ2VyID0gJF9fMS50b0ludGVnZXI7XG4gIHZhciAkYWJzID0gTWF0aC5hYnM7XG4gIHZhciAkaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgdmFyICRpc05hTiA9IGlzTmFOO1xuICB2YXIgTUFYX1NBRkVfSU5URUdFUiA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBNSU5fU0FGRV9JTlRFR0VSID0gLU1hdGgucG93KDIsIDUzKSArIDE7XG4gIHZhciBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbiAgZnVuY3Rpb24gTnVtYmVySXNGaW5pdGUobnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG51bWJlcikgJiYgJGlzRmluaXRlKG51bWJlcik7XG4gIH1cbiAgZnVuY3Rpb24gaXNJbnRlZ2VyKG51bWJlcikge1xuICAgIHJldHVybiBOdW1iZXJJc0Zpbml0ZShudW1iZXIpICYmIHRvSW50ZWdlcihudW1iZXIpID09PSBudW1iZXI7XG4gIH1cbiAgZnVuY3Rpb24gTnVtYmVySXNOYU4obnVtYmVyKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKG51bWJlcikgJiYgJGlzTmFOKG51bWJlcik7XG4gIH1cbiAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICBpZiAoTnVtYmVySXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgdmFyIGludGVncmFsID0gdG9JbnRlZ2VyKG51bWJlcik7XG4gICAgICBpZiAoaW50ZWdyYWwgPT09IG51bWJlcilcbiAgICAgICAgcmV0dXJuICRhYnMoaW50ZWdyYWwpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBwb2x5ZmlsbE51bWJlcihnbG9iYWwpIHtcbiAgICB2YXIgTnVtYmVyID0gZ2xvYmFsLk51bWJlcjtcbiAgICBtYXliZUFkZENvbnN0cyhOdW1iZXIsIFsnTUFYX1NBRkVfSU5URUdFUicsIE1BWF9TQUZFX0lOVEVHRVIsICdNSU5fU0FGRV9JTlRFR0VSJywgTUlOX1NBRkVfSU5URUdFUiwgJ0VQU0lMT04nLCBFUFNJTE9OXSk7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoTnVtYmVyLCBbJ2lzRmluaXRlJywgTnVtYmVySXNGaW5pdGUsICdpc0ludGVnZXInLCBpc0ludGVnZXIsICdpc05hTicsIE51bWJlcklzTmFOLCAnaXNTYWZlSW50ZWdlcicsIGlzU2FmZUludGVnZXJdKTtcbiAgfVxuICByZWdpc3RlclBvbHlmaWxsKHBvbHlmaWxsTnVtYmVyKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgTUFYX1NBRkVfSU5URUdFUigpIHtcbiAgICAgIHJldHVybiBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH0sXG4gICAgZ2V0IE1JTl9TQUZFX0lOVEVHRVIoKSB7XG4gICAgICByZXR1cm4gTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9LFxuICAgIGdldCBFUFNJTE9OKCkge1xuICAgICAgcmV0dXJuIEVQU0lMT047XG4gICAgfSxcbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICByZXR1cm4gTnVtYmVySXNGaW5pdGU7XG4gICAgfSxcbiAgICBnZXQgaXNJbnRlZ2VyKCkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcjtcbiAgICB9LFxuICAgIGdldCBpc05hTigpIHtcbiAgICAgIHJldHVybiBOdW1iZXJJc05hTjtcbiAgICB9LFxuICAgIGdldCBpc1NhZmVJbnRlZ2VyKCkge1xuICAgICAgcmV0dXJuIGlzU2FmZUludGVnZXI7XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxOdW1iZXIoKSB7XG4gICAgICByZXR1cm4gcG9seWZpbGxOdW1iZXI7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9OdW1iZXIuanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvZnJvdW5kLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvZnJvdW5kLmpzXCI7XG4gIHZhciAkaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgdmFyICRpc05hTiA9IGlzTmFOO1xuICB2YXIgJF9fMCA9IE1hdGgsXG4gICAgICBMTjIgPSAkX18wLkxOMixcbiAgICAgIGFicyA9ICRfXzAuYWJzLFxuICAgICAgZmxvb3IgPSAkX18wLmZsb29yLFxuICAgICAgbG9nID0gJF9fMC5sb2csXG4gICAgICBtaW4gPSAkX18wLm1pbixcbiAgICAgIHBvdyA9ICRfXzAucG93O1xuICBmdW5jdGlvbiBwYWNrSUVFRTc1NCh2LCBlYml0cywgZmJpdHMpIHtcbiAgICB2YXIgYmlhcyA9ICgxIDw8IChlYml0cyAtIDEpKSAtIDEsXG4gICAgICAgIHMsXG4gICAgICAgIGUsXG4gICAgICAgIGYsXG4gICAgICAgIGxuLFxuICAgICAgICBpLFxuICAgICAgICBiaXRzLFxuICAgICAgICBzdHIsXG4gICAgICAgIGJ5dGVzO1xuICAgIGZ1bmN0aW9uIHJvdW5kVG9FdmVuKG4pIHtcbiAgICAgIHZhciB3ID0gZmxvb3IobiksXG4gICAgICAgICAgZiA9IG4gLSB3O1xuICAgICAgaWYgKGYgPCAwLjUpXG4gICAgICAgIHJldHVybiB3O1xuICAgICAgaWYgKGYgPiAwLjUpXG4gICAgICAgIHJldHVybiB3ICsgMTtcbiAgICAgIHJldHVybiB3ICUgMiA/IHcgKyAxIDogdztcbiAgICB9XG4gICAgaWYgKHYgIT09IHYpIHtcbiAgICAgIGUgPSAoMSA8PCBlYml0cykgLSAxO1xuICAgICAgZiA9IHBvdygyLCBmYml0cyAtIDEpO1xuICAgICAgcyA9IDA7XG4gICAgfSBlbHNlIGlmICh2ID09PSBJbmZpbml0eSB8fCB2ID09PSAtSW5maW5pdHkpIHtcbiAgICAgIGUgPSAoMSA8PCBlYml0cykgLSAxO1xuICAgICAgZiA9IDA7XG4gICAgICBzID0gKHYgPCAwKSA/IDEgOiAwO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gMCkge1xuICAgICAgZSA9IDA7XG4gICAgICBmID0gMDtcbiAgICAgIHMgPSAoMSAvIHYgPT09IC1JbmZpbml0eSkgPyAxIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHYgPCAwO1xuICAgICAgdiA9IGFicyh2KTtcbiAgICAgIGlmICh2ID49IHBvdygyLCAxIC0gYmlhcykpIHtcbiAgICAgICAgZSA9IG1pbihmbG9vcihsb2codikgLyBMTjIpLCAxMDIzKTtcbiAgICAgICAgZiA9IHJvdW5kVG9FdmVuKHYgLyBwb3coMiwgZSkgKiBwb3coMiwgZmJpdHMpKTtcbiAgICAgICAgaWYgKGYgLyBwb3coMiwgZmJpdHMpID49IDIpIHtcbiAgICAgICAgICBlID0gZSArIDE7XG4gICAgICAgICAgZiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgPiBiaWFzKSB7XG4gICAgICAgICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7XG4gICAgICAgICAgZiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZSA9IGUgKyBiaWFzO1xuICAgICAgICAgIGYgPSBmIC0gcG93KDIsIGZiaXRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZSA9IDA7XG4gICAgICAgIGYgPSByb3VuZFRvRXZlbih2IC8gcG93KDIsIDEgLSBiaWFzIC0gZmJpdHMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYml0cyA9IFtdO1xuICAgIGZvciAoaSA9IGZiaXRzOyBpOyBpIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChmICUgMiA/IDEgOiAwKTtcbiAgICAgIGYgPSBmbG9vcihmIC8gMik7XG4gICAgfVxuICAgIGZvciAoaSA9IGViaXRzOyBpOyBpIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcbiAgICAgIGUgPSBmbG9vcihlIC8gMik7XG4gICAgfVxuICAgIGJpdHMucHVzaChzID8gMSA6IDApO1xuICAgIGJpdHMucmV2ZXJzZSgpO1xuICAgIHN0ciA9IGJpdHMuam9pbignJyk7XG4gICAgYnl0ZXMgPSBbXTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCkge1xuICAgICAgYnl0ZXMucHVzaChwYXJzZUludChzdHIuc3Vic3RyaW5nKDAsIDgpLCAyKSk7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbiAgZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChieXRlcywgZWJpdHMsIGZiaXRzKSB7XG4gICAgdmFyIGJpdHMgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgYixcbiAgICAgICAgc3RyLFxuICAgICAgICBiaWFzLFxuICAgICAgICBzLFxuICAgICAgICBlLFxuICAgICAgICBmO1xuICAgIGZvciAoaSA9IGJ5dGVzLmxlbmd0aDsgaTsgaSAtPSAxKSB7XG4gICAgICBiID0gYnl0ZXNbaSAtIDFdO1xuICAgICAgZm9yIChqID0gODsgajsgaiAtPSAxKSB7XG4gICAgICAgIGJpdHMucHVzaChiICUgMiA/IDEgOiAwKTtcbiAgICAgICAgYiA9IGIgPj4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYml0cy5yZXZlcnNlKCk7XG4gICAgc3RyID0gYml0cy5qb2luKCcnKTtcbiAgICBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcbiAgICBzID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygwLCAxKSwgMikgPyAtMSA6IDE7XG4gICAgZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMSwgMSArIGViaXRzKSwgMik7XG4gICAgZiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMSArIGViaXRzKSwgMik7XG4gICAgaWYgKGUgPT09ICgxIDw8IGViaXRzKSAtIDEpIHtcbiAgICAgIHJldHVybiBmICE9PSAwID8gTmFOIDogcyAqIEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAoZSA+IDApIHtcbiAgICAgIHJldHVybiBzICogcG93KDIsIGUgLSBiaWFzKSAqICgxICsgZiAvIHBvdygyLCBmYml0cykpO1xuICAgIH0gZWxzZSBpZiAoZiAhPT0gMCkge1xuICAgICAgcmV0dXJuIHMgKiBwb3coMiwgLShiaWFzIC0gMSkpICogKGYgLyBwb3coMiwgZmJpdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHMgPCAwID8gLTAgOiAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1bnBhY2tGMzIoYikge1xuICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGIsIDgsIDIzKTtcbiAgfVxuICBmdW5jdGlvbiBwYWNrRjMyKHYpIHtcbiAgICByZXR1cm4gcGFja0lFRUU3NTQodiwgOCwgMjMpO1xuICB9XG4gIGZ1bmN0aW9uIGZyb3VuZCh4KSB7XG4gICAgaWYgKHggPT09IDAgfHwgISRpc0Zpbml0ZSh4KSB8fCAkaXNOYU4oeCkpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5wYWNrRjMyKHBhY2tGMzIoTnVtYmVyKHgpKSk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZnJvdW5kKCkge1xuICAgICAgcmV0dXJuIGZyb3VuZDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9NYXRoLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWF0aC5qc1wiO1xuICB2YXIganNGcm91bmQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9mcm91bmQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL01hdGguanNcIikpLmZyb3VuZDtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91dGlscy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvTWF0aC5qc1wiKSksXG4gICAgICBtYXliZUFkZEZ1bmN0aW9ucyA9ICRfXzMubWF5YmVBZGRGdW5jdGlvbnMsXG4gICAgICByZWdpc3RlclBvbHlmaWxsID0gJF9fMy5yZWdpc3RlclBvbHlmaWxsLFxuICAgICAgdG9VaW50MzIgPSAkX18zLnRvVWludDMyO1xuICB2YXIgJGlzRmluaXRlID0gaXNGaW5pdGU7XG4gIHZhciAkaXNOYU4gPSBpc05hTjtcbiAgdmFyICRfXzAgPSBNYXRoLFxuICAgICAgYWJzID0gJF9fMC5hYnMsXG4gICAgICBjZWlsID0gJF9fMC5jZWlsLFxuICAgICAgZXhwID0gJF9fMC5leHAsXG4gICAgICBmbG9vciA9ICRfXzAuZmxvb3IsXG4gICAgICBsb2cgPSAkX18wLmxvZyxcbiAgICAgIHBvdyA9ICRfXzAucG93LFxuICAgICAgc3FydCA9ICRfXzAuc3FydDtcbiAgZnVuY3Rpb24gY2x6MzIoeCkge1xuICAgIHggPSB0b1VpbnQzMigreCk7XG4gICAgaWYgKHggPT0gMClcbiAgICAgIHJldHVybiAzMjtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBpZiAoKHggJiAweEZGRkYwMDAwKSA9PT0gMCkge1xuICAgICAgeCA8PD0gMTY7XG4gICAgICByZXN1bHQgKz0gMTY7XG4gICAgfVxuICAgIDtcbiAgICBpZiAoKHggJiAweEZGMDAwMDAwKSA9PT0gMCkge1xuICAgICAgeCA8PD0gODtcbiAgICAgIHJlc3VsdCArPSA4O1xuICAgIH1cbiAgICA7XG4gICAgaWYgKCh4ICYgMHhGMDAwMDAwMCkgPT09IDApIHtcbiAgICAgIHggPDw9IDQ7XG4gICAgICByZXN1bHQgKz0gNDtcbiAgICB9XG4gICAgO1xuICAgIGlmICgoeCAmIDB4QzAwMDAwMDApID09PSAwKSB7XG4gICAgICB4IDw8PSAyO1xuICAgICAgcmVzdWx0ICs9IDI7XG4gICAgfVxuICAgIDtcbiAgICBpZiAoKHggJiAweDgwMDAwMDAwKSA9PT0gMCkge1xuICAgICAgeCA8PD0gMTtcbiAgICAgIHJlc3VsdCArPSAxO1xuICAgIH1cbiAgICA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBpbXVsKHgsIHkpIHtcbiAgICB4ID0gdG9VaW50MzIoK3gpO1xuICAgIHkgPSB0b1VpbnQzMigreSk7XG4gICAgdmFyIHhoID0gKHggPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICB2YXIgeGwgPSB4ICYgMHhmZmZmO1xuICAgIHZhciB5aCA9ICh5ID4+PiAxNikgJiAweGZmZmY7XG4gICAgdmFyIHlsID0geSAmIDB4ZmZmZjtcbiAgICByZXR1cm4geGwgKiB5bCArICgoKHhoICogeWwgKyB4bCAqIHloKSA8PCAxNikgPj4+IDApIHwgMDtcbiAgfVxuICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICB4ID0gK3g7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHggPCAwKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICByZXR1cm4gbG9nKHgpICogMC40MzQyOTQ0ODE5MDMyNTE4Mjg7XG4gIH1cbiAgZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIGxvZyh4KSAqIDEuNDQyNjk1MDQwODg4OTYzNDA3O1xuICB9XG4gIGZ1bmN0aW9uIGxvZzFwKHgpIHtcbiAgICB4ID0gK3g7XG4gICAgaWYgKHggPCAtMSB8fCAkaXNOYU4oeCkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGlmICh4ID09PSAwIHx8IHggPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICB2YXIgbiA9IDUwO1xuICAgIGlmICh4IDwgMCB8fCB4ID4gMSkge1xuICAgICAgcmV0dXJuIGxvZygxICsgeCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJSAyKSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgLT0gcG93KHgsIGkpIC8gaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBwb3coeCwgaSkgLyBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGV4cG0xKHgpIHtcbiAgICB4ID0gK3g7XG4gICAgaWYgKHggPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoISRpc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cCh4KSAtIDE7XG4gIH1cbiAgZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCRpc05hTih4KSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKCEkaXNGaW5pdGUoeCkpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHggPCAwKSB7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmICh4ID4gMjEpIHtcbiAgICAgIHJldHVybiBleHAoeCkgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gKGV4cCh4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBzaW5oKHgpIHtcbiAgICB4ID0gK3g7XG4gICAgaWYgKCEkaXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHJldHVybiAoZXhwKHgpIC0gZXhwKC14KSkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHggPSAreDtcbiAgICBpZiAoeCA9PT0gMClcbiAgICAgIHJldHVybiB4O1xuICAgIGlmICghJGlzRmluaXRlKHgpKVxuICAgICAgcmV0dXJuIHNpZ24oeCk7XG4gICAgdmFyIGV4cDEgPSBleHAoeCk7XG4gICAgdmFyIGV4cDIgPSBleHAoLXgpO1xuICAgIHJldHVybiAoZXhwMSAtIGV4cDIpIC8gKGV4cDEgKyBleHAyKTtcbiAgfVxuICBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICh4IDwgMSlcbiAgICAgIHJldHVybiBOYU47XG4gICAgaWYgKCEkaXNGaW5pdGUoeCkpXG4gICAgICByZXR1cm4geDtcbiAgICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKyAxKSAqIHNxcnQoeCAtIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBhc2luaCh4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICh4ID09PSAwIHx8ICEkaXNGaW5pdGUoeCkpXG4gICAgICByZXR1cm4geDtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xuICAgIHJldHVybiAtbG9nKC14ICsgc3FydCh4ICogeCArIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICh4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHggPT09IDEpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoJGlzTmFOKHgpIHx8IHggPCAtMSB8fCB4ID4gMSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIDAuNSAqIGxvZygoMSArIHgpIC8gKDEgLSB4KSk7XG4gIH1cbiAgZnVuY3Rpb24gaHlwb3QoeCwgeSkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbaV07XG4gICAgICBuID0gK247XG4gICAgICBpZiAobiA9PT0gSW5maW5pdHkgfHwgbiA9PT0gLUluZmluaXR5KVxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICBuID0gYWJzKG4pO1xuICAgICAgaWYgKG4gPiBtYXgpXG4gICAgICAgIG1heCA9IG47XG4gICAgICBhcmdzW2ldID0gbjtcbiAgICB9XG4gICAgaWYgKG1heCA9PT0gMClcbiAgICAgIG1heCA9IDE7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGNvbXBlbnNhdGlvbiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBhcmdzW2ldIC8gbWF4O1xuICAgICAgdmFyIHN1bW1hbmQgPSBuICogbiAtIGNvbXBlbnNhdGlvbjtcbiAgICAgIHZhciBwcmVsaW1pbmFyeSA9IHN1bSArIHN1bW1hbmQ7XG4gICAgICBjb21wZW5zYXRpb24gPSAocHJlbGltaW5hcnkgLSBzdW0pIC0gc3VtbWFuZDtcbiAgICAgIHN1bSA9IHByZWxpbWluYXJ5O1xuICAgIH1cbiAgICByZXR1cm4gc3FydChzdW0pICogbWF4O1xuICB9XG4gIGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgICB4ID0gK3g7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGZsb29yKHgpO1xuICAgIGlmICh4IDwgMClcbiAgICAgIHJldHVybiBjZWlsKHgpO1xuICAgIHJldHVybiB4O1xuICB9XG4gIHZhciBmcm91bmQsXG4gICAgICBmMzI7XG4gIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZjMyID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICBmcm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBmMzJbMF0gPSBOdW1iZXIoeCk7XG4gICAgICByZXR1cm4gZjMyWzBdO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJvdW5kID0ganNGcm91bmQ7XG4gIH1cbiAgZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgeCA9ICt4O1xuICAgIGlmICh4ID09PSAwKVxuICAgICAgcmV0dXJuIHg7XG4gICAgdmFyIG5lZ2F0ZSA9IHggPCAwO1xuICAgIGlmIChuZWdhdGUpXG4gICAgICB4ID0gLXg7XG4gICAgdmFyIHJlc3VsdCA9IHBvdyh4LCAxIC8gMyk7XG4gICAgcmV0dXJuIG5lZ2F0ZSA/IC1yZXN1bHQgOiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxNYXRoKGdsb2JhbCkge1xuICAgIHZhciBNYXRoID0gZ2xvYmFsLk1hdGg7XG4gICAgbWF5YmVBZGRGdW5jdGlvbnMoTWF0aCwgWydhY29zaCcsIGFjb3NoLCAnYXNpbmgnLCBhc2luaCwgJ2F0YW5oJywgYXRhbmgsICdjYnJ0JywgY2JydCwgJ2NsejMyJywgY2x6MzIsICdjb3NoJywgY29zaCwgJ2V4cG0xJywgZXhwbTEsICdmcm91bmQnLCBmcm91bmQsICdoeXBvdCcsIGh5cG90LCAnaW11bCcsIGltdWwsICdsb2cxMCcsIGxvZzEwLCAnbG9nMXAnLCBsb2cxcCwgJ2xvZzInLCBsb2cyLCAnc2lnbicsIHNpZ24sICdzaW5oJywgc2luaCwgJ3RhbmgnLCB0YW5oLCAndHJ1bmMnLCB0cnVuY10pO1xuICB9XG4gIHJlZ2lzdGVyUG9seWZpbGwocG9seWZpbGxNYXRoKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgY2x6MzIoKSB7XG4gICAgICByZXR1cm4gY2x6MzI7XG4gICAgfSxcbiAgICBnZXQgaW11bCgpIHtcbiAgICAgIHJldHVybiBpbXVsO1xuICAgIH0sXG4gICAgZ2V0IHNpZ24oKSB7XG4gICAgICByZXR1cm4gc2lnbjtcbiAgICB9LFxuICAgIGdldCBsb2cxMCgpIHtcbiAgICAgIHJldHVybiBsb2cxMDtcbiAgICB9LFxuICAgIGdldCBsb2cyKCkge1xuICAgICAgcmV0dXJuIGxvZzI7XG4gICAgfSxcbiAgICBnZXQgbG9nMXAoKSB7XG4gICAgICByZXR1cm4gbG9nMXA7XG4gICAgfSxcbiAgICBnZXQgZXhwbTEoKSB7XG4gICAgICByZXR1cm4gZXhwbTE7XG4gICAgfSxcbiAgICBnZXQgY29zaCgpIHtcbiAgICAgIHJldHVybiBjb3NoO1xuICAgIH0sXG4gICAgZ2V0IHNpbmgoKSB7XG4gICAgICByZXR1cm4gc2luaDtcbiAgICB9LFxuICAgIGdldCB0YW5oKCkge1xuICAgICAgcmV0dXJuIHRhbmg7XG4gICAgfSxcbiAgICBnZXQgYWNvc2goKSB7XG4gICAgICByZXR1cm4gYWNvc2g7XG4gICAgfSxcbiAgICBnZXQgYXNpbmgoKSB7XG4gICAgICByZXR1cm4gYXNpbmg7XG4gICAgfSxcbiAgICBnZXQgYXRhbmgoKSB7XG4gICAgICByZXR1cm4gYXRhbmg7XG4gICAgfSxcbiAgICBnZXQgaHlwb3QoKSB7XG4gICAgICByZXR1cm4gaHlwb3Q7XG4gICAgfSxcbiAgICBnZXQgdHJ1bmMoKSB7XG4gICAgICByZXR1cm4gdHJ1bmM7XG4gICAgfSxcbiAgICBnZXQgZnJvdW5kKCkge1xuICAgICAgcmV0dXJuIGZyb3VuZDtcbiAgICB9LFxuICAgIGdldCBjYnJ0KCkge1xuICAgICAgcmV0dXJuIGNicnQ7XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxNYXRoKCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsTWF0aDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL01hdGguanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvV2Vha01hcC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtNYXAuanNcIjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vcHJpdmF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvV2Vha01hcC5qc1wiKSksXG4gICAgICBjcmVhdGVQcml2YXRlU3ltYm9sID0gJF9fNS5jcmVhdGVQcml2YXRlU3ltYm9sLFxuICAgICAgZGVsZXRlUHJpdmF0ZSA9ICRfXzUuZGVsZXRlUHJpdmF0ZSxcbiAgICAgIGdldFByaXZhdGUgPSAkX181LmdldFByaXZhdGUsXG4gICAgICBoYXNQcml2YXRlID0gJF9fNS5oYXNQcml2YXRlLFxuICAgICAgc2V0UHJpdmF0ZSA9ICRfXzUuc2V0UHJpdmF0ZTtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vZnJvemVuLWRhdGEuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtNYXAuanNcIikpLFxuICAgICAgZGVsZXRlRnJvemVuID0gJF9fNi5kZWxldGVGcm96ZW4sXG4gICAgICBnZXRGcm96ZW4gPSAkX182LmdldEZyb3plbixcbiAgICAgIGhhc0Zyb3plbiA9ICRfXzYuaGFzRnJvemVuLFxuICAgICAgc2V0RnJvemVuID0gJF9fNi5zZXRGcm96ZW47XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtNYXAuanNcIikpLFxuICAgICAgaXNPYmplY3QgPSAkX183LmlzT2JqZWN0LFxuICAgICAgcmVnaXN0ZXJQb2x5ZmlsbCA9ICRfXzcucmVnaXN0ZXJQb2x5ZmlsbDtcbiAgdmFyIGhhc05hdGl2ZVN5bWJvbCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9oYXMtbmF0aXZlLXN5bWJvbHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtNYXAuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX18yID0gT2JqZWN0LFxuICAgICAgZGVmaW5lUHJvcGVydHkgPSAkX18yLmRlZmluZVByb3BlcnR5LFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gJF9fMi5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICBpc0V4dGVuc2libGUgPSAkX18yLmlzRXh0ZW5zaWJsZTtcbiAgdmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBzZW50aW5lbCA9IHt9O1xuICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgICB0aGlzLm5hbWVfID0gY3JlYXRlUHJpdmF0ZVN5bWJvbCgpO1xuICAgICAgdGhpcy5mcm96ZW5EYXRhXyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoV2Vha01hcCwge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSlcbiAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcigna2V5IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgICBzZXRGcm96ZW4odGhpcy5mcm96ZW5EYXRhXywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0UHJpdmF0ZShrZXksIHRoaXMubmFtZV8sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBnZXRGcm96ZW4odGhpcy5mcm96ZW5EYXRhXywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0UHJpdmF0ZShrZXksIHRoaXMubmFtZV8pO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlRnJvemVuKHRoaXMuZnJvemVuRGF0YV8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZVByaXZhdGUoa2V5LCB0aGlzLm5hbWVfKTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc0Zyb3plbih0aGlzLmZyb3plbkRhdGFfLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNQcml2YXRlKGtleSwgdGhpcy5uYW1lXyk7XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIG5lZWRzUG9seWZpbGwoZ2xvYmFsKSB7XG4gICAgdmFyICRfXzQgPSBnbG9iYWwsXG4gICAgICAgIFdlYWtNYXAgPSAkX180LldlYWtNYXAsXG4gICAgICAgIFN5bWJvbCA9ICRfXzQuU3ltYm9sO1xuICAgIGlmICghV2Vha01hcCB8fCAhaGFzTmF0aXZlU3ltYm9sKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIHZhciB3bSA9IG5ldyBXZWFrTWFwKFtbbywgZmFsc2VdXSk7XG4gICAgICByZXR1cm4gd20uZ2V0KG8pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxXZWFrTWFwKGdsb2JhbCkge1xuICAgIGlmIChuZWVkc1BvbHlmaWxsKGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbC5XZWFrTWFwID0gV2Vha01hcDtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJQb2x5ZmlsbChwb2x5ZmlsbFdlYWtNYXApO1xuICByZXR1cm4ge1xuICAgIGdldCBXZWFrTWFwKCkge1xuICAgICAgcmV0dXJuIFdlYWtNYXA7XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxXZWFrTWFwKCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsV2Vha01hcDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtNYXAuanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvV2Vha1NldC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtTZXQuanNcIjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vcHJpdmF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvV2Vha1NldC5qc1wiKSksXG4gICAgICBjcmVhdGVQcml2YXRlU3ltYm9sID0gJF9fNS5jcmVhdGVQcml2YXRlU3ltYm9sLFxuICAgICAgZGVsZXRlUHJpdmF0ZSA9ICRfXzUuZGVsZXRlUHJpdmF0ZSxcbiAgICAgIGdldFByaXZhdGUgPSAkX181LmdldFByaXZhdGUsXG4gICAgICBoYXNQcml2YXRlID0gJF9fNS5oYXNQcml2YXRlLFxuICAgICAgc2V0UHJpdmF0ZSA9ICRfXzUuc2V0UHJpdmF0ZTtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vZnJvemVuLWRhdGEuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtTZXQuanNcIikpLFxuICAgICAgZGVsZXRlRnJvemVuID0gJF9fNi5kZWxldGVGcm96ZW4sXG4gICAgICBnZXRGcm96ZW4gPSAkX182LmdldEZyb3plbixcbiAgICAgIHNldEZyb3plbiA9ICRfXzYuc2V0RnJvemVuO1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9XZWFrU2V0LmpzXCIpKSxcbiAgICAgIGlzT2JqZWN0ID0gJF9fNy5pc09iamVjdCxcbiAgICAgIHJlZ2lzdGVyUG9seWZpbGwgPSAkX183LnJlZ2lzdGVyUG9seWZpbGw7XG4gIHZhciBoYXNOYXRpdmVTeW1ib2wgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vaGFzLW5hdGl2ZS1zeW1ib2xzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9XZWFrU2V0LmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fMiA9IE9iamVjdCxcbiAgICAgIGRlZmluZVByb3BlcnR5ID0gJF9fMi5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgIGlzRXh0ZW5zaWJsZSA9ICRfXzIuaXNFeHRlbnNpYmxlO1xuICB2YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIFdlYWtTZXQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBXZWFrU2V0KCkge1xuICAgICAgdGhpcy5uYW1lXyA9IGNyZWF0ZVByaXZhdGVTeW1ib2woKTtcbiAgICAgIHRoaXMuZnJvemVuRGF0YV8gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFdlYWtTZXQsIHtcbiAgICAgIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpXG4gICAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHNldEZyb3plbih0aGlzLmZyb3plbkRhdGFfLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFByaXZhdGUodmFsdWUsIHRoaXMubmFtZV8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlRnJvemVuKHRoaXMuZnJvemVuRGF0YV8sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlUHJpdmF0ZSh2YWx1ZSwgdGhpcy5uYW1lXyk7XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghaXNFeHRlbnNpYmxlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBnZXRGcm96ZW4odGhpcy5mcm96ZW5EYXRhXywgdmFsdWUpID09PSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzUHJpdmF0ZSh2YWx1ZSwgdGhpcy5uYW1lXyk7XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIG5lZWRzUG9seWZpbGwoZ2xvYmFsKSB7XG4gICAgdmFyICRfXzQgPSBnbG9iYWwsXG4gICAgICAgIFdlYWtTZXQgPSAkX180LldlYWtTZXQsXG4gICAgICAgIFN5bWJvbCA9ICRfXzQuU3ltYm9sO1xuICAgIGlmICghV2Vha1NldCB8fCAhaGFzTmF0aXZlU3ltYm9sKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIG8gPSB7fTtcbiAgICAgIHZhciB3bSA9IG5ldyBXZWFrU2V0KFtbb11dKTtcbiAgICAgIHJldHVybiAhd20uaGFzKG8pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxXZWFrU2V0KGdsb2JhbCkge1xuICAgIGlmIChuZWVkc1BvbHlmaWxsKGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbC5XZWFrU2V0ID0gV2Vha1NldDtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJQb2x5ZmlsbChwb2x5ZmlsbFdlYWtTZXQpO1xuICByZXR1cm4ge1xuICAgIGdldCBXZWFrU2V0KCkge1xuICAgICAgcmV0dXJuIFdlYWtTZXQ7XG4gICAgfSxcbiAgICBnZXQgcG9seWZpbGxXZWFrU2V0KCkge1xuICAgICAgcmV0dXJuIHBvbHlmaWxsV2Vha1NldDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3J1bnRpbWUvcG9seWZpbGxzL1dlYWtTZXQuanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvcG9seWZpbGxzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvcnVudGltZS9wb2x5ZmlsbHMvcG9seWZpbGxzLmpzXCI7XG4gIHZhciBwb2x5ZmlsbEFsbCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWxzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9wb2x5ZmlsbHMuanNcIikpLnBvbHlmaWxsQWxsO1xuICBwb2x5ZmlsbEFsbChSZWZsZWN0Lmdsb2JhbCk7XG4gIHZhciBzZXR1cEdsb2JhbHMgPSAkdHJhY2V1clJ1bnRpbWUuc2V0dXBHbG9iYWxzO1xuICAkdHJhY2V1clJ1bnRpbWUuc2V0dXBHbG9iYWxzID0gZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgc2V0dXBHbG9iYWxzKGdsb2JhbCk7XG4gICAgcG9seWZpbGxBbGwoZ2xvYmFsKTtcbiAgfTtcbiAgcmV0dXJuIHt9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9ydW50aW1lL3BvbHlmaWxscy9wb2x5ZmlsbHMuanNcIiArICcnKTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9Tb3VyY2VSYW5nZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvU291cmNlUmFuZ2UuanNcIjtcbiAgdmFyIFNvdXJjZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU291cmNlUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTb3VyY2VSYW5nZSwge3RvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuc3RhcnQuc291cmNlLmNvbnRlbnRzO1xuICAgICAgICByZXR1cm4gc3RyLnNsaWNlKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgICAgfX0sIHt9KTtcbiAgfSgpO1xuICByZXR1cm4ge2dldCBTb3VyY2VSYW5nZSgpIHtcbiAgICAgIHJldHVybiBTb3VyY2VSYW5nZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL0Vycm9yUmVwb3J0ZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL0Vycm9yUmVwb3J0ZXIuanNcIjtcbiAgdmFyIFNvdXJjZVJhbmdlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU291cmNlUmFuZ2UuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvRXJyb3JSZXBvcnRlci5qc1wiKSkuU291cmNlUmFuZ2U7XG4gIHZhciBFcnJvclJlcG9ydGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JSZXBvcnRlcigpIHtcbiAgICAgIHRoaXMuaGFkRXJyb3JfID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShFcnJvclJlcG9ydGVyLCB7XG4gICAgICByZXBvcnRFcnJvcjogZnVuY3Rpb24obG9jYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5oYWRFcnJvcl8gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcG9ydE1lc3NhZ2VJbnRlcm5hbChsb2NhdGlvbiwgbWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgcmVwb3J0TWVzc2FnZUludGVybmFsOiBmdW5jdGlvbihsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobG9jYXRpb24pXG4gICAgICAgICAgbWVzc2FnZSA9IChsb2NhdGlvbi5zdGFydCArIFwiOiBcIiArIG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIGhhZEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFkRXJyb3JfO1xuICAgICAgfSxcbiAgICAgIGNsZWFyRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmhhZEVycm9yXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICBmdW5jdGlvbiBmb3JtYXQobG9jYXRpb24sIHRleHQpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJS4vZywgZnVuY3Rpb24ocykge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgJyVzJzpcbiAgICAgICAgICByZXR1cm4gYXJncyAmJiBhcmdzW2krK107XG4gICAgICAgIGNhc2UgJyUlJzpcbiAgICAgICAgICByZXR1cm4gJyUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfSk7XG4gICAgaWYgKGxvY2F0aW9uKVxuICAgICAgdGV4dCA9IChsb2NhdGlvbiArIFwiOiBcIiArIHRleHQpO1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIDtcbiAgRXJyb3JSZXBvcnRlci5mb3JtYXQgPSBmb3JtYXQ7XG4gIHJldHVybiB7XG4gICAgZ2V0IEVycm9yUmVwb3J0ZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3JSZXBvcnRlcjtcbiAgICB9LFxuICAgIGdldCBmb3JtYXQoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL011dGVkRXJyb3JSZXBvcnRlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvTXV0ZWRFcnJvclJlcG9ydGVyLmpzXCI7XG4gIHZhciBFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9NdXRlZEVycm9yUmVwb3J0ZXIuanNcIikpLkVycm9yUmVwb3J0ZXI7XG4gIHZhciBNdXRlZEVycm9yUmVwb3J0ZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE11dGVkRXJyb3JSZXBvcnRlcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE11dGVkRXJyb3JSZXBvcnRlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE11dGVkRXJyb3JSZXBvcnRlciwge3JlcG9ydE1lc3NhZ2VJbnRlcm5hbDogZnVuY3Rpb24obG9jYXRpb24sIGZvcm1hdCwgYXJncykge319LCB7fSwgJF9fc3VwZXIpO1xuICB9KEVycm9yUmVwb3J0ZXIpO1xuICByZXR1cm4ge2dldCBNdXRlZEVycm9yUmVwb3J0ZXIoKSB7XG4gICAgICByZXR1cm4gTXV0ZWRFcnJvclJlcG9ydGVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL09wdGlvbnMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9PcHRpb25zLmpzXCI7XG4gIGZ1bmN0aW9uIGVudW1lcmFibGVPbmx5T2JqZWN0KG9iaikge1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogb2JqW2tleV1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIG9wdGlvbnNWMDEgPSBlbnVtZXJhYmxlT25seU9iamVjdCh7XG4gICAgYW5ub3RhdGlvbnM6IGZhbHNlLFxuICAgIGFycmF5Q29tcHJlaGVuc2lvbjogZmFsc2UsXG4gICAgYXJyb3dGdW5jdGlvbnM6IHRydWUsXG4gICAgYXN5bmNGdW5jdGlvbnM6IGZhbHNlLFxuICAgIGFzeW5jR2VuZXJhdG9yczogZmFsc2UsXG4gICAgYmxvY2tCaW5kaW5nOiB0cnVlLFxuICAgIGNsYXNzZXM6IHRydWUsXG4gICAgY29tbWVudENhbGxiYWNrOiBmYWxzZSxcbiAgICBjb21wdXRlZFByb3BlcnR5TmFtZXM6IHRydWUsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGRlYnVnTmFtZXM6IGZhbHNlLFxuICAgIGRlZmF1bHRQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIGRlc3RydWN0dXJpbmc6IHRydWUsXG4gICAgZXhwb25lbnRpYXRpb246IGZhbHNlLFxuICAgIGV4cG9ydEZyb21FeHRlbmRlZDogZmFsc2UsXG4gICAgZm9yT2Y6IHRydWUsXG4gICAgZm9yT246IGZhbHNlLFxuICAgIGZyZWVWYXJpYWJsZUNoZWNrZXI6IGZhbHNlLFxuICAgIGdlbmVyYXRvckNvbXByZWhlbnNpb246IGZhbHNlLFxuICAgIGdlbmVyYXRvcnM6IHRydWUsXG4gICAgaW1wb3J0UnVudGltZTogZmFsc2UsXG4gICAgaW5wdXRTb3VyY2VNYXA6IGZhbHNlLFxuICAgIGpzeDogZmFsc2UsXG4gICAgbG93UmVzb2x1dGlvblNvdXJjZU1hcDogZmFsc2UsXG4gICAgbWVtYmVyVmFyaWFibGVzOiBmYWxzZSxcbiAgICBtb2R1bGVOYW1lOiAnZGVmYXVsdCcsXG4gICAgbW9kdWxlczogJ2Jvb3RzdHJhcCcsXG4gICAgbnVtZXJpY0xpdGVyYWxzOiB0cnVlLFxuICAgIG91dHB1dExhbmd1YWdlOiAnZXM1JyxcbiAgICBwcm9wZXJUYWlsQ2FsbHM6IGZhbHNlLFxuICAgIHByb3BlcnR5TWV0aG9kczogdHJ1ZSxcbiAgICBwcm9wZXJ0eU5hbWVTaG9ydGhhbmQ6IHRydWUsXG4gICAgcmVmZXJyZXI6ICcnLFxuICAgIHJlcXVpcmU6IGZhbHNlLFxuICAgIHJlc3RQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIHNjcmlwdDogZmFsc2UsXG4gICAgc291cmNlTWFwczogZmFsc2UsXG4gICAgc291cmNlUm9vdDogZmFsc2UsXG4gICAgc3ByZWFkOiB0cnVlLFxuICAgIHNwcmVhZFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIHN5bWJvbHM6IHRydWUsXG4gICAgdGVtcGxhdGVMaXRlcmFsczogdHJ1ZSxcbiAgICB0eXBlczogZmFsc2UsXG4gICAgdW5pY29kZUVzY2FwZVNlcXVlbmNlczogdHJ1ZSxcbiAgICB1bmljb2RlRXhwcmVzc2lvbnM6IHRydWUsXG4gICAgdmFsaWRhdGU6IGZhbHNlXG4gIH0pO1xuICB2YXIgdmVyc2lvbkxvY2tlZE9wdGlvbnMgPSBvcHRpb25zVjAxO1xuICB2YXIgZGVmYXVsdFZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBmZWF0dXJlT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBleHBlcmltZW50YWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG1vZHVsZU9wdGlvbnMgPSBbJ2FtZCcsICdjb21tb25qcycsICdjbG9zdXJlJywgJ2luc3RhbnRpYXRlJywgJ2lubGluZScsICdib290c3RyYXAnLCAncGFyc2UnXTtcbiAgdmFyIEVYUEVSSU1FTlRBTCA9IDA7XG4gIHZhciBPTl9CWV9ERUZBVUxUID0gMTtcbiAgZnVuY3Rpb24gYWRkRmVhdHVyZU9wdGlvbihuYW1lLCBraW5kKSB7XG4gICAgZmVhdHVyZU9wdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgIGlmIChraW5kID09PSBFWFBFUklNRU5UQUwpXG4gICAgICBleHBlcmltZW50YWxPcHRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0ga2luZCA9PT0gT05fQllfREVGQVVMVDtcbiAgICBkZWZhdWx0VmFsdWVzW25hbWVdID0gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEJvb2xPcHRpb24obmFtZSkge1xuICAgIGRlZmF1bHRWYWx1ZXNbbmFtZV0gPSBmYWxzZTtcbiAgfVxuICBhZGRGZWF0dXJlT3B0aW9uKCdhcnJvd0Z1bmN0aW9ucycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdibG9ja0JpbmRpbmcnLCBPTl9CWV9ERUZBVUxUKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignY2xhc3NlcycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdjb21wdXRlZFByb3BlcnR5TmFtZXMnLCBPTl9CWV9ERUZBVUxUKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignZGVmYXVsdFBhcmFtZXRlcnMnLCBPTl9CWV9ERUZBVUxUKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignZGVzdHJ1Y3R1cmluZycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdmb3JPZicsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdnZW5lcmF0b3JzJywgT05fQllfREVGQVVMVCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ21vZHVsZXMnLCAnU1BFQ0lBTCcpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdudW1lcmljTGl0ZXJhbHMnLCBPTl9CWV9ERUZBVUxUKTtcbiAgYWRkRmVhdHVyZU9wdGlvbigncHJvcGVydHlNZXRob2RzJywgT05fQllfREVGQVVMVCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ3Byb3BlcnR5TmFtZVNob3J0aGFuZCcsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdyZXN0UGFyYW1ldGVycycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdzb3VyY2VNYXBzJywgJ1NQRUNJQUwnKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignc3ByZWFkJywgT05fQllfREVGQVVMVCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ3N5bWJvbHMnLCBPTl9CWV9ERUZBVUxUKTtcbiAgYWRkRmVhdHVyZU9wdGlvbigndGVtcGxhdGVMaXRlcmFscycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCd1bmljb2RlRXNjYXBlU2VxdWVuY2VzJywgT05fQllfREVGQVVMVCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ3VuaWNvZGVFeHByZXNzaW9ucycsIE9OX0JZX0RFRkFVTFQpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdwcm9wZXJUYWlsQ2FsbHMnLCBFWFBFUklNRU5UQUwpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdhbm5vdGF0aW9ucycsIEVYUEVSSU1FTlRBTCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ2FycmF5Q29tcHJlaGVuc2lvbicsIEVYUEVSSU1FTlRBTCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ2FzeW5jRnVuY3Rpb25zJywgRVhQRVJJTUVOVEFMKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignYXN5bmNHZW5lcmF0b3JzJywgRVhQRVJJTUVOVEFMKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignZXhwb25lbnRpYXRpb24nLCBFWFBFUklNRU5UQUwpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdleHBvcnRGcm9tRXh0ZW5kZWQnLCBFWFBFUklNRU5UQUwpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdmb3JPbicsIEVYUEVSSU1FTlRBTCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ2dlbmVyYXRvckNvbXByZWhlbnNpb24nLCBFWFBFUklNRU5UQUwpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCdpbXBvcnRSdW50aW1lJywgRVhQRVJJTUVOVEFMKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignanN4JywgRVhQRVJJTUVOVEFMKTtcbiAgYWRkRmVhdHVyZU9wdGlvbignbWVtYmVyVmFyaWFibGVzJywgRVhQRVJJTUVOVEFMKTtcbiAgYWRkRmVhdHVyZU9wdGlvbigncmVxdWlyZScsIEVYUEVSSU1FTlRBTCk7XG4gIGFkZEZlYXR1cmVPcHRpb24oJ3NwcmVhZFByb3BlcnRpZXMnLCBFWFBFUklNRU5UQUwpO1xuICBhZGRGZWF0dXJlT3B0aW9uKCd0eXBlcycsIEVYUEVSSU1FTlRBTCk7XG4gIHZhciB0cmFuc2Zvcm1PcHRpb25zUHJvdG90eXBlID0ge307XG4gIE9iamVjdC5rZXlzKGZlYXR1cmVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhbnNmb3JtT3B0aW9uc1Byb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnByb3hpZWRPcHRpb25zX1tuYW1lXTtcbiAgICAgICAgaWYgKHYgPT09ICdwYXJzZScpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuICB2YXIgcGFyc2VPcHRpb25zUHJvdG90eXBlID0ge307XG4gIE9iamVjdC5rZXlzKGZlYXR1cmVPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyc2VPcHRpb25zUHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnByb3hpZWRPcHRpb25zX1tuYW1lXTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuICBhZGRCb29sT3B0aW9uKCdjb21tZW50Q2FsbGJhY2snKTtcbiAgYWRkQm9vbE9wdGlvbignZGVidWcnKTtcbiAgYWRkQm9vbE9wdGlvbignZGVidWdOYW1lcycpO1xuICBhZGRCb29sT3B0aW9uKCdmcmVlVmFyaWFibGVDaGVja2VyJyk7XG4gIGFkZEJvb2xPcHRpb24oJ3NjcmlwdCcpO1xuICBhZGRCb29sT3B0aW9uKCd2YWxpZGF0ZScpO1xuICB2YXIgT3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE9wdGlvbnMoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBtb2R1bGVzXzoge1xuICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uTG9ja2VkT3B0aW9ucy5tb2R1bGVzLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU1hcHNfOiB7XG4gICAgICAgICAgdmFsdWU6IHZlcnNpb25Mb2NrZWRPcHRpb25zLnNvdXJjZU1hcHMsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlUm9vdF86IHtcbiAgICAgICAgICB2YWx1ZTogdmVyc2lvbkxvY2tlZE9wdGlvbnMuc291cmNlUm9vdCxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1PcHRpb25zOiB7XG4gICAgICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUodHJhbnNmb3JtT3B0aW9uc1Byb3RvdHlwZSwge3Byb3hpZWRPcHRpb25zXzoge1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcyxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH19KSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZU9wdGlvbnM6IHtcbiAgICAgICAgICB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwYXJzZU9wdGlvbnNQcm90b3R5cGUsIHtwcm94aWVkT3B0aW9uc186IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9fSksXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldEZyb21PYmplY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShPcHRpb25zLCB7XG4gICAgICBzZXQgZXhwZXJpbWVudGFsKHYpIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICB2ID0gY29lcmNlT3B0aW9uVmFsdWUodik7XG4gICAgICAgIE9iamVjdC5rZXlzKGV4cGVyaW1lbnRhbE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICRfXzJbbmFtZV0gPSB2O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZXQgZXhwZXJpbWVudGFsKCkge1xuICAgICAgICB2YXIgJF9fMiA9IHRoaXM7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgT2JqZWN0LmtleXMoZXhwZXJpbWVudGFsT3B0aW9ucykuZXZlcnkoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSAkX18yW25hbWVdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgYXRzY3JpcHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzICYmIHRoaXMuYW5ub3RhdGlvbnMgJiYgdGhpcy5tZW1iZXJWYXJpYWJsZXM7XG4gICAgICB9LFxuICAgICAgc2V0IGF0c2NyaXB0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lbWJlclZhcmlhYmxlcyA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGdldCBtb2R1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVzXztcbiAgICAgIH0sXG4gICAgICBzZXQgbW9kdWxlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXZhbHVlKVxuICAgICAgICAgIHZhbHVlID0gJ2Jvb3RzdHJhcCc7XG4gICAgICAgIGlmIChtb2R1bGVPcHRpb25zLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcXCdtb2R1bGVzXFwnIG9wdGlvbiBcXCcnICsgdmFsdWUgKyAnXFwnLCBub3QgaW4gJyArIG1vZHVsZU9wdGlvbnMuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2R1bGVzXyA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGdldCBzb3VyY2VNYXBzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VNYXBzXztcbiAgICAgIH0sXG4gICAgICBzZXQgc291cmNlTWFwcyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZU1hcHNfID0gdmFsdWUgPyAnZmlsZScgOiBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSAnZmlsZScgfHwgdmFsdWUgPT09ICdpbmxpbmUnIHx8IHZhbHVlID09PSAnbWVtb3J5Jykge1xuICAgICAgICAgIHRoaXMuc291cmNlTWFwc18gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBzb3VyY2VNYXBzIHNob3VsZCBiZSAnICsgJ1tmYWxzZXxpbmxpbmV8ZmlsZXxtZW1vcnldLCBub3QgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFsbE9mZiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICB2YXIgdXNlRGVmYXVsdCA9IGFsbE9mZiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAkX18yW25hbWVdID0gdXNlRGVmYXVsdCAmJiBkZWZhdWx0VmFsdWVzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0cygpO1xuICAgICAgfSxcbiAgICAgIHNldERlZmF1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gJ2Jvb3RzdHJhcCc7XG4gICAgICAgIHRoaXMubW9kdWxlTmFtZSA9ICdkZWZhdWx0JztcbiAgICAgICAgdGhpcy5vdXRwdXRMYW5ndWFnZSA9ICdlczUnO1xuICAgICAgICB0aGlzLnJlZmVycmVyID0gJyc7XG4gICAgICAgIHRoaXMuc291cmNlTWFwcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvdXJjZVJvb3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb3dSZXNvbHV0aW9uU291cmNlTWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5wdXRTb3VyY2VNYXAgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZSBpbiBvYmplY3QpXG4gICAgICAgICAgICAkX18yLnNldE9wdGlvbihuYW1lLCBvYmplY3RbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2R1bGVzID0gb2JqZWN0Lm1vZHVsZXMgfHwgdGhpcy5tb2R1bGVzO1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VNYXBzID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIG9iamVjdC5zb3VyY2VNYXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuc291cmNlTWFwcyA9IG9iamVjdC5zb3VyY2VNYXBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Quc291cmNlUm9vdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuc291cmNlUm9vdCA9IG9iamVjdC5zb3VyY2VSb290O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIG5hbWUgPSB0b0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb246ICcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpZmY6IGZ1bmN0aW9uKHJlZikge1xuICAgICAgICB2YXIgJF9fMiA9IHRoaXM7XG4gICAgICAgIHZhciBtaXNtYXRjaGVzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgaWYgKCRfXzJba2V5XSAhPT0gcmVmW2tleV0pIHtcbiAgICAgICAgICAgIG1pc21hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICBub3c6ICR0cmFjZXVyUnVudGltZS5vcHRpb25zW2tleV0sXG4gICAgICAgICAgICAgIHYwMTogcmVmW2tleV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtaXNtYXRjaGVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGV4cGVyaW1lbnRhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3B0aW9ucyhleHBlcmltZW50YWxPcHRpb25zKTtcbiAgICAgIH0sXG4gICAgICBhdHNjcmlwdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3B0aW9ucyh7XG4gICAgICAgICAgdHlwZXM6IHRydWUsXG4gICAgICAgICAgYW5ub3RhdGlvbnM6IHRydWUsXG4gICAgICAgICAgbWVtYmVyVmFyaWFibGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGxpc3RVbmtub3duT3B0aW9uczogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciB1bmtub3ducyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBvcHRpb25zVjAxKSkge1xuICAgICAgICAgICAgdW5rbm93bnMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVua25vd25zO1xuICAgICAgfVxuICAgIH0pO1xuICB9KCk7XG4gIDtcbiAgdmFyIGRlc2NyaXB0aW9ucyA9IHtcbiAgICBleHBlcmltZW50YWw6ICdUdXJucyBvbiBhbGwgZXhwZXJpbWVudGFsIGZlYXR1cmVzJyxcbiAgICByZXF1aXJlOiAnR2VuZXJhdGUgcmVxdWlyZSBmdW5jdGlvbiBhcmd1bWVudCBmb3Igbm9kZSB3aGVuIG1vZHVsZXM9cmVnaXN0ZXInLFxuICAgIHNvdXJjZU1hcHM6ICdHZW5lcmF0ZSBzb3VyY2UgbWFwIGFuZCAoXFwnZmlsZVxcJykgd3JpdGUgdG8gLm1hcCcgKyAnIG9yIChcXCdpbmxpbmVcXCcpIGFwcGVuZCBkYXRhIFVSTCdcbiAgfTtcbiAgdmFyIENvbW1hbmRPcHRpb25zID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb21tYW5kT3B0aW9ucygpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvbW1hbmRPcHRpb25zKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29tbWFuZE9wdGlvbnMsIHtcbiAgICAgIHBhcnNlQ29tbWFuZDogZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgcmUgPSAvLS0oW149XSspKD86PSguKykpPy87XG4gICAgICAgIHZhciBtID0gcmUuZXhlYyhzKTtcbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgdGhpcy5zZXRPcHRpb25Db2VyY2VkKG1bMV0sIG1bMl0pO1xuICAgICAgfSxcbiAgICAgIHNldE9wdGlvbkNvZXJjZWQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsKVxuICAgICAgICAgIHZhbHVlID0gY29lcmNlT3B0aW9uVmFsdWUodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZnJvbVN0cmluZzogZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ29tbWFuZE9wdGlvbnMuZnJvbUFyZ3Yocy5zcGxpdCgvXFxzKy8pKTtcbiAgICAgIH0sXG4gICAgICBmcm9tQXJndjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG5ldyBDb21tYW5kT3B0aW9ucygpO1xuICAgICAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMucGFyc2VDb21tYW5kKGFyZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9LCAkX19zdXBlcik7XG4gIH0oT3B0aW9ucyk7XG4gIGZ1bmN0aW9uIGNvZXJjZU9wdGlvblZhbHVlKHYpIHtcbiAgICBzd2l0Y2ggKHYpIHtcbiAgICAgIGNhc2UgJ2ZhbHNlJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICEhdiAmJiBTdHJpbmcodik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8tXFx3L2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gY2hbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0b0Rhc2hDYXNlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bQS1aXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuICctJyArIGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkT3B0aW9ucyhmbGFncywgY29tbWFuZE9wdGlvbnMpIHtcbiAgICBmbGFncy5vcHRpb24oJy0tcmVmZXJyZXIgPG5hbWU+JywgJ0JyYWNrZXQgb3V0cHV0IGNvZGUgd2l0aCBTeXN0ZW0ucmVmZXJyZXJOYW1lPTxuYW1lPicsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNvbW1hbmRPcHRpb25zLnNldE9wdGlvbigncmVmZXJyZXInLCBuYW1lKTtcbiAgICAgIFN5c3RlbS5tYXAgPSBTeXN0ZW0uc2VtdmVyTWFwKG5hbWUpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSk7XG4gICAgZmxhZ3Mub3B0aW9uKCctLW1vZHVsZXMgPCcgKyBtb2R1bGVPcHRpb25zLmpvaW4oJywgJykgKyAnPicsICdzZWxlY3QgdGhlIG91dHB1dCBmb3JtYXQgZm9yIG1vZHVsZXMnLCBmdW5jdGlvbihtb2R1bGVGb3JtYXQpIHtcbiAgICAgIGNvbW1hbmRPcHRpb25zLm1vZHVsZXMgPSBtb2R1bGVGb3JtYXQ7XG4gICAgfSk7XG4gICAgZmxhZ3Mub3B0aW9uKCctLW1vZHVsZU5hbWUgW3RydWV8ZmFsc2V8ZGVmYXVsdF0nLCAndHJ1ZSBmb3IgbmFtZWQsIGZhbHNlIGZvciBhbm9ueW1vdXMgbW9kdWxlczsgZGVmYXVsdCBkZXBlbmRzIG9uIC0tbW9kdWxlcycsIGZ1bmN0aW9uKG1vZHVsZU5hbWUpIHtcbiAgICAgIGlmIChtb2R1bGVOYW1lID09PSAndHJ1ZScpXG4gICAgICAgIG1vZHVsZU5hbWUgPSB0cnVlO1xuICAgICAgZWxzZSBpZiAobW9kdWxlTmFtZSA9PT0gJ2ZhbHNlJylcbiAgICAgICAgbW9kdWxlTmFtZSA9IGZhbHNlO1xuICAgICAgZWxzZVxuICAgICAgICBtb2R1bGVOYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgY29tbWFuZE9wdGlvbnMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgfSk7XG4gICAgZmxhZ3Mub3B0aW9uKCctLW91dHB1dExhbmd1YWdlIDxlczZ8ZXM1PicsICdjb21waWxhdGlvbiB0YXJnZXQgbGFuZ3VhZ2UnLCBmdW5jdGlvbihvdXRwdXRMYW5ndWFnZSkge1xuICAgICAgaWYgKG91dHB1dExhbmd1YWdlID09PSAnZXM2JyB8fCBvdXRwdXRMYW5ndWFnZSA9PT0gJ2VzNScpXG4gICAgICAgIGNvbW1hbmRPcHRpb25zLm91dHB1dExhbmd1YWdlID0gb3V0cHV0TGFuZ3VhZ2U7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0TGFuZ3VhZ2UgbXVzdCBiZSBvbmUgb2YgZXM1LCBlczYnKTtcbiAgICB9KTtcbiAgICBmbGFncy5vcHRpb24oJy0tc291cmNlLW1hcHMgW2ZpbGV8aW5saW5lfG1lbW9yeV0nLCAnc291cmNlTWFwcyBnZW5lcmF0ZWQgdG8gZmlsZSBvciBpbmxpbmUgd2l0aCBkYXRhOiBVUkwnLCBmdW5jdGlvbih0bykge1xuICAgICAgcmV0dXJuIGNvbW1hbmRPcHRpb25zLnNvdXJjZU1hcHMgPSB0bztcbiAgICB9KTtcbiAgICBmbGFncy5vcHRpb24oJy0tc291cmNlLXJvb3QgPHRydWV8ZmFsc2V8c3RyaW5nPicsICdzb3VyY2VtYXAgc291cmNlUm9vdCB2YWx1ZS4gZmFsc2UgdG8gb21pdCwgJyArICd0cnVlIGZvciBkaXJlY3Rvcnkgb2Ygb3V0cHV0IGZpbGUuJywgZnVuY3Rpb24odG8pIHtcbiAgICAgIGlmICh0byA9PT0gJ2ZhbHNlJylcbiAgICAgICAgdG8gPSBmYWxzZTtcbiAgICAgIGVsc2UgaWYgKHRvID09PSAndHJ1ZScpXG4gICAgICAgIHRvID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjb21tYW5kT3B0aW9ucy5zb3VyY2VSb290ID0gdG87XG4gICAgfSk7XG4gICAgZmxhZ3Mub3B0aW9uKCctLWxvdy1yZXNvbHV0aW9uLXNvdXJjZS1tYXBzJywgJ0xvd2VyIHNvdXJjZU1hcHMgZ3JhbnVsYXJpdHkgdG8gb25lIG1hcHBpbmcgcGVyIG91dHB1dCBsaW5lJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29tbWFuZE9wdGlvbnMubG93UmVzb2x1dGlvblNvdXJjZU1hcCA9IHRydWU7XG4gICAgfSk7XG4gICAgZmxhZ3Mub3B0aW9uKCctLWV4cGVyaW1lbnRhbCcsICdUdXJucyBvbiBhbGwgZXhwZXJpbWVudGFsIGZlYXR1cmVzJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb21tYW5kT3B0aW9ucy5leHBlcmltZW50YWwgPSB0cnVlO1xuICAgIH0pO1xuICAgIGZsYWdzLm9wdGlvbignLS1hdHNjcmlwdCcsICdUdXJucyBvbiBhbGwgQXRTY3JpcHQgZmVhdHVyZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbW1hbmRPcHRpb25zLmF0c2NyaXB0ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhjb21tYW5kT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZGFzaGVkTmFtZSA9IHRvRGFzaENhc2UobmFtZSk7XG4gICAgICBpZiAoZmxhZ3Mub3B0aW9uRm9yKCctLScgKyBuYW1lKSB8fCBmbGFncy5vcHRpb25Gb3IoJy0tJyArIGRhc2hlZE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSBpbiBmZWF0dXJlT3B0aW9ucykge1xuICAgICAgICBmbGFncy5vcHRpb24oJy0tJyArIGRhc2hlZE5hbWUgKyAnIFt0cnVlfGZhbHNlfHBhcnNlXScsIGRlc2NyaXB0aW9uc1tuYW1lXSk7XG4gICAgICAgIGZsYWdzLm9uKGRhc2hlZE5hbWUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRPcHRpb25zLnNldE9wdGlvbkNvZXJjZWQoZGFzaGVkTmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY29tbWFuZE9wdGlvbnNbbmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgZmxhZ3Mub3B0aW9uKCctLScgKyBkYXNoZWROYW1lLCBkZXNjcmlwdGlvbnNbbmFtZV0pO1xuICAgICAgICBmbGFncy5vbihkYXNoZWROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZE9wdGlvbnMuc2V0T3B0aW9uKGRhc2hlZE5hbWUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBudWxsIGNvbW1hbmRPcHRpb24gJyArIG5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbW1hbmRPcHRpb25zLnNldERlZmF1bHRzKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgb3B0aW9uc1YwMSgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zVjAxO1xuICAgIH0sXG4gICAgZ2V0IHZlcnNpb25Mb2NrZWRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHZlcnNpb25Mb2NrZWRPcHRpb25zO1xuICAgIH0sXG4gICAgZ2V0IE9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gT3B0aW9ucztcbiAgICB9LFxuICAgIGdldCBDb21tYW5kT3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBDb21tYW5kT3B0aW9ucztcbiAgICB9LFxuICAgIGdldCB0b0Rhc2hDYXNlKCkge1xuICAgICAgcmV0dXJuIHRvRGFzaENhc2U7XG4gICAgfSxcbiAgICBnZXQgYWRkT3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBhZGRPcHRpb25zO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvd2ViTG9hZGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL3dlYkxvYWRlci5qc1wiO1xuICB2YXIgd2ViTG9hZGVyID0ge2xvYWQ6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGVycmJhY2spIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlcnI7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDQwNClcbiAgICAgICAgICAgIGVyciA9ICdGaWxlIG5vdCBmb3VuZCBcXCcnICsgdXJsICsgJ1xcJyc7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXJyID0geGhyLnN0YXR1cyArIHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgIGVycmJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGVycmJhY2soZXJyKTtcbiAgICAgIH07XG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHhociAmJiB4aHIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfX07XG4gIHJldHVybiB7Z2V0IHdlYkxvYWRlcigpIHtcbiAgICAgIHJldHVybiB3ZWJMb2FkZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvV2ViUGFnZVRyYW5zY29kZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9XZWJQYWdlVHJhbnNjb2Rlci5qc1wiO1xuICB2YXIgRXJyb3JSZXBvcnRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWwvRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvV2ViUGFnZVRyYW5zY29kZXIuanNcIikpLkVycm9yUmVwb3J0ZXI7XG4gIHZhciBDb21tYW5kT3B0aW9ucyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL09wdGlvbnMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL1dlYlBhZ2VUcmFuc2NvZGVyLmpzXCIpKS5Db21tYW5kT3B0aW9ucztcbiAgdmFyIHdlYkxvYWRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2xvYWRlci93ZWJMb2FkZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL1dlYlBhZ2VUcmFuc2NvZGVyLmpzXCIpKS53ZWJMb2FkZXI7XG4gIHZhciBzY3JpcHRTZWxlY3RvciA9ICdzY3JpcHRbdHlwZT1cIm1vZHVsZVwiXSxzY3JpcHRbdHlwZT1cInRleHQvdHJhY2V1clwiXSc7XG4gIHZhciBXZWJQYWdlVHJhbnNjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFdlYlBhZ2VUcmFuc2NvZGVyKCkge1xuICAgICAgdmFyIHVybCA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgdmFyIHRyYWNldXJPcHRpb25zID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IG5ldyBPcHRpb25zKCk7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMubnVtUGVuZGluZ18gPSAwO1xuICAgICAgdGhpcy5udW1iZXJJbmxpbmVkXyA9IDA7XG4gICAgICB0aGlzLnRyYWNldXJPcHRpb25zXyA9IHRyYWNldXJPcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoV2ViUGFnZVRyYW5zY29kZXIsIHtcbiAgICAgIGFzeW5jTG9hZF86IGZ1bmN0aW9uKHVybCwgZm5jT2ZDb250ZW50LCBvblNjcmlwdHNSZWFkeSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHRoaXMubnVtUGVuZGluZ18rKztcbiAgICAgICAgd2ViTG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnQpXG4gICAgICAgICAgICBmbmNPZkNvbnRlbnQoY29udGVudCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCcsIHVybCk7XG4gICAgICAgICAgaWYgKC0tJF9fMy5udW1QZW5kaW5nXyA8PSAwKVxuICAgICAgICAgICAgb25TY3JpcHRzUmVhZHkoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJQYWdlVHJhbnNjb2RlciBGQUlMRUQgdG8gbG9hZCAnICsgdXJsLCBlcnJvci5zdGFjayB8fCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZEZpbGVGcm9tU2NyaXB0RWxlbWVudDogZnVuY3Rpb24oc2NyaXB0RWxlbWVudCwgbmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhY2V1ck9wdGlvbnNfO1xuICAgICAgICB2YXIgZWxlbWVudE9wdGlvblN0cmluZyA9IHNjcmlwdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0cmFjZXVyT3B0aW9ucycpO1xuICAgICAgICBpZiAoZWxlbWVudE9wdGlvblN0cmluZykge1xuICAgICAgICAgIG9wdGlvbnMgPSBDb21tYW5kT3B0aW9ucy5mcm9tU3RyaW5nKGVsZW1lbnRPcHRpb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lSW5mbyA9IHtcbiAgICAgICAgICBhZGRyZXNzOiBuYW1lLFxuICAgICAgICAgIHJlZmVycmVyTmFtZTogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBtZXRhZGF0YToge3RyYWNldXJPcHRpb25zOiBvcHRpb25zfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbG9hZGluZ1Jlc3VsdDtcbiAgICAgICAgaWYgKHNjcmlwdEVsZW1lbnQudHlwZSA9PT0gJ21vZHVsZScpXG4gICAgICAgICAgbG9hZGluZ1Jlc3VsdCA9IFN5c3RlbS5tb2R1bGUoY29udGVudCwgbmFtZUluZm8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9hZGluZ1Jlc3VsdCA9IFN5c3RlbS5zY3JpcHQoY29udGVudCwgbmFtZUluZm8pO1xuICAgICAgICBsb2FkaW5nUmVzdWx0LmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvci5zdGFjayB8fCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG5leHRJbmxpbmVTY3JpcHROYW1lXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubnVtYmVySW5saW5lZF8gKz0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmlubGluZVNjcmlwdE5hbWVCYXNlXykge1xuICAgICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMudXJsLnNwbGl0KCcuJyk7XG4gICAgICAgICAgc2VnbWVudHMucG9wKCk7XG4gICAgICAgICAgdGhpcy5pbmxpbmVTY3JpcHROYW1lQmFzZV8gPSBzZWdtZW50cy5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5saW5lU2NyaXB0TmFtZUJhc2VfICsgJ19pbmxpbmVfc2NyaXB0XycgKyB0aGlzLm51bWJlcklubGluZWRfICsgJy5qcyc7XG4gICAgICB9LFxuICAgICAgYWRkRmlsZXNGcm9tU2NyaXB0RWxlbWVudHM6IGZ1bmN0aW9uKHNjcmlwdEVsZW1lbnRzLCBvblNjcmlwdHNSZWFkeSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNjcmlwdEVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNjcmlwdEVsZW1lbnQgPSBzY3JpcHRFbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAoIXNjcmlwdEVsZW1lbnQuc3JjKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmV4dElubGluZVNjcmlwdE5hbWVfKCk7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHNjcmlwdEVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmFkZEZpbGVGcm9tU2NyaXB0RWxlbWVudChzY3JpcHRFbGVtZW50LCBuYW1lLCBjb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWUkX180ID0gc2NyaXB0RWxlbWVudC5zcmM7XG4gICAgICAgICAgICB0aGlzLmFzeW5jTG9hZF8obmFtZSRfXzQsIHRoaXMuYWRkRmlsZUZyb21TY3JpcHRFbGVtZW50LmJpbmQodGhpcywgc2NyaXB0RWxlbWVudCwgbmFtZSRfXzQpLCBvblNjcmlwdHNSZWFkeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm51bVBlbmRpbmdfIDw9IDApXG4gICAgICAgICAgb25TY3JpcHRzUmVhZHkoKTtcbiAgICAgIH0sXG4gICAgICBnZXQgcmVwb3J0ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXBvcnRlcl8pIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydGVyXyA9IG5ldyBFcnJvclJlcG9ydGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVwb3J0ZXJfO1xuICAgICAgfSxcbiAgICAgIHB1dEZpbGU6IGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgdmFyIHNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdHJhY2V1ci1zcmMtdXJsJywgZmlsZS5uYW1lKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC50ZXh0Q29udGVudCA9IGZpbGUuZ2VuZXJhdGVkU291cmNlO1xuICAgICAgICB2YXIgcGFyZW50ID0gZmlsZS5zY3JpcHRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc2NyaXB0RWxlbWVudCwgZmlsZS5zY3JpcHRFbGVtZW50IHx8IG51bGwpO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdEFuZFByb2Nlc3NTY3JpcHRzOiBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHNjcmlwdFNlbGVjdG9yO1xuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIXNjcmlwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEZpbGVzRnJvbVNjcmlwdEVsZW1lbnRzKHNjcmlwdHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcnVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBhcmd1bWVudHNbMF0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVhZHkgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgICAgICBpZiAocmVhZHkgPT09ICdjb21wbGV0ZScgfHwgcmVhZHkgPT09ICdsb2FkZWQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RBbmRQcm9jZXNzU2NyaXB0cyhkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gJF9fMy5zZWxlY3RBbmRQcm9jZXNzU2NyaXB0cyhkb25lKTtcbiAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgc2NyaXB0U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gc2NyaXB0U2VsZWN0b3I7XG4gICAgfSxcbiAgICBnZXQgV2ViUGFnZVRyYW5zY29kZXIoKSB7XG4gICAgICByZXR1cm4gV2ViUGFnZVRyYW5zY29kZXI7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9TdHJpbmdTZXQuanNcIjtcbiAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gIH1cbiAgdmFyIFN0cmluZ1NldCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ1NldCgpIHtcbiAgICAgIHRoaXMuc3RvcmFnZV8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3RyaW5nU2V0LCB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZV9bdmFsdWVdID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VfW3ZhbHVlXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZV9bdmFsdWVdO1xuICAgICAgfSxcbiAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBfIGluIHRoaXMuc3RvcmFnZV8pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgdmFsdWVzQXNBcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0b3JhZ2VfKTtcbiAgICAgIH0sXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIGZvciAodmFyIHZhbHVlIGluIHRoaXMuc3RvcmFnZV8pIHtcbiAgICAgICAgICBmdW5jKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICByZXR1cm4ge2dldCBTdHJpbmdTZXQoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nU2V0O1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvU3RyaW5nTWFwLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9TdHJpbmdNYXAuanNcIjtcbiAgdmFyIFN0cmluZ1NldCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0cmluZ1NldC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9TdHJpbmdNYXAuanNcIikpLlN0cmluZ1NldDtcbiAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gIH1cbiAgdmFyIFN0cmluZ01hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0cmluZ01hcCgpIHtcbiAgICAgIHRoaXMuc3RvcmFnZV8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3RyaW5nTWFwLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0U3RyaW5nKGtleSk7XG4gICAgICAgIHRoaXMuc3RvcmFnZV9ba2V5XSA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlX1trZXldO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhrZXkpO1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlX1trZXldO1xuICAgICAgfSxcbiAgICAgIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGFzc2VydFN0cmluZyhrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlX1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAga2V5c0FzQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlXyk7XG4gICAgICB9LFxuICAgICAga2V5c0FzU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIHJldHVybiBzZXQuYWRkKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RvcmFnZV8pIHtcbiAgICAgICAgICBmdW5jKGtleSwgdGhpcy5zdG9yYWdlX1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICByZXR1cm4ge2dldCBTdHJpbmdNYXAoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nTWFwO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL0hUTUxJbXBvcnRUcmFuc2NvZGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvSFRNTEltcG9ydFRyYW5zY29kZXIuanNcIjtcbiAgdmFyIFN0cmluZ01hcCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWwvU3RyaW5nTWFwLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9IVE1MSW1wb3J0VHJhbnNjb2Rlci5qc1wiKSkuU3RyaW5nTWFwO1xuICB2YXIgJF9fNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1dlYlBhZ2VUcmFuc2NvZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9IVE1MSW1wb3J0VHJhbnNjb2Rlci5qc1wiKSksXG4gICAgICBXZWJQYWdlVHJhbnNjb2RlciA9ICRfXzQuV2ViUGFnZVRyYW5zY29kZXIsXG4gICAgICBzY3JpcHRTZWxlY3RvciA9ICRfXzQuc2NyaXB0U2VsZWN0b3I7XG4gIHZhciBpbXBvcnRTZWxlY3RvciA9ICdsaW5rW3JlbD1pbXBvcnRdW2hyZWZdJztcbiAgdmFyIEhUTUxJbXBvcnRUcmFuc2NvZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSFRNTEltcG9ydFRyYW5zY29kZXIoKSB7XG4gICAgICB0aGlzLmltcG9ydHNUb1Byb2Nlc3NfID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShIVE1MSW1wb3J0VHJhbnNjb2Rlciwge1xuICAgICAgZmluZEFsbENoaWxkcmVuSFRNTEltcG9ydHNfOiBmdW5jdGlvbihwYXJlbnRJbXBvcnROb2Rlcykge1xuICAgICAgICB2YXIgZm91bmRJbXBvcnROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBwYXJlbnRJbmRleCA9IDA7IHBhcmVudEluZGV4IDwgcGFyZW50SW1wb3J0Tm9kZXMubGVuZ3RoOyBwYXJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudExpbmsgPSBwYXJlbnRJbXBvcnROb2Rlc1twYXJlbnRJbmRleF07XG4gICAgICAgICAgdmFyIGNoaWxkSW1wb3J0Tm9kZXMgPSBwYXJlbnRMaW5rLmltcG9ydC5xdWVyeVNlbGVjdG9yQWxsKGltcG9ydFNlbGVjdG9yKTtcbiAgICAgICAgICBpZiAoY2hpbGRJbXBvcnROb2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhpcy5maW5kQWxsQ2hpbGRyZW5IVE1MSW1wb3J0c18oY2hpbGRJbXBvcnROb2Rlcyk7XG4gICAgICAgICAgdGhpcy5pbXBvcnRzVG9Qcm9jZXNzXy5wdXNoKHBhcmVudExpbmspO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmlsdGVySFRNTEltcG9ydHNfOiBmdW5jdGlvbihpbXBvcnROb2Rlcykge1xuICAgICAgICB0aGlzLmZpbmRBbGxDaGlsZHJlbkhUTUxJbXBvcnRzXyhpbXBvcnROb2Rlcyk7XG4gICAgICAgIHZhciBpbXBvcnRzVG9QYXJzZSA9IFtdO1xuICAgICAgICB2YXIgZHVwRmlsdGVyTWFwID0gbmV3IFN0cmluZ01hcCgpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbXBvcnRzVG9Qcm9jZXNzXy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgcHJvY2Vzc0xpbmsgPSB0aGlzLmltcG9ydHNUb1Byb2Nlc3NfW2luZGV4XTtcbiAgICAgICAgICBpZiAoIWR1cEZpbHRlck1hcC5oYXMocHJvY2Vzc0xpbmsuaHJlZikpIHtcbiAgICAgICAgICAgIGR1cEZpbHRlck1hcC5zZXQocHJvY2Vzc0xpbmsuaHJlZiwgMCk7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IHByb2Nlc3NMaW5rLmltcG9ydC5xdWVyeVNlbGVjdG9yQWxsKHNjcmlwdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChzY3JpcHRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgIGltcG9ydHNUb1BhcnNlLnB1c2goe1xuICAgICAgICAgICAgICAgIGhyZWY6IHByb2Nlc3NMaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgc2NyaXB0czogc2NyaXB0c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXBvcnRzVG9Qcm9jZXNzXyA9IFtdO1xuICAgICAgICByZXR1cm4gaW1wb3J0c1RvUGFyc2U7XG4gICAgICB9LFxuICAgICAgc2VsZWN0QW5kUHJvY2Vzc0hUTUxJbXBvcnRzOiBmdW5jdGlvbihpbXBvcnROb2RlcywgZG9uZSkge1xuICAgICAgICB2YXIgaW1wb3J0SW5mb0xpc3QgPSB0aGlzLmZpbHRlckhUTUxJbXBvcnRzXyhpbXBvcnROb2Rlcyk7XG4gICAgICAgIGlmIChpbXBvcnRJbmZvTGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB2YXIgcHJvY2Vzc0NvdW50ID0gaW1wb3J0SW5mb0xpc3QubGVuZ3RoO1xuICAgICAgICBpbXBvcnRJbmZvTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGltcG9ydEluZm8pIHtcbiAgICAgICAgICB2YXIgdHJhbnNjb2RlciA9IG5ldyBXZWJQYWdlVHJhbnNjb2RlcihpbXBvcnRJbmZvLmhyZWYpO1xuICAgICAgICAgIHRyYW5zY29kZXIuYWRkRmlsZXNGcm9tU2NyaXB0RWxlbWVudHMoaW1wb3J0SW5mby5zY3JpcHRzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NDb3VudCA9PT0gMCAmJiBkb25lKVxuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb25lID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uKCkge307XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgdmFyIHJlYWR5ID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgICAgaWYgKHJlYWR5ID09PSAnY29tcGxldGUnIHx8IHJlYWR5ID09PSAnbG9hZGVkJykge1xuICAgICAgICAgIHZhciBpbXBvcnROb2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoaW1wb3J0U2VsZWN0b3IpO1xuICAgICAgICAgIGlmIChpbXBvcnROb2Rlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbmRQcm9jZXNzSFRNTEltcG9ydHMoaW1wb3J0Tm9kZXMsIGRvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0hUTUxJbXBvcnRzTG9hZGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpbXBvcnROb2RlcyA9IGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwuYWxsSW1wb3J0cyA/IGV2ZW50LmRldGFpbC5hbGxJbXBvcnRzIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChpbXBvcnRTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoaW1wb3J0Tm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgJF9fMi5zZWxlY3RBbmRQcm9jZXNzSFRNTEltcG9ydHMoaW1wb3J0Tm9kZXMsIGRvbmUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIHJldHVybiB7Z2V0IEhUTUxJbXBvcnRUcmFuc2NvZGVyKCkge1xuICAgICAgcmV0dXJuIEhUTUxJbXBvcnRUcmFuc2NvZGVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL0NvbGxlY3RpbmdFcnJvclJlcG9ydGVyLmpzXCI7XG4gIHZhciBFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9Db2xsZWN0aW5nRXJyb3JSZXBvcnRlci5qc1wiKSkuRXJyb3JSZXBvcnRlcjtcbiAgdmFyIE11bHRpcGxlRXJyb3JzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBNdWx0aXBsZUVycm9ycyhlcnJvcnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE11bHRpcGxlRXJyb3JzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzID8gZXJyb3JzLmpvaW4oJ1xcbicpIDogJyc7XG4gICAgICB0aGlzLm5hbWUgPSAnTXVsdGlwbGVFcnJvcnMnO1xuICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNdWx0aXBsZUVycm9ycywge30sIHt9LCAkX19zdXBlcik7XG4gIH0oRXJyb3IpO1xuICB2YXIgQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvbGxlY3RpbmdFcnJvclJlcG9ydGVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIsIHtcbiAgICAgIHJlcG9ydE1lc3NhZ2VJbnRlcm5hbDogZnVuY3Rpb24obG9jYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCgobG9jYXRpb24uc3RhcnQgKyBcIjogXCIgKyBtZXNzYWdlKSk7XG4gICAgICB9LFxuICAgICAgZXJyb3JzQXNTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0Vycm9yKCkubWVzc2FnZTtcbiAgICAgIH0sXG4gICAgICB0b0Vycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aXBsZUVycm9ycyh0aGlzLmVycm9ycyk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShFcnJvclJlcG9ydGVyKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgTXVsdGlwbGVFcnJvcnMoKSB7XG4gICAgICByZXR1cm4gTXVsdGlwbGVFcnJvcnM7XG4gICAgfSxcbiAgICBnZXQgQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIoKSB7XG4gICAgICByZXR1cm4gQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXI7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwtaW1wb3J0cy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwtaW1wb3J0cy5qc1wiO1xuICAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91dGlsL011dGVkRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC1pbXBvcnRzLmpzXCIpKTtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfV2ViUGFnZVRyYW5zY29kZXJfNDZfanNfXyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1dlYlBhZ2VUcmFuc2NvZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsLWltcG9ydHMuanNcIikpO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19IVE1MSW1wb3J0VHJhbnNjb2Rlcl80Nl9qc19fID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSFRNTEltcG9ydFRyYW5zY29kZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwtaW1wb3J0cy5qc1wiKSk7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vT3B0aW9ucy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC1pbXBvcnRzLmpzXCIpKSxcbiAgICAgIGFkZE9wdGlvbnMgPSAkX18xLmFkZE9wdGlvbnMsXG4gICAgICBDb21tYW5kT3B0aW9ucyA9ICRfXzEuQ29tbWFuZE9wdGlvbnMsXG4gICAgICBPcHRpb25zID0gJF9fMS5PcHRpb25zO1xuICB2YXIgRXJyb3JSZXBvcnRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWwvRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC1pbXBvcnRzLmpzXCIpKS5FcnJvclJlcG9ydGVyO1xuICB2YXIgQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91dGlsL0NvbGxlY3RpbmdFcnJvclJlcG9ydGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsLWltcG9ydHMuanNcIikpLkNvbGxlY3RpbmdFcnJvclJlcG9ydGVyO1xuICB2YXIgdXRpbCA9IHtcbiAgICBhZGRPcHRpb25zOiBhZGRPcHRpb25zLFxuICAgIENvbW1hbmRPcHRpb25zOiBDb21tYW5kT3B0aW9ucyxcbiAgICBDb2xsZWN0aW5nRXJyb3JSZXBvcnRlcjogQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIsXG4gICAgRXJyb3JSZXBvcnRlcjogRXJyb3JSZXBvcnRlcixcbiAgICBPcHRpb25zOiBPcHRpb25zXG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0IFdlYlBhZ2VUcmFuc2NvZGVyKCkge1xuICAgICAgcmV0dXJuICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfV2ViUGFnZVRyYW5zY29kZXJfNDZfanNfXy5XZWJQYWdlVHJhbnNjb2RlcjtcbiAgICB9LFxuICAgIGdldCBIVE1MSW1wb3J0VHJhbnNjb2RlcigpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X0hUTUxJbXBvcnRUcmFuc2NvZGVyXzQ2X2pzX18uSFRNTEltcG9ydFRyYW5zY29kZXI7XG4gICAgfSxcbiAgICBnZXQgdXRpbCgpIHtcbiAgICAgIHJldHVybiB1dGlsO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCI7XG4gIHZhciBBTk5PVEFUSU9OID0gJ0FOTk9UQVRJT04nO1xuICB2YXIgQU5PTl9CTE9DSyA9ICdBTk9OX0JMT0NLJztcbiAgdmFyIEFSR1VNRU5UX0xJU1QgPSAnQVJHVU1FTlRfTElTVCc7XG4gIHZhciBBUlJBWV9DT01QUkVIRU5TSU9OID0gJ0FSUkFZX0NPTVBSRUhFTlNJT04nO1xuICB2YXIgQVJSQVlfTElURVJBTCA9ICdBUlJBWV9MSVRFUkFMJztcbiAgdmFyIEFSUkFZX1BBVFRFUk4gPSAnQVJSQVlfUEFUVEVSTic7XG4gIHZhciBBUlJBWV9UWVBFID0gJ0FSUkFZX1RZUEUnO1xuICB2YXIgQVJST1dfRlVOQ1RJT04gPSAnQVJST1dfRlVOQ1RJT04nO1xuICB2YXIgQVNTSUdOTUVOVF9FTEVNRU5UID0gJ0FTU0lHTk1FTlRfRUxFTUVOVCc7XG4gIHZhciBBV0FJVF9FWFBSRVNTSU9OID0gJ0FXQUlUX0VYUFJFU1NJT04nO1xuICB2YXIgQklOQVJZX0VYUFJFU1NJT04gPSAnQklOQVJZX0VYUFJFU1NJT04nO1xuICB2YXIgQklORElOR19FTEVNRU5UID0gJ0JJTkRJTkdfRUxFTUVOVCc7XG4gIHZhciBCSU5ESU5HX0lERU5USUZJRVIgPSAnQklORElOR19JREVOVElGSUVSJztcbiAgdmFyIEJMT0NLID0gJ0JMT0NLJztcbiAgdmFyIEJSRUFLX1NUQVRFTUVOVCA9ICdCUkVBS19TVEFURU1FTlQnO1xuICB2YXIgQ0FMTF9FWFBSRVNTSU9OID0gJ0NBTExfRVhQUkVTU0lPTic7XG4gIHZhciBDQUxMX1NJR05BVFVSRSA9ICdDQUxMX1NJR05BVFVSRSc7XG4gIHZhciBDQVNFX0NMQVVTRSA9ICdDQVNFX0NMQVVTRSc7XG4gIHZhciBDQVRDSCA9ICdDQVRDSCc7XG4gIHZhciBDTEFTU19ERUNMQVJBVElPTiA9ICdDTEFTU19ERUNMQVJBVElPTic7XG4gIHZhciBDTEFTU19FWFBSRVNTSU9OID0gJ0NMQVNTX0VYUFJFU1NJT04nO1xuICB2YXIgQ09NTUFfRVhQUkVTU0lPTiA9ICdDT01NQV9FWFBSRVNTSU9OJztcbiAgdmFyIENPTVBSRUhFTlNJT05fRk9SID0gJ0NPTVBSRUhFTlNJT05fRk9SJztcbiAgdmFyIENPTVBSRUhFTlNJT05fSUYgPSAnQ09NUFJFSEVOU0lPTl9JRic7XG4gIHZhciBDT01QVVRFRF9QUk9QRVJUWV9OQU1FID0gJ0NPTVBVVEVEX1BST1BFUlRZX05BTUUnO1xuICB2YXIgQ09ORElUSU9OQUxfRVhQUkVTU0lPTiA9ICdDT05ESVRJT05BTF9FWFBSRVNTSU9OJztcbiAgdmFyIENPTlNUUlVDVF9TSUdOQVRVUkUgPSAnQ09OU1RSVUNUX1NJR05BVFVSRSc7XG4gIHZhciBDT05TVFJVQ1RPUl9UWVBFID0gJ0NPTlNUUlVDVE9SX1RZUEUnO1xuICB2YXIgQ09OVElOVUVfU1RBVEVNRU5UID0gJ0NPTlRJTlVFX1NUQVRFTUVOVCc7XG4gIHZhciBDT1ZFUl9GT1JNQUxTID0gJ0NPVkVSX0ZPUk1BTFMnO1xuICB2YXIgQ09WRVJfSU5JVElBTElaRURfTkFNRSA9ICdDT1ZFUl9JTklUSUFMSVpFRF9OQU1FJztcbiAgdmFyIERFQlVHR0VSX1NUQVRFTUVOVCA9ICdERUJVR0dFUl9TVEFURU1FTlQnO1xuICB2YXIgREVGQVVMVF9DTEFVU0UgPSAnREVGQVVMVF9DTEFVU0UnO1xuICB2YXIgRE9fV0hJTEVfU1RBVEVNRU5UID0gJ0RPX1dISUxFX1NUQVRFTUVOVCc7XG4gIHZhciBFTVBUWV9TVEFURU1FTlQgPSAnRU1QVFlfU1RBVEVNRU5UJztcbiAgdmFyIEVYUE9SVF9ERUNMQVJBVElPTiA9ICdFWFBPUlRfREVDTEFSQVRJT04nO1xuICB2YXIgRVhQT1JUX0RFRkFVTFQgPSAnRVhQT1JUX0RFRkFVTFQnO1xuICB2YXIgRVhQT1JUX1NQRUNJRklFUiA9ICdFWFBPUlRfU1BFQ0lGSUVSJztcbiAgdmFyIEVYUE9SVF9TUEVDSUZJRVJfU0VUID0gJ0VYUE9SVF9TUEVDSUZJRVJfU0VUJztcbiAgdmFyIEVYUE9SVF9TVEFSID0gJ0VYUE9SVF9TVEFSJztcbiAgdmFyIEVYUFJFU1NJT05fU1RBVEVNRU5UID0gJ0VYUFJFU1NJT05fU1RBVEVNRU5UJztcbiAgdmFyIEZJTkFMTFkgPSAnRklOQUxMWSc7XG4gIHZhciBGT1JfSU5fU1RBVEVNRU5UID0gJ0ZPUl9JTl9TVEFURU1FTlQnO1xuICB2YXIgRk9SX09GX1NUQVRFTUVOVCA9ICdGT1JfT0ZfU1RBVEVNRU5UJztcbiAgdmFyIEZPUl9PTl9TVEFURU1FTlQgPSAnRk9SX09OX1NUQVRFTUVOVCc7XG4gIHZhciBGT1JfU1RBVEVNRU5UID0gJ0ZPUl9TVEFURU1FTlQnO1xuICB2YXIgRk9STUFMX1BBUkFNRVRFUiA9ICdGT1JNQUxfUEFSQU1FVEVSJztcbiAgdmFyIEZPUk1BTF9QQVJBTUVURVJfTElTVCA9ICdGT1JNQUxfUEFSQU1FVEVSX0xJU1QnO1xuICB2YXIgRk9SV0FSRF9ERUZBVUxUX0VYUE9SVCA9ICdGT1JXQVJEX0RFRkFVTFRfRVhQT1JUJztcbiAgdmFyIEZVTkNUSU9OX0JPRFkgPSAnRlVOQ1RJT05fQk9EWSc7XG4gIHZhciBGVU5DVElPTl9ERUNMQVJBVElPTiA9ICdGVU5DVElPTl9ERUNMQVJBVElPTic7XG4gIHZhciBGVU5DVElPTl9FWFBSRVNTSU9OID0gJ0ZVTkNUSU9OX0VYUFJFU1NJT04nO1xuICB2YXIgRlVOQ1RJT05fVFlQRSA9ICdGVU5DVElPTl9UWVBFJztcbiAgdmFyIEdFTkVSQVRPUl9DT01QUkVIRU5TSU9OID0gJ0dFTkVSQVRPUl9DT01QUkVIRU5TSU9OJztcbiAgdmFyIEdFVF9BQ0NFU1NPUiA9ICdHRVRfQUNDRVNTT1InO1xuICB2YXIgSURFTlRJRklFUl9FWFBSRVNTSU9OID0gJ0lERU5USUZJRVJfRVhQUkVTU0lPTic7XG4gIHZhciBJRl9TVEFURU1FTlQgPSAnSUZfU1RBVEVNRU5UJztcbiAgdmFyIElNUE9SVF9DTEFVU0VfUEFJUiA9ICdJTVBPUlRfQ0xBVVNFX1BBSVInO1xuICB2YXIgSU1QT1JUX0RFQ0xBUkFUSU9OID0gJ0lNUE9SVF9ERUNMQVJBVElPTic7XG4gIHZhciBJTVBPUlRfU1BFQ0lGSUVSID0gJ0lNUE9SVF9TUEVDSUZJRVInO1xuICB2YXIgSU1QT1JUX1NQRUNJRklFUl9TRVQgPSAnSU1QT1JUX1NQRUNJRklFUl9TRVQnO1xuICB2YXIgSU1QT1JUX1RZUEVfQ0xBVVNFID0gJ0lNUE9SVF9UWVBFX0NMQVVTRSc7XG4gIHZhciBJTVBPUlRFRF9CSU5ESU5HID0gJ0lNUE9SVEVEX0JJTkRJTkcnO1xuICB2YXIgSU5ERVhfU0lHTkFUVVJFID0gJ0lOREVYX1NJR05BVFVSRSc7XG4gIHZhciBJTlRFUkZBQ0VfREVDTEFSQVRJT04gPSAnSU5URVJGQUNFX0RFQ0xBUkFUSU9OJztcbiAgdmFyIEpTWF9BVFRSSUJVVEUgPSAnSlNYX0FUVFJJQlVURSc7XG4gIHZhciBKU1hfRUxFTUVOVCA9ICdKU1hfRUxFTUVOVCc7XG4gIHZhciBKU1hfRUxFTUVOVF9OQU1FID0gJ0pTWF9FTEVNRU5UX05BTUUnO1xuICB2YXIgSlNYX1BMQUNFSE9MREVSID0gJ0pTWF9QTEFDRUhPTERFUic7XG4gIHZhciBKU1hfU1BSRUFEX0FUVFJJQlVURSA9ICdKU1hfU1BSRUFEX0FUVFJJQlVURSc7XG4gIHZhciBKU1hfVEVYVCA9ICdKU1hfVEVYVCc7XG4gIHZhciBMQUJFTExFRF9TVEFURU1FTlQgPSAnTEFCRUxMRURfU1RBVEVNRU5UJztcbiAgdmFyIExJVEVSQUxfRVhQUkVTU0lPTiA9ICdMSVRFUkFMX0VYUFJFU1NJT04nO1xuICB2YXIgTElURVJBTF9QUk9QRVJUWV9OQU1FID0gJ0xJVEVSQUxfUFJPUEVSVFlfTkFNRSc7XG4gIHZhciBNRU1CRVJfRVhQUkVTU0lPTiA9ICdNRU1CRVJfRVhQUkVTU0lPTic7XG4gIHZhciBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPSAnTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OJztcbiAgdmFyIE1FVEhPRCA9ICdNRVRIT0QnO1xuICB2YXIgTUVUSE9EX1NJR05BVFVSRSA9ICdNRVRIT0RfU0lHTkFUVVJFJztcbiAgdmFyIE1PRFVMRSA9ICdNT0RVTEUnO1xuICB2YXIgTU9EVUxFX1NQRUNJRklFUiA9ICdNT0RVTEVfU1BFQ0lGSUVSJztcbiAgdmFyIE5BTUVfU1BBQ0VfRVhQT1JUID0gJ05BTUVfU1BBQ0VfRVhQT1JUJztcbiAgdmFyIE5BTUVfU1BBQ0VfSU1QT1JUID0gJ05BTUVfU1BBQ0VfSU1QT1JUJztcbiAgdmFyIE5BTUVEX0VYUE9SVCA9ICdOQU1FRF9FWFBPUlQnO1xuICB2YXIgTkVXX0VYUFJFU1NJT04gPSAnTkVXX0VYUFJFU1NJT04nO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSAnT0JKRUNUX0xJVEVSQUwnO1xuICB2YXIgT0JKRUNUX1BBVFRFUk4gPSAnT0JKRUNUX1BBVFRFUk4nO1xuICB2YXIgT0JKRUNUX1BBVFRFUk5fRklFTEQgPSAnT0JKRUNUX1BBVFRFUk5fRklFTEQnO1xuICB2YXIgT0JKRUNUX1RZUEUgPSAnT0JKRUNUX1RZUEUnO1xuICB2YXIgUEFSRU5fRVhQUkVTU0lPTiA9ICdQQVJFTl9FWFBSRVNTSU9OJztcbiAgdmFyIFBPU1RGSVhfRVhQUkVTU0lPTiA9ICdQT1NURklYX0VYUFJFU1NJT04nO1xuICB2YXIgUFJFREVGSU5FRF9UWVBFID0gJ1BSRURFRklORURfVFlQRSc7XG4gIHZhciBQUk9QRVJUWV9OQU1FX0FTU0lHTk1FTlQgPSAnUFJPUEVSVFlfTkFNRV9BU1NJR05NRU5UJztcbiAgdmFyIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EID0gJ1BST1BFUlRZX05BTUVfU0hPUlRIQU5EJztcbiAgdmFyIFBST1BFUlRZX1NJR05BVFVSRSA9ICdQUk9QRVJUWV9TSUdOQVRVUkUnO1xuICB2YXIgUFJPUEVSVFlfVkFSSUFCTEVfREVDTEFSQVRJT04gPSAnUFJPUEVSVFlfVkFSSUFCTEVfREVDTEFSQVRJT04nO1xuICB2YXIgUkVTVF9QQVJBTUVURVIgPSAnUkVTVF9QQVJBTUVURVInO1xuICB2YXIgUkVUVVJOX1NUQVRFTUVOVCA9ICdSRVRVUk5fU1RBVEVNRU5UJztcbiAgdmFyIFNDUklQVCA9ICdTQ1JJUFQnO1xuICB2YXIgU0VUX0FDQ0VTU09SID0gJ1NFVF9BQ0NFU1NPUic7XG4gIHZhciBTUFJFQURfRVhQUkVTU0lPTiA9ICdTUFJFQURfRVhQUkVTU0lPTic7XG4gIHZhciBTUFJFQURfUEFUVEVSTl9FTEVNRU5UID0gJ1NQUkVBRF9QQVRURVJOX0VMRU1FTlQnO1xuICB2YXIgU1RBVEVfTUFDSElORSA9ICdTVEFURV9NQUNISU5FJztcbiAgdmFyIFNVUEVSX0VYUFJFU1NJT04gPSAnU1VQRVJfRVhQUkVTU0lPTic7XG4gIHZhciBTV0lUQ0hfU1RBVEVNRU5UID0gJ1NXSVRDSF9TVEFURU1FTlQnO1xuICB2YXIgU1lOVEFYX0VSUk9SX1RSRUUgPSAnU1lOVEFYX0VSUk9SX1RSRUUnO1xuICB2YXIgVEVNUExBVEVfTElURVJBTF9FWFBSRVNTSU9OID0gJ1RFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTic7XG4gIHZhciBURU1QTEFURV9MSVRFUkFMX1BPUlRJT04gPSAnVEVNUExBVEVfTElURVJBTF9QT1JUSU9OJztcbiAgdmFyIFRFTVBMQVRFX1NVQlNUSVRVVElPTiA9ICdURU1QTEFURV9TVUJTVElUVVRJT04nO1xuICB2YXIgVEhJU19FWFBSRVNTSU9OID0gJ1RISVNfRVhQUkVTU0lPTic7XG4gIHZhciBUSFJPV19TVEFURU1FTlQgPSAnVEhST1dfU1RBVEVNRU5UJztcbiAgdmFyIFRSWV9TVEFURU1FTlQgPSAnVFJZX1NUQVRFTUVOVCc7XG4gIHZhciBUWVBFX0FMSUFTX0RFQ0xBUkFUSU9OID0gJ1RZUEVfQUxJQVNfREVDTEFSQVRJT04nO1xuICB2YXIgVFlQRV9BUkdVTUVOVFMgPSAnVFlQRV9BUkdVTUVOVFMnO1xuICB2YXIgVFlQRV9OQU1FID0gJ1RZUEVfTkFNRSc7XG4gIHZhciBUWVBFX1BBUkFNRVRFUiA9ICdUWVBFX1BBUkFNRVRFUic7XG4gIHZhciBUWVBFX1BBUkFNRVRFUlMgPSAnVFlQRV9QQVJBTUVURVJTJztcbiAgdmFyIFRZUEVfUkVGRVJFTkNFID0gJ1RZUEVfUkVGRVJFTkNFJztcbiAgdmFyIFVOQVJZX0VYUFJFU1NJT04gPSAnVU5BUllfRVhQUkVTU0lPTic7XG4gIHZhciBVTklPTl9UWVBFID0gJ1VOSU9OX1RZUEUnO1xuICB2YXIgVkFSSUFCTEVfREVDTEFSQVRJT04gPSAnVkFSSUFCTEVfREVDTEFSQVRJT04nO1xuICB2YXIgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCA9ICdWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUJztcbiAgdmFyIFZBUklBQkxFX1NUQVRFTUVOVCA9ICdWQVJJQUJMRV9TVEFURU1FTlQnO1xuICB2YXIgV0hJTEVfU1RBVEVNRU5UID0gJ1dISUxFX1NUQVRFTUVOVCc7XG4gIHZhciBXSVRIX1NUQVRFTUVOVCA9ICdXSVRIX1NUQVRFTUVOVCc7XG4gIHZhciBZSUVMRF9FWFBSRVNTSU9OID0gJ1lJRUxEX0VYUFJFU1NJT04nO1xuICByZXR1cm4ge1xuICAgIGdldCBBTk5PVEFUSU9OKCkge1xuICAgICAgcmV0dXJuIEFOTk9UQVRJT047XG4gICAgfSxcbiAgICBnZXQgQU5PTl9CTE9DSygpIHtcbiAgICAgIHJldHVybiBBTk9OX0JMT0NLO1xuICAgIH0sXG4gICAgZ2V0IEFSR1VNRU5UX0xJU1QoKSB7XG4gICAgICByZXR1cm4gQVJHVU1FTlRfTElTVDtcbiAgICB9LFxuICAgIGdldCBBUlJBWV9DT01QUkVIRU5TSU9OKCkge1xuICAgICAgcmV0dXJuIEFSUkFZX0NPTVBSRUhFTlNJT047XG4gICAgfSxcbiAgICBnZXQgQVJSQVlfTElURVJBTCgpIHtcbiAgICAgIHJldHVybiBBUlJBWV9MSVRFUkFMO1xuICAgIH0sXG4gICAgZ2V0IEFSUkFZX1BBVFRFUk4oKSB7XG4gICAgICByZXR1cm4gQVJSQVlfUEFUVEVSTjtcbiAgICB9LFxuICAgIGdldCBBUlJBWV9UWVBFKCkge1xuICAgICAgcmV0dXJuIEFSUkFZX1RZUEU7XG4gICAgfSxcbiAgICBnZXQgQVJST1dfRlVOQ1RJT04oKSB7XG4gICAgICByZXR1cm4gQVJST1dfRlVOQ1RJT047XG4gICAgfSxcbiAgICBnZXQgQVNTSUdOTUVOVF9FTEVNRU5UKCkge1xuICAgICAgcmV0dXJuIEFTU0lHTk1FTlRfRUxFTUVOVDtcbiAgICB9LFxuICAgIGdldCBBV0FJVF9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIEFXQUlUX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgQklOQVJZX0VYUFJFU1NJT04oKSB7XG4gICAgICByZXR1cm4gQklOQVJZX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgQklORElOR19FTEVNRU5UKCkge1xuICAgICAgcmV0dXJuIEJJTkRJTkdfRUxFTUVOVDtcbiAgICB9LFxuICAgIGdldCBCSU5ESU5HX0lERU5USUZJRVIoKSB7XG4gICAgICByZXR1cm4gQklORElOR19JREVOVElGSUVSO1xuICAgIH0sXG4gICAgZ2V0IEJMT0NLKCkge1xuICAgICAgcmV0dXJuIEJMT0NLO1xuICAgIH0sXG4gICAgZ2V0IEJSRUFLX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBCUkVBS19TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgQ0FMTF9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIENBTExfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBDQUxMX1NJR05BVFVSRSgpIHtcbiAgICAgIHJldHVybiBDQUxMX1NJR05BVFVSRTtcbiAgICB9LFxuICAgIGdldCBDQVNFX0NMQVVTRSgpIHtcbiAgICAgIHJldHVybiBDQVNFX0NMQVVTRTtcbiAgICB9LFxuICAgIGdldCBDQVRDSCgpIHtcbiAgICAgIHJldHVybiBDQVRDSDtcbiAgICB9LFxuICAgIGdldCBDTEFTU19ERUNMQVJBVElPTigpIHtcbiAgICAgIHJldHVybiBDTEFTU19ERUNMQVJBVElPTjtcbiAgICB9LFxuICAgIGdldCBDTEFTU19FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIENMQVNTX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgQ09NTUFfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBDT01NQV9FWFBSRVNTSU9OO1xuICAgIH0sXG4gICAgZ2V0IENPTVBSRUhFTlNJT05fRk9SKCkge1xuICAgICAgcmV0dXJuIENPTVBSRUhFTlNJT05fRk9SO1xuICAgIH0sXG4gICAgZ2V0IENPTVBSRUhFTlNJT05fSUYoKSB7XG4gICAgICByZXR1cm4gQ09NUFJFSEVOU0lPTl9JRjtcbiAgICB9LFxuICAgIGdldCBDT01QVVRFRF9QUk9QRVJUWV9OQU1FKCkge1xuICAgICAgcmV0dXJuIENPTVBVVEVEX1BST1BFUlRZX05BTUU7XG4gICAgfSxcbiAgICBnZXQgQ09ORElUSU9OQUxfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBDT05ESVRJT05BTF9FWFBSRVNTSU9OO1xuICAgIH0sXG4gICAgZ2V0IENPTlNUUlVDVF9TSUdOQVRVUkUoKSB7XG4gICAgICByZXR1cm4gQ09OU1RSVUNUX1NJR05BVFVSRTtcbiAgICB9LFxuICAgIGdldCBDT05TVFJVQ1RPUl9UWVBFKCkge1xuICAgICAgcmV0dXJuIENPTlNUUlVDVE9SX1RZUEU7XG4gICAgfSxcbiAgICBnZXQgQ09OVElOVUVfU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIENPTlRJTlVFX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBDT1ZFUl9GT1JNQUxTKCkge1xuICAgICAgcmV0dXJuIENPVkVSX0ZPUk1BTFM7XG4gICAgfSxcbiAgICBnZXQgQ09WRVJfSU5JVElBTElaRURfTkFNRSgpIHtcbiAgICAgIHJldHVybiBDT1ZFUl9JTklUSUFMSVpFRF9OQU1FO1xuICAgIH0sXG4gICAgZ2V0IERFQlVHR0VSX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBERUJVR0dFUl9TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgREVGQVVMVF9DTEFVU0UoKSB7XG4gICAgICByZXR1cm4gREVGQVVMVF9DTEFVU0U7XG4gICAgfSxcbiAgICBnZXQgRE9fV0hJTEVfU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIERPX1dISUxFX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBFTVBUWV9TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gRU1QVFlfU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IEVYUE9SVF9ERUNMQVJBVElPTigpIHtcbiAgICAgIHJldHVybiBFWFBPUlRfREVDTEFSQVRJT047XG4gICAgfSxcbiAgICBnZXQgRVhQT1JUX0RFRkFVTFQoKSB7XG4gICAgICByZXR1cm4gRVhQT1JUX0RFRkFVTFQ7XG4gICAgfSxcbiAgICBnZXQgRVhQT1JUX1NQRUNJRklFUigpIHtcbiAgICAgIHJldHVybiBFWFBPUlRfU1BFQ0lGSUVSO1xuICAgIH0sXG4gICAgZ2V0IEVYUE9SVF9TUEVDSUZJRVJfU0VUKCkge1xuICAgICAgcmV0dXJuIEVYUE9SVF9TUEVDSUZJRVJfU0VUO1xuICAgIH0sXG4gICAgZ2V0IEVYUE9SVF9TVEFSKCkge1xuICAgICAgcmV0dXJuIEVYUE9SVF9TVEFSO1xuICAgIH0sXG4gICAgZ2V0IEVYUFJFU1NJT05fU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIEVYUFJFU1NJT05fU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IEZJTkFMTFkoKSB7XG4gICAgICByZXR1cm4gRklOQUxMWTtcbiAgICB9LFxuICAgIGdldCBGT1JfSU5fU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIEZPUl9JTl9TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgRk9SX09GX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBGT1JfT0ZfU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IEZPUl9PTl9TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gRk9SX09OX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBGT1JfU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIEZPUl9TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgRk9STUFMX1BBUkFNRVRFUigpIHtcbiAgICAgIHJldHVybiBGT1JNQUxfUEFSQU1FVEVSO1xuICAgIH0sXG4gICAgZ2V0IEZPUk1BTF9QQVJBTUVURVJfTElTVCgpIHtcbiAgICAgIHJldHVybiBGT1JNQUxfUEFSQU1FVEVSX0xJU1Q7XG4gICAgfSxcbiAgICBnZXQgRk9SV0FSRF9ERUZBVUxUX0VYUE9SVCgpIHtcbiAgICAgIHJldHVybiBGT1JXQVJEX0RFRkFVTFRfRVhQT1JUO1xuICAgIH0sXG4gICAgZ2V0IEZVTkNUSU9OX0JPRFkoKSB7XG4gICAgICByZXR1cm4gRlVOQ1RJT05fQk9EWTtcbiAgICB9LFxuICAgIGdldCBGVU5DVElPTl9ERUNMQVJBVElPTigpIHtcbiAgICAgIHJldHVybiBGVU5DVElPTl9ERUNMQVJBVElPTjtcbiAgICB9LFxuICAgIGdldCBGVU5DVElPTl9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIEZVTkNUSU9OX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgRlVOQ1RJT05fVFlQRSgpIHtcbiAgICAgIHJldHVybiBGVU5DVElPTl9UWVBFO1xuICAgIH0sXG4gICAgZ2V0IEdFTkVSQVRPUl9DT01QUkVIRU5TSU9OKCkge1xuICAgICAgcmV0dXJuIEdFTkVSQVRPUl9DT01QUkVIRU5TSU9OO1xuICAgIH0sXG4gICAgZ2V0IEdFVF9BQ0NFU1NPUigpIHtcbiAgICAgIHJldHVybiBHRVRfQUNDRVNTT1I7XG4gICAgfSxcbiAgICBnZXQgSURFTlRJRklFUl9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIElERU5USUZJRVJfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBJRl9TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gSUZfU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IElNUE9SVF9DTEFVU0VfUEFJUigpIHtcbiAgICAgIHJldHVybiBJTVBPUlRfQ0xBVVNFX1BBSVI7XG4gICAgfSxcbiAgICBnZXQgSU1QT1JUX0RFQ0xBUkFUSU9OKCkge1xuICAgICAgcmV0dXJuIElNUE9SVF9ERUNMQVJBVElPTjtcbiAgICB9LFxuICAgIGdldCBJTVBPUlRfU1BFQ0lGSUVSKCkge1xuICAgICAgcmV0dXJuIElNUE9SVF9TUEVDSUZJRVI7XG4gICAgfSxcbiAgICBnZXQgSU1QT1JUX1NQRUNJRklFUl9TRVQoKSB7XG4gICAgICByZXR1cm4gSU1QT1JUX1NQRUNJRklFUl9TRVQ7XG4gICAgfSxcbiAgICBnZXQgSU1QT1JUX1RZUEVfQ0xBVVNFKCkge1xuICAgICAgcmV0dXJuIElNUE9SVF9UWVBFX0NMQVVTRTtcbiAgICB9LFxuICAgIGdldCBJTVBPUlRFRF9CSU5ESU5HKCkge1xuICAgICAgcmV0dXJuIElNUE9SVEVEX0JJTkRJTkc7XG4gICAgfSxcbiAgICBnZXQgSU5ERVhfU0lHTkFUVVJFKCkge1xuICAgICAgcmV0dXJuIElOREVYX1NJR05BVFVSRTtcbiAgICB9LFxuICAgIGdldCBJTlRFUkZBQ0VfREVDTEFSQVRJT04oKSB7XG4gICAgICByZXR1cm4gSU5URVJGQUNFX0RFQ0xBUkFUSU9OO1xuICAgIH0sXG4gICAgZ2V0IEpTWF9BVFRSSUJVVEUoKSB7XG4gICAgICByZXR1cm4gSlNYX0FUVFJJQlVURTtcbiAgICB9LFxuICAgIGdldCBKU1hfRUxFTUVOVCgpIHtcbiAgICAgIHJldHVybiBKU1hfRUxFTUVOVDtcbiAgICB9LFxuICAgIGdldCBKU1hfRUxFTUVOVF9OQU1FKCkge1xuICAgICAgcmV0dXJuIEpTWF9FTEVNRU5UX05BTUU7XG4gICAgfSxcbiAgICBnZXQgSlNYX1BMQUNFSE9MREVSKCkge1xuICAgICAgcmV0dXJuIEpTWF9QTEFDRUhPTERFUjtcbiAgICB9LFxuICAgIGdldCBKU1hfU1BSRUFEX0FUVFJJQlVURSgpIHtcbiAgICAgIHJldHVybiBKU1hfU1BSRUFEX0FUVFJJQlVURTtcbiAgICB9LFxuICAgIGdldCBKU1hfVEVYVCgpIHtcbiAgICAgIHJldHVybiBKU1hfVEVYVDtcbiAgICB9LFxuICAgIGdldCBMQUJFTExFRF9TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gTEFCRUxMRURfU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IExJVEVSQUxfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBMSVRFUkFMX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgTElURVJBTF9QUk9QRVJUWV9OQU1FKCkge1xuICAgICAgcmV0dXJuIExJVEVSQUxfUFJPUEVSVFlfTkFNRTtcbiAgICB9LFxuICAgIGdldCBNRU1CRVJfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBNRU1CRVJfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04oKSB7XG4gICAgICByZXR1cm4gTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OO1xuICAgIH0sXG4gICAgZ2V0IE1FVEhPRCgpIHtcbiAgICAgIHJldHVybiBNRVRIT0Q7XG4gICAgfSxcbiAgICBnZXQgTUVUSE9EX1NJR05BVFVSRSgpIHtcbiAgICAgIHJldHVybiBNRVRIT0RfU0lHTkFUVVJFO1xuICAgIH0sXG4gICAgZ2V0IE1PRFVMRSgpIHtcbiAgICAgIHJldHVybiBNT0RVTEU7XG4gICAgfSxcbiAgICBnZXQgTU9EVUxFX1NQRUNJRklFUigpIHtcbiAgICAgIHJldHVybiBNT0RVTEVfU1BFQ0lGSUVSO1xuICAgIH0sXG4gICAgZ2V0IE5BTUVfU1BBQ0VfRVhQT1JUKCkge1xuICAgICAgcmV0dXJuIE5BTUVfU1BBQ0VfRVhQT1JUO1xuICAgIH0sXG4gICAgZ2V0IE5BTUVfU1BBQ0VfSU1QT1JUKCkge1xuICAgICAgcmV0dXJuIE5BTUVfU1BBQ0VfSU1QT1JUO1xuICAgIH0sXG4gICAgZ2V0IE5BTUVEX0VYUE9SVCgpIHtcbiAgICAgIHJldHVybiBOQU1FRF9FWFBPUlQ7XG4gICAgfSxcbiAgICBnZXQgTkVXX0VYUFJFU1NJT04oKSB7XG4gICAgICByZXR1cm4gTkVXX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgT0JKRUNUX0xJVEVSQUwoKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX0xJVEVSQUw7XG4gICAgfSxcbiAgICBnZXQgT0JKRUNUX1BBVFRFUk4oKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX1BBVFRFUk47XG4gICAgfSxcbiAgICBnZXQgT0JKRUNUX1BBVFRFUk5fRklFTEQoKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX1BBVFRFUk5fRklFTEQ7XG4gICAgfSxcbiAgICBnZXQgT0JKRUNUX1RZUEUoKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX1RZUEU7XG4gICAgfSxcbiAgICBnZXQgUEFSRU5fRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBQQVJFTl9FWFBSRVNTSU9OO1xuICAgIH0sXG4gICAgZ2V0IFBPU1RGSVhfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBQT1NURklYX0VYUFJFU1NJT047XG4gICAgfSxcbiAgICBnZXQgUFJFREVGSU5FRF9UWVBFKCkge1xuICAgICAgcmV0dXJuIFBSRURFRklORURfVFlQRTtcbiAgICB9LFxuICAgIGdldCBQUk9QRVJUWV9OQU1FX0FTU0lHTk1FTlQoKSB7XG4gICAgICByZXR1cm4gUFJPUEVSVFlfTkFNRV9BU1NJR05NRU5UO1xuICAgIH0sXG4gICAgZ2V0IFBST1BFUlRZX05BTUVfU0hPUlRIQU5EKCkge1xuICAgICAgcmV0dXJuIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EO1xuICAgIH0sXG4gICAgZ2V0IFBST1BFUlRZX1NJR05BVFVSRSgpIHtcbiAgICAgIHJldHVybiBQUk9QRVJUWV9TSUdOQVRVUkU7XG4gICAgfSxcbiAgICBnZXQgUFJPUEVSVFlfVkFSSUFCTEVfREVDTEFSQVRJT04oKSB7XG4gICAgICByZXR1cm4gUFJPUEVSVFlfVkFSSUFCTEVfREVDTEFSQVRJT047XG4gICAgfSxcbiAgICBnZXQgUkVTVF9QQVJBTUVURVIoKSB7XG4gICAgICByZXR1cm4gUkVTVF9QQVJBTUVURVI7XG4gICAgfSxcbiAgICBnZXQgUkVUVVJOX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBSRVRVUk5fU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IFNDUklQVCgpIHtcbiAgICAgIHJldHVybiBTQ1JJUFQ7XG4gICAgfSxcbiAgICBnZXQgU0VUX0FDQ0VTU09SKCkge1xuICAgICAgcmV0dXJuIFNFVF9BQ0NFU1NPUjtcbiAgICB9LFxuICAgIGdldCBTUFJFQURfRVhQUkVTU0lPTigpIHtcbiAgICAgIHJldHVybiBTUFJFQURfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBTUFJFQURfUEFUVEVSTl9FTEVNRU5UKCkge1xuICAgICAgcmV0dXJuIFNQUkVBRF9QQVRURVJOX0VMRU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgU1RBVEVfTUFDSElORSgpIHtcbiAgICAgIHJldHVybiBTVEFURV9NQUNISU5FO1xuICAgIH0sXG4gICAgZ2V0IFNVUEVSX0VYUFJFU1NJT04oKSB7XG4gICAgICByZXR1cm4gU1VQRVJfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBTV0lUQ0hfU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIFNXSVRDSF9TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgU1lOVEFYX0VSUk9SX1RSRUUoKSB7XG4gICAgICByZXR1cm4gU1lOVEFYX0VSUk9SX1RSRUU7XG4gICAgfSxcbiAgICBnZXQgVEVNUExBVEVfTElURVJBTF9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIFRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBURU1QTEFURV9MSVRFUkFMX1BPUlRJT04oKSB7XG4gICAgICByZXR1cm4gVEVNUExBVEVfTElURVJBTF9QT1JUSU9OO1xuICAgIH0sXG4gICAgZ2V0IFRFTVBMQVRFX1NVQlNUSVRVVElPTigpIHtcbiAgICAgIHJldHVybiBURU1QTEFURV9TVUJTVElUVVRJT047XG4gICAgfSxcbiAgICBnZXQgVEhJU19FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIFRISVNfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBUSFJPV19TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gVEhST1dfU1RBVEVNRU5UO1xuICAgIH0sXG4gICAgZ2V0IFRSWV9TVEFURU1FTlQoKSB7XG4gICAgICByZXR1cm4gVFJZX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBUWVBFX0FMSUFTX0RFQ0xBUkFUSU9OKCkge1xuICAgICAgcmV0dXJuIFRZUEVfQUxJQVNfREVDTEFSQVRJT047XG4gICAgfSxcbiAgICBnZXQgVFlQRV9BUkdVTUVOVFMoKSB7XG4gICAgICByZXR1cm4gVFlQRV9BUkdVTUVOVFM7XG4gICAgfSxcbiAgICBnZXQgVFlQRV9OQU1FKCkge1xuICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9LFxuICAgIGdldCBUWVBFX1BBUkFNRVRFUigpIHtcbiAgICAgIHJldHVybiBUWVBFX1BBUkFNRVRFUjtcbiAgICB9LFxuICAgIGdldCBUWVBFX1BBUkFNRVRFUlMoKSB7XG4gICAgICByZXR1cm4gVFlQRV9QQVJBTUVURVJTO1xuICAgIH0sXG4gICAgZ2V0IFRZUEVfUkVGRVJFTkNFKCkge1xuICAgICAgcmV0dXJuIFRZUEVfUkVGRVJFTkNFO1xuICAgIH0sXG4gICAgZ2V0IFVOQVJZX0VYUFJFU1NJT04oKSB7XG4gICAgICByZXR1cm4gVU5BUllfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBVTklPTl9UWVBFKCkge1xuICAgICAgcmV0dXJuIFVOSU9OX1RZUEU7XG4gICAgfSxcbiAgICBnZXQgVkFSSUFCTEVfREVDTEFSQVRJT04oKSB7XG4gICAgICByZXR1cm4gVkFSSUFCTEVfREVDTEFSQVRJT047XG4gICAgfSxcbiAgICBnZXQgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCgpIHtcbiAgICAgIHJldHVybiBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUO1xuICAgIH0sXG4gICAgZ2V0IFZBUklBQkxFX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBWQVJJQUJMRV9TVEFURU1FTlQ7XG4gICAgfSxcbiAgICBnZXQgV0hJTEVfU1RBVEVNRU5UKCkge1xuICAgICAgcmV0dXJuIFdISUxFX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBXSVRIX1NUQVRFTUVOVCgpIHtcbiAgICAgIHJldHVybiBXSVRIX1NUQVRFTUVOVDtcbiAgICB9LFxuICAgIGdldCBZSUVMRF9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIFlJRUxEX0VYUFJFU1NJT047XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvVG9rZW5UeXBlLmpzXCI7XG4gIHZhciBBTVBFUlNBTkQgPSAnJic7XG4gIHZhciBBTVBFUlNBTkRfRVFVQUwgPSAnJj0nO1xuICB2YXIgQU5EID0gJyYmJztcbiAgdmFyIEFSUk9XID0gJz0+JztcbiAgdmFyIEFUID0gJ0AnO1xuICB2YXIgQkFDS19RVU9URSA9ICdgJztcbiAgdmFyIEJBTkcgPSAnISc7XG4gIHZhciBCQVIgPSAnfCc7XG4gIHZhciBCQVJfRVFVQUwgPSAnfD0nO1xuICB2YXIgQlJFQUsgPSAnYnJlYWsnO1xuICB2YXIgQ0FSRVQgPSAnXic7XG4gIHZhciBDQVJFVF9FUVVBTCA9ICdePSc7XG4gIHZhciBDQVNFID0gJ2Nhc2UnO1xuICB2YXIgQ0FUQ0ggPSAnY2F0Y2gnO1xuICB2YXIgQ0xBU1MgPSAnY2xhc3MnO1xuICB2YXIgQ0xPU0VfQU5HTEUgPSAnPic7XG4gIHZhciBDTE9TRV9DVVJMWSA9ICd9JztcbiAgdmFyIENMT1NFX1BBUkVOID0gJyknO1xuICB2YXIgQ0xPU0VfU1FVQVJFID0gJ10nO1xuICB2YXIgQ09MT04gPSAnOic7XG4gIHZhciBDT01NQSA9ICcsJztcbiAgdmFyIENPTlNUID0gJ2NvbnN0JztcbiAgdmFyIENPTlRJTlVFID0gJ2NvbnRpbnVlJztcbiAgdmFyIERFQlVHR0VSID0gJ2RlYnVnZ2VyJztcbiAgdmFyIERFRkFVTFQgPSAnZGVmYXVsdCc7XG4gIHZhciBERUxFVEUgPSAnZGVsZXRlJztcbiAgdmFyIERPID0gJ2RvJztcbiAgdmFyIERPVF9ET1RfRE9UID0gJy4uLic7XG4gIHZhciBFTFNFID0gJ2Vsc2UnO1xuICB2YXIgRU5EX09GX0ZJTEUgPSAnRW5kIG9mIEZpbGUnO1xuICB2YXIgRU5VTSA9ICdlbnVtJztcbiAgdmFyIEVRVUFMID0gJz0nO1xuICB2YXIgRVFVQUxfRVFVQUwgPSAnPT0nO1xuICB2YXIgRVFVQUxfRVFVQUxfRVFVQUwgPSAnPT09JztcbiAgdmFyIEVSUk9SID0gJ2Vycm9yJztcbiAgdmFyIEVYUE9SVCA9ICdleHBvcnQnO1xuICB2YXIgRVhURU5EUyA9ICdleHRlbmRzJztcbiAgdmFyIEZBTFNFID0gJ2ZhbHNlJztcbiAgdmFyIEZJTkFMTFkgPSAnZmluYWxseSc7XG4gIHZhciBGT1IgPSAnZm9yJztcbiAgdmFyIEZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbiAgdmFyIEdSRUFURVJfRVFVQUwgPSAnPj0nO1xuICB2YXIgSURFTlRJRklFUiA9ICdpZGVudGlmaWVyJztcbiAgdmFyIElGID0gJ2lmJztcbiAgdmFyIElNUExFTUVOVFMgPSAnaW1wbGVtZW50cyc7XG4gIHZhciBJTVBPUlQgPSAnaW1wb3J0JztcbiAgdmFyIElOID0gJ2luJztcbiAgdmFyIElOU1RBTkNFT0YgPSAnaW5zdGFuY2VvZic7XG4gIHZhciBJTlRFUkZBQ0UgPSAnaW50ZXJmYWNlJztcbiAgdmFyIEpTWF9JREVOVElGSUVSID0gJ2pzeCBpZGVudGlmaWVyJztcbiAgdmFyIExFRlRfU0hJRlQgPSAnPDwnO1xuICB2YXIgTEVGVF9TSElGVF9FUVVBTCA9ICc8PD0nO1xuICB2YXIgTEVTU19FUVVBTCA9ICc8PSc7XG4gIHZhciBMRVQgPSAnbGV0JztcbiAgdmFyIE1JTlVTID0gJy0nO1xuICB2YXIgTUlOVVNfRVFVQUwgPSAnLT0nO1xuICB2YXIgTUlOVVNfTUlOVVMgPSAnLS0nO1xuICB2YXIgTkVXID0gJ25ldyc7XG4gIHZhciBOT19TVUJTVElUVVRJT05fVEVNUExBVEUgPSAnbm8gc3Vic3RpdHV0aW9uIHRlbXBsYXRlJztcbiAgdmFyIE5PVF9FUVVBTCA9ICchPSc7XG4gIHZhciBOT1RfRVFVQUxfRVFVQUwgPSAnIT09JztcbiAgdmFyIE5VTEwgPSAnbnVsbCc7XG4gIHZhciBOVU1CRVIgPSAnbnVtYmVyIGxpdGVyYWwnO1xuICB2YXIgT1BFTl9BTkdMRSA9ICc8JztcbiAgdmFyIE9QRU5fQ1VSTFkgPSAneyc7XG4gIHZhciBPUEVOX1BBUkVOID0gJygnO1xuICB2YXIgT1BFTl9TUVVBUkUgPSAnWyc7XG4gIHZhciBPUiA9ICd8fCc7XG4gIHZhciBQQUNLQUdFID0gJ3BhY2thZ2UnO1xuICB2YXIgUEVSQ0VOVCA9ICclJztcbiAgdmFyIFBFUkNFTlRfRVFVQUwgPSAnJT0nO1xuICB2YXIgUEVSSU9EID0gJy4nO1xuICB2YXIgUExVUyA9ICcrJztcbiAgdmFyIFBMVVNfRVFVQUwgPSAnKz0nO1xuICB2YXIgUExVU19QTFVTID0gJysrJztcbiAgdmFyIFBSSVZBVEUgPSAncHJpdmF0ZSc7XG4gIHZhciBQUk9URUNURUQgPSAncHJvdGVjdGVkJztcbiAgdmFyIFBVQkxJQyA9ICdwdWJsaWMnO1xuICB2YXIgUVVFU1RJT04gPSAnPyc7XG4gIHZhciBSRUdVTEFSX0VYUFJFU1NJT04gPSAncmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwnO1xuICB2YXIgUkVUVVJOID0gJ3JldHVybic7XG4gIHZhciBSSUdIVF9TSElGVCA9ICc+Pic7XG4gIHZhciBSSUdIVF9TSElGVF9FUVVBTCA9ICc+Pj0nO1xuICB2YXIgU0VNSV9DT0xPTiA9ICc7JztcbiAgdmFyIFNMQVNIID0gJy8nO1xuICB2YXIgU0xBU0hfRVFVQUwgPSAnLz0nO1xuICB2YXIgU1RBUiA9ICcqJztcbiAgdmFyIFNUQVJfRVFVQUwgPSAnKj0nO1xuICB2YXIgU1RBUl9TVEFSID0gJyoqJztcbiAgdmFyIFNUQVJfU1RBUl9FUVVBTCA9ICcqKj0nO1xuICB2YXIgU1RBVElDID0gJ3N0YXRpYyc7XG4gIHZhciBTVFJJTkcgPSAnc3RyaW5nIGxpdGVyYWwnO1xuICB2YXIgU1VQRVIgPSAnc3VwZXInO1xuICB2YXIgU1dJVENIID0gJ3N3aXRjaCc7XG4gIHZhciBURU1QTEFURV9IRUFEID0gJ3RlbXBsYXRlIGhlYWQnO1xuICB2YXIgVEVNUExBVEVfTUlERExFID0gJ3RlbXBsYXRlIG1pZGRsZSc7XG4gIHZhciBURU1QTEFURV9UQUlMID0gJ3RlbXBsYXRlIHRhaWwnO1xuICB2YXIgVEhJUyA9ICd0aGlzJztcbiAgdmFyIFRIUk9XID0gJ3Rocm93JztcbiAgdmFyIFRJTERFID0gJ34nO1xuICB2YXIgVFJVRSA9ICd0cnVlJztcbiAgdmFyIFRSWSA9ICd0cnknO1xuICB2YXIgVFlQRU9GID0gJ3R5cGVvZic7XG4gIHZhciBVTlNJR05FRF9SSUdIVF9TSElGVCA9ICc+Pj4nO1xuICB2YXIgVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUwgPSAnPj4+PSc7XG4gIHZhciBWQVIgPSAndmFyJztcbiAgdmFyIFZPSUQgPSAndm9pZCc7XG4gIHZhciBXSElMRSA9ICd3aGlsZSc7XG4gIHZhciBXSVRIID0gJ3dpdGgnO1xuICB2YXIgWUlFTEQgPSAneWllbGQnO1xuICByZXR1cm4ge1xuICAgIGdldCBBTVBFUlNBTkQoKSB7XG4gICAgICByZXR1cm4gQU1QRVJTQU5EO1xuICAgIH0sXG4gICAgZ2V0IEFNUEVSU0FORF9FUVVBTCgpIHtcbiAgICAgIHJldHVybiBBTVBFUlNBTkRfRVFVQUw7XG4gICAgfSxcbiAgICBnZXQgQU5EKCkge1xuICAgICAgcmV0dXJuIEFORDtcbiAgICB9LFxuICAgIGdldCBBUlJPVygpIHtcbiAgICAgIHJldHVybiBBUlJPVztcbiAgICB9LFxuICAgIGdldCBBVCgpIHtcbiAgICAgIHJldHVybiBBVDtcbiAgICB9LFxuICAgIGdldCBCQUNLX1FVT1RFKCkge1xuICAgICAgcmV0dXJuIEJBQ0tfUVVPVEU7XG4gICAgfSxcbiAgICBnZXQgQkFORygpIHtcbiAgICAgIHJldHVybiBCQU5HO1xuICAgIH0sXG4gICAgZ2V0IEJBUigpIHtcbiAgICAgIHJldHVybiBCQVI7XG4gICAgfSxcbiAgICBnZXQgQkFSX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIEJBUl9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBCUkVBSygpIHtcbiAgICAgIHJldHVybiBCUkVBSztcbiAgICB9LFxuICAgIGdldCBDQVJFVCgpIHtcbiAgICAgIHJldHVybiBDQVJFVDtcbiAgICB9LFxuICAgIGdldCBDQVJFVF9FUVVBTCgpIHtcbiAgICAgIHJldHVybiBDQVJFVF9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBDQVNFKCkge1xuICAgICAgcmV0dXJuIENBU0U7XG4gICAgfSxcbiAgICBnZXQgQ0FUQ0goKSB7XG4gICAgICByZXR1cm4gQ0FUQ0g7XG4gICAgfSxcbiAgICBnZXQgQ0xBU1MoKSB7XG4gICAgICByZXR1cm4gQ0xBU1M7XG4gICAgfSxcbiAgICBnZXQgQ0xPU0VfQU5HTEUoKSB7XG4gICAgICByZXR1cm4gQ0xPU0VfQU5HTEU7XG4gICAgfSxcbiAgICBnZXQgQ0xPU0VfQ1VSTFkoKSB7XG4gICAgICByZXR1cm4gQ0xPU0VfQ1VSTFk7XG4gICAgfSxcbiAgICBnZXQgQ0xPU0VfUEFSRU4oKSB7XG4gICAgICByZXR1cm4gQ0xPU0VfUEFSRU47XG4gICAgfSxcbiAgICBnZXQgQ0xPU0VfU1FVQVJFKCkge1xuICAgICAgcmV0dXJuIENMT1NFX1NRVUFSRTtcbiAgICB9LFxuICAgIGdldCBDT0xPTigpIHtcbiAgICAgIHJldHVybiBDT0xPTjtcbiAgICB9LFxuICAgIGdldCBDT01NQSgpIHtcbiAgICAgIHJldHVybiBDT01NQTtcbiAgICB9LFxuICAgIGdldCBDT05TVCgpIHtcbiAgICAgIHJldHVybiBDT05TVDtcbiAgICB9LFxuICAgIGdldCBDT05USU5VRSgpIHtcbiAgICAgIHJldHVybiBDT05USU5VRTtcbiAgICB9LFxuICAgIGdldCBERUJVR0dFUigpIHtcbiAgICAgIHJldHVybiBERUJVR0dFUjtcbiAgICB9LFxuICAgIGdldCBERUZBVUxUKCkge1xuICAgICAgcmV0dXJuIERFRkFVTFQ7XG4gICAgfSxcbiAgICBnZXQgREVMRVRFKCkge1xuICAgICAgcmV0dXJuIERFTEVURTtcbiAgICB9LFxuICAgIGdldCBETygpIHtcbiAgICAgIHJldHVybiBETztcbiAgICB9LFxuICAgIGdldCBET1RfRE9UX0RPVCgpIHtcbiAgICAgIHJldHVybiBET1RfRE9UX0RPVDtcbiAgICB9LFxuICAgIGdldCBFTFNFKCkge1xuICAgICAgcmV0dXJuIEVMU0U7XG4gICAgfSxcbiAgICBnZXQgRU5EX09GX0ZJTEUoKSB7XG4gICAgICByZXR1cm4gRU5EX09GX0ZJTEU7XG4gICAgfSxcbiAgICBnZXQgRU5VTSgpIHtcbiAgICAgIHJldHVybiBFTlVNO1xuICAgIH0sXG4gICAgZ2V0IEVRVUFMKCkge1xuICAgICAgcmV0dXJuIEVRVUFMO1xuICAgIH0sXG4gICAgZ2V0IEVRVUFMX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIEVRVUFMX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IEVRVUFMX0VRVUFMX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIEVRVUFMX0VRVUFMX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IEVSUk9SKCkge1xuICAgICAgcmV0dXJuIEVSUk9SO1xuICAgIH0sXG4gICAgZ2V0IEVYUE9SVCgpIHtcbiAgICAgIHJldHVybiBFWFBPUlQ7XG4gICAgfSxcbiAgICBnZXQgRVhURU5EUygpIHtcbiAgICAgIHJldHVybiBFWFRFTkRTO1xuICAgIH0sXG4gICAgZ2V0IEZBTFNFKCkge1xuICAgICAgcmV0dXJuIEZBTFNFO1xuICAgIH0sXG4gICAgZ2V0IEZJTkFMTFkoKSB7XG4gICAgICByZXR1cm4gRklOQUxMWTtcbiAgICB9LFxuICAgIGdldCBGT1IoKSB7XG4gICAgICByZXR1cm4gRk9SO1xuICAgIH0sXG4gICAgZ2V0IEZVTkNUSU9OKCkge1xuICAgICAgcmV0dXJuIEZVTkNUSU9OO1xuICAgIH0sXG4gICAgZ2V0IEdSRUFURVJfRVFVQUwoKSB7XG4gICAgICByZXR1cm4gR1JFQVRFUl9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBJREVOVElGSUVSKCkge1xuICAgICAgcmV0dXJuIElERU5USUZJRVI7XG4gICAgfSxcbiAgICBnZXQgSUYoKSB7XG4gICAgICByZXR1cm4gSUY7XG4gICAgfSxcbiAgICBnZXQgSU1QTEVNRU5UUygpIHtcbiAgICAgIHJldHVybiBJTVBMRU1FTlRTO1xuICAgIH0sXG4gICAgZ2V0IElNUE9SVCgpIHtcbiAgICAgIHJldHVybiBJTVBPUlQ7XG4gICAgfSxcbiAgICBnZXQgSU4oKSB7XG4gICAgICByZXR1cm4gSU47XG4gICAgfSxcbiAgICBnZXQgSU5TVEFOQ0VPRigpIHtcbiAgICAgIHJldHVybiBJTlNUQU5DRU9GO1xuICAgIH0sXG4gICAgZ2V0IElOVEVSRkFDRSgpIHtcbiAgICAgIHJldHVybiBJTlRFUkZBQ0U7XG4gICAgfSxcbiAgICBnZXQgSlNYX0lERU5USUZJRVIoKSB7XG4gICAgICByZXR1cm4gSlNYX0lERU5USUZJRVI7XG4gICAgfSxcbiAgICBnZXQgTEVGVF9TSElGVCgpIHtcbiAgICAgIHJldHVybiBMRUZUX1NISUZUO1xuICAgIH0sXG4gICAgZ2V0IExFRlRfU0hJRlRfRVFVQUwoKSB7XG4gICAgICByZXR1cm4gTEVGVF9TSElGVF9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBMRVNTX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIExFU1NfRVFVQUw7XG4gICAgfSxcbiAgICBnZXQgTEVUKCkge1xuICAgICAgcmV0dXJuIExFVDtcbiAgICB9LFxuICAgIGdldCBNSU5VUygpIHtcbiAgICAgIHJldHVybiBNSU5VUztcbiAgICB9LFxuICAgIGdldCBNSU5VU19FUVVBTCgpIHtcbiAgICAgIHJldHVybiBNSU5VU19FUVVBTDtcbiAgICB9LFxuICAgIGdldCBNSU5VU19NSU5VUygpIHtcbiAgICAgIHJldHVybiBNSU5VU19NSU5VUztcbiAgICB9LFxuICAgIGdldCBORVcoKSB7XG4gICAgICByZXR1cm4gTkVXO1xuICAgIH0sXG4gICAgZ2V0IE5PX1NVQlNUSVRVVElPTl9URU1QTEFURSgpIHtcbiAgICAgIHJldHVybiBOT19TVUJTVElUVVRJT05fVEVNUExBVEU7XG4gICAgfSxcbiAgICBnZXQgTk9UX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIE5PVF9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBOT1RfRVFVQUxfRVFVQUwoKSB7XG4gICAgICByZXR1cm4gTk9UX0VRVUFMX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IE5VTEwoKSB7XG4gICAgICByZXR1cm4gTlVMTDtcbiAgICB9LFxuICAgIGdldCBOVU1CRVIoKSB7XG4gICAgICByZXR1cm4gTlVNQkVSO1xuICAgIH0sXG4gICAgZ2V0IE9QRU5fQU5HTEUoKSB7XG4gICAgICByZXR1cm4gT1BFTl9BTkdMRTtcbiAgICB9LFxuICAgIGdldCBPUEVOX0NVUkxZKCkge1xuICAgICAgcmV0dXJuIE9QRU5fQ1VSTFk7XG4gICAgfSxcbiAgICBnZXQgT1BFTl9QQVJFTigpIHtcbiAgICAgIHJldHVybiBPUEVOX1BBUkVOO1xuICAgIH0sXG4gICAgZ2V0IE9QRU5fU1FVQVJFKCkge1xuICAgICAgcmV0dXJuIE9QRU5fU1FVQVJFO1xuICAgIH0sXG4gICAgZ2V0IE9SKCkge1xuICAgICAgcmV0dXJuIE9SO1xuICAgIH0sXG4gICAgZ2V0IFBBQ0tBR0UoKSB7XG4gICAgICByZXR1cm4gUEFDS0FHRTtcbiAgICB9LFxuICAgIGdldCBQRVJDRU5UKCkge1xuICAgICAgcmV0dXJuIFBFUkNFTlQ7XG4gICAgfSxcbiAgICBnZXQgUEVSQ0VOVF9FUVVBTCgpIHtcbiAgICAgIHJldHVybiBQRVJDRU5UX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IFBFUklPRCgpIHtcbiAgICAgIHJldHVybiBQRVJJT0Q7XG4gICAgfSxcbiAgICBnZXQgUExVUygpIHtcbiAgICAgIHJldHVybiBQTFVTO1xuICAgIH0sXG4gICAgZ2V0IFBMVVNfRVFVQUwoKSB7XG4gICAgICByZXR1cm4gUExVU19FUVVBTDtcbiAgICB9LFxuICAgIGdldCBQTFVTX1BMVVMoKSB7XG4gICAgICByZXR1cm4gUExVU19QTFVTO1xuICAgIH0sXG4gICAgZ2V0IFBSSVZBVEUoKSB7XG4gICAgICByZXR1cm4gUFJJVkFURTtcbiAgICB9LFxuICAgIGdldCBQUk9URUNURUQoKSB7XG4gICAgICByZXR1cm4gUFJPVEVDVEVEO1xuICAgIH0sXG4gICAgZ2V0IFBVQkxJQygpIHtcbiAgICAgIHJldHVybiBQVUJMSUM7XG4gICAgfSxcbiAgICBnZXQgUVVFU1RJT04oKSB7XG4gICAgICByZXR1cm4gUVVFU1RJT047XG4gICAgfSxcbiAgICBnZXQgUkVHVUxBUl9FWFBSRVNTSU9OKCkge1xuICAgICAgcmV0dXJuIFJFR1VMQVJfRVhQUkVTU0lPTjtcbiAgICB9LFxuICAgIGdldCBSRVRVUk4oKSB7XG4gICAgICByZXR1cm4gUkVUVVJOO1xuICAgIH0sXG4gICAgZ2V0IFJJR0hUX1NISUZUKCkge1xuICAgICAgcmV0dXJuIFJJR0hUX1NISUZUO1xuICAgIH0sXG4gICAgZ2V0IFJJR0hUX1NISUZUX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIFJJR0hUX1NISUZUX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IFNFTUlfQ09MT04oKSB7XG4gICAgICByZXR1cm4gU0VNSV9DT0xPTjtcbiAgICB9LFxuICAgIGdldCBTTEFTSCgpIHtcbiAgICAgIHJldHVybiBTTEFTSDtcbiAgICB9LFxuICAgIGdldCBTTEFTSF9FUVVBTCgpIHtcbiAgICAgIHJldHVybiBTTEFTSF9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBTVEFSKCkge1xuICAgICAgcmV0dXJuIFNUQVI7XG4gICAgfSxcbiAgICBnZXQgU1RBUl9FUVVBTCgpIHtcbiAgICAgIHJldHVybiBTVEFSX0VRVUFMO1xuICAgIH0sXG4gICAgZ2V0IFNUQVJfU1RBUigpIHtcbiAgICAgIHJldHVybiBTVEFSX1NUQVI7XG4gICAgfSxcbiAgICBnZXQgU1RBUl9TVEFSX0VRVUFMKCkge1xuICAgICAgcmV0dXJuIFNUQVJfU1RBUl9FUVVBTDtcbiAgICB9LFxuICAgIGdldCBTVEFUSUMoKSB7XG4gICAgICByZXR1cm4gU1RBVElDO1xuICAgIH0sXG4gICAgZ2V0IFNUUklORygpIHtcbiAgICAgIHJldHVybiBTVFJJTkc7XG4gICAgfSxcbiAgICBnZXQgU1VQRVIoKSB7XG4gICAgICByZXR1cm4gU1VQRVI7XG4gICAgfSxcbiAgICBnZXQgU1dJVENIKCkge1xuICAgICAgcmV0dXJuIFNXSVRDSDtcbiAgICB9LFxuICAgIGdldCBURU1QTEFURV9IRUFEKCkge1xuICAgICAgcmV0dXJuIFRFTVBMQVRFX0hFQUQ7XG4gICAgfSxcbiAgICBnZXQgVEVNUExBVEVfTUlERExFKCkge1xuICAgICAgcmV0dXJuIFRFTVBMQVRFX01JRERMRTtcbiAgICB9LFxuICAgIGdldCBURU1QTEFURV9UQUlMKCkge1xuICAgICAgcmV0dXJuIFRFTVBMQVRFX1RBSUw7XG4gICAgfSxcbiAgICBnZXQgVEhJUygpIHtcbiAgICAgIHJldHVybiBUSElTO1xuICAgIH0sXG4gICAgZ2V0IFRIUk9XKCkge1xuICAgICAgcmV0dXJuIFRIUk9XO1xuICAgIH0sXG4gICAgZ2V0IFRJTERFKCkge1xuICAgICAgcmV0dXJuIFRJTERFO1xuICAgIH0sXG4gICAgZ2V0IFRSVUUoKSB7XG4gICAgICByZXR1cm4gVFJVRTtcbiAgICB9LFxuICAgIGdldCBUUlkoKSB7XG4gICAgICByZXR1cm4gVFJZO1xuICAgIH0sXG4gICAgZ2V0IFRZUEVPRigpIHtcbiAgICAgIHJldHVybiBUWVBFT0Y7XG4gICAgfSxcbiAgICBnZXQgVU5TSUdORURfUklHSFRfU0hJRlQoKSB7XG4gICAgICByZXR1cm4gVU5TSUdORURfUklHSFRfU0hJRlQ7XG4gICAgfSxcbiAgICBnZXQgVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUwoKSB7XG4gICAgICByZXR1cm4gVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUw7XG4gICAgfSxcbiAgICBnZXQgVkFSKCkge1xuICAgICAgcmV0dXJuIFZBUjtcbiAgICB9LFxuICAgIGdldCBWT0lEKCkge1xuICAgICAgcmV0dXJuIFZPSUQ7XG4gICAgfSxcbiAgICBnZXQgV0hJTEUoKSB7XG4gICAgICByZXR1cm4gV0hJTEU7XG4gICAgfSxcbiAgICBnZXQgV0lUSCgpIHtcbiAgICAgIHJldHVybiBXSVRIO1xuICAgIH0sXG4gICAgZ2V0IFlJRUxEKCkge1xuICAgICAgcmV0dXJuIFlJRUxEO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvVG9rZW4uanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvVG9rZW4uanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9Ub2tlbi5qc1wiKSksXG4gICAgICBBTVBFUlNBTkRfRVFVQUwgPSAkX18xLkFNUEVSU0FORF9FUVVBTCxcbiAgICAgIEJBUl9FUVVBTCA9ICRfXzEuQkFSX0VRVUFMLFxuICAgICAgQ0FSRVRfRVFVQUwgPSAkX18xLkNBUkVUX0VRVUFMLFxuICAgICAgRVFVQUwgPSAkX18xLkVRVUFMLFxuICAgICAgTEVGVF9TSElGVF9FUVVBTCA9ICRfXzEuTEVGVF9TSElGVF9FUVVBTCxcbiAgICAgIE1JTlVTX0VRVUFMID0gJF9fMS5NSU5VU19FUVVBTCxcbiAgICAgIFBFUkNFTlRfRVFVQUwgPSAkX18xLlBFUkNFTlRfRVFVQUwsXG4gICAgICBQTFVTX0VRVUFMID0gJF9fMS5QTFVTX0VRVUFMLFxuICAgICAgUklHSFRfU0hJRlRfRVFVQUwgPSAkX18xLlJJR0hUX1NISUZUX0VRVUFMLFxuICAgICAgU0xBU0hfRVFVQUwgPSAkX18xLlNMQVNIX0VRVUFMLFxuICAgICAgU1RBUl9FUVVBTCA9ICRfXzEuU1RBUl9FUVVBTCxcbiAgICAgIFNUQVJfU1RBUl9FUVVBTCA9ICRfXzEuU1RBUl9TVEFSX0VRVUFMLFxuICAgICAgVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUwgPSAkX18xLlVOU0lHTkVEX1JJR0hUX1NISUZUX0VRVUFMO1xuICB2YXIgVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUb2tlbih0eXBlLCBsb2NhdGlvbikge1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFRva2VuLCB7XG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgICB9LFxuICAgICAgaXNBc3NpZ25tZW50T3BlcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNBc3NpZ25tZW50T3BlcmF0b3IodGhpcy50eXBlKTtcbiAgICAgIH0sXG4gICAgICBpc0tleXdvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgaXNTdHJpY3RLZXl3b3JkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICBmdW5jdGlvbiBpc0Fzc2lnbm1lbnRPcGVyYXRvcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFNUEVSU0FORF9FUVVBTDpcbiAgICAgIGNhc2UgQkFSX0VRVUFMOlxuICAgICAgY2FzZSBDQVJFVF9FUVVBTDpcbiAgICAgIGNhc2UgRVFVQUw6XG4gICAgICBjYXNlIExFRlRfU0hJRlRfRVFVQUw6XG4gICAgICBjYXNlIE1JTlVTX0VRVUFMOlxuICAgICAgY2FzZSBQRVJDRU5UX0VRVUFMOlxuICAgICAgY2FzZSBQTFVTX0VRVUFMOlxuICAgICAgY2FzZSBSSUdIVF9TSElGVF9FUVVBTDpcbiAgICAgIGNhc2UgU0xBU0hfRVFVQUw6XG4gICAgICBjYXNlIFNUQVJfRVFVQUw6XG4gICAgICBjYXNlIFNUQVJfU1RBUl9FUVVBTDpcbiAgICAgIGNhc2UgVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUw6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgVG9rZW4oKSB7XG4gICAgICByZXR1cm4gVG9rZW47XG4gICAgfSxcbiAgICBnZXQgaXNBc3NpZ25tZW50T3BlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gaXNBc3NpZ25tZW50T3BlcmF0b3I7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvSlNPTi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvSlNPTi5qc1wiO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0odikge1xuICAgIHZhciByZXBsYWNlciA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHJldHVybiB0cmFuc2Zvcm1fKHJlcGxhY2VyKCcnLCB2KSwgcmVwbGFjZXIpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybV8odiwgcmVwbGFjZXIpIHtcbiAgICB2YXIgcnYsXG4gICAgICAgIHR2O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2YXIgbGVuID0gdi5sZW5ndGg7XG4gICAgICBydiA9IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHR2ID0gdHJhbnNmb3JtXyhyZXBsYWNlcihTdHJpbmcoaSksIHZbaV0pLCByZXBsYWNlcik7XG4gICAgICAgIHJ2W2ldID0gdHYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0djtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHJ2ID0ge307XG4gICAgICBPYmplY3Qua2V5cyh2KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdHYgPSB0cmFuc2Zvcm1fKHJlcGxhY2VyKGssIHZba10pLCByZXBsYWNlcik7XG4gICAgICAgIGlmICh0diAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcnZba10gPSB0djtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHJldHVybiB7Z2V0IHRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCI7XG4gIHZhciAkQVJHVU1FTlRTID0gJyRhcmd1bWVudHMnO1xuICB2YXIgQU5ZID0gJ2FueSc7XG4gIHZhciBBUFBMWSA9ICdhcHBseSc7XG4gIHZhciBBUkdVTUVOVFMgPSAnYXJndW1lbnRzJztcbiAgdmFyIEFSUkFZID0gJ0FycmF5JztcbiAgdmFyIEFTID0gJ2FzJztcbiAgdmFyIEFTWU5DID0gJ2FzeW5jJztcbiAgdmFyIEFTWU5DX1NUQVIgPSAnYXN5bmMgc3Rhcic7XG4gIHZhciBBV0FJVCA9ICdhd2FpdCc7XG4gIHZhciBCSU5EID0gJ2JpbmQnO1xuICB2YXIgQ0FMTCA9ICdjYWxsJztcbiAgdmFyIENPTkZJR1VSQUJMRSA9ICdjb25maWd1cmFibGUnO1xuICB2YXIgQ09OU1RSVUNUT1IgPSAnY29uc3RydWN0b3InO1xuICB2YXIgQ1JFQVRFID0gJ2NyZWF0ZSc7XG4gIHZhciBDVVJSRU5UID0gJ2N1cnJlbnQnO1xuICB2YXIgREVGSU5FX1BST1BFUlRZID0gJ2RlZmluZVByb3BlcnR5JztcbiAgdmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG4gIHZhciBGUkVFWkUgPSAnZnJlZXplJztcbiAgdmFyIEZST00gPSAnZnJvbSc7XG4gIHZhciBGVU5DVElPTiA9ICdGdW5jdGlvbic7XG4gIHZhciBHRVQgPSAnZ2V0JztcbiAgdmFyIEhBUyA9ICdoYXMnO1xuICB2YXIgTEVOR1RIID0gJ2xlbmd0aCc7XG4gIHZhciBNT0RVTEUgPSAnbW9kdWxlJztcbiAgdmFyIE5FVyA9ICduZXcnO1xuICB2YXIgT0JKRUNUID0gJ09iamVjdCc7XG4gIHZhciBPQkpFQ1RfTkFNRSA9ICdPYmplY3QnO1xuICB2YXIgT0YgPSAnb2YnO1xuICB2YXIgT04gPSAnb24nO1xuICB2YXIgUFJFVkVOVF9FWFRFTlNJT05TID0gJ3ByZXZlbnRFeHRlbnNpb25zJztcbiAgdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuICB2YXIgUFVTSCA9ICdwdXNoJztcbiAgdmFyIFNFVCA9ICdzZXQnO1xuICB2YXIgU0xJQ0UgPSAnc2xpY2UnO1xuICB2YXIgVEhJUyA9ICd0aGlzJztcbiAgdmFyIFRSQUNFVVJfUlVOVElNRSA9ICckdHJhY2V1clJ1bnRpbWUnO1xuICB2YXIgVFlQRSA9ICd0eXBlJztcbiAgdmFyIFVOREVGSU5FRCA9ICd1bmRlZmluZWQnO1xuICB2YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuICByZXR1cm4ge1xuICAgIGdldCAkQVJHVU1FTlRTKCkge1xuICAgICAgcmV0dXJuICRBUkdVTUVOVFM7XG4gICAgfSxcbiAgICBnZXQgQU5ZKCkge1xuICAgICAgcmV0dXJuIEFOWTtcbiAgICB9LFxuICAgIGdldCBBUFBMWSgpIHtcbiAgICAgIHJldHVybiBBUFBMWTtcbiAgICB9LFxuICAgIGdldCBBUkdVTUVOVFMoKSB7XG4gICAgICByZXR1cm4gQVJHVU1FTlRTO1xuICAgIH0sXG4gICAgZ2V0IEFSUkFZKCkge1xuICAgICAgcmV0dXJuIEFSUkFZO1xuICAgIH0sXG4gICAgZ2V0IEFTKCkge1xuICAgICAgcmV0dXJuIEFTO1xuICAgIH0sXG4gICAgZ2V0IEFTWU5DKCkge1xuICAgICAgcmV0dXJuIEFTWU5DO1xuICAgIH0sXG4gICAgZ2V0IEFTWU5DX1NUQVIoKSB7XG4gICAgICByZXR1cm4gQVNZTkNfU1RBUjtcbiAgICB9LFxuICAgIGdldCBBV0FJVCgpIHtcbiAgICAgIHJldHVybiBBV0FJVDtcbiAgICB9LFxuICAgIGdldCBCSU5EKCkge1xuICAgICAgcmV0dXJuIEJJTkQ7XG4gICAgfSxcbiAgICBnZXQgQ0FMTCgpIHtcbiAgICAgIHJldHVybiBDQUxMO1xuICAgIH0sXG4gICAgZ2V0IENPTkZJR1VSQUJMRSgpIHtcbiAgICAgIHJldHVybiBDT05GSUdVUkFCTEU7XG4gICAgfSxcbiAgICBnZXQgQ09OU1RSVUNUT1IoKSB7XG4gICAgICByZXR1cm4gQ09OU1RSVUNUT1I7XG4gICAgfSxcbiAgICBnZXQgQ1JFQVRFKCkge1xuICAgICAgcmV0dXJuIENSRUFURTtcbiAgICB9LFxuICAgIGdldCBDVVJSRU5UKCkge1xuICAgICAgcmV0dXJuIENVUlJFTlQ7XG4gICAgfSxcbiAgICBnZXQgREVGSU5FX1BST1BFUlRZKCkge1xuICAgICAgcmV0dXJuIERFRklORV9QUk9QRVJUWTtcbiAgICB9LFxuICAgIGdldCBFTlVNRVJBQkxFKCkge1xuICAgICAgcmV0dXJuIEVOVU1FUkFCTEU7XG4gICAgfSxcbiAgICBnZXQgRlJFRVpFKCkge1xuICAgICAgcmV0dXJuIEZSRUVaRTtcbiAgICB9LFxuICAgIGdldCBGUk9NKCkge1xuICAgICAgcmV0dXJuIEZST007XG4gICAgfSxcbiAgICBnZXQgRlVOQ1RJT04oKSB7XG4gICAgICByZXR1cm4gRlVOQ1RJT047XG4gICAgfSxcbiAgICBnZXQgR0VUKCkge1xuICAgICAgcmV0dXJuIEdFVDtcbiAgICB9LFxuICAgIGdldCBIQVMoKSB7XG4gICAgICByZXR1cm4gSEFTO1xuICAgIH0sXG4gICAgZ2V0IExFTkdUSCgpIHtcbiAgICAgIHJldHVybiBMRU5HVEg7XG4gICAgfSxcbiAgICBnZXQgTU9EVUxFKCkge1xuICAgICAgcmV0dXJuIE1PRFVMRTtcbiAgICB9LFxuICAgIGdldCBORVcoKSB7XG4gICAgICByZXR1cm4gTkVXO1xuICAgIH0sXG4gICAgZ2V0IE9CSkVDVCgpIHtcbiAgICAgIHJldHVybiBPQkpFQ1Q7XG4gICAgfSxcbiAgICBnZXQgT0JKRUNUX05BTUUoKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX05BTUU7XG4gICAgfSxcbiAgICBnZXQgT0YoKSB7XG4gICAgICByZXR1cm4gT0Y7XG4gICAgfSxcbiAgICBnZXQgT04oKSB7XG4gICAgICByZXR1cm4gT047XG4gICAgfSxcbiAgICBnZXQgUFJFVkVOVF9FWFRFTlNJT05TKCkge1xuICAgICAgcmV0dXJuIFBSRVZFTlRfRVhURU5TSU9OUztcbiAgICB9LFxuICAgIGdldCBQUk9UT1RZUEUoKSB7XG4gICAgICByZXR1cm4gUFJPVE9UWVBFO1xuICAgIH0sXG4gICAgZ2V0IFBVU0goKSB7XG4gICAgICByZXR1cm4gUFVTSDtcbiAgICB9LFxuICAgIGdldCBTRVQoKSB7XG4gICAgICByZXR1cm4gU0VUO1xuICAgIH0sXG4gICAgZ2V0IFNMSUNFKCkge1xuICAgICAgcmV0dXJuIFNMSUNFO1xuICAgIH0sXG4gICAgZ2V0IFRISVMoKSB7XG4gICAgICByZXR1cm4gVEhJUztcbiAgICB9LFxuICAgIGdldCBUUkFDRVVSX1JVTlRJTUUoKSB7XG4gICAgICByZXR1cm4gVFJBQ0VVUl9SVU5USU1FO1xuICAgIH0sXG4gICAgZ2V0IFRZUEUoKSB7XG4gICAgICByZXR1cm4gVFlQRTtcbiAgICB9LFxuICAgIGdldCBVTkRFRklORUQoKSB7XG4gICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgIH0sXG4gICAgZ2V0IFdSSVRBQkxFKCkge1xuICAgICAgcmV0dXJuIFdSSVRBQkxFO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L3RyZWVzL1BhcnNlVHJlZS5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVHlwZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWUuanNcIikpO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWUuanNcIikpLFxuICAgICAgSURFTlRJRklFUiA9ICRfXzIuSURFTlRJRklFUixcbiAgICAgIFNUQVIgPSAkX18yLlNUQVIsXG4gICAgICBTVFJJTkcgPSAkX18yLlNUUklORyxcbiAgICAgIFZBUiA9ICRfXzIuVkFSO1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWUuanNcIikpLlRva2VuO1xuICB2YXIgdXRpbEpTT04gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vdXRpbC9KU09OLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlLmpzXCIpKTtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUHJlZGVmaW5lZE5hbWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWUuanNcIikpLFxuICAgICAgQVNZTkMgPSAkX180LkFTWU5DLFxuICAgICAgQVNZTkNfU1RBUiA9ICRfXzQuQVNZTkNfU1RBUjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlLmpzXCIpKSxcbiAgICAgIEFSUkFZX0NPTVBSRUhFTlNJT04gPSAkX181LkFSUkFZX0NPTVBSRUhFTlNJT04sXG4gICAgICBBUlJBWV9MSVRFUkFMID0gJF9fNS5BUlJBWV9MSVRFUkFMLFxuICAgICAgQVJSQVlfUEFUVEVSTiA9ICRfXzUuQVJSQVlfUEFUVEVSTixcbiAgICAgIEFSUk9XX0ZVTkNUSU9OID0gJF9fNS5BUlJPV19GVU5DVElPTixcbiAgICAgIEFXQUlUX0VYUFJFU1NJT04gPSAkX181LkFXQUlUX0VYUFJFU1NJT04sXG4gICAgICBCSU5BUllfRVhQUkVTU0lPTiA9ICRfXzUuQklOQVJZX0VYUFJFU1NJT04sXG4gICAgICBCSU5ESU5HX0lERU5USUZJRVIgPSAkX181LkJJTkRJTkdfSURFTlRJRklFUixcbiAgICAgIEJMT0NLID0gJF9fNS5CTE9DSyxcbiAgICAgIEJSRUFLX1NUQVRFTUVOVCA9ICRfXzUuQlJFQUtfU1RBVEVNRU5ULFxuICAgICAgQ0FMTF9FWFBSRVNTSU9OID0gJF9fNS5DQUxMX0VYUFJFU1NJT04sXG4gICAgICBDTEFTU19ERUNMQVJBVElPTiA9ICRfXzUuQ0xBU1NfREVDTEFSQVRJT04sXG4gICAgICBDTEFTU19FWFBSRVNTSU9OID0gJF9fNS5DTEFTU19FWFBSRVNTSU9OLFxuICAgICAgQ09NTUFfRVhQUkVTU0lPTiA9ICRfXzUuQ09NTUFfRVhQUkVTU0lPTixcbiAgICAgIENPTkRJVElPTkFMX0VYUFJFU1NJT04gPSAkX181LkNPTkRJVElPTkFMX0VYUFJFU1NJT04sXG4gICAgICBDT05TVFJVQ1RPUl9UWVBFID0gJF9fNS5DT05TVFJVQ1RPUl9UWVBFLFxuICAgICAgQ09OVElOVUVfU1RBVEVNRU5UID0gJF9fNS5DT05USU5VRV9TVEFURU1FTlQsXG4gICAgICBERUJVR0dFUl9TVEFURU1FTlQgPSAkX181LkRFQlVHR0VSX1NUQVRFTUVOVCxcbiAgICAgIERPX1dISUxFX1NUQVRFTUVOVCA9ICRfXzUuRE9fV0hJTEVfU1RBVEVNRU5ULFxuICAgICAgRU1QVFlfU1RBVEVNRU5UID0gJF9fNS5FTVBUWV9TVEFURU1FTlQsXG4gICAgICBFWFBPUlRfREVDTEFSQVRJT04gPSAkX181LkVYUE9SVF9ERUNMQVJBVElPTixcbiAgICAgIEVYUFJFU1NJT05fU1RBVEVNRU5UID0gJF9fNS5FWFBSRVNTSU9OX1NUQVRFTUVOVCxcbiAgICAgIEZPUl9JTl9TVEFURU1FTlQgPSAkX181LkZPUl9JTl9TVEFURU1FTlQsXG4gICAgICBGT1JfT0ZfU1RBVEVNRU5UID0gJF9fNS5GT1JfT0ZfU1RBVEVNRU5ULFxuICAgICAgRk9SX09OX1NUQVRFTUVOVCA9ICRfXzUuRk9SX09OX1NUQVRFTUVOVCxcbiAgICAgIEZPUl9TVEFURU1FTlQgPSAkX181LkZPUl9TVEFURU1FTlQsXG4gICAgICBGT1JNQUxfUEFSQU1FVEVSID0gJF9fNS5GT1JNQUxfUEFSQU1FVEVSLFxuICAgICAgRlVOQ1RJT05fREVDTEFSQVRJT04gPSAkX181LkZVTkNUSU9OX0RFQ0xBUkFUSU9OLFxuICAgICAgRlVOQ1RJT05fRVhQUkVTU0lPTiA9ICRfXzUuRlVOQ1RJT05fRVhQUkVTU0lPTixcbiAgICAgIEZVTkNUSU9OX1RZUEUgPSAkX181LkZVTkNUSU9OX1RZUEUsXG4gICAgICBHRU5FUkFUT1JfQ09NUFJFSEVOU0lPTiA9ICRfXzUuR0VORVJBVE9SX0NPTVBSRUhFTlNJT04sXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX181LklERU5USUZJRVJfRVhQUkVTU0lPTixcbiAgICAgIElGX1NUQVRFTUVOVCA9ICRfXzUuSUZfU1RBVEVNRU5ULFxuICAgICAgSU1QT1JUX0RFQ0xBUkFUSU9OID0gJF9fNS5JTVBPUlRfREVDTEFSQVRJT04sXG4gICAgICBJTVBPUlRFRF9CSU5ESU5HID0gJF9fNS5JTVBPUlRFRF9CSU5ESU5HLFxuICAgICAgSU5URVJGQUNFX0RFQ0xBUkFUSU9OID0gJF9fNS5JTlRFUkZBQ0VfREVDTEFSQVRJT04sXG4gICAgICBKU1hfRUxFTUVOVCA9ICRfXzUuSlNYX0VMRU1FTlQsXG4gICAgICBMQUJFTExFRF9TVEFURU1FTlQgPSAkX181LkxBQkVMTEVEX1NUQVRFTUVOVCxcbiAgICAgIExJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzUuTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgTElURVJBTF9QUk9QRVJUWV9OQU1FID0gJF9fNS5MSVRFUkFMX1BST1BFUlRZX05BTUUsXG4gICAgICBNRU1CRVJfRVhQUkVTU0lPTiA9ICRfXzUuTUVNQkVSX0VYUFJFU1NJT04sXG4gICAgICBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPSAkX181Lk1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTixcbiAgICAgIE5FV19FWFBSRVNTSU9OID0gJF9fNS5ORVdfRVhQUkVTU0lPTixcbiAgICAgIE9CSkVDVF9MSVRFUkFMID0gJF9fNS5PQkpFQ1RfTElURVJBTCxcbiAgICAgIE9CSkVDVF9QQVRURVJOID0gJF9fNS5PQkpFQ1RfUEFUVEVSTixcbiAgICAgIE9CSkVDVF9UWVBFID0gJF9fNS5PQkpFQ1RfVFlQRSxcbiAgICAgIFBBUkVOX0VYUFJFU1NJT04gPSAkX181LlBBUkVOX0VYUFJFU1NJT04sXG4gICAgICBQT1NURklYX0VYUFJFU1NJT04gPSAkX181LlBPU1RGSVhfRVhQUkVTU0lPTixcbiAgICAgIFBSRURFRklORURfVFlQRSA9ICRfXzUuUFJFREVGSU5FRF9UWVBFLFxuICAgICAgUFJPUEVSVFlfTkFNRV9TSE9SVEhBTkQgPSAkX181LlBST1BFUlRZX05BTUVfU0hPUlRIQU5ELFxuICAgICAgUkVTVF9QQVJBTUVURVIgPSAkX181LlJFU1RfUEFSQU1FVEVSLFxuICAgICAgUkVUVVJOX1NUQVRFTUVOVCA9ICRfXzUuUkVUVVJOX1NUQVRFTUVOVCxcbiAgICAgIFNQUkVBRF9FWFBSRVNTSU9OID0gJF9fNS5TUFJFQURfRVhQUkVTU0lPTixcbiAgICAgIFNQUkVBRF9QQVRURVJOX0VMRU1FTlQgPSAkX181LlNQUkVBRF9QQVRURVJOX0VMRU1FTlQsXG4gICAgICBTVVBFUl9FWFBSRVNTSU9OID0gJF9fNS5TVVBFUl9FWFBSRVNTSU9OLFxuICAgICAgU1dJVENIX1NUQVRFTUVOVCA9ICRfXzUuU1dJVENIX1NUQVRFTUVOVCxcbiAgICAgIFRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzUuVEVNUExBVEVfTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgVEhJU19FWFBSRVNTSU9OID0gJF9fNS5USElTX0VYUFJFU1NJT04sXG4gICAgICBUSFJPV19TVEFURU1FTlQgPSAkX181LlRIUk9XX1NUQVRFTUVOVCxcbiAgICAgIFRSWV9TVEFURU1FTlQgPSAkX181LlRSWV9TVEFURU1FTlQsXG4gICAgICBUWVBFX0FMSUFTX0RFQ0xBUkFUSU9OID0gJF9fNS5UWVBFX0FMSUFTX0RFQ0xBUkFUSU9OLFxuICAgICAgVFlQRV9OQU1FID0gJF9fNS5UWVBFX05BTUUsXG4gICAgICBUWVBFX1JFRkVSRU5DRSA9ICRfXzUuVFlQRV9SRUZFUkVOQ0UsXG4gICAgICBVTkFSWV9FWFBSRVNTSU9OID0gJF9fNS5VTkFSWV9FWFBSRVNTSU9OLFxuICAgICAgVkFSSUFCTEVfREVDTEFSQVRJT04gPSAkX181LlZBUklBQkxFX0RFQ0xBUkFUSU9OLFxuICAgICAgVkFSSUFCTEVfU1RBVEVNRU5UID0gJF9fNS5WQVJJQUJMRV9TVEFURU1FTlQsXG4gICAgICBXSElMRV9TVEFURU1FTlQgPSAkX181LldISUxFX1NUQVRFTUVOVCxcbiAgICAgIFdJVEhfU1RBVEVNRU5UID0gJF9fNS5XSVRIX1NUQVRFTUVOVCxcbiAgICAgIFlJRUxEX0VYUFJFU1NJT04gPSAkX181LllJRUxEX0VYUFJFU1NJT047XG4gIHZhciBQYXJzZVRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVRyZWUobG9jYXRpb24pIHtcbiAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFBhcnNlVHJlZSwge1xuICAgICAgaXNQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFSUkFZX1BBVFRFUk46XG4gICAgICAgICAgY2FzZSBPQkpFQ1RfUEFUVEVSTjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0xlZnRIYW5kU2lkZUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgQVJSQVlfUEFUVEVSTjpcbiAgICAgICAgICBjYXNlIElERU5USUZJRVJfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIE1FTUJFUl9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgT0JKRUNUX1BBVFRFUk46XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFBBUkVOX0VYUFJFU1NJT046XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmlzTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEFSUkFZX0NPTVBSRUhFTlNJT046XG4gICAgICAgICAgY2FzZSBBUlJBWV9MSVRFUkFMOlxuICAgICAgICAgIGNhc2UgQVJST1dfRlVOQ1RJT046XG4gICAgICAgICAgY2FzZSBBV0FJVF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgQklOQVJZX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBDQUxMX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBDTEFTU19FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgQ09ORElUSU9OQUxfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIEZVTkNUSU9OX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBHRU5FUkFUT1JfQ09NUFJFSEVOU0lPTjpcbiAgICAgICAgICBjYXNlIElERU5USUZJRVJfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIEpTWF9FTEVNRU5UOlxuICAgICAgICAgIGNhc2UgTElURVJBTF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBORVdfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIE9CSkVDVF9MSVRFUkFMOlxuICAgICAgICAgIGNhc2UgUEFSRU5fRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIFBPU1RGSVhfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIFRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIFNVUEVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBUSElTX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBVTkFSWV9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgWUlFTERfRVhQUkVTU0lPTjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc01lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgVEhJU19FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgQ0xBU1NfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIFNVUEVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBJREVOVElGSUVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBKU1hfRUxFTUVOVDpcbiAgICAgICAgICBjYXNlIExJVEVSQUxfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIEFSUkFZX0xJVEVSQUw6XG4gICAgICAgICAgY2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgICAgICAgICBjYXNlIFBBUkVOX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBURU1QTEFURV9MSVRFUkFMX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBGVU5DVElPTl9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBDQUxMX0VYUFJFU1NJT046XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIE5FV19FWFBSRVNTSU9OOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncyAhPT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgaXNFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25tZW50RXhwcmVzc2lvbigpIHx8IHRoaXMudHlwZSA9PT0gQ09NTUFfRVhQUkVTU0lPTjtcbiAgICAgIH0sXG4gICAgICBpc0Fzc2lnbm1lbnRPclNwcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSB8fCB0aGlzLnR5cGUgPT09IFNQUkVBRF9FWFBSRVNTSU9OO1xuICAgICAgfSxcbiAgICAgIGlzUmVzdFBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFJFU1RfUEFSQU1FVEVSIHx8ICh0aGlzLnR5cGUgPT09IEZPUk1BTF9QQVJBTUVURVIgJiYgdGhpcy5wYXJhbWV0ZXIuaXNSZXN0UGFyYW1ldGVyKCkpO1xuICAgICAgfSxcbiAgICAgIGlzU3ByZWFkUGF0dGVybkVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTUFJFQURfUEFUVEVSTl9FTEVNRU5UO1xuICAgICAgfSxcbiAgICAgIGlzU3RhdGVtZW50TGlzdEl0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0YXRlbWVudCgpIHx8IHRoaXMuaXNEZWNsYXJhdGlvbigpIHx8IHRoaXMudHlwZSA9PT0gVFlQRV9BTElBU19ERUNMQVJBVElPTjtcbiAgICAgIH0sXG4gICAgICBpc1N0YXRlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBCTE9DSzpcbiAgICAgICAgICBjYXNlIFZBUklBQkxFX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIEVNUFRZX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIEVYUFJFU1NJT05fU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgSUZfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgQ09OVElOVUVfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgQlJFQUtfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgUkVUVVJOX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIFdJVEhfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgTEFCRUxMRURfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgVEhST1dfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgVFJZX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIERFQlVHR0VSX1NUQVRFTUVOVDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlzQnJlYWthYmxlU3RhdGVtZW50KCk7XG4gICAgICB9LFxuICAgICAgaXNEZWNsYXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBGVU5DVElPTl9ERUNMQVJBVElPTjpcbiAgICAgICAgICBjYXNlIENMQVNTX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMZXhpY2FsRGVjbGFyYXRpb24oKTtcbiAgICAgIH0sXG4gICAgICBpc0xleGljYWxEZWNsYXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBWQVJJQUJMRV9TVEFURU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnMuZGVjbGFyYXRpb25UeXBlICE9PSBWQVI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGlzQnJlYWthYmxlU3RhdGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNXSVRDSF9TVEFURU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0l0ZXJhdGlvblN0YXRlbWVudCgpO1xuICAgICAgfSxcbiAgICAgIGlzSXRlcmF0aW9uU3RhdGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIERPX1dISUxFX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIEZPUl9JTl9TVEFURU1FTlQ6XG4gICAgICAgICAgY2FzZSBGT1JfT0ZfU1RBVEVNRU5UOlxuICAgICAgICAgIGNhc2UgRk9SX09OX1NUQVRFTUVOVDpcbiAgICAgICAgICBjYXNlIEZPUl9TVEFURU1FTlQ6XG4gICAgICAgICAgY2FzZSBXSElMRV9TVEFURU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgaXNTY3JpcHRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIENMQVNTX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgIGNhc2UgRVhQT1JUX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgIGNhc2UgRlVOQ1RJT05fREVDTEFSQVRJT046XG4gICAgICAgICAgY2FzZSBJTVBPUlRfREVDTEFSQVRJT046XG4gICAgICAgICAgY2FzZSBJTlRFUkZBQ0VfREVDTEFSQVRJT046XG4gICAgICAgICAgY2FzZSBWQVJJQUJMRV9ERUNMQVJBVElPTjpcbiAgICAgICAgICBjYXNlIFRZUEVfQUxJQVNfREVDTEFSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc1N0YXRlbWVudCgpO1xuICAgICAgfSxcbiAgICAgIGlzR2VuZXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LaW5kICE9PSBudWxsICYmIHRoaXMuZnVuY3Rpb25LaW5kLnR5cGUgPT09IFNUQVI7XG4gICAgICB9LFxuICAgICAgaXNBc3luY0Z1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25LaW5kICE9PSBudWxsICYmIHRoaXMuZnVuY3Rpb25LaW5kLnR5cGUgPT09IElERU5USUZJRVIgJiYgdGhpcy5mdW5jdGlvbktpbmQudmFsdWUgPT09IEFTWU5DO1xuICAgICAgfSxcbiAgICAgIGlzQXN5bmNHZW5lcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbktpbmQgIT09IG51bGwgJiYgdGhpcy5mdW5jdGlvbktpbmQudHlwZSA9PT0gSURFTlRJRklFUiAmJiB0aGlzLmZ1bmN0aW9uS2luZC52YWx1ZSA9PT0gQVNZTkNfU1RBUjtcbiAgICAgIH0sXG4gICAgICBpc1R5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgQ09OU1RSVUNUT1JfVFlQRTpcbiAgICAgICAgICBjYXNlIEZVTkNUSU9OX1RZUEU6XG4gICAgICAgICAgY2FzZSBPQkpFQ1RfVFlQRTpcbiAgICAgICAgICBjYXNlIFBSRURFRklORURfVFlQRTpcbiAgICAgICAgICBjYXNlIFRZUEVfTkFNRTpcbiAgICAgICAgICBjYXNlIFRZUEVfUkVGRVJFTkNFOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGdldERpcmVjdGl2ZVByb2xvZ3VlU3RyaW5nVG9rZW5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzO1xuICAgICAgICBpZiAodHJlZS50eXBlICE9PSBFWFBSRVNTSU9OX1NUQVRFTUVOVCB8fCAhKHRyZWUgPSB0cmVlLmV4cHJlc3Npb24pKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodHJlZS50eXBlICE9PSBMSVRFUkFMX0VYUFJFU1NJT04gfHwgISh0cmVlID0gdHJlZS5saXRlcmFsVG9rZW4pKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodHJlZS50eXBlICE9PSBTVFJJTkcpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIGlzRGlyZWN0aXZlUHJvbG9ndWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3RpdmVQcm9sb2d1ZVN0cmluZ1Rva2VuXygpICE9PSBudWxsO1xuICAgICAgfSxcbiAgICAgIGlzVXNlU3RyaWN0RGlyZWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy5nZXREaXJlY3RpdmVQcm9sb2d1ZVN0cmluZ1Rva2VuXygpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHYgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHYgPT09ICdcInVzZSBzdHJpY3RcIicgfHwgdiA9PT0gXCIndXNlIHN0cmljdCdcIjtcbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXRpbEpTT04udHJhbnNmb3JtKHRoaXMsIFBhcnNlVHJlZS5yZXBsYWNlcik7XG4gICAgICB9LFxuICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiAyO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgUGFyc2VUcmVlLnJlcGxhY2VyLCBpbmRlbnQpO1xuICAgICAgfSxcbiAgICAgIGdldFN0cmluZ1ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIElERU5USUZJRVJfRVhQUkVTU0lPTjpcbiAgICAgICAgICBjYXNlIEJJTkRJTkdfSURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXJUb2tlbi50b1N0cmluZygpO1xuICAgICAgICAgIGNhc2UgSU1QT1JURURfQklORElORzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmcuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICBjYXNlIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZS50b1N0cmluZygpO1xuICAgICAgICAgIGNhc2UgTElURVJBTF9QUk9QRVJUWV9OQU1FOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbFRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc3RyaXBMb2NhdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSAnbG9jYXRpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZXI6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBQYXJzZVRyZWUgfHwgdiBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICAgICAgdmFyIHJ2ID0ge3R5cGU6IHYudHlwZX07XG4gICAgICAgICAgT2JqZWN0LmtleXModikuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJ2xvY2F0aW9uJylcbiAgICAgICAgICAgICAgcnZbbmFtZV0gPSB2W25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSgpO1xuICByZXR1cm4ge1xuICAgIGdldCBQYXJzZVRyZWVUeXBlKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZVR5cGU7XG4gICAgfSxcbiAgICBnZXQgUGFyc2VUcmVlKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZTtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiO1xuICB2YXIgUGFyc2VUcmVlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiKSkuUGFyc2VUcmVlO1xuICB2YXIgUGFyc2VUcmVlVHlwZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIpKTtcbiAgdmFyIEFOTk9UQVRJT04gPSBQYXJzZVRyZWVUeXBlLkFOTk9UQVRJT047XG4gIHZhciBBbm5vdGF0aW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uKGxvY2F0aW9uLCBuYW1lLCBhcmdzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBbm5vdGF0aW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQW5ub3RhdGlvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQW5ub3RhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QW5ub3RhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEFOTk9UQVRJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQU5PTl9CTE9DSyA9IFBhcnNlVHJlZVR5cGUuQU5PTl9CTE9DSztcbiAgdmFyIEFub25CbG9jayA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQW5vbkJsb2NrKGxvY2F0aW9uLCBzdGF0ZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBbm9uQmxvY2spLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFub25CbG9jaywge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQW5vbkJsb2NrKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBbm9uQmxvY2sodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBBTk9OX0JMT0NLO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEFSR1VNRU5UX0xJU1QgPSBQYXJzZVRyZWVUeXBlLkFSR1VNRU5UX0xJU1Q7XG4gIHZhciBBcmd1bWVudExpc3QgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFyZ3VtZW50TGlzdChsb2NhdGlvbiwgYXJncykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXJndW1lbnRMaXN0KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBcmd1bWVudExpc3QsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUFyZ3VtZW50TGlzdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QXJndW1lbnRMaXN0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQVJHVU1FTlRfTElTVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBBUlJBWV9DT01QUkVIRU5TSU9OID0gUGFyc2VUcmVlVHlwZS5BUlJBWV9DT01QUkVIRU5TSU9OO1xuICB2YXIgQXJyYXlDb21wcmVoZW5zaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBcnJheUNvbXByZWhlbnNpb24obG9jYXRpb24sIGNvbXByZWhlbnNpb25MaXN0LCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBcnJheUNvbXByZWhlbnNpb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5jb21wcmVoZW5zaW9uTGlzdCA9IGNvbXByZWhlbnNpb25MaXN0O1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycmF5Q29tcHJlaGVuc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQXJyYXlDb21wcmVoZW5zaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBcnJheUNvbXByZWhlbnNpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBBUlJBWV9DT01QUkVIRU5TSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEFSUkFZX0xJVEVSQUwgPSBQYXJzZVRyZWVUeXBlLkFSUkFZX0xJVEVSQUw7XG4gIHZhciBBcnJheUxpdGVyYWwgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFycmF5TGl0ZXJhbChsb2NhdGlvbiwgZWxlbWVudHMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEFycmF5TGl0ZXJhbCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBcnJheUxpdGVyYWwsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUFycmF5TGl0ZXJhbCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QXJyYXlMaXRlcmFsKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQVJSQVlfTElURVJBTDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBBUlJBWV9QQVRURVJOID0gUGFyc2VUcmVlVHlwZS5BUlJBWV9QQVRURVJOO1xuICB2YXIgQXJyYXlQYXR0ZXJuID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBcnJheVBhdHRlcm4obG9jYXRpb24sIGVsZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBcnJheVBhdHRlcm4pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQXJyYXlQYXR0ZXJuLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1BcnJheVBhdHRlcm4odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEFycmF5UGF0dGVybih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEFSUkFZX1BBVFRFUk47XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQVJSQVlfVFlQRSA9IFBhcnNlVHJlZVR5cGUuQVJSQVlfVFlQRTtcbiAgdmFyIEFycmF5VHlwZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlUeXBlKGxvY2F0aW9uLCBlbGVtZW50VHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXJyYXlUeXBlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycmF5VHlwZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQXJyYXlUeXBlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBBUlJBWV9UWVBFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEFSUk9XX0ZVTkNUSU9OID0gUGFyc2VUcmVlVHlwZS5BUlJPV19GVU5DVElPTjtcbiAgdmFyIEFycm93RnVuY3Rpb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFycm93RnVuY3Rpb24obG9jYXRpb24sIGZ1bmN0aW9uS2luZCwgcGFyYW1ldGVyTGlzdCwgYm9keSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXJyb3dGdW5jdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmZ1bmN0aW9uS2luZCA9IGZ1bmN0aW9uS2luZDtcbiAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCA9IHBhcmFtZXRlckxpc3Q7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQXJyb3dGdW5jdGlvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQXJyb3dGdW5jdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QXJyb3dGdW5jdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEFSUk9XX0ZVTkNUSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEFTU0lHTk1FTlRfRUxFTUVOVCA9IFBhcnNlVHJlZVR5cGUuQVNTSUdOTUVOVF9FTEVNRU5UO1xuICB2YXIgQXNzaWdubWVudEVsZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRFbGVtZW50KGxvY2F0aW9uLCBhc3NpZ25tZW50LCBpbml0aWFsaXplcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXNzaWdubWVudEVsZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5hc3NpZ25tZW50ID0gYXNzaWdubWVudDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFzc2lnbm1lbnRFbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Bc3NpZ25tZW50RWxlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QXNzaWdubWVudEVsZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBBU1NJR05NRU5UX0VMRU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQVdBSVRfRVhQUkVTU0lPTiA9IFBhcnNlVHJlZVR5cGUuQVdBSVRfRVhQUkVTU0lPTjtcbiAgdmFyIEF3YWl0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKGxvY2F0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBd2FpdEV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEF3YWl0RXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQXdhaXRFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBd2FpdEV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBBV0FJVF9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEJJTkFSWV9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5CSU5BUllfRVhQUkVTU0lPTjtcbiAgdmFyIEJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24obG9jYXRpb24sIGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQmluYXJ5RXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQmluYXJ5RXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQmluYXJ5RXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QmluYXJ5RXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEJJTkFSWV9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEJJTkRJTkdfRUxFTUVOVCA9IFBhcnNlVHJlZVR5cGUuQklORElOR19FTEVNRU5UO1xuICB2YXIgQmluZGluZ0VsZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdFbGVtZW50KGxvY2F0aW9uLCBiaW5kaW5nLCBpbml0aWFsaXplcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQmluZGluZ0VsZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEJpbmRpbmdFbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1CaW5kaW5nRWxlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QmluZGluZ0VsZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBCSU5ESU5HX0VMRU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQklORElOR19JREVOVElGSUVSID0gUGFyc2VUcmVlVHlwZS5CSU5ESU5HX0lERU5USUZJRVI7XG4gIHZhciBCaW5kaW5nSWRlbnRpZmllciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQmluZGluZ0lkZW50aWZpZXIobG9jYXRpb24sIGlkZW50aWZpZXJUb2tlbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQmluZGluZ0lkZW50aWZpZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pZGVudGlmaWVyVG9rZW4gPSBpZGVudGlmaWVyVG9rZW47XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShCaW5kaW5nSWRlbnRpZmllciwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQmluZGluZ0lkZW50aWZpZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEJpbmRpbmdJZGVudGlmaWVyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQklORElOR19JREVOVElGSUVSO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEJMT0NLID0gUGFyc2VUcmVlVHlwZS5CTE9DSztcbiAgdmFyIEJsb2NrID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCbG9jayhsb2NhdGlvbiwgc3RhdGVtZW50cykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQmxvY2spLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEJsb2NrLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1CbG9jayh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QmxvY2sodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBCTE9DSztcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBCUkVBS19TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkJSRUFLX1NUQVRFTUVOVDtcbiAgdmFyIEJyZWFrU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCcmVha1N0YXRlbWVudChsb2NhdGlvbiwgbmFtZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQnJlYWtTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEJyZWFrU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1CcmVha1N0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QnJlYWtTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBCUkVBS19TVEFURU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ0FMTF9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5DQUxMX0VYUFJFU1NJT047XG4gIHZhciBDYWxsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ2FsbEV4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhbmQsIGFyZ3MpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENhbGxFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ2FsbEV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNhbGxFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRDYWxsRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENBTExfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDQUxMX1NJR05BVFVSRSA9IFBhcnNlVHJlZVR5cGUuQ0FMTF9TSUdOQVRVUkU7XG4gIHZhciBDYWxsU2lnbmF0dXJlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDYWxsU2lnbmF0dXJlKGxvY2F0aW9uLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ2FsbFNpZ25hdHVyZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICB0aGlzLnBhcmFtZXRlckxpc3QgPSBwYXJhbWV0ZXJMaXN0O1xuICAgICAgdGhpcy5yZXR1cm5UeXBlID0gcmV0dXJuVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKENhbGxTaWduYXR1cmUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNhbGxTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENhbGxTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBDQUxMX1NJR05BVFVSRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDQVNFX0NMQVVTRSA9IFBhcnNlVHJlZVR5cGUuQ0FTRV9DTEFVU0U7XG4gIHZhciBDYXNlQ2xhdXNlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDYXNlQ2xhdXNlKGxvY2F0aW9uLCBleHByZXNzaW9uLCBzdGF0ZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDYXNlQ2xhdXNlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ2FzZUNsYXVzZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ2FzZUNsYXVzZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Q2FzZUNsYXVzZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENBU0VfQ0xBVVNFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIENBVENIID0gUGFyc2VUcmVlVHlwZS5DQVRDSDtcbiAgdmFyIENhdGNoID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDYXRjaChsb2NhdGlvbiwgYmluZGluZywgY2F0Y2hCb2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDYXRjaCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgICAgdGhpcy5jYXRjaEJvZHkgPSBjYXRjaEJvZHk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDYXRjaCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ2F0Y2godGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENhdGNoKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ0FUQ0g7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ0xBU1NfREVDTEFSQVRJT04gPSBQYXJzZVRyZWVUeXBlLkNMQVNTX0RFQ0xBUkFUSU9OO1xuICB2YXIgQ2xhc3NEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihsb2NhdGlvbiwgbmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIGFubm90YXRpb25zLCB0eXBlUGFyYW1ldGVycykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ2xhc3NEZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIHRoaXMudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKENsYXNzRGVjbGFyYXRpb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENsYXNzRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBDTEFTU19ERUNMQVJBVElPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDTEFTU19FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5DTEFTU19FWFBSRVNTSU9OO1xuICB2YXIgQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24obG9jYXRpb24sIG5hbWUsIHN1cGVyQ2xhc3MsIGVsZW1lbnRzLCBhbm5vdGF0aW9ucywgdHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENsYXNzRXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5zdXBlckNsYXNzID0gc3VwZXJDbGFzcztcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIHRoaXMudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKENsYXNzRXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRDbGFzc0V4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBDTEFTU19FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIENPTU1BX0VYUFJFU1NJT04gPSBQYXJzZVRyZWVUeXBlLkNPTU1BX0VYUFJFU1NJT047XG4gIHZhciBDb21tYUV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvbW1hRXhwcmVzc2lvbihsb2NhdGlvbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvbW1hRXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb21tYUV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNvbW1hRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Q29tbWFFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ09NTUFfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDT01QUkVIRU5TSU9OX0ZPUiA9IFBhcnNlVHJlZVR5cGUuQ09NUFJFSEVOU0lPTl9GT1I7XG4gIHZhciBDb21wcmVoZW5zaW9uRm9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb21wcmVoZW5zaW9uRm9yKGxvY2F0aW9uLCBsZWZ0LCBpdGVyYXRvcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29tcHJlaGVuc2lvbkZvcikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29tcHJlaGVuc2lvbkZvciwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ29tcHJlaGVuc2lvbkZvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Q29tcHJlaGVuc2lvbkZvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTVBSRUhFTlNJT05fRk9SO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIENPTVBSRUhFTlNJT05fSUYgPSBQYXJzZVRyZWVUeXBlLkNPTVBSRUhFTlNJT05fSUY7XG4gIHZhciBDb21wcmVoZW5zaW9uSWYgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvbXByZWhlbnNpb25JZihsb2NhdGlvbiwgZXhwcmVzc2lvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29tcHJlaGVuc2lvbklmKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb21wcmVoZW5zaW9uSWYsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNvbXByZWhlbnNpb25JZih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Q29tcHJlaGVuc2lvbklmKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ09NUFJFSEVOU0lPTl9JRjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDT01QVVRFRF9QUk9QRVJUWV9OQU1FID0gUGFyc2VUcmVlVHlwZS5DT01QVVRFRF9QUk9QRVJUWV9OQU1FO1xuICB2YXIgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvbXB1dGVkUHJvcGVydHlOYW1lKGxvY2F0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDb21wdXRlZFByb3BlcnR5TmFtZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29tcHV0ZWRQcm9wZXJ0eU5hbWUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNvbXB1dGVkUHJvcGVydHlOYW1lKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRDb21wdXRlZFByb3BlcnR5TmFtZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTVBVVEVEX1BST1BFUlRZX05BTUU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ09ORElUSU9OQUxfRVhQUkVTU0lPTiA9IFBhcnNlVHJlZVR5cGUuQ09ORElUSU9OQUxfRVhQUkVTU0lPTjtcbiAgdmFyIENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKGxvY2F0aW9uLCBjb25kaXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDb25kaXRpb25hbEV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29uZGl0aW9uYWxFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Db25kaXRpb25hbEV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTkRJVElPTkFMX0VYUFJFU1NJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ09OU1RSVUNUX1NJR05BVFVSRSA9IFBhcnNlVHJlZVR5cGUuQ09OU1RSVUNUX1NJR05BVFVSRTtcbiAgdmFyIENvbnN0cnVjdFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RydWN0U2lnbmF0dXJlKGxvY2F0aW9uLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29uc3RydWN0U2lnbmF0dXJlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCA9IHBhcmFtZXRlckxpc3Q7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSByZXR1cm5UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29uc3RydWN0U2lnbmF0dXJlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Db25zdHJ1Y3RTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENvbnN0cnVjdFNpZ25hdHVyZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTlNUUlVDVF9TSUdOQVRVUkU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ09OU1RSVUNUT1JfVFlQRSA9IFBhcnNlVHJlZVR5cGUuQ09OU1RSVUNUT1JfVFlQRTtcbiAgdmFyIENvbnN0cnVjdG9yVHlwZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3JUeXBlKGxvY2F0aW9uLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29uc3RydWN0b3JUeXBlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCA9IHBhcmFtZXRlckxpc3Q7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSByZXR1cm5UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29uc3RydWN0b3JUeXBlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Db25zdHJ1Y3RvclR5cGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENvbnN0cnVjdG9yVHlwZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIENPTlNUUlVDVE9SX1RZUEU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgQ09OVElOVUVfU1RBVEVNRU5UID0gUGFyc2VUcmVlVHlwZS5DT05USU5VRV9TVEFURU1FTlQ7XG4gIHZhciBDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobG9jYXRpb24sIG5hbWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvbnRpbnVlU3RhdGVtZW50KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb250aW51ZVN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ29udGludWVTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENvbnRpbnVlU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ09OVElOVUVfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIENPVkVSX0ZPUk1BTFMgPSBQYXJzZVRyZWVUeXBlLkNPVkVSX0ZPUk1BTFM7XG4gIHZhciBDb3ZlckZvcm1hbHMgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvdmVyRm9ybWFscyhsb2NhdGlvbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvdmVyRm9ybWFscykuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb3ZlckZvcm1hbHMsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUNvdmVyRm9ybWFscyh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Q292ZXJGb3JtYWxzKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ09WRVJfRk9STUFMUztcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBDT1ZFUl9JTklUSUFMSVpFRF9OQU1FID0gUGFyc2VUcmVlVHlwZS5DT1ZFUl9JTklUSUFMSVpFRF9OQU1FO1xuICB2YXIgQ292ZXJJbml0aWFsaXplZE5hbWUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvdmVySW5pdGlhbGl6ZWROYW1lKGxvY2F0aW9uLCBuYW1lLCBlcXVhbFRva2VuLCBpbml0aWFsaXplcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ292ZXJJbml0aWFsaXplZE5hbWUpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuZXF1YWxUb2tlbiA9IGVxdWFsVG9rZW47XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb3ZlckluaXRpYWxpemVkTmFtZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtQ292ZXJJbml0aWFsaXplZE5hbWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdENvdmVySW5pdGlhbGl6ZWROYW1lKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gQ09WRVJfSU5JVElBTElaRURfTkFNRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBERUJVR0dFUl9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkRFQlVHR0VSX1NUQVRFTUVOVDtcbiAgdmFyIERlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudChsb2NhdGlvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRGVidWdnZXJTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRGVidWdnZXJTdGF0ZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybURlYnVnZ2VyU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXREZWJ1Z2dlclN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIERFQlVHR0VSX1NUQVRFTUVOVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBERUZBVUxUX0NMQVVTRSA9IFBhcnNlVHJlZVR5cGUuREVGQVVMVF9DTEFVU0U7XG4gIHZhciBEZWZhdWx0Q2xhdXNlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0Q2xhdXNlKGxvY2F0aW9uLCBzdGF0ZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihEZWZhdWx0Q2xhdXNlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShEZWZhdWx0Q2xhdXNlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1EZWZhdWx0Q2xhdXNlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXREZWZhdWx0Q2xhdXNlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9DTEFVU0U7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgRE9fV0hJTEVfU1RBVEVNRU5UID0gUGFyc2VUcmVlVHlwZS5ET19XSElMRV9TVEFURU1FTlQ7XG4gIHZhciBEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KGxvY2F0aW9uLCBib2R5LCBjb25kaXRpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKERvV2hpbGVTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRG9XaGlsZVN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtRG9XaGlsZVN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0RG9XaGlsZVN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIERPX1dISUxFX1NUQVRFTUVOVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBFTVBUWV9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkVNUFRZX1NUQVRFTUVOVDtcbiAgdmFyIEVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFbXB0eVN0YXRlbWVudChsb2NhdGlvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRW1wdHlTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRW1wdHlTdGF0ZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUVtcHR5U3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRFbXB0eVN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1NUQVRFTUVOVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBFWFBPUlRfREVDTEFSQVRJT04gPSBQYXJzZVRyZWVUeXBlLkVYUE9SVF9ERUNMQVJBVElPTjtcbiAgdmFyIEV4cG9ydERlY2xhcmF0aW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnREZWNsYXJhdGlvbihsb2NhdGlvbiwgZGVjbGFyYXRpb24sIGFubm90YXRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBvcnREZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShFeHBvcnREZWNsYXJhdGlvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEV4cG9ydERlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRVhQT1JUX0RFQ0xBUkFUSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEVYUE9SVF9ERUZBVUxUID0gUGFyc2VUcmVlVHlwZS5FWFBPUlRfREVGQVVMVDtcbiAgdmFyIEV4cG9ydERlZmF1bHQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEV4cG9ydERlZmF1bHQobG9jYXRpb24sIGV4cHJlc3Npb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEV4cG9ydERlZmF1bHQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV4cG9ydERlZmF1bHQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUV4cG9ydERlZmF1bHQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEV4cG9ydERlZmF1bHQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBFWFBPUlRfREVGQVVMVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBFWFBPUlRfU1BFQ0lGSUVSID0gUGFyc2VUcmVlVHlwZS5FWFBPUlRfU1BFQ0lGSUVSO1xuICB2YXIgRXhwb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnRTcGVjaWZpZXIobG9jYXRpb24sIGxocywgcmhzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBvcnRTcGVjaWZpZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV4cG9ydFNwZWNpZmllciwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtRXhwb3J0U3BlY2lmaWVyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRFeHBvcnRTcGVjaWZpZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBFWFBPUlRfU1BFQ0lGSUVSO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEVYUE9SVF9TUEVDSUZJRVJfU0VUID0gUGFyc2VUcmVlVHlwZS5FWFBPUlRfU1BFQ0lGSUVSX1NFVDtcbiAgdmFyIEV4cG9ydFNwZWNpZmllclNldCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0U3BlY2lmaWVyU2V0KGxvY2F0aW9uLCBzcGVjaWZpZXJzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBvcnRTcGVjaWZpZXJTZXQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV4cG9ydFNwZWNpZmllclNldCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtRXhwb3J0U3BlY2lmaWVyU2V0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRFeHBvcnRTcGVjaWZpZXJTZXQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBFWFBPUlRfU1BFQ0lGSUVSX1NFVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBFWFBPUlRfU1RBUiA9IFBhcnNlVHJlZVR5cGUuRVhQT1JUX1NUQVI7XG4gIHZhciBFeHBvcnRTdGFyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnRTdGFyKGxvY2F0aW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBvcnRTdGFyKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV4cG9ydFN0YXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUV4cG9ydFN0YXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEV4cG9ydFN0YXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBFWFBPUlRfU1RBUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBFWFBSRVNTSU9OX1NUQVRFTUVOVCA9IFBhcnNlVHJlZVR5cGUuRVhQUkVTU0lPTl9TVEFURU1FTlQ7XG4gIHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGxvY2F0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHByZXNzaW9uU3RhdGVtZW50KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShFeHByZXNzaW9uU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1FeHByZXNzaW9uU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRVhQUkVTU0lPTl9TVEFURU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgRklOQUxMWSA9IFBhcnNlVHJlZVR5cGUuRklOQUxMWTtcbiAgdmFyIEZpbmFsbHkgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZpbmFsbHkobG9jYXRpb24sIGJsb2NrKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5hbGx5KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZpbmFsbHksIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZpbmFsbHkodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEZpbmFsbHkodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGSU5BTExZO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEZPUl9JTl9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkZPUl9JTl9TVEFURU1FTlQ7XG4gIHZhciBGb3JJblN0YXRlbWVudCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRm9ySW5TdGF0ZW1lbnQobG9jYXRpb24sIGluaXRpYWxpemVyLCBjb2xsZWN0aW9uLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JJblN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvckluU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Gb3JJblN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9ySW5TdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGT1JfSU5fU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEZPUl9PRl9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkZPUl9PRl9TVEFURU1FTlQ7XG4gIHZhciBGb3JPZlN0YXRlbWVudCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRm9yT2ZTdGF0ZW1lbnQobG9jYXRpb24sIGluaXRpYWxpemVyLCBjb2xsZWN0aW9uLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JPZlN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvck9mU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Gb3JPZlN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9yT2ZTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGT1JfT0ZfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEZPUl9PTl9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkZPUl9PTl9TVEFURU1FTlQ7XG4gIHZhciBGb3JPblN0YXRlbWVudCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRm9yT25TdGF0ZW1lbnQobG9jYXRpb24sIGluaXRpYWxpemVyLCBvYnNlcnZhYmxlLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JPblN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvck9uU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Gb3JPblN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9yT25TdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGT1JfT05fU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEZPUl9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkZPUl9TVEFURU1FTlQ7XG4gIHZhciBGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZvclN0YXRlbWVudChsb2NhdGlvbiwgaW5pdGlhbGl6ZXIsIGNvbmRpdGlvbiwgaW5jcmVtZW50LCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pbml0aWFsaXplciA9IGluaXRpYWxpemVyO1xuICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudDtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGb3JTdGF0ZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZvclN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9yU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRk9SX1NUQVRFTUVOVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBGT1JNQUxfUEFSQU1FVEVSID0gUGFyc2VUcmVlVHlwZS5GT1JNQUxfUEFSQU1FVEVSO1xuICB2YXIgRm9ybWFsUGFyYW1ldGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGb3JtYWxQYXJhbWV0ZXIobG9jYXRpb24sIHBhcmFtZXRlciwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JtYWxQYXJhbWV0ZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5wYXJhbWV0ZXIgPSBwYXJhbWV0ZXI7XG4gICAgICB0aGlzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGb3JtYWxQYXJhbWV0ZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZvcm1hbFBhcmFtZXRlcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9ybWFsUGFyYW1ldGVyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRk9STUFMX1BBUkFNRVRFUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBGT1JNQUxfUEFSQU1FVEVSX0xJU1QgPSBQYXJzZVRyZWVUeXBlLkZPUk1BTF9QQVJBTUVURVJfTElTVDtcbiAgdmFyIEZvcm1hbFBhcmFtZXRlckxpc3QgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZvcm1hbFBhcmFtZXRlckxpc3QobG9jYXRpb24sIHBhcmFtZXRlcnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEZvcm1hbFBhcmFtZXRlckxpc3QpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvcm1hbFBhcmFtZXRlckxpc3QsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZvcm1hbFBhcmFtZXRlckxpc3QodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEZvcm1hbFBhcmFtZXRlckxpc3QodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGT1JNQUxfUEFSQU1FVEVSX0xJU1Q7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgRk9SV0FSRF9ERUZBVUxUX0VYUE9SVCA9IFBhcnNlVHJlZVR5cGUuRk9SV0FSRF9ERUZBVUxUX0VYUE9SVDtcbiAgdmFyIEZvcndhcmREZWZhdWx0RXhwb3J0ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGb3J3YXJkRGVmYXVsdEV4cG9ydChsb2NhdGlvbiwgbmFtZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRm9yd2FyZERlZmF1bHRFeHBvcnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvcndhcmREZWZhdWx0RXhwb3J0LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Gb3J3YXJkRGVmYXVsdEV4cG9ydCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0Rm9yd2FyZERlZmF1bHRFeHBvcnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGT1JXQVJEX0RFRkFVTFRfRVhQT1JUO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEZVTkNUSU9OX0JPRFkgPSBQYXJzZVRyZWVUeXBlLkZVTkNUSU9OX0JPRFk7XG4gIHZhciBGdW5jdGlvbkJvZHkgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uQm9keShsb2NhdGlvbiwgc3RhdGVtZW50cykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRnVuY3Rpb25Cb2R5KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGdW5jdGlvbkJvZHksIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZ1bmN0aW9uQm9keSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0RnVuY3Rpb25Cb2R5KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRlVOQ1RJT05fQk9EWTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBGVU5DVElPTl9ERUNMQVJBVElPTiA9IFBhcnNlVHJlZVR5cGUuRlVOQ1RJT05fREVDTEFSQVRJT047XG4gIHZhciBGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKGxvY2F0aW9uLCBuYW1lLCBmdW5jdGlvbktpbmQsIHBhcmFtZXRlckxpc3QsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgYm9keSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRnVuY3Rpb25EZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5mdW5jdGlvbktpbmQgPSBmdW5jdGlvbktpbmQ7XG4gICAgICB0aGlzLnBhcmFtZXRlckxpc3QgPSBwYXJhbWV0ZXJMaXN0O1xuICAgICAgdGhpcy50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZ1bmN0aW9uRGVjbGFyYXRpb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBGVU5DVElPTl9ERUNMQVJBVElPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBGVU5DVElPTl9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5GVU5DVElPTl9FWFBSRVNTSU9OO1xuICB2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obG9jYXRpb24sIG5hbWUsIGZ1bmN0aW9uS2luZCwgcGFyYW1ldGVyTGlzdCwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGdW5jdGlvbkV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuZnVuY3Rpb25LaW5kID0gZnVuY3Rpb25LaW5kO1xuICAgICAgdGhpcy5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1ldGVyTGlzdDtcbiAgICAgIHRoaXMudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGdW5jdGlvbkV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRlVOQ1RJT05fRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBGVU5DVElPTl9UWVBFID0gUGFyc2VUcmVlVHlwZS5GVU5DVElPTl9UWVBFO1xuICB2YXIgRnVuY3Rpb25UeXBlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGdW5jdGlvblR5cGUobG9jYXRpb24sIHR5cGVQYXJhbWV0ZXJzLCBwYXJhbWV0ZXJMaXN0LCByZXR1cm5UeXBlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGdW5jdGlvblR5cGUpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgdGhpcy5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1ldGVyTGlzdDtcbiAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHJldHVyblR5cGU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGdW5jdGlvblR5cGUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUZ1bmN0aW9uVHlwZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0RnVuY3Rpb25UeXBlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gRlVOQ1RJT05fVFlQRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBHRU5FUkFUT1JfQ09NUFJFSEVOU0lPTiA9IFBhcnNlVHJlZVR5cGUuR0VORVJBVE9SX0NPTVBSRUhFTlNJT047XG4gIHZhciBHZW5lcmF0b3JDb21wcmVoZW5zaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JDb21wcmVoZW5zaW9uKGxvY2F0aW9uLCBjb21wcmVoZW5zaW9uTGlzdCwgZXhwcmVzc2lvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoR2VuZXJhdG9yQ29tcHJlaGVuc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmNvbXByZWhlbnNpb25MaXN0ID0gY29tcHJlaGVuc2lvbkxpc3Q7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoR2VuZXJhdG9yQ29tcHJlaGVuc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtR2VuZXJhdG9yQ29tcHJlaGVuc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0R2VuZXJhdG9yQ29tcHJlaGVuc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEdFTkVSQVRPUl9DT01QUkVIRU5TSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEdFVF9BQ0NFU1NPUiA9IFBhcnNlVHJlZVR5cGUuR0VUX0FDQ0VTU09SO1xuICB2YXIgR2V0QWNjZXNzb3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEdldEFjY2Vzc29yKGxvY2F0aW9uLCBpc1N0YXRpYywgbmFtZSwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihHZXRBY2Nlc3NvcikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEdldEFjY2Vzc29yLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1HZXRBY2Nlc3Nvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0R2V0QWNjZXNzb3IodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBHRVRfQUNDRVNTT1I7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgSURFTlRJRklFUl9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5JREVOVElGSUVSX0VYUFJFU1NJT047XG4gIHZhciBJZGVudGlmaWVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllckV4cHJlc3Npb24obG9jYXRpb24sIGlkZW50aWZpZXJUb2tlbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSWRlbnRpZmllckV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pZGVudGlmaWVyVG9rZW4gPSBpZGVudGlmaWVyVG9rZW47XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJZGVudGlmaWVyRXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSWRlbnRpZmllckV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdElkZW50aWZpZXJFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSURFTlRJRklFUl9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIElGX1NUQVRFTUVOVCA9IFBhcnNlVHJlZVR5cGUuSUZfU1RBVEVNRU5UO1xuICB2YXIgSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIElmU3RhdGVtZW50KGxvY2F0aW9uLCBjb25kaXRpb24sIGlmQ2xhdXNlLCBlbHNlQ2xhdXNlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihJZlN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIHRoaXMuaWZDbGF1c2UgPSBpZkNsYXVzZTtcbiAgICAgIHRoaXMuZWxzZUNsYXVzZSA9IGVsc2VDbGF1c2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJZlN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSWZTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdElmU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSUZfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIElNUE9SVEVEX0JJTkRJTkcgPSBQYXJzZVRyZWVUeXBlLklNUE9SVEVEX0JJTkRJTkc7XG4gIHZhciBJbXBvcnRlZEJpbmRpbmcgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEltcG9ydGVkQmluZGluZyhsb2NhdGlvbiwgYmluZGluZykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW1wb3J0ZWRCaW5kaW5nKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbXBvcnRlZEJpbmRpbmcsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUltcG9ydGVkQmluZGluZyh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SW1wb3J0ZWRCaW5kaW5nKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU1QT1JURURfQklORElORztcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBJTVBPUlRfQ0xBVVNFX1BBSVIgPSBQYXJzZVRyZWVUeXBlLklNUE9SVF9DTEFVU0VfUEFJUjtcbiAgdmFyIEltcG9ydENsYXVzZVBhaXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEltcG9ydENsYXVzZVBhaXIobG9jYXRpb24sIGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEltcG9ydENsYXVzZVBhaXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbXBvcnRDbGF1c2VQYWlyLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1JbXBvcnRDbGF1c2VQYWlyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRJbXBvcnRDbGF1c2VQYWlyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU1QT1JUX0NMQVVTRV9QQUlSO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIElNUE9SVF9ERUNMQVJBVElPTiA9IFBhcnNlVHJlZVR5cGUuSU1QT1JUX0RFQ0xBUkFUSU9OO1xuICB2YXIgSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEltcG9ydERlY2xhcmF0aW9uKGxvY2F0aW9uLCBpbXBvcnRDbGF1c2UsIG1vZHVsZVNwZWNpZmllcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW1wb3J0RGVjbGFyYXRpb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pbXBvcnRDbGF1c2UgPSBpbXBvcnRDbGF1c2U7XG4gICAgICB0aGlzLm1vZHVsZVNwZWNpZmllciA9IG1vZHVsZVNwZWNpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEltcG9ydERlY2xhcmF0aW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SW1wb3J0RGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBJTVBPUlRfREVDTEFSQVRJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgSU1QT1JUX1NQRUNJRklFUiA9IFBhcnNlVHJlZVR5cGUuSU1QT1JUX1NQRUNJRklFUjtcbiAgdmFyIEltcG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gSW1wb3J0U3BlY2lmaWVyKGxvY2F0aW9uLCBiaW5kaW5nLCBuYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihJbXBvcnRTcGVjaWZpZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbXBvcnRTcGVjaWZpZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUltcG9ydFNwZWNpZmllcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SW1wb3J0U3BlY2lmaWVyKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU1QT1JUX1NQRUNJRklFUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBJTVBPUlRfU1BFQ0lGSUVSX1NFVCA9IFBhcnNlVHJlZVR5cGUuSU1QT1JUX1NQRUNJRklFUl9TRVQ7XG4gIHZhciBJbXBvcnRTcGVjaWZpZXJTZXQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEltcG9ydFNwZWNpZmllclNldChsb2NhdGlvbiwgc3BlY2lmaWVycykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW1wb3J0U3BlY2lmaWVyU2V0KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbXBvcnRTcGVjaWZpZXJTZXQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUltcG9ydFNwZWNpZmllclNldCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SW1wb3J0U3BlY2lmaWVyU2V0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU1QT1JUX1NQRUNJRklFUl9TRVQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgSU1QT1JUX1RZUEVfQ0xBVVNFID0gUGFyc2VUcmVlVHlwZS5JTVBPUlRfVFlQRV9DTEFVU0U7XG4gIHZhciBJbXBvcnRUeXBlQ2xhdXNlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBJbXBvcnRUeXBlQ2xhdXNlKGxvY2F0aW9uLCBjbGF1c2UpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEltcG9ydFR5cGVDbGF1c2UpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5jbGF1c2UgPSBjbGF1c2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbXBvcnRUeXBlQ2xhdXNlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1JbXBvcnRUeXBlQ2xhdXNlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRJbXBvcnRUeXBlQ2xhdXNlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU1QT1JUX1RZUEVfQ0xBVVNFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIElOREVYX1NJR05BVFVSRSA9IFBhcnNlVHJlZVR5cGUuSU5ERVhfU0lHTkFUVVJFO1xuICB2YXIgSW5kZXhTaWduYXR1cmUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEluZGV4U2lnbmF0dXJlKGxvY2F0aW9uLCBuYW1lLCBpbmRleFR5cGUsIHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihJbmRleFNpZ25hdHVyZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5pbmRleFR5cGUgPSBpbmRleFR5cGU7XG4gICAgICB0aGlzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbmRleFNpZ25hdHVyZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSW5kZXhTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEluZGV4U2lnbmF0dXJlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSU5ERVhfU0lHTkFUVVJFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIElOVEVSRkFDRV9ERUNMQVJBVElPTiA9IFBhcnNlVHJlZVR5cGUuSU5URVJGQUNFX0RFQ0xBUkFUSU9OO1xuICB2YXIgSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEludGVyZmFjZURlY2xhcmF0aW9uKGxvY2F0aW9uLCBuYW1lLCB0eXBlUGFyYW1ldGVycywgZXh0ZW5kc0NsYXVzZSwgb2JqZWN0VHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW50ZXJmYWNlRGVjbGFyYXRpb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHRoaXMuZXh0ZW5kc0NsYXVzZSA9IGV4dGVuZHNDbGF1c2U7XG4gICAgICB0aGlzLm9iamVjdFR5cGUgPSBvYmplY3RUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSW50ZXJmYWNlRGVjbGFyYXRpb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIElOVEVSRkFDRV9ERUNMQVJBVElPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBKU1hfQVRUUklCVVRFID0gUGFyc2VUcmVlVHlwZS5KU1hfQVRUUklCVVRFO1xuICB2YXIgSnN4QXR0cmlidXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBKc3hBdHRyaWJ1dGUobG9jYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihKc3hBdHRyaWJ1dGUpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEpzeEF0dHJpYnV0ZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSnN4QXR0cmlidXRlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRKc3hBdHRyaWJ1dGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBKU1hfQVRUUklCVVRFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEpTWF9FTEVNRU5UID0gUGFyc2VUcmVlVHlwZS5KU1hfRUxFTUVOVDtcbiAgdmFyIEpzeEVsZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEpzeEVsZW1lbnQobG9jYXRpb24sIG5hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihKc3hFbGVtZW50KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSnN4RWxlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSnN4RWxlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SnN4RWxlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTWF9FTEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEpTWF9FTEVNRU5UX05BTUUgPSBQYXJzZVRyZWVUeXBlLkpTWF9FTEVNRU5UX05BTUU7XG4gIHZhciBKc3hFbGVtZW50TmFtZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gSnN4RWxlbWVudE5hbWUobG9jYXRpb24sIG5hbWVzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihKc3hFbGVtZW50TmFtZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShKc3hFbGVtZW50TmFtZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtSnN4RWxlbWVudE5hbWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEpzeEVsZW1lbnROYW1lKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gSlNYX0VMRU1FTlRfTkFNRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBKU1hfUExBQ0VIT0xERVIgPSBQYXJzZVRyZWVUeXBlLkpTWF9QTEFDRUhPTERFUjtcbiAgdmFyIEpzeFBsYWNlaG9sZGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBKc3hQbGFjZWhvbGRlcihsb2NhdGlvbiwgZXhwcmVzc2lvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSnN4UGxhY2Vob2xkZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEpzeFBsYWNlaG9sZGVyLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Kc3hQbGFjZWhvbGRlcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0SnN4UGxhY2Vob2xkZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBKU1hfUExBQ0VIT0xERVI7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgSlNYX1NQUkVBRF9BVFRSSUJVVEUgPSBQYXJzZVRyZWVUeXBlLkpTWF9TUFJFQURfQVRUUklCVVRFO1xuICB2YXIgSnN4U3ByZWFkQXR0cmlidXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBKc3hTcHJlYWRBdHRyaWJ1dGUobG9jYXRpb24sIGV4cHJlc3Npb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEpzeFNwcmVhZEF0dHJpYnV0ZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSnN4U3ByZWFkQXR0cmlidXRlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Kc3hTcHJlYWRBdHRyaWJ1dGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEpzeFNwcmVhZEF0dHJpYnV0ZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTWF9TUFJFQURfQVRUUklCVVRFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIEpTWF9URVhUID0gUGFyc2VUcmVlVHlwZS5KU1hfVEVYVDtcbiAgdmFyIEpzeFRleHQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEpzeFRleHQobG9jYXRpb24sIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihKc3hUZXh0KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEpzeFRleHQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUpzeFRleHQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdEpzeFRleHQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBKU1hfVEVYVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBMQUJFTExFRF9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLkxBQkVMTEVEX1NUQVRFTUVOVDtcbiAgdmFyIExhYmVsbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBMYWJlbGxlZFN0YXRlbWVudChsb2NhdGlvbiwgbmFtZSwgc3RhdGVtZW50KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihMYWJlbGxlZFN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5zdGF0ZW1lbnQgPSBzdGF0ZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShMYWJlbGxlZFN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtTGFiZWxsZWRTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdExhYmVsbGVkU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gTEFCRUxMRURfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIExJVEVSQUxfRVhQUkVTU0lPTiA9IFBhcnNlVHJlZVR5cGUuTElURVJBTF9FWFBSRVNTSU9OO1xuICB2YXIgTGl0ZXJhbEV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIExpdGVyYWxFeHByZXNzaW9uKGxvY2F0aW9uLCBsaXRlcmFsVG9rZW4pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKExpdGVyYWxFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubGl0ZXJhbFRva2VuID0gbGl0ZXJhbFRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTGl0ZXJhbEV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUxpdGVyYWxFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRMaXRlcmFsRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIExJVEVSQUxfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBMSVRFUkFMX1BST1BFUlRZX05BTUUgPSBQYXJzZVRyZWVUeXBlLkxJVEVSQUxfUFJPUEVSVFlfTkFNRTtcbiAgdmFyIExpdGVyYWxQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIExpdGVyYWxQcm9wZXJ0eU5hbWUobG9jYXRpb24sIGxpdGVyYWxUb2tlbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTGl0ZXJhbFByb3BlcnR5TmFtZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmxpdGVyYWxUb2tlbiA9IGxpdGVyYWxUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKExpdGVyYWxQcm9wZXJ0eU5hbWUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUxpdGVyYWxQcm9wZXJ0eU5hbWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdExpdGVyYWxQcm9wZXJ0eU5hbWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBMSVRFUkFMX1BST1BFUlRZX05BTUU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgTUVNQkVSX0VYUFJFU1NJT04gPSBQYXJzZVRyZWVUeXBlLk1FTUJFUl9FWFBSRVNTSU9OO1xuICB2YXIgTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTWVtYmVyRXhwcmVzc2lvbihsb2NhdGlvbiwgb3BlcmFuZCwgbWVtYmVyTmFtZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTWVtYmVyRXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgICAgdGhpcy5tZW1iZXJOYW1lID0gbWVtYmVyTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE1lbWJlckV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybU1lbWJlckV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE1lbWJlckV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBNRU1CRVJfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPSBQYXJzZVRyZWVUeXBlLk1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTjtcbiAgdmFyIE1lbWJlckxvb2t1cEV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE1lbWJlckxvb2t1cEV4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhbmQsIG1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE1lbWJlckxvb2t1cEV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcbiAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvbiA9IG1lbWJlckV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNZW1iZXJMb29rdXBFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1NZW1iZXJMb29rdXBFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRNZW1iZXJMb29rdXBFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIE1FVEhPRCA9IFBhcnNlVHJlZVR5cGUuTUVUSE9EO1xuICB2YXIgTWV0aG9kID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBNZXRob2QobG9jYXRpb24sIGlzU3RhdGljLCBmdW5jdGlvbktpbmQsIG5hbWUsIHBhcmFtZXRlckxpc3QsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgYm9keSwgZGVidWdOYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihNZXRob2QpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgdGhpcy5mdW5jdGlvbktpbmQgPSBmdW5jdGlvbktpbmQ7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1ldGVyTGlzdDtcbiAgICAgIHRoaXMudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICB0aGlzLmRlYnVnTmFtZSA9IGRlYnVnTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE1ldGhvZCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtTWV0aG9kKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRNZXRob2QodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBNRVRIT0Q7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgTUVUSE9EX1NJR05BVFVSRSA9IFBhcnNlVHJlZVR5cGUuTUVUSE9EX1NJR05BVFVSRTtcbiAgdmFyIE1ldGhvZFNpZ25hdHVyZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTWV0aG9kU2lnbmF0dXJlKGxvY2F0aW9uLCBuYW1lLCBvcHRpb25hbCwgY2FsbFNpZ25hdHVyZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTWV0aG9kU2lnbmF0dXJlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB0aGlzLmNhbGxTaWduYXR1cmUgPSBjYWxsU2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTWV0aG9kU2lnbmF0dXJlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1NZXRob2RTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE1ldGhvZFNpZ25hdHVyZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE1FVEhPRF9TSUdOQVRVUkU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgTU9EVUxFID0gUGFyc2VUcmVlVHlwZS5NT0RVTEU7XG4gIHZhciBNb2R1bGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE1vZHVsZShsb2NhdGlvbiwgc2NyaXB0SXRlbUxpc3QsIG1vZHVsZU5hbWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE1vZHVsZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnNjcmlwdEl0ZW1MaXN0ID0gc2NyaXB0SXRlbUxpc3Q7XG4gICAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTW9kdWxlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Nb2R1bGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE1vZHVsZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE1PRFVMRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBNT0RVTEVfU1BFQ0lGSUVSID0gUGFyc2VUcmVlVHlwZS5NT0RVTEVfU1BFQ0lGSUVSO1xuICB2YXIgTW9kdWxlU3BlY2lmaWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBNb2R1bGVTcGVjaWZpZXIobG9jYXRpb24sIHRva2VuKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihNb2R1bGVTcGVjaWZpZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTW9kdWxlU3BlY2lmaWVyLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Nb2R1bGVTcGVjaWZpZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE1vZHVsZVNwZWNpZmllcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE1PRFVMRV9TUEVDSUZJRVI7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgTkFNRV9TUEFDRV9FWFBPUlQgPSBQYXJzZVRyZWVUeXBlLk5BTUVfU1BBQ0VfRVhQT1JUO1xuICB2YXIgTmFtZVNwYWNlRXhwb3J0ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOYW1lU3BhY2VFeHBvcnQobG9jYXRpb24sIG5hbWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE5hbWVTcGFjZUV4cG9ydCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTmFtZVNwYWNlRXhwb3J0LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1OYW1lU3BhY2VFeHBvcnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE5hbWVTcGFjZUV4cG9ydCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUVfU1BBQ0VfRVhQT1JUO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIE5BTUVfU1BBQ0VfSU1QT1JUID0gUGFyc2VUcmVlVHlwZS5OQU1FX1NQQUNFX0lNUE9SVDtcbiAgdmFyIE5hbWVTcGFjZUltcG9ydCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTmFtZVNwYWNlSW1wb3J0KGxvY2F0aW9uLCBiaW5kaW5nKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihOYW1lU3BhY2VJbXBvcnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5iaW5kaW5nID0gYmluZGluZztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE5hbWVTcGFjZUltcG9ydCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtTmFtZVNwYWNlSW1wb3J0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXROYW1lU3BhY2VJbXBvcnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBOQU1FX1NQQUNFX0lNUE9SVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBOQU1FRF9FWFBPUlQgPSBQYXJzZVRyZWVUeXBlLk5BTUVEX0VYUE9SVDtcbiAgdmFyIE5hbWVkRXhwb3J0ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOYW1lZEV4cG9ydChsb2NhdGlvbiwgZXhwb3J0Q2xhdXNlLCBtb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE5hbWVkRXhwb3J0KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZXhwb3J0Q2xhdXNlID0gZXhwb3J0Q2xhdXNlO1xuICAgICAgdGhpcy5tb2R1bGVTcGVjaWZpZXIgPSBtb2R1bGVTcGVjaWZpZXI7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShOYW1lZEV4cG9ydCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtTmFtZWRFeHBvcnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE5hbWVkRXhwb3J0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gTkFNRURfRVhQT1JUO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIE5FV19FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5ORVdfRVhQUkVTU0lPTjtcbiAgdmFyIE5ld0V4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE5ld0V4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhbmQsIGFyZ3MpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE5ld0V4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcbiAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShOZXdFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1OZXdFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXROZXdFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gTkVXX0VYUFJFU1NJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgT0JKRUNUX0xJVEVSQUwgPSBQYXJzZVRyZWVUeXBlLk9CSkVDVF9MSVRFUkFMO1xuICB2YXIgT2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0TGl0ZXJhbChsb2NhdGlvbiwgcHJvcGVydHlOYW1lQW5kVmFsdWVzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihPYmplY3RMaXRlcmFsKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMucHJvcGVydHlOYW1lQW5kVmFsdWVzID0gcHJvcGVydHlOYW1lQW5kVmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoT2JqZWN0TGl0ZXJhbCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtT2JqZWN0TGl0ZXJhbCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0T2JqZWN0TGl0ZXJhbCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE9CSkVDVF9MSVRFUkFMO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIE9CSkVDVF9QQVRURVJOID0gUGFyc2VUcmVlVHlwZS5PQkpFQ1RfUEFUVEVSTjtcbiAgdmFyIE9iamVjdFBhdHRlcm4gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE9iamVjdFBhdHRlcm4obG9jYXRpb24sIGZpZWxkcykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoT2JqZWN0UGF0dGVybikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE9iamVjdFBhdHRlcm4sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybU9iamVjdFBhdHRlcm4odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE9iamVjdFBhdHRlcm4odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBPQkpFQ1RfUEFUVEVSTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBPQkpFQ1RfUEFUVEVSTl9GSUVMRCA9IFBhcnNlVHJlZVR5cGUuT0JKRUNUX1BBVFRFUk5fRklFTEQ7XG4gIHZhciBPYmplY3RQYXR0ZXJuRmllbGQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE9iamVjdFBhdHRlcm5GaWVsZChsb2NhdGlvbiwgbmFtZSwgZWxlbWVudCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoT2JqZWN0UGF0dGVybkZpZWxkKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoT2JqZWN0UGF0dGVybkZpZWxkLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1PYmplY3RQYXR0ZXJuRmllbGQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE9iamVjdFBhdHRlcm5GaWVsZCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIE9CSkVDVF9QQVRURVJOX0ZJRUxEO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIE9CSkVDVF9UWVBFID0gUGFyc2VUcmVlVHlwZS5PQkpFQ1RfVFlQRTtcbiAgdmFyIE9iamVjdFR5cGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE9iamVjdFR5cGUobG9jYXRpb24sIHR5cGVNZW1iZXJzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihPYmplY3RUeXBlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudHlwZU1lbWJlcnMgPSB0eXBlTWVtYmVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE9iamVjdFR5cGUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybU9iamVjdFR5cGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdE9iamVjdFR5cGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBPQkpFQ1RfVFlQRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBQQVJFTl9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5QQVJFTl9FWFBSRVNTSU9OO1xuICB2YXIgUGFyZW5FeHByZXNzaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQYXJlbkV4cHJlc3Npb24obG9jYXRpb24sIGV4cHJlc3Npb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFBhcmVuRXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUGFyZW5FeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1QYXJlbkV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFBhcmVuRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFBBUkVOX0VYUFJFU1NJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgUE9TVEZJWF9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5QT1NURklYX0VYUFJFU1NJT047XG4gIHZhciBQb3N0Zml4RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUG9zdGZpeEV4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhbmQsIG9wZXJhdG9yKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQb3N0Zml4RXhwcmVzc2lvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUG9zdGZpeEV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVBvc3RmaXhFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRQb3N0Zml4RXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFBPU1RGSVhfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBQUkVERUZJTkVEX1RZUEUgPSBQYXJzZVRyZWVUeXBlLlBSRURFRklORURfVFlQRTtcbiAgdmFyIFByZWRlZmluZWRUeXBlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQcmVkZWZpbmVkVHlwZShsb2NhdGlvbiwgdHlwZVRva2VuKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcmVkZWZpbmVkVHlwZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnR5cGVUb2tlbiA9IHR5cGVUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFByZWRlZmluZWRUeXBlLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1QcmVkZWZpbmVkVHlwZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0UHJlZGVmaW5lZFR5cGUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBQUkVERUZJTkVEX1RZUEU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgU0NSSVBUID0gUGFyc2VUcmVlVHlwZS5TQ1JJUFQ7XG4gIHZhciBTY3JpcHQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNjcmlwdChsb2NhdGlvbiwgc2NyaXB0SXRlbUxpc3QsIG1vZHVsZU5hbWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFNjcmlwdCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnNjcmlwdEl0ZW1MaXN0ID0gc2NyaXB0SXRlbUxpc3Q7XG4gICAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2NyaXB0LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1TY3JpcHQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFNjcmlwdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFNDUklQVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBQUk9QRVJUWV9OQU1FX0FTU0lHTk1FTlQgPSBQYXJzZVRyZWVUeXBlLlBST1BFUlRZX05BTUVfQVNTSUdOTUVOVDtcbiAgdmFyIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQobG9jYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQcm9wZXJ0eU5hbWVBc3NpZ25tZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Qcm9wZXJ0eU5hbWVBc3NpZ25tZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gUFJPUEVSVFlfTkFNRV9BU1NJR05NRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EID0gUGFyc2VUcmVlVHlwZS5QUk9QRVJUWV9OQU1FX1NIT1JUSEFORDtcbiAgdmFyIFByb3BlcnR5TmFtZVNob3J0aGFuZCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUHJvcGVydHlOYW1lU2hvcnRoYW5kKGxvY2F0aW9uLCBuYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcm9wZXJ0eU5hbWVTaG9ydGhhbmQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFByb3BlcnR5TmFtZVNob3J0aGFuZCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtUHJvcGVydHlOYW1lU2hvcnRoYW5kKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRQcm9wZXJ0eU5hbWVTaG9ydGhhbmQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBQUk9QRVJUWV9OQU1FX1NIT1JUSEFORDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBQUk9QRVJUWV9WQVJJQUJMRV9ERUNMQVJBVElPTiA9IFBhcnNlVHJlZVR5cGUuUFJPUEVSVFlfVkFSSUFCTEVfREVDTEFSQVRJT047XG4gIHZhciBQcm9wZXJ0eVZhcmlhYmxlRGVjbGFyYXRpb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbihsb2NhdGlvbiwgaXNTdGF0aWMsIG5hbWUsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgaW5pdGlhbGl6ZXIpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zO1xuICAgICAgdGhpcy5pbml0aWFsaXplciA9IGluaXRpYWxpemVyO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUHJvcGVydHlWYXJpYWJsZURlY2xhcmF0aW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Qcm9wZXJ0eVZhcmlhYmxlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFBST1BFUlRZX1ZBUklBQkxFX0RFQ0xBUkFUSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFBST1BFUlRZX1NJR05BVFVSRSA9IFBhcnNlVHJlZVR5cGUuUFJPUEVSVFlfU0lHTkFUVVJFO1xuICB2YXIgUHJvcGVydHlTaWduYXR1cmUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFByb3BlcnR5U2lnbmF0dXJlKGxvY2F0aW9uLCBuYW1lLCBvcHRpb25hbCwgdHlwZUFubm90YXRpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFByb3BlcnR5U2lnbmF0dXJlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICB0aGlzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQcm9wZXJ0eVNpZ25hdHVyZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtUHJvcGVydHlTaWduYXR1cmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFByb3BlcnR5U2lnbmF0dXJlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gUFJPUEVSVFlfU0lHTkFUVVJFO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFJFU1RfUEFSQU1FVEVSID0gUGFyc2VUcmVlVHlwZS5SRVNUX1BBUkFNRVRFUjtcbiAgdmFyIFJlc3RQYXJhbWV0ZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFJlc3RQYXJhbWV0ZXIobG9jYXRpb24sIGlkZW50aWZpZXIpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFJlc3RQYXJhbWV0ZXIpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFJlc3RQYXJhbWV0ZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVJlc3RQYXJhbWV0ZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFJlc3RQYXJhbWV0ZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBSRVNUX1BBUkFNRVRFUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBSRVRVUk5fU1RBVEVNRU5UID0gUGFyc2VUcmVlVHlwZS5SRVRVUk5fU1RBVEVNRU5UO1xuICB2YXIgUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQobG9jYXRpb24sIGV4cHJlc3Npb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFJldHVyblN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUmV0dXJuU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1SZXR1cm5TdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFJldHVyblN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9TVEFURU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgU0VUX0FDQ0VTU09SID0gUGFyc2VUcmVlVHlwZS5TRVRfQUNDRVNTT1I7XG4gIHZhciBTZXRBY2Nlc3NvciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gU2V0QWNjZXNzb3IobG9jYXRpb24sIGlzU3RhdGljLCBuYW1lLCBwYXJhbWV0ZXJMaXN0LCBhbm5vdGF0aW9ucywgYm9keSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU2V0QWNjZXNzb3IpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMucGFyYW1ldGVyTGlzdCA9IHBhcmFtZXRlckxpc3Q7XG4gICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2V0QWNjZXNzb3IsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVNldEFjY2Vzc29yKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRTZXRBY2Nlc3Nvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFNFVF9BQ0NFU1NPUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBTUFJFQURfRVhQUkVTU0lPTiA9IFBhcnNlVHJlZVR5cGUuU1BSRUFEX0VYUFJFU1NJT047XG4gIHZhciBTcHJlYWRFeHByZXNzaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTcHJlYWRFeHByZXNzaW9uKGxvY2F0aW9uLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTcHJlYWRFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTcHJlYWRFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1TcHJlYWRFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRTcHJlYWRFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gU1BSRUFEX0VYUFJFU1NJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgU1BSRUFEX1BBVFRFUk5fRUxFTUVOVCA9IFBhcnNlVHJlZVR5cGUuU1BSRUFEX1BBVFRFUk5fRUxFTUVOVDtcbiAgdmFyIFNwcmVhZFBhdHRlcm5FbGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTcHJlYWRQYXR0ZXJuRWxlbWVudChsb2NhdGlvbiwgbHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTcHJlYWRQYXR0ZXJuRWxlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmx2YWx1ZSA9IGx2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFNwcmVhZFBhdHRlcm5FbGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1TcHJlYWRQYXR0ZXJuRWxlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0U3ByZWFkUGF0dGVybkVsZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTUFJFQURfUEFUVEVSTl9FTEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFNVUEVSX0VYUFJFU1NJT04gPSBQYXJzZVRyZWVUeXBlLlNVUEVSX0VYUFJFU1NJT047XG4gIHZhciBTdXBlckV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFN1cGVyRXhwcmVzc2lvbihsb2NhdGlvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3VwZXJFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFN1cGVyRXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtU3VwZXJFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRTdXBlckV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTVVBFUl9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFNXSVRDSF9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLlNXSVRDSF9TVEFURU1FTlQ7XG4gIHZhciBTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChsb2NhdGlvbiwgZXhwcmVzc2lvbiwgY2FzZUNsYXVzZXMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFN3aXRjaFN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgdGhpcy5jYXNlQ2xhdXNlcyA9IGNhc2VDbGF1c2VzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3dpdGNoU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1Td2l0Y2hTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFN3aXRjaFN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFNXSVRDSF9TVEFURU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgU1lOVEFYX0VSUk9SX1RSRUUgPSBQYXJzZVRyZWVUeXBlLlNZTlRBWF9FUlJPUl9UUkVFO1xuICB2YXIgU3ludGF4RXJyb3JUcmVlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTeW50YXhFcnJvclRyZWUobG9jYXRpb24sIG5leHRUb2tlbiwgbWVzc2FnZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3ludGF4RXJyb3JUcmVlKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMubmV4dFRva2VuID0gbmV4dFRva2VuO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFN5bnRheEVycm9yVHJlZSwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtU3ludGF4RXJyb3JUcmVlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRTeW50YXhFcnJvclRyZWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBTWU5UQVhfRVJST1JfVFJFRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBURU1QTEFURV9MSVRFUkFMX0VYUFJFU1NJT04gPSBQYXJzZVRyZWVUeXBlLlRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTjtcbiAgdmFyIFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhbmQsIGVsZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1UZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVEVNUExBVEVfTElURVJBTF9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFRFTVBMQVRFX0xJVEVSQUxfUE9SVElPTiA9IFBhcnNlVHJlZVR5cGUuVEVNUExBVEVfTElURVJBTF9QT1JUSU9OO1xuICB2YXIgVGVtcGxhdGVMaXRlcmFsUG9ydGlvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsUG9ydGlvbihsb2NhdGlvbiwgdmFsdWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFRlbXBsYXRlTGl0ZXJhbFBvcnRpb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVGVtcGxhdGVMaXRlcmFsUG9ydGlvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtVGVtcGxhdGVMaXRlcmFsUG9ydGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VGVtcGxhdGVMaXRlcmFsUG9ydGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRFTVBMQVRFX0xJVEVSQUxfUE9SVElPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBURU1QTEFURV9TVUJTVElUVVRJT04gPSBQYXJzZVRyZWVUeXBlLlRFTVBMQVRFX1NVQlNUSVRVVElPTjtcbiAgdmFyIFRlbXBsYXRlU3Vic3RpdHV0aW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVN1YnN0aXR1dGlvbihsb2NhdGlvbiwgZXhwcmVzc2lvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVGVtcGxhdGVTdWJzdGl0dXRpb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFRlbXBsYXRlU3Vic3RpdHV0aW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1UZW1wbGF0ZVN1YnN0aXR1dGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VGVtcGxhdGVTdWJzdGl0dXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBURU1QTEFURV9TVUJTVElUVVRJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgVEhJU19FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5USElTX0VYUFJFU1NJT047XG4gIHZhciBUaGlzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVGhpc0V4cHJlc3Npb24obG9jYXRpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFRoaXNFeHByZXNzaW9uKS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFRoaXNFeHByZXNzaW9uLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1UaGlzRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VGhpc0V4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUSElTX0VYUFJFU1NJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgVEhST1dfU1RBVEVNRU5UID0gUGFyc2VUcmVlVHlwZS5USFJPV19TVEFURU1FTlQ7XG4gIHZhciBUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQobG9jYXRpb24sIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUaHJvd1N0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUaHJvd1N0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtVGhyb3dTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFRocm93U3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVEhST1dfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFRSWV9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLlRSWV9TVEFURU1FTlQ7XG4gIHZhciBUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFRyeVN0YXRlbWVudChsb2NhdGlvbiwgYm9keSwgY2F0Y2hCbG9jaywgZmluYWxseUJsb2NrKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUcnlTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIHRoaXMuY2F0Y2hCbG9jayA9IGNhdGNoQmxvY2s7XG4gICAgICB0aGlzLmZpbmFsbHlCbG9jayA9IGZpbmFsbHlCbG9jaztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFRyeVN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtVHJ5U3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRUcnlTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUUllfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFRZUEVfQUxJQVNfREVDTEFSQVRJT04gPSBQYXJzZVRyZWVUeXBlLlRZUEVfQUxJQVNfREVDTEFSQVRJT047XG4gIHZhciBUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHlwZUFsaWFzRGVjbGFyYXRpb24obG9jYXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUeXBlQWxpYXNEZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVHlwZUFsaWFzRGVjbGFyYXRpb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVR5cGVBbGlhc0RlY2xhcmF0aW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfQUxJQVNfREVDTEFSQVRJT047XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgVFlQRV9BUkdVTUVOVFMgPSBQYXJzZVRyZWVUeXBlLlRZUEVfQVJHVU1FTlRTO1xuICB2YXIgVHlwZUFyZ3VtZW50cyA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHlwZUFyZ3VtZW50cyhsb2NhdGlvbiwgYXJncykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVHlwZUFyZ3VtZW50cykuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVHlwZUFyZ3VtZW50cywge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtVHlwZUFyZ3VtZW50cyh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VHlwZUFyZ3VtZW50cyh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfQVJHVU1FTlRTO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFRZUEVfTkFNRSA9IFBhcnNlVHJlZVR5cGUuVFlQRV9OQU1FO1xuICB2YXIgVHlwZU5hbWUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFR5cGVOYW1lKGxvY2F0aW9uLCBtb2R1bGVOYW1lLCBuYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUeXBlTmFtZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLm1vZHVsZU5hbWUgPSBtb2R1bGVOYW1lO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFR5cGVOYW1lLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1UeXBlTmFtZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VHlwZU5hbWUodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgVFlQRV9QQVJBTUVURVIgPSBQYXJzZVRyZWVUeXBlLlRZUEVfUEFSQU1FVEVSO1xuICB2YXIgVHlwZVBhcmFtZXRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHlwZVBhcmFtZXRlcihsb2NhdGlvbiwgaWRlbnRpZmllclRva2VuLCBleHRlbmRzVHlwZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVHlwZVBhcmFtZXRlcikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmlkZW50aWZpZXJUb2tlbiA9IGlkZW50aWZpZXJUb2tlbjtcbiAgICAgIHRoaXMuZXh0ZW5kc1R5cGUgPSBleHRlbmRzVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFR5cGVQYXJhbWV0ZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVR5cGVQYXJhbWV0ZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFR5cGVQYXJhbWV0ZXIodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX1BBUkFNRVRFUjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBUWVBFX1BBUkFNRVRFUlMgPSBQYXJzZVRyZWVUeXBlLlRZUEVfUEFSQU1FVEVSUztcbiAgdmFyIFR5cGVQYXJhbWV0ZXJzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBUeXBlUGFyYW1ldGVycyhsb2NhdGlvbiwgcGFyYW1ldGVycykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVHlwZVBhcmFtZXRlcnMpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFR5cGVQYXJhbWV0ZXJzLCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1UeXBlUGFyYW1ldGVycyh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VHlwZVBhcmFtZXRlcnModGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX1BBUkFNRVRFUlM7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgVFlQRV9SRUZFUkVOQ0UgPSBQYXJzZVRyZWVUeXBlLlRZUEVfUkVGRVJFTkNFO1xuICB2YXIgVHlwZVJlZmVyZW5jZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHlwZVJlZmVyZW5jZShsb2NhdGlvbiwgdHlwZU5hbWUsIGFyZ3MpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFR5cGVSZWZlcmVuY2UpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy50eXBlTmFtZSA9IHR5cGVOYW1lO1xuICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFR5cGVSZWZlcmVuY2UsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVR5cGVSZWZlcmVuY2UodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFR5cGVSZWZlcmVuY2UodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX1JFRkVSRU5DRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBVTkFSWV9FWFBSRVNTSU9OID0gUGFyc2VUcmVlVHlwZS5VTkFSWV9FWFBSRVNTSU9OO1xuICB2YXIgVW5hcnlFeHByZXNzaW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBVbmFyeUV4cHJlc3Npb24obG9jYXRpb24sIG9wZXJhdG9yLCBvcGVyYW5kKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihVbmFyeUV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFVuYXJ5RXhwcmVzc2lvbiwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtVW5hcnlFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRVbmFyeUV4cHJlc3Npb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBVTkFSWV9FWFBSRVNTSU9OO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFVOSU9OX1RZUEUgPSBQYXJzZVRyZWVUeXBlLlVOSU9OX1RZUEU7XG4gIHZhciBVbmlvblR5cGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFVuaW9uVHlwZShsb2NhdGlvbiwgdHlwZXMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFVuaW9uVHlwZSkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShVbmlvblR5cGUsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVVuaW9uVHlwZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VW5pb25UeXBlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVU5JT05fVFlQRTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBWQVJJQUJMRV9ERUNMQVJBVElPTiA9IFBhcnNlVHJlZVR5cGUuVkFSSUFCTEVfREVDTEFSQVRJT047XG4gIHZhciBWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0aW9uKGxvY2F0aW9uLCBsdmFsdWUsIHR5cGVBbm5vdGF0aW9uLCBpbml0aWFsaXplcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVmFyaWFibGVEZWNsYXJhdGlvbikuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmx2YWx1ZSA9IGx2YWx1ZTtcbiAgICAgIHRoaXMudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhcmlhYmxlRGVjbGFyYXRpb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24odGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWQVJJQUJMRV9ERUNMQVJBVElPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUID0gUGFyc2VUcmVlVHlwZS5WQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUO1xuICB2YXIgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGxvY2F0aW9uLCBkZWNsYXJhdGlvblR5cGUsIGRlY2xhcmF0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5kZWNsYXJhdGlvblR5cGUgPSBkZWNsYXJhdGlvblR5cGU7XG4gICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodGhpcyk7XG4gICAgICB9LFxuICAgICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFZBUklBQkxFX1NUQVRFTUVOVCA9IFBhcnNlVHJlZVR5cGUuVkFSSUFCTEVfU1RBVEVNRU5UO1xuICB2YXIgVmFyaWFibGVTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFZhcmlhYmxlU3RhdGVtZW50KGxvY2F0aW9uLCBkZWNsYXJhdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFZhcmlhYmxlU3RhdGVtZW50KS5jYWxsKHRoaXMsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVmFyaWFibGVTdGF0ZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVZhcmlhYmxlU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRWYXJpYWJsZVN0YXRlbWVudCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZBUklBQkxFX1NUQVRFTUVOVDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHZhciBXSElMRV9TVEFURU1FTlQgPSBQYXJzZVRyZWVUeXBlLldISUxFX1NUQVRFTUVOVDtcbiAgdmFyIFdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBXaGlsZVN0YXRlbWVudChsb2NhdGlvbiwgY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihXaGlsZVN0YXRlbWVudCkuY2FsbCh0aGlzLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShXaGlsZVN0YXRlbWVudCwge1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtV2hpbGVTdGF0ZW1lbnQodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFdoaWxlU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gV0hJTEVfU1RBVEVNRU5UO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlKTtcbiAgdmFyIFdJVEhfU1RBVEVNRU5UID0gUGFyc2VUcmVlVHlwZS5XSVRIX1NUQVRFTUVOVDtcbiAgdmFyIFdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFdpdGhTdGF0ZW1lbnQobG9jYXRpb24sIGV4cHJlc3Npb24sIGJvZHkpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFdpdGhTdGF0ZW1lbnQpLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShXaXRoU3RhdGVtZW50LCB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1XaXRoU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRXaXRoU3RhdGVtZW50KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gV0lUSF9TVEFURU1FTlQ7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICB2YXIgWUlFTERfRVhQUkVTU0lPTiA9IFBhcnNlVHJlZVR5cGUuWUlFTERfRVhQUkVTU0lPTjtcbiAgdmFyIFlpZWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKGxvY2F0aW9uLCBleHByZXNzaW9uLCBpc1lpZWxkRm9yKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihZaWVsZEV4cHJlc3Npb24pLmNhbGwodGhpcywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIHRoaXMuaXNZaWVsZEZvciA9IGlzWWllbGRGb3I7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShZaWVsZEV4cHJlc3Npb24sIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybVlpZWxkRXhwcmVzc2lvbih0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0WWllbGRFeHByZXNzaW9uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gWUlFTERfRVhQUkVTU0lPTjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IEFubm90YXRpb24oKSB7XG4gICAgICByZXR1cm4gQW5ub3RhdGlvbjtcbiAgICB9LFxuICAgIGdldCBBbm9uQmxvY2soKSB7XG4gICAgICByZXR1cm4gQW5vbkJsb2NrO1xuICAgIH0sXG4gICAgZ2V0IEFyZ3VtZW50TGlzdCgpIHtcbiAgICAgIHJldHVybiBBcmd1bWVudExpc3Q7XG4gICAgfSxcbiAgICBnZXQgQXJyYXlDb21wcmVoZW5zaW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5Q29tcHJlaGVuc2lvbjtcbiAgICB9LFxuICAgIGdldCBBcnJheUxpdGVyYWwoKSB7XG4gICAgICByZXR1cm4gQXJyYXlMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IEFycmF5UGF0dGVybigpIHtcbiAgICAgIHJldHVybiBBcnJheVBhdHRlcm47XG4gICAgfSxcbiAgICBnZXQgQXJyYXlUeXBlKCkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZTtcbiAgICB9LFxuICAgIGdldCBBcnJvd0Z1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycm93RnVuY3Rpb247XG4gICAgfSxcbiAgICBnZXQgQXNzaWdubWVudEVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gQXNzaWdubWVudEVsZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgQXdhaXRFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIEF3YWl0RXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIEJpbmFyeUV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgQmluZGluZ0VsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gQmluZGluZ0VsZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgQmluZGluZ0lkZW50aWZpZXIoKSB7XG4gICAgICByZXR1cm4gQmluZGluZ0lkZW50aWZpZXI7XG4gICAgfSxcbiAgICBnZXQgQmxvY2soKSB7XG4gICAgICByZXR1cm4gQmxvY2s7XG4gICAgfSxcbiAgICBnZXQgQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gQnJlYWtTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgQ2FsbEV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gQ2FsbEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgQ2FsbFNpZ25hdHVyZSgpIHtcbiAgICAgIHJldHVybiBDYWxsU2lnbmF0dXJlO1xuICAgIH0sXG4gICAgZ2V0IENhc2VDbGF1c2UoKSB7XG4gICAgICByZXR1cm4gQ2FzZUNsYXVzZTtcbiAgICB9LFxuICAgIGdldCBDYXRjaCgpIHtcbiAgICAgIHJldHVybiBDYXRjaDtcbiAgICB9LFxuICAgIGdldCBDbGFzc0RlY2xhcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIENsYXNzRGVjbGFyYXRpb247XG4gICAgfSxcbiAgICBnZXQgQ2xhc3NFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIENsYXNzRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBDb21tYUV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gQ29tbWFFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IENvbXByZWhlbnNpb25Gb3IoKSB7XG4gICAgICByZXR1cm4gQ29tcHJlaGVuc2lvbkZvcjtcbiAgICB9LFxuICAgIGdldCBDb21wcmVoZW5zaW9uSWYoKSB7XG4gICAgICByZXR1cm4gQ29tcHJlaGVuc2lvbklmO1xuICAgIH0sXG4gICAgZ2V0IENvbXB1dGVkUHJvcGVydHlOYW1lKCkge1xuICAgICAgcmV0dXJuIENvbXB1dGVkUHJvcGVydHlOYW1lO1xuICAgIH0sXG4gICAgZ2V0IENvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgQ29uc3RydWN0U2lnbmF0dXJlKCkge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdFNpZ25hdHVyZTtcbiAgICB9LFxuICAgIGdldCBDb25zdHJ1Y3RvclR5cGUoKSB7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3JUeXBlO1xuICAgIH0sXG4gICAgZ2V0IENvbnRpbnVlU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIENvbnRpbnVlU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IENvdmVyRm9ybWFscygpIHtcbiAgICAgIHJldHVybiBDb3ZlckZvcm1hbHM7XG4gICAgfSxcbiAgICBnZXQgQ292ZXJJbml0aWFsaXplZE5hbWUoKSB7XG4gICAgICByZXR1cm4gQ292ZXJJbml0aWFsaXplZE5hbWU7XG4gICAgfSxcbiAgICBnZXQgRGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgRGVmYXVsdENsYXVzZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0Q2xhdXNlO1xuICAgIH0sXG4gICAgZ2V0IERvV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gRG9XaGlsZVN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBFbXB0eVN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBFbXB0eVN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICAgIHJldHVybiBFeHBvcnREZWNsYXJhdGlvbjtcbiAgICB9LFxuICAgIGdldCBFeHBvcnREZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIEV4cG9ydERlZmF1bHQ7XG4gICAgfSxcbiAgICBnZXQgRXhwb3J0U3BlY2lmaWVyKCkge1xuICAgICAgcmV0dXJuIEV4cG9ydFNwZWNpZmllcjtcbiAgICB9LFxuICAgIGdldCBFeHBvcnRTcGVjaWZpZXJTZXQoKSB7XG4gICAgICByZXR1cm4gRXhwb3J0U3BlY2lmaWVyU2V0O1xuICAgIH0sXG4gICAgZ2V0IEV4cG9ydFN0YXIoKSB7XG4gICAgICByZXR1cm4gRXhwb3J0U3RhcjtcbiAgICB9LFxuICAgIGdldCBFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgRmluYWxseSgpIHtcbiAgICAgIHJldHVybiBGaW5hbGx5O1xuICAgIH0sXG4gICAgZ2V0IEZvckluU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIEZvckluU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IEZvck9mU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIEZvck9mU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IEZvck9uU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIEZvck9uU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IEZvclN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgRm9ybWFsUGFyYW1ldGVyKCkge1xuICAgICAgcmV0dXJuIEZvcm1hbFBhcmFtZXRlcjtcbiAgICB9LFxuICAgIGdldCBGb3JtYWxQYXJhbWV0ZXJMaXN0KCkge1xuICAgICAgcmV0dXJuIEZvcm1hbFBhcmFtZXRlckxpc3Q7XG4gICAgfSxcbiAgICBnZXQgRm9yd2FyZERlZmF1bHRFeHBvcnQoKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZERlZmF1bHRFeHBvcnQ7XG4gICAgfSxcbiAgICBnZXQgRnVuY3Rpb25Cb2R5KCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uQm9keTtcbiAgICB9LFxuICAgIGdldCBGdW5jdGlvbkRlY2xhcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgfSxcbiAgICBnZXQgRnVuY3Rpb25FeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBGdW5jdGlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gRnVuY3Rpb25UeXBlO1xuICAgIH0sXG4gICAgZ2V0IEdlbmVyYXRvckNvbXByZWhlbnNpb24oKSB7XG4gICAgICByZXR1cm4gR2VuZXJhdG9yQ29tcHJlaGVuc2lvbjtcbiAgICB9LFxuICAgIGdldCBHZXRBY2Nlc3NvcigpIHtcbiAgICAgIHJldHVybiBHZXRBY2Nlc3NvcjtcbiAgICB9LFxuICAgIGdldCBJZGVudGlmaWVyRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBJZGVudGlmaWVyRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBJZlN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBJZlN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBJbXBvcnRlZEJpbmRpbmcoKSB7XG4gICAgICByZXR1cm4gSW1wb3J0ZWRCaW5kaW5nO1xuICAgIH0sXG4gICAgZ2V0IEltcG9ydENsYXVzZVBhaXIoKSB7XG4gICAgICByZXR1cm4gSW1wb3J0Q2xhdXNlUGFpcjtcbiAgICB9LFxuICAgIGdldCBJbXBvcnREZWNsYXJhdGlvbigpIHtcbiAgICAgIHJldHVybiBJbXBvcnREZWNsYXJhdGlvbjtcbiAgICB9LFxuICAgIGdldCBJbXBvcnRTcGVjaWZpZXIoKSB7XG4gICAgICByZXR1cm4gSW1wb3J0U3BlY2lmaWVyO1xuICAgIH0sXG4gICAgZ2V0IEltcG9ydFNwZWNpZmllclNldCgpIHtcbiAgICAgIHJldHVybiBJbXBvcnRTcGVjaWZpZXJTZXQ7XG4gICAgfSxcbiAgICBnZXQgSW1wb3J0VHlwZUNsYXVzZSgpIHtcbiAgICAgIHJldHVybiBJbXBvcnRUeXBlQ2xhdXNlO1xuICAgIH0sXG4gICAgZ2V0IEluZGV4U2lnbmF0dXJlKCkge1xuICAgICAgcmV0dXJuIEluZGV4U2lnbmF0dXJlO1xuICAgIH0sXG4gICAgZ2V0IEludGVyZmFjZURlY2xhcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIEludGVyZmFjZURlY2xhcmF0aW9uO1xuICAgIH0sXG4gICAgZ2V0IEpzeEF0dHJpYnV0ZSgpIHtcbiAgICAgIHJldHVybiBKc3hBdHRyaWJ1dGU7XG4gICAgfSxcbiAgICBnZXQgSnN4RWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBKc3hFbGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IEpzeEVsZW1lbnROYW1lKCkge1xuICAgICAgcmV0dXJuIEpzeEVsZW1lbnROYW1lO1xuICAgIH0sXG4gICAgZ2V0IEpzeFBsYWNlaG9sZGVyKCkge1xuICAgICAgcmV0dXJuIEpzeFBsYWNlaG9sZGVyO1xuICAgIH0sXG4gICAgZ2V0IEpzeFNwcmVhZEF0dHJpYnV0ZSgpIHtcbiAgICAgIHJldHVybiBKc3hTcHJlYWRBdHRyaWJ1dGU7XG4gICAgfSxcbiAgICBnZXQgSnN4VGV4dCgpIHtcbiAgICAgIHJldHVybiBKc3hUZXh0O1xuICAgIH0sXG4gICAgZ2V0IExhYmVsbGVkU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIExhYmVsbGVkU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IExpdGVyYWxFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIExpdGVyYWxFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IExpdGVyYWxQcm9wZXJ0eU5hbWUoKSB7XG4gICAgICByZXR1cm4gTGl0ZXJhbFByb3BlcnR5TmFtZTtcbiAgICB9LFxuICAgIGdldCBNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIE1lbWJlckV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgTWVtYmVyTG9va3VwRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBNZW1iZXJMb29rdXBFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IE1ldGhvZCgpIHtcbiAgICAgIHJldHVybiBNZXRob2Q7XG4gICAgfSxcbiAgICBnZXQgTWV0aG9kU2lnbmF0dXJlKCkge1xuICAgICAgcmV0dXJuIE1ldGhvZFNpZ25hdHVyZTtcbiAgICB9LFxuICAgIGdldCBNb2R1bGUoKSB7XG4gICAgICByZXR1cm4gTW9kdWxlO1xuICAgIH0sXG4gICAgZ2V0IE1vZHVsZVNwZWNpZmllcigpIHtcbiAgICAgIHJldHVybiBNb2R1bGVTcGVjaWZpZXI7XG4gICAgfSxcbiAgICBnZXQgTmFtZVNwYWNlRXhwb3J0KCkge1xuICAgICAgcmV0dXJuIE5hbWVTcGFjZUV4cG9ydDtcbiAgICB9LFxuICAgIGdldCBOYW1lU3BhY2VJbXBvcnQoKSB7XG4gICAgICByZXR1cm4gTmFtZVNwYWNlSW1wb3J0O1xuICAgIH0sXG4gICAgZ2V0IE5hbWVkRXhwb3J0KCkge1xuICAgICAgcmV0dXJuIE5hbWVkRXhwb3J0O1xuICAgIH0sXG4gICAgZ2V0IE5ld0V4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gTmV3RXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBPYmplY3RMaXRlcmFsKCkge1xuICAgICAgcmV0dXJuIE9iamVjdExpdGVyYWw7XG4gICAgfSxcbiAgICBnZXQgT2JqZWN0UGF0dGVybigpIHtcbiAgICAgIHJldHVybiBPYmplY3RQYXR0ZXJuO1xuICAgIH0sXG4gICAgZ2V0IE9iamVjdFBhdHRlcm5GaWVsZCgpIHtcbiAgICAgIHJldHVybiBPYmplY3RQYXR0ZXJuRmllbGQ7XG4gICAgfSxcbiAgICBnZXQgT2JqZWN0VHlwZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3RUeXBlO1xuICAgIH0sXG4gICAgZ2V0IFBhcmVuRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBQYXJlbkV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gUG9zdGZpeEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgUHJlZGVmaW5lZFR5cGUoKSB7XG4gICAgICByZXR1cm4gUHJlZGVmaW5lZFR5cGU7XG4gICAgfSxcbiAgICBnZXQgU2NyaXB0KCkge1xuICAgICAgcmV0dXJuIFNjcmlwdDtcbiAgICB9LFxuICAgIGdldCBQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KCkge1xuICAgICAgcmV0dXJuIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQ7XG4gICAgfSxcbiAgICBnZXQgUHJvcGVydHlOYW1lU2hvcnRoYW5kKCkge1xuICAgICAgcmV0dXJuIFByb3BlcnR5TmFtZVNob3J0aGFuZDtcbiAgICB9LFxuICAgIGdldCBQcm9wZXJ0eVZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgICByZXR1cm4gUHJvcGVydHlWYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgIH0sXG4gICAgZ2V0IFByb3BlcnR5U2lnbmF0dXJlKCkge1xuICAgICAgcmV0dXJuIFByb3BlcnR5U2lnbmF0dXJlO1xuICAgIH0sXG4gICAgZ2V0IFJlc3RQYXJhbWV0ZXIoKSB7XG4gICAgICByZXR1cm4gUmVzdFBhcmFtZXRlcjtcbiAgICB9LFxuICAgIGdldCBSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IFNldEFjY2Vzc29yKCkge1xuICAgICAgcmV0dXJuIFNldEFjY2Vzc29yO1xuICAgIH0sXG4gICAgZ2V0IFNwcmVhZEV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gU3ByZWFkRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBTcHJlYWRQYXR0ZXJuRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBTcHJlYWRQYXR0ZXJuRWxlbWVudDtcbiAgICB9LFxuICAgIGdldCBTdXBlckV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gU3VwZXJFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IFN3aXRjaFN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBTd2l0Y2hTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgU3ludGF4RXJyb3JUcmVlKCkge1xuICAgICAgcmV0dXJuIFN5bnRheEVycm9yVHJlZTtcbiAgICB9LFxuICAgIGdldCBUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgVGVtcGxhdGVMaXRlcmFsUG9ydGlvbigpIHtcbiAgICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uO1xuICAgIH0sXG4gICAgZ2V0IFRlbXBsYXRlU3Vic3RpdHV0aW9uKCkge1xuICAgICAgcmV0dXJuIFRlbXBsYXRlU3Vic3RpdHV0aW9uO1xuICAgIH0sXG4gICAgZ2V0IFRoaXNFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIFRoaXNFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IFRocm93U3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIFRocm93U3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IFRyeVN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBUcnlTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgVHlwZUFsaWFzRGVjbGFyYXRpb24oKSB7XG4gICAgICByZXR1cm4gVHlwZUFsaWFzRGVjbGFyYXRpb247XG4gICAgfSxcbiAgICBnZXQgVHlwZUFyZ3VtZW50cygpIHtcbiAgICAgIHJldHVybiBUeXBlQXJndW1lbnRzO1xuICAgIH0sXG4gICAgZ2V0IFR5cGVOYW1lKCkge1xuICAgICAgcmV0dXJuIFR5cGVOYW1lO1xuICAgIH0sXG4gICAgZ2V0IFR5cGVQYXJhbWV0ZXIoKSB7XG4gICAgICByZXR1cm4gVHlwZVBhcmFtZXRlcjtcbiAgICB9LFxuICAgIGdldCBUeXBlUGFyYW1ldGVycygpIHtcbiAgICAgIHJldHVybiBUeXBlUGFyYW1ldGVycztcbiAgICB9LFxuICAgIGdldCBUeXBlUmVmZXJlbmNlKCkge1xuICAgICAgcmV0dXJuIFR5cGVSZWZlcmVuY2U7XG4gICAgfSxcbiAgICBnZXQgVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIFVuYXJ5RXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBVbmlvblR5cGUoKSB7XG4gICAgICByZXR1cm4gVW5pb25UeXBlO1xuICAgIH0sXG4gICAgZ2V0IFZhcmlhYmxlRGVjbGFyYXRpb24oKSB7XG4gICAgICByZXR1cm4gVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICB9LFxuICAgIGdldCBWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpIHtcbiAgICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0aW9uTGlzdDtcbiAgICB9LFxuICAgIGdldCBWYXJpYWJsZVN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBWYXJpYWJsZVN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBXaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBXaGlsZVN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBXaXRoU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIFdpdGhTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgWWllbGRFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIFlpZWxkRXhwcmVzc2lvbjtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5ub3RhdGlvbiA9ICRfXzIuQW5ub3RhdGlvbixcbiAgICAgIEFub25CbG9jayA9ICRfXzIuQW5vbkJsb2NrLFxuICAgICAgQXJndW1lbnRMaXN0ID0gJF9fMi5Bcmd1bWVudExpc3QsXG4gICAgICBBcnJheUNvbXByZWhlbnNpb24gPSAkX18yLkFycmF5Q29tcHJlaGVuc2lvbixcbiAgICAgIEFycmF5TGl0ZXJhbCA9ICRfXzIuQXJyYXlMaXRlcmFsLFxuICAgICAgQXJyYXlQYXR0ZXJuID0gJF9fMi5BcnJheVBhdHRlcm4sXG4gICAgICBBcnJheVR5cGUgPSAkX18yLkFycmF5VHlwZSxcbiAgICAgIEFycm93RnVuY3Rpb24gPSAkX18yLkFycm93RnVuY3Rpb24sXG4gICAgICBBc3NpZ25tZW50RWxlbWVudCA9ICRfXzIuQXNzaWdubWVudEVsZW1lbnQsXG4gICAgICBBd2FpdEV4cHJlc3Npb24gPSAkX18yLkF3YWl0RXhwcmVzc2lvbixcbiAgICAgIEJpbmFyeUV4cHJlc3Npb24gPSAkX18yLkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBCaW5kaW5nRWxlbWVudCA9ICRfXzIuQmluZGluZ0VsZW1lbnQsXG4gICAgICBCaW5kaW5nSWRlbnRpZmllciA9ICRfXzIuQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBCbG9jayA9ICRfXzIuQmxvY2ssXG4gICAgICBCcmVha1N0YXRlbWVudCA9ICRfXzIuQnJlYWtTdGF0ZW1lbnQsXG4gICAgICBDYWxsRXhwcmVzc2lvbiA9ICRfXzIuQ2FsbEV4cHJlc3Npb24sXG4gICAgICBDYWxsU2lnbmF0dXJlID0gJF9fMi5DYWxsU2lnbmF0dXJlLFxuICAgICAgQ2FzZUNsYXVzZSA9ICRfXzIuQ2FzZUNsYXVzZSxcbiAgICAgIENhdGNoID0gJF9fMi5DYXRjaCxcbiAgICAgIENsYXNzRGVjbGFyYXRpb24gPSAkX18yLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgICBDbGFzc0V4cHJlc3Npb24gPSAkX18yLkNsYXNzRXhwcmVzc2lvbixcbiAgICAgIENvbW1hRXhwcmVzc2lvbiA9ICRfXzIuQ29tbWFFeHByZXNzaW9uLFxuICAgICAgQ29tcHJlaGVuc2lvbkZvciA9ICRfXzIuQ29tcHJlaGVuc2lvbkZvcixcbiAgICAgIENvbXByZWhlbnNpb25JZiA9ICRfXzIuQ29tcHJlaGVuc2lvbklmLFxuICAgICAgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUgPSAkX18yLkNvbXB1dGVkUHJvcGVydHlOYW1lLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gJF9fMi5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICBDb25zdHJ1Y3RTaWduYXR1cmUgPSAkX18yLkNvbnN0cnVjdFNpZ25hdHVyZSxcbiAgICAgIENvbnN0cnVjdG9yVHlwZSA9ICRfXzIuQ29uc3RydWN0b3JUeXBlLFxuICAgICAgQ29udGludWVTdGF0ZW1lbnQgPSAkX18yLkNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgQ292ZXJGb3JtYWxzID0gJF9fMi5Db3ZlckZvcm1hbHMsXG4gICAgICBDb3ZlckluaXRpYWxpemVkTmFtZSA9ICRfXzIuQ292ZXJJbml0aWFsaXplZE5hbWUsXG4gICAgICBEZWJ1Z2dlclN0YXRlbWVudCA9ICRfXzIuRGVidWdnZXJTdGF0ZW1lbnQsXG4gICAgICBEZWZhdWx0Q2xhdXNlID0gJF9fMi5EZWZhdWx0Q2xhdXNlLFxuICAgICAgRG9XaGlsZVN0YXRlbWVudCA9ICRfXzIuRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgIEVtcHR5U3RhdGVtZW50ID0gJF9fMi5FbXB0eVN0YXRlbWVudCxcbiAgICAgIEV4cG9ydERlY2xhcmF0aW9uID0gJF9fMi5FeHBvcnREZWNsYXJhdGlvbixcbiAgICAgIEV4cG9ydERlZmF1bHQgPSAkX18yLkV4cG9ydERlZmF1bHQsXG4gICAgICBFeHBvcnRTcGVjaWZpZXIgPSAkX18yLkV4cG9ydFNwZWNpZmllcixcbiAgICAgIEV4cG9ydFNwZWNpZmllclNldCA9ICRfXzIuRXhwb3J0U3BlY2lmaWVyU2V0LFxuICAgICAgRXhwb3J0U3RhciA9ICRfXzIuRXhwb3J0U3RhcixcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX18yLkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBGaW5hbGx5ID0gJF9fMi5GaW5hbGx5LFxuICAgICAgRm9ySW5TdGF0ZW1lbnQgPSAkX18yLkZvckluU3RhdGVtZW50LFxuICAgICAgRm9yT2ZTdGF0ZW1lbnQgPSAkX18yLkZvck9mU3RhdGVtZW50LFxuICAgICAgRm9yT25TdGF0ZW1lbnQgPSAkX18yLkZvck9uU3RhdGVtZW50LFxuICAgICAgRm9yU3RhdGVtZW50ID0gJF9fMi5Gb3JTdGF0ZW1lbnQsXG4gICAgICBGb3JtYWxQYXJhbWV0ZXIgPSAkX18yLkZvcm1hbFBhcmFtZXRlcixcbiAgICAgIEZvcm1hbFBhcmFtZXRlckxpc3QgPSAkX18yLkZvcm1hbFBhcmFtZXRlckxpc3QsXG4gICAgICBGb3J3YXJkRGVmYXVsdEV4cG9ydCA9ICRfXzIuRm9yd2FyZERlZmF1bHRFeHBvcnQsXG4gICAgICBGdW5jdGlvbkJvZHkgPSAkX18yLkZ1bmN0aW9uQm9keSxcbiAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAkX18yLkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb24gPSAkX18yLkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgIEZ1bmN0aW9uVHlwZSA9ICRfXzIuRnVuY3Rpb25UeXBlLFxuICAgICAgR2VuZXJhdG9yQ29tcHJlaGVuc2lvbiA9ICRfXzIuR2VuZXJhdG9yQ29tcHJlaGVuc2lvbixcbiAgICAgIEdldEFjY2Vzc29yID0gJF9fMi5HZXRBY2Nlc3NvcixcbiAgICAgIElkZW50aWZpZXJFeHByZXNzaW9uID0gJF9fMi5JZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIElmU3RhdGVtZW50ID0gJF9fMi5JZlN0YXRlbWVudCxcbiAgICAgIEltcG9ydGVkQmluZGluZyA9ICRfXzIuSW1wb3J0ZWRCaW5kaW5nLFxuICAgICAgSW1wb3J0Q2xhdXNlUGFpciA9ICRfXzIuSW1wb3J0Q2xhdXNlUGFpcixcbiAgICAgIEltcG9ydERlY2xhcmF0aW9uID0gJF9fMi5JbXBvcnREZWNsYXJhdGlvbixcbiAgICAgIEltcG9ydFNwZWNpZmllciA9ICRfXzIuSW1wb3J0U3BlY2lmaWVyLFxuICAgICAgSW1wb3J0U3BlY2lmaWVyU2V0ID0gJF9fMi5JbXBvcnRTcGVjaWZpZXJTZXQsXG4gICAgICBJbXBvcnRUeXBlQ2xhdXNlID0gJF9fMi5JbXBvcnRUeXBlQ2xhdXNlLFxuICAgICAgSW5kZXhTaWduYXR1cmUgPSAkX18yLkluZGV4U2lnbmF0dXJlLFxuICAgICAgSW50ZXJmYWNlRGVjbGFyYXRpb24gPSAkX18yLkludGVyZmFjZURlY2xhcmF0aW9uLFxuICAgICAgSnN4QXR0cmlidXRlID0gJF9fMi5Kc3hBdHRyaWJ1dGUsXG4gICAgICBKc3hFbGVtZW50ID0gJF9fMi5Kc3hFbGVtZW50LFxuICAgICAgSnN4RWxlbWVudE5hbWUgPSAkX18yLkpzeEVsZW1lbnROYW1lLFxuICAgICAgSnN4UGxhY2Vob2xkZXIgPSAkX18yLkpzeFBsYWNlaG9sZGVyLFxuICAgICAgSnN4U3ByZWFkQXR0cmlidXRlID0gJF9fMi5Kc3hTcHJlYWRBdHRyaWJ1dGUsXG4gICAgICBKc3hUZXh0ID0gJF9fMi5Kc3hUZXh0LFxuICAgICAgTGFiZWxsZWRTdGF0ZW1lbnQgPSAkX18yLkxhYmVsbGVkU3RhdGVtZW50LFxuICAgICAgTGl0ZXJhbEV4cHJlc3Npb24gPSAkX18yLkxpdGVyYWxFeHByZXNzaW9uLFxuICAgICAgTGl0ZXJhbFByb3BlcnR5TmFtZSA9ICRfXzIuTGl0ZXJhbFByb3BlcnR5TmFtZSxcbiAgICAgIE1lbWJlckV4cHJlc3Npb24gPSAkX18yLk1lbWJlckV4cHJlc3Npb24sXG4gICAgICBNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fMi5NZW1iZXJMb29rdXBFeHByZXNzaW9uLFxuICAgICAgTWV0aG9kID0gJF9fMi5NZXRob2QsXG4gICAgICBNZXRob2RTaWduYXR1cmUgPSAkX18yLk1ldGhvZFNpZ25hdHVyZSxcbiAgICAgIE1vZHVsZSA9ICRfXzIuTW9kdWxlLFxuICAgICAgTW9kdWxlU3BlY2lmaWVyID0gJF9fMi5Nb2R1bGVTcGVjaWZpZXIsXG4gICAgICBOYW1lU3BhY2VFeHBvcnQgPSAkX18yLk5hbWVTcGFjZUV4cG9ydCxcbiAgICAgIE5hbWVTcGFjZUltcG9ydCA9ICRfXzIuTmFtZVNwYWNlSW1wb3J0LFxuICAgICAgTmFtZWRFeHBvcnQgPSAkX18yLk5hbWVkRXhwb3J0LFxuICAgICAgTmV3RXhwcmVzc2lvbiA9ICRfXzIuTmV3RXhwcmVzc2lvbixcbiAgICAgIE9iamVjdExpdGVyYWwgPSAkX18yLk9iamVjdExpdGVyYWwsXG4gICAgICBPYmplY3RQYXR0ZXJuID0gJF9fMi5PYmplY3RQYXR0ZXJuLFxuICAgICAgT2JqZWN0UGF0dGVybkZpZWxkID0gJF9fMi5PYmplY3RQYXR0ZXJuRmllbGQsXG4gICAgICBPYmplY3RUeXBlID0gJF9fMi5PYmplY3RUeXBlLFxuICAgICAgUGFyZW5FeHByZXNzaW9uID0gJF9fMi5QYXJlbkV4cHJlc3Npb24sXG4gICAgICBQb3N0Zml4RXhwcmVzc2lvbiA9ICRfXzIuUG9zdGZpeEV4cHJlc3Npb24sXG4gICAgICBQcmVkZWZpbmVkVHlwZSA9ICRfXzIuUHJlZGVmaW5lZFR5cGUsXG4gICAgICBTY3JpcHQgPSAkX18yLlNjcmlwdCxcbiAgICAgIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQgPSAkX18yLlByb3BlcnR5TmFtZUFzc2lnbm1lbnQsXG4gICAgICBQcm9wZXJ0eU5hbWVTaG9ydGhhbmQgPSAkX18yLlByb3BlcnR5TmFtZVNob3J0aGFuZCxcbiAgICAgIFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbiA9ICRfXzIuUHJvcGVydHlWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgUHJvcGVydHlTaWduYXR1cmUgPSAkX18yLlByb3BlcnR5U2lnbmF0dXJlLFxuICAgICAgUmVzdFBhcmFtZXRlciA9ICRfXzIuUmVzdFBhcmFtZXRlcixcbiAgICAgIFJldHVyblN0YXRlbWVudCA9ICRfXzIuUmV0dXJuU3RhdGVtZW50LFxuICAgICAgU2V0QWNjZXNzb3IgPSAkX18yLlNldEFjY2Vzc29yLFxuICAgICAgU3ByZWFkRXhwcmVzc2lvbiA9ICRfXzIuU3ByZWFkRXhwcmVzc2lvbixcbiAgICAgIFNwcmVhZFBhdHRlcm5FbGVtZW50ID0gJF9fMi5TcHJlYWRQYXR0ZXJuRWxlbWVudCxcbiAgICAgIFN1cGVyRXhwcmVzc2lvbiA9ICRfXzIuU3VwZXJFeHByZXNzaW9uLFxuICAgICAgU3dpdGNoU3RhdGVtZW50ID0gJF9fMi5Td2l0Y2hTdGF0ZW1lbnQsXG4gICAgICBTeW50YXhFcnJvclRyZWUgPSAkX18yLlN5bnRheEVycm9yVHJlZSxcbiAgICAgIFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24gPSAkX18yLlRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uID0gJF9fMi5UZW1wbGF0ZUxpdGVyYWxQb3J0aW9uLFxuICAgICAgVGVtcGxhdGVTdWJzdGl0dXRpb24gPSAkX18yLlRlbXBsYXRlU3Vic3RpdHV0aW9uLFxuICAgICAgVGhpc0V4cHJlc3Npb24gPSAkX18yLlRoaXNFeHByZXNzaW9uLFxuICAgICAgVGhyb3dTdGF0ZW1lbnQgPSAkX18yLlRocm93U3RhdGVtZW50LFxuICAgICAgVHJ5U3RhdGVtZW50ID0gJF9fMi5UcnlTdGF0ZW1lbnQsXG4gICAgICBUeXBlQWxpYXNEZWNsYXJhdGlvbiA9ICRfXzIuVHlwZUFsaWFzRGVjbGFyYXRpb24sXG4gICAgICBUeXBlQXJndW1lbnRzID0gJF9fMi5UeXBlQXJndW1lbnRzLFxuICAgICAgVHlwZU5hbWUgPSAkX18yLlR5cGVOYW1lLFxuICAgICAgVHlwZVBhcmFtZXRlciA9ICRfXzIuVHlwZVBhcmFtZXRlcixcbiAgICAgIFR5cGVQYXJhbWV0ZXJzID0gJF9fMi5UeXBlUGFyYW1ldGVycyxcbiAgICAgIFR5cGVSZWZlcmVuY2UgPSAkX18yLlR5cGVSZWZlcmVuY2UsXG4gICAgICBVbmFyeUV4cHJlc3Npb24gPSAkX18yLlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgIFVuaW9uVHlwZSA9ICRfXzIuVW5pb25UeXBlLFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbiA9ICRfXzIuVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gJF9fMi5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIFZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMi5WYXJpYWJsZVN0YXRlbWVudCxcbiAgICAgIFdoaWxlU3RhdGVtZW50ID0gJF9fMi5XaGlsZVN0YXRlbWVudCxcbiAgICAgIFdpdGhTdGF0ZW1lbnQgPSAkX18yLldpdGhTdGF0ZW1lbnQsXG4gICAgICBZaWVsZEV4cHJlc3Npb24gPSAkX18yLllpZWxkRXhwcmVzc2lvbjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VUcmVlVHJhbnNmb3JtZXIoKSB7fVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQYXJzZVRyZWVUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtQW55OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlID09PSBudWxsID8gbnVsbCA6IHRyZWUudHJhbnNmb3JtKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxpc3Q6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdmFyICRfXzE7XG4gICAgICAgIHZhciBidWlsZGVyID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0aGlzLnRyYW5zZm9ybUFueShlbGVtZW50KTtcbiAgICAgICAgICBpZiAoYnVpbGRlciAhPSBudWxsIHx8IGVsZW1lbnQgIT0gdHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIGlmIChidWlsZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXIgPSBsaXN0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZCBpbnN0YW5jZW9mIEFub25CbG9jaylcbiAgICAgICAgICAgICAgKCRfXzEgPSBidWlsZGVyKS5wdXNoLmFwcGx5KCRfXzEsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodHJhbnNmb3JtZWQuc3RhdGVtZW50cykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBidWlsZGVyLnB1c2godHJhbnNmb3JtZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlciB8fCBsaXN0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVN0YXRlTWFjaGluZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignU3RhdGUgbWFjaGluZXMgc2hvdWxkIG5vdCBsaXZlIG91dHNpZGUgb2YgdGhlIEdlbmVyYXRvclRyYW5zZm9ybWVyLicpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRvQmxvY2tPclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkIGluc3RhbmNlb2YgQW5vbkJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCbG9jayh0cmFuc2Zvcm1lZC5sb2NhdGlvbiwgdHJhbnNmb3JtZWQuc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFubm90YXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYXJncyk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgYXJncyA9PT0gdHJlZS5hcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRyZWUubG9jYXRpb24sIG5hbWUsIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFub25CbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnN0YXRlbWVudHMpO1xuICAgICAgICBpZiAoc3RhdGVtZW50cyA9PT0gdHJlZS5zdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sodHJlZS5sb2NhdGlvbiwgc3RhdGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXJndW1lbnRMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYXJncyk7XG4gICAgICAgIGlmIChhcmdzID09PSB0cmVlLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFyZ3VtZW50TGlzdCh0cmVlLmxvY2F0aW9uLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BcnJheUNvbXByZWhlbnNpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGNvbXByZWhlbnNpb25MaXN0ID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuY29tcHJlaGVuc2lvbkxpc3QpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChjb21wcmVoZW5zaW9uTGlzdCA9PT0gdHJlZS5jb21wcmVoZW5zaW9uTGlzdCAmJiBleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29tcHJlaGVuc2lvbih0cmVlLmxvY2F0aW9uLCBjb21wcmVoZW5zaW9uTGlzdCwgZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXJyYXlMaXRlcmFsOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmVsZW1lbnRzKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzID09PSB0cmVlLmVsZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpdGVyYWwodHJlZS5sb2NhdGlvbiwgZWxlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycmF5UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIGlmIChlbGVtZW50cyA9PT0gdHJlZS5lbGVtZW50cykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlQYXR0ZXJuKHRyZWUubG9jYXRpb24sIGVsZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BcnJheVR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5lbGVtZW50VHlwZSk7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdHJlZS5lbGVtZW50VHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKHRyZWUubG9jYXRpb24sIGVsZW1lbnRUeXBlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BcnJvd0Z1bmN0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJvZHkpO1xuICAgICAgICBpZiAocGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyb3dGdW5jdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLmZ1bmN0aW9uS2luZCwgcGFyYW1ldGVyTGlzdCwgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXNzaWdubWVudEVsZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmFzc2lnbm1lbnQpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQgPT09IHRyZWUuYXNzaWdubWVudCAmJiBpbml0aWFsaXplciA9PT0gdHJlZS5pbml0aWFsaXplcikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXNzaWdubWVudEVsZW1lbnQodHJlZS5sb2NhdGlvbiwgYXNzaWdubWVudCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUF3YWl0RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEF3YWl0RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIGlmIChsZWZ0ID09PSB0cmVlLmxlZnQgJiYgcmlnaHQgPT09IHRyZWUucmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbGVmdCwgdHJlZS5vcGVyYXRvciwgcmlnaHQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJpbmRpbmdFbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIGlmIChiaW5kaW5nID09PSB0cmVlLmJpbmRpbmcgJiYgaW5pdGlhbGl6ZXIgPT09IHRyZWUuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdFbGVtZW50KHRyZWUubG9jYXRpb24sIGJpbmRpbmcsIGluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5kaW5nSWRlbnRpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnN0YXRlbWVudHMpO1xuICAgICAgICBpZiAoc3RhdGVtZW50cyA9PT0gdHJlZS5zdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayh0cmVlLmxvY2F0aW9uLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CcmVha1N0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5hcmdzKTtcbiAgICAgICAgaWYgKG9wZXJhbmQgPT09IHRyZWUub3BlcmFuZCAmJiBhcmdzID09PSB0cmVlLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENhbGxFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG9wZXJhbmQsIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNhbGxTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIHJldHVyblR5cGUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJldHVyblR5cGUpO1xuICAgICAgICBpZiAodHlwZVBhcmFtZXRlcnMgPT09IHRyZWUudHlwZVBhcmFtZXRlcnMgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIHJldHVyblR5cGUgPT09IHRyZWUucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbFNpZ25hdHVyZSh0cmVlLmxvY2F0aW9uLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2FzZUNsYXVzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuc3RhdGVtZW50cyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24gJiYgc3RhdGVtZW50cyA9PT0gdHJlZS5zdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDYXNlQ2xhdXNlKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24sIHN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNhdGNoOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgdmFyIGNhdGNoQm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY2F0Y2hCb2R5KTtcbiAgICAgICAgaWYgKGJpbmRpbmcgPT09IHRyZWUuYmluZGluZyAmJiBjYXRjaEJvZHkgPT09IHRyZWUuY2F0Y2hCb2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDYXRjaCh0cmVlLmxvY2F0aW9uLCBiaW5kaW5nLCBjYXRjaEJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmVsZW1lbnRzKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHRyZWUubmFtZSAmJiBzdXBlckNsYXNzID09PSB0cmVlLnN1cGVyQ2xhc3MgJiYgZWxlbWVudHMgPT09IHRyZWUuZWxlbWVudHMgJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMgJiYgdHlwZVBhcmFtZXRlcnMgPT09IHRyZWUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENsYXNzRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgbmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIGFubm90YXRpb25zLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgc3VwZXJDbGFzcyA9PT0gdHJlZS5zdXBlckNsYXNzICYmIGVsZW1lbnRzID09PSB0cmVlLmVsZW1lbnRzICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIHR5cGVQYXJhbWV0ZXJzID09PSB0cmVlLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0V4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIGFubm90YXRpb25zLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29tbWFFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zID09PSB0cmVlLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21tYUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbXByZWhlbnNpb25Gb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmxlZnQpO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLml0ZXJhdG9yKTtcbiAgICAgICAgaWYgKGxlZnQgPT09IHRyZWUubGVmdCAmJiBpdGVyYXRvciA9PT0gdHJlZS5pdGVyYXRvcikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlaGVuc2lvbkZvcih0cmVlLmxvY2F0aW9uLCBsZWZ0LCBpdGVyYXRvcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29tcHJlaGVuc2lvbklmOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHRyZWUuZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlaGVuc2lvbklmKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbXB1dGVkUHJvcGVydHlOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHRyZWUuZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZWRQcm9wZXJ0eU5hbWUodHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHRyZWUuY29uZGl0aW9uICYmIGxlZnQgPT09IHRyZWUubGVmdCAmJiByaWdodCA9PT0gdHJlZS5yaWdodCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGNvbmRpdGlvbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbnN0cnVjdFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmV0dXJuVHlwZSk7XG4gICAgICAgIGlmICh0eXBlUGFyYW1ldGVycyA9PT0gdHJlZS50eXBlUGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJMaXN0ID09PSB0cmVlLnBhcmFtZXRlckxpc3QgJiYgcmV0dXJuVHlwZSA9PT0gdHJlZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RTaWduYXR1cmUodHJlZS5sb2NhdGlvbiwgdHlwZVBhcmFtZXRlcnMsIHBhcmFtZXRlckxpc3QsIHJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbnN0cnVjdG9yVHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmV0dXJuVHlwZSk7XG4gICAgICAgIGlmICh0eXBlUGFyYW1ldGVycyA9PT0gdHJlZS50eXBlUGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJMaXN0ID09PSB0cmVlLnBhcmFtZXRlckxpc3QgJiYgcmV0dXJuVHlwZSA9PT0gdHJlZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvclR5cGUodHJlZS5sb2NhdGlvbiwgdHlwZVBhcmFtZXRlcnMsIHBhcmFtZXRlckxpc3QsIHJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvdmVyRm9ybWFsczogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyA9PT0gdHJlZS5leHByZXNzaW9ucykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ292ZXJGb3JtYWxzKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db3ZlckluaXRpYWxpemVkTmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb3ZlckluaXRpYWxpemVkTmFtZSh0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuZXF1YWxUb2tlbiwgaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybURlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybURlZmF1bHRDbGF1c2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zdGF0ZW1lbnRzKTtcbiAgICAgICAgaWYgKHN0YXRlbWVudHMgPT09IHRyZWUuc3RhdGVtZW50cykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdENsYXVzZSh0cmVlLmxvY2F0aW9uLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Eb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1Ub0Jsb2NrT3JTdGF0ZW1lbnQodHJlZS5ib2R5KTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKGJvZHkgPT09IHRyZWUuYm9keSAmJiBjb25kaXRpb24gPT09IHRyZWUuY29uZGl0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEb1doaWxlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGJvZHksIGNvbmRpdGlvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5kZWNsYXJhdGlvbik7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uID09PSB0cmVlLmRlY2xhcmF0aW9uICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBvcnREZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBkZWNsYXJhdGlvbiwgYW5ub3RhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydERlZmF1bHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdHJlZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBvcnREZWZhdWx0KHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnRTcGVjaWZpZXJTZXQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHNwZWNpZmllcnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zcGVjaWZpZXJzKTtcbiAgICAgICAgaWYgKHNwZWNpZmllcnMgPT09IHRyZWUuc3BlY2lmaWVycykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXhwb3J0U3BlY2lmaWVyU2V0KHRyZWUubG9jYXRpb24sIHNwZWNpZmllcnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFN0YXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRmluYWxseTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJsb2NrKTtcbiAgICAgICAgaWYgKGJsb2NrID09PSB0cmVlLmJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaW5hbGx5KHRyZWUubG9jYXRpb24sIGJsb2NrKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtVG9CbG9ja09yU3RhdGVtZW50KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChpbml0aWFsaXplciA9PT0gdHJlZS5pbml0aWFsaXplciAmJiBjb2xsZWN0aW9uID09PSB0cmVlLmNvbGxlY3Rpb24gJiYgYm9keSA9PT0gdHJlZS5ib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JJblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBpbml0aWFsaXplciwgY29sbGVjdGlvbiwgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5jb2xsZWN0aW9uKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybVRvQmxvY2tPclN0YXRlbWVudCh0cmVlLmJvZHkpO1xuICAgICAgICBpZiAoaW5pdGlhbGl6ZXIgPT09IHRyZWUuaW5pdGlhbGl6ZXIgJiYgY29sbGVjdGlvbiA9PT0gdHJlZS5jb2xsZWN0aW9uICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRm9yT2ZTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgaW5pdGlhbGl6ZXIsIGNvbGxlY3Rpb24sIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvck9uU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub2JzZXJ2YWJsZSk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1Ub0Jsb2NrT3JTdGF0ZW1lbnQodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyICYmIG9ic2VydmFibGUgPT09IHRyZWUub2JzZXJ2YWJsZSAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvck9uU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGluaXRpYWxpemVyLCBvYnNlcnZhYmxlLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluY3JlbWVudCk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1Ub0Jsb2NrT3JTdGF0ZW1lbnQodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyICYmIGNvbmRpdGlvbiA9PT0gdHJlZS5jb25kaXRpb24gJiYgaW5jcmVtZW50ID09PSB0cmVlLmluY3JlbWVudCAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvclN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBpbml0aWFsaXplciwgY29uZGl0aW9uLCBpbmNyZW1lbnQsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvcm1hbFBhcmFtZXRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgcGFyYW1ldGVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXIpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICBpZiAocGFyYW1ldGVyID09PSB0cmVlLnBhcmFtZXRlciAmJiB0eXBlQW5ub3RhdGlvbiA9PT0gdHJlZS50eXBlQW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9ucyA9PT0gdHJlZS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWFsUGFyYW1ldGVyKHRyZWUubG9jYXRpb24sIHBhcmFtZXRlciwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JtYWxQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUucGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB0cmVlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hbFBhcmFtZXRlckxpc3QodHJlZS5sb2NhdGlvbiwgcGFyYW1ldGVycyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yd2FyZERlZmF1bHRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25Cb2R5OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuc3RhdGVtZW50cyk7XG4gICAgICAgIGlmIChzdGF0ZW1lbnRzID09PSB0cmVlLnN0YXRlbWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQm9keSh0cmVlLmxvY2F0aW9uLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIHR5cGVBbm5vdGF0aW9uID09PSB0cmVlLnR5cGVBbm5vdGF0aW9uICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBuYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgcGFyYW1ldGVyTGlzdCwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHRyZWUubmFtZSAmJiBwYXJhbWV0ZXJMaXN0ID09PSB0cmVlLnBhcmFtZXRlckxpc3QgJiYgdHlwZUFubm90YXRpb24gPT09IHRyZWUudHlwZUFubm90YXRpb24gJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMgJiYgYm9keSA9PT0gdHJlZS5ib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbmFtZSwgdHJlZS5mdW5jdGlvbktpbmQsIHBhcmFtZXRlckxpc3QsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25UeXBlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yZXR1cm5UeXBlKTtcbiAgICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzID09PSB0cmVlLnR5cGVQYXJhbWV0ZXJzICYmIHBhcmFtZXRlckxpc3QgPT09IHRyZWUucGFyYW1ldGVyTGlzdCAmJiByZXR1cm5UeXBlID09PSB0cmVlLnJldHVyblR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uVHlwZSh0cmVlLmxvY2F0aW9uLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtR2VuZXJhdG9yQ29tcHJlaGVuc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgY29tcHJlaGVuc2lvbkxpc3QgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5jb21wcmVoZW5zaW9uTGlzdCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGNvbXByZWhlbnNpb25MaXN0ID09PSB0cmVlLmNvbXByZWhlbnNpb25MaXN0ICYmIGV4cHJlc3Npb24gPT09IHRyZWUuZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJhdG9yQ29tcHJlaGVuc2lvbih0cmVlLmxvY2F0aW9uLCBjb21wcmVoZW5zaW9uTGlzdCwgZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtR2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgdHlwZUFubm90YXRpb24gPT09IHRyZWUudHlwZUFubm90YXRpb24gJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMgJiYgYm9keSA9PT0gdHJlZS5ib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBuYW1lLCB0eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUlmU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHZhciBpZkNsYXVzZSA9IHRoaXMudHJhbnNmb3JtVG9CbG9ja09yU3RhdGVtZW50KHRyZWUuaWZDbGF1c2UpO1xuICAgICAgICB2YXIgZWxzZUNsYXVzZSA9IHRoaXMudHJhbnNmb3JtVG9CbG9ja09yU3RhdGVtZW50KHRyZWUuZWxzZUNsYXVzZSk7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHRyZWUuY29uZGl0aW9uICYmIGlmQ2xhdXNlID09PSB0cmVlLmlmQ2xhdXNlICYmIGVsc2VDbGF1c2UgPT09IHRyZWUuZWxzZUNsYXVzZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSWZTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgY29uZGl0aW9uLCBpZkNsYXVzZSwgZWxzZUNsYXVzZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW1wb3J0ZWRCaW5kaW5nOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgaWYgKGJpbmRpbmcgPT09IHRyZWUuYmluZGluZykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW1wb3J0ZWRCaW5kaW5nKHRyZWUubG9jYXRpb24sIGJpbmRpbmcpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUltcG9ydENsYXVzZVBhaXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5maXJzdCk7XG4gICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnNlY29uZCk7XG4gICAgICAgIGlmIChmaXJzdCA9PT0gdHJlZS5maXJzdCAmJiBzZWNvbmQgPT09IHRyZWUuc2Vjb25kKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRDbGF1c2VQYWlyKHRyZWUubG9jYXRpb24sIGZpcnN0LCBzZWNvbmQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbXBvcnRDbGF1c2UgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmltcG9ydENsYXVzZSk7XG4gICAgICAgIHZhciBtb2R1bGVTcGVjaWZpZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIGlmIChpbXBvcnRDbGF1c2UgPT09IHRyZWUuaW1wb3J0Q2xhdXNlICYmIG1vZHVsZVNwZWNpZmllciA9PT0gdHJlZS5tb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEltcG9ydERlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIGltcG9ydENsYXVzZSwgbW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJpbmRpbmcpO1xuICAgICAgICBpZiAoYmluZGluZyA9PT0gdHJlZS5iaW5kaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRTcGVjaWZpZXIodHJlZS5sb2NhdGlvbiwgYmluZGluZywgdHJlZS5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnRTcGVjaWZpZXJTZXQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHNwZWNpZmllcnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zcGVjaWZpZXJzKTtcbiAgICAgICAgaWYgKHNwZWNpZmllcnMgPT09IHRyZWUuc3BlY2lmaWVycykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW1wb3J0U3BlY2lmaWVyU2V0KHRyZWUubG9jYXRpb24sIHNwZWNpZmllcnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUltcG9ydFR5cGVDbGF1c2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY2xhdXNlKTtcbiAgICAgICAgaWYgKGNsYXVzZSA9PT0gdHJlZS5jbGF1c2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEltcG9ydFR5cGVDbGF1c2UodHJlZS5sb2NhdGlvbiwgY2xhdXNlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbmRleFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaW5kZXhUeXBlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbmRleFR5cGUpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgaWYgKGluZGV4VHlwZSA9PT0gdHJlZS5pbmRleFR5cGUgJiYgdHlwZUFubm90YXRpb24gPT09IHRyZWUudHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEluZGV4U2lnbmF0dXJlKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgaW5kZXhUeXBlLCB0eXBlQW5ub3RhdGlvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW50ZXJmYWNlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHZhciBvYmplY3RUeXBlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vYmplY3RUeXBlKTtcbiAgICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzID09PSB0cmVlLnR5cGVQYXJhbWV0ZXJzICYmIG9iamVjdFR5cGUgPT09IHRyZWUub2JqZWN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCB0eXBlUGFyYW1ldGVycywgdHJlZS5leHRlbmRzQ2xhdXNlLCBvYmplY3RUeXBlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hBdHRyaWJ1dGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS52YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJlZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSnN4QXR0cmlidXRlKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeEVsZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmF0dHJpYnV0ZXMpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5jaGlsZHJlbik7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgYXR0cmlidXRlcyA9PT0gdHJlZS5hdHRyaWJ1dGVzICYmIGNoaWxkcmVuID09PSB0cmVlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBKc3hFbGVtZW50KHRyZWUubG9jYXRpb24sIG5hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hFbGVtZW50TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hQbGFjZWhvbGRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEpzeFBsYWNlaG9sZGVyKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeFNwcmVhZEF0dHJpYnV0ZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEpzeFNwcmVhZEF0dHJpYnV0ZSh0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hUZXh0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxhYmVsbGVkU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN0YXRlbWVudCk7XG4gICAgICAgIGlmIChzdGF0ZW1lbnQgPT09IHRyZWUuc3RhdGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYWJlbGxlZFN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHN0YXRlbWVudCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGl0ZXJhbFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgaWYgKG9wZXJhbmQgPT09IHRyZWUub3BlcmFuZCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWVtYmVyRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBvcGVyYW5kLCB0cmVlLm1lbWJlck5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlckxvb2t1cEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB2YXIgbWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChvcGVyYW5kID09PSB0cmVlLm9wZXJhbmQgJiYgbWVtYmVyRXhwcmVzc2lvbiA9PT0gdHJlZS5tZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZW1iZXJMb29rdXBFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG9wZXJhbmQsIG1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJvZHkpO1xuICAgICAgICB2YXIgZGVidWdOYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5kZWJ1Z05hbWUpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIHBhcmFtZXRlckxpc3QgPT09IHRyZWUucGFyYW1ldGVyTGlzdCAmJiB0eXBlQW5ub3RhdGlvbiA9PT0gdHJlZS50eXBlQW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9ucyA9PT0gdHJlZS5hbm5vdGF0aW9ucyAmJiBib2R5ID09PSB0cmVlLmJvZHkgJiYgZGVidWdOYW1lID09PSB0cmVlLmRlYnVnTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kKHRyZWUubG9jYXRpb24sIHRyZWUuaXNTdGF0aWMsIHRyZWUuZnVuY3Rpb25LaW5kLCBuYW1lLCBwYXJhbWV0ZXJMaXN0LCB0eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGJvZHksIGRlYnVnTmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWV0aG9kU2lnbmF0dXJlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIGNhbGxTaWduYXR1cmUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNhbGxTaWduYXR1cmUpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIGNhbGxTaWduYXR1cmUgPT09IHRyZWUuY2FsbFNpZ25hdHVyZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kU2lnbmF0dXJlKHRyZWUubG9jYXRpb24sIG5hbWUsIHRyZWUub3B0aW9uYWwsIGNhbGxTaWduYXR1cmUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zY3JpcHRJdGVtTGlzdCk7XG4gICAgICAgIGlmIChzY3JpcHRJdGVtTGlzdCA9PT0gdHJlZS5zY3JpcHRJdGVtTGlzdCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTW9kdWxlKHRyZWUubG9jYXRpb24sIHNjcmlwdEl0ZW1MaXN0LCB0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1OYW1lU3BhY2VFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTmFtZVNwYWNlSW1wb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgaWYgKGJpbmRpbmcgPT09IHRyZWUuYmluZGluZykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmFtZVNwYWNlSW1wb3J0KHRyZWUubG9jYXRpb24sIGJpbmRpbmcpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHBvcnRDbGF1c2UgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cG9ydENsYXVzZSk7XG4gICAgICAgIHZhciBtb2R1bGVTcGVjaWZpZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIGlmIChleHBvcnRDbGF1c2UgPT09IHRyZWUuZXhwb3J0Q2xhdXNlICYmIG1vZHVsZVNwZWNpZmllciA9PT0gdHJlZS5tb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkRXhwb3J0KHRyZWUubG9jYXRpb24sIGV4cG9ydENsYXVzZSwgbW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1OZXdFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmFyZ3MpO1xuICAgICAgICBpZiAob3BlcmFuZCA9PT0gdHJlZS5vcGVyYW5kICYmIGFyZ3MgPT09IHRyZWUuYXJncykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmV3RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBvcGVyYW5kLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1PYmplY3RMaXRlcmFsOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVBbmRWYWx1ZXMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5wcm9wZXJ0eU5hbWVBbmRWYWx1ZXMpO1xuICAgICAgICBpZiAocHJvcGVydHlOYW1lQW5kVmFsdWVzID09PSB0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0TGl0ZXJhbCh0cmVlLmxvY2F0aW9uLCBwcm9wZXJ0eU5hbWVBbmRWYWx1ZXMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdFBhdHRlcm46IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmZpZWxkcyk7XG4gICAgICAgIGlmIChmaWVsZHMgPT09IHRyZWUuZmllbGRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RQYXR0ZXJuKHRyZWUubG9jYXRpb24sIGZpZWxkcyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtT2JqZWN0UGF0dGVybkZpZWxkOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmVsZW1lbnQpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIGVsZW1lbnQgPT09IHRyZWUuZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0UGF0dGVybkZpZWxkKHRyZWUubG9jYXRpb24sIG5hbWUsIGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdFR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHR5cGVNZW1iZXJzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUudHlwZU1lbWJlcnMpO1xuICAgICAgICBpZiAodHlwZU1lbWJlcnMgPT09IHRyZWUudHlwZU1lbWJlcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFR5cGUodHJlZS5sb2NhdGlvbiwgdHlwZU1lbWJlcnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVBhcmVuRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcmVuRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Qb3N0Zml4RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIGlmIChvcGVyYW5kID09PSB0cmVlLm9wZXJhbmQpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RmaXhFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG9wZXJhbmQsIHRyZWUub3BlcmF0b3IpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByZWRlZmluZWRUeXBlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zY3JpcHRJdGVtTGlzdCk7XG4gICAgICAgIGlmIChzY3JpcHRJdGVtTGlzdCA9PT0gdHJlZS5zY3JpcHRJdGVtTGlzdCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0KHRyZWUubG9jYXRpb24sIHNjcmlwdEl0ZW1MaXN0LCB0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByb3BlcnR5TmFtZUFzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnZhbHVlKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHRyZWUubmFtZSAmJiB2YWx1ZSA9PT0gdHJlZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlOYW1lQXNzaWdubWVudCh0cmVlLmxvY2F0aW9uLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUHJvcGVydHlOYW1lU2hvcnRoYW5kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIHR5cGVBbm5vdGF0aW9uID09PSB0cmVlLnR5cGVBbm5vdGF0aW9uICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVZhcmlhYmxlRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgbmFtZSwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBpbml0aWFsaXplcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUHJvcGVydHlTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHRyZWUubmFtZSAmJiB0eXBlQW5ub3RhdGlvbiA9PT0gdHJlZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlTaWduYXR1cmUodHJlZS5sb2NhdGlvbiwgbmFtZSwgdHJlZS5vcHRpb25hbCwgdHlwZUFubm90YXRpb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVJlc3RQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdHJlZS5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXN0UGFyYW1ldGVyKHRyZWUubG9jYXRpb24sIGlkZW50aWZpZXIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVJldHVyblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2V0QWNjZXNzb3IodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgbmFtZSwgcGFyYW1ldGVyTGlzdCwgYW5ub3RhdGlvbnMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNwcmVhZEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdHJlZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJlYWRFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNwcmVhZFBhdHRlcm5FbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICAgIGlmIChsdmFsdWUgPT09IHRyZWUubHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJlYWRQYXR0ZXJuRWxlbWVudCh0cmVlLmxvY2F0aW9uLCBsdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVN1cGVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Td2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgY2FzZUNsYXVzZXMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5jYXNlQ2xhdXNlcyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24gJiYgY2FzZUNsYXVzZXMgPT09IHRyZWUuY2FzZUNsYXVzZXMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN3aXRjaFN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uLCBjYXNlQ2xhdXNlcyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU3ludGF4RXJyb3JUcmVlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIGlmIChvcGVyYW5kID09PSB0cmVlLm9wZXJhbmQgJiYgZWxlbWVudHMgPT09IHRyZWUuZWxlbWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgb3BlcmFuZCwgZWxlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlTGl0ZXJhbFBvcnRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVGVtcGxhdGVTdWJzdGl0dXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdHJlZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVN1YnN0aXR1dGlvbih0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UaHJvd1N0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cmVlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUaHJvd1N0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVHJ5U3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgdmFyIGNhdGNoQmxvY2sgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNhdGNoQmxvY2spO1xuICAgICAgICB2YXIgZmluYWxseUJsb2NrID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5maW5hbGx5QmxvY2spO1xuICAgICAgICBpZiAoYm9keSA9PT0gdHJlZS5ib2R5ICYmIGNhdGNoQmxvY2sgPT09IHRyZWUuY2F0Y2hCbG9jayAmJiBmaW5hbGx5QmxvY2sgPT09IHRyZWUuZmluYWxseUJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcnlTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgYm9keSwgY2F0Y2hCbG9jaywgZmluYWxseUJsb2NrKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UeXBlQWxpYXNEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cmVlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlQWxpYXNEZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UeXBlQXJndW1lbnRzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYXJncyk7XG4gICAgICAgIGlmIChhcmdzID09PSB0cmVlLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFR5cGVBcmd1bWVudHModHJlZS5sb2NhdGlvbiwgYXJncyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVHlwZU5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG1vZHVsZU5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgICBpZiAobW9kdWxlTmFtZSA9PT0gdHJlZS5tb2R1bGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlTmFtZSh0cmVlLmxvY2F0aW9uLCBtb2R1bGVOYW1lLCB0cmVlLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVR5cGVQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4dGVuZHNUeXBlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHRlbmRzVHlwZSk7XG4gICAgICAgIGlmIChleHRlbmRzVHlwZSA9PT0gdHJlZS5leHRlbmRzVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZVBhcmFtZXRlcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlkZW50aWZpZXJUb2tlbiwgZXh0ZW5kc1R5cGUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVR5cGVQYXJhbWV0ZXJzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUucGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB0cmVlLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFR5cGVQYXJhbWV0ZXJzKHRyZWUubG9jYXRpb24sIHBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVR5cGVSZWZlcmVuY2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlTmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5hcmdzKTtcbiAgICAgICAgaWYgKHR5cGVOYW1lID09PSB0cmVlLnR5cGVOYW1lICYmIGFyZ3MgPT09IHRyZWUuYXJncykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZVJlZmVyZW5jZSh0cmVlLmxvY2F0aW9uLCB0eXBlTmFtZSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgaWYgKG9wZXJhbmQgPT09IHRyZWUub3BlcmFuZCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVW5hcnlFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRyZWUub3BlcmF0b3IsIG9wZXJhbmQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVVuaW9uVHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHlwZXMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS50eXBlcyk7XG4gICAgICAgIGlmICh0eXBlcyA9PT0gdHJlZS50eXBlcykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVW5pb25UeXBlKHRyZWUubG9jYXRpb24sIHR5cGVzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1WYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgaWYgKGx2YWx1ZSA9PT0gdHJlZS5sdmFsdWUgJiYgdHlwZUFubm90YXRpb24gPT09IHRyZWUudHlwZUFubm90YXRpb24gJiYgaW5pdGlhbGl6ZXIgPT09IHRyZWUuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgbHZhbHVlLCB0eXBlQW5ub3RhdGlvbiwgaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zID09PSB0cmVlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodHJlZS5sb2NhdGlvbiwgdHJlZS5kZWNsYXJhdGlvblR5cGUsIGRlY2xhcmF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb25zKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9ucyA9PT0gdHJlZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGRlY2xhcmF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY29uZGl0aW9uKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybVRvQmxvY2tPclN0YXRlbWVudCh0cmVlLmJvZHkpO1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB0cmVlLmNvbmRpdGlvbiAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdoaWxlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGNvbmRpdGlvbiwgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtV2l0aFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1Ub0Jsb2NrT3JTdGF0ZW1lbnQodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHRyZWUuZXhwcmVzc2lvbiAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdpdGhTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbiwgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHRyZWUuZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWWllbGRFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24sIHRyZWUuaXNZaWVsZEZvcik7XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIHJldHVybiB7Z2V0IFBhcnNlVHJlZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9BdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvQXR0YWNoTW9kdWxlTmFtZVRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0F0dGFjaE1vZHVsZU5hbWVUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX18yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvQXR0YWNoTW9kdWxlTmFtZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIE1vZHVsZSA9ICRfXzIuTW9kdWxlLFxuICAgICAgU2NyaXB0ID0gJF9fMi5TY3JpcHQ7XG4gIHZhciBBdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEF0dGFjaE1vZHVsZU5hbWVUcmFuc2Zvcm1lcihtb2R1bGVOYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1vZHVsZU5hbWVfID0gbW9kdWxlTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEF0dGFjaE1vZHVsZU5hbWVUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtTW9kdWxlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9kdWxlKHRyZWUubG9jYXRpb24sIHRyZWUuc2NyaXB0SXRlbUxpc3QsIHRoaXMubW9kdWxlTmFtZV8pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjcmlwdCh0cmVlLmxvY2F0aW9uLCB0cmVlLnNjcmlwdEl0ZW1MaXN0LCB0aGlzLm1vZHVsZU5hbWVfKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgQXR0YWNoTW9kdWxlTmFtZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEF0dGFjaE1vZHVsZU5hbWVUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvSWRlbnRpZmllclRva2VuLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0lkZW50aWZpZXJUb2tlbi5qc1wiO1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0lkZW50aWZpZXJUb2tlbi5qc1wiKSkuVG9rZW47XG4gIHZhciBJREVOVElGSUVSID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvSWRlbnRpZmllclRva2VuLmpzXCIpKS5JREVOVElGSUVSO1xuICB2YXIgSWRlbnRpZmllclRva2VuID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBJZGVudGlmaWVyVG9rZW4obG9jYXRpb24sIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihJZGVudGlmaWVyVG9rZW4pLmNhbGwodGhpcywgSURFTlRJRklFUiwgbG9jYXRpb24pO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSWRlbnRpZmllclRva2VuLCB7dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRva2VuKTtcbiAgcmV0dXJuIHtnZXQgSWRlbnRpZmllclRva2VuKCkge1xuICAgICAgcmV0dXJuIElkZW50aWZpZXJUb2tlbjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvTGl0ZXJhbFRva2VuLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiO1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiKSkuVG9rZW47XG4gIHZhciAkX18xMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiKSksXG4gICAgICBOVUxMID0gJF9fMTEuTlVMTCxcbiAgICAgIE5VTUJFUiA9ICRfXzExLk5VTUJFUixcbiAgICAgIFNUUklORyA9ICRfXzExLlNUUklORztcbiAgdmFyIFN0cmluZ1BhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciAkX18yO1xuICAgIGZ1bmN0aW9uIFN0cmluZ1BhcnNlcih2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTdHJpbmdQYXJzZXIsICgkX18yID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18yLCBTeW1ib2wuaXRlcmF0b3IsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18yLCBcIm5leHRcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoKyt0aGlzLmluZGV4ID49IHRoaXMudmFsdWUubGVuZ3RoIC0gMSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlW3RoaXMuaW5kZXhdLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18yLCBcInBhcnNlXCIsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuaW5kZXhPZignXFxcXCcpID09PSAtMSlcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyICRfXzYgPSB0cnVlO1xuICAgICAgICB2YXIgJF9fNyA9IGZhbHNlO1xuICAgICAgICB2YXIgJF9fOCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciAkX180ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAkX18zID0gKHRoaXMpW1N5bWJvbC5pdGVyYXRvcl0oKTsgISgkX182ID0gKCRfXzQgPSAkX18zLm5leHQoKSkuZG9uZSk7ICRfXzYgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSAkX180LnZhbHVlO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gY2ggPT09ICdcXFxcJyA/IHRoaXMucGFyc2VFc2NhcGVTZXF1ZW5jZSgpIDogY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICgkX185KSB7XG4gICAgICAgICAgJF9fNyA9IHRydWU7XG4gICAgICAgICAgJF9fOCA9ICRfXzk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghJF9fNiAmJiAkX18zLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICRfXzMucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICgkX183KSB7XG4gICAgICAgICAgICAgIHRocm93ICRfXzg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgkX18yLCBcInBhcnNlRXNjYXBlU2VxdWVuY2VcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLm5leHQoKS52YWx1ZTtcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICBjYXNlICdcXHUyMDI4JzpcbiAgICAgICAgICBjYXNlICdcXHUyMDI5JzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIHJldHVybiAnXFwwJztcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHJldHVybiAnXFxiJztcbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJldHVybiAnXFxmJztcbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldHVybiAnXFxyJztcbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx0JztcbiAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx2JztcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMubmV4dCgpLnZhbHVlICsgdGhpcy5uZXh0KCkudmFsdWUsIDE2KSk7XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKG5leHRWYWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhleERpZ2l0cyA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobmV4dFZhbHVlID0gdGhpcy5uZXh0KCkudmFsdWUpICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgIGhleERpZ2l0cyArPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludChoZXhEaWdpdHMsIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDEwMDAwKSAvIDB4NDAwKSArIDB4RDgwMDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gKGNvZGVQb2ludCAtIDB4MTAwMDApICUgMHg0MDAgKyAweERDMDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCwgbG93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuZXh0VmFsdWUgKyB0aGlzLm5leHQoKS52YWx1ZSArIHRoaXMubmV4dCgpLnZhbHVlICsgdGhpcy5uZXh0KCkudmFsdWUsIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChOdW1iZXIoY2gpIDwgOClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPY3RhbCBsaXRlcmFscyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSksICRfXzIpLCB7fSk7XG4gIH0oKTtcbiAgdmFyIExpdGVyYWxUb2tlbiA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbFRva2VuKHR5cGUsIHZhbHVlLCBsb2NhdGlvbikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTGl0ZXJhbFRva2VuKS5jYWxsKHRoaXMsIHR5cGUsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKExpdGVyYWxUb2tlbiwge1xuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgcHJvY2Vzc2VkVmFsdWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBOVUxMOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY2FzZSBOVU1CRVI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KDApID09PSA0OCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSA2NjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnZhbHVlLnNsaWNlKDIpLCAyKTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDExMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudmFsdWUuc2xpY2UoMiksIDgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgU1RSSU5HOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFN0cmluZ1BhcnNlcih0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShUb2tlbik7XG4gIHJldHVybiB7Z2V0IExpdGVyYWxUb2tlbigpIHtcbiAgICAgIHJldHVybiBMaXRlcmFsVG9rZW47XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9hc3NlcnQuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL2Fzc2VydC5qc1wiO1xuICBmdW5jdGlvbiBhc3NlcnQoYikge1xuICAgIGlmICghYiAmJiAkdHJhY2V1clJ1bnRpbWUub3B0aW9ucy5kZWJ1ZylcbiAgICAgIHRocm93IEVycm9yKCdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgYXNzZXJ0KCkge1xuICAgICAgcmV0dXJuIGFzc2VydDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyc2VUcmVlRmFjdG9yeS5qc1wiO1xuICB2YXIgSWRlbnRpZmllclRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9JZGVudGlmaWVyVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLklkZW50aWZpZXJUb2tlbjtcbiAgdmFyIExpdGVyYWxUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvTGl0ZXJhbFRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIpKS5MaXRlcmFsVG9rZW47XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLFxuICAgICAgUGFyc2VUcmVlID0gJF9fMy5QYXJzZVRyZWUsXG4gICAgICBQYXJzZVRyZWVUeXBlID0gJF9fMy5QYXJzZVRyZWVUeXBlO1xuICB2YXIgJF9fNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUHJlZGVmaW5lZE5hbWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLFxuICAgICAgQ0FMTCA9ICRfXzQuQ0FMTCxcbiAgICAgIENSRUFURSA9ICRfXzQuQ1JFQVRFLFxuICAgICAgREVGSU5FX1BST1BFUlRZID0gJF9fNC5ERUZJTkVfUFJPUEVSVFksXG4gICAgICBGUkVFWkUgPSAkX180LkZSRUVaRSxcbiAgICAgIE9CSkVDVCA9ICRfXzQuT0JKRUNULFxuICAgICAgVU5ERUZJTkVEID0gJF9fNC5VTkRFRklORUQ7XG4gIHZhciBUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLlRva2VuO1xuICB2YXIgJF9fNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIpKSxcbiAgICAgIEVRVUFMID0gJF9fNi5FUVVBTCxcbiAgICAgIEZBTFNFID0gJF9fNi5GQUxTRSxcbiAgICAgIE5VTEwgPSAkX182Lk5VTEwsXG4gICAgICBOVU1CRVIgPSAkX182Lk5VTUJFUixcbiAgICAgIFNUUklORyA9ICRfXzYuU1RSSU5HLFxuICAgICAgVFJVRSA9ICRfXzYuVFJVRSxcbiAgICAgIFZPSUQgPSAkX182LlZPSUQ7XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLmFzc2VydDtcbiAgdmFyICRfXzggPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcnNlVHJlZUZhY3RvcnkuanNcIikpLFxuICAgICAgQXJndW1lbnRMaXN0ID0gJF9fOC5Bcmd1bWVudExpc3QsXG4gICAgICBBcnJheUxpdGVyYWwgPSAkX184LkFycmF5TGl0ZXJhbCxcbiAgICAgIEJpbmRpbmdFbGVtZW50ID0gJF9fOC5CaW5kaW5nRWxlbWVudCxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb24gPSAkX184LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBCaW5kaW5nSWRlbnRpZmllciA9ICRfXzguQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBCbG9jayA9ICRfXzguQmxvY2ssXG4gICAgICBCcmVha1N0YXRlbWVudCA9ICRfXzguQnJlYWtTdGF0ZW1lbnQsXG4gICAgICBDYWxsRXhwcmVzc2lvbiA9ICRfXzguQ2FsbEV4cHJlc3Npb24sXG4gICAgICBDYXNlQ2xhdXNlID0gJF9fOC5DYXNlQ2xhdXNlLFxuICAgICAgQ2F0Y2ggPSAkX184LkNhdGNoLFxuICAgICAgQ2xhc3NEZWNsYXJhdGlvbiA9ICRfXzguQ2xhc3NEZWNsYXJhdGlvbixcbiAgICAgIENvbW1hRXhwcmVzc2lvbiA9ICRfXzguQ29tbWFFeHByZXNzaW9uLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gJF9fOC5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICBDb250aW51ZVN0YXRlbWVudCA9ICRfXzguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICBEZWZhdWx0Q2xhdXNlID0gJF9fOC5EZWZhdWx0Q2xhdXNlLFxuICAgICAgRG9XaGlsZVN0YXRlbWVudCA9ICRfXzguRG9XaGlsZVN0YXRlbWVudCxcbiAgICAgIEVtcHR5U3RhdGVtZW50ID0gJF9fOC5FbXB0eVN0YXRlbWVudCxcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX184LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBGaW5hbGx5ID0gJF9fOC5GaW5hbGx5LFxuICAgICAgRm9ySW5TdGF0ZW1lbnQgPSAkX184LkZvckluU3RhdGVtZW50LFxuICAgICAgRm9yT2ZTdGF0ZW1lbnQgPSAkX184LkZvck9mU3RhdGVtZW50LFxuICAgICAgRm9yU3RhdGVtZW50ID0gJF9fOC5Gb3JTdGF0ZW1lbnQsXG4gICAgICBGb3JtYWxQYXJhbWV0ZXIgPSAkX184LkZvcm1hbFBhcmFtZXRlcixcbiAgICAgIEZvcm1hbFBhcmFtZXRlckxpc3QgPSAkX184LkZvcm1hbFBhcmFtZXRlckxpc3QsXG4gICAgICBGdW5jdGlvbkJvZHkgPSAkX184LkZ1bmN0aW9uQm9keSxcbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICRfXzguRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX184LklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgSWZTdGF0ZW1lbnQgPSAkX184LklmU3RhdGVtZW50LFxuICAgICAgSW1wb3J0ZWRCaW5kaW5nID0gJF9fOC5JbXBvcnRlZEJpbmRpbmcsXG4gICAgICBMaXRlcmFsRXhwcmVzc2lvbiA9ICRfXzguTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBMaXRlcmFsUHJvcGVydHlOYW1lID0gJF9fOC5MaXRlcmFsUHJvcGVydHlOYW1lLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIE1lbWJlckxvb2t1cEV4cHJlc3Npb24gPSAkX184Lk1lbWJlckxvb2t1cEV4cHJlc3Npb24sXG4gICAgICBOZXdFeHByZXNzaW9uID0gJF9fOC5OZXdFeHByZXNzaW9uLFxuICAgICAgT2JqZWN0TGl0ZXJhbCA9ICRfXzguT2JqZWN0TGl0ZXJhbCxcbiAgICAgIFBhcmVuRXhwcmVzc2lvbiA9ICRfXzguUGFyZW5FeHByZXNzaW9uLFxuICAgICAgUG9zdGZpeEV4cHJlc3Npb24gPSAkX184LlBvc3RmaXhFeHByZXNzaW9uLFxuICAgICAgU2NyaXB0ID0gJF9fOC5TY3JpcHQsXG4gICAgICBQcm9wZXJ0eU5hbWVBc3NpZ25tZW50ID0gJF9fOC5Qcm9wZXJ0eU5hbWVBc3NpZ25tZW50LFxuICAgICAgUmVzdFBhcmFtZXRlciA9ICRfXzguUmVzdFBhcmFtZXRlcixcbiAgICAgIFJldHVyblN0YXRlbWVudCA9ICRfXzguUmV0dXJuU3RhdGVtZW50LFxuICAgICAgU3ByZWFkRXhwcmVzc2lvbiA9ICRfXzguU3ByZWFkRXhwcmVzc2lvbixcbiAgICAgIFN3aXRjaFN0YXRlbWVudCA9ICRfXzguU3dpdGNoU3RhdGVtZW50LFxuICAgICAgVGhpc0V4cHJlc3Npb24gPSAkX184LlRoaXNFeHByZXNzaW9uLFxuICAgICAgVGhyb3dTdGF0ZW1lbnQgPSAkX184LlRocm93U3RhdGVtZW50LFxuICAgICAgVHJ5U3RhdGVtZW50ID0gJF9fOC5UcnlTdGF0ZW1lbnQsXG4gICAgICBVbmFyeUV4cHJlc3Npb24gPSAkX184LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAkX184LlZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCA9ICRfXzguVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QsXG4gICAgICBWYXJpYWJsZVN0YXRlbWVudCA9ICRfXzguVmFyaWFibGVTdGF0ZW1lbnQsXG4gICAgICBXaGlsZVN0YXRlbWVudCA9ICRfXzguV2hpbGVTdGF0ZW1lbnQsXG4gICAgICBXaXRoU3RhdGVtZW50ID0gJF9fOC5XaXRoU3RhdGVtZW50O1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG4gIHZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUubWFwKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3JUb2tlbihvcGVyYXRvcikge1xuICAgIHJldHVybiBuZXcgVG9rZW4ob3BlcmF0b3IsIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyVG9rZW4obnVsbCwgaWRlbnRpZmllcik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsVG9rZW4oU1RSSU5HLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJvb2xlYW5MaXRlcmFsVG9rZW4odmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHZhbHVlID8gVFJVRSA6IEZBTFNFLCBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVOdWxsTGl0ZXJhbFRva2VuKCkge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKE5VTEwsICdudWxsJywgbnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTnVtYmVyTGl0ZXJhbFRva2VuKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsVG9rZW4oTlVNQkVSLCBTdHJpbmcodmFsdWUpLCBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QoKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYWxQYXJhbWV0ZXJMaXN0KG51bGwsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYWxQYXJhbWV0ZXIobmFtZSkge1xuICAgIHZhciBiaW5kaW5nSWRlbnRpZmllciA9IGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKG5hbWUpO1xuICAgIHJldHVybiBuZXcgRm9ybWFsUGFyYW1ldGVyKG51bGwsIG5ldyBCaW5kaW5nRWxlbWVudChudWxsLCBiaW5kaW5nSWRlbnRpZmllciwgbnVsbCksIG51bGwsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVBcmd1bWVudExpc3QobGlzdCkge1xuICAgIHJldHVybiBuZXcgQXJndW1lbnRMaXN0KG51bGwsIGxpc3QpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5QXJndW1lbnRMaXN0KCkge1xuICAgIHJldHVybiBjcmVhdGVBcmd1bWVudExpc3QoW10pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5TGl0ZXJhbChsaXN0KSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUxpdGVyYWwobnVsbCwgbGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRW1wdHlBcnJheUxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5TGl0ZXJhbChbXSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGhzLCByaHMpIHtcbiAgICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24obnVsbCwgbGhzLCBjcmVhdGVPcGVyYXRvclRva2VuKEVRVUFMKSwgcmhzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCaW5hcnlFeHByZXNzaW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuICAgIHJldHVybiBuZXcgQmluYXJ5RXhwcmVzc2lvbihudWxsLCBsZWZ0LCBvcGVyYXRvciwgcmlnaHQpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKVxuICAgICAgaWRlbnRpZmllciA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyKTtcbiAgICBlbHNlIGlmIChpZGVudGlmaWVyLnR5cGUgPT09IFBhcnNlVHJlZVR5cGUuQklORElOR19JREVOVElGSUVSKVxuICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgZWxzZSBpZiAoaWRlbnRpZmllci50eXBlID09PSBQYXJzZVRyZWVUeXBlLklERU5USUZJRVJfRVhQUkVTU0lPTilcbiAgICAgIHJldHVybiBuZXcgQmluZGluZ0lkZW50aWZpZXIoaWRlbnRpZmllci5sb2NhdGlvbiwgaWRlbnRpZmllci5pZGVudGlmaWVyVG9rZW4pO1xuICAgIHJldHVybiBuZXcgQmluZGluZ0lkZW50aWZpZXIobnVsbCwgaWRlbnRpZmllcik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW1wb3J0ZWRCaW5kaW5nKG5hbWUpIHtcbiAgICB2YXIgYmluZGluZ0lkZW50aWZpZXIgPSBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcihuYW1lKTtcbiAgICByZXR1cm4gbmV3IEltcG9ydGVkQmluZGluZyhiaW5kaW5nSWRlbnRpZmllci5sb2NhdGlvbiwgYmluZGluZ0lkZW50aWZpZXIpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUVtcHR5U3RhdGVtZW50KCkge1xuICAgIHJldHVybiBuZXcgRW1wdHlTdGF0ZW1lbnQobnVsbCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRW1wdHlCbG9jaygpIHtcbiAgICByZXR1cm4gY3JlYXRlQmxvY2soW10pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHN0YXRlbWVudHMpIHtcbiAgICByZXR1cm4gbmV3IEJsb2NrKG51bGwsIHN0YXRlbWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQm9keShzdGF0ZW1lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJvZHkobnVsbCwgc3RhdGVtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU2NvcGVkRXhwcmVzc2lvbihib2R5LCBzY29wZSkge1xuICAgIGFzc2VydChib2R5LnR5cGUgPT09ICdGVU5DVElPTl9CT0RZJyk7XG4gICAgcmV0dXJuIGNyZWF0ZUNhbGxDYWxsKGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRW1wdHlQYXJhbWV0ZXJMaXN0KCksIGJvZHkpKSwgc2NvcGUpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUltbWVkaWF0ZWx5SW52b2tlZEZ1bmN0aW9uRXhwcmVzc2lvbihib2R5KSB7XG4gICAgYXNzZXJ0KGJvZHkudHlwZSA9PT0gJ0ZVTkNUSU9OX0JPRFknKTtcbiAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QoKSwgYm9keSkpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihvcGVyYW5kKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogY3JlYXRlRW1wdHlBcmd1bWVudExpc3QoKTtcbiAgICByZXR1cm4gbmV3IENhbGxFeHByZXNzaW9uKG51bGwsIG9wZXJhbmQsIGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJyZWFrU3RhdGVtZW50KCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBCcmVha1N0YXRlbWVudChudWxsLCBuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDYWxsQ2FsbChmdW5jLCB0aGlzRXhwcmVzc2lvbikge1xuICAgIHJldHVybiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGZ1bmMsIENBTEwpLCBjcmVhdGVBcmd1bWVudExpc3QoW3RoaXNFeHByZXNzaW9uXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNhc2VDbGF1c2UoZXhwcmVzc2lvbiwgc3RhdGVtZW50cykge1xuICAgIHJldHVybiBuZXcgQ2FzZUNsYXVzZShudWxsLCBleHByZXNzaW9uLCBzdGF0ZW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDYXRjaChpZGVudGlmaWVyLCBjYXRjaEJvZHkpIHtcbiAgICBpZGVudGlmaWVyID0gY3JlYXRlQmluZGluZ0lkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgcmV0dXJuIG5ldyBDYXRjaChudWxsLCBpZGVudGlmaWVyLCBjYXRjaEJvZHkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzRGVjbGFyYXRpb24obmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzRGVjbGFyYXRpb24obnVsbCwgbmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIFtdKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcbiAgICByZXR1cm4gbmV3IENvbW1hRXhwcmVzc2lvbihudWxsLCBleHByZXNzaW9ucyk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKGNvbmRpdGlvbiwgbGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbihudWxsLCBjb25kaXRpb24sIGxlZnQsIHJpZ2h0KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIHJldHVybiBuZXcgQ29udGludWVTdGF0ZW1lbnQobnVsbCwgbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdENsYXVzZShzdGF0ZW1lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0Q2xhdXNlKG51bGwsIHN0YXRlbWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQoYm9keSwgY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBEb1doaWxlU3RhdGVtZW50KG51bGwsIGJvZHksIGNvbmRpdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudChsaHMsIHJocykge1xuICAgIHJldHVybiBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxocywgcmhzKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2FsbFN0YXRlbWVudChvcGVyYW5kKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoY3JlYXRlQ2FsbEV4cHJlc3Npb24ob3BlcmFuZCwgYXJncykpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudChudWxsLCBleHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGaW5hbGx5KGJsb2NrKSB7XG4gICAgcmV0dXJuIG5ldyBGaW5hbGx5KG51bGwsIGJsb2NrKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGb3JPZlN0YXRlbWVudChpbml0aWFsaXplciwgY29sbGVjdGlvbiwgYm9keSkge1xuICAgIHJldHVybiBuZXcgRm9yT2ZTdGF0ZW1lbnQobnVsbCwgaW5pdGlhbGl6ZXIsIGNvbGxlY3Rpb24sIGJvZHkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZvckluU3RhdGVtZW50KGluaXRpYWxpemVyLCBjb2xsZWN0aW9uLCBib2R5KSB7XG4gICAgcmV0dXJuIG5ldyBGb3JJblN0YXRlbWVudChudWxsLCBpbml0aWFsaXplciwgY29sbGVjdGlvbiwgYm9keSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRm9yU3RhdGVtZW50KHZhcmlhYmxlcywgY29uZGl0aW9uLCBpbmNyZW1lbnQsIGJvZHkpIHtcbiAgICByZXR1cm4gbmV3IEZvclN0YXRlbWVudChudWxsLCB2YXJpYWJsZXMsIGNvbmRpdGlvbiwgaW5jcmVtZW50LCBib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1ldGVyTGlzdCwgYm9keSkge1xuICAgIGFzc2VydChib2R5LnR5cGUgPT09ICdGVU5DVElPTl9CT0RZJyk7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgbnVsbCwgZmFsc2UsIHBhcmFtZXRlckxpc3QsIG51bGwsIFtdLCBib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihpZGVudGlmaWVyKSB7XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnc3RyaW5nJylcbiAgICAgIGlkZW50aWZpZXIgPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4oaWRlbnRpZmllcik7XG4gICAgZWxzZSBpZiAoaWRlbnRpZmllciBpbnN0YW5jZW9mIEJpbmRpbmdJZGVudGlmaWVyKVxuICAgICAgaWRlbnRpZmllciA9IGlkZW50aWZpZXIuaWRlbnRpZmllclRva2VuO1xuICAgIHJldHVybiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24obnVsbCwgaWRlbnRpZmllcik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVW5kZWZpbmVkRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oVU5ERUZJTkVEKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVJZlN0YXRlbWVudChjb25kaXRpb24sIGlmQ2xhdXNlKSB7XG4gICAgdmFyIGVsc2VDbGF1c2UgPSBhcmd1bWVudHNbMl0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IElmU3RhdGVtZW50KG51bGwsIGNvbmRpdGlvbiwgaWZDbGF1c2UsIGVsc2VDbGF1c2UpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKG51bGwsIGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbih2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUJvb2xlYW5MaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihudWxsLCBjcmVhdGVCb29sZWFuTGl0ZXJhbFRva2VuKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVHJ1ZUxpdGVyYWwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJvb2xlYW5MaXRlcmFsKHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZhbHNlTGl0ZXJhbCgpIHtcbiAgICByZXR1cm4gY3JlYXRlQm9vbGVhbkxpdGVyYWwoZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU51bGxMaXRlcmFsKCkge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24obnVsbCwgY3JlYXRlTnVsbExpdGVyYWxUb2tlbigpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVOdW1iZXJMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbihudWxsLCBjcmVhdGVOdW1iZXJMaXRlcmFsVG9rZW4odmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKG9wZXJhbmQsIG1lbWJlck5hbWUpIHtcbiAgICBmb3IgKHZhciBtZW1iZXJOYW1lcyA9IFtdLFxuICAgICAgICAkX18wID0gMjsgJF9fMCA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzArKylcbiAgICAgIG1lbWJlck5hbWVzWyRfXzAgLSAyXSA9IGFyZ3VtZW50c1skX18wXTtcbiAgICBpZiAodHlwZW9mIG9wZXJhbmQgPT09ICdzdHJpbmcnIHx8IG9wZXJhbmQgaW5zdGFuY2VvZiBJZGVudGlmaWVyVG9rZW4pXG4gICAgICBvcGVyYW5kID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24ob3BlcmFuZCk7XG4gICAgaWYgKHR5cGVvZiBtZW1iZXJOYW1lID09PSAnc3RyaW5nJylcbiAgICAgIG1lbWJlck5hbWUgPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4obWVtYmVyTmFtZSk7XG4gICAgaWYgKG1lbWJlck5hbWUgaW5zdGFuY2VvZiBMaXRlcmFsVG9rZW4pXG4gICAgICBtZW1iZXJOYW1lID0gbmV3IExpdGVyYWxFeHByZXNzaW9uKG51bGwsIG1lbWJlck5hbWUpO1xuICAgIHZhciB0cmVlID0gbWVtYmVyTmFtZSBpbnN0YW5jZW9mIExpdGVyYWxFeHByZXNzaW9uID8gbmV3IE1lbWJlckxvb2t1cEV4cHJlc3Npb24obnVsbCwgb3BlcmFuZCwgbWVtYmVyTmFtZSkgOiBuZXcgTWVtYmVyRXhwcmVzc2lvbihudWxsLCBvcGVyYW5kLCBtZW1iZXJOYW1lKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lbWJlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmVlID0gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbih0cmVlLCBtZW1iZXJOYW1lc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU1lbWJlckxvb2t1cEV4cHJlc3Npb24ob3BlcmFuZCwgbWVtYmVyRXhwcmVzc2lvbikge1xuICAgIHJldHVybiBuZXcgTWVtYmVyTG9va3VwRXhwcmVzc2lvbihudWxsLCBvcGVyYW5kLCBtZW1iZXJFeHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVUaGlzRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gbmV3IFRoaXNFeHByZXNzaW9uKG51bGwpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU5ld0V4cHJlc3Npb24ob3BlcmFuZCwgYXJncykge1xuICAgIHJldHVybiBuZXcgTmV3RXhwcmVzc2lvbihudWxsLCBvcGVyYW5kLCBhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RGcmVlemUodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihPQkpFQ1QsIEZSRUVaRSksIGNyZWF0ZUFyZ3VtZW50TGlzdChbdmFsdWVdKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0Q3JlYXRlKHByb3RvRXhwcmVzc2lvbikge1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYXJndW1lbnRMaXN0ID0gW3Byb3RvRXhwcmVzc2lvbl07XG4gICAgaWYgKGRlc2NyaXB0b3JzKVxuICAgICAgYXJndW1lbnRMaXN0LnB1c2goZGVzY3JpcHRvcnMpO1xuICAgIHJldHVybiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjcmVhdGVNZW1iZXJFeHByZXNzaW9uKE9CSkVDVCwgQ1JFQVRFKSwgY3JlYXRlQXJndW1lbnRMaXN0KGFyZ3VtZW50TGlzdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdExpdGVyYWxGb3JEZXNjcmlwdG9yKGRlc2NyKSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZUFuZFZhbHVlcyA9IE9iamVjdC5rZXlzKGRlc2NyKS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gZGVzY3JbbmFtZV07XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFBhcnNlVHJlZSkpXG4gICAgICAgIHZhbHVlID0gY3JlYXRlQm9vbGVhbkxpdGVyYWwoISF2YWx1ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudChuYW1lLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdExpdGVyYWwocHJvcGVydHlOYW1lQW5kVmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVEZWZpbmVQcm9wZXJ0eSh0cmVlLCBuYW1lLCBkZXNjcikge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICBuYW1lID0gY3JlYXRlU3RyaW5nTGl0ZXJhbChuYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihPQkpFQ1QsIERFRklORV9QUk9QRVJUWSksIGNyZWF0ZUFyZ3VtZW50TGlzdChbdHJlZSwgbmFtZSwgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3IoZGVzY3IpXSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdExpdGVyYWwocHJvcGVydHlOYW1lQW5kVmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RMaXRlcmFsKG51bGwsIHByb3BlcnR5TmFtZUFuZFZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gbmV3IFBhcmVuRXhwcmVzc2lvbihudWxsLCBleHByZXNzaW9uKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQb3N0Zml4RXhwcmVzc2lvbihvcGVyYW5kLCBvcGVyYXRvcikge1xuICAgIHJldHVybiBuZXcgUG9zdGZpeEV4cHJlc3Npb24obnVsbCwgb3BlcmFuZCwgb3BlcmF0b3IpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVNjcmlwdChzY3JpcHRJdGVtTGlzdCkge1xuICAgIHJldHVybiBuZXcgU2NyaXB0KG51bGwsIHNjcmlwdEl0ZW1MaXN0LCBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSAnc3RyaW5nJylcbiAgICAgIGlkZW50aWZpZXIgPSBjcmVhdGVMaXRlcmFsUHJvcGVydHlOYW1lKGlkZW50aWZpZXIpO1xuICAgIHJldHVybiBuZXcgUHJvcGVydHlOYW1lQXNzaWdubWVudChudWxsLCBpZGVudGlmaWVyLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlTGl0ZXJhbFByb3BlcnR5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJvcGVydHlOYW1lKG51bGwsIGNyZWF0ZUlkZW50aWZpZXJUb2tlbihuYW1lKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUmVzdFBhcmFtZXRlcihpZGVudGlmaWVyKSB7XG4gICAgdmFyIHJlc3QgPSBuZXcgUmVzdFBhcmFtZXRlcihudWxsLCBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG4gICAgcmV0dXJuIG5ldyBGb3JtYWxQYXJhbWV0ZXIobnVsbCwgcmVzdCwgbnVsbCwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVJldHVyblN0YXRlbWVudChleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIG5ldyBSZXR1cm5TdGF0ZW1lbnQobnVsbCwgZXhwcmVzc2lvbik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU3ByZWFkRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIG5ldyBTcHJlYWRFeHByZXNzaW9uKG51bGwsIGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVN3aXRjaFN0YXRlbWVudChleHByZXNzaW9uLCBjYXNlQ2xhdXNlcykge1xuICAgIHJldHVybiBuZXcgU3dpdGNoU3RhdGVtZW50KG51bGwsIGV4cHJlc3Npb24sIGNhc2VDbGF1c2VzKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVUaHJvd1N0YXRlbWVudCh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVGhyb3dTdGF0ZW1lbnQobnVsbCwgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVRyeVN0YXRlbWVudChib2R5LCBjYXRjaEJsb2NrKSB7XG4gICAgdmFyIGZpbmFsbHlCbG9jayA9IGFyZ3VtZW50c1syXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgIHJldHVybiBuZXcgVHJ5U3RhdGVtZW50KG51bGwsIGJvZHksIGNhdGNoQmxvY2ssIGZpbmFsbHlCbG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBvcGVyYW5kKSB7XG4gICAgcmV0dXJuIG5ldyBVbmFyeUV4cHJlc3Npb24obnVsbCwgb3BlcmF0b3IsIG9wZXJhbmQpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChjcmVhdGVTdHJpbmdMaXRlcmFsKCd1c2Ugc3RyaWN0JykpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGJpbmRpbmcsIGlkZW50aWZpZXJPckRlY2xhcmF0aW9ucykge1xuICAgIHZhciBpbml0aWFsaXplciA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoaWRlbnRpZmllck9yRGVjbGFyYXRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBpZGVudGlmaWVyT3JEZWNsYXJhdGlvbnM7XG4gICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KG51bGwsIGJpbmRpbmcsIGRlY2xhcmF0aW9ucyk7XG4gICAgfVxuICAgIHZhciBpZGVudGlmaWVyID0gaWRlbnRpZmllck9yRGVjbGFyYXRpb25zO1xuICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChiaW5kaW5nLCBbY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihpZGVudGlmaWVyLCBpbml0aWFsaXplcildKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKGlkZW50aWZpZXIsIGluaXRpYWxpemVyKSB7XG4gICAgaWYgKCEoaWRlbnRpZmllciBpbnN0YW5jZW9mIFBhcnNlVHJlZSkgfHwgaWRlbnRpZmllci50eXBlICE9PSBQYXJzZVRyZWVUeXBlLkJJTkRJTkdfSURFTlRJRklFUiAmJiBpZGVudGlmaWVyLnR5cGUgIT09IFBhcnNlVHJlZVR5cGUuT0JKRUNUX1BBVFRFUk4gJiYgaWRlbnRpZmllci50eXBlICE9PSBQYXJzZVRyZWVUeXBlLkFSUkFZX1BBVFRFUk4pIHtcbiAgICAgIGlkZW50aWZpZXIgPSBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWYXJpYWJsZURlY2xhcmF0aW9uKG51bGwsIGlkZW50aWZpZXIsIG51bGwsIGluaXRpYWxpemVyKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChsaXN0T3JCaW5kaW5nKSB7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGluaXRpYWxpemVyID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChsaXN0T3JCaW5kaW5nIGluc3RhbmNlb2YgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QpXG4gICAgICByZXR1cm4gbmV3IFZhcmlhYmxlU3RhdGVtZW50KG51bGwsIGxpc3RPckJpbmRpbmcpO1xuICAgIHZhciBiaW5kaW5nID0gbGlzdE9yQmluZGluZztcbiAgICB2YXIgbGlzdCA9IGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGJpbmRpbmcsIGlkZW50aWZpZXIsIGluaXRpYWxpemVyKTtcbiAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQobGlzdCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVm9pZDAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihjcmVhdGVVbmFyeUV4cHJlc3Npb24oY3JlYXRlT3BlcmF0b3JUb2tlbihWT0lEKSwgY3JlYXRlTnVtYmVyTGl0ZXJhbCgwKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVdoaWxlU3RhdGVtZW50KGNvbmRpdGlvbiwgYm9keSkge1xuICAgIHJldHVybiBuZXcgV2hpbGVTdGF0ZW1lbnQobnVsbCwgY29uZGl0aW9uLCBib2R5KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVXaXRoU3RhdGVtZW50KGV4cHJlc3Npb24sIGJvZHkpIHtcbiAgICByZXR1cm4gbmV3IFdpdGhTdGF0ZW1lbnQobnVsbCwgZXhwcmVzc2lvbiwgYm9keSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQXNzaWduU3RhdGVTdGF0ZW1lbnQoc3RhdGUpIHtcbiAgICByZXR1cm4gY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudChjcmVhdGVNZW1iZXJFeHByZXNzaW9uKCckY3R4JywgJ3N0YXRlJyksIGNyZWF0ZU51bWJlckxpdGVyYWwoc3RhdGUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBjcmVhdGVPcGVyYXRvclRva2VuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU9wZXJhdG9yVG9rZW47XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlSWRlbnRpZmllclRva2VuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJUb2tlbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVTdHJpbmdMaXRlcmFsVG9rZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUJvb2xlYW5MaXRlcmFsVG9rZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQm9vbGVhbkxpdGVyYWxUb2tlbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVOdWxsTGl0ZXJhbFRva2VuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU51bGxMaXRlcmFsVG9rZW47XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlTnVtYmVyTGl0ZXJhbFRva2VuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU51bWJlckxpdGVyYWxUb2tlbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlQYXJhbWV0ZXJMaXN0O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUZvcm1hbFBhcmFtZXRlcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYWxQYXJhbWV0ZXI7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlQXJndW1lbnRMaXN0KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFyZ3VtZW50TGlzdDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVFbXB0eUFyZ3VtZW50TGlzdCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eUFyZ3VtZW50TGlzdDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVBcnJheUxpdGVyYWwoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQXJyYXlMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUVtcHR5QXJyYXlMaXRlcmFsKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5QXJyYXlMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQmluYXJ5RXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVJbXBvcnRlZEJpbmRpbmcoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSW1wb3J0ZWRCaW5kaW5nO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUVtcHR5U3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5U3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUVtcHR5QmxvY2soKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlCbG9jaztcbiAgICB9LFxuICAgIGdldCBjcmVhdGVCbG9jaygpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCbG9jaztcbiAgICB9LFxuICAgIGdldCBjcmVhdGVGdW5jdGlvbkJvZHkoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25Cb2R5O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVNjb3BlZEV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2NvcGVkRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVJbW1lZGlhdGVseUludm9rZWRGdW5jdGlvbkV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSW1tZWRpYXRlbHlJbnZva2VkRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUNhbGxFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUJyZWFrU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJyZWFrU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUNhc2VDbGF1c2UoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ2FzZUNsYXVzZTtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVDYXRjaCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDYXRjaDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVDbGFzc0RlY2xhcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNsYXNzRGVjbGFyYXRpb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlQ29tbWFFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRpbnVlU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZURlZmF1bHRDbGF1c2UoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVmYXVsdENsYXVzZTtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVEb1doaWxlU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURvV2hpbGVTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUNhbGxTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ2FsbFN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlRmluYWxseSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaW5hbGx5O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUZvck9mU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvck9mU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUZvckluU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvckluU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUZvclN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGb3JTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVVbmRlZmluZWRFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVVuZGVmaW5lZEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlSWZTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlSWZTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUJvb2xlYW5MaXRlcmFsKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJvb2xlYW5MaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVRydWVMaXRlcmFsKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRydWVMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUZhbHNlTGl0ZXJhbCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGYWxzZUxpdGVyYWw7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlTnVsbExpdGVyYWwoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTnVsbExpdGVyYWw7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlTnVtYmVyTGl0ZXJhbCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVOdW1iZXJMaXRlcmFsO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZU1lbWJlckV4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU1lbWJlckxvb2t1cEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlVGhpc0V4cHJlc3Npb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGhpc0V4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVOZXdFeHByZXNzaW9uO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZU9iamVjdEZyZWV6ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVPYmplY3RGcmVlemU7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlT2JqZWN0Q3JlYXRlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdENyZWF0ZTtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVPYmplY3RMaXRlcmFsRm9yRGVzY3JpcHRvcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVPYmplY3RMaXRlcmFsRm9yRGVzY3JpcHRvcjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVEZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEZWZpbmVQcm9wZXJ0eTtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVPYmplY3RMaXRlcmFsKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdExpdGVyYWw7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlUGFyZW5FeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVQb3N0Zml4RXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVTY3JpcHQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU2NyaXB0O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVByb3BlcnR5TmFtZUFzc2lnbm1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVMaXRlcmFsUHJvcGVydHlOYW1lKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWxQcm9wZXJ0eU5hbWU7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlUmVzdFBhcmFtZXRlcigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZXN0UGFyYW1ldGVyO1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVJldHVyblN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlU3dpdGNoU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVN3aXRjaFN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVUaHJvd1N0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUaHJvd1N0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVUcnlTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHJ5U3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVVbmFyeUV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlVXNlU3RyaWN0RGlyZWN0aXZlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZTtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdDtcbiAgICB9LFxuICAgIGdldCBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb247XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlVm9pZDAoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVm9pZDA7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlV2hpbGVTdGF0ZW1lbnQoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2hpbGVTdGF0ZW1lbnQ7XG4gICAgfSxcbiAgICBnZXQgY3JlYXRlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXaXRoU3RhdGVtZW50O1xuICAgIH0sXG4gICAgZ2V0IGNyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50O1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VUcmVlVmlzaXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZVRyZWVWaXNpdG9yLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVWaXNpdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VUcmVlVmlzaXRvcigpIHt9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFBhcnNlVHJlZVZpc2l0b3IsIHtcbiAgICAgIHZpc2l0QW55OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRyZWUgIT09IG51bGwgJiYgdHJlZS52aXNpdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52aXNpdEFueShsaXN0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdFN0YXRlTWFjaGluZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignU3RhdGUgbWFjaGluZXMgc2hvdWxkIG5vdCBsaXZlIG91dHNpZGUgb2YgdGhlIEdlbmVyYXRvclRyYW5zZm9ybWVyLicpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QW5ub3RhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5hcmdzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFub25CbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJndW1lbnRMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJheUNvbXByZWhlbnNpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5jb21wcmVoZW5zaW9uTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFycmF5TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmVsZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFycmF5UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmVsZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFycmF5VHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZWxlbWVudFR5cGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJyb3dGdW5jdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFzc2lnbm1lbnRFbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5hc3NpZ25tZW50KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEF3YWl0RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnJpZ2h0KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEJpbmRpbmdFbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0QmxvY2s6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5zdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0Q2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDYWxsU2lnbmF0dXJlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2FzZUNsYXVzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuc3RhdGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDYXRjaDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jYXRjaEJvZHkpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmVsZW1lbnRzKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb21tYUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5leHByZXNzaW9ucyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb21wcmVoZW5zaW9uRm9yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLml0ZXJhdG9yKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbXByZWhlbnNpb25JZjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb21wdXRlZFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnJpZ2h0KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbnN0cnVjdFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5yZXR1cm5UeXBlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbnN0cnVjdG9yVHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5yZXR1cm5UeXBlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0Q292ZXJGb3JtYWxzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q292ZXJJbml0aWFsaXplZE5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdERlYnVnZ2VyU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0RGVmYXVsdENsYXVzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb25kaXRpb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRFeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cG9ydERlZmF1bHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0RXhwb3J0U3BlY2lmaWVyU2V0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuc3BlY2lmaWVycyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnRTdGFyOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0RXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRGaW5hbGx5OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ibG9jayk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuY29sbGVjdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb2xsZWN0aW9uKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJvZHkpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9yT25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9ic2VydmFibGUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbmNyZW1lbnQpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JtYWxQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnBhcmFtZXRlcik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9ybWFsUGFyYW1ldGVyTGlzdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9yd2FyZERlZmF1bHRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRGdW5jdGlvbkJvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5zdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucmV0dXJuVHlwZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRHZW5lcmF0b3JDb21wcmVoZW5zaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuY29tcHJlaGVuc2lvbkxpc3QpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRHZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdElmU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb25kaXRpb24pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaWZDbGF1c2UpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZWxzZUNsYXVzZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJbXBvcnRlZEJpbmRpbmc6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJpbmRpbmcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0Q2xhdXNlUGFpcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZmlyc3QpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuc2Vjb25kKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbXBvcnRDbGF1c2UpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJbXBvcnRTcGVjaWZpZXJTZXQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5zcGVjaWZpZXJzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydFR5cGVDbGF1c2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNsYXVzZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJbmRleFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5kZXhUeXBlKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEludGVyZmFjZURlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vYmplY3RUeXBlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEpzeEF0dHJpYnV0ZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4RWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuY2hpbGRyZW4pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4RWxlbWVudE5hbWU6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRKc3hQbGFjZWhvbGRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRKc3hTcHJlYWRBdHRyaWJ1dGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4VGV4dDogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdExhYmVsbGVkU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdGF0ZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRMaXRlcmFsUHJvcGVydHlOYW1lOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0TWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUub3BlcmFuZCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZW1iZXJMb29rdXBFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TWV0aG9kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJvZHkpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZGVidWdOYW1lKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1ldGhvZFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jYWxsU2lnbmF0dXJlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1vZHVsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnNjcmlwdEl0ZW1MaXN0KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdE5hbWVTcGFjZUV4cG9ydDogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdE5hbWVTcGFjZUltcG9ydDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgdmlzaXROYW1lZEV4cG9ydDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwb3J0Q2xhdXNlKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICB9LFxuICAgICAgdmlzaXROZXdFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0T2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRPYmplY3RQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZmllbGRzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdFBhdHRlcm5GaWVsZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5lbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdFR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS50eXBlTWVtYmVycyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQYXJlbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UHJlZGVmaW5lZFR5cGU6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRTY3JpcHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5zY3JpcHRJdGVtTGlzdCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQcm9wZXJ0eU5hbWVBc3NpZ25tZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFByb3BlcnR5TmFtZVNob3J0aGFuZDogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UHJvcGVydHlTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UmVzdFBhcmFtZXRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaWRlbnRpZmllcik7XG4gICAgICB9LFxuICAgICAgdmlzaXRSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTcHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFNwcmVhZFBhdHRlcm5FbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U3VwZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0U3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5jYXNlQ2xhdXNlcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTeW50YXhFcnJvclRyZWU6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0VGVtcGxhdGVTdWJzdGl0dXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VGhpc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VHJ5U3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNhdGNoQmxvY2spO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZmluYWxseUJsb2NrKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFR5cGVBbGlhc0RlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlQXJndW1lbnRzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlTmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubW9kdWxlTmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHRlbmRzVHlwZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUGFyYW1ldGVyczogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLnBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VHlwZVJlZmVyZW5jZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZU5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VW5pb25UeXBlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUudHlwZXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubHZhbHVlKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZGVjbGFyYXRpb25zKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFZhcmlhYmxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0V2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICByZXR1cm4ge2dldCBQYXJzZVRyZWVWaXNpdG9yKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZVZpc2l0b3I7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZFZpc2l0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GaW5kVmlzaXRvci5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUGFyc2VUcmVlVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZFZpc2l0b3IuanNcIikpLlBhcnNlVHJlZVZpc2l0b3I7XG4gIHZhciBGaW5kVmlzaXRvciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRmluZFZpc2l0b3IoKSB7XG4gICAgICB2YXIga2VlcE9uR29pbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5kVmlzaXRvcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZm91bmRfID0gZmFsc2U7XG4gICAgICB0aGlzLnNob3VsZENvbnRpbnVlXyA9IHRydWU7XG4gICAgICB0aGlzLmtlZXBPbkdvaW5nXyA9IGtlZXBPbkdvaW5nO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRmluZFZpc2l0b3IsIHtcbiAgICAgIGdldCBmb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRfO1xuICAgICAgfSxcbiAgICAgIHNldCBmb3VuZCh2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdGhpcy5mb3VuZF8gPSB0cnVlO1xuICAgICAgICAgIGlmICghdGhpcy5rZWVwT25Hb2luZ18pXG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRpbnVlXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBbnk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW51ZV8gJiYgdHJlZSAmJiB0cmVlLnZpc2l0KHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLnNob3VsZENvbnRpbnVlXyAmJiBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52aXNpdEFueShsaXN0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVZpc2l0b3IpO1xuICByZXR1cm4ge2dldCBGaW5kVmlzaXRvcigpIHtcbiAgICAgIHJldHVybiBGaW5kVmlzaXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL1N5bnRheEVycm9yUmVwb3J0ZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL1N5bnRheEVycm9yUmVwb3J0ZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9FcnJvclJlcG9ydGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL1N5bnRheEVycm9yUmVwb3J0ZXIuanNcIikpLFxuICAgICAgRXJyb3JSZXBvcnRlciA9ICRfXzEuRXJyb3JSZXBvcnRlcixcbiAgICAgIGZvcm1hdCA9ICRfXzEuZm9ybWF0O1xuICB2YXIgU3ludGF4RXJyb3JSZXBvcnRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gU3ludGF4RXJyb3JSZXBvcnRlcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFN5bnRheEVycm9yUmVwb3J0ZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTeW50YXhFcnJvclJlcG9ydGVyLCB7cmVwb3J0TWVzc2FnZUludGVybmFsOiBmdW5jdGlvbihsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgcyA9IGZvcm1hdChsb2NhdGlvbiwgbWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEVycm9yUmVwb3J0ZXIpO1xuICByZXR1cm4ge2dldCBTeW50YXhFcnJvclJlcG9ydGVyKCkge1xuICAgICAgcmV0dXJuIFN5bnRheEVycm9yUmVwb3J0ZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0pzeElkZW50aWZpZXJUb2tlbi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9Kc3hJZGVudGlmaWVyVG9rZW4uanNcIjtcbiAgdmFyIFRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9Kc3hJZGVudGlmaWVyVG9rZW4uanNcIikpLlRva2VuO1xuICB2YXIgSlNYX0lERU5USUZJRVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9Kc3hJZGVudGlmaWVyVG9rZW4uanNcIikpLkpTWF9JREVOVElGSUVSO1xuICB2YXIgSnN4SWRlbnRpZmllclRva2VuID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBKc3hJZGVudGlmaWVyVG9rZW4obG9jYXRpb24sIHZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihKc3hJZGVudGlmaWVyVG9rZW4pLmNhbGwodGhpcywgSlNYX0lERU5USUZJRVIsIGxvY2F0aW9uKTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEpzeElkZW50aWZpZXJUb2tlbiwge3RvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShUb2tlbik7XG4gIHJldHVybiB7Z2V0IEpzeElkZW50aWZpZXJUb2tlbigpIHtcbiAgICAgIHJldHVybiBKc3hJZGVudGlmaWVyVG9rZW47XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0tleXdvcmRzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0tleXdvcmRzLmpzXCI7XG4gIHZhciBrZXl3b3JkcyA9IFsnYnJlYWsnLCAnY2FzZScsICdjYXRjaCcsICdjbGFzcycsICdjb25zdCcsICdjb250aW51ZScsICdkZWJ1Z2dlcicsICdkZWZhdWx0JywgJ2RlbGV0ZScsICdkbycsICdlbHNlJywgJ2V4cG9ydCcsICdmaW5hbGx5JywgJ2ZvcicsICdmdW5jdGlvbicsICdpZicsICdpbXBvcnQnLCAnaW4nLCAnaW5zdGFuY2VvZicsICdsZXQnLCAnbmV3JywgJ3JldHVybicsICdzdXBlcicsICdzd2l0Y2gnLCAndGhpcycsICd0aHJvdycsICd0cnknLCAndHlwZW9mJywgJ3ZhcicsICd2b2lkJywgJ3doaWxlJywgJ3dpdGgnLCAnZW51bScsICdleHRlbmRzJywgJ251bGwnLCAndHJ1ZScsICdmYWxzZSddO1xuICB2YXIgc3RyaWN0S2V5d29yZHMgPSBbJ2ltcGxlbWVudHMnLCAnaW50ZXJmYWNlJywgJ3BhY2thZ2UnLCAncHJpdmF0ZScsICdwcm90ZWN0ZWQnLCAncHVibGljJywgJ3N0YXRpYycsICd5aWVsZCddO1xuICB2YXIga2V5d29yZHNCeU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgTk9STUFMX0tFWVdPUkQgPSAxO1xuICB2YXIgU1RSSUNUX0tFWVdPUkQgPSAyO1xuICBrZXl3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAga2V5d29yZHNCeU5hbWVbdmFsdWVdID0gTk9STUFMX0tFWVdPUkQ7XG4gIH0pO1xuICBzdHJpY3RLZXl3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAga2V5d29yZHNCeU5hbWVbdmFsdWVdID0gU1RSSUNUX0tFWVdPUkQ7XG4gIH0pO1xuICBmdW5jdGlvbiBnZXRLZXl3b3JkVHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiBrZXl3b3Jkc0J5TmFtZVt2YWx1ZV07XG4gIH1cbiAgZnVuY3Rpb24gaXNTdHJpY3RLZXl3b3JkKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdldEtleXdvcmRUeXBlKHZhbHVlKSA9PT0gU1RSSUNUX0tFWVdPUkQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgTk9STUFMX0tFWVdPUkQoKSB7XG4gICAgICByZXR1cm4gTk9STUFMX0tFWVdPUkQ7XG4gICAgfSxcbiAgICBnZXQgU1RSSUNUX0tFWVdPUkQoKSB7XG4gICAgICByZXR1cm4gU1RSSUNUX0tFWVdPUkQ7XG4gICAgfSxcbiAgICBnZXQgZ2V0S2V5d29yZFR5cGUoKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5d29yZFR5cGU7XG4gICAgfSxcbiAgICBnZXQgaXNTdHJpY3RLZXl3b3JkKCkge1xuICAgICAgcmV0dXJuIGlzU3RyaWN0S2V5d29yZDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0tleXdvcmRUb2tlbi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9LZXl3b3JkVG9rZW4uanNcIjtcbiAgdmFyIFNUUklDVF9LRVlXT1JEID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vS2V5d29yZHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9LZXl3b3JkVG9rZW4uanNcIikpLlNUUklDVF9LRVlXT1JEO1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0tleXdvcmRUb2tlbi5qc1wiKSkuVG9rZW47XG4gIHZhciBLZXl3b3JkVG9rZW4gPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEtleXdvcmRUb2tlbih0eXBlLCBrZXl3b3JkVHlwZSwgbG9jYXRpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEtleXdvcmRUb2tlbikuY2FsbCh0aGlzLCB0eXBlLCBsb2NhdGlvbik7XG4gICAgICB0aGlzLmlzU3RyaWN0S2V5d29yZF8gPSBrZXl3b3JkVHlwZSA9PT0gU1RSSUNUX0tFWVdPUkQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShLZXl3b3JkVG9rZW4sIHtcbiAgICAgIGlzS2V5d29yZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGlzU3RyaWN0S2V5d29yZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RyaWN0S2V5d29yZF87XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShUb2tlbik7XG4gIHJldHVybiB7Z2V0IEtleXdvcmRUb2tlbigpIHtcbiAgICAgIHJldHVybiBLZXl3b3JkVG9rZW47XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L3VuaWNvZGUtdGFibGVzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L3VuaWNvZGUtdGFibGVzLmpzXCI7XG4gIHZhciBpZFN0YXJ0VGFibGUgPSBbMTcwLCAxNzAsIDE4MSwgMTgxLCAxODYsIDE4NiwgMTkyLCAyMTQsIDIxNiwgMjQ2LCAyNDgsIDQ0MiwgNDQzLCA0NDMsIDQ0NCwgNDQ3LCA0NDgsIDQ1MSwgNDUyLCA2NTksIDY2MCwgNjYwLCA2NjEsIDY4NywgNjg4LCA3MDUsIDcxMCwgNzIxLCA3MzYsIDc0MCwgNzQ4LCA3NDgsIDc1MCwgNzUwLCA4ODAsIDg4MywgODg0LCA4ODQsIDg4NiwgODg3LCA4OTAsIDg5MCwgODkxLCA4OTMsIDg5NSwgODk1LCA5MDIsIDkwMiwgOTA0LCA5MDYsIDkwOCwgOTA4LCA5MTAsIDkyOSwgOTMxLCAxMDEzLCAxMDE1LCAxMTUzLCAxMTYyLCAxMzI3LCAxMzI5LCAxMzY2LCAxMzY5LCAxMzY5LCAxMzc3LCAxNDE1LCAxNDg4LCAxNTE0LCAxNTIwLCAxNTIyLCAxNTY4LCAxNTk5LCAxNjAwLCAxNjAwLCAxNjAxLCAxNjEwLCAxNjQ2LCAxNjQ3LCAxNjQ5LCAxNzQ3LCAxNzQ5LCAxNzQ5LCAxNzY1LCAxNzY2LCAxNzc0LCAxNzc1LCAxNzg2LCAxNzg4LCAxNzkxLCAxNzkxLCAxODA4LCAxODA4LCAxODEwLCAxODM5LCAxODY5LCAxOTU3LCAxOTY5LCAxOTY5LCAxOTk0LCAyMDI2LCAyMDM2LCAyMDM3LCAyMDQyLCAyMDQyLCAyMDQ4LCAyMDY5LCAyMDc0LCAyMDc0LCAyMDg0LCAyMDg0LCAyMDg4LCAyMDg4LCAyMTEyLCAyMTM2LCAyMjA4LCAyMjI2LCAyMzA4LCAyMzYxLCAyMzY1LCAyMzY1LCAyMzg0LCAyMzg0LCAyMzkyLCAyNDAxLCAyNDE3LCAyNDE3LCAyNDE4LCAyNDMyLCAyNDM3LCAyNDQ0LCAyNDQ3LCAyNDQ4LCAyNDUxLCAyNDcyLCAyNDc0LCAyNDgwLCAyNDgyLCAyNDgyLCAyNDg2LCAyNDg5LCAyNDkzLCAyNDkzLCAyNTEwLCAyNTEwLCAyNTI0LCAyNTI1LCAyNTI3LCAyNTI5LCAyNTQ0LCAyNTQ1LCAyNTY1LCAyNTcwLCAyNTc1LCAyNTc2LCAyNTc5LCAyNjAwLCAyNjAyLCAyNjA4LCAyNjEwLCAyNjExLCAyNjEzLCAyNjE0LCAyNjE2LCAyNjE3LCAyNjQ5LCAyNjUyLCAyNjU0LCAyNjU0LCAyNjc0LCAyNjc2LCAyNjkzLCAyNzAxLCAyNzAzLCAyNzA1LCAyNzA3LCAyNzI4LCAyNzMwLCAyNzM2LCAyNzM4LCAyNzM5LCAyNzQxLCAyNzQ1LCAyNzQ5LCAyNzQ5LCAyNzY4LCAyNzY4LCAyNzg0LCAyNzg1LCAyODIxLCAyODI4LCAyODMxLCAyODMyLCAyODM1LCAyODU2LCAyODU4LCAyODY0LCAyODY2LCAyODY3LCAyODY5LCAyODczLCAyODc3LCAyODc3LCAyOTA4LCAyOTA5LCAyOTExLCAyOTEzLCAyOTI5LCAyOTI5LCAyOTQ3LCAyOTQ3LCAyOTQ5LCAyOTU0LCAyOTU4LCAyOTYwLCAyOTYyLCAyOTY1LCAyOTY5LCAyOTcwLCAyOTcyLCAyOTcyLCAyOTc0LCAyOTc1LCAyOTc5LCAyOTgwLCAyOTg0LCAyOTg2LCAyOTkwLCAzMDAxLCAzMDI0LCAzMDI0LCAzMDc3LCAzMDg0LCAzMDg2LCAzMDg4LCAzMDkwLCAzMTEyLCAzMTE0LCAzMTI5LCAzMTMzLCAzMTMzLCAzMTYwLCAzMTYxLCAzMTY4LCAzMTY5LCAzMjA1LCAzMjEyLCAzMjE0LCAzMjE2LCAzMjE4LCAzMjQwLCAzMjQyLCAzMjUxLCAzMjUzLCAzMjU3LCAzMjYxLCAzMjYxLCAzMjk0LCAzMjk0LCAzMjk2LCAzMjk3LCAzMzEzLCAzMzE0LCAzMzMzLCAzMzQwLCAzMzQyLCAzMzQ0LCAzMzQ2LCAzMzg2LCAzMzg5LCAzMzg5LCAzNDA2LCAzNDA2LCAzNDI0LCAzNDI1LCAzNDUwLCAzNDU1LCAzNDYxLCAzNDc4LCAzNDgyLCAzNTA1LCAzNTA3LCAzNTE1LCAzNTE3LCAzNTE3LCAzNTIwLCAzNTI2LCAzNTg1LCAzNjMyLCAzNjM0LCAzNjM1LCAzNjQ4LCAzNjUzLCAzNjU0LCAzNjU0LCAzNzEzLCAzNzE0LCAzNzE2LCAzNzE2LCAzNzE5LCAzNzIwLCAzNzIyLCAzNzIyLCAzNzI1LCAzNzI1LCAzNzMyLCAzNzM1LCAzNzM3LCAzNzQzLCAzNzQ1LCAzNzQ3LCAzNzQ5LCAzNzQ5LCAzNzUxLCAzNzUxLCAzNzU0LCAzNzU1LCAzNzU3LCAzNzYwLCAzNzYyLCAzNzYzLCAzNzczLCAzNzczLCAzNzc2LCAzNzgwLCAzNzgyLCAzNzgyLCAzODA0LCAzODA3LCAzODQwLCAzODQwLCAzOTA0LCAzOTExLCAzOTEzLCAzOTQ4LCAzOTc2LCAzOTgwLCA0MDk2LCA0MTM4LCA0MTU5LCA0MTU5LCA0MTc2LCA0MTgxLCA0MTg2LCA0MTg5LCA0MTkzLCA0MTkzLCA0MTk3LCA0MTk4LCA0MjA2LCA0MjA4LCA0MjEzLCA0MjI1LCA0MjM4LCA0MjM4LCA0MjU2LCA0MjkzLCA0Mjk1LCA0Mjk1LCA0MzAxLCA0MzAxLCA0MzA0LCA0MzQ2LCA0MzQ4LCA0MzQ4LCA0MzQ5LCA0NjgwLCA0NjgyLCA0Njg1LCA0Njg4LCA0Njk0LCA0Njk2LCA0Njk2LCA0Njk4LCA0NzAxLCA0NzA0LCA0NzQ0LCA0NzQ2LCA0NzQ5LCA0NzUyLCA0Nzg0LCA0Nzg2LCA0Nzg5LCA0NzkyLCA0Nzk4LCA0ODAwLCA0ODAwLCA0ODAyLCA0ODA1LCA0ODA4LCA0ODIyLCA0ODI0LCA0ODgwLCA0ODgyLCA0ODg1LCA0ODg4LCA0OTU0LCA0OTkyLCA1MDA3LCA1MDI0LCA1MTA4LCA1MTIxLCA1NzQwLCA1NzQzLCA1NzU5LCA1NzYxLCA1Nzg2LCA1NzkyLCA1ODY2LCA1ODcwLCA1ODcyLCA1ODczLCA1ODgwLCA1ODg4LCA1OTAwLCA1OTAyLCA1OTA1LCA1OTIwLCA1OTM3LCA1OTUyLCA1OTY5LCA1OTg0LCA1OTk2LCA1OTk4LCA2MDAwLCA2MDE2LCA2MDY3LCA2MTAzLCA2MTAzLCA2MTA4LCA2MTA4LCA2MTc2LCA2MjEwLCA2MjExLCA2MjExLCA2MjEyLCA2MjYzLCA2MjcyLCA2MzEyLCA2MzE0LCA2MzE0LCA2MzIwLCA2Mzg5LCA2NDAwLCA2NDMwLCA2NDgwLCA2NTA5LCA2NTEyLCA2NTE2LCA2NTI4LCA2NTcxLCA2NTkzLCA2NTk5LCA2NjU2LCA2Njc4LCA2Njg4LCA2NzQwLCA2ODIzLCA2ODIzLCA2OTE3LCA2OTYzLCA2OTgxLCA2OTg3LCA3MDQzLCA3MDcyLCA3MDg2LCA3MDg3LCA3MDk4LCA3MTQxLCA3MTY4LCA3MjAzLCA3MjQ1LCA3MjQ3LCA3MjU4LCA3Mjg3LCA3Mjg4LCA3MjkzLCA3NDAxLCA3NDA0LCA3NDA2LCA3NDA5LCA3NDEzLCA3NDE0LCA3NDI0LCA3NDY3LCA3NDY4LCA3NTMwLCA3NTMxLCA3NTQzLCA3NTQ0LCA3NTQ0LCA3NTQ1LCA3NTc4LCA3NTc5LCA3NjE1LCA3NjgwLCA3OTU3LCA3OTYwLCA3OTY1LCA3OTY4LCA4MDA1LCA4MDA4LCA4MDEzLCA4MDE2LCA4MDIzLCA4MDI1LCA4MDI1LCA4MDI3LCA4MDI3LCA4MDI5LCA4MDI5LCA4MDMxLCA4MDYxLCA4MDY0LCA4MTE2LCA4MTE4LCA4MTI0LCA4MTI2LCA4MTI2LCA4MTMwLCA4MTMyLCA4MTM0LCA4MTQwLCA4MTQ0LCA4MTQ3LCA4MTUwLCA4MTU1LCA4MTYwLCA4MTcyLCA4MTc4LCA4MTgwLCA4MTgyLCA4MTg4LCA4MzA1LCA4MzA1LCA4MzE5LCA4MzE5LCA4MzM2LCA4MzQ4LCA4NDUwLCA4NDUwLCA4NDU1LCA4NDU1LCA4NDU4LCA4NDY3LCA4NDY5LCA4NDY5LCA4NDcyLCA4NDcyLCA4NDczLCA4NDc3LCA4NDg0LCA4NDg0LCA4NDg2LCA4NDg2LCA4NDg4LCA4NDg4LCA4NDkwLCA4NDkzLCA4NDk0LCA4NDk0LCA4NDk1LCA4NTAwLCA4NTAxLCA4NTA0LCA4NTA1LCA4NTA1LCA4NTA4LCA4NTExLCA4NTE3LCA4NTIxLCA4NTI2LCA4NTI2LCA4NTQ0LCA4NTc4LCA4NTc5LCA4NTgwLCA4NTgxLCA4NTg0LCAxMTI2NCwgMTEzMTAsIDExMzEyLCAxMTM1OCwgMTEzNjAsIDExMzg3LCAxMTM4OCwgMTEzODksIDExMzkwLCAxMTQ5MiwgMTE0OTksIDExNTAyLCAxMTUwNiwgMTE1MDcsIDExNTIwLCAxMTU1NywgMTE1NTksIDExNTU5LCAxMTU2NSwgMTE1NjUsIDExNTY4LCAxMTYyMywgMTE2MzEsIDExNjMxLCAxMTY0OCwgMTE2NzAsIDExNjgwLCAxMTY4NiwgMTE2ODgsIDExNjk0LCAxMTY5NiwgMTE3MDIsIDExNzA0LCAxMTcxMCwgMTE3MTIsIDExNzE4LCAxMTcyMCwgMTE3MjYsIDExNzI4LCAxMTczNCwgMTE3MzYsIDExNzQyLCAxMjI5MywgMTIyOTMsIDEyMjk0LCAxMjI5NCwgMTIyOTUsIDEyMjk1LCAxMjMyMSwgMTIzMjksIDEyMzM3LCAxMjM0MSwgMTIzNDQsIDEyMzQ2LCAxMjM0NywgMTIzNDcsIDEyMzQ4LCAxMjM0OCwgMTIzNTMsIDEyNDM4LCAxMjQ0MywgMTI0NDQsIDEyNDQ1LCAxMjQ0NiwgMTI0NDcsIDEyNDQ3LCAxMjQ0OSwgMTI1MzgsIDEyNTQwLCAxMjU0MiwgMTI1NDMsIDEyNTQzLCAxMjU0OSwgMTI1ODksIDEyNTkzLCAxMjY4NiwgMTI3MDQsIDEyNzMwLCAxMjc4NCwgMTI3OTksIDEzMzEyLCAxOTg5MywgMTk5NjgsIDQwOTA4LCA0MDk2MCwgNDA5ODAsIDQwOTgxLCA0MDk4MSwgNDA5ODIsIDQyMTI0LCA0MjE5MiwgNDIyMzEsIDQyMjMyLCA0MjIzNywgNDIyNDAsIDQyNTA3LCA0MjUwOCwgNDI1MDgsIDQyNTEyLCA0MjUyNywgNDI1MzgsIDQyNTM5LCA0MjU2MCwgNDI2MDUsIDQyNjA2LCA0MjYwNiwgNDI2MjMsIDQyNjIzLCA0MjYyNCwgNDI2NTEsIDQyNjUyLCA0MjY1MywgNDI2NTYsIDQyNzI1LCA0MjcyNiwgNDI3MzUsIDQyNzc1LCA0Mjc4MywgNDI3ODYsIDQyODYzLCA0Mjg2NCwgNDI4NjQsIDQyODY1LCA0Mjg4NywgNDI4ODgsIDQyODg4LCA0Mjg5MSwgNDI4OTQsIDQyODk2LCA0MjkyNSwgNDI5MjgsIDQyOTI5LCA0Mjk5OSwgNDI5OTksIDQzMDAwLCA0MzAwMSwgNDMwMDIsIDQzMDAyLCA0MzAwMywgNDMwMDksIDQzMDExLCA0MzAxMywgNDMwMTUsIDQzMDE4LCA0MzAyMCwgNDMwNDIsIDQzMDcyLCA0MzEyMywgNDMxMzgsIDQzMTg3LCA0MzI1MCwgNDMyNTUsIDQzMjU5LCA0MzI1OSwgNDMyNzQsIDQzMzAxLCA0MzMxMiwgNDMzMzQsIDQzMzYwLCA0MzM4OCwgNDMzOTYsIDQzNDQyLCA0MzQ3MSwgNDM0NzEsIDQzNDg4LCA0MzQ5MiwgNDM0OTQsIDQzNDk0LCA0MzQ5NSwgNDM1MDMsIDQzNTE0LCA0MzUxOCwgNDM1MjAsIDQzNTYwLCA0MzU4NCwgNDM1ODYsIDQzNTg4LCA0MzU5NSwgNDM2MTYsIDQzNjMxLCA0MzYzMiwgNDM2MzIsIDQzNjMzLCA0MzYzOCwgNDM2NDIsIDQzNjQyLCA0MzY0NiwgNDM2OTUsIDQzNjk3LCA0MzY5NywgNDM3MDEsIDQzNzAyLCA0MzcwNSwgNDM3MDksIDQzNzEyLCA0MzcxMiwgNDM3MTQsIDQzNzE0LCA0MzczOSwgNDM3NDAsIDQzNzQxLCA0Mzc0MSwgNDM3NDQsIDQzNzU0LCA0Mzc2MiwgNDM3NjIsIDQzNzYzLCA0Mzc2NCwgNDM3NzcsIDQzNzgyLCA0Mzc4NSwgNDM3OTAsIDQzNzkzLCA0Mzc5OCwgNDM4MDgsIDQzODE0LCA0MzgxNiwgNDM4MjIsIDQzODI0LCA0Mzg2NiwgNDM4NjgsIDQzODcxLCA0Mzg3NiwgNDM4NzcsIDQzOTY4LCA0NDAwMiwgNDQwMzIsIDU1MjAzLCA1NTIxNiwgNTUyMzgsIDU1MjQzLCA1NTI5MSwgNjM3NDQsIDY0MTA5LCA2NDExMiwgNjQyMTcsIDY0MjU2LCA2NDI2MiwgNjQyNzUsIDY0Mjc5LCA2NDI4NSwgNjQyODUsIDY0Mjg3LCA2NDI5NiwgNjQyOTgsIDY0MzEwLCA2NDMxMiwgNjQzMTYsIDY0MzE4LCA2NDMxOCwgNjQzMjAsIDY0MzIxLCA2NDMyMywgNjQzMjQsIDY0MzI2LCA2NDQzMywgNjQ0NjcsIDY0ODI5LCA2NDg0OCwgNjQ5MTEsIDY0OTE0LCA2NDk2NywgNjUwMDgsIDY1MDE5LCA2NTEzNiwgNjUxNDAsIDY1MTQyLCA2NTI3NiwgNjUzMTMsIDY1MzM4LCA2NTM0NSwgNjUzNzAsIDY1MzgyLCA2NTM5MSwgNjUzOTIsIDY1MzkyLCA2NTM5MywgNjU0MzcsIDY1NDM4LCA2NTQzOSwgNjU0NDAsIDY1NDcwLCA2NTQ3NCwgNjU0NzksIDY1NDgyLCA2NTQ4NywgNjU0OTAsIDY1NDk1LCA2NTQ5OCwgNjU1MDAsIDY1NTM2LCA2NTU0NywgNjU1NDksIDY1NTc0LCA2NTU3NiwgNjU1OTQsIDY1NTk2LCA2NTU5NywgNjU1OTksIDY1NjEzLCA2NTYxNiwgNjU2MjksIDY1NjY0LCA2NTc4NiwgNjU4NTYsIDY1OTA4LCA2NjE3NiwgNjYyMDQsIDY2MjA4LCA2NjI1NiwgNjYzMDQsIDY2MzM1LCA2NjM1MiwgNjYzNjgsIDY2MzY5LCA2NjM2OSwgNjYzNzAsIDY2Mzc3LCA2NjM3OCwgNjYzNzgsIDY2Mzg0LCA2NjQyMSwgNjY0MzIsIDY2NDYxLCA2NjQ2NCwgNjY0OTksIDY2NTA0LCA2NjUxMSwgNjY1MTMsIDY2NTE3LCA2NjU2MCwgNjY2MzksIDY2NjQwLCA2NjcxNywgNjY4MTYsIDY2ODU1LCA2Njg2NCwgNjY5MTUsIDY3MDcyLCA2NzM4MiwgNjczOTIsIDY3NDEzLCA2NzQyNCwgNjc0MzEsIDY3NTg0LCA2NzU4OSwgNjc1OTIsIDY3NTkyLCA2NzU5NCwgNjc2MzcsIDY3NjM5LCA2NzY0MCwgNjc2NDQsIDY3NjQ0LCA2NzY0NywgNjc2NjksIDY3NjgwLCA2NzcwMiwgNjc3MTIsIDY3NzQyLCA2Nzg0MCwgNjc4NjEsIDY3ODcyLCA2Nzg5NywgNjc5NjgsIDY4MDIzLCA2ODAzMCwgNjgwMzEsIDY4MDk2LCA2ODA5NiwgNjgxMTIsIDY4MTE1LCA2ODExNywgNjgxMTksIDY4MTIxLCA2ODE0NywgNjgxOTIsIDY4MjIwLCA2ODIyNCwgNjgyNTIsIDY4Mjg4LCA2ODI5NSwgNjgyOTcsIDY4MzI0LCA2ODM1MiwgNjg0MDUsIDY4NDE2LCA2ODQzNywgNjg0NDgsIDY4NDY2LCA2ODQ4MCwgNjg0OTcsIDY4NjA4LCA2ODY4MCwgNjk2MzUsIDY5Njg3LCA2OTc2MywgNjk4MDcsIDY5ODQwLCA2OTg2NCwgNjk4OTEsIDY5OTI2LCA2OTk2OCwgNzAwMDIsIDcwMDA2LCA3MDAwNiwgNzAwMTksIDcwMDY2LCA3MDA4MSwgNzAwODQsIDcwMTA2LCA3MDEwNiwgNzAxNDQsIDcwMTYxLCA3MDE2MywgNzAxODcsIDcwMzIwLCA3MDM2NiwgNzA0MDUsIDcwNDEyLCA3MDQxNSwgNzA0MTYsIDcwNDE5LCA3MDQ0MCwgNzA0NDIsIDcwNDQ4LCA3MDQ1MCwgNzA0NTEsIDcwNDUzLCA3MDQ1NywgNzA0NjEsIDcwNDYxLCA3MDQ5MywgNzA0OTcsIDcwNzg0LCA3MDgzMSwgNzA4NTIsIDcwODUzLCA3MDg1NSwgNzA4NTUsIDcxMDQwLCA3MTA4NiwgNzExNjgsIDcxMjE1LCA3MTIzNiwgNzEyMzYsIDcxMjk2LCA3MTMzOCwgNzE4NDAsIDcxOTAzLCA3MTkzNSwgNzE5MzUsIDcyMzg0LCA3MjQ0MCwgNzM3MjgsIDc0NjQ4LCA3NDc1MiwgNzQ4NjIsIDc3ODI0LCA3ODg5NCwgOTIxNjAsIDkyNzI4LCA5MjczNiwgOTI3NjYsIDkyODgwLCA5MjkwOSwgOTI5MjgsIDkyOTc1LCA5Mjk5MiwgOTI5OTUsIDkzMDI3LCA5MzA0NywgOTMwNTMsIDkzMDcxLCA5Mzk1MiwgOTQwMjAsIDk0MDMyLCA5NDAzMiwgOTQwOTksIDk0MTExLCAxMTA1OTIsIDExMDU5MywgMTEzNjY0LCAxMTM3NzAsIDExMzc3NiwgMTEzNzg4LCAxMTM3OTIsIDExMzgwMCwgMTEzODA4LCAxMTM4MTcsIDExOTgwOCwgMTE5ODkyLCAxMTk4OTQsIDExOTk2NCwgMTE5OTY2LCAxMTk5NjcsIDExOTk3MCwgMTE5OTcwLCAxMTk5NzMsIDExOTk3NCwgMTE5OTc3LCAxMTk5ODAsIDExOTk4MiwgMTE5OTkzLCAxMTk5OTUsIDExOTk5NSwgMTE5OTk3LCAxMjAwMDMsIDEyMDAwNSwgMTIwMDY5LCAxMjAwNzEsIDEyMDA3NCwgMTIwMDc3LCAxMjAwODQsIDEyMDA4NiwgMTIwMDkyLCAxMjAwOTQsIDEyMDEyMSwgMTIwMTIzLCAxMjAxMjYsIDEyMDEyOCwgMTIwMTMyLCAxMjAxMzQsIDEyMDEzNCwgMTIwMTM4LCAxMjAxNDQsIDEyMDE0NiwgMTIwNDg1LCAxMjA0ODgsIDEyMDUxMiwgMTIwNTE0LCAxMjA1MzgsIDEyMDU0MCwgMTIwNTcwLCAxMjA1NzIsIDEyMDU5NiwgMTIwNTk4LCAxMjA2MjgsIDEyMDYzMCwgMTIwNjU0LCAxMjA2NTYsIDEyMDY4NiwgMTIwNjg4LCAxMjA3MTIsIDEyMDcxNCwgMTIwNzQ0LCAxMjA3NDYsIDEyMDc3MCwgMTIwNzcyLCAxMjA3NzksIDEyNDkyOCwgMTI1MTI0LCAxMjY0NjQsIDEyNjQ2NywgMTI2NDY5LCAxMjY0OTUsIDEyNjQ5NywgMTI2NDk4LCAxMjY1MDAsIDEyNjUwMCwgMTI2NTAzLCAxMjY1MDMsIDEyNjUwNSwgMTI2NTE0LCAxMjY1MTYsIDEyNjUxOSwgMTI2NTIxLCAxMjY1MjEsIDEyNjUyMywgMTI2NTIzLCAxMjY1MzAsIDEyNjUzMCwgMTI2NTM1LCAxMjY1MzUsIDEyNjUzNywgMTI2NTM3LCAxMjY1MzksIDEyNjUzOSwgMTI2NTQxLCAxMjY1NDMsIDEyNjU0NSwgMTI2NTQ2LCAxMjY1NDgsIDEyNjU0OCwgMTI2NTUxLCAxMjY1NTEsIDEyNjU1MywgMTI2NTUzLCAxMjY1NTUsIDEyNjU1NSwgMTI2NTU3LCAxMjY1NTcsIDEyNjU1OSwgMTI2NTU5LCAxMjY1NjEsIDEyNjU2MiwgMTI2NTY0LCAxMjY1NjQsIDEyNjU2NywgMTI2NTcwLCAxMjY1NzIsIDEyNjU3OCwgMTI2NTgwLCAxMjY1ODMsIDEyNjU4NSwgMTI2NTg4LCAxMjY1OTAsIDEyNjU5MCwgMTI2NTkyLCAxMjY2MDEsIDEyNjYwMywgMTI2NjE5LCAxMjY2MjUsIDEyNjYyNywgMTI2NjI5LCAxMjY2MzMsIDEyNjYzNSwgMTI2NjUxLCAxMzEwNzIsIDE3Mzc4MiwgMTczODI0LCAxNzc5NzIsIDE3Nzk4NCwgMTc4MjA1LCAxOTQ1NjAsIDE5NTEwMV07XG4gIHZhciBpZENvbnRpbnVlVGFibGUgPSBbMTgzLCAxODMsIDc2OCwgODc5LCA5MDMsIDkwMywgMTE1NSwgMTE1OSwgMTQyNSwgMTQ2OSwgMTQ3MSwgMTQ3MSwgMTQ3MywgMTQ3NCwgMTQ3NiwgMTQ3NywgMTQ3OSwgMTQ3OSwgMTU1MiwgMTU2MiwgMTYxMSwgMTYzMSwgMTYzMiwgMTY0MSwgMTY0OCwgMTY0OCwgMTc1MCwgMTc1NiwgMTc1OSwgMTc2NCwgMTc2NywgMTc2OCwgMTc3MCwgMTc3MywgMTc3NiwgMTc4NSwgMTgwOSwgMTgwOSwgMTg0MCwgMTg2NiwgMTk1OCwgMTk2OCwgMTk4NCwgMTk5MywgMjAyNywgMjAzNSwgMjA3MCwgMjA3MywgMjA3NSwgMjA4MywgMjA4NSwgMjA4NywgMjA4OSwgMjA5MywgMjEzNywgMjEzOSwgMjI3NiwgMjMwNiwgMjMwNywgMjMwNywgMjM2MiwgMjM2MiwgMjM2MywgMjM2MywgMjM2NCwgMjM2NCwgMjM2NiwgMjM2OCwgMjM2OSwgMjM3NiwgMjM3NywgMjM4MCwgMjM4MSwgMjM4MSwgMjM4MiwgMjM4MywgMjM4NSwgMjM5MSwgMjQwMiwgMjQwMywgMjQwNiwgMjQxNSwgMjQzMywgMjQzMywgMjQzNCwgMjQzNSwgMjQ5MiwgMjQ5MiwgMjQ5NCwgMjQ5NiwgMjQ5NywgMjUwMCwgMjUwMywgMjUwNCwgMjUwNywgMjUwOCwgMjUwOSwgMjUwOSwgMjUxOSwgMjUxOSwgMjUzMCwgMjUzMSwgMjUzNCwgMjU0MywgMjU2MSwgMjU2MiwgMjU2MywgMjU2MywgMjYyMCwgMjYyMCwgMjYyMiwgMjYyNCwgMjYyNSwgMjYyNiwgMjYzMSwgMjYzMiwgMjYzNSwgMjYzNywgMjY0MSwgMjY0MSwgMjY2MiwgMjY3MSwgMjY3MiwgMjY3MywgMjY3NywgMjY3NywgMjY4OSwgMjY5MCwgMjY5MSwgMjY5MSwgMjc0OCwgMjc0OCwgMjc1MCwgMjc1MiwgMjc1MywgMjc1NywgMjc1OSwgMjc2MCwgMjc2MSwgMjc2MSwgMjc2MywgMjc2NCwgMjc2NSwgMjc2NSwgMjc4NiwgMjc4NywgMjc5MCwgMjc5OSwgMjgxNywgMjgxNywgMjgxOCwgMjgxOSwgMjg3NiwgMjg3NiwgMjg3OCwgMjg3OCwgMjg3OSwgMjg3OSwgMjg4MCwgMjg4MCwgMjg4MSwgMjg4NCwgMjg4NywgMjg4OCwgMjg5MSwgMjg5MiwgMjg5MywgMjg5MywgMjkwMiwgMjkwMiwgMjkwMywgMjkwMywgMjkxNCwgMjkxNSwgMjkxOCwgMjkyNywgMjk0NiwgMjk0NiwgMzAwNiwgMzAwNywgMzAwOCwgMzAwOCwgMzAwOSwgMzAxMCwgMzAxNCwgMzAxNiwgMzAxOCwgMzAyMCwgMzAyMSwgMzAyMSwgMzAzMSwgMzAzMSwgMzA0NiwgMzA1NSwgMzA3MiwgMzA3MiwgMzA3MywgMzA3NSwgMzEzNCwgMzEzNiwgMzEzNywgMzE0MCwgMzE0MiwgMzE0NCwgMzE0NiwgMzE0OSwgMzE1NywgMzE1OCwgMzE3MCwgMzE3MSwgMzE3NCwgMzE4MywgMzIwMSwgMzIwMSwgMzIwMiwgMzIwMywgMzI2MCwgMzI2MCwgMzI2MiwgMzI2MiwgMzI2MywgMzI2MywgMzI2NCwgMzI2OCwgMzI3MCwgMzI3MCwgMzI3MSwgMzI3MiwgMzI3NCwgMzI3NSwgMzI3NiwgMzI3NywgMzI4NSwgMzI4NiwgMzI5OCwgMzI5OSwgMzMwMiwgMzMxMSwgMzMyOSwgMzMyOSwgMzMzMCwgMzMzMSwgMzM5MCwgMzM5MiwgMzM5MywgMzM5NiwgMzM5OCwgMzQwMCwgMzQwMiwgMzQwNCwgMzQwNSwgMzQwNSwgMzQxNSwgMzQxNSwgMzQyNiwgMzQyNywgMzQzMCwgMzQzOSwgMzQ1OCwgMzQ1OSwgMzUzMCwgMzUzMCwgMzUzNSwgMzUzNywgMzUzOCwgMzU0MCwgMzU0MiwgMzU0MiwgMzU0NCwgMzU1MSwgMzU1OCwgMzU2NywgMzU3MCwgMzU3MSwgMzYzMywgMzYzMywgMzYzNiwgMzY0MiwgMzY1NSwgMzY2MiwgMzY2NCwgMzY3MywgMzc2MSwgMzc2MSwgMzc2NCwgMzc2OSwgMzc3MSwgMzc3MiwgMzc4NCwgMzc4OSwgMzc5MiwgMzgwMSwgMzg2NCwgMzg2NSwgMzg3MiwgMzg4MSwgMzg5MywgMzg5MywgMzg5NSwgMzg5NSwgMzg5NywgMzg5NywgMzkwMiwgMzkwMywgMzk1MywgMzk2NiwgMzk2NywgMzk2NywgMzk2OCwgMzk3MiwgMzk3NCwgMzk3NSwgMzk4MSwgMzk5MSwgMzk5MywgNDAyOCwgNDAzOCwgNDAzOCwgNDEzOSwgNDE0MCwgNDE0MSwgNDE0NCwgNDE0NSwgNDE0NSwgNDE0NiwgNDE1MSwgNDE1MiwgNDE1MiwgNDE1MywgNDE1NCwgNDE1NSwgNDE1NiwgNDE1NywgNDE1OCwgNDE2MCwgNDE2OSwgNDE4MiwgNDE4MywgNDE4NCwgNDE4NSwgNDE5MCwgNDE5MiwgNDE5NCwgNDE5NiwgNDE5OSwgNDIwNSwgNDIwOSwgNDIxMiwgNDIyNiwgNDIyNiwgNDIyNywgNDIyOCwgNDIyOSwgNDIzMCwgNDIzMSwgNDIzNiwgNDIzNywgNDIzNywgNDIzOSwgNDIzOSwgNDI0MCwgNDI0OSwgNDI1MCwgNDI1MiwgNDI1MywgNDI1MywgNDk1NywgNDk1OSwgNDk2OSwgNDk3NywgNTkwNiwgNTkwOCwgNTkzOCwgNTk0MCwgNTk3MCwgNTk3MSwgNjAwMiwgNjAwMywgNjA2OCwgNjA2OSwgNjA3MCwgNjA3MCwgNjA3MSwgNjA3NywgNjA3OCwgNjA4NSwgNjA4NiwgNjA4NiwgNjA4NywgNjA4OCwgNjA4OSwgNjA5OSwgNjEwOSwgNjEwOSwgNjExMiwgNjEyMSwgNjE1NSwgNjE1NywgNjE2MCwgNjE2OSwgNjMxMywgNjMxMywgNjQzMiwgNjQzNCwgNjQzNSwgNjQzOCwgNjQzOSwgNjQ0MCwgNjQ0MSwgNjQ0MywgNjQ0OCwgNjQ0OSwgNjQ1MCwgNjQ1MCwgNjQ1MSwgNjQ1NiwgNjQ1NywgNjQ1OSwgNjQ3MCwgNjQ3OSwgNjU3NiwgNjU5MiwgNjYwMCwgNjYwMSwgNjYwOCwgNjYxNywgNjYxOCwgNjYxOCwgNjY3OSwgNjY4MCwgNjY4MSwgNjY4MiwgNjY4MywgNjY4MywgNjc0MSwgNjc0MSwgNjc0MiwgNjc0MiwgNjc0MywgNjc0MywgNjc0NCwgNjc1MCwgNjc1MiwgNjc1MiwgNjc1MywgNjc1MywgNjc1NCwgNjc1NCwgNjc1NSwgNjc1NiwgNjc1NywgNjc2NCwgNjc2NSwgNjc3MCwgNjc3MSwgNjc4MCwgNjc4MywgNjc4MywgNjc4NCwgNjc5MywgNjgwMCwgNjgwOSwgNjgzMiwgNjg0NSwgNjkxMiwgNjkxNSwgNjkxNiwgNjkxNiwgNjk2NCwgNjk2NCwgNjk2NSwgNjk2NSwgNjk2NiwgNjk3MCwgNjk3MSwgNjk3MSwgNjk3MiwgNjk3MiwgNjk3MywgNjk3NywgNjk3OCwgNjk3OCwgNjk3OSwgNjk4MCwgNjk5MiwgNzAwMSwgNzAxOSwgNzAyNywgNzA0MCwgNzA0MSwgNzA0MiwgNzA0MiwgNzA3MywgNzA3MywgNzA3NCwgNzA3NywgNzA3OCwgNzA3OSwgNzA4MCwgNzA4MSwgNzA4MiwgNzA4MiwgNzA4MywgNzA4NSwgNzA4OCwgNzA5NywgNzE0MiwgNzE0MiwgNzE0MywgNzE0MywgNzE0NCwgNzE0NSwgNzE0NiwgNzE0OCwgNzE0OSwgNzE0OSwgNzE1MCwgNzE1MCwgNzE1MSwgNzE1MywgNzE1NCwgNzE1NSwgNzIwNCwgNzIxMSwgNzIxMiwgNzIxOSwgNzIyMCwgNzIyMSwgNzIyMiwgNzIyMywgNzIzMiwgNzI0MSwgNzI0OCwgNzI1NywgNzM3NiwgNzM3OCwgNzM4MCwgNzM5MiwgNzM5MywgNzM5MywgNzM5NCwgNzQwMCwgNzQwNSwgNzQwNSwgNzQxMCwgNzQxMSwgNzQxMiwgNzQxMiwgNzQxNiwgNzQxNywgNzYxNiwgNzY2OSwgNzY3NiwgNzY3OSwgODI1NSwgODI1NiwgODI3NiwgODI3NiwgODQwMCwgODQxMiwgODQxNywgODQxNywgODQyMSwgODQzMiwgMTE1MDMsIDExNTA1LCAxMTY0NywgMTE2NDcsIDExNzQ0LCAxMTc3NSwgMTIzMzAsIDEyMzMzLCAxMjMzNCwgMTIzMzUsIDEyNDQxLCAxMjQ0MiwgNDI1MjgsIDQyNTM3LCA0MjYwNywgNDI2MDcsIDQyNjEyLCA0MjYyMSwgNDI2NTUsIDQyNjU1LCA0MjczNiwgNDI3MzcsIDQzMDEwLCA0MzAxMCwgNDMwMTQsIDQzMDE0LCA0MzAxOSwgNDMwMTksIDQzMDQzLCA0MzA0NCwgNDMwNDUsIDQzMDQ2LCA0MzA0NywgNDMwNDcsIDQzMTM2LCA0MzEzNywgNDMxODgsIDQzMjAzLCA0MzIwNCwgNDMyMDQsIDQzMjE2LCA0MzIyNSwgNDMyMzIsIDQzMjQ5LCA0MzI2NCwgNDMyNzMsIDQzMzAyLCA0MzMwOSwgNDMzMzUsIDQzMzQ1LCA0MzM0NiwgNDMzNDcsIDQzMzkyLCA0MzM5NCwgNDMzOTUsIDQzMzk1LCA0MzQ0MywgNDM0NDMsIDQzNDQ0LCA0MzQ0NSwgNDM0NDYsIDQzNDQ5LCA0MzQ1MCwgNDM0NTEsIDQzNDUyLCA0MzQ1MiwgNDM0NTMsIDQzNDU2LCA0MzQ3MiwgNDM0ODEsIDQzNDkzLCA0MzQ5MywgNDM1MDQsIDQzNTEzLCA0MzU2MSwgNDM1NjYsIDQzNTY3LCA0MzU2OCwgNDM1NjksIDQzNTcwLCA0MzU3MSwgNDM1NzIsIDQzNTczLCA0MzU3NCwgNDM1ODcsIDQzNTg3LCA0MzU5NiwgNDM1OTYsIDQzNTk3LCA0MzU5NywgNDM2MDAsIDQzNjA5LCA0MzY0MywgNDM2NDMsIDQzNjQ0LCA0MzY0NCwgNDM2NDUsIDQzNjQ1LCA0MzY5NiwgNDM2OTYsIDQzNjk4LCA0MzcwMCwgNDM3MDMsIDQzNzA0LCA0MzcxMCwgNDM3MTEsIDQzNzEzLCA0MzcxMywgNDM3NTUsIDQzNzU1LCA0Mzc1NiwgNDM3NTcsIDQzNzU4LCA0Mzc1OSwgNDM3NjUsIDQzNzY1LCA0Mzc2NiwgNDM3NjYsIDQ0MDAzLCA0NDAwNCwgNDQwMDUsIDQ0MDA1LCA0NDAwNiwgNDQwMDcsIDQ0MDA4LCA0NDAwOCwgNDQwMDksIDQ0MDEwLCA0NDAxMiwgNDQwMTIsIDQ0MDEzLCA0NDAxMywgNDQwMTYsIDQ0MDI1LCA2NDI4NiwgNjQyODYsIDY1MDI0LCA2NTAzOSwgNjUwNTYsIDY1MDY5LCA2NTA3NSwgNjUwNzYsIDY1MTAxLCA2NTEwMywgNjUyOTYsIDY1MzA1LCA2NTM0MywgNjUzNDMsIDY2MDQ1LCA2NjA0NSwgNjYyNzIsIDY2MjcyLCA2NjQyMiwgNjY0MjYsIDY2NzIwLCA2NjcyOSwgNjgwOTcsIDY4MDk5LCA2ODEwMSwgNjgxMDIsIDY4MTA4LCA2ODExMSwgNjgxNTIsIDY4MTU0LCA2ODE1OSwgNjgxNTksIDY4MzI1LCA2ODMyNiwgNjk2MzIsIDY5NjMyLCA2OTYzMywgNjk2MzMsIDY5NjM0LCA2OTYzNCwgNjk2ODgsIDY5NzAyLCA2OTczNCwgNjk3NDMsIDY5NzU5LCA2OTc2MSwgNjk3NjIsIDY5NzYyLCA2OTgwOCwgNjk4MTAsIDY5ODExLCA2OTgxNCwgNjk4MTUsIDY5ODE2LCA2OTgxNywgNjk4MTgsIDY5ODcyLCA2OTg4MSwgNjk4ODgsIDY5ODkwLCA2OTkyNywgNjk5MzEsIDY5OTMyLCA2OTkzMiwgNjk5MzMsIDY5OTQwLCA2OTk0MiwgNjk5NTEsIDcwMDAzLCA3MDAwMywgNzAwMTYsIDcwMDE3LCA3MDAxOCwgNzAwMTgsIDcwMDY3LCA3MDA2OSwgNzAwNzAsIDcwMDc4LCA3MDA3OSwgNzAwODAsIDcwMDk2LCA3MDEwNSwgNzAxODgsIDcwMTkwLCA3MDE5MSwgNzAxOTMsIDcwMTk0LCA3MDE5NSwgNzAxOTYsIDcwMTk2LCA3MDE5NywgNzAxOTcsIDcwMTk4LCA3MDE5OSwgNzAzNjcsIDcwMzY3LCA3MDM2OCwgNzAzNzAsIDcwMzcxLCA3MDM3OCwgNzAzODQsIDcwMzkzLCA3MDQwMSwgNzA0MDEsIDcwNDAyLCA3MDQwMywgNzA0NjAsIDcwNDYwLCA3MDQ2MiwgNzA0NjMsIDcwNDY0LCA3MDQ2NCwgNzA0NjUsIDcwNDY4LCA3MDQ3MSwgNzA0NzIsIDcwNDc1LCA3MDQ3NywgNzA0ODcsIDcwNDg3LCA3MDQ5OCwgNzA0OTksIDcwNTAyLCA3MDUwOCwgNzA1MTIsIDcwNTE2LCA3MDgzMiwgNzA4MzQsIDcwODM1LCA3MDg0MCwgNzA4NDEsIDcwODQxLCA3MDg0MiwgNzA4NDIsIDcwODQzLCA3MDg0NiwgNzA4NDcsIDcwODQ4LCA3MDg0OSwgNzA4NDksIDcwODUwLCA3MDg1MSwgNzA4NjQsIDcwODczLCA3MTA4NywgNzEwODksIDcxMDkwLCA3MTA5MywgNzEwOTYsIDcxMDk5LCA3MTEwMCwgNzExMDEsIDcxMTAyLCA3MTEwMiwgNzExMDMsIDcxMTA0LCA3MTIxNiwgNzEyMTgsIDcxMjE5LCA3MTIyNiwgNzEyMjcsIDcxMjI4LCA3MTIyOSwgNzEyMjksIDcxMjMwLCA3MTIzMCwgNzEyMzEsIDcxMjMyLCA3MTI0OCwgNzEyNTcsIDcxMzM5LCA3MTMzOSwgNzEzNDAsIDcxMzQwLCA3MTM0MSwgNzEzNDEsIDcxMzQyLCA3MTM0MywgNzEzNDQsIDcxMzQ5LCA3MTM1MCwgNzEzNTAsIDcxMzUxLCA3MTM1MSwgNzEzNjAsIDcxMzY5LCA3MTkwNCwgNzE5MTMsIDkyNzY4LCA5Mjc3NywgOTI5MTIsIDkyOTE2LCA5Mjk3NiwgOTI5ODIsIDkzMDA4LCA5MzAxNywgOTQwMzMsIDk0MDc4LCA5NDA5NSwgOTQwOTgsIDExMzgyMSwgMTEzODIyLCAxMTkxNDEsIDExOTE0MiwgMTE5MTQzLCAxMTkxNDUsIDExOTE0OSwgMTE5MTU0LCAxMTkxNjMsIDExOTE3MCwgMTE5MTczLCAxMTkxNzksIDExOTIxMCwgMTE5MjEzLCAxMTkzNjIsIDExOTM2NCwgMTIwNzgyLCAxMjA4MzEsIDEyNTEzNiwgMTI1MTQyLCA5MTc3NjAsIDkxNzk5OV07XG4gIHJldHVybiB7XG4gICAgZ2V0IGlkU3RhcnRUYWJsZSgpIHtcbiAgICAgIHJldHVybiBpZFN0YXJ0VGFibGU7XG4gICAgfSxcbiAgICBnZXQgaWRDb250aW51ZVRhYmxlKCkge1xuICAgICAgcmV0dXJuIGlkQ29udGludWVUYWJsZTtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NjYW5uZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU2Nhbm5lci5qc1wiO1xuICB2YXIgSWRlbnRpZmllclRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSWRlbnRpZmllclRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU2Nhbm5lci5qc1wiKSkuSWRlbnRpZmllclRva2VuO1xuICB2YXIgSnN4SWRlbnRpZmllclRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSnN4SWRlbnRpZmllclRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU2Nhbm5lci5qc1wiKSkuSnN4SWRlbnRpZmllclRva2VuO1xuICB2YXIgS2V5d29yZFRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vS2V5d29yZFRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU2Nhbm5lci5qc1wiKSkuS2V5d29yZFRva2VuO1xuICB2YXIgTGl0ZXJhbFRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTGl0ZXJhbFRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU2Nhbm5lci5qc1wiKSkuTGl0ZXJhbFRva2VuO1xuICB2YXIgU291cmNlUmFuZ2UgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9Tb3VyY2VSYW5nZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NjYW5uZXIuanNcIikpLlNvdXJjZVJhbmdlO1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NjYW5uZXIuanNcIikpLlRva2VuO1xuICB2YXIgZ2V0S2V5d29yZFR5cGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9LZXl3b3Jkcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NjYW5uZXIuanNcIikpLmdldEtleXdvcmRUeXBlO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi91bmljb2RlLXRhYmxlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NjYW5uZXIuanNcIikpLFxuICAgICAgaWRDb250aW51ZVRhYmxlID0gJF9fMTAuaWRDb250aW51ZVRhYmxlLFxuICAgICAgaWRTdGFydFRhYmxlID0gJF9fMTAuaWRTdGFydFRhYmxlO1xuICB2YXIgJF9fMTEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9TY2FubmVyLmpzXCIpKSxcbiAgICAgIEFNUEVSU0FORCA9ICRfXzExLkFNUEVSU0FORCxcbiAgICAgIEFNUEVSU0FORF9FUVVBTCA9ICRfXzExLkFNUEVSU0FORF9FUVVBTCxcbiAgICAgIEFORCA9ICRfXzExLkFORCxcbiAgICAgIEFSUk9XID0gJF9fMTEuQVJST1csXG4gICAgICBBVCA9ICRfXzExLkFULFxuICAgICAgQkFORyA9ICRfXzExLkJBTkcsXG4gICAgICBCQVIgPSAkX18xMS5CQVIsXG4gICAgICBCQVJfRVFVQUwgPSAkX18xMS5CQVJfRVFVQUwsXG4gICAgICBDQVJFVCA9ICRfXzExLkNBUkVULFxuICAgICAgQ0FSRVRfRVFVQUwgPSAkX18xMS5DQVJFVF9FUVVBTCxcbiAgICAgIENMT1NFX0FOR0xFID0gJF9fMTEuQ0xPU0VfQU5HTEUsXG4gICAgICBDTE9TRV9DVVJMWSA9ICRfXzExLkNMT1NFX0NVUkxZLFxuICAgICAgQ0xPU0VfUEFSRU4gPSAkX18xMS5DTE9TRV9QQVJFTixcbiAgICAgIENMT1NFX1NRVUFSRSA9ICRfXzExLkNMT1NFX1NRVUFSRSxcbiAgICAgIENPTE9OID0gJF9fMTEuQ09MT04sXG4gICAgICBDT01NQSA9ICRfXzExLkNPTU1BLFxuICAgICAgRE9UX0RPVF9ET1QgPSAkX18xMS5ET1RfRE9UX0RPVCxcbiAgICAgIEVORF9PRl9GSUxFID0gJF9fMTEuRU5EX09GX0ZJTEUsXG4gICAgICBFUVVBTCA9ICRfXzExLkVRVUFMLFxuICAgICAgRVFVQUxfRVFVQUwgPSAkX18xMS5FUVVBTF9FUVVBTCxcbiAgICAgIEVRVUFMX0VRVUFMX0VRVUFMID0gJF9fMTEuRVFVQUxfRVFVQUxfRVFVQUwsXG4gICAgICBFUlJPUiA9ICRfXzExLkVSUk9SLFxuICAgICAgR1JFQVRFUl9FUVVBTCA9ICRfXzExLkdSRUFURVJfRVFVQUwsXG4gICAgICBMRUZUX1NISUZUID0gJF9fMTEuTEVGVF9TSElGVCxcbiAgICAgIExFRlRfU0hJRlRfRVFVQUwgPSAkX18xMS5MRUZUX1NISUZUX0VRVUFMLFxuICAgICAgTEVTU19FUVVBTCA9ICRfXzExLkxFU1NfRVFVQUwsXG4gICAgICBNSU5VUyA9ICRfXzExLk1JTlVTLFxuICAgICAgTUlOVVNfRVFVQUwgPSAkX18xMS5NSU5VU19FUVVBTCxcbiAgICAgIE1JTlVTX01JTlVTID0gJF9fMTEuTUlOVVNfTUlOVVMsXG4gICAgICBOT19TVUJTVElUVVRJT05fVEVNUExBVEUgPSAkX18xMS5OT19TVUJTVElUVVRJT05fVEVNUExBVEUsXG4gICAgICBOT1RfRVFVQUwgPSAkX18xMS5OT1RfRVFVQUwsXG4gICAgICBOT1RfRVFVQUxfRVFVQUwgPSAkX18xMS5OT1RfRVFVQUxfRVFVQUwsXG4gICAgICBOVU1CRVIgPSAkX18xMS5OVU1CRVIsXG4gICAgICBPUEVOX0FOR0xFID0gJF9fMTEuT1BFTl9BTkdMRSxcbiAgICAgIE9QRU5fQ1VSTFkgPSAkX18xMS5PUEVOX0NVUkxZLFxuICAgICAgT1BFTl9QQVJFTiA9ICRfXzExLk9QRU5fUEFSRU4sXG4gICAgICBPUEVOX1NRVUFSRSA9ICRfXzExLk9QRU5fU1FVQVJFLFxuICAgICAgT1IgPSAkX18xMS5PUixcbiAgICAgIFBFUkNFTlQgPSAkX18xMS5QRVJDRU5ULFxuICAgICAgUEVSQ0VOVF9FUVVBTCA9ICRfXzExLlBFUkNFTlRfRVFVQUwsXG4gICAgICBQRVJJT0QgPSAkX18xMS5QRVJJT0QsXG4gICAgICBQTFVTID0gJF9fMTEuUExVUyxcbiAgICAgIFBMVVNfRVFVQUwgPSAkX18xMS5QTFVTX0VRVUFMLFxuICAgICAgUExVU19QTFVTID0gJF9fMTEuUExVU19QTFVTLFxuICAgICAgUVVFU1RJT04gPSAkX18xMS5RVUVTVElPTixcbiAgICAgIFJFR1VMQVJfRVhQUkVTU0lPTiA9ICRfXzExLlJFR1VMQVJfRVhQUkVTU0lPTixcbiAgICAgIFJJR0hUX1NISUZUID0gJF9fMTEuUklHSFRfU0hJRlQsXG4gICAgICBSSUdIVF9TSElGVF9FUVVBTCA9ICRfXzExLlJJR0hUX1NISUZUX0VRVUFMLFxuICAgICAgU0VNSV9DT0xPTiA9ICRfXzExLlNFTUlfQ09MT04sXG4gICAgICBTTEFTSCA9ICRfXzExLlNMQVNILFxuICAgICAgU0xBU0hfRVFVQUwgPSAkX18xMS5TTEFTSF9FUVVBTCxcbiAgICAgIFNUQVIgPSAkX18xMS5TVEFSLFxuICAgICAgU1RBUl9FUVVBTCA9ICRfXzExLlNUQVJfRVFVQUwsXG4gICAgICBTVEFSX1NUQVIgPSAkX18xMS5TVEFSX1NUQVIsXG4gICAgICBTVEFSX1NUQVJfRVFVQUwgPSAkX18xMS5TVEFSX1NUQVJfRVFVQUwsXG4gICAgICBTVFJJTkcgPSAkX18xMS5TVFJJTkcsXG4gICAgICBURU1QTEFURV9IRUFEID0gJF9fMTEuVEVNUExBVEVfSEVBRCxcbiAgICAgIFRFTVBMQVRFX01JRERMRSA9ICRfXzExLlRFTVBMQVRFX01JRERMRSxcbiAgICAgIFRFTVBMQVRFX1RBSUwgPSAkX18xMS5URU1QTEFURV9UQUlMLFxuICAgICAgVElMREUgPSAkX18xMS5USUxERSxcbiAgICAgIFVOU0lHTkVEX1JJR0hUX1NISUZUID0gJF9fMTEuVU5TSUdORURfUklHSFRfU0hJRlQsXG4gICAgICBVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTCA9ICRfXzExLlVOU0lHTkVEX1JJR0hUX1NISUZUX0VRVUFMO1xuICB2YXIgaXNXaGl0ZXNwYWNlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGlzV2hpdGVzcGFjZUFycmF5W2ldID0gaSA+PSA5ICYmIGkgPD0gMTMgfHwgaSA9PT0gMHgyMDtcbiAgfVxuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIGlmIChjb2RlIDwgMTI4KVxuICAgICAgcmV0dXJuIGlzV2hpdGVzcGFjZUFycmF5W2NvZGVdO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAweEEwOlxuICAgICAgY2FzZSAweEZFRkY6XG4gICAgICBjYXNlIDB4MjAyODpcbiAgICAgIGNhc2UgMHgyMDI5OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAxMDpcbiAgICAgIGNhc2UgMTM6XG4gICAgICBjYXNlIDB4MjAyODpcbiAgICAgIGNhc2UgMHgyMDI5OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xuICB9XG4gIHZhciBpc0hleERpZ2l0QXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSRfXzAgPSAwOyBpJF9fMCA8IDEyODsgaSRfXzArKykge1xuICAgIGlzSGV4RGlnaXRBcnJheVtpJF9fMF0gPSBpJF9fMCA+PSA0OCAmJiBpJF9fMCA8PSA1NyB8fCBpJF9fMCA+PSA2NSAmJiBpJF9fMCA8PSA3MCB8fCBpJF9fMCA+PSA5NyAmJiBpJF9fMCA8PSAxMDI7XG4gIH1cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPCAxMjggJiYgaXNIZXhEaWdpdEFycmF5W2NvZGVdO1xuICB9XG4gIGZ1bmN0aW9uIGlzQmluYXJ5RGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSA0OCB8fCBjb2RlID09PSA0OTtcbiAgfVxuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTU7XG4gIH1cbiAgdmFyIGlzSWRlbnRpZmllclN0YXJ0QXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSRfXzEgPSAwOyBpJF9fMSA8IDEyODsgaSRfXzErKykge1xuICAgIGlzSWRlbnRpZmllclN0YXJ0QXJyYXlbaSRfXzFdID0gaSRfXzEgPT09IDM2IHx8IGkkX18xID49IDY1ICYmIGkkX18xIDw9IDkwIHx8IGkkX18xID09PSA5NSB8fCBpJF9fMSA+PSA5NyAmJiBpJF9fMSA8PSAxMjI7XG4gIH1cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlIDwgMTI4ID8gaXNJZGVudGlmaWVyU3RhcnRBcnJheVtjb2RlXSA6IGluVGFibGUoaWRTdGFydFRhYmxlLCBjb2RlKTtcbiAgfVxuICB2YXIgaXNJZGVudGlmaWVyUGFydEFycmF5ID0gW107XG4gIGZvciAodmFyIGkkX18yID0gMDsgaSRfXzIgPCAxMjg7IGkkX18yKyspIHtcbiAgICBpc0lkZW50aWZpZXJQYXJ0QXJyYXlbaSRfXzJdID0gaXNJZGVudGlmaWVyU3RhcnQoaSRfXzIpIHx8IGlzRGVjaW1hbERpZ2l0KGkkX18yKTtcbiAgfVxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA8IDEyOCA/IGlzSWRlbnRpZmllclBhcnRBcnJheVtjb2RlXSA6IGluVGFibGUoaWRTdGFydFRhYmxlLCBjb2RlKSB8fCBpblRhYmxlKGlkQ29udGludWVUYWJsZSwgY29kZSkgfHwgY29kZSA9PT0gODIwNCB8fCBjb2RlID09PSA4MjA1O1xuICB9XG4gIGZ1bmN0aW9uIGluVGFibGUodGFibGUsIGNvZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlLmxlbmd0aDsgKSB7XG4gICAgICBpZiAoY29kZSA8IHRhYmxlW2krK10pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChjb2RlIDw9IHRhYmxlW2krK10pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWd1bGFyRXhwcmVzc2lvbkNoYXIoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgY2FzZSA5MTpcbiAgICAgIGNhc2UgOTI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIWlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZWd1bGFyRXhwcmVzc2lvbkZpcnN0Q2hhcihjb2RlKSB7XG4gICAgcmV0dXJuIGlzUmVndWxhckV4cHJlc3Npb25DaGFyKGNvZGUpICYmIGNvZGUgIT09IDQyO1xuICB9XG4gIHZhciBpbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgdG9rZW4sXG4gICAgICBsYXN0VG9rZW4sXG4gICAgICBsb29rYWhlYWRUb2tlbixcbiAgICAgIGN1cnJlbnRDaGFyQ29kZSxcbiAgICAgIGxpbmVOdW1iZXJUYWJsZSxcbiAgICAgIGVycm9yUmVwb3J0ZXIsXG4gICAgICBjdXJyZW50UGFyc2VyLFxuICAgICAgb3B0aW9ucztcbiAgZnVuY3Rpb24gaW5pdChyZXBvcnRlciwgZmlsZSwgcGFyc2VyLCB0cmFjZXVyT3B0aW9ucykge1xuICAgIGVycm9yUmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgICBsaW5lTnVtYmVyVGFibGUgPSBmaWxlLmxpbmVOdW1iZXJUYWJsZTtcbiAgICBpbnB1dCA9IGZpbGUuY29udGVudHM7XG4gICAgbGVuZ3RoID0gZmlsZS5jb250ZW50cy5sZW5ndGg7XG4gICAgc2V0SW5kZXgoMCk7XG4gICAgY3VycmVudFBhcnNlciA9IHBhcnNlcjtcbiAgICBvcHRpb25zID0gdHJhY2V1ck9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TGFzdFRva2VuKCkge1xuICAgIHJldHVybiBsYXN0VG9rZW47XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbFRva2VuKCkge1xuICAgIGxhc3RUb2tlbiA9IG5leHRSZWd1bGFyRXhwcmVzc2lvbkxpdGVyYWxUb2tlbjIoKTtcbiAgICB0b2tlbiA9IHNjYW5Ub2tlbigpO1xuICAgIHJldHVybiBsYXN0VG9rZW47XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFRlbXBsYXRlTGl0ZXJhbFRva2VuKCkge1xuICAgIHZhciB0ID0gbmV4dFRlbXBsYXRlTGl0ZXJhbFRva2VuMigpO1xuICAgIHRva2VuID0gc2NhblRva2VuKCk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gc2V0SW5kZXgoaSkge1xuICAgIGluZGV4ID0gaTtcbiAgICBsYXN0VG9rZW4gPSBudWxsO1xuICAgIHRva2VuID0gbnVsbDtcbiAgICBsb29rYWhlYWRUb2tlbiA9IG51bGw7XG4gICAgdXBkYXRlQ3VycmVudENoYXJDb2RlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIGdldFBvc2l0aW9uQnlPZmZzZXQoZ2V0T2Zmc2V0KCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uQnlPZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIGxpbmVOdW1iZXJUYWJsZS5nZXRTb3VyY2VQb3NpdGlvbihvZmZzZXQpO1xuICB9XG4gIGZ1bmN0aW9uIG5leHRDbG9zZUFuZ2xlKCkge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSBHUkVBVEVSX0VRVUFMOlxuICAgICAgY2FzZSBSSUdIVF9TSElGVDpcbiAgICAgIGNhc2UgUklHSFRfU0hJRlRfRVFVQUw6XG4gICAgICBjYXNlIFVOU0lHTkVEX1JJR0hUX1NISUZUOlxuICAgICAgY2FzZSBVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTDpcbiAgICAgICAgc2V0SW5kZXgoaW5kZXggLSB0b2tlbi50eXBlLmxlbmd0aCArIDEpO1xuICAgICAgICBsYXN0VG9rZW4gPSBjcmVhdGVUb2tlbihDTE9TRV9BTkdMRSwgaW5kZXgpO1xuICAgICAgICB0b2tlbiA9IHNjYW5Ub2tlbigpO1xuICAgICAgICByZXR1cm4gbGFzdFRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFRva2VuKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VG9rZW5SYW5nZShzdGFydE9mZnNldCkge1xuICAgIHJldHVybiBsaW5lTnVtYmVyVGFibGUuZ2V0U291cmNlUmFuZ2Uoc3RhcnRPZmZzZXQsIGluZGV4KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRva2VuID8gdG9rZW4ubG9jYXRpb24uc3RhcnQub2Zmc2V0IDogaW5kZXg7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbFRva2VuMigpIHtcbiAgICB2YXIgYmVnaW5JbmRleCA9IGluZGV4IC0gdG9rZW4udG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFNMQVNIX0VRVUFMKSB7XG4gICAgICBza2lwUmVndWxhckV4cHJlc3Npb25Cb2R5Q29udGludWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNraXBSZWd1bGFyRXhwcmVzc2lvbkJvZHkoYmVnaW5JbmRleCk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q2hhckNvZGUgIT09IDQ3KSB7XG4gICAgICByZXBvcnRFcnJvcignRXhwZWN0ZWQgXFwnL1xcJyBpbiByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCcsIGJlZ2luSW5kZXgpO1xuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsVG9rZW4oUkVHVUxBUl9FWFBSRVNTSU9OLCBnZXRUb2tlblN0cmluZyhiZWdpbkluZGV4KSwgZ2V0VG9rZW5SYW5nZShiZWdpbkluZGV4KSk7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydChjdXJyZW50Q2hhckNvZGUpKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKFJFR1VMQVJfRVhQUkVTU0lPTiwgZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCksIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBSZWd1bGFyRXhwcmVzc2lvbkJvZHkoYmVnaW5JbmRleCkge1xuICAgIGlmICghaXNSZWd1bGFyRXhwcmVzc2lvbkZpcnN0Q2hhcihjdXJyZW50Q2hhckNvZGUpKSB7XG4gICAgICByZXBvcnRFcnJvcignRXhwZWN0ZWQgcmVndWxhciBleHByZXNzaW9uIGZpcnN0IGNoYXInLCBiZWdpbkluZGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2tpcFJlZ3VsYXJFeHByZXNzaW9uQm9keUNvbnRpbnVhdGlvbigpO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBSZWd1bGFyRXhwcmVzc2lvbkJvZHlDb250aW51YXRpb24oKSB7XG4gICAgd2hpbGUgKCFpc0F0RW5kKCkgJiYgaXNSZWd1bGFyRXhwcmVzc2lvbkNoYXIoY3VycmVudENoYXJDb2RlKSkge1xuICAgICAgaWYgKCFza2lwUmVndWxhckV4cHJlc3Npb25DaGFyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBza2lwUmVndWxhckV4cHJlc3Npb25DaGFyKCkge1xuICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG4gICAgICBjYXNlIDkyOlxuICAgICAgICByZXR1cm4gc2tpcFJlZ3VsYXJFeHByZXNzaW9uQmFja3NsYXNoU2VxdWVuY2UoKTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIHJldHVybiBza2lwUmVndWxhckV4cHJlc3Npb25DbGFzcygpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFJlZ3VsYXJFeHByZXNzaW9uQmFja3NsYXNoU2VxdWVuY2UoKSB7XG4gICAgdmFyIGJlZ2luSW5kZXggPSBpbmRleDtcbiAgICBuZXh0KCk7XG4gICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY3VycmVudENoYXJDb2RlKSB8fCBpc0F0RW5kKCkpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdOZXcgbGluZSBub3QgYWxsb3dlZCBpbiByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCcsIGJlZ2luSW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBSZWd1bGFyRXhwcmVzc2lvbkNsYXNzKCkge1xuICAgIHZhciBiZWdpbkluZGV4ID0gaW5kZXg7XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlICghaXNBdEVuZCgpICYmIHBlZWtSZWd1bGFyRXhwcmVzc2lvbkNsYXNzQ2hhcigpKSB7XG4gICAgICBpZiAoIXNraXBSZWd1bGFyRXhwcmVzc2lvbkNsYXNzQ2hhcigpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRDaGFyQ29kZSAhPT0gOTMpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdcXCddXFwnIGV4cGVjdGVkJywgYmVnaW5JbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcGVla1JlZ3VsYXJFeHByZXNzaW9uQ2xhc3NDaGFyKCkge1xuICAgIHJldHVybiBjdXJyZW50Q2hhckNvZGUgIT09IDkzICYmICFpc0xpbmVUZXJtaW5hdG9yKGN1cnJlbnRDaGFyQ29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFJlZ3VsYXJFeHByZXNzaW9uQ2xhc3NDaGFyKCkge1xuICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDkyKSB7XG4gICAgICByZXR1cm4gc2tpcFJlZ3VsYXJFeHByZXNzaW9uQmFja3NsYXNoU2VxdWVuY2UoKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBUZW1wbGF0ZUNoYXJhY3RlcigpIHtcbiAgICB3aGlsZSAoIWlzQXRFbmQoKSkge1xuICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgc2tpcFN0cmluZ0xpdGVyYWxFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IDEyMylcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2NhblRlbXBsYXRlU3RhcnQoYmVnaW5JbmRleCkge1xuICAgIGlmIChpc0F0RW5kKCkpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdVbnRlcm1pbmF0ZWQgdGVtcGxhdGUgbGl0ZXJhbCcsIGJlZ2luSW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiBsYXN0VG9rZW4gPSBjcmVhdGVUb2tlbihFTkRfT0ZfRklMRSwgYmVnaW5JbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW5TaGFyZWQoTk9fU1VCU1RJVFVUSU9OX1RFTVBMQVRFLCBURU1QTEFURV9IRUFEKTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW4yKCkge1xuICAgIGlmIChpc0F0RW5kKCkpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdFeHBlY3RlZCBcXCd9XFwnIGFmdGVyIGV4cHJlc3Npb24gaW4gdGVtcGxhdGUgbGl0ZXJhbCcsIGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gY3JlYXRlVG9rZW4oRU5EX09GX0ZJTEUsIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKHRva2VuLnR5cGUgIT09IENMT1NFX0NVUkxZKSB7XG4gICAgICByZXBvcnRFcnJvcignRXhwZWN0ZWQgXFwnfVxcJyBhZnRlciBleHByZXNzaW9uIGluIHRlbXBsYXRlIGxpdGVyYWwnLCBpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEVSUk9SLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW5TaGFyZWQoVEVNUExBVEVfVEFJTCwgVEVNUExBVEVfTUlERExFKTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW5TaGFyZWQoZW5kVHlwZSwgbWlkZGxlVHlwZSkge1xuICAgIHZhciBiZWdpbkluZGV4ID0gaW5kZXg7XG4gICAgc2tpcFRlbXBsYXRlQ2hhcmFjdGVyKCk7XG4gICAgaWYgKGlzQXRFbmQoKSkge1xuICAgICAgcmVwb3J0RXJyb3IoJ1VudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsJyk7XG4gICAgICByZXR1cm4gY3JlYXRlVG9rZW4oRVJST1IsIGJlZ2luSW5kZXgpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBnZXRUb2tlblN0cmluZyhiZWdpbkluZGV4KTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuICAgICAgY2FzZSA5NjpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gbGFzdFRva2VuID0gbmV3IExpdGVyYWxUb2tlbihlbmRUeXBlLCB2YWx1ZSwgZ2V0VG9rZW5SYW5nZShiZWdpbkluZGV4IC0gMSkpO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBsYXN0VG9rZW4gPSBuZXcgTGl0ZXJhbFRva2VuKG1pZGRsZVR5cGUsIHZhbHVlLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXggLSAxKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBlZWtKc3hUb2tlbigpIHtcbiAgICByZXR1cm4gdG9rZW4gfHwgKHRva2VuID0gc2NhbkpzeFRva2VuKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5leHRKc3hUb2tlbigpIHtcbiAgICBsYXN0VG9rZW4gPSBwZWVrSnN4VG9rZW4oKTtcbiAgICB0b2tlbiA9IG51bGw7XG4gICAgcmV0dXJuIGxhc3RUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBzY2FuSnN4VG9rZW4oKSB7XG4gICAgc2tpcENvbW1lbnRzKCk7XG4gICAgdmFyIGJlZ2luSW5kZXggPSBpbmRleDtcbiAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHJldHVybiBzY2FuSnN4U3RyaW5nTGl0ZXJhbChiZWdpbkluZGV4LCBjdXJyZW50Q2hhckNvZGUpO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ0xPU0VfQU5HTEUsIGJlZ2luSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgIHJldHVybiBzY2FuVG9rZW4oKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KGN1cnJlbnRDaGFyQ29kZSkgfHwgY3VycmVudENoYXJDb2RlID09PSA0NSkge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBpbnB1dC5zbGljZShiZWdpbkluZGV4LCBpbmRleCk7XG4gICAgcmV0dXJuIG5ldyBKc3hJZGVudGlmaWVyVG9rZW4oZ2V0VG9rZW5SYW5nZShiZWdpbkluZGV4KSwgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHNjYW5Kc3hTdHJpbmdMaXRlcmFsKGJlZ2luSW5kZXgsIHRlcm1pbmF0b3IpIHtcbiAgICBuZXh0KCk7XG4gICAgd2hpbGUgKCFpc0F0RW5kKCkgJiYgY3VycmVudENoYXJDb2RlICE9PSB0ZXJtaW5hdG9yKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q2hhckNvZGUgIT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdVbnRlcm1pbmF0ZWQgU3RyaW5nIExpdGVyYWwnLCBiZWdpbkluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdGVyYWxUb2tlbihTVFJJTkcsIGdldFRva2VuU3RyaW5nKGJlZ2luSW5kZXgpLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXgpKTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0SnN4VGV4dFRva2VuKCkge1xuICAgIGxhc3RUb2tlbiA9IHRva2VuIHx8IHNjYW5Kc3hUZXh0VG9rZW4oKTtcbiAgICB0b2tlbiA9IG51bGw7XG4gICAgcmV0dXJuIGxhc3RUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBza2lwSnN4VGV4dCgpIHtcbiAgICB3aGlsZSAoIWlzQXRFbmQoKSAmJiBwZWVrSnN4VGV4dCgpKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzSnN4VGV4dENoYXIoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA2MDpcbiAgICAgIGNhc2UgMTIzOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBKc3hUZXh0KCkge1xuICAgIHdoaWxlICghaXNBdEVuZCgpICYmIGlzSnN4VGV4dENoYXIoY3VycmVudENoYXJDb2RlKSkge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzY2FuSnN4VGV4dFRva2VuKCkge1xuICAgIHZhciBiZWdpbkluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGlzQXRFbmQoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEVORF9PRl9GSUxFLCBiZWdpbkluZGV4KTtcbiAgICB9XG4gICAgc2tpcEpzeFRleHQoKTtcbiAgICBpZiAoYmVnaW5JbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG4gICAgICAgIGNhc2UgNjA6XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUEVOX0FOR0xFLCBiZWdpbkluZGV4KTtcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUEVOX0NVUkxZLCBiZWdpbkluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsVG9rZW4oU1RSSU5HLCBnZXRUb2tlblN0cmluZyhiZWdpbkluZGV4KSwgZ2V0VG9rZW5SYW5nZShiZWdpbkluZGV4KSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgIHZhciB0ID0gcGVla1Rva2VuKCk7XG4gICAgdG9rZW4gPSBsb29rYWhlYWRUb2tlbiB8fCBzY2FuVG9rZW4oKTtcbiAgICBsb29rYWhlYWRUb2tlbiA9IG51bGw7XG4gICAgbGFzdFRva2VuID0gdDtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBmdW5jdGlvbiBwZWVrVG9rZW5Ob0xpbmVUZXJtaW5hdG9yKCkge1xuICAgIHZhciB0ID0gcGVla1Rva2VuKCk7XG4gICAgdmFyIHN0YXJ0ID0gbGFzdFRva2VuLmxvY2F0aW9uLmVuZC5vZmZzZXQ7XG4gICAgdmFyIGVuZCA9IHQubG9jYXRpb24uc3RhcnQub2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihpbnB1dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gcGVlayhleHBlY3RlZFR5cGUpIHtcbiAgICByZXR1cm4gcGVla1Rva2VuKCkudHlwZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICB9XG4gIGZ1bmN0aW9uIHBlZWtMb29rYWhlYWQoZXhwZWN0ZWRUeXBlKSB7XG4gICAgcmV0dXJuIHBlZWtUb2tlbkxvb2thaGVhZCgpLnR5cGUgPT09IGV4cGVjdGVkVHlwZTtcbiAgfVxuICBmdW5jdGlvbiBwZWVrVG9rZW4oKSB7XG4gICAgcmV0dXJuIHRva2VuIHx8ICh0b2tlbiA9IHNjYW5Ub2tlbigpKTtcbiAgfVxuICBmdW5jdGlvbiBwZWVrVHlwZSgpIHtcbiAgICByZXR1cm4gcGVla1Rva2VuKCkudHlwZTtcbiAgfVxuICBmdW5jdGlvbiBwZWVrTG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHBlZWtUb2tlbigpLmxvY2F0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIHBlZWtUb2tlbkxvb2thaGVhZCgpIHtcbiAgICBpZiAoIXRva2VuKVxuICAgICAgdG9rZW4gPSBzY2FuVG9rZW4oKTtcbiAgICBpZiAoIWxvb2thaGVhZFRva2VuKVxuICAgICAgbG9va2FoZWFkVG9rZW4gPSBzY2FuVG9rZW4oKTtcbiAgICByZXR1cm4gbG9va2FoZWFkVG9rZW47XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKCFpc0F0RW5kKCkgJiYgcGVla1doaXRlc3BhY2UoKSkge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwZWVrV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gaXNXaGl0ZXNwYWNlKGN1cnJlbnRDaGFyQ29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gc2tpcENvbW1lbnRzKCkge1xuICAgIHdoaWxlIChza2lwQ29tbWVudCgpKSB7fVxuICB9XG4gIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgIHNraXBXaGl0ZXNwYWNlKCk7XG4gICAgdmFyIGNvZGUgPSBjdXJyZW50Q2hhckNvZGU7XG4gICAgaWYgKGNvZGUgPT09IDQ3KSB7XG4gICAgICBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgc2tpcFNpbmdsZUxpbmVDb21tZW50KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbW1lbnRDYWxsYmFjayhzdGFydCwgaW5kZXgpIHtcbiAgICBpZiAob3B0aW9ucy5jb21tZW50Q2FsbGJhY2spXG4gICAgICBjdXJyZW50UGFyc2VyLmhhbmRsZUNvbW1lbnQobGluZU51bWJlclRhYmxlLmdldFNvdXJjZVJhbmdlKHN0YXJ0LCBpbmRleCkpO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBTaW5nbGVMaW5lQ29tbWVudCgpIHtcbiAgICB2YXIgc3RhcnQgPSBpbmRleDtcbiAgICBpbmRleCArPSAyO1xuICAgIHdoaWxlICghaXNBdEVuZCgpICYmICFpc0xpbmVUZXJtaW5hdG9yKGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpKSB7fVxuICAgIHVwZGF0ZUN1cnJlbnRDaGFyQ29kZSgpO1xuICAgIGNvbW1lbnRDYWxsYmFjayhzdGFydCwgaW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBNdWx0aUxpbmVDb21tZW50KCkge1xuICAgIHZhciBzdGFydCA9IGluZGV4O1xuICAgIHZhciBpID0gaW5wdXQuaW5kZXhPZignKi8nLCBpbmRleCArIDIpO1xuICAgIGlmIChpICE9PSAtMSlcbiAgICAgIGluZGV4ID0gaSArIDI7XG4gICAgZWxzZVxuICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgdXBkYXRlQ3VycmVudENoYXJDb2RlKCk7XG4gICAgY29tbWVudENhbGxiYWNrKHN0YXJ0LCBpbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NhblRva2VuKCkge1xuICAgIHNraXBDb21tZW50cygpO1xuICAgIHZhciBiZWdpbkluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGlzQXRFbmQoKSlcbiAgICAgIHJldHVybiBjcmVhdGVUb2tlbihFTkRfT0ZfRklMRSwgYmVnaW5JbmRleCk7XG4gICAgdmFyIGNvZGUgPSBjdXJyZW50Q2hhckNvZGU7XG4gICAgbmV4dCgpO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUEVOX0NVUkxZLCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgMTI1OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ0xPU0VfQ1VSTFksIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA0MDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKE9QRU5fUEFSRU4sIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA0MTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKENMT1NFX1BBUkVOLCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUEVOX1NRVUFSRSwgYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDkzOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ0xPU0VfU1FVQVJFLCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgNDY6XG4gICAgICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG4gICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDQ2KSB7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oRE9UX0RPVF9ET1QsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjdXJyZW50Q2hhckNvZGUpKVxuICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWJlclBvc3RQZXJpb2QoYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFBFUklPRCwgYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDU5OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oU0VNSV9DT0xPTiwgYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDQ0OlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ09NTUEsIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSAxMjY6XG4gICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihUSUxERSwgYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDYzOlxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oUVVFU1RJT04sIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA1ODpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKENPTE9OLCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG4gICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDYxKSB7XG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKExFRlRfU0hJRlRfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKExFRlRfU0hJRlQsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oTEVTU19FUVVBTCwgYmVnaW5JbmRleCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUEVOX0FOR0xFLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFJJR0hUX1NISUZUX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTCwgYmVnaW5JbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihVTlNJR05FRF9SSUdIVF9TSElGVCwgYmVnaW5JbmRleCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFJJR0hUX1NISUZULCBiZWdpbkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEdSRUFURVJfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ0xPU0VfQU5HTEUsIGJlZ2luSW5kZXgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDYxOlxuICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA2MSkge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA2MSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEVRVUFMX0VRVUFMX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEVRVUFMX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA2MiAmJiBvcHRpb25zLmFycm93RnVuY3Rpb25zKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihBUlJPVywgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEVRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDYxKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDYxKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oTk9UX0VRVUFMX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKE5PVF9FUVVBTCwgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEJBTkcsIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA0MjpcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNjEpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFNUQVJfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2hhckNvZGUgPT09IDQyICYmIG9wdGlvbnMuZXhwb25lbnRpYXRpb24pIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNjEpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihTVEFSX1NUQVJfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oU1RBUl9TVEFSLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oU1RBUiwgYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDM3OlxuICAgICAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA2MSkge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oUEVSQ0VOVF9FUVVBTCwgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFBFUkNFTlQsIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA5NDpcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNjEpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKENBUkVUX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQ0FSRVQsIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyQ29kZSA9PT0gNjEpIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFNMQVNIX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oU0xBU0gsIGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA0MzpcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFBMVVNfUExVUywgYmVnaW5JbmRleCk7XG4gICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihQTFVTX0VRVUFMLCBiZWdpbkluZGV4KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKFBMVVMsIGJlZ2luSW5kZXgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDQ1OlxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oTUlOVVNfTUlOVVMsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oTUlOVVNfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oTUlOVVMsIGJlZ2luSW5kZXgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDM4OlxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQU5ELCBiZWdpbkluZGV4KTtcbiAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEFNUEVSU0FORF9FUVVBTCwgYmVnaW5JbmRleCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihBTVBFUlNBTkQsIGJlZ2luSW5kZXgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEyNDpcbiAgICAgICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgICAgICBjYXNlIDEyNDpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihPUiwgYmVnaW5JbmRleCk7XG4gICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVUb2tlbihCQVJfRVFVQUwsIGJlZ2luSW5kZXgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oQkFSLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA5NjpcbiAgICAgICAgcmV0dXJuIHNjYW5UZW1wbGF0ZVN0YXJ0KGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRva2VuKEFULCBiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgNDg6XG4gICAgICAgIHJldHVybiBzY2FuUG9zdFplcm8oYmVnaW5JbmRleCk7XG4gICAgICBjYXNlIDQ5OlxuICAgICAgY2FzZSA1MDpcbiAgICAgIGNhc2UgNTE6XG4gICAgICBjYXNlIDUyOlxuICAgICAgY2FzZSA1MzpcbiAgICAgIGNhc2UgNTQ6XG4gICAgICBjYXNlIDU1OlxuICAgICAgY2FzZSA1NjpcbiAgICAgIGNhc2UgNTc6XG4gICAgICAgIHJldHVybiBzY2FuUG9zdERpZ2l0KGJlZ2luSW5kZXgpO1xuICAgICAgY2FzZSAzNDpcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbChiZWdpbkluZGV4LCBjb2RlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllck9yS2V5d29yZChiZWdpbkluZGV4LCBjb2RlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2Nhbk51bWJlclBvc3RQZXJpb2QoYmVnaW5JbmRleCkge1xuICAgIHNraXBEZWNpbWFsRGlnaXRzKCk7XG4gICAgcmV0dXJuIHNjYW5FeHBvbmVudE9mTnVtZXJpY0xpdGVyYWwoYmVnaW5JbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NhblBvc3REaWdpdChiZWdpbkluZGV4KSB7XG4gICAgc2tpcERlY2ltYWxEaWdpdHMoKTtcbiAgICByZXR1cm4gc2NhbkZyYWN0aW9uYWxOdW1lcmljTGl0ZXJhbChiZWdpbkluZGV4KTtcbiAgfVxuICBmdW5jdGlvbiBzY2FuUG9zdFplcm8oYmVnaW5JbmRleCkge1xuICAgIHN3aXRjaCAoY3VycmVudENoYXJDb2RlKSB7XG4gICAgICBjYXNlIDQ2OlxuICAgICAgICByZXR1cm4gc2NhbkZyYWN0aW9uYWxOdW1lcmljTGl0ZXJhbChiZWdpbkluZGV4KTtcbiAgICAgIGNhc2UgODg6XG4gICAgICBjYXNlIDEyMDpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY3VycmVudENoYXJDb2RlKSkge1xuICAgICAgICAgIHJlcG9ydEVycm9yKCdIZXggSW50ZWdlciBMaXRlcmFsIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgZGlnaXQnLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBza2lwSGV4RGlnaXRzKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKE5VTUJFUiwgZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCksIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICAgICAgY2FzZSA2NjpcbiAgICAgIGNhc2UgOTg6XG4gICAgICAgIGlmICghb3B0aW9ucy5udW1lcmljTGl0ZXJhbHMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgaWYgKCFpc0JpbmFyeURpZ2l0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgICAgICByZXBvcnRFcnJvcignQmluYXJ5IEludGVnZXIgTGl0ZXJhbCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGRpZ2l0JywgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEJpbmFyeURpZ2l0cygpO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxUb2tlbihOVU1CRVIsIGdldFRva2VuU3RyaW5nKGJlZ2luSW5kZXgpLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXgpKTtcbiAgICAgIGNhc2UgNzk6XG4gICAgICBjYXNlIDExMTpcbiAgICAgICAgaWYgKCFvcHRpb25zLm51bWVyaWNMaXRlcmFscylcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChjdXJyZW50Q2hhckNvZGUpKSB7XG4gICAgICAgICAgcmVwb3J0RXJyb3IoJ09jdGFsIEludGVnZXIgTGl0ZXJhbCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGRpZ2l0JywgYmVnaW5JbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcE9jdGFsRGlnaXRzKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKE5VTUJFUiwgZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCksIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICAgICAgY2FzZSA0ODpcbiAgICAgIGNhc2UgNDk6XG4gICAgICBjYXNlIDUwOlxuICAgICAgY2FzZSA1MTpcbiAgICAgIGNhc2UgNTI6XG4gICAgICBjYXNlIDUzOlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgNTU6XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSA1NzpcbiAgICAgICAgcmV0dXJuIHNjYW5Qb3N0RGlnaXQoYmVnaW5JbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKE5VTUJFUiwgZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCksIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKHR5cGUsIGJlZ2luSW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHR5cGUsIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgdmFyIGJlZ2luSW5kZXggPSBpbmRleDtcbiAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAxMTcpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIGlmIChza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCArIDEpLCAxNik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcG9ydEVycm9yKCdJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIGluIGlkZW50aWZpZXInLCBiZWdpbkluZGV4IC0gMSk7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXJPcktleXdvcmQoYmVnaW5JbmRleCwgY29kZSkge1xuICAgIHZhciBlc2NhcGVkQ2hhckNvZGVzO1xuICAgIGlmIChjb2RlID09PSA5Mikge1xuICAgICAgY29kZSA9IHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgIGVzY2FwZWRDaGFyQ29kZXMgPSBbY29kZV07XG4gICAgfVxuICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgIHJlcG9ydEVycm9yKChcIkNoYXJhY3RlciBjb2RlICdcIiArIGNvZGUgKyBcIicgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllciBzdGFydCBjaGFyXCIpLCBiZWdpbkluZGV4KTtcbiAgICAgIHJldHVybiBjcmVhdGVUb2tlbihFUlJPUiwgYmVnaW5JbmRleCk7XG4gICAgfVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29kZSA9IGN1cnJlbnRDaGFyQ29kZTtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNvZGUpKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gOTIpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBjb2RlID0gcmVhZFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBpZiAoIWVzY2FwZWRDaGFyQ29kZXMpXG4gICAgICAgICAgZXNjYXBlZENoYXJDb2RlcyA9IFtdO1xuICAgICAgICBlc2NhcGVkQ2hhckNvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjb2RlKSlcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oRVJST1IsIGJlZ2luSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGluZGV4KTtcbiAgICB2YXIga2V5d29yZFR5cGUgPSBnZXRLZXl3b3JkVHlwZSh2YWx1ZSk7XG4gICAgaWYgKGtleXdvcmRUeXBlKVxuICAgICAgcmV0dXJuIG5ldyBLZXl3b3JkVG9rZW4odmFsdWUsIGtleXdvcmRUeXBlLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXgpKTtcbiAgICBpZiAoZXNjYXBlZENoYXJDb2Rlcykge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcdS4uLi4vZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlc2NhcGVkQ2hhckNvZGVzW2krK10pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSWRlbnRpZmllclRva2VuKGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCksIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbChiZWdpbkluZGV4LCB0ZXJtaW5hdG9yKSB7XG4gICAgd2hpbGUgKHBlZWtTdHJpbmdMaXRlcmFsQ2hhcih0ZXJtaW5hdG9yKSkge1xuICAgICAgaWYgKCFza2lwU3RyaW5nTGl0ZXJhbENoYXIoKSkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxUb2tlbihTVFJJTkcsIGdldFRva2VuU3RyaW5nKGJlZ2luSW5kZXgpLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRDaGFyQ29kZSAhPT0gdGVybWluYXRvcikge1xuICAgICAgcmVwb3J0RXJyb3IoJ1VudGVybWluYXRlZCBTdHJpbmcgTGl0ZXJhbCcsIGJlZ2luSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKFNUUklORywgZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCksIGdldFRva2VuUmFuZ2UoYmVnaW5JbmRleCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFRva2VuU3RyaW5nKGJlZ2luSW5kZXgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKGJlZ2luSW5kZXgsIGluZGV4KTtcbiAgfVxuICBmdW5jdGlvbiBwZWVrU3RyaW5nTGl0ZXJhbENoYXIodGVybWluYXRvcikge1xuICAgIHJldHVybiAhaXNBdEVuZCgpICYmIGN1cnJlbnRDaGFyQ29kZSAhPT0gdGVybWluYXRvciAmJiAhaXNMaW5lVGVybWluYXRvcihjdXJyZW50Q2hhckNvZGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBTdHJpbmdMaXRlcmFsQ2hhcigpIHtcbiAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA5Mikge1xuICAgICAgcmV0dXJuIHNraXBTdHJpbmdMaXRlcmFsRXNjYXBlU2VxdWVuY2UoKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBTdHJpbmdMaXRlcmFsRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgbmV4dCgpO1xuICAgIGlmIChpc0F0RW5kKCkpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdVbnRlcm1pbmF0ZWQgc3RyaW5nIGxpdGVyYWwgZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgIHNraXBMaW5lVGVybWluYXRvcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjb2RlID0gY3VycmVudENoYXJDb2RlO1xuICAgIG5leHQoKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgMzk6XG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSA5MjpcbiAgICAgIGNhc2UgOTg6XG4gICAgICBjYXNlIDEwMjpcbiAgICAgIGNhc2UgMTEwOlxuICAgICAgY2FzZSAxMTQ6XG4gICAgICBjYXNlIDExNjpcbiAgICAgIGNhc2UgMTE4OlxuICAgICAgY2FzZSA0ODpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIDEyMDpcbiAgICAgICAgcmV0dXJuIHNraXBIZXhEaWdpdCgpICYmIHNraXBIZXhEaWdpdCgpO1xuICAgICAgY2FzZSAxMTc6XG4gICAgICAgIHJldHVybiBza2lwVW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSAxMjMgJiYgb3B0aW9ucy51bmljb2RlRXNjYXBlU2VxdWVuY2VzKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICB2YXIgYmVnaW5JbmRleCA9IGluZGV4O1xuICAgICAgaWYgKCFpc0hleERpZ2l0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgICAgcmVwb3J0RXJyb3IoJ0hleCBkaWdpdCBleHBlY3RlZCcsIGJlZ2luSW5kZXgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBza2lwSGV4RGlnaXRzKCk7XG4gICAgICBpZiAoY3VycmVudENoYXJDb2RlICE9PSAxMjUpIHtcbiAgICAgICAgcmVwb3J0RXJyb3IoJ0hleCBkaWdpdCBleHBlY3RlZCcsIGJlZ2luSW5kZXgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0VG9rZW5TdHJpbmcoYmVnaW5JbmRleCwgaW5kZXgpO1xuICAgICAgaWYgKHBhcnNlSW50KGNvZGVQb2ludCwgMTYpID4gMHgxMEZGRkYpIHtcbiAgICAgICAgcmVwb3J0RXJyb3IoJ1RoZSBjb2RlIHBvaW50IGluIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgY2Fubm90IGV4Y2VlZCAxMEZGRkYnLCBiZWdpbkluZGV4KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKSAmJiBza2lwSGV4RGlnaXQoKTtcbiAgfVxuICBmdW5jdGlvbiBza2lwSGV4RGlnaXQoKSB7XG4gICAgaWYgKCFpc0hleERpZ2l0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgIHJlcG9ydEVycm9yKCdIZXggZGlnaXQgZXhwZWN0ZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHNraXBMaW5lVGVybWluYXRvcigpIHtcbiAgICB2YXIgZmlyc3QgPSBjdXJyZW50Q2hhckNvZGU7XG4gICAgbmV4dCgpO1xuICAgIGlmIChmaXJzdCA9PT0gMTMgJiYgY3VycmVudENoYXJDb2RlID09PSAxMCkge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzY2FuRnJhY3Rpb25hbE51bWVyaWNMaXRlcmFsKGJlZ2luSW5kZXgpIHtcbiAgICBpZiAoY3VycmVudENoYXJDb2RlID09PSA0Nikge1xuICAgICAgbmV4dCgpO1xuICAgICAgc2tpcERlY2ltYWxEaWdpdHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYW5FeHBvbmVudE9mTnVtZXJpY0xpdGVyYWwoYmVnaW5JbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gc2NhbkV4cG9uZW50T2ZOdW1lcmljTGl0ZXJhbChiZWdpbkluZGV4KSB7XG4gICAgc3dpdGNoIChjdXJyZW50Q2hhckNvZGUpIHtcbiAgICAgIGNhc2UgMTAxOlxuICAgICAgY2FzZSA2OTpcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRDaGFyQ29kZSkge1xuICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY3VycmVudENoYXJDb2RlKSkge1xuICAgICAgICAgIHJlcG9ydEVycm9yKCdFeHBvbmVudCBwYXJ0IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgZGlnaXQnLCBiZWdpbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBza2lwRGVjaW1hbERpZ2l0cygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExpdGVyYWxUb2tlbihOVU1CRVIsIGdldFRva2VuU3RyaW5nKGJlZ2luSW5kZXgpLCBnZXRUb2tlblJhbmdlKGJlZ2luSW5kZXgpKTtcbiAgfVxuICBmdW5jdGlvbiBza2lwRGVjaW1hbERpZ2l0cygpIHtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoY3VycmVudENoYXJDb2RlKSkge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBza2lwSGV4RGlnaXRzKCkge1xuICAgIHdoaWxlIChpc0hleERpZ2l0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2tpcEJpbmFyeURpZ2l0cygpIHtcbiAgICB3aGlsZSAoaXNCaW5hcnlEaWdpdChjdXJyZW50Q2hhckNvZGUpKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNraXBPY3RhbERpZ2l0cygpIHtcbiAgICB3aGlsZSAoaXNPY3RhbERpZ2l0KGN1cnJlbnRDaGFyQ29kZSkpIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNBdEVuZCgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IGxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGluZGV4Kys7XG4gICAgdXBkYXRlQ3VycmVudENoYXJDb2RlKCk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlQ3VycmVudENoYXJDb2RlKCkge1xuICAgIGN1cnJlbnRDaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlcG9ydEVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiBpbmRleDtcbiAgICB2YXIgZW5kSW5kZXggPSBhcmd1bWVudHNbMl0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzJdIDogaW5kZXg7XG4gICAgdmFyIHN0YXJ0ID0gZ2V0UG9zaXRpb25CeU9mZnNldChzdGFydEluZGV4KTtcbiAgICB2YXIgZW5kID0gZ2V0UG9zaXRpb25CeU9mZnNldChlbmRJbmRleCk7XG4gICAgdmFyIGxvY2F0aW9uID0gbmV3IFNvdXJjZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIGVycm9yUmVwb3J0ZXIucmVwb3J0RXJyb3IobG9jYXRpb24sIG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0IGlzV2hpdGVzcGFjZSgpIHtcbiAgICAgIHJldHVybiBpc1doaXRlc3BhY2U7XG4gICAgfSxcbiAgICBnZXQgaXNMaW5lVGVybWluYXRvcigpIHtcbiAgICAgIHJldHVybiBpc0xpbmVUZXJtaW5hdG9yO1xuICAgIH0sXG4gICAgZ2V0IGlzSWRlbnRpZmllclBhcnQoKSB7XG4gICAgICByZXR1cm4gaXNJZGVudGlmaWVyUGFydDtcbiAgICB9LFxuICAgIGdldCBpbml0KCkge1xuICAgICAgcmV0dXJuIGluaXQ7XG4gICAgfSxcbiAgICBnZXQgZ2V0TGFzdFRva2VuKCkge1xuICAgICAgcmV0dXJuIGdldExhc3RUb2tlbjtcbiAgICB9LFxuICAgIGdldCBuZXh0UmVndWxhckV4cHJlc3Npb25MaXRlcmFsVG9rZW4oKSB7XG4gICAgICByZXR1cm4gbmV4dFJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbFRva2VuO1xuICAgIH0sXG4gICAgZ2V0IG5leHRUZW1wbGF0ZUxpdGVyYWxUb2tlbigpIHtcbiAgICAgIHJldHVybiBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW47XG4gICAgfSxcbiAgICBnZXQgc2V0SW5kZXgoKSB7XG4gICAgICByZXR1cm4gc2V0SW5kZXg7XG4gICAgfSxcbiAgICBnZXQgZ2V0UG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb247XG4gICAgfSxcbiAgICBnZXQgbmV4dENsb3NlQW5nbGUoKSB7XG4gICAgICByZXR1cm4gbmV4dENsb3NlQW5nbGU7XG4gICAgfSxcbiAgICBnZXQgcGVla0pzeFRva2VuKCkge1xuICAgICAgcmV0dXJuIHBlZWtKc3hUb2tlbjtcbiAgICB9LFxuICAgIGdldCBuZXh0SnN4VG9rZW4oKSB7XG4gICAgICByZXR1cm4gbmV4dEpzeFRva2VuO1xuICAgIH0sXG4gICAgZ2V0IG5leHRKc3hUZXh0VG9rZW4oKSB7XG4gICAgICByZXR1cm4gbmV4dEpzeFRleHRUb2tlbjtcbiAgICB9LFxuICAgIGdldCBuZXh0VG9rZW4oKSB7XG4gICAgICByZXR1cm4gbmV4dFRva2VuO1xuICAgIH0sXG4gICAgZ2V0IHBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICByZXR1cm4gcGVla1Rva2VuTm9MaW5lVGVybWluYXRvcjtcbiAgICB9LFxuICAgIGdldCBwZWVrKCkge1xuICAgICAgcmV0dXJuIHBlZWs7XG4gICAgfSxcbiAgICBnZXQgcGVla0xvb2thaGVhZCgpIHtcbiAgICAgIHJldHVybiBwZWVrTG9va2FoZWFkO1xuICAgIH0sXG4gICAgZ2V0IHBlZWtUb2tlbigpIHtcbiAgICAgIHJldHVybiBwZWVrVG9rZW47XG4gICAgfSxcbiAgICBnZXQgcGVla1R5cGUoKSB7XG4gICAgICByZXR1cm4gcGVla1R5cGU7XG4gICAgfSxcbiAgICBnZXQgcGVla0xvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHBlZWtMb2NhdGlvbjtcbiAgICB9LFxuICAgIGdldCBwZWVrVG9rZW5Mb29rYWhlYWQoKSB7XG4gICAgICByZXR1cm4gcGVla1Rva2VuTG9va2FoZWFkO1xuICAgIH0sXG4gICAgZ2V0IGlzQXRFbmQoKSB7XG4gICAgICByZXR1cm4gaXNBdEVuZDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0cnVjdG9yVmFsaWRhdG9yLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0cnVjdG9yVmFsaWRhdG9yLmpzXCI7XG4gIHZhciBTVVBFUl9FWFBSRVNTSU9OID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvQ29uc3RydWN0b3JWYWxpZGF0b3IuanNcIikpLlNVUEVSX0VYUFJFU1NJT047XG4gIHZhciBGaW5kVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9jb2RlZ2VuZXJhdGlvbi9GaW5kVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0cnVjdG9yVmFsaWRhdG9yLmpzXCIpKS5GaW5kVmlzaXRvcjtcbiAgdmFyIENvbnN0cnVjdG9yVmFsaWRhdG9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvclZhbGlkYXRvcihyZXBvcnRlcikge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29uc3RydWN0b3JWYWxpZGF0b3IpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJlcG9ydGVyXyA9IHJlcG9ydGVyO1xuICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29uc3RydWN0b3JWYWxpZGF0b3IsIHtcbiAgICAgIHZpc2l0Q2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VGhpc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8odHJlZS5sb2NhdGlvbiwgJ3RoaXMnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gU1VQRVJfRVhQUkVTU0lPTikge1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5hcmdzKTtcbiAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENvbnN0cnVjdG9yVmFsaWRhdG9yLnByb3RvdHlwZSwgXCJ2aXNpdENhbGxFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTdXBlckV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8odHJlZS5sb2NhdGlvbiwgJ3N1cGVyIHByb3BlcnR5Jyk7XG4gICAgICB9LFxuICAgICAgcmVwb3J0RXJyb3JfOiBmdW5jdGlvbihsb2NhdGlvbiwga2luZCkge1xuICAgICAgICB0aGlzLnJlcG9ydGVyXy5yZXBvcnRFcnJvcihsb2NhdGlvbiwgKFwiJ1wiICsga2luZCArIFwiJyBpcyBub3QgYWxsb3dlZCBiZWZvcmUgc3VwZXIoKVwiKSk7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRWaXNpdG9yKTtcbiAgZnVuY3Rpb24gdmFsaWRhdGVDb25zdHJ1Y3Rvcih0cmVlLCByZXBvcnRlcikge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IENvbnN0cnVjdG9yVmFsaWRhdG9yKHJlcG9ydGVyKTtcbiAgICB2aXNpdG9yLnZpc2l0QW55KHRyZWUpO1xuICAgIGlmICh2aXNpdG9yLmhhc0Vycm9yKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aXNpdG9yLmZvdW5kKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmVwb3J0ZXIucmVwb3J0RXJyb3IodHJlZS5sb2NhdGlvbiwgJ0Rlcml2ZWQgY29uc3RydWN0b3IgbXVzdCBjYWxsIHN1cGVyKCknKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtnZXQgdmFsaWRhdGVDb25zdHJ1Y3RvcigpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUNvbnN0cnVjdG9yO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N0YXRpY3NlbWFudGljcy92YWxpZGF0ZVBhcmFtZXRlcnMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvdmFsaWRhdGVQYXJhbWV0ZXJzLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QYXJzZVRyZWVWaXNpdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvdmFsaWRhdGVQYXJhbWV0ZXJzLmpzXCIpKS5QYXJzZVRyZWVWaXNpdG9yO1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvdmFsaWRhdGVQYXJhbWV0ZXJzLmpzXCIpKS5TdHJpbmdTZXQ7XG4gIHZhciBpc1N0cmljdEtleXdvcmQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L0tleXdvcmRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvdmFsaWRhdGVQYXJhbWV0ZXJzLmpzXCIpKS5pc1N0cmljdEtleXdvcmQ7XG4gIHZhciBQYXJhbWV0ZXJWYWxpZGF0aW9uVmlzaXRvciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUGFyYW1ldGVyVmFsaWRhdGlvblZpc2l0b3IoaXNTdHJpY3QsIHJlcG9ydGVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQYXJhbWV0ZXJWYWxpZGF0aW9uVmlzaXRvcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucmVwb3J0ZXJfID0gcmVwb3J0ZXI7XG4gICAgICB0aGlzLm5hbWVzXyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgIHRoaXMuZXJyb3JzXyA9IFtdO1xuICAgICAgdGhpcy5yZXBvcnRTdHJpY3RLZXl3b3Jkc18gPSBpc1N0cmljdDtcbiAgICAgIHRoaXMucmVwb3J0RHVwbGljYXRlc18gPSBpc1N0cmljdDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFBhcmFtZXRlclZhbGlkYXRpb25WaXNpdG9yLCB7XG4gICAgICB2aXNpdEJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdHJlZS5pZGVudGlmaWVyVG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMucmVwb3J0U3RyaWN0S2V5d29yZHNfICYmIChpc1N0cmljdEtleXdvcmQobmFtZSkgfHwgbmFtZSA9PT0gJ2V2YWwnIHx8IG5hbWUgPT09ICdhcmd1bWVudHMnKSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0ZXJfLnJlcG9ydEVycm9yKHRyZWUubG9jYXRpb24sIChuYW1lICsgXCIgaXMgYSByZXNlcnZlZCBpZGVudGlmaWVyXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lc18uaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5tYXliZVJlcG9ydER1cGxpY2F0ZUVycm9yXyhuYW1lLCB0cmVlLmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzXy5hZGQobmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5pbml0aWFsaXplciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RWFybGllckVycm9yc18oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRSZXN0UGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RWFybGllckVycm9yc18oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmlkZW50aWZpZXIpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9ybWFsUGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5wYXJhbWV0ZXIpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJyYXlQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RWFybGllckVycm9yc18oKTtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcmFtZXRlclZhbGlkYXRpb25WaXNpdG9yLnByb3RvdHlwZSwgXCJ2aXNpdEFycmF5UGF0dGVyblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0T2JqZWN0UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnJlcG9ydEVhcmxpZXJFcnJvcnNfKCk7XG4gICAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQYXJhbWV0ZXJWYWxpZGF0aW9uVmlzaXRvci5wcm90b3R5cGUsIFwidmlzaXRPYmplY3RQYXR0ZXJuXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgcmVwb3J0RHVwbGljYXRlRXJyb3JfOiBmdW5jdGlvbihuYW1lLCBsb2NhdGlvbikge1xuICAgICAgICB0aGlzLnJlcG9ydGVyXy5yZXBvcnRFcnJvcihsb2NhdGlvbiwgKFwiRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lIFwiICsgbmFtZSkpO1xuICAgICAgfSxcbiAgICAgIG1heWJlUmVwb3J0RHVwbGljYXRlRXJyb3JfOiBmdW5jdGlvbihuYW1lLCBsb2NhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5yZXBvcnREdXBsaWNhdGVzXykge1xuICAgICAgICAgIHRoaXMucmVwb3J0RHVwbGljYXRlRXJyb3JfKG5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yc18ucHVzaChuYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXBvcnRFYXJsaWVyRXJyb3JzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXBvcnREdXBsaWNhdGVzXykge1xuICAgICAgICAgIHRoaXMucmVwb3J0RHVwbGljYXRlc18gPSB0cnVlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lcnJvcnNfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZXJyb3JzX1tpXTtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuZXJyb3JzX1tpICsgMV07XG4gICAgICAgICAgICB0aGlzLnJlcG9ydER1cGxpY2F0ZUVycm9yXyhuYW1lLCBsb2NhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVWaXNpdG9yKTtcbiAgdmFyICRfX2RlZmF1bHQgPSBmdW5jdGlvbih0cmVlLCBpc1N0cmljdCwgcmVwb3J0ZXIpIHtcbiAgICBuZXcgUGFyYW1ldGVyVmFsaWRhdGlvblZpc2l0b3IoaXNTdHJpY3QsIHJlcG9ydGVyKS52aXNpdEFueSh0cmVlKTtcbiAgfTtcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX19kZWZhdWx0O1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N0YXRpY3NlbWFudGljcy9pc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N0YXRpY3NlbWFudGljcy9pc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldC5qc1wiO1xuICB2YXIgJF9fMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3RhdGljc2VtYW50aWNzL2lzVmFsaWRTaW1wbGVBc3NpZ25tZW50VGFyZ2V0LmpzXCIpKSxcbiAgICAgIElERU5USUZJRVJfRVhQUkVTU0lPTiA9ICRfXzEuSURFTlRJRklFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0VYUFJFU1NJT04gPSAkX18xLk1FTUJFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OID0gJF9fMS5NRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04sXG4gICAgICBQQVJFTl9FWFBSRVNTSU9OID0gJF9fMS5QQVJFTl9FWFBSRVNTSU9OO1xuICBmdW5jdGlvbiBpc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldCh0cmVlLCBpc1N0cmljdCkge1xuICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICBjYXNlIElERU5USUZJRVJfRVhQUkVTU0lPTjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaXNTdHJpY3QpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0cmVlLmlkZW50aWZpZXJUb2tlbi52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09ICdhcmd1bWVudHMnICYmIHZhbHVlICE9PSAnZXZhbCc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUEFSRU5fRVhQUkVTU0lPTjpcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRTaW1wbGVBc3NpZ25tZW50VGFyZ2V0KHRyZWUuZXhwcmVzc2lvbiwgaXNTdHJpY3QpO1xuICAgICAgY2FzZSBNRU1CRVJfRVhQUkVTU0lPTjpcbiAgICAgIGNhc2UgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlci5qc1wiO1xuICB2YXIgRmluZFZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY29kZWdlbmVyYXRpb24vRmluZFZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLkZpbmRWaXNpdG9yO1xuICB2YXIgSWRlbnRpZmllclRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSWRlbnRpZmllclRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIpKS5JZGVudGlmaWVyVG9rZW47XG4gIHZhciAkX18yNSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLFxuICAgICAgQVJSQVlfTElURVJBTCA9ICRfXzI1LkFSUkFZX0xJVEVSQUwsXG4gICAgICBCSU5ESU5HX0lERU5USUZJRVIgPSAkX18yNS5CSU5ESU5HX0lERU5USUZJRVIsXG4gICAgICBDQUxMX0VYUFJFU1NJT04gPSAkX18yNS5DQUxMX0VYUFJFU1NJT04sXG4gICAgICBDT01QVVRFRF9QUk9QRVJUWV9OQU1FID0gJF9fMjUuQ09NUFVURURfUFJPUEVSVFlfTkFNRSxcbiAgICAgIENPVkVSX0ZPUk1BTFMgPSAkX18yNS5DT1ZFUl9GT1JNQUxTLFxuICAgICAgRk9STUFMX1BBUkFNRVRFUl9MSVNUID0gJF9fMjUuRk9STUFMX1BBUkFNRVRFUl9MSVNULFxuICAgICAgSURFTlRJRklFUl9FWFBSRVNTSU9OID0gJF9fMjUuSURFTlRJRklFUl9FWFBSRVNTSU9OLFxuICAgICAgTElURVJBTF9QUk9QRVJUWV9OQU1FID0gJF9fMjUuTElURVJBTF9QUk9QRVJUWV9OQU1FLFxuICAgICAgT0JKRUNUX0xJVEVSQUwgPSAkX18yNS5PQkpFQ1RfTElURVJBTCxcbiAgICAgIFJFU1RfUEFSQU1FVEVSID0gJF9fMjUuUkVTVF9QQVJBTUVURVIsXG4gICAgICBTWU5UQVhfRVJST1JfVFJFRSA9ICRfXzI1LlNZTlRBWF9FUlJPUl9UUkVFO1xuICB2YXIgT3B0aW9ucyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9PcHRpb25zLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIpKS5PcHRpb25zO1xuICB2YXIgJF9fMjcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlci5qc1wiKSksXG4gICAgICBBUyA9ICRfXzI3LkFTLFxuICAgICAgQVNZTkMgPSAkX18yNy5BU1lOQyxcbiAgICAgIEFTWU5DX1NUQVIgPSAkX18yNy5BU1lOQ19TVEFSLFxuICAgICAgQVdBSVQgPSAkX18yNy5BV0FJVCxcbiAgICAgIENPTlNUUlVDVE9SID0gJF9fMjcuQ09OU1RSVUNUT1IsXG4gICAgICBGUk9NID0gJF9fMjcuRlJPTSxcbiAgICAgIEdFVCA9ICRfXzI3LkdFVCxcbiAgICAgIE9GID0gJF9fMjcuT0YsXG4gICAgICBPTiA9ICRfXzI3Lk9OLFxuICAgICAgU0VUID0gJF9fMjcuU0VULFxuICAgICAgVFlQRSA9ICRfXzI3LlRZUEU7XG4gIHZhciBTeW50YXhFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3ludGF4RXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlci5qc1wiKSkuU3ludGF4RXJyb3JSZXBvcnRlcjtcbiAgdmFyICRfXzI5ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU2Nhbm5lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlci5qc1wiKSksXG4gICAgICBnZXRMYXN0VG9rZW4gPSAkX18yOS5nZXRMYXN0VG9rZW4sXG4gICAgICBnZXRQb3NpdGlvbiA9ICRfXzI5LmdldFBvc2l0aW9uLFxuICAgICAgaW5pdFNjYW5uZXIgPSAkX18yOS5pbml0LFxuICAgICAgaXNBdEVuZCA9ICRfXzI5LmlzQXRFbmQsXG4gICAgICBuZXh0Q2xvc2VBbmdsZSA9ICRfXzI5Lm5leHRDbG9zZUFuZ2xlLFxuICAgICAgbmV4dEpzeFRleHRUb2tlbiA9ICRfXzI5Lm5leHRKc3hUZXh0VG9rZW4sXG4gICAgICBuZXh0SnN4VG9rZW4gPSAkX18yOS5uZXh0SnN4VG9rZW4sXG4gICAgICBuZXh0UmVndWxhckV4cHJlc3Npb25MaXRlcmFsVG9rZW4gPSAkX18yOS5uZXh0UmVndWxhckV4cHJlc3Npb25MaXRlcmFsVG9rZW4sXG4gICAgICBuZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW4gPSAkX18yOS5uZXh0VGVtcGxhdGVMaXRlcmFsVG9rZW4sXG4gICAgICBuZXh0VG9rZW4gPSAkX18yOS5uZXh0VG9rZW4sXG4gICAgICBwZWVrID0gJF9fMjkucGVlayxcbiAgICAgIHBlZWtKc3hUb2tlbiA9ICRfXzI5LnBlZWtKc3hUb2tlbixcbiAgICAgIHBlZWtMb2NhdGlvbiA9ICRfXzI5LnBlZWtMb2NhdGlvbixcbiAgICAgIHBlZWtMb29rYWhlYWQgPSAkX18yOS5wZWVrTG9va2FoZWFkLFxuICAgICAgcGVla1Rva2VuID0gJF9fMjkucGVla1Rva2VuLFxuICAgICAgcGVla1Rva2VuTG9va2FoZWFkID0gJF9fMjkucGVla1Rva2VuTG9va2FoZWFkLFxuICAgICAgcGVla1Rva2VuTm9MaW5lVGVybWluYXRvciA9ICRfXzI5LnBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IsXG4gICAgICBwZWVrVHlwZSA9ICRfXzI5LnBlZWtUeXBlLFxuICAgICAgcmVzZXRTY2FubmVyID0gJF9fMjkuc2V0SW5kZXg7XG4gIHZhciBTb3VyY2VSYW5nZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi91dGlsL1NvdXJjZVJhbmdlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIpKS5Tb3VyY2VSYW5nZTtcbiAgdmFyICRfXzMxID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLFxuICAgICAgVG9rZW4gPSAkX18zMS5Ub2tlbixcbiAgICAgIGlzQXNzaWdubWVudE9wZXJhdG9yID0gJF9fMzEuaXNBc3NpZ25tZW50T3BlcmF0b3I7XG4gIHZhciBnZXRLZXl3b3JkVHlwZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0tleXdvcmRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIpKS5nZXRLZXl3b3JkVHlwZTtcbiAgdmFyIHZhbGlkYXRlQ29uc3RydWN0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc2VtYW50aWNzL0NvbnN0cnVjdG9yVmFsaWRhdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VyLmpzXCIpKS52YWxpZGF0ZUNvbnN0cnVjdG9yO1xuICB2YXIgdmFsaWRhdGVQYXJhbWV0ZXJzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N0YXRpY3NlbWFudGljcy92YWxpZGF0ZVBhcmFtZXRlcnMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBpc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zdGF0aWNzZW1hbnRpY3MvaXNWYWxpZFNpbXBsZUFzc2lnbm1lbnRUYXJnZXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX18zNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlci5qc1wiKSksXG4gICAgICBBTVBFUlNBTkQgPSAkX18zNi5BTVBFUlNBTkQsXG4gICAgICBBTkQgPSAkX18zNi5BTkQsXG4gICAgICBBUlJPVyA9ICRfXzM2LkFSUk9XLFxuICAgICAgQVQgPSAkX18zNi5BVCxcbiAgICAgIEJBTkcgPSAkX18zNi5CQU5HLFxuICAgICAgQkFSID0gJF9fMzYuQkFSLFxuICAgICAgQlJFQUsgPSAkX18zNi5CUkVBSyxcbiAgICAgIENBUkVUID0gJF9fMzYuQ0FSRVQsXG4gICAgICBDQVNFID0gJF9fMzYuQ0FTRSxcbiAgICAgIENBVENIID0gJF9fMzYuQ0FUQ0gsXG4gICAgICBDTEFTUyA9ICRfXzM2LkNMQVNTLFxuICAgICAgQ0xPU0VfQU5HTEUgPSAkX18zNi5DTE9TRV9BTkdMRSxcbiAgICAgIENMT1NFX0NVUkxZID0gJF9fMzYuQ0xPU0VfQ1VSTFksXG4gICAgICBDTE9TRV9QQVJFTiA9ICRfXzM2LkNMT1NFX1BBUkVOLFxuICAgICAgQ0xPU0VfU1FVQVJFID0gJF9fMzYuQ0xPU0VfU1FVQVJFLFxuICAgICAgQ09MT04gPSAkX18zNi5DT0xPTixcbiAgICAgIENPTU1BID0gJF9fMzYuQ09NTUEsXG4gICAgICBDT05TVCA9ICRfXzM2LkNPTlNULFxuICAgICAgQ09OVElOVUUgPSAkX18zNi5DT05USU5VRSxcbiAgICAgIERFQlVHR0VSID0gJF9fMzYuREVCVUdHRVIsXG4gICAgICBERUZBVUxUID0gJF9fMzYuREVGQVVMVCxcbiAgICAgIERFTEVURSA9ICRfXzM2LkRFTEVURSxcbiAgICAgIERPID0gJF9fMzYuRE8sXG4gICAgICBET1RfRE9UX0RPVCA9ICRfXzM2LkRPVF9ET1RfRE9ULFxuICAgICAgRUxTRSA9ICRfXzM2LkVMU0UsXG4gICAgICBFTkRfT0ZfRklMRSA9ICRfXzM2LkVORF9PRl9GSUxFLFxuICAgICAgRVFVQUwgPSAkX18zNi5FUVVBTCxcbiAgICAgIEVRVUFMX0VRVUFMID0gJF9fMzYuRVFVQUxfRVFVQUwsXG4gICAgICBFUVVBTF9FUVVBTF9FUVVBTCA9ICRfXzM2LkVRVUFMX0VRVUFMX0VRVUFMLFxuICAgICAgRVJST1IgPSAkX18zNi5FUlJPUixcbiAgICAgIEVYUE9SVCA9ICRfXzM2LkVYUE9SVCxcbiAgICAgIEVYVEVORFMgPSAkX18zNi5FWFRFTkRTLFxuICAgICAgRkFMU0UgPSAkX18zNi5GQUxTRSxcbiAgICAgIEZJTkFMTFkgPSAkX18zNi5GSU5BTExZLFxuICAgICAgRk9SID0gJF9fMzYuRk9SLFxuICAgICAgRlVOQ1RJT04gPSAkX18zNi5GVU5DVElPTixcbiAgICAgIEdSRUFURVJfRVFVQUwgPSAkX18zNi5HUkVBVEVSX0VRVUFMLFxuICAgICAgSURFTlRJRklFUiA9ICRfXzM2LklERU5USUZJRVIsXG4gICAgICBJRiA9ICRfXzM2LklGLFxuICAgICAgSU1QTEVNRU5UUyA9ICRfXzM2LklNUExFTUVOVFMsXG4gICAgICBJTVBPUlQgPSAkX18zNi5JTVBPUlQsXG4gICAgICBJTiA9ICRfXzM2LklOLFxuICAgICAgSU5TVEFOQ0VPRiA9ICRfXzM2LklOU1RBTkNFT0YsXG4gICAgICBJTlRFUkZBQ0UgPSAkX18zNi5JTlRFUkZBQ0UsXG4gICAgICBKU1hfSURFTlRJRklFUiA9ICRfXzM2LkpTWF9JREVOVElGSUVSLFxuICAgICAgTEVGVF9TSElGVCA9ICRfXzM2LkxFRlRfU0hJRlQsXG4gICAgICBMRVNTX0VRVUFMID0gJF9fMzYuTEVTU19FUVVBTCxcbiAgICAgIExFVCA9ICRfXzM2LkxFVCxcbiAgICAgIE1JTlVTID0gJF9fMzYuTUlOVVMsXG4gICAgICBNSU5VU19NSU5VUyA9ICRfXzM2Lk1JTlVTX01JTlVTLFxuICAgICAgTkVXID0gJF9fMzYuTkVXLFxuICAgICAgTk9fU1VCU1RJVFVUSU9OX1RFTVBMQVRFID0gJF9fMzYuTk9fU1VCU1RJVFVUSU9OX1RFTVBMQVRFLFxuICAgICAgTk9UX0VRVUFMID0gJF9fMzYuTk9UX0VRVUFMLFxuICAgICAgTk9UX0VRVUFMX0VRVUFMID0gJF9fMzYuTk9UX0VRVUFMX0VRVUFMLFxuICAgICAgTlVMTCA9ICRfXzM2Lk5VTEwsXG4gICAgICBOVU1CRVIgPSAkX18zNi5OVU1CRVIsXG4gICAgICBPUEVOX0FOR0xFID0gJF9fMzYuT1BFTl9BTkdMRSxcbiAgICAgIE9QRU5fQ1VSTFkgPSAkX18zNi5PUEVOX0NVUkxZLFxuICAgICAgT1BFTl9QQVJFTiA9ICRfXzM2Lk9QRU5fUEFSRU4sXG4gICAgICBPUEVOX1NRVUFSRSA9ICRfXzM2Lk9QRU5fU1FVQVJFLFxuICAgICAgT1IgPSAkX18zNi5PUixcbiAgICAgIFBBQ0tBR0UgPSAkX18zNi5QQUNLQUdFLFxuICAgICAgUEVSQ0VOVCA9ICRfXzM2LlBFUkNFTlQsXG4gICAgICBQRVJJT0QgPSAkX18zNi5QRVJJT0QsXG4gICAgICBQTFVTID0gJF9fMzYuUExVUyxcbiAgICAgIFBMVVNfUExVUyA9ICRfXzM2LlBMVVNfUExVUyxcbiAgICAgIFBSSVZBVEUgPSAkX18zNi5QUklWQVRFLFxuICAgICAgUFJPVEVDVEVEID0gJF9fMzYuUFJPVEVDVEVELFxuICAgICAgUFVCTElDID0gJF9fMzYuUFVCTElDLFxuICAgICAgUVVFU1RJT04gPSAkX18zNi5RVUVTVElPTixcbiAgICAgIFJFVFVSTiA9ICRfXzM2LlJFVFVSTixcbiAgICAgIFJJR0hUX1NISUZUID0gJF9fMzYuUklHSFRfU0hJRlQsXG4gICAgICBTRU1JX0NPTE9OID0gJF9fMzYuU0VNSV9DT0xPTixcbiAgICAgIFNMQVNIID0gJF9fMzYuU0xBU0gsXG4gICAgICBTTEFTSF9FUVVBTCA9ICRfXzM2LlNMQVNIX0VRVUFMLFxuICAgICAgU1RBUiA9ICRfXzM2LlNUQVIsXG4gICAgICBTVEFSX1NUQVIgPSAkX18zNi5TVEFSX1NUQVIsXG4gICAgICBTVEFUSUMgPSAkX18zNi5TVEFUSUMsXG4gICAgICBTVFJJTkcgPSAkX18zNi5TVFJJTkcsXG4gICAgICBTVVBFUiA9ICRfXzM2LlNVUEVSLFxuICAgICAgU1dJVENIID0gJF9fMzYuU1dJVENILFxuICAgICAgVEVNUExBVEVfSEVBRCA9ICRfXzM2LlRFTVBMQVRFX0hFQUQsXG4gICAgICBURU1QTEFURV9UQUlMID0gJF9fMzYuVEVNUExBVEVfVEFJTCxcbiAgICAgIFRISVMgPSAkX18zNi5USElTLFxuICAgICAgVEhST1cgPSAkX18zNi5USFJPVyxcbiAgICAgIFRJTERFID0gJF9fMzYuVElMREUsXG4gICAgICBUUlVFID0gJF9fMzYuVFJVRSxcbiAgICAgIFRSWSA9ICRfXzM2LlRSWSxcbiAgICAgIFRZUEVPRiA9ICRfXzM2LlRZUEVPRixcbiAgICAgIFVOU0lHTkVEX1JJR0hUX1NISUZUID0gJF9fMzYuVU5TSUdORURfUklHSFRfU0hJRlQsXG4gICAgICBWQVIgPSAkX18zNi5WQVIsXG4gICAgICBWT0lEID0gJF9fMzYuVk9JRCxcbiAgICAgIFdISUxFID0gJF9fMzYuV0hJTEUsXG4gICAgICBXSVRIID0gJF9fMzYuV0lUSCxcbiAgICAgIFlJRUxEID0gJF9fMzYuWUlFTEQ7XG4gIHZhciAkX18zNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZXIuanNcIikpLFxuICAgICAgQXJndW1lbnRMaXN0ID0gJF9fMzcuQXJndW1lbnRMaXN0LFxuICAgICAgQXJyYXlDb21wcmVoZW5zaW9uID0gJF9fMzcuQXJyYXlDb21wcmVoZW5zaW9uLFxuICAgICAgQXJyYXlMaXRlcmFsID0gJF9fMzcuQXJyYXlMaXRlcmFsLFxuICAgICAgQXJyYXlQYXR0ZXJuID0gJF9fMzcuQXJyYXlQYXR0ZXJuLFxuICAgICAgQXJyYXlUeXBlID0gJF9fMzcuQXJyYXlUeXBlLFxuICAgICAgQXJyb3dGdW5jdGlvbiA9ICRfXzM3LkFycm93RnVuY3Rpb24sXG4gICAgICBBc3NpZ25tZW50RWxlbWVudCA9ICRfXzM3LkFzc2lnbm1lbnRFbGVtZW50LFxuICAgICAgQXdhaXRFeHByZXNzaW9uID0gJF9fMzcuQXdhaXRFeHByZXNzaW9uLFxuICAgICAgQmluYXJ5RXhwcmVzc2lvbiA9ICRfXzM3LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBCaW5kaW5nRWxlbWVudCA9ICRfXzM3LkJpbmRpbmdFbGVtZW50LFxuICAgICAgQmluZGluZ0lkZW50aWZpZXIgPSAkX18zNy5CaW5kaW5nSWRlbnRpZmllcixcbiAgICAgIEJsb2NrID0gJF9fMzcuQmxvY2ssXG4gICAgICBCcmVha1N0YXRlbWVudCA9ICRfXzM3LkJyZWFrU3RhdGVtZW50LFxuICAgICAgQ2FsbEV4cHJlc3Npb24gPSAkX18zNy5DYWxsRXhwcmVzc2lvbixcbiAgICAgIENhbGxTaWduYXR1cmUgPSAkX18zNy5DYWxsU2lnbmF0dXJlLFxuICAgICAgQ2FzZUNsYXVzZSA9ICRfXzM3LkNhc2VDbGF1c2UsXG4gICAgICBDYXRjaCA9ICRfXzM3LkNhdGNoLFxuICAgICAgQ2xhc3NEZWNsYXJhdGlvbiA9ICRfXzM3LkNsYXNzRGVjbGFyYXRpb24sXG4gICAgICBDbGFzc0V4cHJlc3Npb24gPSAkX18zNy5DbGFzc0V4cHJlc3Npb24sXG4gICAgICBDb21tYUV4cHJlc3Npb24gPSAkX18zNy5Db21tYUV4cHJlc3Npb24sXG4gICAgICBDb21wcmVoZW5zaW9uRm9yID0gJF9fMzcuQ29tcHJlaGVuc2lvbkZvcixcbiAgICAgIENvbXByZWhlbnNpb25JZiA9ICRfXzM3LkNvbXByZWhlbnNpb25JZixcbiAgICAgIENvbXB1dGVkUHJvcGVydHlOYW1lID0gJF9fMzcuQ29tcHV0ZWRQcm9wZXJ0eU5hbWUsXG4gICAgICBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAkX18zNy5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICBDb25zdHJ1Y3RTaWduYXR1cmUgPSAkX18zNy5Db25zdHJ1Y3RTaWduYXR1cmUsXG4gICAgICBDb25zdHJ1Y3RvclR5cGUgPSAkX18zNy5Db25zdHJ1Y3RvclR5cGUsXG4gICAgICBDb250aW51ZVN0YXRlbWVudCA9ICRfXzM3LkNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgQ292ZXJGb3JtYWxzID0gJF9fMzcuQ292ZXJGb3JtYWxzLFxuICAgICAgQ292ZXJJbml0aWFsaXplZE5hbWUgPSAkX18zNy5Db3ZlckluaXRpYWxpemVkTmFtZSxcbiAgICAgIERlYnVnZ2VyU3RhdGVtZW50ID0gJF9fMzcuRGVidWdnZXJTdGF0ZW1lbnQsXG4gICAgICBBbm5vdGF0aW9uID0gJF9fMzcuQW5ub3RhdGlvbixcbiAgICAgIERlZmF1bHRDbGF1c2UgPSAkX18zNy5EZWZhdWx0Q2xhdXNlLFxuICAgICAgRG9XaGlsZVN0YXRlbWVudCA9ICRfXzM3LkRvV2hpbGVTdGF0ZW1lbnQsXG4gICAgICBFbXB0eVN0YXRlbWVudCA9ICRfXzM3LkVtcHR5U3RhdGVtZW50LFxuICAgICAgRXhwb3J0RGVjbGFyYXRpb24gPSAkX18zNy5FeHBvcnREZWNsYXJhdGlvbixcbiAgICAgIEV4cG9ydERlZmF1bHQgPSAkX18zNy5FeHBvcnREZWZhdWx0LFxuICAgICAgRXhwb3J0U3BlY2lmaWVyID0gJF9fMzcuRXhwb3J0U3BlY2lmaWVyLFxuICAgICAgRXhwb3J0U3BlY2lmaWVyU2V0ID0gJF9fMzcuRXhwb3J0U3BlY2lmaWVyU2V0LFxuICAgICAgRXhwb3J0U3RhciA9ICRfXzM3LkV4cG9ydFN0YXIsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50ID0gJF9fMzcuRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgIEZpbmFsbHkgPSAkX18zNy5GaW5hbGx5LFxuICAgICAgRm9ySW5TdGF0ZW1lbnQgPSAkX18zNy5Gb3JJblN0YXRlbWVudCxcbiAgICAgIEZvck9mU3RhdGVtZW50ID0gJF9fMzcuRm9yT2ZTdGF0ZW1lbnQsXG4gICAgICBGb3JPblN0YXRlbWVudCA9ICRfXzM3LkZvck9uU3RhdGVtZW50LFxuICAgICAgRm9yU3RhdGVtZW50ID0gJF9fMzcuRm9yU3RhdGVtZW50LFxuICAgICAgRm9ybWFsUGFyYW1ldGVyID0gJF9fMzcuRm9ybWFsUGFyYW1ldGVyLFxuICAgICAgRm9ybWFsUGFyYW1ldGVyTGlzdCA9ICRfXzM3LkZvcm1hbFBhcmFtZXRlckxpc3QsXG4gICAgICBGb3J3YXJkRGVmYXVsdEV4cG9ydCA9ICRfXzM3LkZvcndhcmREZWZhdWx0RXhwb3J0LFxuICAgICAgRnVuY3Rpb25Cb2R5ID0gJF9fMzcuRnVuY3Rpb25Cb2R5LFxuICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbiA9ICRfXzM3LkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb24gPSAkX18zNy5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBGdW5jdGlvblR5cGUgPSAkX18zNy5GdW5jdGlvblR5cGUsXG4gICAgICBHZW5lcmF0b3JDb21wcmVoZW5zaW9uID0gJF9fMzcuR2VuZXJhdG9yQ29tcHJlaGVuc2lvbixcbiAgICAgIEdldEFjY2Vzc29yID0gJF9fMzcuR2V0QWNjZXNzb3IsXG4gICAgICBJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzM3LklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgSWZTdGF0ZW1lbnQgPSAkX18zNy5JZlN0YXRlbWVudCxcbiAgICAgIEltcG9ydENsYXVzZVBhaXIgPSAkX18zNy5JbXBvcnRDbGF1c2VQYWlyLFxuICAgICAgSW1wb3J0RGVjbGFyYXRpb24gPSAkX18zNy5JbXBvcnREZWNsYXJhdGlvbixcbiAgICAgIEltcG9ydFNwZWNpZmllciA9ICRfXzM3LkltcG9ydFNwZWNpZmllcixcbiAgICAgIEltcG9ydFNwZWNpZmllclNldCA9ICRfXzM3LkltcG9ydFNwZWNpZmllclNldCxcbiAgICAgIEltcG9ydGVkQmluZGluZyA9ICRfXzM3LkltcG9ydGVkQmluZGluZyxcbiAgICAgIEltcG9ydFR5cGVDbGF1c2UgPSAkX18zNy5JbXBvcnRUeXBlQ2xhdXNlLFxuICAgICAgSW5kZXhTaWduYXR1cmUgPSAkX18zNy5JbmRleFNpZ25hdHVyZSxcbiAgICAgIEludGVyZmFjZURlY2xhcmF0aW9uID0gJF9fMzcuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICBKc3hBdHRyaWJ1dGUgPSAkX18zNy5Kc3hBdHRyaWJ1dGUsXG4gICAgICBKc3hFbGVtZW50ID0gJF9fMzcuSnN4RWxlbWVudCxcbiAgICAgIEpzeEVsZW1lbnROYW1lID0gJF9fMzcuSnN4RWxlbWVudE5hbWUsXG4gICAgICBKc3hQbGFjZWhvbGRlciA9ICRfXzM3LkpzeFBsYWNlaG9sZGVyLFxuICAgICAgSnN4U3ByZWFkQXR0cmlidXRlID0gJF9fMzcuSnN4U3ByZWFkQXR0cmlidXRlLFxuICAgICAgSnN4VGV4dCA9ICRfXzM3LkpzeFRleHQsXG4gICAgICBMYWJlbGxlZFN0YXRlbWVudCA9ICRfXzM3LkxhYmVsbGVkU3RhdGVtZW50LFxuICAgICAgTGl0ZXJhbEV4cHJlc3Npb24gPSAkX18zNy5MaXRlcmFsRXhwcmVzc2lvbixcbiAgICAgIExpdGVyYWxQcm9wZXJ0eU5hbWUgPSAkX18zNy5MaXRlcmFsUHJvcGVydHlOYW1lLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzM3Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICBNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fMzcuTWVtYmVyTG9va3VwRXhwcmVzc2lvbixcbiAgICAgIE1ldGhvZCA9ICRfXzM3Lk1ldGhvZCxcbiAgICAgIE1ldGhvZFNpZ25hdHVyZSA9ICRfXzM3Lk1ldGhvZFNpZ25hdHVyZSxcbiAgICAgIE1vZHVsZSA9ICRfXzM3Lk1vZHVsZSxcbiAgICAgIE1vZHVsZVNwZWNpZmllciA9ICRfXzM3Lk1vZHVsZVNwZWNpZmllcixcbiAgICAgIE5hbWVTcGFjZUV4cG9ydCA9ICRfXzM3Lk5hbWVTcGFjZUV4cG9ydCxcbiAgICAgIE5hbWVTcGFjZUltcG9ydCA9ICRfXzM3Lk5hbWVTcGFjZUltcG9ydCxcbiAgICAgIE5hbWVkRXhwb3J0ID0gJF9fMzcuTmFtZWRFeHBvcnQsXG4gICAgICBOZXdFeHByZXNzaW9uID0gJF9fMzcuTmV3RXhwcmVzc2lvbixcbiAgICAgIE9iamVjdExpdGVyYWwgPSAkX18zNy5PYmplY3RMaXRlcmFsLFxuICAgICAgT2JqZWN0UGF0dGVybiA9ICRfXzM3Lk9iamVjdFBhdHRlcm4sXG4gICAgICBPYmplY3RQYXR0ZXJuRmllbGQgPSAkX18zNy5PYmplY3RQYXR0ZXJuRmllbGQsXG4gICAgICBPYmplY3RUeXBlID0gJF9fMzcuT2JqZWN0VHlwZSxcbiAgICAgIFBhcmVuRXhwcmVzc2lvbiA9ICRfXzM3LlBhcmVuRXhwcmVzc2lvbixcbiAgICAgIFBvc3RmaXhFeHByZXNzaW9uID0gJF9fMzcuUG9zdGZpeEV4cHJlc3Npb24sXG4gICAgICBQcmVkZWZpbmVkVHlwZSA9ICRfXzM3LlByZWRlZmluZWRUeXBlLFxuICAgICAgUHJvcGVydHlOYW1lQXNzaWdubWVudCA9ICRfXzM3LlByb3BlcnR5TmFtZUFzc2lnbm1lbnQsXG4gICAgICBQcm9wZXJ0eU5hbWVTaG9ydGhhbmQgPSAkX18zNy5Qcm9wZXJ0eU5hbWVTaG9ydGhhbmQsXG4gICAgICBQcm9wZXJ0eVNpZ25hdHVyZSA9ICRfXzM3LlByb3BlcnR5U2lnbmF0dXJlLFxuICAgICAgUHJvcGVydHlWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fMzcuUHJvcGVydHlWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgUmVzdFBhcmFtZXRlciA9ICRfXzM3LlJlc3RQYXJhbWV0ZXIsXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQgPSAkX18zNy5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICBTY3JpcHQgPSAkX18zNy5TY3JpcHQsXG4gICAgICBTZXRBY2Nlc3NvciA9ICRfXzM3LlNldEFjY2Vzc29yLFxuICAgICAgU3ByZWFkRXhwcmVzc2lvbiA9ICRfXzM3LlNwcmVhZEV4cHJlc3Npb24sXG4gICAgICBTcHJlYWRQYXR0ZXJuRWxlbWVudCA9ICRfXzM3LlNwcmVhZFBhdHRlcm5FbGVtZW50LFxuICAgICAgU3VwZXJFeHByZXNzaW9uID0gJF9fMzcuU3VwZXJFeHByZXNzaW9uLFxuICAgICAgU3dpdGNoU3RhdGVtZW50ID0gJF9fMzcuU3dpdGNoU3RhdGVtZW50LFxuICAgICAgU3ludGF4RXJyb3JUcmVlID0gJF9fMzcuU3ludGF4RXJyb3JUcmVlLFxuICAgICAgVGVtcGxhdGVMaXRlcmFsRXhwcmVzc2lvbiA9ICRfXzM3LlRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uID0gJF9fMzcuVGVtcGxhdGVMaXRlcmFsUG9ydGlvbixcbiAgICAgIFRlbXBsYXRlU3Vic3RpdHV0aW9uID0gJF9fMzcuVGVtcGxhdGVTdWJzdGl0dXRpb24sXG4gICAgICBUaGlzRXhwcmVzc2lvbiA9ICRfXzM3LlRoaXNFeHByZXNzaW9uLFxuICAgICAgVGhyb3dTdGF0ZW1lbnQgPSAkX18zNy5UaHJvd1N0YXRlbWVudCxcbiAgICAgIFRyeVN0YXRlbWVudCA9ICRfXzM3LlRyeVN0YXRlbWVudCxcbiAgICAgIFR5cGVBbGlhc0RlY2xhcmF0aW9uID0gJF9fMzcuVHlwZUFsaWFzRGVjbGFyYXRpb24sXG4gICAgICBUeXBlQXJndW1lbnRzID0gJF9fMzcuVHlwZUFyZ3VtZW50cyxcbiAgICAgIFR5cGVOYW1lID0gJF9fMzcuVHlwZU5hbWUsXG4gICAgICBUeXBlUGFyYW1ldGVyID0gJF9fMzcuVHlwZVBhcmFtZXRlcixcbiAgICAgIFR5cGVQYXJhbWV0ZXJzID0gJF9fMzcuVHlwZVBhcmFtZXRlcnMsXG4gICAgICBUeXBlUmVmZXJlbmNlID0gJF9fMzcuVHlwZVJlZmVyZW5jZSxcbiAgICAgIFVuYXJ5RXhwcmVzc2lvbiA9ICRfXzM3LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgIFVuaW9uVHlwZSA9ICRfXzM3LlVuaW9uVHlwZSxcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAkX18zNy5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX18zNy5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIFZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMzcuVmFyaWFibGVTdGF0ZW1lbnQsXG4gICAgICBXaGlsZVN0YXRlbWVudCA9ICRfXzM3LldoaWxlU3RhdGVtZW50LFxuICAgICAgV2l0aFN0YXRlbWVudCA9ICRfXzM3LldpdGhTdGF0ZW1lbnQsXG4gICAgICBZaWVsZEV4cHJlc3Npb24gPSAkX18zNy5ZaWVsZEV4cHJlc3Npb247XG4gIHZhciBBTExPV19JTiA9IHRydWU7XG4gIHZhciBOT19JTiA9IGZhbHNlO1xuICB2YXIgSU5JVElBTElaRVJfUkVRVUlSRUQgPSB0cnVlO1xuICB2YXIgSU5JVElBTElaRVJfT1BUSU9OQUwgPSBmYWxzZTtcbiAgdmFyIFZhbGlkYXRlT2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVmFsaWRhdGVPYmplY3RMaXRlcmFsKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVmFsaWRhdGVPYmplY3RMaXRlcmFsKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5lcnJvclRva2VuID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhbGlkYXRlT2JqZWN0TGl0ZXJhbCwge3Zpc2l0Q292ZXJJbml0aWFsaXplZE5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5lcnJvclRva2VuID0gdHJlZS5lcXVhbFRva2VuO1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRWaXNpdG9yKTtcbiAgZnVuY3Rpb24gY29udGFpbnNJbml0aWFsaXplcihkZWNsYXJhdGlvbnMpIHtcbiAgICByZXR1cm4gZGVjbGFyYXRpb25zLnNvbWUoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYuaW5pdGlhbGl6ZXI7XG4gICAgfSk7XG4gIH1cbiAgdmFyIEZVTkNUSU9OX1NUQVRFX1NDUklQVCA9IDE7XG4gIHZhciBGVU5DVElPTl9TVEFURV9NT0RVTEUgPSAxIDw8IDE7XG4gIHZhciBGVU5DVElPTl9TVEFURV9GVU5DVElPTiA9IDEgPDwgMjtcbiAgdmFyIEZVTkNUSU9OX1NUQVRFX0FSUk9XID0gMSA8PCAzO1xuICB2YXIgRlVOQ1RJT05fU1RBVEVfTUVUSE9EID0gMSA8PCA0O1xuICB2YXIgRlVOQ1RJT05fU1RBVEVfREVSSVZFRF9DT05TVFJVQ1RPUiA9IDEgPDwgNTtcbiAgdmFyIEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUiA9IDEgPDwgNjtcbiAgdmFyIEZVTkNUSU9OX1NUQVRFX0FTWU5DID0gMSA8PCA3O1xuICB2YXIgRlVOQ1RJT05fU1RBVEVfTEVOSUVOVCA9IEZVTkNUSU9OX1NUQVRFX01FVEhPRCB8IEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUiB8IEZVTkNUSU9OX1NUQVRFX0FTWU5DIHwgRlVOQ1RJT05fU1RBVEVfREVSSVZFRF9DT05TVFJVQ1RPUjtcbiAgdmFyIEZ1bmN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBGdW5jdGlvblN0YXRlKG91dGVyLCBraW5kKSB7XG4gICAgICB0aGlzLm91dGVyID0gb3V0ZXI7XG4gICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRnVuY3Rpb25TdGF0ZSwge1xuICAgICAgaXNUb3BNb3N0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZCAmIChGVU5DVElPTl9TVEFURV9TQ1JJUFQgfCBGVU5DVElPTl9TVEFURV9NT0RVTEUpO1xuICAgICAgfSxcbiAgICAgIGlzTWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZCAmIEZVTkNUSU9OX1NUQVRFX01FVEhPRDtcbiAgICAgIH0sXG4gICAgICBpc0Rlcml2ZWRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQgJiBGVU5DVElPTl9TVEFURV9ERVJJVkVEX0NPTlNUUlVDVE9SO1xuICAgICAgfSxcbiAgICAgIGlzQXJyb3dGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQgJiBGVU5DVElPTl9TVEFURV9BUlJPVztcbiAgICAgIH0sXG4gICAgICBpc0dlbmVyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQgJiBGVU5DVElPTl9TVEFURV9HRU5FUkFUT1I7XG4gICAgICB9LFxuICAgICAgaXNBc3luY0Z1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2luZCAmIEZVTkNUSU9OX1NUQVRFX0FTWU5DO1xuICAgICAgfSxcbiAgICAgIGlzQXN5bmNHZW5lcmF0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0dlbmVyYXRvcigpICYmIHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIoZmlsZSkge1xuICAgICAgdmFyIGVycm9yUmVwb3J0ZXIgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogbmV3IFN5bnRheEVycm9yUmVwb3J0ZXIoKTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1syXSA6IG5ldyBPcHRpb25zKCk7XG4gICAgICB0aGlzLmVycm9yUmVwb3J0ZXJfID0gZXJyb3JSZXBvcnRlcjtcbiAgICAgIGluaXRTY2FubmVyKGVycm9yUmVwb3J0ZXIsIGZpbGUsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zXyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmNvdmVySW5pdGlhbGl6ZWROYW1lQ291bnRfID0gMDtcbiAgICAgIHRoaXMuc3RyaWN0TW9kZV8gPSBmYWxzZTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG4gICAgICB0aGlzLmZ1bmN0aW9uU3RhdGVfID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFBhcnNlciwge1xuICAgICAgZ2V0IGFsbG93WWllbGRfKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvblN0YXRlXy5pc0dlbmVyYXRvcigpO1xuICAgICAgfSxcbiAgICAgIGdldCBhbGxvd0F3YWl0XygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25TdGF0ZV8uaXNBc3luY0Z1bmN0aW9uKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGFsbG93Rm9yT25fKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvblN0YXRlXy5pc0FzeW5jRnVuY3Rpb24oKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVNjcmlwdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RyaWN0TW9kZV8gPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGZzID0gdGhpcy5wdXNoRnVuY3Rpb25TdGF0ZV8oRlVOQ1RJT05fU1RBVEVfU0NSSVBUKTtcbiAgICAgICAgdmFyIHNjcmlwdEl0ZW1MaXN0ID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RfKHRydWUpO1xuICAgICAgICB0aGlzLmVhdF8oRU5EX09GX0ZJTEUpO1xuICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY3JpcHQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgc2NyaXB0SXRlbUxpc3QsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHB1c2hGdW5jdGlvblN0YXRlXzogZnVuY3Rpb24oa2luZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvblN0YXRlXyA9IG5ldyBGdW5jdGlvblN0YXRlKHRoaXMuZnVuY3Rpb25TdGF0ZV8sIGtpbmQpO1xuICAgICAgfSxcbiAgICAgIHBvcEZ1bmN0aW9uU3RhdGVfOiBmdW5jdGlvbihmcykge1xuICAgICAgICBpZiAoZnMgIT0gdGhpcy5mdW5jdGlvblN0YXRlXykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZ1bmN0aW9uU3RhdGVfID0gdGhpcy5mdW5jdGlvblN0YXRlXy5vdXRlcjtcbiAgICAgIH0sXG4gICAgICBwYXJzZVN0YXRlbWVudExpc3RfOiBmdW5jdGlvbihjaGVja1VzZVN0cmljdERpcmVjdGl2ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB3aGlsZSAoKHR5cGUgPSBwZWVrVHlwZSgpKSAhPT0gQ0xPU0VfQ1VSTFkgJiYgdHlwZSAhPT0gRU5EX09GX0ZJTEUpIHtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtXyh0eXBlKTtcbiAgICAgICAgICBpZiAoY2hlY2tVc2VTdHJpY3REaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGVtZW50LmlzRGlyZWN0aXZlUHJvbG9ndWUoKSkge1xuICAgICAgICAgICAgICBjaGVja1VzZVN0cmljdERpcmVjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZW1lbnQuaXNVc2VTdHJpY3REaXJlY3RpdmUoKSkge1xuICAgICAgICAgICAgICB0aGlzLnN0cmljdE1vZGVfID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hlY2tVc2VTdHJpY3REaXJlY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHBhcnNlU3RhdGVtZW50TGlzdEl0ZW1fOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgTEVUOlxuICAgICAgICAgIGNhc2UgQ09OU1Q6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5ibG9ja0JpbmRpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudF8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQ0xBU1M6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5jbGFzc2VzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3NEZWNsYXJhdGlvbl8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRlVOQ1RJT046XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb25fKCk7XG4gICAgICAgICAgY2FzZSBJREVOVElGSUVSOlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18udHlwZXMgJiYgdGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oVFlQRSkgJiYgcGVla0xvb2thaGVhZChJREVOVElGSUVSKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRXaXRoVHlwZV8odHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VNb2R1bGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhGVU5DVElPTl9TVEFURV9NT0RVTEUpO1xuICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0aGlzLnBhcnNlTW9kdWxlSXRlbUxpc3RfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhFTkRfT0ZfRklMRSk7XG4gICAgICAgIHRoaXMucG9wRnVuY3Rpb25TdGF0ZV8oZnMpO1xuICAgICAgICByZXR1cm4gbmV3IE1vZHVsZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBzY3JpcHRJdGVtTGlzdCwgbnVsbCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VNb2R1bGVJdGVtTGlzdF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0cmljdE1vZGVfID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgd2hpbGUgKCh0eXBlID0gcGVla1R5cGUoKSkgIT09IEVORF9PRl9GSUxFKSB7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMucGFyc2VNb2R1bGVJdGVtXyh0eXBlKTtcbiAgICAgICAgICByZXN1bHQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcGFyc2VNb2R1bGVJdGVtXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIElNUE9SVDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0RGVjbGFyYXRpb25fKCk7XG4gICAgICAgICAgY2FzZSBFWFBPUlQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uXygpO1xuICAgICAgICAgIGNhc2UgQVQ6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBbm5vdGF0ZWREZWNsYXJhdGlvbnNfKHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbV8odHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VNb2R1bGVTcGVjaWZpZXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcy5lYXRfKFNUUklORyk7XG4gICAgICAgIHJldHVybiBuZXcgTW9kdWxlU3BlY2lmaWVyKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZU5hbWVTcGFjZUltcG9ydF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oU1RBUik7XG4gICAgICAgIHRoaXMuZWF0SWRfKEFTKTtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLnBhcnNlSW1wb3J0ZWRCaW5kaW5nXygpO1xuICAgICAgICByZXR1cm4gbmV3IE5hbWVTcGFjZUltcG9ydCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBiaW5kaW5nKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUltcG9ydERlY2xhcmF0aW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhJTVBPUlQpO1xuICAgICAgICB2YXIgaW1wb3J0Q2xhdXNlID0gbnVsbDtcbiAgICAgICAgaWYgKCFwZWVrKFNUUklORykpIHtcbiAgICAgICAgICBpbXBvcnRDbGF1c2UgPSB0aGlzLnBhcnNlSW1wb3J0Q2xhdXNlXyh0cnVlLCB0aGlzLm9wdGlvbnNfLnR5cGVzKTtcbiAgICAgICAgICB0aGlzLmVhdElkXyhGUk9NKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcl8oKTtcbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IEltcG9ydERlY2xhcmF0aW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGltcG9ydENsYXVzZSwgbW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUltcG9ydENsYXVzZV86IGZ1bmN0aW9uKGFsbG93SW1wb3J0ZWREZWZhdWx0QmluZGluZywgYWxsb3dUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgIGNhc2UgU1RBUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTmFtZVNwYWNlSW1wb3J0XygpO1xuICAgICAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyU2V0XygpO1xuICAgICAgICAgIGNhc2UgSURFTlRJRklFUjpcbiAgICAgICAgICAgIGlmIChhbGxvd1R5cGUgJiYgdGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oVFlQRSkpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgICAgICAgdmFyIHQgPSBwZWVrVG9rZW5Mb29rYWhlYWQoKTtcbiAgICAgICAgICAgICAgaWYgKHQudHlwZSA9PT0gT1BFTl9DVVJMWSB8fCB0LnR5cGUgPT09IElERU5USUZJRVIgJiYgdC52YWx1ZSAhPT0gRlJPTSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWF0SWRfKFRZUEUpO1xuICAgICAgICAgICAgICAgIHZhciBjbGF1c2UgPSB0aGlzLnBhcnNlSW1wb3J0Q2xhdXNlXyhhbGxvd0ltcG9ydGVkRGVmYXVsdEJpbmRpbmcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltcG9ydFR5cGVDbGF1c2UodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgY2xhdXNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93SW1wb3J0ZWREZWZhdWx0QmluZGluZykge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQkX180ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgICAgICAgdmFyIGltcG9ydGVkQmluZGluZyA9IHRoaXMucGFyc2VJbXBvcnRlZEJpbmRpbmdfKCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmVhdElmXyhDT01NQSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy5wYXJzZUltcG9ydENsYXVzZV8oZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltcG9ydENsYXVzZVBhaXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0JF9fNCksIGltcG9ydGVkQmluZGluZywgc2Vjb25kKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0ZWRCaW5kaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmV4cGVjdGVkVG9rZW5fKCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VJbXBvcnRTcGVjaWZpZXJTZXRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB3aGlsZSAoIXBlZWsoQ0xPU0VfQ1VSTFkpICYmICFpc0F0RW5kKCkpIHtcbiAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcl8oKSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmVhdElmXyhDT01NQSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfQ1VSTFkpO1xuICAgICAgICByZXR1cm4gbmV3IEltcG9ydFNwZWNpZmllclNldCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBzcGVjaWZpZXJzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUltcG9ydGVkQmluZGluZ186IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRlZEJpbmRpbmcodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VJbXBvcnRTcGVjaWZpZXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHRva2VuID0gcGVla1Rva2VuKCk7XG4gICAgICAgIHZhciBpc0tleXdvcmQgPSB0b2tlbi5pc0tleXdvcmQoKTtcbiAgICAgICAgdmFyIGJpbmRpbmc7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5lYXRJZE5hbWVfKCk7XG4gICAgICAgIGlmIChpc0tleXdvcmQgfHwgdGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oQVMpKSB7XG4gICAgICAgICAgdGhpcy5lYXRJZF8oQVMpO1xuICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnBhcnNlSW1wb3J0ZWRCaW5kaW5nXygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJpbmRpbmcgPSBuZXcgSW1wb3J0ZWRCaW5kaW5nKG5hbWUubG9jYXRpb24sIG5ldyBCaW5kaW5nSWRlbnRpZmllcihuYW1lLmxvY2F0aW9uLCBuYW1lKSk7XG4gICAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRTcGVjaWZpZXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgYmluZGluZywgbmFtZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oRVhQT1JUKTtcbiAgICAgICAgdmFyIGV4cG9ydFRyZWU7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMucG9wQW5ub3RhdGlvbnNfKCk7XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBDT05TVDpcbiAgICAgICAgICBjYXNlIExFVDpcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmJsb2NrQmluZGluZykge1xuICAgICAgICAgICAgICBleHBvcnRUcmVlID0gdGhpcy5wYXJzZVZhcmlhYmxlU3RhdGVtZW50XygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5leHBlY3RlZFRva2VuXygpO1xuICAgICAgICAgIGNhc2UgVkFSOlxuICAgICAgICAgICAgZXhwb3J0VHJlZSA9IHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudF8oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRlVOQ1RJT046XG4gICAgICAgICAgICBleHBvcnRUcmVlID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb25fKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIENMQVNTOlxuICAgICAgICAgICAgZXhwb3J0VHJlZSA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uXygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBERUZBVUxUOlxuICAgICAgICAgICAgZXhwb3J0VHJlZSA9IHRoaXMucGFyc2VFeHBvcnREZWZhdWx0XygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgIGNhc2UgU1RBUjpcbiAgICAgICAgICAgIGV4cG9ydFRyZWUgPSB0aGlzLnBhcnNlTmFtZWRFeHBvcnRfKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIElERU5USUZJRVI6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5hc3luY0Z1bmN0aW9ucyAmJiB0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhBU1lOQykpIHtcbiAgICAgICAgICAgICAgdmFyIGFzeW5jVG9rZW4gPSB0aGlzLmVhdElkXygpO1xuICAgICAgICAgICAgICBleHBvcnRUcmVlID0gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbl8oYXN5bmNUb2tlbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18udHlwZXMgJiYgdGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oVFlQRSkgJiYgcGVla0xvb2thaGVhZChJREVOVElGSUVSKSkge1xuICAgICAgICAgICAgICBleHBvcnRUcmVlID0gdGhpcy5wYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uXygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnNfLmV4cG9ydEZyb21FeHRlbmRlZCkge1xuICAgICAgICAgICAgICBleHBvcnRUcmVlID0gdGhpcy5wYXJzZU5hbWVkRXhwb3J0XygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmV4cGVjdGVkVG9rZW5fKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwZWVrVG9rZW4oKTtcbiAgICAgICAgICAgICAgaWYgKCF0b2tlbi5pc0tleXdvcmQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5leHBlY3RlZFRva2VuXygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cG9ydFRyZWUgPSB0aGlzLnBhcnNlTmFtZWRFeHBvcnRfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHBvcnREZWNsYXJhdGlvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHBvcnRUcmVlLCBhbm5vdGF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VFeHBvcnREZWZhdWx0XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBkZWZhdWx0VG9rZW4gPSB0aGlzLmVhdF8oREVGQVVMVCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmV4cG9ydEZyb21FeHRlbmRlZCAmJiB0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhGUk9NKSkge1xuICAgICAgICAgIHZhciBpZE5hbWUgPSBuZXcgSWRlbnRpZmllclRva2VuKGRlZmF1bHRUb2tlbi5sb2NhdGlvbiwgREVGQVVMVCk7XG4gICAgICAgICAgdmFyIG5hbWVkRXhwb3J0ID0gbmV3IEZvcndhcmREZWZhdWx0RXhwb3J0KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGlkTmFtZSk7XG4gICAgICAgICAgdGhpcy5lYXRJZF8oRlJPTSk7XG4gICAgICAgICAgdmFyIG1vZHVsZVNwZWNpZmllciA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXJfKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOYW1lZEV4cG9ydCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBuYW1lZEV4cG9ydCwgbW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwb3J0VmFsdWU7XG4gICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgIGNhc2UgRlVOQ1RJT046XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciB0cmVlID0gdGhpcy5wYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICAgICAgaWYgKHRyZWUubmFtZSkge1xuICAgICAgICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIHRyZWUudHlwZUFubm90YXRpb24sIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwb3J0VmFsdWUgPSB0cmVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENMQVNTOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uc18uY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3ludGF4RXJyb3JfKCdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdHJlZSRfXzUgPSB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uXygpO1xuICAgICAgICAgICAgICBpZiAodHJlZSRfXzUubmFtZSkge1xuICAgICAgICAgICAgICAgIHRyZWUkX181ID0gbmV3IENsYXNzRGVjbGFyYXRpb24odHJlZSRfXzUubG9jYXRpb24sIHRyZWUkX181Lm5hbWUsIHRyZWUkX181LnN1cGVyQ2xhc3MsIHRyZWUkX181LmVsZW1lbnRzLCB0cmVlJF9fNS5hbm5vdGF0aW9ucywgdHJlZSRfXzUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlID0gdHJlZSRfXzU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBleHBvcnRWYWx1ZSA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXhwb3J0RGVmYXVsdCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHBvcnRWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VOYW1lZEV4cG9ydF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgZXhwb3J0Q2xhdXNlLFxuICAgICAgICAgICAgbW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgZXhwb3J0Q2xhdXNlID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllclNldF8oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhGUk9NKSkge1xuICAgICAgICAgICAgICB0aGlzLmVhdElkXyhGUk9NKTtcbiAgICAgICAgICAgICAgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcl8oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVFeHBvcnRTcGVjaWZpZXJTZXRfKGV4cG9ydENsYXVzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNUQVI6XG4gICAgICAgICAgICBleHBvcnRDbGF1c2UgPSB0aGlzLnBhcnNlRXhwb3J0U3Rhcl8oKTtcbiAgICAgICAgICAgIHRoaXMuZWF0SWRfKEZST00pO1xuICAgICAgICAgICAgbW9kdWxlU3BlY2lmaWVyID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcl8oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBleHBvcnRDbGF1c2UgPSB0aGlzLnBhcnNlRm9yd2FyZERlZmF1bHRFeHBvcnRfKCk7XG4gICAgICAgICAgICB0aGlzLmVhdElkXyhGUk9NKTtcbiAgICAgICAgICAgIG1vZHVsZVNwZWNpZmllciA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXJfKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdFBvc3NpYmxlSW1wbGljaXRTZW1pQ29sb25fKCk7XG4gICAgICAgIHJldHVybiBuZXcgTmFtZWRFeHBvcnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZXhwb3J0Q2xhdXNlLCBtb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRXhwb3J0U3Rhcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oU1RBUik7XG4gICAgICAgIGlmICh0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhBUykpIHtcbiAgICAgICAgICB0aGlzLmVhdElkXyhBUyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmVhdElkTmFtZV8oKTtcbiAgICAgICAgICByZXR1cm4gbmV3IE5hbWVTcGFjZUV4cG9ydCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cG9ydFN0YXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VFeHBvcnRTcGVjaWZpZXJTZXRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFt0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyXygpXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0SWZfKENPTU1BKSkge1xuICAgICAgICAgIGlmIChwZWVrKENMT1NFX0NVUkxZKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyXygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfQ1VSTFkpO1xuICAgICAgICByZXR1cm4gbmV3IEV4cG9ydFNwZWNpZmllclNldCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBzcGVjaWZpZXJzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUV4cG9ydFNwZWNpZmllcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgbGhzID0gdGhpcy5lYXRJZE5hbWVfKCk7XG4gICAgICAgIHZhciByaHMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oQVMpKSB7XG4gICAgICAgICAgdGhpcy5lYXRJZF8oKTtcbiAgICAgICAgICByaHMgPSB0aGlzLmVhdElkTmFtZV8oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4cG9ydFNwZWNpZmllcih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBsaHMsIHJocyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VGb3J3YXJkRGVmYXVsdEV4cG9ydF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgaWROYW1lID0gdGhpcy5lYXRJZE5hbWVfKCk7XG4gICAgICAgIHJldHVybiBuZXcgRm9yd2FyZERlZmF1bHRFeHBvcnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaWROYW1lKTtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZUV4cG9ydFNwZWNpZmllclNldF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLnNwZWNpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3BlY2lmaWVyID0gdHJlZS5zcGVjaWZpZXJzW2ldO1xuICAgICAgICAgIGlmIChnZXRLZXl3b3JkVHlwZShzcGVjaWZpZXIubGhzLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8oc3BlY2lmaWVyLmxocy5sb2NhdGlvbiwgKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIHNwZWNpZmllci5saHMudmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwZWVrSWRfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBJREVOVElGSUVSKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdHJpY3RNb2RlXylcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBwZWVrVG9rZW4oKS5pc1N0cmljdEtleXdvcmQoKTtcbiAgICAgIH0sXG4gICAgICBwZWVrSWROYW1lXzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IElERU5USUZJRVIgfHwgdG9rZW4uaXNLZXl3b3JkKCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VDbGFzc1NoYXJlZF86IGZ1bmN0aW9uKGNvbnN0cikge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgc3RyaWN0TW9kZSA9IHRoaXMuc3RyaWN0TW9kZV87XG4gICAgICAgIHRoaXMuc3RyaWN0TW9kZV8gPSB0cnVlO1xuICAgICAgICB0aGlzLmVhdF8oQ0xBU1MpO1xuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoY29uc3RyID09PSBDbGFzc0RlY2xhcmF0aW9uIHx8ICFwZWVrKEVYVEVORFMpICYmICFwZWVrKE9QRU5fQ1VSTFkpKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy50eXBlcykge1xuICAgICAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlVHlwZVBhcmFtZXRlcnNPcHRfKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFubm90YXRpb25zID0gdGhpcy5wb3BBbm5vdGF0aW9uc18oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmVhdElmXyhFWFRFTkRTKSkge1xuICAgICAgICAgIHN1cGVyQ2xhc3MgPSB0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5jb3ZlckZvcm1hbHNUb1BhcmVuRXhwcmVzc2lvbl8oc3VwZXJDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50c18oc3VwZXJDbGFzcyk7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9DVVJMWSk7XG4gICAgICAgIHRoaXMuc3RyaWN0TW9kZV8gPSBzdHJpY3RNb2RlO1xuICAgICAgICByZXR1cm4gbmV3IGNvbnN0cih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBuYW1lLCBzdXBlckNsYXNzLCBlbGVtZW50cywgYW5ub3RhdGlvbnMsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNsYXNzRGVjbGFyYXRpb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzc1NoYXJlZF8oQ2xhc3NEZWNsYXJhdGlvbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VDbGFzc0V4cHJlc3Npb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzc1NoYXJlZF8oQ2xhc3NFeHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNsYXNzRWxlbWVudHNfOiBmdW5jdGlvbihkZXJpdmVkQ2xhc3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gU0VNSV9DT0xPTikge1xuICAgICAgICAgICAgbmV4dFRva2VuKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBlZWtDbGFzc0VsZW1lbnRfKHBlZWtUeXBlKCkpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBhcnNlQ2xhc3NFbGVtZW50XyhkZXJpdmVkQ2xhc3MpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcGVla0NsYXNzRWxlbWVudF86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVla1Byb3BlcnR5TmFtZV8odHlwZSkgfHwgdHlwZSA9PT0gU1RBUiAmJiB0aGlzLm9wdGlvbnNfLmdlbmVyYXRvcnMgfHwgdHlwZSA9PT0gQVQgJiYgdGhpcy5vcHRpb25zXy5hbm5vdGF0aW9ucztcbiAgICAgIH0sXG4gICAgICBwYXJzZVByb3BlcnR5TmFtZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocGVlayhPUEVOX1NRVUFSRSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21wdXRlZFByb3BlcnR5TmFtZV8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsUHJvcGVydHlOYW1lXygpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGl0ZXJhbFByb3BlcnR5TmFtZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJvcGVydHlOYW1lKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNvbXB1dGVkUHJvcGVydHlOYW1lXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1NRVUFSRSk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9TUVVBUkUpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXB1dGVkUHJvcGVydHlOYW1lKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlU3RhdGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZzID0gdGhpcy5wdXNoRnVuY3Rpb25TdGF0ZV8oRlVOQ1RJT05fU1RBVEVfTEVOSUVOVCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTW9kdWxlSXRlbV8ocGVla1R5cGUoKSk7XG4gICAgICAgIHRoaXMucG9wRnVuY3Rpb25TdGF0ZV8oZnMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHBhcnNlU3RhdGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKEZVTkNUSU9OX1NUQVRFX0xFTklFTlQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZU1vZHVsZUl0ZW1MaXN0XygpO1xuICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBwYXJzZVN0YXRlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudFdpdGhUeXBlXyhwZWVrVHlwZSgpKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVN0YXRlbWVudFdpdGhUeXBlXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFVFVSTjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50XygpO1xuICAgICAgICAgIGNhc2UgVkFSOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudF8oKTtcbiAgICAgICAgICBjYXNlIElGOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudF8oKTtcbiAgICAgICAgICBjYXNlIEZPUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50XygpO1xuICAgICAgICAgIGNhc2UgQlJFQUs6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrU3RhdGVtZW50XygpO1xuICAgICAgICAgIGNhc2UgU1dJVENIOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBUSFJPVzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBXSElMRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBBVDpcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFubm90YXRpb25zKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFubm90YXRlZERlY2xhcmF0aW9uc18oZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBDT05USU5VRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29udGludWVTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBERUJVR0dFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBETzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudF8oKTtcbiAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrXygpO1xuICAgICAgICAgIGNhc2UgU0VNSV9DT0xPTjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBUUlk6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudF8oKTtcbiAgICAgICAgICBjYXNlIFdJVEg6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnRfKCk7XG4gICAgICAgICAgY2FzZSBJTlRFUkZBQ0U6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy50eXBlcykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUludGVyZmFjZURlY2xhcmF0aW9uXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRmFsbFRocm91Z2hTdGF0ZW1lbnRfKCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25fKEZ1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25fKEZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb25fOiBmdW5jdGlvbihhc3luY1Rva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNGdW5jdGlvbl8oYXN5bmNUb2tlbiwgRnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbl86IGZ1bmN0aW9uKGFzeW5jVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3luY0Z1bmN0aW9uXyhhc3luY1Rva2VuLCBGdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHBlZWtBc3luY1N0YXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc18uYXN5bmNHZW5lcmF0b3JzICYmIHBlZWsoU1RBUik7XG4gICAgICB9LFxuICAgICAgcGFyc2VBc3luY0Z1bmN0aW9uXzogZnVuY3Rpb24oYXN5bmNUb2tlbiwgY3Rvcikge1xuICAgICAgICB2YXIgc3RhcnQgPSBhc3luY1Rva2VuLmxvY2F0aW9uLnN0YXJ0O1xuICAgICAgICB0aGlzLmVhdF8oRlVOQ1RJT04pO1xuICAgICAgICB2YXIga2luZCA9IEZVTkNUSU9OX1NUQVRFX0ZVTkNUSU9OIHwgRlVOQ1RJT05fU1RBVEVfQVNZTkM7XG4gICAgICAgIGlmICh0aGlzLnBlZWtBc3luY1N0YXJfKCkpIHtcbiAgICAgICAgICBraW5kIHw9IEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUjtcbiAgICAgICAgICB0aGlzLmVhdF8oU1RBUik7XG4gICAgICAgICAgYXN5bmNUb2tlbiA9IG5ldyBJZGVudGlmaWVyVG9rZW4oYXN5bmNUb2tlbi5sb2NhdGlvbiwgQVNZTkNfU1RBUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZzID0gdGhpcy5wdXNoRnVuY3Rpb25TdGF0ZV8oa2luZCk7XG4gICAgICAgIHZhciBmID0gdGhpcy5wYXJzZUZ1bmN0aW9uMl8oc3RhcnQsIGFzeW5jVG9rZW4sIGN0b3IpO1xuICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgcGFyc2VGdW5jdGlvbl86IGZ1bmN0aW9uKGN0b3IpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKEZVTkNUSU9OKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uS2luZCA9IG51bGw7XG4gICAgICAgIHZhciBraW5kID0gRlVOQ1RJT05fU1RBVEVfRlVOQ1RJT047XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmdlbmVyYXRvcnMgJiYgcGVlayhTVEFSKSkge1xuICAgICAgICAgIGZ1bmN0aW9uS2luZCA9IHRoaXMuZWF0XyhTVEFSKTtcbiAgICAgICAgICBraW5kIHw9IEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhraW5kKTtcbiAgICAgICAgdmFyIGYgPSB0aGlzLnBhcnNlRnVuY3Rpb24yXyhzdGFydCwgZnVuY3Rpb25LaW5kLCBjdG9yKTtcbiAgICAgICAgdGhpcy5wb3BGdW5jdGlvblN0YXRlXyhmcyk7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRnVuY3Rpb24yXzogZnVuY3Rpb24oc3RhcnQsIGZ1bmN0aW9uS2luZCwgY3Rvcikge1xuICAgICAgICB2YXIgbmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoY3RvciA9PT0gRnVuY3Rpb25EZWNsYXJhdGlvbiB8fCB0aGlzLnBlZWtCaW5kaW5nSWRlbnRpZmllcl8ocGVla1R5cGUoKSkpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyXygpO1xuICAgICAgICAgIGFubm90YXRpb25zID0gdGhpcy5wb3BBbm5vdGF0aW9uc18oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnNfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5XyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5hbWUsIGZ1bmN0aW9uS2luZCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICBwZWVrUmVzdF86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IERPVF9ET1RfRE9UICYmIHRoaXMub3B0aW9uc18ucmVzdFBhcmFtZXRlcnM7XG4gICAgICB9LFxuICAgICAgcGFyc2VGb3JtYWxQYXJhbWV0ZXJzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBmb3JtYWxzID0gW107XG4gICAgICAgIHRoaXMucHVzaEFubm90YXRpb25zXygpO1xuICAgICAgICB2YXIgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgIGlmICh0aGlzLnBlZWtSZXN0Xyh0eXBlKSkge1xuICAgICAgICAgIGZvcm1hbHMucHVzaCh0aGlzLnBhcnNlRm9ybWFsUmVzdFBhcmFtZXRlcl8oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMucGVla0Zvcm1hbFBhcmFtZXRlcl8ocGVla1R5cGUoKSkpXG4gICAgICAgICAgICBmb3JtYWxzLnB1c2godGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcl8oSU5JVElBTElaRVJfT1BUSU9OQUwpKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oQ09NTUEpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBbm5vdGF0aW9uc18oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWtSZXN0XyhwZWVrVHlwZSgpKSkge1xuICAgICAgICAgICAgICBmb3JtYWxzLnB1c2godGhpcy5wYXJzZUZvcm1hbFJlc3RQYXJhbWV0ZXJfKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcm1hbHMucHVzaCh0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyXyhJTklUSUFMSVpFUl9PUFRJT05BTCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hbFBhcmFtZXRlckxpc3QodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZm9ybWFscyk7XG4gICAgICB9LFxuICAgICAgcGVla0Zvcm1hbFBhcmFtZXRlcl86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVla0JpbmRpbmdFbGVtZW50Xyh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZvcm1hbFBhcmFtZXRlcl86IGZ1bmN0aW9uKGluaXRpYWxpemVyQWxsb3dlZCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMucGFyc2VCaW5kaW5nRWxlbWVudEJpbmRpbmdfKCk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy5wYXJzZUJpbmRpbmdFbGVtZW50SW5pdGlhbGl6ZXJfKGluaXRpYWxpemVyQWxsb3dlZCk7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWFsUGFyYW1ldGVyKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5ldyBCaW5kaW5nRWxlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBiaW5kaW5nLCBpbml0aWFsaXplciksIHR5cGVBbm5vdGF0aW9uLCB0aGlzLnBvcEFubm90YXRpb25zXygpKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZvcm1hbFJlc3RQYXJhbWV0ZXJfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHJlc3RQYXJhbWV0ZXIgPSB0aGlzLnBhcnNlUmVzdFBhcmFtZXRlcl8oKTtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5wYXJzZVR5cGVBbm5vdGF0aW9uT3B0XygpO1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hbFBhcmFtZXRlcih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCByZXN0UGFyYW1ldGVyLCB0eXBlQW5ub3RhdGlvbiwgdGhpcy5wb3BBbm5vdGF0aW9uc18oKSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VSZXN0UGFyYW1ldGVyXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhET1RfRE9UX0RPVCk7XG4gICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5wYXJzZVR5cGVBbm5vdGF0aW9uT3B0XygpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3RQYXJhbWV0ZXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaWQsIHR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZ1bmN0aW9uQm9keV86IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9DVVJMWSk7XG4gICAgICAgIHZhciBzdHJpY3RNb2RlID0gdGhpcy5zdHJpY3RNb2RlXztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0Xyghc3RyaWN0TW9kZSk7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycyhwYXJhbXMsIHRoaXMuc3RyaWN0TW9kZV8sIHRoaXMuZXJyb3JSZXBvcnRlcl8pO1xuICAgICAgICB0aGlzLnN0cmljdE1vZGVfID0gc3RyaWN0TW9kZTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX0NVUkxZKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJvZHkodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVNwcmVhZEV4cHJlc3Npb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKERPVF9ET1RfRE9UKTtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJlYWRFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG9wZXJhbmQpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQmxvY2tfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RfKGZhbHNlKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX0NVUkxZKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVmFyaWFibGVTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdF8oQUxMT1dfSU4sIElOSVRJQUxJWkVSX1JFUVVJUkVEKTtcbiAgICAgICAgdGhpcy5jaGVja0luaXRpYWxpemVyc18oZGVjbGFyYXRpb25zKTtcbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGRlY2xhcmF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdF86IGZ1bmN0aW9uKGFsbG93SW4sIGluaXRpYWxpemVyUmVxdWlyZWQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIENPTlNUOlxuICAgICAgICAgIGNhc2UgTEVUOlxuICAgICAgICAgIGNhc2UgVkFSOlxuICAgICAgICAgICAgbmV4dFRva2VuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCh0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbl8odHlwZSwgYWxsb3dJbiwgaW5pdGlhbGl6ZXJSZXF1aXJlZCkpO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oQ09NTUEpKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25fKHR5cGUsIGFsbG93SW4sIGluaXRpYWxpemVyUmVxdWlyZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHR5cGUsIGRlY2xhcmF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uXzogZnVuY3Rpb24oYmluZGluZywgbm9JbiwgaW5pdGlhbGl6ZXJSZXF1aXJlZCkge1xuICAgICAgICB2YXIgaW5pdFJlcXVpcmVkID0gaW5pdGlhbGl6ZXJSZXF1aXJlZCAhPT0gSU5JVElBTElaRVJfT1BUSU9OQUw7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBsdmFsdWU7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMucGVla1BhdHRlcm5fKHBlZWtUeXBlKCkpKSB7XG4gICAgICAgICAgbHZhbHVlID0gdGhpcy5wYXJzZUJpbmRpbmdQYXR0ZXJuXygpO1xuICAgICAgICAgIHR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsdmFsdWUgPSB0aGlzLnBhcnNlQmluZGluZ0lkZW50aWZpZXJfKCk7XG4gICAgICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLnBhcnNlVHlwZUFubm90YXRpb25PcHRfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXQgPSBudWxsO1xuICAgICAgICBpZiAocGVlayhFUVVBTCkpIHtcbiAgICAgICAgICBpbml0ID0gdGhpcy5wYXJzZUluaXRpYWxpemVyXyhub0luKTtcbiAgICAgICAgfSBlbHNlIGlmIChsdmFsdWUuaXNQYXR0ZXJuKCkgJiYgaW5pdFJlcXVpcmVkKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8obHZhbHVlLmxvY2F0aW9uLCAnZGVzdHJ1Y3R1cmluZyBtdXN0IGhhdmUgYW4gaW5pdGlhbGl6ZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbHZhbHVlLCB0eXBlQW5ub3RhdGlvbiwgaW5pdCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VJbml0aWFsaXplcl86IGZ1bmN0aW9uKGFsbG93SW4pIHtcbiAgICAgICAgdGhpcy5lYXRfKEVRVUFMKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbl8oYWxsb3dJbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VJbml0aWFsaXplck9wdF86IGZ1bmN0aW9uKGFsbG93SW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0SWZfKEVRVUFMKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhhbGxvd0luKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgcGFyc2VFbXB0eVN0YXRlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oU0VNSV9DT0xPTik7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlTdGF0ZW1lbnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VGYWxsVGhyb3VnaFN0YXRlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmV4cGVjdGVkVG9rZW5fKCk7XG4gICAgICAgICAgY2FzZSBGVU5DVElPTjpcbiAgICAgICAgICBjYXNlIENMQVNTOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkXyhwZWVrVG9rZW4oKSk7XG4gICAgICAgICAgY2FzZSBMRVQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IHBlZWtMb29rYWhlYWQoT1BFTl9TUVVBUkUpO1xuICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN5bnRheEVycm9yXyhcIkEgc3RhdGVtZW50IGNhbm5vdCBzdGFydCB3aXRoICdsZXQgWydcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5hc3luY0Z1bmN0aW9ucyAmJiB0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhBU1lOQykgJiYgcGVla0xvb2thaGVhZChGVU5DVElPTikpIHtcbiAgICAgICAgICB2YXIgYXN5bmNUb2tlbiA9IHRoaXMuZWF0SWRfKCk7XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uVG9rZW4gPSBwZWVrVG9rZW5Ob0xpbmVUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uVG9rZW4gIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbl8oYXN5bmNUb2tlbik7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBhc3luY1Rva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICBpZiAodGhpcy5lYXRJZl8oQ09MT04pKSB7XG4gICAgICAgICAgICB2YXIgbmFtZVRva2VuID0gZXhwcmVzc2lvbi5pZGVudGlmaWVyVG9rZW47XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudF8oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFiZWxsZWRTdGF0ZW1lbnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZVRva2VuLCBzdGF0ZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdFBvc3NpYmxlSW1wbGljaXRTZW1pQ29sb25fKCk7XG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUlmU3RhdGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhJRik7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHZhciBpZkNsYXVzZSA9IHRoaXMucGFyc2VTdGF0ZW1lbnRfKCk7XG4gICAgICAgIHZhciBlbHNlQ2xhdXNlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZWF0SWZfKEVMU0UpKSB7XG4gICAgICAgICAgZWxzZUNsYXVzZSA9IHRoaXMucGFyc2VTdGF0ZW1lbnRfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJZlN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBjb25kaXRpb24sIGlmQ2xhdXNlLCBlbHNlQ2xhdXNlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZURvV2hpbGVTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKERPKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50XygpO1xuICAgICAgICB0aGlzLmVhdF8oV0hJTEUpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLmVhdFBvc3NpYmxlSW1wbGljaXRTZW1pQ29sb25fKCk7XG4gICAgICAgIHJldHVybiBuZXcgRG9XaGlsZVN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBib2R5LCBjb25kaXRpb24pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlV2hpbGVTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKFdISUxFKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50XygpO1xuICAgICAgICByZXR1cm4gbmV3IFdoaWxlU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGNvbmRpdGlvbiwgYm9keSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VGb3JTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKEZPUik7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdmFyIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICBpZiAodGhpcy5wZWVrVmFyaWFibGVEZWNsYXJhdGlvbkxpc3RfKHR5cGUpKSB7XG4gICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdF8oTk9fSU4sIElOSVRJQUxJWkVSX09QVElPTkFMKTtcbiAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdmFyaWFibGVzLmRlY2xhcmF0aW9ucztcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEgfHwgY29udGFpbnNJbml0aWFsaXplcihkZWNsYXJhdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudDJfKHN0YXJ0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gSU4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW5TdGF0ZW1lbnRfKHN0YXJ0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wZWVrT2ZfKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yT2ZTdGF0ZW1lbnRfKHN0YXJ0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hbGxvd0Zvck9uXyAmJiB0aGlzLnBlZWtPbl8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JPblN0YXRlbWVudF8oc3RhcnQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJbml0aWFsaXplcnNfKHZhcmlhYmxlcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudDJfKHN0YXJ0LCB2YXJpYWJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU0VNSV9DT0xPTikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50Ml8oc3RhcnQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3ZlckluaXRpYWxpemVkTmFtZUNvdW50ID0gdGhpcy5jb3ZlckluaXRpYWxpemVkTmFtZUNvdW50XztcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy5wYXJzZUV4cHJlc3Npb25BbGxvd1BhdHRlcm5fKE5PX0lOKTtcbiAgICAgICAgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgIGlmICgodHlwZSA9PT0gSU4gfHwgdGhpcy5wZWVrT2ZfKCkgfHwgdGhpcy5hbGxvd0Zvck9uXyAmJiB0aGlzLnBlZWtPbl8oKSkpIHtcbiAgICAgICAgICBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtTGVmdEhhbmRTaWRlRXhwcmVzc2lvbl8oaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVBc3NpZ25tZW50VGFyZ2V0Xyhpbml0aWFsaXplciwgJ2Fzc2lnbm1lbnQnKTtcbiAgICAgICAgICBpZiAodGhpcy5wZWVrT2ZfKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yT2ZTdGF0ZW1lbnRfKHN0YXJ0LCBpbml0aWFsaXplcik7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFsbG93Rm9yT25fICYmIHRoaXMucGVla09uXygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvck9uU3RhdGVtZW50XyhzdGFydCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluU3RhdGVtZW50XyhzdGFydCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlTm9Db3ZlckluaXRpYWxpemVkTmFtZXNfKGluaXRpYWxpemVyLCBjb3ZlckluaXRpYWxpemVkTmFtZUNvdW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQyXyhzdGFydCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHBlZWtPZl86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5mb3JPZiAmJiB0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhPRik7XG4gICAgICB9LFxuICAgICAgcGVla09uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLmZvck9uICYmIHRoaXMucGVla1ByZWRlZmluZWRTdHJpbmdfKE9OKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZvck9mU3RhdGVtZW50XzogZnVuY3Rpb24oc3RhcnQsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuZWF0SWRfKCk7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50XygpO1xuICAgICAgICByZXR1cm4gbmV3IEZvck9mU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGluaXRpYWxpemVyLCBjb2xsZWN0aW9uLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZvck9uU3RhdGVtZW50XzogZnVuY3Rpb24oc3RhcnQsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuZWF0SWRfKCk7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50XygpO1xuICAgICAgICByZXR1cm4gbmV3IEZvck9uU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGluaXRpYWxpemVyLCBvYnNlcnZhYmxlLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICBjaGVja0luaXRpYWxpemVyc186IGZ1bmN0aW9uKHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5ibG9ja0JpbmRpbmcgJiYgdmFyaWFibGVzLmRlY2xhcmF0aW9uVHlwZSA9PT0gQ09OU1QpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHZhcmlhYmxlcy5kZWNsYXJhdGlvblR5cGU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tJbml0aWFsaXplcl8odHlwZSwgdmFyaWFibGVzLmRlY2xhcmF0aW9uc1tpXSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tJbml0aWFsaXplcl86IGZ1bmN0aW9uKHR5cGUsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmJsb2NrQmluZGluZyAmJiB0eXBlID09PSBDT05TVCAmJiBkZWNsYXJhdGlvbi5pbml0aWFsaXplciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKGRlY2xhcmF0aW9uLmxvY2F0aW9uLCAnY29uc3QgdmFyaWFibGVzIG11c3QgaGF2ZSBhbiBpbml0aWFsaXplcicpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBwZWVrVmFyaWFibGVEZWNsYXJhdGlvbkxpc3RfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgVkFSOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBDT05TVDpcbiAgICAgICAgICBjYXNlIExFVDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLmJsb2NrQmluZGluZztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VGb3JTdGF0ZW1lbnQyXzogZnVuY3Rpb24oc3RhcnQsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIHRoaXMuZWF0XyhTRU1JX0NPTE9OKTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICghcGVlayhTRU1JX0NPTE9OKSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKFNFTUlfQ09MT04pO1xuICAgICAgICB2YXIgaW5jcmVtZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKCFwZWVrKENMT1NFX1BBUkVOKSkge1xuICAgICAgICAgIGluY3JlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50XygpO1xuICAgICAgICByZXR1cm4gbmV3IEZvclN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBpbml0aWFsaXplciwgY29uZGl0aW9uLCBpbmNyZW1lbnQsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRm9ySW5TdGF0ZW1lbnRfOiBmdW5jdGlvbihzdGFydCwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5lYXRfKElOKTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgRm9ySW5TdGF0ZW1lbnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaW5pdGlhbGl6ZXIsIGNvbGxlY3Rpb24sIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ29udGludWVTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKENPTlRJTlVFKTtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMucGVla0ltcGxpY2l0U2VtaUNvbG9uXygpKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuZWF0SWRPcHRfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnRpbnVlU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQnJlYWtTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKEJSRUFLKTtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMucGVla0ltcGxpY2l0U2VtaUNvbG9uXygpKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuZWF0SWRPcHRfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IEJyZWFrU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlUmV0dXJuU3RhdGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciByZXR1cm5Ub2tlbiA9IHRoaXMuZWF0XyhSRVRVUk4pO1xuICAgICAgICBpZiAodGhpcy5mdW5jdGlvblN0YXRlXy5pc1RvcE1vc3QoKSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHJldHVyblRva2VuLmxvY2F0aW9uLCAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMucGVla0ltcGxpY2l0U2VtaUNvbG9uXygpKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVlpZWxkRXhwcmVzc2lvbl86IGZ1bmN0aW9uKGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKFlJRUxEKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICB2YXIgaXNZaWVsZEZvciA9IGZhbHNlO1xuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrVG9rZW5Ob0xpbmVUZXJtaW5hdG9yKCk7XG4gICAgICAgIGlmICh0b2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfUEFSRU46XG4gICAgICAgICAgICBjYXNlIENMT1NFX1NRVUFSRTpcbiAgICAgICAgICAgIGNhc2UgQ09MT046XG4gICAgICAgICAgICBjYXNlIENPTU1BOlxuICAgICAgICAgICAgY2FzZSBFTkRfT0ZfRklMRTpcbiAgICAgICAgICAgIGNhc2UgU0VNSV9DT0xPTjpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpc1lpZWxkRm9yID0gdGhpcy5lYXRJZl8oU1RBUik7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKGFsbG93SW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFlpZWxkRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByZXNzaW9uLCBpc1lpZWxkRm9yKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVdpdGhTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHdpdGhUb2tlbiA9IHRoaXMuZWF0XyhXSVRIKTtcbiAgICAgICAgaWYgKHRoaXMuc3RyaWN0TW9kZV8pIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yXyh3aXRoVG9rZW4ubG9jYXRpb24sICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudF8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXaXRoU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGV4cHJlc3Npb24sIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlU3dpdGNoU3RhdGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhTV0lUQ0gpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB2YXIgY2FzZUNsYXVzZXMgPSB0aGlzLnBhcnNlQ2FzZUNsYXVzZXNfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9DVVJMWSk7XG4gICAgICAgIHJldHVybiBuZXcgU3dpdGNoU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGV4cHJlc3Npb24sIGNhc2VDbGF1c2VzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNhc2VDbGF1c2VzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmb3VuZERlZmF1bHRDbGF1c2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIENBU0U6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXh0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgICAgICAgICAgdGhpcy5lYXRfKENPTE9OKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHRoaXMucGFyc2VDYXNlU3RhdGVtZW50c09wdF8oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgQ2FzZUNsYXVzZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgREVGQVVMVDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmREZWZhdWx0Q2xhdXNlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yXyhkZWZhdWx0VG9rZW4ubG9jYXRpb24sICdTd2l0Y2ggc3RhdGVtZW50cyBtYXkgaGF2ZSBhdCBtb3N0IG9uZSBcXCdkZWZhdWx0XFwnIGNsYXVzZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZERlZmF1bHRDbGF1c2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVhdF8oQ09MT04pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWZhdWx0Q2xhdXNlKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHRoaXMucGFyc2VDYXNlU3RhdGVtZW50c09wdF8oKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcnNlQ2FzZVN0YXRlbWVudHNPcHRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUgPSBwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlIENBU0U6XG4gICAgICAgICAgICBjYXNlIERFRkFVTFQ6XG4gICAgICAgICAgICBjYXNlIENMT1NFX0NVUkxZOlxuICAgICAgICAgICAgY2FzZSBFTkRfT0ZfRklMRTpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtXyh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYXJzZVRocm93U3RhdGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhUSFJPVyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5wZWVrSW1wbGljaXRTZW1pQ29sb25fKCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IFRocm93U3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVRyeVN0YXRlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oVFJZKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQmxvY2tfKCk7XG4gICAgICAgIHZhciBjYXRjaEJsb2NrID0gbnVsbDtcbiAgICAgICAgaWYgKHBlZWsoQ0FUQ0gpKSB7XG4gICAgICAgICAgY2F0Y2hCbG9jayA9IHRoaXMucGFyc2VDYXRjaF8oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmluYWxseUJsb2NrID0gbnVsbDtcbiAgICAgICAgaWYgKHBlZWsoRklOQUxMWSkpIHtcbiAgICAgICAgICBmaW5hbGx5QmxvY2sgPSB0aGlzLnBhcnNlRmluYWxseUJsb2NrXygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXRjaEJsb2NrID09PSBudWxsICYmIGZpbmFsbHlCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbigpO1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRva2VuLmxvY2F0aW9uLCBcIidjYXRjaCcgb3IgJ2ZpbmFsbHknIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyeVN0YXRlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBib2R5LCBjYXRjaEJsb2NrLCBmaW5hbGx5QmxvY2spO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ2F0Y2hfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGNhdGNoQmxvY2s7XG4gICAgICAgIHRoaXMuZWF0XyhDQVRDSCk7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdmFyIGJpbmRpbmc7XG4gICAgICAgIGlmICh0aGlzLnBlZWtQYXR0ZXJuXyhwZWVrVHlwZSgpKSlcbiAgICAgICAgICBiaW5kaW5nID0gdGhpcy5wYXJzZUJpbmRpbmdQYXR0ZXJuXygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYmluZGluZyA9IHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGNhdGNoQm9keSA9IHRoaXMucGFyc2VCbG9ja18oKTtcbiAgICAgICAgY2F0Y2hCbG9jayA9IG5ldyBDYXRjaCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBiaW5kaW5nLCBjYXRjaEJvZHkpO1xuICAgICAgICByZXR1cm4gY2F0Y2hCbG9jaztcbiAgICAgIH0sXG4gICAgICBwYXJzZUZpbmFsbHlCbG9ja186IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oRklOQUxMWSk7XG4gICAgICAgIHZhciBmaW5hbGx5QmxvY2sgPSB0aGlzLnBhcnNlQmxvY2tfKCk7XG4gICAgICAgIHJldHVybiBuZXcgRmluYWxseSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBmaW5hbGx5QmxvY2spO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKERFQlVHR0VSKTtcbiAgICAgICAgdGhpcy5lYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXygpO1xuICAgICAgICByZXR1cm4gbmV3IERlYnVnZ2VyU3RhdGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCkpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlUHJpbWFyeUV4cHJlc3Npb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBDTEFTUzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLmNsYXNzZXMgPyB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uXygpIDogdGhpcy5wYXJzZVVuZXhwZWN0ZWRSZXNlcnZlZFdvcmRfKHBlZWtUb2tlbigpKTtcbiAgICAgICAgICBjYXNlIFRISVM6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRoaXNFeHByZXNzaW9uXygpO1xuICAgICAgICAgIGNhc2UgSURFTlRJRklFUjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLnBhcnNlSWRlbnRpZmllckV4cHJlc3Npb25fKCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzeW5jRnVuY3Rpb25zICYmIGlkZW50aWZpZXIuaWRlbnRpZmllclRva2VuLnZhbHVlID09PSBBU1lOQykge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbiRfXzYgPSBwZWVrVG9rZW5Ob0xpbmVUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuJF9fNiAmJiB0b2tlbiRfXzYudHlwZSA9PT0gRlVOQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhc3luY1Rva2VuID0gaWRlbnRpZmllci5pZGVudGlmaWVyVG9rZW47XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25FeHByZXNzaW9uXyhhc3luY1Rva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBOVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJTkc6XG4gICAgICAgICAgY2FzZSBUUlVFOlxuICAgICAgICAgIGNhc2UgRkFMU0U6XG4gICAgICAgICAgY2FzZSBOVUxMOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUxpdGVyYWxfKCk7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaXRlcmFsXygpO1xuICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb25TdGFydGluZ1dpdGhQYXJlbl8oKTtcbiAgICAgICAgICBjYXNlIFNMQVNIOlxuICAgICAgICAgIGNhc2UgU0xBU0hfRVFVQUw6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbF8oKTtcbiAgICAgICAgICBjYXNlIE5PX1NVQlNUSVRVVElPTl9URU1QTEFURTpcbiAgICAgICAgICBjYXNlIFRFTVBMQVRFX0hFQUQ6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy50ZW1wbGF0ZUxpdGVyYWxzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGVMaXRlcmFsXyhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSU1QTEVNRU5UUzpcbiAgICAgICAgICBjYXNlIElOVEVSRkFDRTpcbiAgICAgICAgICBjYXNlIFBBQ0tBR0U6XG4gICAgICAgICAgY2FzZSBQUklWQVRFOlxuICAgICAgICAgIGNhc2UgUFJPVEVDVEVEOlxuICAgICAgICAgIGNhc2UgUFVCTElDOlxuICAgICAgICAgIGNhc2UgU1RBVElDOlxuICAgICAgICAgIGNhc2UgWUlFTEQ6XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpY3RNb2RlXykge1xuICAgICAgICAgICAgICB0aGlzLnJlcG9ydFJlc2VydmVkSWRlbnRpZmllcl8obmV4dFRva2VuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5qc3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VKc3hFbGVtZW50XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFTkRfT0ZfRklMRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3ludGF4RXJyb3JfKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbigpO1xuICAgICAgICBpZiAodG9rZW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuZXhwZWN0ZWRSZXNlcnZlZFdvcmRfKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuZXhwZWN0ZWRUb2tlbl8odG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlU3VwZXJFeHByZXNzaW9uXzogZnVuY3Rpb24oaXNOZXcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGZzID0gdGhpcy5mdW5jdGlvblN0YXRlXztcbiAgICAgICAgd2hpbGUgKGZzICYmIGZzLmlzQXJyb3dGdW5jdGlvbigpKSB7XG4gICAgICAgICAgZnMgPSBmcy5vdXRlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3VwZXJUb2tlbiA9IHRoaXMuZWF0XyhTVVBFUik7XG4gICAgICAgIGlmICghZnMgfHwgIWZzLmlzTWV0aG9kKCkpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yXyhzdXBlclRva2VuLmxvY2F0aW9uLCAnc3VwZXIgaXMgb25seSBhbGxvd2VkIGluIG1ldGhvZHMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmFuZCA9IG5ldyBTdXBlckV4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSk7XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IE9QRU5fU1FVQVJFKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lbWJlckxvb2t1cEV4cHJlc3Npb25fKHN0YXJ0LCBvcGVyYW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZW1iZXJFeHByZXNzaW9uXyhzdGFydCwgb3BlcmFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWVtYmVyTG9va3VwRXhwcmVzc2lvbl8oc3RhcnQsIG9wZXJhbmQpO1xuICAgICAgICAgIGNhc2UgUEVSSU9EOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZW1iZXJFeHByZXNzaW9uXyhzdGFydCwgb3BlcmFuZCk7XG4gICAgICAgICAgY2FzZSBPUEVOX1BBUkVOOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgc3VwZXJDYWxsID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uXyhzdGFydCwgb3BlcmFuZCk7XG4gICAgICAgICAgICAgIGlmICghZnMuaXNEZXJpdmVkQ29uc3RydWN0b3IoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHN1cGVyVG9rZW4ubG9jYXRpb24sICdzdXBlciBjYWxsIGlzIG9ubHkgYWxsb3dlZCBpbiBkZXJpdmVkIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyQ2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuZXhwZWN0ZWRUb2tlbl8oKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVRoaXNFeHByZXNzaW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhUSElTKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpKTtcbiAgICAgIH0sXG4gICAgICBwZWVrQmluZGluZ0lkZW50aWZpZXJfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZWtJZF8odHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VCaW5kaW5nSWRlbnRpZmllcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuZWF0SWRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ0lkZW50aWZpZXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaWRlbnRpZmllcik7XG4gICAgICB9LFxuICAgICAgcGFyc2VJZGVudGlmaWVyRXhwcmVzc2lvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuZWF0SWRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaWRlbnRpZmllcik7XG4gICAgICB9LFxuICAgICAgcGFyc2VJZGVudGlmaWVyTmFtZUV4cHJlc3Npb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSB0aGlzLmVhdElkTmFtZV8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBpZGVudGlmaWVyKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUxpdGVyYWxFeHByZXNzaW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBsaXRlcmFsID0gdGhpcy5uZXh0TGl0ZXJhbFRva2VuXygpO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGxpdGVyYWwpO1xuICAgICAgfSxcbiAgICAgIG5leHRMaXRlcmFsVG9rZW5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5leHRUb2tlbigpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlUmVndWxhckV4cHJlc3Npb25MaXRlcmFsXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBsaXRlcmFsID0gbmV4dFJlZ3VsYXJFeHByZXNzaW9uTGl0ZXJhbFRva2VuKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbGl0ZXJhbCk7XG4gICAgICB9LFxuICAgICAgcGVla1NwcmVhZF86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IERPVF9ET1RfRE9UICYmIHRoaXMub3B0aW9uc18uc3ByZWFkO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXJyYXlMaXRlcmFsXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgdmFyIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gRk9SICYmIHRoaXMub3B0aW9uc18uYXJyYXlDb21wcmVoZW5zaW9uKVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlDb21wcmVoZW5zaW9uXyhzdGFydCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IENPTU1BKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGVla1NwcmVhZF8odHlwZSkpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlU3ByZWFkRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IENMT1NFX1NRVUFSRSB8fCB0eXBlID09PSBFTkRfT0ZfRklMRSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudHMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gQ0xPU0VfU1FVQVJFKVxuICAgICAgICAgICAgdGhpcy5lYXRfKENPTU1BKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfU1FVQVJFKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpdGVyYWwodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZWxlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXJyYXlDb21wcmVoZW5zaW9uXzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnBhcnNlQ29tcHJlaGVuc2lvbkxpc3RfKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9TUVVBUkUpO1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29tcHJlaGVuc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBsaXN0LCBleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNvbXByZWhlbnNpb25MaXN0XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW3RoaXMucGFyc2VDb21wcmVoZW5zaW9uRm9yXygpXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEZPUjpcbiAgICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VDb21wcmVoZW5zaW9uRm9yXygpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIElGOlxuICAgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZUNvbXByZWhlbnNpb25JZl8oKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VDb21wcmVoZW5zaW9uRm9yXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhGT1IpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZUZvckJpbmRpbmdfKCk7XG4gICAgICAgIHRoaXMuZWF0SWRfKE9GKTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVoZW5zaW9uRm9yKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGxlZnQsIGl0ZXJhdG9yKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNvbXByZWhlbnNpb25JZl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oSUYpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVoZW5zaW9uSWYodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VPYmplY3RMaXRlcmFsXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrUHJvcGVydHlEZWZpbml0aW9uXyhwZWVrVHlwZSgpKSkge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eURlZmluaXRpb24gPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uXygpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5RGVmaW5pdGlvbik7XG4gICAgICAgICAgaWYgKCF0aGlzLmVhdElmXyhDT01NQSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfQ1VSTFkpO1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdExpdGVyYWwodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVByb3BlcnR5RGVmaW5pdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKEZVTkNUSU9OX1NUQVRFX1NDUklQVCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uXygpO1xuICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBwYXJzZVByb3BlcnR5RGVmaW5pdGlvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgZnVuY3Rpb25LaW5kID0gbnVsbDtcbiAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmdlbmVyYXRvcnMgJiYgdGhpcy5vcHRpb25zXy5wcm9wZXJ0eU1ldGhvZHMgJiYgcGVlayhTVEFSKSkge1xuICAgICAgICAgIHZhciBmcyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKEZVTkNUSU9OX1NUQVRFX01FVEhPRCB8IEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUik7XG4gICAgICAgICAgdmFyIG0gPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kXyhzdGFydCwgaXNTdGF0aWMsIFtdKTtcbiAgICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zcHJlYWRQcm9wZXJ0aWVzICYmIHBlZWsoRE9UX0RPVF9ET1QpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTcHJlYWRFeHByZXNzaW9uXygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbigpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVfKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnByb3BlcnR5TWV0aG9kcyAmJiBwZWVrKE9QRU5fUEFSRU4pKSB7XG4gICAgICAgICAgdmFyIGZzJF9fNyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKEZVTkNUSU9OX1NUQVRFX01FVEhPRCk7XG4gICAgICAgICAgdmFyIG0kX184ID0gdGhpcy5wYXJzZU1ldGhvZF8oc3RhcnQsIGlzU3RhdGljLCBmdW5jdGlvbktpbmQsIG5hbWUsIFtdKTtcbiAgICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzJF9fNyk7XG4gICAgICAgICAgcmV0dXJuIG0kX184O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVhdElmXyhDT0xPTikpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5TmFtZUFzc2lnbm1lbnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FKSB7XG4gICAgICAgICAgdmFyIG5hbWVMaXRlcmFsID0gbmFtZS5saXRlcmFsVG9rZW47XG4gICAgICAgICAgaWYgKG5hbWVMaXRlcmFsLnZhbHVlID09PSBHRVQgJiYgdGhpcy5wZWVrUHJvcGVydHlOYW1lXyh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZXRBY2Nlc3Nvcl8oc3RhcnQsIGlzU3RhdGljLCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuYW1lTGl0ZXJhbC52YWx1ZSA9PT0gU0VUICYmIHRoaXMucGVla1Byb3BlcnR5TmFtZV8odHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2V0QWNjZXNzb3JfKHN0YXJ0LCBpc1N0YXRpYywgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5hc3luY0Z1bmN0aW9ucyAmJiBuYW1lTGl0ZXJhbC52YWx1ZSA9PT0gQVNZTkMgJiYgKHRoaXMucGVla1Byb3BlcnR5TmFtZV8odHlwZSkgfHwgdGhpcy5wZWVrQXN5bmNTdGFyXygpKSkge1xuICAgICAgICAgICAgdmFyIGFzeW5jID0gbmFtZUxpdGVyYWw7XG4gICAgICAgICAgICB2YXIga2luZCA9IEZVTkNUSU9OX1NUQVRFX01FVEhPRCB8IEZVTkNUSU9OX1NUQVRFX0FTWU5DO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla0FzeW5jU3Rhcl8oKSkge1xuICAgICAgICAgICAgICBraW5kIHw9IEZVTkNUSU9OX1NUQVRFX0dFTkVSQVRPUjtcbiAgICAgICAgICAgICAgdGhpcy5lYXRfKFNUQVIpO1xuICAgICAgICAgICAgICBhc3luYyA9IG5ldyBJZGVudGlmaWVyVG9rZW4oYXN5bmMubG9jYXRpb24sIEFTWU5DX1NUQVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWUkX185ID0gdGhpcy5wYXJzZVByb3BlcnR5TmFtZV8oKTtcbiAgICAgICAgICAgIHZhciBmcyRfXzEwID0gdGhpcy5wdXNoRnVuY3Rpb25TdGF0ZV8oa2luZCk7XG4gICAgICAgICAgICB2YXIgbSRfXzExID0gdGhpcy5wYXJzZU1ldGhvZF8oc3RhcnQsIGlzU3RhdGljLCBhc3luYywgbmFtZSRfXzksIFtdKTtcbiAgICAgICAgICAgIHRoaXMucG9wRnVuY3Rpb25TdGF0ZV8oZnMkX18xMCk7XG4gICAgICAgICAgICByZXR1cm4gbSRfXzExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5wcm9wZXJ0eU5hbWVTaG9ydGhhbmQgJiYgKG5hbWVMaXRlcmFsLnR5cGUgPT09IElERU5USUZJRVIgfHwgbmFtZUxpdGVyYWwuaXNTdHJpY3RLZXl3b3JkKCkgJiYgIXRoaXMuc3RyaWN0TW9kZV8gfHwgbmFtZUxpdGVyYWwudHlwZSA9PT0gWUlFTEQgJiYgdGhpcy5hbGxvd1lpZWxkXykpIHtcbiAgICAgICAgICAgIGlmIChwZWVrKEVRVUFMKSkge1xuICAgICAgICAgICAgICB0b2tlbiA9IG5leHRUb2tlbigpO1xuICAgICAgICAgICAgICB2YXIgY292ZXJJbml0aWFsaXplZE5hbWVDb3VudCA9IHRoaXMuY292ZXJJbml0aWFsaXplZE5hbWVDb3VudF87XG4gICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgICAgICAgIHRoaXMuZW5zdXJlTm9Db3ZlckluaXRpYWxpemVkTmFtZXNfKGV4cHIsIGNvdmVySW5pdGlhbGl6ZWROYW1lQ291bnQpO1xuICAgICAgICAgICAgICB0aGlzLmNvdmVySW5pdGlhbGl6ZWROYW1lQ291bnRfKys7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ292ZXJJbml0aWFsaXplZE5hbWUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZUxpdGVyYWwsIHRva2VuLCBleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlOYW1lU2hvcnRoYW5kKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5hbWVMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuc3RyaWN0TW9kZV8gJiYgbmFtZUxpdGVyYWwuaXNTdHJpY3RLZXl3b3JkKCkpXG4gICAgICAgICAgICB0aGlzLnJlcG9ydFJlc2VydmVkSWRlbnRpZmllcl8obmFtZUxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lLnR5cGUgPT09IENPTVBVVEVEX1BST1BFUlRZX05BTUUpXG4gICAgICAgICAgdG9rZW4gPSBwZWVrVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmV4cGVjdGVkVG9rZW5fKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNsYXNzRWxlbWVudF86IGZ1bmN0aW9uKGRlcml2ZWRDbGFzcykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnBhcnNlQW5ub3RhdGlvbnNfKCk7XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgdmFyIGlzU3RhdGljID0gZmFsc2UsXG4gICAgICAgICAgICBmdW5jdGlvbktpbmQgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNUQVRJQzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXRpY1Rva2VuID0gbmV4dFRva2VuKCk7XG4gICAgICAgICAgICAgIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9QRU5fUEFSRU46XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbmV3IExpdGVyYWxQcm9wZXJ0eU5hbWUobG9jYXRpb24sIHN0YXRpY1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gdGhpcy5wdXNoRnVuY3Rpb25TdGF0ZV8oRlVOQ1RJT05fU1RBVEVfTUVUSE9EKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnBhcnNlTWV0aG9kXyhzdGFydCwgaXNTdGF0aWMsIGZ1bmN0aW9uS2luZCwgbmFtZSwgYW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBTVEFSICYmIHRoaXMub3B0aW9uc18uZ2VuZXJhdG9ycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2RfKHN0YXJ0LCB0cnVlLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzRWxlbWVudDJfKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMsIGRlcml2ZWRDbGFzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBTVEFSOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2RfKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzRWxlbWVudDJfKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMsIGRlcml2ZWRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYXJzZUdlbmVyYXRvck1ldGhvZF86IGZ1bmN0aW9uKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIGZ1bmN0aW9uS2luZCA9IHRoaXMuZWF0XyhTVEFSKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlUHJvcGVydHlOYW1lXygpO1xuICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhGVU5DVElPTl9TVEFURV9NRVRIT0QgfCBGVU5DVElPTl9TVEFURV9HRU5FUkFUT1IpO1xuICAgICAgICB2YXIgbSA9IHRoaXMucGFyc2VNZXRob2RfKHN0YXJ0LCBpc1N0YXRpYywgZnVuY3Rpb25LaW5kLCBuYW1lLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgIHRoaXMucG9wRnVuY3Rpb25TdGF0ZV8oZnMpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH0sXG4gICAgICBwYXJzZU1ldGhvZF86IGZ1bmN0aW9uKHN0YXJ0LCBpc1N0YXRpYywgZnVuY3Rpb25LaW5kLCBuYW1lLCBhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnNfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5XyhwYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaXNTdGF0aWMsIGZ1bmN0aW9uS2luZCwgbmFtZSwgcGFyYW1ldGVyTGlzdCwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5LCBudWxsKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbl86IGZ1bmN0aW9uKHN0YXJ0LCBpc1N0YXRpYywgbmFtZSwgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy5wYXJzZVR5cGVBbm5vdGF0aW9uT3B0XygpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnBhcnNlSW5pdGlhbGl6ZXJPcHRfKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKFNFTUlfQ09MT04pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBpc1N0YXRpYywgbmFtZSwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBpbml0aWFsaXplcik7XG4gICAgICB9LFxuICAgICAgcGFyc2VDbGFzc0VsZW1lbnQyXzogZnVuY3Rpb24oc3RhcnQsIGlzU3RhdGljLCBhbm5vdGF0aW9ucywgZGVyaXZlZENsYXNzKSB7XG4gICAgICAgIHZhciBmdW5jdGlvbktpbmQgPSBudWxsO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVfKCk7XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FICYmIG5hbWUubGl0ZXJhbFRva2VuLnZhbHVlID09PSBHRVQgJiYgdGhpcy5wZWVrUHJvcGVydHlOYW1lXyh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlR2V0QWNjZXNzb3JfKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lLnR5cGUgPT09IExJVEVSQUxfUFJPUEVSVFlfTkFNRSAmJiBuYW1lLmxpdGVyYWxUb2tlbi52YWx1ZSA9PT0gU0VUICYmIHRoaXMucGVla1Byb3BlcnR5TmFtZV8odHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNldEFjY2Vzc29yXyhzdGFydCwgaXNTdGF0aWMsIGFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5hc3luY0Z1bmN0aW9ucyAmJiBuYW1lLnR5cGUgPT09IExJVEVSQUxfUFJPUEVSVFlfTkFNRSAmJiBuYW1lLmxpdGVyYWxUb2tlbi52YWx1ZSA9PT0gQVNZTkMgJiYgKHRoaXMucGVla1Byb3BlcnR5TmFtZV8odHlwZSkgfHwgdGhpcy5wZWVrQXN5bmNTdGFyXygpKSkge1xuICAgICAgICAgIHZhciBhc3luYyA9IG5hbWUubGl0ZXJhbFRva2VuO1xuICAgICAgICAgIHZhciBraW5kID0gRlVOQ1RJT05fU1RBVEVfTUVUSE9EIHwgRlVOQ1RJT05fU1RBVEVfQVNZTkM7XG4gICAgICAgICAgaWYgKHRoaXMucGVla0FzeW5jU3Rhcl8oKSkge1xuICAgICAgICAgICAga2luZCB8PSBGVU5DVElPTl9TVEFURV9HRU5FUkFUT1I7XG4gICAgICAgICAgICB0aGlzLmVhdF8oU1RBUik7XG4gICAgICAgICAgICBhc3luYyA9IG5ldyBJZGVudGlmaWVyVG9rZW4oYXN5bmMubG9jYXRpb24sIEFTWU5DX1NUQVIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gdGhpcy5wYXJzZVByb3BlcnR5TmFtZV8oKTtcbiAgICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhraW5kKTtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMucGFyc2VNZXRob2RfKHN0YXJ0LCBpc1N0YXRpYywgYXN5bmMsIG5hbWUsIGFubm90YXRpb25zKTtcbiAgICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc18ubWVtYmVyVmFyaWFibGVzIHx8IHR5cGUgPT09IE9QRU5fUEFSRU4pIHtcbiAgICAgICAgICB2YXIga2luZCRfXzEyID0gRlVOQ1RJT05fU1RBVEVfTUVUSE9EO1xuICAgICAgICAgIHZhciBpc0Rlcml2ZWRDb25zdHJ1Y3RvciA9IGRlcml2ZWRDbGFzcyAmJiAhaXNTdGF0aWMgJiYgZnVuY3Rpb25LaW5kID09PSBudWxsICYmIG5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FICYmIG5hbWUubGl0ZXJhbFRva2VuLnZhbHVlID09PSBDT05TVFJVQ1RPUjtcbiAgICAgICAgICBpZiAoaXNEZXJpdmVkQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGtpbmQkX18xMiB8PSBGVU5DVElPTl9TVEFURV9ERVJJVkVEX0NPTlNUUlVDVE9SO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZnMkX18xMyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKGtpbmQkX18xMik7XG4gICAgICAgICAgdmFyIG0kX18xNCA9IHRoaXMucGFyc2VNZXRob2RfKHN0YXJ0LCBpc1N0YXRpYywgZnVuY3Rpb25LaW5kLCBuYW1lLCBhbm5vdGF0aW9ucyk7XG4gICAgICAgICAgdGhpcy5wb3BGdW5jdGlvblN0YXRlXyhmcyRfXzEzKTtcbiAgICAgICAgICBpZiAoaXNEZXJpdmVkQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29uc3RydWN0b3IobSRfXzE0LCB0aGlzLmVycm9yUmVwb3J0ZXJfKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG0kX18xNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByb3BlcnR5VmFyaWFibGVEZWNsYXJhdGlvbl8oc3RhcnQsIGlzU3RhdGljLCBuYW1lLCBhbm5vdGF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VHZXRBY2Nlc3Nvcl86IGZ1bmN0aW9uKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlUHJvcGVydHlOYW1lXygpO1xuICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhGVU5DVElPTl9TVEFURV9NRVRIT0QpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5XyhudWxsKTtcbiAgICAgICAgdGhpcy5wb3BGdW5jdGlvblN0YXRlXyhmcyk7XG4gICAgICAgIHJldHVybiBuZXcgR2V0QWNjZXNzb3IodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaXNTdGF0aWMsIG5hbWUsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgYm9keSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VTZXRBY2Nlc3Nvcl86IGZ1bmN0aW9uKHN0YXJ0LCBpc1N0YXRpYywgYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlUHJvcGVydHlOYW1lXygpO1xuICAgICAgICB2YXIgZnMgPSB0aGlzLnB1c2hGdW5jdGlvblN0YXRlXyhGVU5DVElPTl9TVEFURV9NRVRIT0QpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy5wYXJzZVByb3BlcnR5U2V0UGFyYW1ldGVyTGlzdF8oKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5XyhwYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdGhpcy5wb3BGdW5jdGlvblN0YXRlXyhmcyk7XG4gICAgICAgIHJldHVybiBuZXcgU2V0QWNjZXNzb3IodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaXNTdGF0aWMsIG5hbWUsIHBhcmFtZXRlckxpc3QsIGFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICBwZWVrUHJvcGVydHlEZWZpbml0aW9uXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrUHJvcGVydHlOYW1lXyh0eXBlKSB8fCB0eXBlID09PSBTVEFSICYmIHRoaXMub3B0aW9uc18ucHJvcGVydHlNZXRob2RzICYmIHRoaXMub3B0aW9uc18uZ2VuZXJhdG9ycyB8fCB0eXBlID09PSBET1RfRE9UX0RPVCAmJiB0aGlzLm9wdGlvbnNfLnNwcmVhZFByb3BlcnRpZXM7XG4gICAgICB9LFxuICAgICAgcGVla1Byb3BlcnR5TmFtZV86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBJREVOVElGSUVSOlxuICAgICAgICAgIGNhc2UgU1RSSU5HOlxuICAgICAgICAgIGNhc2UgTlVNQkVSOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfLmNvbXB1dGVkUHJvcGVydHlOYW1lcztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHBlZWtUb2tlbigpLmlzS2V5d29yZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGVla1ByZWRlZmluZWRTdHJpbmdfOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGVla1Rva2VuKCk7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBJREVOVElGSUVSICYmIHRva2VuLnZhbHVlID09PSBzdHJpbmc7XG4gICAgICB9LFxuICAgICAgcGFyc2VQcm9wZXJ0eVNldFBhcmFtZXRlckxpc3RfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGJpbmRpbmc7XG4gICAgICAgIHRoaXMucHVzaEFubm90YXRpb25zXygpO1xuICAgICAgICBpZiAodGhpcy5wZWVrUGF0dGVybl8ocGVla1R5cGUoKSkpXG4gICAgICAgICAgYmluZGluZyA9IHRoaXMucGFyc2VCaW5kaW5nUGF0dGVybl8oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnBhcnNlQmluZGluZ0lkZW50aWZpZXJfKCk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlciA9IG5ldyBGb3JtYWxQYXJhbWV0ZXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmV3IEJpbmRpbmdFbGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGJpbmRpbmcsIG51bGwpLCB0eXBlQW5ub3RhdGlvbiwgdGhpcy5wb3BBbm5vdGF0aW9uc18oKSk7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWFsUGFyYW1ldGVyTGlzdChwYXJhbWV0ZXIubG9jYXRpb24sIFtwYXJhbWV0ZXJdKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVByaW1hcnlFeHByZXNzaW9uU3RhcnRpbmdXaXRoUGFyZW5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICBpZiAocGVlayhGT1IpICYmIHRoaXMub3B0aW9uc18uZ2VuZXJhdG9yQ29tcHJlaGVuc2lvbilcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUdlbmVyYXRvckNvbXByZWhlbnNpb25fKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb3ZlckZvcm1hbHNfKHN0YXJ0KTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVN5bnRheEVycm9yXzogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8odG9rZW4ubG9jYXRpb24sIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yVHJlZSh0b2tlbi5sb2NhdGlvbiwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVW5leHBlY3RlZFRva2VuXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiBwZWVrVG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IE5PX1NVQlNUSVRVVElPTl9URU1QTEFURSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3ludGF4RXJyb3JfKCdVbmV4cGVjdGVkIHRva2VuIGAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN5bnRheEVycm9yXygoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdG9rZW4pKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVVuZXhwZWN0ZWRSZXNlcnZlZFdvcmRfOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN5bnRheEVycm9yXygoXCJVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQgXCIgKyB0b2tlbikpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbl86IGZ1bmN0aW9uKGFsbG93SW4pIHtcbiAgICAgICAgdmFyIGNvdmVySW5pdGlhbGl6ZWROYW1lQ291bnQgPSB0aGlzLmNvdmVySW5pdGlhbGl6ZWROYW1lQ291bnRfO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uQWxsb3dQYXR0ZXJuXyhhbGxvd0luKTtcbiAgICAgICAgdGhpcy5lbnN1cmVOb0NvdmVySW5pdGlhbGl6ZWROYW1lc18oZXhwcmVzc2lvbiwgY292ZXJJbml0aWFsaXplZE5hbWVDb3VudCk7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKEZVTkNUSU9OX1NUQVRFX0xFTklFTlQpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIHRoaXMucG9wRnVuY3Rpb25TdGF0ZV8oZnMpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH0sXG4gICAgICBwYXJzZUV4cHJlc3Npb25BbGxvd1BhdHRlcm5fOiBmdW5jdGlvbihhbGxvd0luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhhbGxvd0luKTtcbiAgICAgICAgaWYgKHBlZWsoQ09NTUEpKSB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW2V4cHJlc3Npb25dO1xuICAgICAgICAgIHdoaWxlICh0aGlzLmVhdElmXyhDT01NQSkpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhhbGxvd0luKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29tbWFFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH0sXG4gICAgICBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXzogZnVuY3Rpb24oYWxsb3dJbikge1xuICAgICAgICBpZiAodGhpcy5hbGxvd1lpZWxkXyAmJiBwZWVrKFlJRUxEKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbl8oYWxsb3dJbik7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciB2YWxpZEFzeW5jUGFyZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXN5bmNGdW5jdGlvbnMgJiYgdGhpcy5wZWVrUHJlZGVmaW5lZFN0cmluZ18oQVNZTkMpKSB7XG4gICAgICAgICAgdmFyIGFzeW5jVG9rZW4gPSBwZWVrVG9rZW4oKTtcbiAgICAgICAgICB2YXIgbWF5YmVPcGVuUGFyZW5Ub2tlbiA9IHBlZWtUb2tlbkxvb2thaGVhZCgpO1xuICAgICAgICAgIHZhbGlkQXN5bmNQYXJlbiA9IG1heWJlT3BlblBhcmVuVG9rZW4udHlwZSA9PT0gT1BFTl9QQVJFTiAmJiBhc3luY1Rva2VuLmxvY2F0aW9uLmVuZC5saW5lID09PSBtYXliZU9wZW5QYXJlblRva2VuLmxvY2F0aW9uLnN0YXJ0LmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWxfKGFsbG93SW4pO1xuICAgICAgICB2YXIgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzeW5jRnVuY3Rpb25zICYmIGxlZnQudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OICYmIGxlZnQuaWRlbnRpZmllclRva2VuLnZhbHVlID09PSBBU1lOQyAmJiB0eXBlID09PSBJREVOVElGSUVSKSB7XG4gICAgICAgICAgaWYgKHBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdJZGVudGlmaWVyID0gdGhpcy5wYXJzZUJpbmRpbmdJZGVudGlmaWVyXygpO1xuICAgICAgICAgICAgdmFyIGFzeW5jVG9rZW4kX18xNSA9IGxlZnQuaWRlbnRpZmllclRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0Z1bmN0aW9uXyhzdGFydCwgYmluZGluZ0lkZW50aWZpZXIsIGFzeW5jVG9rZW4kX18xNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBBUlJPVyAmJiBwZWVrVG9rZW5Ob0xpbmVUZXJtaW5hdG9yKCkgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBDT1ZFUl9GT1JNQUxTIHx8IGxlZnQudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0Z1bmN0aW9uXyhzdGFydCwgbGVmdCwgbnVsbCk7XG4gICAgICAgICAgaWYgKHZhbGlkQXN5bmNQYXJlbiAmJiBsZWZ0LnR5cGUgPT09IENBTExfRVhQUkVTU0lPTikge1xuICAgICAgICAgICAgdmFyIGFzeW5jVG9rZW4kX18xNiA9IGxlZnQub3BlcmFuZC5pZGVudGlmaWVyVG9rZW47XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RnVuY3Rpb25fKHN0YXJ0LCBsZWZ0LmFyZ3MsIGFzeW5jVG9rZW4kX18xNik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgPSB0aGlzLmNvdmVyRm9ybWFsc1RvUGFyZW5FeHByZXNzaW9uXyhsZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMucGVla0Fzc2lnbm1lbnRPcGVyYXRvcl8odHlwZSkpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gRVFVQUwpXG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1MZWZ0SGFuZFNpZGVFeHByZXNzaW9uXyhsZWZ0KTtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlQXNzaWdubWVudFRhcmdldF8obGVmdCwgJ2Fzc2lnbm1lbnQnKTtcbiAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKGFsbG93SW4pO1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5RXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBsZWZ0LCBvcGVyYXRvciwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxlZnRIYW5kU2lkZUV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBBUlJBWV9MSVRFUkFMOlxuICAgICAgICAgIGNhc2UgT0JKRUNUX0xJVEVSQUw6XG4gICAgICAgICAgICByZXNldFNjYW5uZXIodHJlZS5sb2NhdGlvbi5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3NpZ25tZW50UGF0dGVybl8oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICBwZWVrQXNzaWdubWVudE9wZXJhdG9yXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gaXNBc3NpZ25tZW50T3BlcmF0b3IodHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VDb25kaXRpb25hbF86IGZ1bmN0aW9uKGFsbG93SW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uXyhhbGxvd0luKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0SWZfKFFVRVNUSU9OKSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8oY29uZGl0aW9uKTtcbiAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICAgIHRoaXMuZWF0XyhDT0xPTik7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhhbGxvd0luKTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBjb25kaXRpb24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZGl0aW9uO1xuICAgICAgfSxcbiAgICAgIGdldFByZWNlZGVuY2VfOiBmdW5jdGlvbih0eXBlLCBhbGxvd0luKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgT1I6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICBjYXNlIEFORDpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIGNhc2UgQkFSOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgY2FzZSBDQVJFVDpcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgIGNhc2UgQU1QRVJTQU5EOlxuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgICAgY2FzZSBFUVVBTF9FUVVBTDpcbiAgICAgICAgICBjYXNlIEVRVUFMX0VRVUFMX0VRVUFMOlxuICAgICAgICAgIGNhc2UgTk9UX0VRVUFMOlxuICAgICAgICAgIGNhc2UgTk9UX0VRVUFMX0VRVUFMOlxuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgY2FzZSBDTE9TRV9BTkdMRTpcbiAgICAgICAgICBjYXNlIEdSRUFURVJfRVFVQUw6XG4gICAgICAgICAgY2FzZSBJTlNUQU5DRU9GOlxuICAgICAgICAgIGNhc2UgTEVTU19FUVVBTDpcbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICBjYXNlIElOOlxuICAgICAgICAgICAgcmV0dXJuIGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICBjYXNlIExFRlRfU0hJRlQ6XG4gICAgICAgICAgY2FzZSBSSUdIVF9TSElGVDpcbiAgICAgICAgICBjYXNlIFVOU0lHTkVEX1JJR0hUX1NISUZUOlxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgY2FzZSBNSU5VUzpcbiAgICAgICAgICBjYXNlIFBMVVM6XG4gICAgICAgICAgICByZXR1cm4gOTtcbiAgICAgICAgICBjYXNlIFNMQVNIOlxuICAgICAgICAgIGNhc2UgU1RBUjpcbiAgICAgICAgICBjYXNlIFBFUkNFTlQ6XG4gICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgY2FzZSBTVEFSX1NUQVI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zXy5leHBvbmVudGlhdGlvbiA/IDExIDogMDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYXJzZUJpbmFyeUV4cHJlc3Npb25fOiBmdW5jdGlvbihhbGxvd0luKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbl8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uSGVscGVyXyhzdGFydCwgbGVmdCwgLTEsIGFsbG93SW4pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQmluYXJ5RXhwcmVzc2lvbkhlbHBlcl86IGZ1bmN0aW9uKHN0YXJ0LCBsZWZ0LCBtaW5QcmVjLCBhbGxvd0luKSB7XG4gICAgICAgIHZhciB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgdmFyIHByZWMgPSB0aGlzLmdldFByZWNlZGVuY2VfKHR5cGUsIGFsbG93SW4pO1xuICAgICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0VG9SaWdodCA9IHR5cGUgIT09IFNUQVJfU1RBUjtcbiAgICAgICAgaWYgKGxlZnRUb1JpZ2h0ID8gcHJlYyA+IG1pblByZWMgOiBwcmVjID49IG1pblByZWMpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICB2YXIgcmlnaHRTdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgICAgdmFyIHJpZ2h0VW5hcnkgPSB0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uXygpO1xuICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VCaW5hcnlFeHByZXNzaW9uSGVscGVyXyhyaWdodFN0YXJ0LCByaWdodFVuYXJ5LCBwcmVjLCBhbGxvd0luKTtcbiAgICAgICAgICBsZWZ0ID0gdGhpcy50b1ByaW1hcnlFeHByZXNzaW9uXyhsZWZ0KTtcbiAgICAgICAgICByaWdodCA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8ocmlnaHQpO1xuICAgICAgICAgIHZhciBub2RlID0gbmV3IEJpbmFyeUV4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbGVmdCwgdG9rZW4sIHJpZ2h0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmFyeUV4cHJlc3Npb25IZWxwZXJfKHN0YXJ0LCBub2RlLCBtaW5QcmVjLCBhbGxvd0luKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH0sXG4gICAgICBwYXJzZVVuYXJ5RXhwcmVzc2lvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0F3YWl0XyAmJiB0aGlzLnBlZWtQcmVkZWZpbmVkU3RyaW5nXyhBV0FJVCkpIHtcbiAgICAgICAgICB0aGlzLmVhdElkXygpO1xuICAgICAgICAgIHZhciBvcGVyYW5kO1xuICAgICAgICAgIGlmICh0aGlzLmFsbG93WWllbGRfICYmIHBlZWsoWUlFTEQpKSB7XG4gICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICAgIG9wZXJhbmQgPSB0aGlzLnRvUHJpbWFyeUV4cHJlc3Npb25fKG9wZXJhbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEF3YWl0RXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBvcGVyYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZWVrVW5hcnlPcGVyYXRvcl8ocGVla1R5cGUoKSkpIHtcbiAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICB2YXIgb3BlcmFuZCRfXzE3ID0gdGhpcy5wYXJzZVVuYXJ5RXhwcmVzc2lvbl8oKTtcbiAgICAgICAgICBvcGVyYW5kJF9fMTcgPSB0aGlzLnRvUHJpbWFyeUV4cHJlc3Npb25fKG9wZXJhbmQkX18xNyk7XG4gICAgICAgICAgaWYgKG9wZXJhbmQkX18xNy50eXBlICE9PSBTWU5UQVhfRVJST1JfVFJFRSkge1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvci50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUExVU19QTFVTOlxuICAgICAgICAgICAgICBjYXNlIE1JTlVTX01JTlVTOlxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBc3NpZ25tZW50VGFyZ2V0XyhvcGVyYW5kJF9fMTcsICdwcmVmaXggb3BlcmF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVW5hcnlFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG9wZXJhdG9yLCBvcGVyYW5kJF9fMTcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9zdGZpeEV4cHJlc3Npb25fKCk7XG4gICAgICB9LFxuICAgICAgcGVla1VuYXJ5T3BlcmF0b3JfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgREVMRVRFOlxuICAgICAgICAgIGNhc2UgVk9JRDpcbiAgICAgICAgICBjYXNlIFRZUEVPRjpcbiAgICAgICAgICBjYXNlIFBMVVNfUExVUzpcbiAgICAgICAgICBjYXNlIE1JTlVTX01JTlVTOlxuICAgICAgICAgIGNhc2UgUExVUzpcbiAgICAgICAgICBjYXNlIE1JTlVTOlxuICAgICAgICAgIGNhc2UgVElMREU6XG4gICAgICAgICAgY2FzZSBCQU5HOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcnNlUG9zdGZpeEV4cHJlc3Npb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbl8oKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVla1Bvc3RmaXhPcGVyYXRvcl8ocGVla1R5cGUoKSkpIHtcbiAgICAgICAgICBvcGVyYW5kID0gdGhpcy50b1ByaW1hcnlFeHByZXNzaW9uXyhvcGVyYW5kKTtcbiAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlQXNzaWdubWVudFRhcmdldF8ob3BlcmFuZCwgJ3Bvc3RmaXggb3BlcmF0aW9uJyk7XG4gICAgICAgICAgb3BlcmFuZCA9IG5ldyBQb3N0Zml4RXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBvcGVyYW5kLCBvcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICB9LFxuICAgICAgcGVla1Bvc3RmaXhPcGVyYXRvcl86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBQTFVTX1BMVVM6XG4gICAgICAgICAgY2FzZSBNSU5VU19NSU5VUzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHRva2VuID0gcGVla1Rva2VuTm9MaW5lVGVybWluYXRvcigpO1xuICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gIT09IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRoaXMucGFyc2VOZXdFeHByZXNzaW9uXygpO1xuICAgICAgICBpZiAoIShvcGVyYW5kIGluc3RhbmNlb2YgTmV3RXhwcmVzc2lvbikgfHwgb3BlcmFuZC5hcmdzICE9PSBudWxsKSB7XG4gICAgICAgICAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgICAgICBjYXNlIE9QRU5fUEFSRU46XG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8ob3BlcmFuZCk7XG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbl8oc3RhcnQsIG9wZXJhbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIE9QRU5fU1FVQVJFOlxuICAgICAgICAgICAgICAgIG9wZXJhbmQgPSB0aGlzLnRvUHJpbWFyeUV4cHJlc3Npb25fKG9wZXJhbmQpO1xuICAgICAgICAgICAgICAgIG9wZXJhbmQgPSB0aGlzLnBhcnNlTWVtYmVyTG9va3VwRXhwcmVzc2lvbl8oc3RhcnQsIG9wZXJhbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFBFUklPRDpcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy50b1ByaW1hcnlFeHByZXNzaW9uXyhvcGVyYW5kKTtcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5wYXJzZU1lbWJlckV4cHJlc3Npb25fKHN0YXJ0LCBvcGVyYW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBOT19TVUJTVElUVVRJT05fVEVNUExBVEU6XG4gICAgICAgICAgICAgIGNhc2UgVEVNUExBVEVfSEVBRDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uc18udGVtcGxhdGVMaXRlcmFscylcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8ob3BlcmFuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18udGVtcGxhdGVMaXRlcmFscykge1xuICAgICAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWxfKG9wZXJhbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgIH0sXG4gICAgICBwYXJzZU1lbWJlckV4cHJlc3Npb25Ob05ld186IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgb3BlcmFuZDtcbiAgICAgICAgaWYgKHBlZWtUeXBlKCkgPT09IEZVTkNUSU9OKSB7XG4gICAgICAgICAgb3BlcmFuZCA9IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb25fKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlcmFuZCA9IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbl8oKTtcbiAgICAgICAgfVxuICAgICAgICBsb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8ob3BlcmFuZCk7XG4gICAgICAgICAgICAgIG9wZXJhbmQgPSB0aGlzLnBhcnNlTWVtYmVyTG9va3VwRXhwcmVzc2lvbl8oc3RhcnQsIG9wZXJhbmQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUEVSSU9EOlxuICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy50b1ByaW1hcnlFeHByZXNzaW9uXyhvcGVyYW5kKTtcbiAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMucGFyc2VNZW1iZXJFeHByZXNzaW9uXyhzdGFydCwgb3BlcmFuZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOT19TVUJTVElUVVRJT05fVEVNUExBVEU6XG4gICAgICAgICAgICBjYXNlIFRFTVBMQVRFX0hFQUQ6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zXy50ZW1wbGF0ZUxpdGVyYWxzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIG9wZXJhbmQgPSB0aGlzLnRvUHJpbWFyeUV4cHJlc3Npb25fKG9wZXJhbmQpO1xuICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbF8ob3BlcmFuZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhbmQ7XG4gICAgICB9LFxuICAgICAgcGFyc2VNZW1iZXJFeHByZXNzaW9uXzogZnVuY3Rpb24oc3RhcnQsIG9wZXJhbmQpIHtcbiAgICAgICAgdGhpcy5lYXRfKFBFUklPRCk7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5lYXRJZE5hbWVfKCk7XG4gICAgICAgIHJldHVybiBuZXcgTWVtYmVyRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBvcGVyYW5kLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZU1lbWJlckxvb2t1cEV4cHJlc3Npb25fOiBmdW5jdGlvbihzdGFydCwgb3BlcmFuZCkge1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9TUVVBUkUpO1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1NRVUFSRSk7XG4gICAgICAgIHJldHVybiBuZXcgTWVtYmVyTG9va3VwRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBvcGVyYW5kLCBtZW1iZXIpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ2FsbEV4cHJlc3Npb25fOiBmdW5jdGlvbihzdGFydCwgb3BlcmFuZCkge1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudHNfKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbEV4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgb3BlcmFuZCwgYXJncyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VOZXdFeHByZXNzaW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcGVyYW5kLFxuICAgICAgICAgICAgc3RhcnQ7XG4gICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgIGNhc2UgTkVXOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgICAgICAgIHRoaXMuZWF0XyhORVcpO1xuICAgICAgICAgICAgICBpZiAocGVlayhTVVBFUikpIHtcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5wYXJzZVN1cGVyRXhwcmVzc2lvbl8odHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IHRoaXMudG9QcmltYXJ5RXhwcmVzc2lvbl8odGhpcy5wYXJzZU5ld0V4cHJlc3Npb25fKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHBlZWsoT1BFTl9QQVJFTikpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50c18oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IE5ld0V4cHJlc3Npb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgb3BlcmFuZCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBTVVBFUjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3VwZXJFeHByZXNzaW9uXyhmYWxzZSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWVtYmVyRXhwcmVzc2lvbk5vTmV3XygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VBcmd1bWVudHNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICBpZiAoIXBlZWsoQ0xPU0VfUEFSRU4pKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VBcmd1bWVudF8oKSk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuZWF0SWZfKENPTU1BKSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VBcmd1bWVudF8oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHJldHVybiBuZXcgQXJndW1lbnRMaXN0KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXJndW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGVla1NwcmVhZF8ocGVla1R5cGUoKSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTcHJlYWRFeHByZXNzaW9uXygpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICB9LFxuICAgICAgcGFyc2VBcnJvd0Z1bmN0aW9uXzogZnVuY3Rpb24oc3RhcnQsIHRyZWUsIGFzeW5jVG9rZW4pIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICB2YXIgZm9ybWFscztcbiAgICAgICAgdmFyIGtpbmQgPSBGVU5DVElPTl9TVEFURV9BUlJPVztcbiAgICAgICAgaWYgKGFzeW5jVG9rZW4gJiYgYXN5bmNUb2tlbi52YWx1ZSA9PT0gQVNZTkMpIHtcbiAgICAgICAgICBraW5kIHw9IEZVTkNUSU9OX1NUQVRFX0FTWU5DO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcyA9IHRoaXMucHVzaEZ1bmN0aW9uU3RhdGVfKGtpbmQpO1xuICAgICAgICB2YXIgbWFrZUZvcm1hbHMgPSBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYWxQYXJhbWV0ZXJMaXN0KCRfXzMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIFtuZXcgRm9ybWFsUGFyYW1ldGVyKHRyZWUubG9jYXRpb24sIG5ldyBCaW5kaW5nRWxlbWVudCh0cmVlLmxvY2F0aW9uLCB0cmVlLCBudWxsKSwgbnVsbCwgW10pXSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBJREVOVElGSUVSX0VYUFJFU1NJT046XG4gICAgICAgICAgICBmb3JtYWxzID0gbWFrZUZvcm1hbHMobmV3IEJpbmRpbmdJZGVudGlmaWVyKHRyZWUubG9jYXRpb24sIHRyZWUuaWRlbnRpZmllclRva2VuKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEJJTkRJTkdfSURFTlRJRklFUjpcbiAgICAgICAgICAgIGZvcm1hbHMgPSBtYWtlRm9ybWFscyh0cmVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRk9STUFMX1BBUkFNRVRFUl9MSVNUOlxuICAgICAgICAgICAgZm9ybWFscyA9IHRyZWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZm9ybWFscyA9IHRoaXMudG9Gb3JtYWxQYXJhbWV0ZXJzXyhzdGFydCwgdHJlZSwgYXN5bmNUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKEFSUk9XKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQ29uY2lzZUJvZHlfKGZvcm1hbHMpO1xuICAgICAgICB0aGlzLnBvcEZ1bmN0aW9uU3RhdGVfKGZzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJvd0Z1bmN0aW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGFzeW5jVG9rZW4sIGZvcm1hbHMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ292ZXJGb3JtYWxzXzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGlmICghcGVlayhDTE9TRV9QQVJFTikpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrUmVzdF8odHlwZSkpIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlUmVzdFBhcmFtZXRlcl8oKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lYXRJZl8oQ09NTUEpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IHdoaWxlICghcGVlayhDTE9TRV9QQVJFTikgJiYgIWlzQXRFbmQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb3ZlckZvcm1hbHModGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIGVuc3VyZU5vQ292ZXJJbml0aWFsaXplZE5hbWVzXzogZnVuY3Rpb24odHJlZSwgY292ZXJJbml0aWFsaXplZE5hbWVDb3VudCkge1xuICAgICAgICBpZiAoY292ZXJJbml0aWFsaXplZE5hbWVDb3VudCA9PT0gdGhpcy5jb3ZlckluaXRpYWxpemVkTmFtZUNvdW50XylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBmaW5kZXIgPSBuZXcgVmFsaWRhdGVPYmplY3RMaXRlcmFsKCk7XG4gICAgICAgIGZpbmRlci52aXNpdEFueSh0cmVlKTtcbiAgICAgICAgaWYgKGZpbmRlci5mb3VuZCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IGZpbmRlci5lcnJvclRva2VuO1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRva2VuLmxvY2F0aW9uLCAoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvUHJpbWFyeUV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLnR5cGUgPT09IENPVkVSX0ZPUk1BTFMpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJGb3JtYWxzVG9QYXJlbkV4cHJlc3Npb25fKHRyZWUpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZUNvdmVyRm9ybWFsc0FzUGFyZW5FeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uc1tpXS50eXBlID09PSBSRVNUX1BBUkFNRVRFUikge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuKERPVF9ET1RfRE9ULCB0cmVlLmV4cHJlc3Npb25zW2ldLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRva2VuLmxvY2F0aW9uLCAoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdG9rZW4pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb3ZlckZvcm1hbHNUb1BhcmVuRXhwcmVzc2lvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZSA9PT0gQ09WRVJfRk9STUFMUykge1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRyZWUuZXhwcmVzc2lvbnM7XG4gICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnVW5leHBlY3RlZCB0b2tlbiApJztcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRyZWUubG9jYXRpb24sIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ292ZXJGb3JtYWxzQXNQYXJlbkV4cHJlc3Npb25fKHRyZWUpO1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnNbMF0ubG9jYXRpb24sIGV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJlbkV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRvRm9ybWFsUGFyYW1ldGVyc186IGZ1bmN0aW9uKHN0YXJ0LCB0cmVlLCBhc3luY1Rva2VuKSB7XG4gICAgICAgIHJlc2V0U2Nhbm5lcihzdGFydC5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93Rm9ybWFsUGFyYW1ldGVyc18oYXN5bmNUb2tlbik7XG4gICAgICB9LFxuICAgICAgcGFyc2VBcnJvd0Zvcm1hbFBhcmFtZXRlcnNfOiBmdW5jdGlvbihhc3luY1Rva2VuKSB7XG4gICAgICAgIGlmIChhc3luY1Rva2VuKVxuICAgICAgICAgIHRoaXMuZWF0XyhJREVOVElGSUVSKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzXygpO1xuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICAgIH0sXG4gICAgICBwZWVrQXJyb3dfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSBBUlJPVyAmJiB0aGlzLm9wdGlvbnNfLmFycm93RnVuY3Rpb25zO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ29uY2lzZUJvZHlfOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBlZWsoT1BFTl9DVVJMWSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbkJvZHlfKHBhcmFtcyk7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycyhwYXJhbXMsIHRoaXMuc3RyaWN0TW9kZV8sIHRoaXMuZXJyb3JSZXBvcnRlcl8pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICB9LFxuICAgICAgcGFyc2VHZW5lcmF0b3JDb21wcmVoZW5zaW9uXzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdmFyIGNvbXByZWhlbnNpb25MaXN0ID0gdGhpcy5wYXJzZUNvbXByZWhlbnNpb25MaXN0XygpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRvckNvbXByZWhlbnNpb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgY29tcHJlaGVuc2lvbkxpc3QsIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlRm9yQmluZGluZ186IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wZWVrUGF0dGVybl8ocGVla1R5cGUoKSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kaW5nUGF0dGVybl8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgIH0sXG4gICAgICBwZWVrUGF0dGVybl86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc18uZGVzdHJ1Y3R1cmluZyAmJiAodGhpcy5wZWVrT2JqZWN0UGF0dGVybl8odHlwZSkgfHwgdGhpcy5wZWVrQXJyYXlQYXR0ZXJuXyh0eXBlKSk7XG4gICAgICB9LFxuICAgICAgcGVla0FycmF5UGF0dGVybl86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IE9QRU5fU1FVQVJFO1xuICAgICAgfSxcbiAgICAgIHBlZWtPYmplY3RQYXR0ZXJuXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gT1BFTl9DVVJMWTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUJpbmRpbmdQYXR0ZXJuXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGF0dGVybl8odHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VQYXR0ZXJuXzogZnVuY3Rpb24odXNlQmluZGluZykge1xuICAgICAgICBpZiAodGhpcy5wZWVrQXJyYXlQYXR0ZXJuXyhwZWVrVHlwZSgpKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycmF5UGF0dGVybl8odXNlQmluZGluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0UGF0dGVybl8odXNlQmluZGluZyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VBcnJheUJpbmRpbmdQYXR0ZXJuXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlQYXR0ZXJuXyh0cnVlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVBhdHRlcm5FbGVtZW50XzogZnVuY3Rpb24odXNlQmluZGluZykge1xuICAgICAgICByZXR1cm4gdXNlQmluZGluZyA/IHRoaXMucGFyc2VCaW5kaW5nRWxlbWVudF8oKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RWxlbWVudF8oKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVBhdHRlcm5SZXN0RWxlbWVudF86IGZ1bmN0aW9uKHVzZUJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVzZUJpbmRpbmcgPyB0aGlzLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50XygpIDogdGhpcy5wYXJzZUFzc2lnbm1lbnRSZXN0RWxlbWVudF8oKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUFycmF5UGF0dGVybl86IGZ1bmN0aW9uKHVzZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1NRVUFSRSk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICAgIGlmICh0eXBlID09PSBDT01NQSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGVla1NwcmVhZF8odHlwZSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godGhpcy5wYXJzZVBhdHRlcm5SZXN0RWxlbWVudF8odXNlQmluZGluZykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBDTE9TRV9TUVVBUkUgfHwgdHlwZSA9PT0gRU5EX09GX0ZJTEUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VQYXR0ZXJuRWxlbWVudF8odXNlQmluZGluZykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gcGVla1R5cGUoKTtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gQ0xPU0VfU1FVQVJFKSB7XG4gICAgICAgICAgICB0aGlzLmVhdF8oQ09NTUEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfU1FVQVJFKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVBhdHRlcm4odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZWxlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQmluZGluZ0VsZW1lbnRMaXN0XzogZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVsaXNpb25PcHRfKGVsZW1lbnRzKTtcbiAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ0VsZW1lbnRfKCkpO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oQ09NTUEpKSB7XG4gICAgICAgICAgdGhpcy5wYXJzZUVsaXNpb25PcHRfKGVsZW1lbnRzKTtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VCaW5kaW5nRWxlbWVudF8oKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYXJzZUVsaXNpb25PcHRfOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oQ09NTUEpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBlZWtCaW5kaW5nRWxlbWVudF86IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVla0JpbmRpbmdJZGVudGlmaWVyXyh0eXBlKSB8fCB0aGlzLnBlZWtQYXR0ZXJuXyh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUJpbmRpbmdFbGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5wYXJzZUJpbmRpbmdFbGVtZW50QmluZGluZ18oKTtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy5wYXJzZUJpbmRpbmdFbGVtZW50SW5pdGlhbGl6ZXJfKElOSVRJQUxJWkVSX09QVElPTkFMKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nRWxlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBiaW5kaW5nLCBpbml0aWFsaXplcik7XG4gICAgICB9LFxuICAgICAgcGFyc2VCaW5kaW5nRWxlbWVudEJpbmRpbmdfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucGVla1BhdHRlcm5fKHBlZWtUeXBlKCkpKVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmluZGluZ1BhdHRlcm5fKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmluZGluZ0lkZW50aWZpZXJfKCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VCaW5kaW5nRWxlbWVudEluaXRpYWxpemVyXzogZnVuY3Rpb24oaW5pdGlhbGl6ZXJSZXF1aXJlZCkge1xuICAgICAgICBpZiAocGVlayhFUVVBTCkgfHwgaW5pdGlhbGl6ZXJSZXF1aXJlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5pdGlhbGl6ZXJfKEFMTE9XX0lOKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBwYXJzZUJpbmRpbmdSZXN0RWxlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oRE9UX0RPVF9ET1QpO1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucGFyc2VCaW5kaW5nSWRlbnRpZmllcl8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJlYWRQYXR0ZXJuRWxlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBpZGVudGlmaWVyKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZU9iamVjdFBhdHRlcm5fOiBmdW5jdGlvbih1c2VCaW5kaW5nKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9DVVJMWSk7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB3aGlsZSAoKHR5cGUgPSBwZWVrVHlwZSgpKSAhPT0gQ0xPU0VfQ1VSTFkgJiYgdHlwZSAhPT0gRU5EX09GX0ZJTEUpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMucGFyc2VQYXR0ZXJuUHJvcGVydHlfKHVzZUJpbmRpbmcpKTtcbiAgICAgICAgICBpZiAoIXRoaXMuZWF0SWZfKENPTU1BKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9DVVJMWSk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0UGF0dGVybih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VQYXR0ZXJuUHJvcGVydHlfOiBmdW5jdGlvbih1c2VCaW5kaW5nKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZVByb3BlcnR5TmFtZV8oKTtcbiAgICAgICAgdmFyIHJlcXVpcmVDb2xvbiA9IG5hbWUudHlwZSAhPT0gTElURVJBTF9QUk9QRVJUWV9OQU1FIHx8ICFuYW1lLmxpdGVyYWxUb2tlbi5pc1N0cmljdEtleXdvcmQoKSAmJiBuYW1lLmxpdGVyYWxUb2tlbi50eXBlICE9PSBJREVOVElGSUVSO1xuICAgICAgICBpZiAocmVxdWlyZUNvbG9uIHx8IHBlZWsoQ09MT04pKSB7XG4gICAgICAgICAgdGhpcy5lYXRfKENPTE9OKTtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VQYXR0ZXJuRWxlbWVudF8odXNlQmluZGluZyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RQYXR0ZXJuRmllbGQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuID0gbmFtZS5saXRlcmFsVG9rZW47XG4gICAgICAgIGlmICh0aGlzLnN0cmljdE1vZGVfICYmIHRva2VuLmlzU3RyaWN0S2V5d29yZCgpKVxuICAgICAgICAgIHRoaXMucmVwb3J0UmVzZXJ2ZWRJZGVudGlmaWVyXyh0b2tlbik7XG4gICAgICAgIGlmICh1c2VCaW5kaW5nKSB7XG4gICAgICAgICAgdmFyIGJpbmRpbmcgPSBuZXcgQmluZGluZ0lkZW50aWZpZXIobmFtZS5sb2NhdGlvbiwgdG9rZW4pO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciRfXzE4ID0gdGhpcy5wYXJzZUluaXRpYWxpemVyT3B0XyhBTExPV19JTik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nRWxlbWVudCh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBiaW5kaW5nLCBpbml0aWFsaXplciRfXzE4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXNzaWdubWVudCA9IG5ldyBJZGVudGlmaWVyRXhwcmVzc2lvbihuYW1lLmxvY2F0aW9uLCB0b2tlbik7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMucGFyc2VJbml0aWFsaXplck9wdF8oQUxMT1dfSU4pO1xuICAgICAgICByZXR1cm4gbmV3IEFzc2lnbm1lbnRFbGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGFzc2lnbm1lbnQsIGluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUFzc2lnbm1lbnRQYXR0ZXJuXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGF0dGVybl8oZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXJyYXlBc3NpZ25tZW50UGF0dGVybl86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycmF5UGF0dGVybl8oZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXNzaWdubWVudEVsZW1lbnRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSB0aGlzLnBhcnNlRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRfKCk7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMucGFyc2VJbml0aWFsaXplck9wdF8oQUxMT1dfSU4pO1xuICAgICAgICByZXR1cm4gbmV3IEFzc2lnbm1lbnRFbGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGFzc2lnbm1lbnQsIGluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZURlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgIGNhc2UgT1BFTl9TUVVBUkU6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycmF5QXNzaWdubWVudFBhdHRlcm5fKCk7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RBc3NpZ25tZW50UGF0dGVybl8oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXygpO1xuICAgICAgICBleHByZXNzaW9uID0gdGhpcy5jb3ZlckZvcm1hbHNUb1BhcmVuRXhwcmVzc2lvbl8oZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMudmFsaWRhdGVBc3NpZ25tZW50VGFyZ2V0XyhleHByZXNzaW9uLCAnYXNzaWdubWVudCcpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH0sXG4gICAgICBwYXJzZUFzc2lnbm1lbnRSZXN0RWxlbWVudF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oRE9UX0RPVF9ET1QpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3ByZWFkUGF0dGVybkVsZW1lbnQodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgaWQpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlT2JqZWN0QXNzaWdubWVudFBhdHRlcm5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RQYXR0ZXJuXyhmYWxzZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VBc3NpZ25tZW50UHJvcGVydHlfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXR0ZXJuUHJvcGVydHlfKGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVRlbXBsYXRlTGl0ZXJhbF86IGZ1bmN0aW9uKG9wZXJhbmQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gb3BlcmFuZCA/IG9wZXJhbmQubG9jYXRpb24uc3RhcnQgOiB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW25ldyBUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uKHRva2VuLmxvY2F0aW9uLCB0b2tlbildO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gTk9fU1VCU1RJVFVUSU9OX1RFTVBMQVRFKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG9wZXJhbmQsIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uXyhBTExPV19JTik7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IFRlbXBsYXRlU3Vic3RpdHV0aW9uKGV4cHJlc3Npb24ubG9jYXRpb24sIGV4cHJlc3Npb24pKTtcbiAgICAgICAgd2hpbGUgKGV4cHJlc3Npb24udHlwZSAhPT0gU1lOVEFYX0VSUk9SX1RSRUUpIHtcbiAgICAgICAgICB0b2tlbiA9IG5leHRUZW1wbGF0ZUxpdGVyYWxUb2tlbigpO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSBFUlJPUiB8fCB0b2tlbi50eXBlID09PSBFTkRfT0ZfRklMRSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IFRlbXBsYXRlTGl0ZXJhbFBvcnRpb24odG9rZW4ubG9jYXRpb24sIHRva2VuKSk7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRFTVBMQVRFX1RBSUwpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBUZW1wbGF0ZVN1YnN0aXR1dGlvbihleHByZXNzaW9uLmxvY2F0aW9uLCBleHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG9wZXJhbmQsIGVsZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVR5cGVBbm5vdGF0aW9uT3B0XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnR5cGVzICYmIHRoaXMuZWF0T3B0XyhDT0xPTikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgcGFyc2VUeXBlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAocGVla1R5cGUoKSkge1xuICAgICAgICAgIGNhc2UgTkVXOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb25zdHJ1Y3RvclR5cGVfKCk7XG4gICAgICAgICAgY2FzZSBPUEVOX1BBUkVOOlxuICAgICAgICAgIGNhc2UgT1BFTl9BTkdMRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25UeXBlXygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHRoaXMucGFyc2VQcmltYXJ5VHlwZV8oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVbmlvblR5cGVTdWZmaXhfKHN0YXJ0LCBlbGVtZW50VHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VQcmltYXJ5VHlwZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUsXG4gICAgICAgICAgICB0b2tlbjtcbiAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBWT0lEOlxuICAgICAgICAgICAgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIGVsZW1lbnRUeXBlID0gbmV3IFByZWRlZmluZWRUeXBlKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHRva2VuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSURFTlRJRklFUjpcbiAgICAgICAgICAgIHN3aXRjaCAocGVla1Rva2VuKCkudmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50VHlwZSA9IG5ldyBQcmVkZWZpbmVkVHlwZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZWxlbWVudFR5cGUgPSB0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgVFlQRU9GOlxuICAgICAgICAgICAgZWxlbWVudFR5cGUgPSB0aGlzLnBhcnNlVHlwZVF1ZXJ5XyhzdGFydCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICAgICAgICBlbGVtZW50VHlwZSA9IHRoaXMucGFyc2VPYmplY3RUeXBlXygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVW5leHBlY3RlZFRva2VuXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlUeXBlU3VmZml4XyhzdGFydCwgZWxlbWVudFR5cGUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVHlwZVJlZmVyZW5jZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLnBhcnNlVHlwZU5hbWVfKCk7XG4gICAgICAgIHZhciBhcmdzID0gbnVsbDtcbiAgICAgICAgaWYgKHBlZWsoT1BFTl9BTkdMRSkpIHtcbiAgICAgICAgICB2YXIgYXJncyRfXzE5ID0gdGhpcy5wYXJzZVR5cGVBcmd1bWVudHNfKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUeXBlUmVmZXJlbmNlKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHR5cGVOYW1lLCBhcmdzJF9fMTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlTmFtZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVVuaW9uVHlwZVN1ZmZpeF86IGZ1bmN0aW9uKHN0YXJ0LCBlbGVtZW50VHlwZSkge1xuICAgICAgICBpZiAocGVlayhCQVIpKSB7XG4gICAgICAgICAgdmFyIHR5cGVzID0gW2VsZW1lbnRUeXBlXTtcbiAgICAgICAgICB0aGlzLmVhdF8oQkFSKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdHlwZXMucHVzaCh0aGlzLnBhcnNlUHJpbWFyeVR5cGVfKCkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVhdElmXyhCQVIpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVuaW9uVHlwZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRUeXBlO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQXJyYXlUeXBlU3VmZml4XzogZnVuY3Rpb24oc3RhcnQsIGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IoKTtcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUgPT09IE9QRU5fU1FVQVJFKSB7XG4gICAgICAgICAgdGhpcy5lYXRfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfU1FVQVJFKTtcbiAgICAgICAgICBlbGVtZW50VHlwZSA9IG5ldyBBcnJheVR5cGUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZWxlbWVudFR5cGUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlUeXBlU3VmZml4XyhzdGFydCwgZWxlbWVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50VHlwZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZVR5cGVBcmd1bWVudHNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQU5HTEUpO1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLnBhcnNlVHlwZV8oKV07XG4gICAgICAgIHdoaWxlIChwZWVrKENPTU1BKSkge1xuICAgICAgICAgIHRoaXMuZWF0XyhDT01NQSk7XG4gICAgICAgICAgYXJncy5wdXNoKHRoaXMucGFyc2VUeXBlXygpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0Q2xvc2VBbmdsZSgpO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gQ0xPU0VfQU5HTEUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVuZXhwZWN0ZWRUb2tlbl8odG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUFyZ3VtZW50cyh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUNvbnN0cnVjdG9yVHlwZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdF8oTkVXKTtcbiAgICAgICAgdmFyIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZVR5cGVQYXJhbWV0ZXJzT3B0XygpO1xuICAgICAgICB0aGlzLmVhdF8oT1BFTl9QQVJFTik7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnNfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHRoaXMuZWF0XyhBUlJPVyk7XG4gICAgICAgIHZhciByZXR1cm5UeXBlID0gdGhpcy5wYXJzZVR5cGVfKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JUeXBlKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHR5cGVQYXJhbWV0ZXJzLCBwYXJhbWV0ZXJMaXN0LCByZXR1cm5UeXBlKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZU9iamVjdFR5cGVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHR5cGVNZW1iZXJzID0gW107XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX0NVUkxZKTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWtUeXBlTWVtYmVyXyh0eXBlID0gcGVla1R5cGUoKSkpIHtcbiAgICAgICAgICB0eXBlTWVtYmVycy5wdXNoKHRoaXMucGFyc2VUeXBlTWVtYmVyXyh0eXBlKSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmVhdElmXyhTRU1JX0NPTE9OKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWF0XyhDTE9TRV9DVVJMWSk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0VHlwZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCB0eXBlTWVtYmVycyk7XG4gICAgICB9LFxuICAgICAgcGVla1R5cGVNZW1iZXJfOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgTkVXOlxuICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTjpcbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICBjYXNlIElERU5USUZJRVI6XG4gICAgICAgICAgY2FzZSBTVFJJTkc6XG4gICAgICAgICAgY2FzZSBOVU1CRVI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHBlZWtUb2tlbigpLmlzS2V5d29yZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VUeXBlTWVtYmVyXzogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIE5FVzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29uc3RydWN0U2lnbmF0dXJlXygpO1xuICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTjpcbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxTaWduYXR1cmVfKCk7XG4gICAgICAgICAgY2FzZSBPUEVOX1NRVUFSRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5kZXhTaWduYXR1cmVfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHRoaXMucGFyc2VMaXRlcmFsUHJvcGVydHlOYW1lXygpO1xuICAgICAgICB2YXIgaXNPcHQgPSB0aGlzLmVhdElmXyhRVUVTVElPTik7XG4gICAgICAgIHR5cGUgPSBwZWVrVHlwZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gT1BFTl9BTkdMRSB8fCB0eXBlID09PSBPUEVOX1BBUkVOKSB7XG4gICAgICAgICAgdmFyIGNhbGxTaWduYXR1cmUgPSB0aGlzLnBhcnNlQ2FsbFNpZ25hdHVyZV8oKTtcbiAgICAgICAgICByZXR1cm4gbmV3IE1ldGhvZFNpZ25hdHVyZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBwcm9wZXJ0eU5hbWUsIGlzT3B0LCBjYWxsU2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnBhcnNlVHlwZUFubm90YXRpb25PcHRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlTaWduYXR1cmUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgcHJvcGVydHlOYW1lLCBpc09wdCwgdHlwZUFubm90YXRpb24pO1xuICAgICAgfSxcbiAgICAgIHBhcnNlQ2FsbFNpZ25hdHVyZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlVHlwZVBhcmFtZXRlcnNPcHRfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyc18oKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdmFyIHJldHVyblR5cGUgPSB0aGlzLnBhcnNlVHlwZUFubm90YXRpb25PcHRfKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbFNpZ25hdHVyZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCB0eXBlUGFyYW1ldGVycywgcGFyYW1ldGVyTGlzdCwgcmV0dXJuVHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VDb25zdHJ1Y3RTaWduYXR1cmVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE5FVyk7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHRoaXMucGFyc2VUeXBlUGFyYW1ldGVyc09wdF8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fUEFSRU4pO1xuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzXygpO1xuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB2YXIgcmV0dXJuVHlwZSA9IHRoaXMucGFyc2VUeXBlQW5ub3RhdGlvbk9wdF8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RTaWduYXR1cmUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgdHlwZVBhcmFtZXRlcnMsIHBhcmFtZXRlckxpc3QsIHJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlSW5kZXhTaWduYXR1cmVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5lYXRJZF8oKTtcbiAgICAgICAgdGhpcy5lYXRfKENPTE9OKTtcbiAgICAgICAgdmFyIHR5cGVOYW1lO1xuICAgICAgICB2YXIgdHlwZVN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgaWYgKHRoaXMucGVla1ByZWRlZmluZWRTdHJpbmdfKCdzdHJpbmcnKSkge1xuICAgICAgICAgIHR5cGVOYW1lID0gdGhpcy5lYXRJZF8oJ3N0cmluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVOYW1lID0gdGhpcy5lYXRJZF8oJ251bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleFR5cGUgPSBuZXcgUHJlZGVmaW5lZFR5cGUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHR5cGVTdGFydCksIHR5cGVOYW1lKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1NRVUFSRSk7XG4gICAgICAgIHRoaXMuZWF0XyhDT0xPTik7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMucGFyc2VUeXBlXygpO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4U2lnbmF0dXJlKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIGlkLCBpbmRleFR5cGUsIHR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUZ1bmN0aW9uVHlwZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlVHlwZVBhcmFtZXRlcnNPcHRfKCk7XG4gICAgICAgIHRoaXMuZWF0XyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVyc18oKTtcbiAgICAgICAgdGhpcy5lYXRfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy5lYXRfKEFSUk9XKTtcbiAgICAgICAgdmFyIHJldHVyblR5cGUgPSB0aGlzLnBhcnNlVHlwZV8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvblR5cGUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgdHlwZVBhcmFtZXRlcnMsIHBhcmFtZXRlckxpc3QsIHJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVHlwZVF1ZXJ5XzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgJ05ZSSc7XG4gICAgICB9LFxuICAgICAgcGVla1R5cGVQYXJhbWV0ZXJzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwZWVrKE9QRU5fQU5HTEUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVHlwZVBhcmFtZXRlcnNPcHRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHBlZWsoT1BFTl9BTkdMRSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVQYXJhbWV0ZXJzXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVHlwZVBhcmFtZXRlcnNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdGhpcy5lYXRfKE9QRU5fQU5HTEUpO1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IFt0aGlzLnBhcnNlVHlwZVBhcmFtZXRlcl8oKV07XG4gICAgICAgIHdoaWxlIChwZWVrKENPTU1BKSkge1xuICAgICAgICAgIHRoaXMuZWF0XyhDT01NQSk7XG4gICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHRoaXMucGFyc2VUeXBlUGFyYW1ldGVyXygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfQU5HTEUpO1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVQYXJhbWV0ZXJzKHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIHBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlVHlwZVBhcmFtZXRlcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmVhdElkXygpO1xuICAgICAgICB2YXIgZXh0ZW5kc1R5cGUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5lYXRJZl8oRVhURU5EUykpIHtcbiAgICAgICAgICBleHRlbmRzVHlwZSA9IHRoaXMucGFyc2VUeXBlXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHlwZVBhcmFtZXRlcih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBpZCwgZXh0ZW5kc1R5cGUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlTmFtZWRPclByZWRlZmluZWRUeXBlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHN3aXRjaCAocGVla1Rva2VuKCkudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdhbnknOlxuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHRva2VuID0gbmV4dFRva2VuKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZGVmaW5lZFR5cGUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgdG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVOYW1lXygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2VUeXBlTmFtZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmVhdElkXygpO1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSBuZXcgVHlwZU5hbWUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbnVsbCwgaWQpO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oUEVSSU9EKSkge1xuICAgICAgICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5lYXRJZE5hbWVfKCk7XG4gICAgICAgICAgdHlwZU5hbWUgPSBuZXcgVHlwZU5hbWUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgdHlwZU5hbWUsIG1lbWJlck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlTmFtZTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUludGVyZmFjZURlY2xhcmF0aW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0VHJlZVN0YXJ0TG9jYXRpb25fKCk7XG4gICAgICAgIHRoaXMuZWF0XyhJTlRFUkZBQ0UpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZWF0SWRfKCk7XG4gICAgICAgIHZhciB0eXBlUGFyYW1ldGVycyA9IHRoaXMucGFyc2VUeXBlUGFyYW1ldGVyc09wdF8oKTtcbiAgICAgICAgdmFyIGV4dGVuZHNDbGF1c2U7XG4gICAgICAgIGlmICh0aGlzLmVhdElmXyhFWFRFTkRTKSkge1xuICAgICAgICAgIGV4dGVuZHNDbGF1c2UgPSB0aGlzLnBhcnNlSW50ZXJmYWNlRXh0ZW5kc0NsYXVzZV8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRlbmRzQ2xhdXNlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iamVjdFR5cGUgPSB0aGlzLnBhcnNlT2JqZWN0VHlwZV8oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2VEZWNsYXJhdGlvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBuYW1lLCB0eXBlUGFyYW1ldGVycywgZXh0ZW5kc0NsYXVzZSwgb2JqZWN0VHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VJbnRlcmZhY2VFeHRlbmRzQ2xhdXNlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbdGhpcy5wYXJzZVR5cGVSZWZlcmVuY2VfKCldO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXRJZl8oQ09NTUEpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5wYXJzZVR5cGVSZWZlcmVuY2VfKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgcGFyc2VBbm5vdGF0ZWREZWNsYXJhdGlvbnNfOiBmdW5jdGlvbihwYXJzaW5nTW9kdWxlSXRlbSkge1xuICAgICAgICB0aGlzLnB1c2hBbm5vdGF0aW9uc18oKTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uO1xuICAgICAgICB2YXIgdHlwZSA9IHBlZWtUeXBlKCk7XG4gICAgICAgIGlmIChwYXJzaW5nTW9kdWxlSXRlbSkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1vZHVsZUl0ZW1fKHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudExpc3RJdGVtXyh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uc18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRoaXMuYW5ub3RhdGlvbnNfWzBdLmxvY2F0aW9uLCAnVW5zdXBwb3J0ZWQgYW5ub3RhdGVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgICB9LFxuICAgICAgcGFyc2VBbm5vdGF0aW9uc186IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0SWZfKEFUKSkge1xuICAgICAgICAgIGFubm90YXRpb25zLnB1c2godGhpcy5wYXJzZUFubm90YXRpb25fKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgICAgIH0sXG4gICAgICBwdXNoQW5ub3RhdGlvbnNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uc18gPSB0aGlzLnBhcnNlQW5ub3RhdGlvbnNfKCk7XG4gICAgICB9LFxuICAgICAgcG9wQW5ub3RhdGlvbnNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0aW9uc187XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnNfID0gW107XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgICAgIH0sXG4gICAgICBwYXJzZUFubm90YXRpb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRUcmVlU3RhcnRMb2NhdGlvbl8oKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWVtYmVyRXhwcmVzc2lvbk5vTmV3XygpO1xuICAgICAgICB2YXIgYXJncyA9IG51bGw7XG4gICAgICAgIGlmIChwZWVrKE9QRU5fUEFSRU4pKVxuICAgICAgICAgIGFyZ3MgPSB0aGlzLnBhcnNlQXJndW1lbnRzXygpO1xuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgZXhwcmVzc2lvbiwgYXJncyk7XG4gICAgICB9LFxuICAgICAgcGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldFRyZWVTdGFydExvY2F0aW9uXygpO1xuICAgICAgICB0aGlzLmVhdElkXyhUWVBFKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmVhdElkXygpO1xuICAgICAgICB0aGlzLmVhdF8oRVFVQUwpO1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VUeXBlXygpO1xuICAgICAgICB0aGlzLmVhdFBvc3NpYmxlSW1wbGljaXRTZW1pQ29sb25fKCk7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUFsaWFzRGVjbGFyYXRpb24odGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZSwgdHlwZSk7XG4gICAgICB9LFxuICAgICAgcGFyc2VKc3hFbGVtZW50XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuZWF0SnN4XyhPUEVOX0FOR0xFKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VKc3hFbGVtZW50Q29udGludWF0aW9uXyh0b2tlbi5sb2NhdGlvbi5zdGFydCk7XG4gICAgICB9LFxuICAgICAgcGFyc2VKc3hFbGVtZW50Q29udGludWF0aW9uXzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSnN4RWxlbWVudE5hbWVfKCk7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMucGFyc2VKc3hBdHRyaWJ1dGVzXygpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgc3dpdGNoIChwZWVrSnN4VG9rZW4oKS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBTTEFTSDpcbiAgICAgICAgICAgIG5leHRKc3hUb2tlbigpO1xuICAgICAgICAgICAgdGhpcy5lYXRfKENMT1NFX0FOR0xFKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgQ0xPU0VfQU5HTEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5leHRKc3hUZXh0VG9rZW4oKTtcbiAgICAgICAgICAgICAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0SnN4VGV4dFRva2VuKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFNUUklORzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IEpzeFRleHQodG9rZW4ubG9jYXRpb24sIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCRfXzIwID0gdG9rZW4ubG9jYXRpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcGVlayhDTE9TRV9DVVJMWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXRKc3hfKENMT1NFX0NVUkxZKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2VIb2xkZXIgPSBuZXcgSnN4UGxhY2Vob2xkZXIodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0JF9fMjApLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHBsYWNlSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBPUEVOX0FOR0xFOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0JF9fMjEgPSB0b2tlbi5sb2NhdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVla0pzeFRva2VuKCkudHlwZSA9PT0gU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRKc3hUb2tlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YkVsZW1lbnQgPSB0aGlzLnBhcnNlSnN4RWxlbWVudENvbnRpbnVhdGlvbl8oc3RhcnQkX18yMSk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzdWJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXNldFNjYW5uZXIoc3ViRWxlbWVudC5sb2NhdGlvbi5lbmQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTeW50YXhFcnJvcl8oJ1VuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNsb3NlTmFtZSA9IHRoaXMucGFyc2VKc3hFbGVtZW50TmFtZV8oKTtcbiAgICAgICAgICAgICAgaWYgKCFqc3hOYW1lc0VxdWFsKG5hbWUsIGNsb3NlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yXyhjbG9zZU5hbWUubG9jYXRpb24sIChcIk5vbiBtYXRjaGluZyBKU1ggY2xvc2luZyB0YWcuIEV4cGVjdGVkIFwiICsganN4TmFtZVRvU3RyaW5nKG5hbWUpICsgXCIsIGZvdW5kIFwiICsganN4TmFtZVRvU3RyaW5nKGNsb3NlTmFtZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmVhdF8oQ0xPU0VfQU5HTEUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTeW50YXhFcnJvcl8oJ1VuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBKc3hFbGVtZW50KHRoaXMuZ2V0VHJlZUxvY2F0aW9uXyhzdGFydCksIG5hbWUsIGF0dHJzLCBjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICAgIHBhcnNlSnN4RWxlbWVudE5hbWVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmVhdEpzeF8oSlNYX0lERU5USUZJRVIpO1xuICAgICAgICB2YXIgc3RhcnQgPSBpZC5sb2NhdGlvbi5zdGFydDtcbiAgICAgICAgdG9rZW5zLnB1c2goaWQpO1xuICAgICAgICB3aGlsZSAocGVla0pzeFRva2VuKCkudHlwZSA9PT0gUEVSSU9EKSB7XG4gICAgICAgICAgbmV4dEpzeFRva2VuKCk7XG4gICAgICAgICAgdmFyIGlkJF9fMjIgPSB0aGlzLmVhdEpzeF8oSlNYX0lERU5USUZJRVIpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKGlkJF9fMjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSnN4RWxlbWVudE5hbWUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgdG9rZW5zKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUpzeEF0dHJpYnV0ZXNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKHBlZWtKc3hUb2tlbigpLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgSlNYX0lERU5USUZJRVI6XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLnBhcnNlSnN4QXR0cmlidXRlXygpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFk6XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLnBhcnNlSnN4U3ByZWFkQXR0cmlidXRlXygpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sXG4gICAgICBwYXJzZUpzeEF0dHJpYnV0ZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZWF0SnN4XyhKU1hfSURFTlRJRklFUik7XG4gICAgICAgIHZhciBzdGFydCA9IG5hbWUubG9jYXRpb24uc3RhcnQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChwZWVrSnN4VG9rZW4oKS50eXBlID09PSBFUVVBTCkge1xuICAgICAgICAgIHRoaXMuZWF0SnN4XyhFUVVBTCk7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSnN4QXR0cmlidXRlVmFsdWVfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBKc3hBdHRyaWJ1dGUodGhpcy5nZXRUcmVlTG9jYXRpb25fKHN0YXJ0KSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHBhcnNlSnN4QXR0cmlidXRlVmFsdWVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGVla0pzeFRva2VuKCk7XG4gICAgICAgIHZhciBzdGFydCA9IHRva2VuLmxvY2F0aW9uLnN0YXJ0O1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNUUklORzpcbiAgICAgICAgICAgIG5leHRKc3hUb2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCB0b2tlbik7XG4gICAgICAgICAgY2FzZSBPUEVOX0NVUkxZOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuZXh0SnN4VG9rZW4oKTtcbiAgICAgICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb25fKEFMTE9XX0lOKTtcbiAgICAgICAgICAgICAgdGhpcy5lYXRKc3hfKENMT1NFX0NVUkxZKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBKc3hQbGFjZWhvbGRlcih0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUpzeEVsZW1lbnRfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTeW50YXhFcnJvcl8oJ1VuZXhwZWN0ZWQgdG9rZW4nKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZUpzeFNwcmVhZEF0dHJpYnV0ZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrSnN4VG9rZW4oKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdG9rZW4ubG9jYXRpb24uc3RhcnQ7XG4gICAgICAgIG5leHRKc3hUb2tlbigpO1xuICAgICAgICB0aGlzLmVhdEpzeF8oRE9UX0RPVF9ET1QpO1xuICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbl8oQUxMT1dfSU4pO1xuICAgICAgICB0aGlzLmVhdEpzeF8oQ0xPU0VfQ1VSTFkpO1xuICAgICAgICByZXR1cm4gbmV3IEpzeFNwcmVhZEF0dHJpYnV0ZSh0aGlzLmdldFRyZWVMb2NhdGlvbl8oc3RhcnQpLCBleHByKTtcbiAgICAgIH0sXG4gICAgICBlYXRQb3NzaWJsZUltcGxpY2l0U2VtaUNvbG9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IoKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgU0VNSV9DT0xPTjpcbiAgICAgICAgICAgIG5leHRUb2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgRU5EX09GX0ZJTEU6XG4gICAgICAgICAgY2FzZSBDTE9TRV9DVVJMWTpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG9ydEVycm9yXyh0b2tlbi5sb2NhdGlvbiwgJ1NlbWktY29sb24gZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICBwZWVrSW1wbGljaXRTZW1pQ29sb25fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3dpdGNoIChwZWVrVHlwZSgpKSB7XG4gICAgICAgICAgY2FzZSBTRU1JX0NPTE9OOlxuICAgICAgICAgIGNhc2UgQ0xPU0VfQ1VSTFk6XG4gICAgICAgICAgY2FzZSBFTkRfT0ZfRklMRTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWtUb2tlbk5vTGluZVRlcm1pbmF0b3IoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuID09PSBudWxsO1xuICAgICAgfSxcbiAgICAgIGVhdE9wdF86IGZ1bmN0aW9uKGV4cGVjdGVkVG9rZW5UeXBlKSB7XG4gICAgICAgIGlmIChwZWVrKGV4cGVjdGVkVG9rZW5UeXBlKSlcbiAgICAgICAgICByZXR1cm4gbmV4dFRva2VuKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGVhdElkT3B0XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwZWVrKElERU5USUZJRVIpID8gdGhpcy5lYXRJZF8oKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZWF0SWRfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgdG9rZW4gPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IElERU5USUZJRVIpIHtcbiAgICAgICAgICBpZiAoZXhwZWN0ZWQgJiYgdG9rZW4udmFsdWUgIT09IGV4cGVjdGVkKVxuICAgICAgICAgICAgdGhpcy5yZXBvcnRFeHBlY3RlZEVycm9yXyh0b2tlbiwgZXhwZWN0ZWQpO1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4uaXNTdHJpY3RLZXl3b3JkKCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdHJpY3RNb2RlXykge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRSZXNlcnZlZElkZW50aWZpZXJfKHRva2VuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyVG9rZW4odG9rZW4ubG9jYXRpb24sIHRva2VuLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEV4cGVjdGVkRXJyb3JfKHRva2VuLCBleHBlY3RlZCB8fCAnaWRlbnRpZmllcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0sXG4gICAgICBlYXRJZE5hbWVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHQgPSBuZXh0VG9rZW4oKTtcbiAgICAgICAgaWYgKHQudHlwZSAhPT0gSURFTlRJRklFUikge1xuICAgICAgICAgIGlmICghdC5pc0tleXdvcmQoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFeHBlY3RlZEVycm9yXyh0LCAnaWRlbnRpZmllcicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllclRva2VuKHQubG9jYXRpb24sIHQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9LFxuICAgICAgZWF0XzogZnVuY3Rpb24oZXhwZWN0ZWRUb2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFeHBlY3RlZFRva2VuXyhuZXh0VG9rZW4oKSwgZXhwZWN0ZWRUb2tlblR5cGUpO1xuICAgICAgfSxcbiAgICAgIGVhdElmXzogZnVuY3Rpb24oZXhwZWN0ZWRUb2tlblR5cGUpIHtcbiAgICAgICAgaWYgKHBlZWsoZXhwZWN0ZWRUb2tlblR5cGUpKSB7XG4gICAgICAgICAgbmV4dFRva2VuKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGVhdEpzeF86IGZ1bmN0aW9uKGV4cGVjdGVkVG9rZW5UeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRXhwZWN0ZWRUb2tlbl8obmV4dEpzeFRva2VuKCksIGV4cGVjdGVkVG9rZW5UeXBlKTtcbiAgICAgIH0sXG4gICAgICBpc0V4cGVjdGVkVG9rZW5fOiBmdW5jdGlvbih0b2tlbiwgZXhwZWN0ZWRUb2tlblR5cGUpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IGV4cGVjdGVkVG9rZW5UeXBlKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFeHBlY3RlZEVycm9yXyh0b2tlbiwgZXhwZWN0ZWRUb2tlblR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0sXG4gICAgICByZXBvcnRFeHBlY3RlZEVycm9yXzogZnVuY3Rpb24odG9rZW4sIGV4cGVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRva2VuLmxvY2F0aW9uLCAoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdG9rZW4pKTtcbiAgICAgIH0sXG4gICAgICBnZXRUcmVlU3RhcnRMb2NhdGlvbl86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGVla0xvY2F0aW9uKCkuc3RhcnQ7XG4gICAgICB9LFxuICAgICAgZ2V0VHJlZUVuZExvY2F0aW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXN0VG9rZW4oKS5sb2NhdGlvbi5lbmQ7XG4gICAgICB9LFxuICAgICAgZ2V0VHJlZUxvY2F0aW9uXzogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VSYW5nZShzdGFydCwgdGhpcy5nZXRUcmVlRW5kTG9jYXRpb25fKCkpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNvbW1lbnQ6IGZ1bmN0aW9uKHJhbmdlKSB7fSxcbiAgICAgIGlzQXRFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNBdEVuZCgpO1xuICAgICAgfSxcbiAgICAgIHJlcG9ydEVycm9yXzogZnVuY3Rpb24obG9jYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lcnJvclJlcG9ydGVyXy5yZXBvcnRFcnJvcihsb2NhdGlvbiwgbWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgcmVwb3J0UmVzZXJ2ZWRJZGVudGlmaWVyXzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcl8odG9rZW4ubG9jYXRpb24sICh0b2tlbi50eXBlICsgXCIgaXMgYSByZXNlcnZlZCBpZGVudGlmaWVyXCIpKTtcbiAgICAgIH0sXG4gICAgICB2YWxpZGF0ZUFzc2lnbm1lbnRUYXJnZXRfOiBmdW5jdGlvbih0cmVlLCBvcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCF0cmVlLmlzUGF0dGVybigpICYmICFpc1ZhbGlkU2ltcGxlQXNzaWdubWVudFRhcmdldCh0cmVlLCB0aGlzLnN0cmljdE1vZGVfKSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKHRyZWUubG9jYXRpb24sIChcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgZXhwcmVzc2lvbiBpbiBcIiArIG9wZXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIGpzeE5hbWVzRXF1YWwobmFtZSwgb3RoZXIpIHtcbiAgICBpZiAobmFtZS5uYW1lcy5sZW5ndGggIT09IG90aGVyLm5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuYW1lLm5hbWVzW2ldLnZhbHVlICE9PSBvdGhlci5uYW1lc1tpXS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGpzeE5hbWVUb1N0cmluZyhuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUubmFtZXMuam9pbignLicpO1xuICB9XG4gIHJldHVybiB7Z2V0IFBhcnNlcigpIHtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvdXRpbC9Tb3VyY2VQb3NpdGlvbi5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvU291cmNlUG9zaXRpb24uanNcIjtcbiAgdmFyIFNvdXJjZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU291cmNlUG9zaXRpb24oc291cmNlLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxpbmVfID0gLTE7XG4gICAgICB0aGlzLmNvbHVtbl8gPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFNvdXJjZVBvc2l0aW9uLCB7XG4gICAgICBnZXQgbGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZV8gPT09IC0xKVxuICAgICAgICAgIHRoaXMubGluZV8gPSB0aGlzLnNvdXJjZS5saW5lTnVtYmVyVGFibGUuZ2V0TGluZSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVfO1xuICAgICAgfSxcbiAgICAgIGdldCBjb2x1bW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbl8gPT09IC0xKVxuICAgICAgICAgIHRoaXMuY29sdW1uXyA9IHRoaXMuc291cmNlLmxpbmVOdW1iZXJUYWJsZS5nZXRDb2x1bW4odGhpcy5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5fO1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnNvdXJjZSA/IHRoaXMuc291cmNlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIChuYW1lICsgXCI6XCIgKyAodGhpcy5saW5lICsgMSkgKyBcIjpcIiArICh0aGlzLmNvbHVtbiArIDEpKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgU291cmNlUG9zaXRpb24oKSB7XG4gICAgICByZXR1cm4gU291cmNlUG9zaXRpb247XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpbmVOdW1iZXJUYWJsZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9MaW5lTnVtYmVyVGFibGUuanNcIjtcbiAgdmFyIFNvdXJjZVBvc2l0aW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU291cmNlUG9zaXRpb24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9MaW5lTnVtYmVyVGFibGUuanNcIikpLlNvdXJjZVBvc2l0aW9uO1xuICB2YXIgU291cmNlUmFuZ2UgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9Tb3VyY2VSYW5nZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpbmVOdW1iZXJUYWJsZS5qc1wiKSkuU291cmNlUmFuZ2U7XG4gIHZhciBpc0xpbmVUZXJtaW5hdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU2Nhbm5lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L0xpbmVOdW1iZXJUYWJsZS5qc1wiKSkuaXNMaW5lVGVybWluYXRvcjtcbiAgdmFyIE1BWF9JTlRfUkVQUkVTRU5UQVRJT04gPSA5MDA3MTk5MjU0NzQwOTkyO1xuICBmdW5jdGlvbiBjb21wdXRlTGluZVN0YXJ0T2Zmc2V0cyhzb3VyY2UpIHtcbiAgICB2YXIgbGluZVN0YXJ0T2Zmc2V0cyA9IFswXTtcbiAgICB2YXIgayA9IDE7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHNvdXJjZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY29kZSkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDEzICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsaW5lU3RhcnRPZmZzZXRzW2srK10gPSBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVTdGFydE9mZnNldHNbaysrXSA9IE1BWF9JTlRfUkVQUkVTRU5UQVRJT047XG4gICAgcmV0dXJuIGxpbmVTdGFydE9mZnNldHM7XG4gIH1cbiAgdmFyIExpbmVOdW1iZXJUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExpbmVOdW1iZXJUYWJsZShzb3VyY2VGaWxlKSB7XG4gICAgICB0aGlzLnNvdXJjZUZpbGVfID0gc291cmNlRmlsZTtcbiAgICAgIHRoaXMubGluZVN0YXJ0T2Zmc2V0c18gPSBudWxsO1xuICAgICAgdGhpcy5sYXN0TGluZV8gPSAwO1xuICAgICAgdGhpcy5sYXN0T2Zmc2V0XyA9IC0xO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTGluZU51bWJlclRhYmxlLCB7XG4gICAgICBlbnN1cmVMaW5lU3RhcnRPZmZzZXRzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lU3RhcnRPZmZzZXRzXykge1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0T2Zmc2V0c18gPSBjb21wdXRlTGluZVN0YXJ0T2Zmc2V0cyh0aGlzLnNvdXJjZUZpbGVfLmNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFNvdXJjZVBvc2l0aW9uOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VQb3NpdGlvbih0aGlzLnNvdXJjZUZpbGVfLCBvZmZzZXQpO1xuICAgICAgfSxcbiAgICAgIGdldExpbmU6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB0aGlzLmxhc3RPZmZzZXRfKVxuICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RMaW5lXztcbiAgICAgICAgdGhpcy5lbnN1cmVMaW5lU3RhcnRPZmZzZXRzXygpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgIGlmIChvZmZzZXQgPCB0aGlzLmxhc3RPZmZzZXRfKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGFzdExpbmVfOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0T2Zmc2V0c19baV0gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGxpbmUgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSRfXzEgPSB0aGlzLmxhc3RMaW5lXzsgdHJ1ZTsgaSRfXzErKykge1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0T2Zmc2V0c19baSRfXzFdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGxpbmUgPSBpJF9fMSAtIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RMaW5lXyA9IGxpbmU7XG4gICAgICAgIHRoaXMubGFzdE9mZnNldF8gPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgfSxcbiAgICAgIG9mZnNldE9mTGluZTogZnVuY3Rpb24obGluZSkge1xuICAgICAgICB0aGlzLmVuc3VyZUxpbmVTdGFydE9mZnNldHNfKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVTdGFydE9mZnNldHNfW2xpbmVdO1xuICAgICAgfSxcbiAgICAgIGdldENvbHVtbjogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgLSB0aGlzLmxpbmVTdGFydE9mZnNldHNfW2xpbmVdO1xuICAgICAgfSxcbiAgICAgIGdldFNvdXJjZVJhbmdlOiBmdW5jdGlvbihzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU291cmNlUmFuZ2UodGhpcy5nZXRTb3VyY2VQb3NpdGlvbihzdGFydE9mZnNldCksIHRoaXMuZ2V0U291cmNlUG9zaXRpb24oZW5kT2Zmc2V0KSk7XG4gICAgICB9XG4gICAgfSwge30pO1xuICB9KCk7XG4gIHJldHVybiB7Z2V0IExpbmVOdW1iZXJUYWJsZSgpIHtcbiAgICAgIHJldHVybiBMaW5lTnVtYmVyVGFibGU7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1NvdXJjZUZpbGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU291cmNlRmlsZS5qc1wiO1xuICB2YXIgTGluZU51bWJlclRhYmxlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTGluZU51bWJlclRhYmxlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvU291cmNlRmlsZS5qc1wiKSkuTGluZU51bWJlclRhYmxlO1xuICB2YXIgU291cmNlRmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFNvdXJjZUZpbGUobmFtZSwgY29udGVudHMpIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmNvbnRlbnRzID0gY29udGVudHM7XG4gICAgICB0aGlzLmxpbmVOdW1iZXJUYWJsZSA9IG5ldyBMaW5lTnVtYmVyVGFibGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTb3VyY2VGaWxlLCB7fSwge30pO1xuICB9KCk7XG4gIHJldHVybiB7Z2V0IFNvdXJjZUZpbGUoKSB7XG4gICAgICByZXR1cm4gU291cmNlRmlsZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCI7XG4gIHZhciAkX18yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QbGFjZWhvbGRlclBhcnNlci5qc1wiKSksXG4gICAgICBBUkdVTUVOVF9MSVNUID0gJF9fMi5BUkdVTUVOVF9MSVNULFxuICAgICAgQkxPQ0sgPSAkX18yLkJMT0NLLFxuICAgICAgRVhQUkVTU0lPTl9TVEFURU1FTlQgPSAkX18yLkVYUFJFU1NJT05fU1RBVEVNRU5ULFxuICAgICAgRlVOQ1RJT05fQk9EWSA9ICRfXzIuRlVOQ1RJT05fQk9EWSxcbiAgICAgIElERU5USUZJRVJfRVhQUkVTU0lPTiA9ICRfXzIuSURFTlRJRklFUl9FWFBSRVNTSU9OO1xuICB2YXIgSWRlbnRpZmllclRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9JZGVudGlmaWVyVG9rZW4uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIpKS5JZGVudGlmaWVyVG9rZW47XG4gIHZhciBMaXRlcmFsVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGxhY2Vob2xkZXJQYXJzZXIuanNcIikpLkxpdGVyYWxUb2tlbjtcbiAgdmFyIENvbGxlY3RpbmdFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIpKS5Db2xsZWN0aW5nRXJyb3JSZXBvcnRlcjtcbiAgdmFyIE9wdGlvbnMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vT3B0aW9ucy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGxhY2Vob2xkZXJQYXJzZXIuanNcIikpLk9wdGlvbnM7XG4gIHZhciBQYXJzZVRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGxhY2Vob2xkZXJQYXJzZXIuanNcIikpLlBhcnNlVHJlZTtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIFBhcnNlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QbGFjZWhvbGRlclBhcnNlci5qc1wiKSkuUGFyc2VyO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIpKSxcbiAgICAgIExpdGVyYWxFeHByZXNzaW9uID0gJF9fMTAuTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBMaXRlcmFsUHJvcGVydHlOYW1lID0gJF9fMTAuTGl0ZXJhbFByb3BlcnR5TmFtZSxcbiAgICAgIFR5cGVOYW1lID0gJF9fMTAuVHlwZU5hbWU7XG4gIHZhciBTb3VyY2VGaWxlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Tb3VyY2VGaWxlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QbGFjZWhvbGRlclBhcnNlci5qc1wiKSkuU291cmNlRmlsZTtcbiAgdmFyIElERU5USUZJRVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGxhY2Vob2xkZXJQYXJzZXIuanNcIikpLklERU5USUZJRVI7XG4gIHZhciAkX18xMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUFycmF5TGl0ZXJhbCA9ICRfXzEzLmNyZWF0ZUFycmF5TGl0ZXJhbCxcbiAgICAgIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyID0gJF9fMTMuY3JlYXRlQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBjcmVhdGVCbG9jayA9ICRfXzEzLmNyZWF0ZUJsb2NrLFxuICAgICAgY3JlYXRlQm9vbGVhbkxpdGVyYWwgPSAkX18xMy5jcmVhdGVCb29sZWFuTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbiA9ICRfXzEzLmNyZWF0ZUNvbW1hRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX18xMy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50LFxuICAgICAgY3JlYXRlRnVuY3Rpb25Cb2R5ID0gJF9fMTMuY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18xMy5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJUb2tlbiA9ICRfXzEzLmNyZWF0ZUlkZW50aWZpZXJUb2tlbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX18xMy5jcmVhdGVNZW1iZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTnVsbExpdGVyYWwgPSAkX18xMy5jcmVhdGVOdWxsTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZU51bWJlckxpdGVyYWwgPSAkX18xMy5jcmVhdGVOdW1iZXJMaXRlcmFsLFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fMTMuY3JlYXRlUGFyZW5FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlU3RyaW5nTGl0ZXJhbCA9ICRfXzEzLmNyZWF0ZVN0cmluZ0xpdGVyYWwsXG4gICAgICBjcmVhdGVWb2lkMCA9ICRfXzEzLmNyZWF0ZVZvaWQwO1xuICB2YXIgTk9UX0ZPVU5EID0ge307XG4gIGZ1bmN0aW9uIG1ha2VQYXJzZUZ1bmN0aW9uKGRvUGFyc2UpIHtcbiAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZUxpdGVyYWxzKSB7XG4gICAgICBmb3IgKHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAkX18xID0gMTsgJF9fMSA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzErKylcbiAgICAgICAgdmFsdWVzWyRfXzEgLSAxXSA9IGFyZ3VtZW50c1skX18xXTtcbiAgICAgIHJldHVybiBwYXJzZShzb3VyY2VMaXRlcmFscywgdmFsdWVzLCBkb1BhcnNlLCBjYWNoZSk7XG4gICAgfTtcbiAgfVxuICB2YXIgcGFyc2VFeHByZXNzaW9uID0gbWFrZVBhcnNlRnVuY3Rpb24oZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBwLnBhcnNlRXhwcmVzc2lvbigpO1xuICB9KTtcbiAgdmFyIHBhcnNlU3RhdGVtZW50ID0gbWFrZVBhcnNlRnVuY3Rpb24oZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBwLnBhcnNlU3RhdGVtZW50KCk7XG4gIH0pO1xuICB2YXIgcGFyc2VNb2R1bGUgPSBtYWtlUGFyc2VGdW5jdGlvbihmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHAucGFyc2VNb2R1bGUoKTtcbiAgfSk7XG4gIHZhciBwYXJzZVNjcmlwdCA9IG1ha2VQYXJzZUZ1bmN0aW9uKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcC5wYXJzZVNjcmlwdCgpO1xuICB9KTtcbiAgdmFyIHBhcnNlU3RhdGVtZW50cyA9IG1ha2VQYXJzZUZ1bmN0aW9uKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcC5wYXJzZVN0YXRlbWVudHMoKTtcbiAgfSk7XG4gIHZhciBwYXJzZVByb3BlcnR5RGVmaW5pdGlvbiA9IG1ha2VQYXJzZUZ1bmN0aW9uKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gcC5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbigpO1xuICB9KTtcbiAgZnVuY3Rpb24gcGFyc2Uoc291cmNlTGl0ZXJhbHMsIHZhbHVlcywgZG9QYXJzZSwgY2FjaGUpIHtcbiAgICB2YXIgdHJlZSA9IGNhY2hlLmdldChzb3VyY2VMaXRlcmFscyk7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICB2YXIgc291cmNlID0gaW5zZXJ0UGxhY2Vob2xkZXJJZGVudGlmaWVycyhzb3VyY2VMaXRlcmFscyk7XG4gICAgICB2YXIgZXJyb3JSZXBvcnRlciA9IG5ldyBDb2xsZWN0aW5nRXJyb3JSZXBvcnRlcigpO1xuICAgICAgdmFyIHBhcnNlciA9IGdldFBhcnNlcihzb3VyY2UsIGVycm9yUmVwb3J0ZXIpO1xuICAgICAgdHJlZSA9IGRvUGFyc2UocGFyc2VyKTtcbiAgICAgIGlmIChlcnJvclJlcG9ydGVyLmhhZEVycm9yKCkgfHwgIXRyZWUgfHwgIXBhcnNlci5pc0F0RW5kKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkludGVybmFsIGVycm9yIHRyeWluZyB0byBwYXJzZTpcXG5cXG5cIiArIHNvdXJjZSArIFwiXFxuXFxuXCIgKyBlcnJvclJlcG9ydGVyLmVycm9yc0FzU3RyaW5nKCkpKTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLnNldChzb3VyY2VMaXRlcmFscywgdHJlZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIGlmICh0cmVlIGluc3RhbmNlb2YgUGFyc2VUcmVlKVxuICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlclRyYW5zZm9ybWVyKHZhbHVlcykudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXJUcmFuc2Zvcm1lcih2YWx1ZXMpLnRyYW5zZm9ybUxpc3QodHJlZSk7XG4gIH1cbiAgdmFyIFBSRUZJWCA9ICckX19wbGFjZWhvbGRlcl9fJztcbiAgZnVuY3Rpb24gaW5zZXJ0UGxhY2Vob2xkZXJJZGVudGlmaWVycyhzb3VyY2VMaXRlcmFscykge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VMaXRlcmFsc1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNvdXJjZUxpdGVyYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgKz0gUFJFRklYICsgU3RyaW5nKGkgLSAxKSArIHNvdXJjZUxpdGVyYWxzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHZhciBjb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gZ2V0UGFyc2VyKHNvdXJjZSwgZXJyb3JSZXBvcnRlcikge1xuICAgIHZhciBmaWxlID0gbmV3IFNvdXJjZUZpbGUobnVsbCwgc291cmNlKTtcbiAgICB2YXIgb3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgb3B0aW9ucy5leHBlcmltZW50YWwgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgUGFyc2VyKGZpbGUsIGVycm9yUmVwb3J0ZXIsIG9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvRXhwcmVzc2lvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBhcnNlVHJlZSlcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyVG9rZW4pXG4gICAgICByZXR1cm4gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odmFsdWUpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdGVyYWxUb2tlbilcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odmFsdWUubG9jYXRpb24sIHZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIFBhcnNlVHJlZSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAxKVxuICAgICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgICAgaWYgKHZhbHVlWzBdLmlzU3RhdGVtZW50KCkpXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2NrKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJlbkV4cHJlc3Npb24oY3JlYXRlQ29tbWFFeHByZXNzaW9uKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQXJyYXlMaXRlcmFsKHZhbHVlLm1hcChjb252ZXJ0VmFsdWVUb0V4cHJlc3Npb24pKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIGNyZWF0ZU51bGxMaXRlcmFsKCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gY3JlYXRlVm9pZDAoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0xpdGVyYWwodmFsdWUpO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiBjcmVhdGVCb29sZWFuTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gY3JlYXRlTnVtYmVyTGl0ZXJhbCh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlVG9JZGVudGlmaWVyVG9rZW4odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJZGVudGlmaWVyVG9rZW4pXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJUb2tlbih2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlVG9UeXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGFyc2VUcmVlKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVOYW1lKG51bGwsIG51bGwsIGNvbnZlcnRWYWx1ZVRvSWRlbnRpZmllclRva2VuKHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElkZW50aWZpZXJUb2tlbikge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlTmFtZShudWxsLCBudWxsLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cbiAgdmFyIFBsYWNlaG9sZGVyVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyVHJhbnNmb3JtZXIodmFsdWVzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQbGFjZWhvbGRlclRyYW5zZm9ybWVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQbGFjZWhvbGRlclRyYW5zZm9ybWVyLCB7XG4gICAgICBnZXRWYWx1ZUF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlXzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihQUkVGSVgpICE9PSAwKVxuICAgICAgICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXQoTnVtYmVyKHN0ci5zbGljZShQUkVGSVgubGVuZ3RoKSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVfKHRyZWUuaWRlbnRpZmllclRva2VuLnZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VmFsdWVUb0V4cHJlc3Npb24odmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVfKHRyZWUuaWRlbnRpZmllclRva2VuLnZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHJldHVybiBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcih2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uLnR5cGUgPT09IElERU5USUZJRVJfRVhQUkVTU0lPTikge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uKHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybWVkRXhwcmVzc2lvbiA9PT0gdHJlZS5leHByZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybWVkRXhwcmVzc2lvbi5pc1N0YXRlbWVudExpc3RJdGVtKCkgfHwgdHJhbnNmb3JtZWRFeHByZXNzaW9uLnR5cGUgPT09IEZVTkNUSU9OX0JPRFkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEV4cHJlc3Npb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KHRyYW5zZm9ybWVkRXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQbGFjZWhvbGRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1FeHByZXNzaW9uU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmxvY2s6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuc3RhdGVtZW50cy5sZW5ndGggPT09IDEgJiYgdHJlZS5zdGF0ZW1lbnRzWzBdLnR5cGUgPT09IEVYUFJFU1NJT05fU1RBVEVNRU5UKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkU3RhdGVtZW50ID0gdGhpcy50cmFuc2Zvcm1FeHByZXNzaW9uU3RhdGVtZW50KHRyZWUuc3RhdGVtZW50c1swXSk7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybWVkU3RhdGVtZW50ID09PSB0cmVlLnN0YXRlbWVudHNbMF0pXG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtZWRTdGF0ZW1lbnQudHlwZSA9PT0gQkxPQ0spXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRTdGF0ZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQbGFjZWhvbGRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1CbG9ja1wiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5zdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0cmVlLnN0YXRlbWVudHNbMF0udHlwZSA9PT0gRVhQUkVTU0lPTl9TVEFURU1FTlQpIHtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRTdGF0ZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUV4cHJlc3Npb25TdGF0ZW1lbnQodHJlZS5zdGF0ZW1lbnRzWzBdKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtZWRTdGF0ZW1lbnQudHlwZSA9PT0gRlVOQ1RJT05fQk9EWSlcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFN0YXRlbWVudDtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtZWRTdGF0ZW1lbnQgPT09IHRyZWUuc3RhdGVtZW50c1swXSlcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm1lZFN0YXRlbWVudC50eXBlID09PSBCTE9DSylcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbkJvZHkodHJhbnNmb3JtZWRTdGF0ZW1lbnQuc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQbGFjZWhvbGRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkJvZHlcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVfKHRyZWUubWVtYmVyTmFtZS52YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGxhY2Vob2xkZXJUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTWVtYmVyRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKG9wZXJhbmQsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1MaXRlcmFsUHJvcGVydHlOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmxpdGVyYWxUb2tlbi50eXBlID09PSBJREVOVElGSUVSKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZV8odHJlZS5saXRlcmFsVG9rZW4udmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcm9wZXJ0eU5hbWUobnVsbCwgY29udmVydFZhbHVlVG9JZGVudGlmaWVyVG9rZW4odmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQbGFjZWhvbGRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MaXRlcmFsUHJvcGVydHlOYW1lXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXJndW1lbnRMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmFyZ3MubGVuZ3RoID09PSAxICYmIHRyZWUuYXJnc1swXS50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICB2YXIgYXJnMCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYXJnc1swXSk7XG4gICAgICAgICAgaWYgKGFyZzAgPT09IHRyZWUuYXJnc1swXSlcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIGlmIChhcmcwLnR5cGUgPT09IEFSR1VNRU5UX0xJU1QpXG4gICAgICAgICAgICByZXR1cm4gYXJnMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBsYWNlaG9sZGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUFyZ3VtZW50TGlzdFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVR5cGVOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVfKHRyZWUubmFtZS52YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gTk9UX0ZPVU5EKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGxhY2Vob2xkZXJUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtVHlwZU5hbWVcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyIG1vZHVsZU5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgICBpZiAobW9kdWxlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVHlwZU5hbWUobnVsbCwgbW9kdWxlTmFtZSwgY29udmVydFZhbHVlVG9JZGVudGlmaWVyVG9rZW4odmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFZhbHVlVG9UeXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbjtcbiAgICB9LFxuICAgIGdldCBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudDtcbiAgICB9LFxuICAgIGdldCBwYXJzZU1vZHVsZSgpIHtcbiAgICAgIHJldHVybiBwYXJzZU1vZHVsZTtcbiAgICB9LFxuICAgIGdldCBwYXJzZVNjcmlwdCgpIHtcbiAgICAgIHJldHVybiBwYXJzZVNjcmlwdDtcbiAgICB9LFxuICAgIGdldCBwYXJzZVN0YXRlbWVudHMoKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnRzO1xuICAgIH0sXG4gICAgZ2V0IHBhcnNlUHJvcGVydHlEZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uO1xuICAgIH0sXG4gICAgZ2V0IFBsYWNlaG9sZGVyVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gUGxhY2Vob2xkZXJUcmFuc2Zvcm1lcjtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHJlcGVuZFN0YXRlbWVudHMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QcmVwZW5kU3RhdGVtZW50cy5qc1wiO1xuICBmdW5jdGlvbiBwcmVwZW5kU3RhdGVtZW50cyhzdGF0ZW1lbnRzKSB7XG4gICAgdmFyICRfXzE7XG4gICAgZm9yICh2YXIgc3RhdGVtZW50c1RvUHJlcGVuZCA9IFtdLFxuICAgICAgICAkX18wID0gMTsgJF9fMCA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzArKylcbiAgICAgIHN0YXRlbWVudHNUb1ByZXBlbmRbJF9fMCAtIDFdID0gYXJndW1lbnRzWyRfXzBdO1xuICAgIGlmICghc3RhdGVtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGVtZW50c1RvUHJlcGVuZDtcbiAgICBpZiAoIXN0YXRlbWVudHNUb1ByZXBlbmQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgdmFyIHRyYW5zZm9ybWVkID0gW107XG4gICAgdmFyIGluUHJvbG9nID0gdHJ1ZTtcbiAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgICB2YXIgJF9fMTtcbiAgICAgIGlmIChpblByb2xvZyAmJiAhc3RhdGVtZW50LmlzRGlyZWN0aXZlUHJvbG9ndWUoKSkge1xuICAgICAgICAoJF9fMSA9IHRyYW5zZm9ybWVkKS5wdXNoLmFwcGx5KCRfXzEsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoc3RhdGVtZW50c1RvUHJlcGVuZCkpO1xuICAgICAgICBpblByb2xvZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtZWQucHVzaChzdGF0ZW1lbnQpO1xuICAgIH0pO1xuICAgIGlmIChpblByb2xvZykge1xuICAgICAgKCRfXzEgPSB0cmFuc2Zvcm1lZCkucHVzaC5hcHBseSgkX18xLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHN0YXRlbWVudHNUb1ByZXBlbmQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG4gIHJldHVybiB7Z2V0IHByZXBlbmRTdGF0ZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIHByZXBlbmRTdGF0ZW1lbnRzO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiO1xuICB2YXIgJF9fNSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIikpLFxuICAgICAgQ09OU1QgPSAkX181LkNPTlNULFxuICAgICAgVkFSID0gJF9fNS5WQVI7XG4gIHZhciAkX182ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIikpLFxuICAgICAgSW1wb3J0RGVjbGFyYXRpb24gPSAkX182LkltcG9ydERlY2xhcmF0aW9uLFxuICAgICAgSW1wb3J0ZWRCaW5kaW5nID0gJF9fNi5JbXBvcnRlZEJpbmRpbmcsXG4gICAgICBJbXBvcnRTcGVjaWZpZXIgPSAkX182LkltcG9ydFNwZWNpZmllcixcbiAgICAgIEltcG9ydFNwZWNpZmllclNldCA9ICRfXzYuSW1wb3J0U3BlY2lmaWVyU2V0LFxuICAgICAgTW9kdWxlID0gJF9fNi5Nb2R1bGUsXG4gICAgICBNb2R1bGVTcGVjaWZpZXIgPSAkX182Lk1vZHVsZVNwZWNpZmllcixcbiAgICAgIFNjcmlwdCA9ICRfXzYuU2NyaXB0O1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIikpLlN0cmluZ1NldDtcbiAgdmFyICRfXzggPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIikpLFxuICAgICAgY3JlYXRlQmluZGluZ0lkZW50aWZpZXIgPSAkX184LmNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyLFxuICAgICAgY3JlYXRlSWRlbnRpZmllclRva2VuID0gJF9fOC5jcmVhdGVJZGVudGlmaWVyVG9rZW4sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzguY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVNZW1iZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlU3RyaW5nTGl0ZXJhbCA9ICRfXzguY3JlYXRlU3RyaW5nTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbiA9ICRfXzguY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuLFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX184LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgcGFyc2VFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiKSkucGFyc2VFeHByZXNzaW9uO1xuICB2YXIgcHJlcGVuZFN0YXRlbWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QcmVwZW5kU3RhdGVtZW50cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIpKS5wcmVwZW5kU3RhdGVtZW50cztcbiAgZnVuY3Rpb24gdG9UZW1wTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIChcIiRfX1wiICsgbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25UeXBlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5wYXJzZU9wdGlvbnMuYmxvY2tCaW5kaW5nICYmICFvcHRpb25zLnRyYW5zZm9ybU9wdGlvbnMuYmxvY2tCaW5kaW5nID8gQ09OU1QgOiBWQVI7XG4gIH1cbiAgZnVuY3Rpb24gSW1wb3J0UnVudGltZVRyYWl0KFBhcnNlVHJlZVRyYW5zZm9ybWVyQ2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICAgIGZ1bmN0aW9uICRfXzAoKSB7XG4gICAgICAgIHZhciAkX180O1xuICAgICAgICBmb3IgKHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICAkX18zID0gMDsgJF9fMyA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzMrKylcbiAgICAgICAgICBhcmdzWyRfXzNdID0gYXJndW1lbnRzWyRfXzNdO1xuICAgICAgICAoJF9fNCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKCRfXzApKS5jYWxsLmFwcGx5KCRfXzQsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RoaXNdLCBhcmdzKSk7XG4gICAgICAgIHRoaXMuaW1wb3J0ZWROYW1lcyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgICAgdGhpcy5fZXhpc3RpbmdJbXBvcnRzID0gbmV3IFN0cmluZ1NldCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKCRfXzAsIHtcbiAgICAgICAgZ2V0UnVudGltZUV4cHJlc3Npb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltcG9ydFJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW1wb3J0ZWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRvVGVtcE5hbWUobmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbignJHRyYWNldXJSdW50aW1lJywgbmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByZXF1aXJlZE5hbWVzKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydGVkTmFtZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEltcG9ydGVkTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHRoaXMuaW1wb3J0ZWROYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybVNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCAkX18wLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1TY3JpcHRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICBpZiAodHJlZSA9PT0gdHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbXBvcnRSdW50aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzY3JpcHRJdGVtTGlzdCA9IHRoaXMuYWRkUnVudGltZUltcG9ydHModHJhbnNmb3JtZWQuc2NyaXB0SXRlbUxpc3QpO1xuICAgICAgICAgIHJldHVybiBuZXcgU2NyaXB0KHRyZWUubG9jYXRpb24sIHNjcmlwdEl0ZW1MaXN0LCB0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1Nb2R1bGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgJF9fMC5wcm90b3R5cGUsIFwidHJhbnNmb3JtTW9kdWxlXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgICAgaWYgKHRyZWUgPT09IHRyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW1wb3J0UnVudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0aGlzLmFkZFJ1bnRpbWVJbXBvcnRzKHRyYW5zZm9ybWVkLnNjcmlwdEl0ZW1MaXN0KTtcbiAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsZSh0cmVlLmxvY2F0aW9uLCBzY3JpcHRJdGVtTGlzdCwgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtSW1wb3J0ZWRCaW5kaW5nOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdGhpcy5fZXhpc3RpbmdJbXBvcnRzLmFkZCh0cmVlLmJpbmRpbmcuZ2V0U3RyaW5nVmFsdWUoKSk7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCAkX18wLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1JbXBvcnRlZEJpbmRpbmdcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldE1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHZhciBiYXNlID0gJ3RyYWNldXIvZGlzdC9jb21tb25qcyc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tb2R1bGVzID09PSAncGFyc2UnKSB7XG4gICAgICAgICAgICBiYXNlID0gJ3RyYWNldXIvc3JjJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vZHVsZUlkID0gY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuKChiYXNlICsgXCIvcnVudGltZS9tb2R1bGVzL1wiICsgbmFtZSArIFwiLmpzXCIpKTtcbiAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsZVNwZWNpZmllcihudWxsLCBtb2R1bGVJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bnRpbWVJbXBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgJF9fMiA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0ZWROYW1lcy52YWx1ZXNBc0FycmF5KCkuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhJF9fMi5fZXhpc3RpbmdJbXBvcnRzLmhhcyh0b1RlbXBOYW1lKG5hbWUpKTtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbignZGVmYXVsdCcpO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBuZXcgSW1wb3J0ZWRCaW5kaW5nKG51bGwsIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKHRvVGVtcE5hbWUobmFtZSkpKTtcbiAgICAgICAgICAgIHZhciBzcGVjaWZpZXIgPSBuZXcgSW1wb3J0U3BlY2lmaWVyKG51bGwsIGJpbmRpbmcsIGRlZik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEltcG9ydERlY2xhcmF0aW9uKG51bGwsIG5ldyBJbXBvcnRTcGVjaWZpZXJTZXQobnVsbCwgW3NwZWNpZmllcl0pLCAkX18yLl9nZXRNb2R1bGVTcGVjaWZpZXIobmFtZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGRSdW50aW1lSW1wb3J0czogZnVuY3Rpb24oc2NyaXB0SXRlbUxpc3QpIHtcbiAgICAgICAgICB2YXIgcnVudGltZUltcG9ydHMgPSB0aGlzLmdldFJ1bnRpbWVJbXBvcnRzKCk7XG4gICAgICAgICAgcmV0dXJuIHByZXBlbmRTdGF0ZW1lbnRzLmFwcGx5KCh2b2lkIDApLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKFtzY3JpcHRJdGVtTGlzdF0sIHJ1bnRpbWVJbXBvcnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHt9LCAkX19zdXBlcik7XG4gICAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lckNsYXNzKTtcbiAgfVxuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIEltcG9ydFJ1bnRpbWVUcmFpdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX182ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgTW9kdWxlID0gJF9fNi5Nb2R1bGUsXG4gICAgICBTY3JpcHQgPSAkX182LlNjcmlwdDtcbiAgdmFyIEFSR1VNRU5UUyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUHJlZGVmaW5lZE5hbWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiKSkuQVJHVU1FTlRTO1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIikpLlN0cmluZ1NldDtcbiAgdmFyICRfXzkgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIExFVCA9ICRfXzkuTEVULFxuICAgICAgVkFSID0gJF9fOS5WQVI7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18xMC5jcmVhdGVGdW5jdGlvbkJvZHksXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzEwLmNyZWF0ZVRoaXNFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18xMC5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24gPSAkX18xMC5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX18xMC5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMTAuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQ7XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICB2YXIgVGVtcFZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBWYXJTdGF0ZW1lbnQobmFtZSwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXI7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUZW1wVmFyU3RhdGVtZW50LCB7fSwge30pO1xuICB9KCk7XG4gIHZhciBUZW1wU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUZW1wU2NvcGUoKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJzID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUZW1wU2NvcGUsIHtcbiAgICAgIHB1c2g6IGZ1bmN0aW9uKGlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgICAgfSxcbiAgICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXJzLnBvcCgpO1xuICAgICAgfSxcbiAgICAgIHJlbGVhc2U6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5pZGVudGlmaWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIG9iai5yZWxlYXNlVGVtcE5hbWUodGhpcy5pZGVudGlmaWVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVmFyU2NvcGUob3B0aW9ucykge1xuICAgICAgdGhpcy50aGlzTmFtZSA9IG51bGw7XG4gICAgICB0aGlzLmFyZ3VtZW50TmFtZSA9IG51bGw7XG4gICAgICB0aGlzLnRlbXBWYXJTdGF0ZW1lbnRzID0gW107XG4gICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBvcHRpb25zLmJsb2NrQmluZGluZyAmJiAhb3B0aW9ucy50cmFuc2Zvcm1PcHRpb25zLmJsb2NrQmluZGluZyA/IExFVCA6IFZBUjtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhclNjb3BlLCB7XG4gICAgICBwdXNoOiBmdW5jdGlvbih0ZW1wVmFyU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMudGVtcFZhclN0YXRlbWVudHMucHVzaCh0ZW1wVmFyU3RhdGVtZW50KTtcbiAgICAgIH0sXG4gICAgICBwb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wVmFyU3RhdGVtZW50cy5wb3AoKTtcbiAgICAgIH0sXG4gICAgICByZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudGVtcFZhclN0YXRlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBvYmoucmVsZWFzZVRlbXBOYW1lKHRoaXMudGVtcFZhclN0YXRlbWVudHNbaV0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRlbXBWYXJTdGF0ZW1lbnRzLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNlZW5OYW1lcyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBWYXJTdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyICRfXzQgPSB0aGlzLnRlbXBWYXJTdGF0ZW1lbnRzW2ldLFxuICAgICAgICAgICAgICBuYW1lID0gJF9fNC5uYW1lLFxuICAgICAgICAgICAgICBpbml0aWFsaXplciA9ICRfXzQuaW5pdGlhbGl6ZXI7XG4gICAgICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChpbml0aWFsaXplcilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZSBvZiBUZW1wVmFyVHJhbnNmb3JtZXInKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWVuTmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24obmFtZSwgaW5pdGlhbGl6ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodGhpcy5kZWNsYXJhdGlvblR5cGVfLCBkZWNsYXJhdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVGVtcFZhclRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUZW1wVmFyVHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmlkZW50aWZpZXJHZW5lcmF0b3IgPSBpZGVudGlmaWVyR2VuZXJhdG9yO1xuICAgICAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMudGVtcFZhclN0YWNrXyA9IFtuZXcgVmFyU2NvcGUodGhpcy5vcHRpb25zKV07XG4gICAgICB0aGlzLnRlbXBTY29wZVN0YWNrXyA9IFtuZXcgVGVtcFNjb3BlKCldO1xuICAgICAgdGhpcy5uYW1lUG9vbF8gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFRlbXBWYXJUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtU3RhdGVtZW50c186IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdGhpcy50ZW1wVmFyU3RhY2tfLnB1c2gobmV3IFZhclNjb3BlKHRoaXMub3B0aW9ucykpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRTdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgdmFycyA9IHRoaXMudGVtcFZhclN0YWNrXy5wb3AoKTtcbiAgICAgICAgaWYgKHZhcnMuaXNFbXB0eSgpKVxuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFN0YXRlbWVudHM7XG4gICAgICAgIHZhciB2YXJpYWJsZVN0YXRlbWVudCA9IHZhcnMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgdmFycy5yZWxlYXNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHJlcGVuZFN0YXRlbWVudHModHJhbnNmb3JtZWRTdGF0ZW1lbnRzLCB2YXJpYWJsZVN0YXRlbWVudCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU2NyaXB0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY3JpcHRJdGVtTGlzdCA9IHRoaXMudHJhbnNmb3JtU3RhdGVtZW50c18odHJlZS5zY3JpcHRJdGVtTGlzdCk7XG4gICAgICAgIGlmIChzY3JpcHRJdGVtTGlzdCA9PT0gdHJlZS5zY3JpcHRJdGVtTGlzdCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0KHRyZWUubG9jYXRpb24sIHNjcmlwdEl0ZW1MaXN0LCB0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0aGlzLnRyYW5zZm9ybVN0YXRlbWVudHNfKHRyZWUuc2NyaXB0SXRlbUxpc3QpO1xuICAgICAgICBpZiAoc2NyaXB0SXRlbUxpc3QgPT09IHRyZWUuc2NyaXB0SXRlbUxpc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1vZHVsZSh0cmVlLmxvY2F0aW9uLCBzY3JpcHRJdGVtTGlzdCwgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkJvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5wdXNoVGVtcFNjb3BlKCk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1TdGF0ZW1lbnRzXyh0cmVlLnN0YXRlbWVudHMpO1xuICAgICAgICB0aGlzLnBvcFRlbXBTY29wZSgpO1xuICAgICAgICBpZiAoc3RhdGVtZW50cyA9PT0gdHJlZS5zdGF0ZW1lbnRzKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25Cb2R5KHN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIGdldFRlbXBJZGVudGlmaWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWVfKCk7XG4gICAgICAgIHRoaXMudGVtcFNjb3BlU3RhY2tfW3RoaXMudGVtcFNjb3BlU3RhY2tfLmxlbmd0aCAtIDFdLnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSxcbiAgICAgIGdldE5hbWVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZVBvb2xfLmxlbmd0aCA/IHRoaXMubmFtZVBvb2xfLnBvcCgpIDogdGhpcy5pZGVudGlmaWVyR2VuZXJhdG9yLmdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcigpO1xuICAgICAgfSxcbiAgICAgIGFkZFRlbXBWYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBhcmd1bWVudHNbMF0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgdmFyIHZhcnMgPSB0aGlzLnRlbXBWYXJTdGFja19bdGhpcy50ZW1wVmFyU3RhY2tfLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZV8oKTtcbiAgICAgICAgdmFycy5wdXNoKG5ldyBUZW1wVmFyU3RhdGVtZW50KG5hbWUsIGluaXRpYWxpemVyKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVGVtcFZhck5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHZhcnMgPSB0aGlzLnRlbXBWYXJTdGFja19bdGhpcy50ZW1wVmFyU3RhY2tfLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXJzLnB1c2gobmV3IFRlbXBWYXJTdGF0ZW1lbnQobmFtZSwgbnVsbCkpO1xuICAgICAgfSxcbiAgICAgIGFkZFRlbXBWYXJGb3JUaGlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhclNjb3BlID0gdGhpcy50ZW1wVmFyU3RhY2tfW3RoaXMudGVtcFZhclN0YWNrXy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHZhclNjb3BlLnRoaXNOYW1lIHx8ICh2YXJTY29wZS50aGlzTmFtZSA9IHRoaXMuYWRkVGVtcFZhcihjcmVhdGVUaGlzRXhwcmVzc2lvbigpKSk7XG4gICAgICB9LFxuICAgICAgYWRkVGVtcFZhckZvckFyZ3VtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YXJTY29wZSA9IHRoaXMudGVtcFZhclN0YWNrX1t0aGlzLnRlbXBWYXJTdGFja18ubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB2YXJTY29wZS5hcmd1bWVudE5hbWUgfHwgKHZhclNjb3BlLmFyZ3VtZW50TmFtZSA9IHRoaXMuYWRkVGVtcFZhcihjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihBUkdVTUVOVFMpKSk7XG4gICAgICB9LFxuICAgICAgcHVzaFRlbXBTY29wZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGVtcFNjb3BlU3RhY2tfLnB1c2gobmV3IFRlbXBTY29wZSgpKTtcbiAgICAgIH0sXG4gICAgICBwb3BUZW1wU2NvcGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRlbXBTY29wZVN0YWNrXy5wb3AoKS5yZWxlYXNlKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIHJlbGVhc2VUZW1wTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLm5hbWVQb29sXy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBUZW1wVmFyVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gVGVtcFZhclRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9iaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm4uanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvYmluZGluZ3NJbkRlc3RydWN0dXJpbmdQYXR0ZXJuLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QYXJzZVRyZWVWaXNpdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvYmluZGluZ3NJbkRlc3RydWN0dXJpbmdQYXR0ZXJuLmpzXCIpKS5QYXJzZVRyZWVWaXNpdG9yO1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvYmluZGluZ3NJbkRlc3RydWN0dXJpbmdQYXR0ZXJuLmpzXCIpKS5TdHJpbmdTZXQ7XG4gIHZhciBCaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm5WaXNpdG9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm5WaXNpdG9yKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQmluZGluZ3NJbkRlc3RydWN0dXJpbmdQYXR0ZXJuVmlzaXRvcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBuZXcgU3RyaW5nU2V0KCk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShCaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm5WaXNpdG9yLCB7XG4gICAgICB2aXNpdEJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuYWRkKHRyZWUuZ2V0U3RyaW5nVmFsdWUoKSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVmlzaXRvcik7XG4gIGZ1bmN0aW9uIGJpbmRpbmdzSW5EZXN0cnVjdHVyaW5nUGF0dGVybih0cmVlKSB7XG4gICAgdmFyIHYgPSBuZXcgQmluZGluZ3NJbkRlc3RydWN0dXJpbmdQYXR0ZXJuVmlzaXRvcigpO1xuICAgIHYudmlzaXRBbnkodHJlZSk7XG4gICAgcmV0dXJuIHYuYmluZGluZ3M7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBiaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm47XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQVJSQVlfTElURVJBTCA9ICRfXzguQVJSQVlfTElURVJBTCxcbiAgICAgIEFSUkFZX1BBVFRFUk4gPSAkX184LkFSUkFZX1BBVFRFUk4sXG4gICAgICBBU1NJR05NRU5UX0VMRU1FTlQgPSAkX184LkFTU0lHTk1FTlRfRUxFTUVOVCxcbiAgICAgIEJJTkRJTkdfRUxFTUVOVCA9ICRfXzguQklORElOR19FTEVNRU5ULFxuICAgICAgQklORElOR19JREVOVElGSUVSID0gJF9fOC5CSU5ESU5HX0lERU5USUZJRVIsXG4gICAgICBCTE9DSyA9ICRfXzguQkxPQ0ssXG4gICAgICBDQUxMX0VYUFJFU1NJT04gPSAkX184LkNBTExfRVhQUkVTU0lPTixcbiAgICAgIENPTVBVVEVEX1BST1BFUlRZX05BTUUgPSAkX184LkNPTVBVVEVEX1BST1BFUlRZX05BTUUsXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX184LklERU5USUZJRVJfRVhQUkVTU0lPTixcbiAgICAgIExJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzguTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0VYUFJFU1NJT04gPSAkX184Lk1FTUJFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OID0gJF9fOC5NRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04sXG4gICAgICBPQkpFQ1RfTElURVJBTCA9ICRfXzguT0JKRUNUX0xJVEVSQUwsXG4gICAgICBPQkpFQ1RfUEFUVEVSTl9GSUVMRCA9ICRfXzguT0JKRUNUX1BBVFRFUk5fRklFTEQsXG4gICAgICBPQkpFQ1RfUEFUVEVSTiA9ICRfXzguT0JKRUNUX1BBVFRFUk4sXG4gICAgICBQQVJFTl9FWFBSRVNTSU9OID0gJF9fOC5QQVJFTl9FWFBSRVNTSU9OLFxuICAgICAgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCA9ICRfXzguVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCxcbiAgICAgIFZBUklBQkxFX1NUQVRFTUVOVCA9ICRfXzguVkFSSUFCTEVfU1RBVEVNRU5UO1xuICB2YXIgJF9fOSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFub25CbG9jayA9ICRfXzkuQW5vbkJsb2NrLFxuICAgICAgQXNzaWdubWVudEVsZW1lbnQgPSAkX185LkFzc2lnbm1lbnRFbGVtZW50LFxuICAgICAgQmluZGluZ0VsZW1lbnQgPSAkX185LkJpbmRpbmdFbGVtZW50LFxuICAgICAgQ2F0Y2ggPSAkX185LkNhdGNoLFxuICAgICAgRXhwb3J0RGVjbGFyYXRpb24gPSAkX185LkV4cG9ydERlY2xhcmF0aW9uLFxuICAgICAgRm9ySW5TdGF0ZW1lbnQgPSAkX185LkZvckluU3RhdGVtZW50LFxuICAgICAgRm9yT2ZTdGF0ZW1lbnQgPSAkX185LkZvck9mU3RhdGVtZW50LFxuICAgICAgRm9yT25TdGF0ZW1lbnQgPSAkX185LkZvck9uU3RhdGVtZW50LFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX185LlZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgVmFyaWFibGVTdGF0ZW1lbnQgPSAkX185LlZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgSW1wb3J0UnVudGltZVRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Rlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgJF9fMTIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEVRVUFMID0gJF9fMTIuRVFVQUwsXG4gICAgICBMRVQgPSAkX18xMi5MRVQsXG4gICAgICBWQVIgPSAkX18xMi5WQVI7XG4gIHZhciBiaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc2VtYW50aWNzL2JpbmRpbmdzSW5EZXN0cnVjdHVyaW5nUGF0dGVybi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fMTQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24gPSAkX18xNC5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyID0gJF9fMTQuY3JlYXRlQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBjcmVhdGVCbG9jayA9ICRfXzE0LmNyZWF0ZUJsb2NrLFxuICAgICAgY3JlYXRlQ29tbWFFeHByZXNzaW9uID0gJF9fMTQuY3JlYXRlQ29tbWFFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzE0LmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18xNC5jcmVhdGVGdW5jdGlvbkJvZHksXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzE0LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzE0LmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fMTQuY3JlYXRlTWVtYmVyTG9va3VwRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbiA9ICRfXzE0LmNyZWF0ZVBhcmVuRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24gPSAkX18xNC5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX18xNC5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMTQuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQ7XG4gIHZhciBwYXJzZUV4cHJlc3Npb24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIpKS5wYXJzZUV4cHJlc3Npb247XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICB2YXIgRGVzdWdhcmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIERlc3VnYXJpbmcocnZhbHVlKSB7XG4gICAgICB0aGlzLnJ2YWx1ZSA9IHJ2YWx1ZTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgIHRoaXMucGVuZGluZ0V4cHJlc3Npb25zID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShEZXN1Z2FyaW5nLCB7XG4gICAgICBjcmVhdGVJdGVyYXRvcjogZnVuY3Rpb24oaXRlcklkKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0V4cHJlc3Npb25zLnB1c2gocGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcIiwgXCIgPSBcIiwgXCJbU3ltYm9sLml0ZXJhdG9yXSgpXCJdKSwgaXRlcklkLCB0aGlzLnJ2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUluaXRpYWxpemVyOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdFeHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoaXMucGVuZGluZ0V4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLnBlbmRpbmdFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xuICAgICAgfSxcbiAgICAgIHNraXBIb2xlOiBmdW5jdGlvbihpdGVySWQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRXhwcmVzc2lvbnMucHVzaChwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIi5uZXh0KClcIl0pLCBpdGVySWQpKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIEFzc2lnbm1lbnRFeHByZXNzaW9uRGVzdWdhcmluZyA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb25EZXN1Z2FyaW5nKHJ2YWx1ZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXNzaWdubWVudEV4cHJlc3Npb25EZXN1Z2FyaW5nKS5jYWxsKHRoaXMsIHJ2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBc3NpZ25tZW50RXhwcmVzc2lvbkRlc3VnYXJpbmcsIHtcbiAgICAgIGFzc2lnbjogZnVuY3Rpb24obHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgbHZhbHVlID0gbHZhbHVlIGluc3RhbmNlb2YgQXNzaWdubWVudEVsZW1lbnQgPyBsdmFsdWUuYXNzaWdubWVudCA6IGx2YWx1ZTtcbiAgICAgICAgcnZhbHVlID0gdGhpcy5jcmVhdGVJbml0aWFsaXplcihydmFsdWUpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obHZhbHVlLCBydmFsdWUpKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24odGVtcElkLCBydmFsdWUpIHtcbiAgICAgICAgdmFyICRfXzY7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoaXMuZXhwcmVzc2lvbnM7XG4gICAgICAgIGV4cHJlc3Npb25zLnVuc2hpZnQoY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odGVtcElkLCBydmFsdWUpKTtcbiAgICAgICAgKCRfXzYgPSBleHByZXNzaW9ucykucHVzaC5hcHBseSgkX182LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHRoaXMucGVuZGluZ0V4cHJlc3Npb25zLCBbdGVtcElkXSkpO1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oRGVzdWdhcmluZyk7XG4gIHZhciBWYXJpYWJsZURlY2xhcmF0aW9uRGVzdWdhcmluZyA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbkRlc3VnYXJpbmcocnZhbHVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihWYXJpYWJsZURlY2xhcmF0aW9uRGVzdWdhcmluZykuY2FsbCh0aGlzLCBydmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVmFyaWFibGVEZWNsYXJhdGlvbkRlc3VnYXJpbmcsIHtcbiAgICAgIGFzc2lnbjogZnVuY3Rpb24obHZhbHVlLCBydmFsdWUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBsdmFsdWUgaW5zdGFuY2VvZiBCaW5kaW5nRWxlbWVudCA/IGx2YWx1ZS5iaW5kaW5nIDogY3JlYXRlQmluZGluZ0lkZW50aWZpZXIobHZhbHVlKTtcbiAgICAgICAgcnZhbHVlID0gdGhpcy5jcmVhdGVJbml0aWFsaXplcihydmFsdWUpO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zLnB1c2goY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihiaW5kaW5nLCBydmFsdWUpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZGVjbGFyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9ucztcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KERlc3VnYXJpbmcpO1xuICB2YXIgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCBpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnBhcmFtZXRlckRlY2xhcmF0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUFycmF5UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtT2JqZWN0UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnB1c2hUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIHJ2O1xuICAgICAgICBpZiAodHJlZS5vcGVyYXRvci50eXBlID09PSBFUVVBTCAmJiB0cmVlLmxlZnQuaXNQYXR0ZXJuKCkpIHtcbiAgICAgICAgICBydiA9IHRoaXMudHJhbnNmb3JtQW55KHRoaXMuZGVzdWdhckFzc2lnbm1lbnRfKHRyZWUubGVmdCwgdHJlZS5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ2ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQmluYXJ5RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wVGVtcFNjb3BlKCk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0sXG4gICAgICBkZXN1Z2FyQXNzaWdubWVudF86IGZ1bmN0aW9uKGx2YWx1ZSwgcnZhbHVlKSB7XG4gICAgICAgIHZhciB0ZW1wSWQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmFkZFRlbXBWYXIoKSk7XG4gICAgICAgIHZhciBkZXN1Z2FyaW5nID0gbmV3IEFzc2lnbm1lbnRFeHByZXNzaW9uRGVzdWdhcmluZyh0ZW1wSWQpO1xuICAgICAgICB0aGlzLmRlc3VnYXJQYXR0ZXJuXyhkZXN1Z2FyaW5nLCBsdmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVzdWdhcmluZy5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0ZW1wSWQsIHJ2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzQgPSB0aGlzO1xuICAgICAgICBpZiAoIWhhc0Rlc3RydWN0dXJpbmcodHJlZSkpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbkxpc3RcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzdWdhcmVkRGVjbGFyYXRpb25zID0gW107XG4gICAgICAgIHRyZWUuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB2YXIgJF9fNjtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24ubHZhbHVlLmlzUGF0dGVybigpKSB7XG4gICAgICAgICAgICAoJF9fNiA9IGRlc3VnYXJlZERlY2xhcmF0aW9ucykucHVzaC5hcHBseSgkX182LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKCRfXzQuZGVzdWdhclZhcmlhYmxlRGVjbGFyYXRpb25fKGRlY2xhcmF0aW9uKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN1Z2FyZWREZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkVHJlZSA9IHRoaXMudHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodHJlZS5kZWNsYXJhdGlvblR5cGUsIGRlc3VnYXJlZERlY2xhcmF0aW9ucykpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRUcmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvckluU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZvckluT3JPZk9yT25fKHRyZWUsICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZvckluU3RhdGVtZW50XCIpLCBGb3JJblN0YXRlbWVudCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRm9ySW5Pck9mT3JPbl8odHJlZSwgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnRcIiksIEZvck9mU3RhdGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JPblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Gb3JJbk9yT2ZPck9uXyh0cmVlLCAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Gb3JPblN0YXRlbWVudFwiKSwgRm9yT25TdGF0ZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvckluT3JPZk9yT25fOiBmdW5jdGlvbih0cmVlLCBzdXBlck1ldGhvZCwgY29uc3RyKSB7XG4gICAgICAgIHZhciAkX182O1xuICAgICAgICBpZiAoIXRyZWUuaW5pdGlhbGl6ZXIuaXNQYXR0ZXJuKCkgJiYgKHRyZWUuaW5pdGlhbGl6ZXIudHlwZSAhPT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCB8fCAhaGFzRGVzdHJ1Y3R1cmluZyh0cmVlLmluaXRpYWxpemVyKSkpIHtcbiAgICAgICAgICByZXR1cm4gc3VwZXJNZXRob2QuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uVHlwZSxcbiAgICAgICAgICAgIGx2YWx1ZTtcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIuaXNQYXR0ZXJuKCkpIHtcbiAgICAgICAgICBkZWNsYXJhdGlvblR5cGUgPSBudWxsO1xuICAgICAgICAgIGx2YWx1ZSA9IHRyZWUuaW5pdGlhbGl6ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25UeXBlID0gdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvblR5cGU7XG4gICAgICAgICAgbHZhbHVlID0gdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnNbMF0ubHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5kZXN1Z2FyQmluZGluZ18obHZhbHVlLCBzdGF0ZW1lbnRzLCBkZWNsYXJhdGlvblR5cGUpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIGJpbmRpbmcsIG51bGwpO1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGJvZHkudHlwZSA9PT0gQkxPQ0spXG4gICAgICAgICAgKCRfXzYgPSBzdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KCRfXzYsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoYm9keS5zdGF0ZW1lbnRzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYm9keSk7XG4gICAgICAgIGJvZHkgPSBjcmVhdGVCbG9jayhzdGF0ZW1lbnRzKTtcbiAgICAgICAgdGhpcy5wb3BUZW1wU2NvcGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHIodHJlZS5sb2NhdGlvbiwgaW5pdGlhbGl6ZXIsIGNvbGxlY3Rpb24sIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFzc2lnbm1lbnRFbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoIXRyZWUuYmluZGluZy5pc1BhdHRlcm4oKSB8fCB0cmVlLmluaXRpYWxpemVyKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJEZWNsYXJhdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnBhcmFtZXRlckRlY2xhcmF0aW9ucyA9IFtdO1xuICAgICAgICAgIHRoaXMucHVzaFRlbXBTY29wZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJOYW1lID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgYmluZGluZyA9IGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKHZhck5hbWUpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih2YXJOYW1lKTtcbiAgICAgICAgdmFyIGRlY2wgPSBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHRyZWUuYmluZGluZywgaW5pdGlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnBhcmFtZXRlckRlY2xhcmF0aW9ucy5wdXNoKGRlY2wpO1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdFbGVtZW50KG51bGwsIGJpbmRpbmcsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJEZWNsYXJhdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uQm9keVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgbGlzdCA9IGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFZBUiwgdGhpcy5wYXJhbWV0ZXJEZWNsYXJhdGlvbnMpO1xuICAgICAgICB2YXIgc3RhdGVtZW50ID0gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQobGlzdCk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gcHJlcGVuZFN0YXRlbWVudHModHJlZS5zdGF0ZW1lbnRzLCBzdGF0ZW1lbnQpO1xuICAgICAgICB2YXIgbmV3Qm9keSA9IGNyZWF0ZUZ1bmN0aW9uQm9keShzdGF0ZW1lbnRzKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJEZWNsYXJhdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25Cb2R5XCIpLmNhbGwodGhpcywgbmV3Qm9keSk7XG4gICAgICAgIHRoaXMucG9wVGVtcFNjb3BlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2F0Y2g6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzY7XG4gICAgICAgIGlmICghdHJlZS5iaW5kaW5nLmlzUGF0dGVybigpKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1DYXRjaFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY2F0Y2hCb2R5KTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm9wdGlvbnMuYmxvY2tCaW5kaW5nID8gTEVUIDogVkFSO1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuZGVzdWdhckJpbmRpbmdfKHRyZWUuYmluZGluZywgc3RhdGVtZW50cywga2luZCk7XG4gICAgICAgICgkX182ID0gc3RhdGVtZW50cykucHVzaC5hcHBseSgkX182LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGJvZHkuc3RhdGVtZW50cykpO1xuICAgICAgICByZXR1cm4gbmV3IENhdGNoKHRyZWUubG9jYXRpb24sIGJpbmRpbmcsIGNyZWF0ZUJsb2NrKHN0YXRlbWVudHMpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5kZWNsYXJhdGlvbi50eXBlID09PSBWQVJJQUJMRV9TVEFURU1FTlQgJiYgaGFzRGVzdHJ1Y3R1cmluZyh0cmVlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykpIHtcbiAgICAgICAgICB2YXIgbmFtZXMgPSBiaW5kaW5nc0luRGVzdHJ1Y3R1cmluZ1BhdHRlcm4odHJlZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpO1xuICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgdmFyICRfXzUgPSBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9ICRfXzUuZGVjbGFyYXRpb25zLFxuICAgICAgICAgICAgICBkZWNsYXJhdGlvblR5cGUgPSAkX181LmRlY2xhcmF0aW9uVHlwZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uJF9fNyA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBuZXcgVmFyaWFibGVTdGF0ZW1lbnQoZGVjbGFyYXRpb24kX183LmxvY2F0aW9uLCBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoZGVjbGFyYXRpb24kX183LmxvY2F0aW9uLCBkZWNsYXJhdGlvblR5cGUsIFtkZWNsYXJhdGlvbiRfXzddKSk7XG4gICAgICAgICAgICBpZiAobmFtZXMuaGFzKGRlY2xhcmF0aW9uc1tpXS5sdmFsdWUuZ2V0U3RyaW5nVmFsdWUoKSkpIHtcbiAgICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IEV4cG9ydERlY2xhcmF0aW9uKHN0YXRlbWVudC5sb2NhdGlvbiwgc3RhdGVtZW50LCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUV4cG9ydERlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgZGVzdWdhckJpbmRpbmdfOiBmdW5jdGlvbihiaW5kaW5nVHJlZSwgc3RhdGVtZW50cywgZGVjbGFyYXRpb25UeXBlKSB7XG4gICAgICAgIHZhciB2YXJOYW1lID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgYmluZGluZyA9IGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKHZhck5hbWUpO1xuICAgICAgICB2YXIgaWRFeHByID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odmFyTmFtZSk7XG4gICAgICAgIHZhciBkZXN1Z2FyaW5nO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25UeXBlID09PSBudWxsKVxuICAgICAgICAgIGRlc3VnYXJpbmcgPSBuZXcgQXNzaWdubWVudEV4cHJlc3Npb25EZXN1Z2FyaW5nKGlkRXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkZXN1Z2FyaW5nID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25EZXN1Z2FyaW5nKGlkRXhwcik7XG4gICAgICAgIHRoaXMuZGVzdWdhclBhdHRlcm5fKGRlc3VnYXJpbmcsIGJpbmRpbmdUcmVlKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihkZXN1Z2FyaW5nLmV4cHJlc3Npb25zKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjcmVhdGVWYXJpYWJsZVN0YXRlbWVudCh0aGlzLnRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGRlY2xhcmF0aW9uVHlwZSwgZGVzdWdhcmluZy5kZWNsYXJhdGlvbnMpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgICAgfSxcbiAgICAgIGRlc3VnYXJWYXJpYWJsZURlY2xhcmF0aW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdGVtcFJWYWx1ZU5hbWUgPSB0aGlzLmdldFRlbXBJZGVudGlmaWVyKCk7XG4gICAgICAgIHZhciB0ZW1wUlZhbHVlSWRlbnQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0ZW1wUlZhbHVlTmFtZSk7XG4gICAgICAgIHZhciBkZXN1Z2FyaW5nO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXI7XG4gICAgICAgIHN3aXRjaCAodHJlZS5pbml0aWFsaXplci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBBUlJBWV9MSVRFUkFMOlxuICAgICAgICAgIGNhc2UgQ0FMTF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgSURFTlRJRklFUl9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTElURVJBTF9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgICAgICAgICBjYXNlIFBBUkVOX0VYUFJFU1NJT046XG4gICAgICAgICAgICBpbml0aWFsaXplciA9IHRyZWUuaW5pdGlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZGVzdWdhcmluZyA9IG5ldyBWYXJpYWJsZURlY2xhcmF0aW9uRGVzdWdhcmluZyh0ZW1wUlZhbHVlSWRlbnQpO1xuICAgICAgICBkZXN1Z2FyaW5nLmFzc2lnbihkZXN1Z2FyaW5nLnJ2YWx1ZSwgdHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHZhciBpbml0aWFsaXplckZvdW5kID0gdGhpcy5kZXN1Z2FyUGF0dGVybl8oZGVzdWdhcmluZywgdHJlZS5sdmFsdWUpO1xuICAgICAgICBpZiAoaW5pdGlhbGl6ZXJGb3VuZCB8fCBkZXN1Z2FyaW5nLmRlY2xhcmF0aW9ucy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3VnYXJpbmcuZGVjbGFyYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICBpbml0aWFsaXplciA9IGNyZWF0ZVBhcmVuRXhwcmVzc2lvbih0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZXN1Z2FyaW5nID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25EZXN1Z2FyaW5nKGluaXRpYWxpemVyKTtcbiAgICAgICAgdGhpcy5kZXN1Z2FyUGF0dGVybl8oZGVzdWdhcmluZywgdHJlZS5sdmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVzdWdhcmluZy5kZWNsYXJhdGlvbnM7XG4gICAgICB9LFxuICAgICAgZGVzdWdhclBhdHRlcm5fOiBmdW5jdGlvbihkZXN1Z2FyaW5nLCB0cmVlKSB7XG4gICAgICAgIHZhciAkX180ID0gdGhpcztcbiAgICAgICAgdmFyIGluaXRpYWxpemVyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBBUlJBWV9QQVRURVJOOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXR0ZXJuID0gdHJlZTtcbiAgICAgICAgICAgICAgdGhpcy5wdXNoVGVtcFNjb3BlKCk7XG4gICAgICAgICAgICAgIHZhciBpdGVySWQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmFkZFRlbXBWYXIoKSk7XG4gICAgICAgICAgICAgIHZhciBpdGVyT2JqZWN0SWQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmFkZFRlbXBWYXIoKSk7XG4gICAgICAgICAgICAgIGRlc3VnYXJpbmcuY3JlYXRlSXRlcmF0b3IoaXRlcklkKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGx2YWx1ZSA9IHBhdHRlcm4uZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGx2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGVzdWdhcmluZy5za2lwSG9sZShpdGVySWQpO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsdmFsdWUuaXNTcHJlYWRQYXR0ZXJuRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3JUb0FycmF5ID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignaXRlcmF0b3JUb0FycmF5Jyk7XG4gICAgICAgICAgICAgICAgICBkZXN1Z2FyaW5nLmFzc2lnbihsdmFsdWUubHZhbHVlLCBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIihcIiwgXCIpXCJdKSwgaXRlcmF0b3JUb0FycmF5LCBpdGVySWQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGx2YWx1ZS5pbml0aWFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlc3VnYXJpbmcuYXNzaWduKGx2YWx1ZSwgdGhpcy5jcmVhdGVDb25kaXRpb25hbEl0ZXJFeHByZXNzaW9uKGl0ZXJPYmplY3RJZCwgaXRlcklkLCBsdmFsdWUuaW5pdGlhbGl6ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5wb3BUZW1wU2NvcGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBPQkpFQ1RfUEFUVEVSTjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGF0dGVybiA9IHRyZWU7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50SGVscGVyID0gZnVuY3Rpb24obHZhbHVlLCBpbml0aWFsaXplcikge1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsaXplcilcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBsb29rdXAgPSAkX180LmNyZWF0ZUNvbmRpdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihkZXN1Z2FyaW5nLnJ2YWx1ZSwgbHZhbHVlLCBpbml0aWFsaXplcik7XG4gICAgICAgICAgICAgICAgZGVzdWdhcmluZy5hc3NpZ24obHZhbHVlLCBsb29rdXApO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwYXR0ZXJuLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvb2t1cDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQVNTSUdOTUVOVF9FTEVNRU5UOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50SGVscGVyKGZpZWxkLmFzc2lnbm1lbnQsIGZpZWxkLmluaXRpYWxpemVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJJTkRJTkdfRUxFTUVOVDpcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEhlbHBlcihmaWVsZC5iaW5kaW5nLCBmaWVsZC5pbml0aWFsaXplcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBPQkpFQ1RfUEFUVEVSTl9GSUVMRDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5lbGVtZW50LmluaXRpYWxpemVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZXJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGxvb2t1cCA9ICRfXzQuY3JlYXRlQ29uZGl0aW9uYWxNZW1iZXJFeHByZXNzaW9uKGRlc3VnYXJpbmcucnZhbHVlLCBuYW1lLCBmaWVsZC5lbGVtZW50LmluaXRpYWxpemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICBkZXN1Z2FyaW5nLmFzc2lnbihmaWVsZC5lbGVtZW50LCBsb29rdXApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFBBUkVOX0VYUFJFU1NJT046XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN1Z2FyUGF0dGVybl8oZGVzdWdhcmluZywgdHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXN1Z2FyaW5nIGluc3RhbmNlb2YgVmFyaWFibGVEZWNsYXJhdGlvbkRlc3VnYXJpbmcgJiYgZGVzdWdhcmluZy5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVzdWdhcmluZy5hc3NpZ24oY3JlYXRlQmluZGluZ0lkZW50aWZpZXIodGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKSwgZGVzdWdhcmluZy5ydmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplckZvdW5kO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUNvbmRpdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24ocnZhbHVlLCBuYW1lLCBpbml0aWFsaXplcikge1xuICAgICAgICBpZiAobmFtZS50eXBlID09PSBDT01QVVRFRF9QUk9QRVJUWV9OQU1FKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29uZGl0aW9uYWxNZW1iZXJMb29rdXBFeHByZXNzaW9uKHJ2YWx1ZSwgbmFtZS5leHByZXNzaW9uLCBpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBzd2l0Y2ggKG5hbWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgQklORElOR19JREVOVElGSUVSOlxuICAgICAgICAgIGNhc2UgSURFTlRJRklFUl9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgdG9rZW4gPSBuYW1lLmlkZW50aWZpZXJUb2tlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0b2tlbiA9IG5hbWUubGl0ZXJhbFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZXIpXG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24ocnZhbHVlLCB0b2tlbik7XG4gICAgICAgIHZhciB0ZW1wSWRlbnQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmFkZFRlbXBWYXIoKSk7XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIihcIiwgXCIgPSBcIiwgXCIuXCIsIFwiKSA9PT0gdm9pZCAwID9cXG4gICAgICAgIFwiLCBcIiA6IFwiLCBcIlwiXSksIHRlbXBJZGVudCwgcnZhbHVlLCB0b2tlbiwgaW5pdGlhbGl6ZXIsIHRlbXBJZGVudCk7XG4gICAgICB9LFxuICAgICAgY3JlYXRlQ29uZGl0aW9uYWxNZW1iZXJMb29rdXBFeHByZXNzaW9uOiBmdW5jdGlvbihydmFsdWUsIGluZGV4LCBpbml0aWFsaXplcikge1xuICAgICAgICBpZiAoIWluaXRpYWxpemVyKVxuICAgICAgICAgIHJldHVybiBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uKHJ2YWx1ZSwgaW5kZXgpO1xuICAgICAgICB2YXIgdGVtcElkZW50ID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGhpcy5hZGRUZW1wVmFyKCkpO1xuICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIoXCIsIFwiID0gXCIsIFwiW1wiLCBcIl0pID09PSB2b2lkIDAgP1xcbiAgICAgICAgXCIsIFwiIDogXCIsIFwiXCJdKSwgdGVtcElkZW50LCBydmFsdWUsIGluZGV4LCBpbml0aWFsaXplciwgdGVtcElkZW50KTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVDb25kaXRpb25hbEl0ZXJFeHByZXNzaW9uOiBmdW5jdGlvbihpdGVyT2JqZWN0SWQsIGl0ZXJJZCwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIihcIiwgXCIgPVxcbiAgICAgICAgXCIsIFwiLm5leHQoKSkuZG9uZSA/IHZvaWQgMCA6IFwiLCBcIi52YWx1ZVwiXSksIGl0ZXJPYmplY3RJZCwgaXRlcklkLCBpdGVyT2JqZWN0SWQpO1xuICAgICAgICBpZiAoIWluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBJZGVudCA9IGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRoaXMuYWRkVGVtcFZhcigpKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiKFwiLCBcIiA9IFwiLCBcIikgPT09IHZvaWQgMCA/XFxuICAgICAgICBcIiwgXCIgOiBcIiwgXCJcIl0pLCB0ZW1wSWRlbnQsIGV4cHIsIGluaXRpYWxpemVyLCB0ZW1wSWRlbnQpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSW1wb3J0UnVudGltZVRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpO1xuICBmdW5jdGlvbiBoYXNEZXN0cnVjdHVyaW5nKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5kZWNsYXJhdGlvbnMuc29tZShmdW5jdGlvbihkZWNsYXJhdGlvbikge1xuICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uLmx2YWx1ZS5pc1BhdHRlcm4oKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge2dldCBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVTeW1ib2wuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvTW9kdWxlU3ltYm9sLmpzXCI7XG4gIHZhciBTdHJpbmdNYXAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vdXRpbC9TdHJpbmdNYXAuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVTeW1ib2wuanNcIikpLlN0cmluZ01hcDtcbiAgdmFyIGFzc2VydCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi8uLi91dGlsL2Fzc2VydC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL01vZHVsZVN5bWJvbC5qc1wiKSkuYXNzZXJ0O1xuICB2YXIgRXhwb3J0c0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnRzTGlzdChub3JtYWxpemVkTmFtZSkge1xuICAgICAgdGhpcy5leHBvcnRzXyA9IG5ldyBTdHJpbmdNYXAoKTtcbiAgICAgIGlmIChub3JtYWxpemVkTmFtZSAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZWROYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShFeHBvcnRzTGlzdCwge1xuICAgICAgYWRkRXhwb3J0OiBmdW5jdGlvbihuYW1lLCB0cmVlKSB7XG4gICAgICAgIGFzc2VydCghdGhpcy5leHBvcnRzXy5oYXMobmFtZSkpO1xuICAgICAgICB0aGlzLmV4cG9ydHNfLnNldChuYW1lLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICBnZXRFeHBvcnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0c18uZ2V0KG5hbWUpO1xuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRzXy5rZXlzQXNBcnJheSgpO1xuICAgICAgfSxcbiAgICAgIGFkZEV4cG9ydHNGcm9tTW9kdWxlOiBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2R1bGUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICRfXzIuYWRkRXhwb3J0KG5hbWUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIE1vZHVsZVN5bWJvbCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTW9kdWxlU3ltYm9sKHRyZWUsIG5vcm1hbGl6ZWROYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihNb2R1bGVTeW1ib2wpLmNhbGwodGhpcywgbm9ybWFsaXplZE5hbWUpO1xuICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgIHRoaXMuaW1wb3J0c18gPSBuZXcgU3RyaW5nTWFwKCk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNb2R1bGVTeW1ib2wsIHtcbiAgICAgIGFkZEltcG9ydDogZnVuY3Rpb24obmFtZSwgdHJlZSkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuaW1wb3J0c18uaGFzKG5hbWUpKTtcbiAgICAgICAgdGhpcy5pbXBvcnRzXy5zZXQobmFtZSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgZ2V0SW1wb3J0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydHNfLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEV4cG9ydHNMaXN0KTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgRXhwb3J0c0xpc3QoKSB7XG4gICAgICByZXR1cm4gRXhwb3J0c0xpc3Q7XG4gICAgfSxcbiAgICBnZXQgTW9kdWxlU3ltYm9sKCkge1xuICAgICAgcmV0dXJuIE1vZHVsZVN5bWJvbDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL01vZHVsZVZpc2l0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvTW9kdWxlVmlzaXRvci5qc1wiO1xuICB2YXIgRXhwb3J0c0xpc3QgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Nb2R1bGVTeW1ib2wuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVWaXNpdG9yLmpzXCIpKS5FeHBvcnRzTGlzdDtcbiAgdmFyIFBhcnNlVHJlZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L1BhcnNlVHJlZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVWaXNpdG9yLmpzXCIpKS5QYXJzZVRyZWVWaXNpdG9yO1xuICB2YXIgJF9fMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi8uLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL01vZHVsZVZpc2l0b3IuanNcIikpLFxuICAgICAgRVhQT1JUX0RFQ0xBUkFUSU9OID0gJF9fMy5FWFBPUlRfREVDTEFSQVRJT04sXG4gICAgICBJTVBPUlRfREVDTEFSQVRJT04gPSAkX18zLklNUE9SVF9ERUNMQVJBVElPTjtcbiAgdmFyIE1vZHVsZVZpc2l0b3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE1vZHVsZVZpc2l0b3IocmVwb3J0ZXIsIGxvYWRlciwgbW9kdWxlU3ltYm9sKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihNb2R1bGVWaXNpdG9yKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5yZXBvcnRlciA9IHJlcG9ydGVyO1xuICAgICAgdGhpcy5sb2FkZXJfID0gbG9hZGVyO1xuICAgICAgdGhpcy5tb2R1bGVTeW1ib2wgPSBtb2R1bGVTeW1ib2w7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNb2R1bGVWaXNpdG9yLCB7XG4gICAgICBnZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgcmVmZXJyZXIgPSB0aGlzLm1vZHVsZVN5bWJvbC5ub3JtYWxpemVkTmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyXy5nZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcihuYW1lLCByZWZlcnJlcik7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0RnVuY3Rpb25Cb2R5OiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0QmxvY2s6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0Q2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7fSxcbiAgICAgIHZpc2l0TW9kdWxlRWxlbWVudF86IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEVYUE9SVF9ERUNMQVJBVElPTjpcbiAgICAgICAgICBjYXNlIElNUE9SVF9ERUNMQVJBVElPTjpcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbnkoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdFNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0cmVlLnNjcmlwdEl0ZW1MaXN0LmZvckVhY2godGhpcy52aXNpdE1vZHVsZUVsZW1lbnRfLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1vZHVsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0cmVlLnNjcmlwdEl0ZW1MaXN0LmZvckVhY2godGhpcy52aXNpdE1vZHVsZUVsZW1lbnRfLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICByZXBvcnRFcnJvcjogZnVuY3Rpb24odHJlZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlcG9ydGVyLnJlcG9ydEVycm9yKHRyZWUubG9jYXRpb24sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVmlzaXRvcik7XG4gIHJldHVybiB7Z2V0IE1vZHVsZVZpc2l0b3IoKSB7XG4gICAgICByZXR1cm4gTW9kdWxlVmlzaXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvRXhwb3J0VmlzaXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9FeHBvcnRWaXNpdG9yLmpzXCI7XG4gIHZhciBNb2R1bGVWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTW9kdWxlVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydFZpc2l0b3IuanNcIikpLk1vZHVsZVZpc2l0b3I7XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9FeHBvcnRWaXNpdG9yLmpzXCIpKS5hc3NlcnQ7XG4gIHZhciBFeHBvcnRWaXNpdG9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBFeHBvcnRWaXNpdG9yKHJlcG9ydGVyLCBsb2FkZXIsIG1vZHVsZVN5bWJvbCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRXhwb3J0VmlzaXRvcikuY2FsbCh0aGlzLCByZXBvcnRlciwgbG9hZGVyLCBtb2R1bGVTeW1ib2wpO1xuICAgICAgdGhpcy5pbkV4cG9ydF8gPSBmYWxzZTtcbiAgICAgIHRoaXMubW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV4cG9ydFZpc2l0b3IsIHtcbiAgICAgIGFkZEV4cG9ydF86IGZ1bmN0aW9uKG5hbWUsIHRyZWUpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyk7XG4gICAgICAgIGlmICh0aGlzLmluRXhwb3J0XylcbiAgICAgICAgICB0aGlzLmFkZEV4cG9ydChuYW1lLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICBhZGRFeHBvcnQ6IGZ1bmN0aW9uKG5hbWUsIHRyZWUpIHtcbiAgICAgICAgdmFyIG1vZHVsZVN5bWJvbCA9IHRoaXMubW9kdWxlU3ltYm9sO1xuICAgICAgICB2YXIgZXhpc3RpbmdFeHBvcnQgPSBtb2R1bGVTeW1ib2wuZ2V0RXhwb3J0KG5hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFeHBvcnQpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKHRyZWUsIChcIkR1cGxpY2F0ZSBleHBvcnQuICdcIiArIG5hbWUgKyBcIicgd2FzIHByZXZpb3VzbHkgXCIpICsgKFwiZXhwb3J0ZWQgYXQgXCIgKyBleGlzdGluZ0V4cG9ydC5sb2NhdGlvbi5zdGFydCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZHVsZVN5bWJvbC5hZGRFeHBvcnQobmFtZSwgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHBvcnRfKHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW4udmFsdWUsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5pbkV4cG9ydF8gPSB0cnVlO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICB0aGlzLmluRXhwb3J0XyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZWRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVTcGVjaWZpZXIgPSB0cmVlLm1vZHVsZVNwZWNpZmllcjtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cG9ydENsYXVzZSk7XG4gICAgICAgIHRoaXMubW9kdWxlU3BlY2lmaWVyID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cG9ydERlZmF1bHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHBvcnRfKCdkZWZhdWx0JywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHBvcnRfKCh0cmVlLnJocyB8fCB0cmVlLmxocykudmFsdWUsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3RhcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMSA9IHRoaXM7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5tb2R1bGVTcGVjaWZpZXIudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgIHZhciBleHBvcnRMaXN0ID0gdGhpcy5nZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcihuYW1lKTtcbiAgICAgICAgaWYgKGV4cG9ydExpc3QpIHtcbiAgICAgICAgICBleHBvcnRMaXN0LmdldEV4cG9ydHMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkX18xLmFkZEV4cG9ydChuYW1lLCB0cmVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZVNwYWNlRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuYWRkRXhwb3J0Xyh0cmVlLm5hbWUudmFsdWUsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9yd2FyZERlZmF1bHRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHBvcnRfKHRyZWUubmFtZS52YWx1ZSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuYWRkRXhwb3J0Xyh0cmVlLm5hbWUuZ2V0U3RyaW5nVmFsdWUoKSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5sdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QmluZGluZ0lkZW50aWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHBvcnRfKHRyZWUuZ2V0U3RyaW5nVmFsdWUoKSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmFkZEV4cG9ydCh0cmVlLm5hbWUudmFsdWUsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oTW9kdWxlVmlzaXRvcik7XG4gIHJldHVybiB7Z2V0IEV4cG9ydFZpc2l0b3IoKSB7XG4gICAgICByZXR1cm4gRXhwb3J0VmlzaXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvRGlyZWN0RXhwb3J0VmlzaXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9EaXJlY3RFeHBvcnRWaXNpdG9yLmpzXCI7XG4gIHZhciBFeHBvcnRWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRXhwb3J0VmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0RpcmVjdEV4cG9ydFZpc2l0b3IuanNcIikpLkV4cG9ydFZpc2l0b3I7XG4gIHZhciBUWVBFX0FMSUFTX0RFQ0xBUkFUSU9OID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvRGlyZWN0RXhwb3J0VmlzaXRvci5qc1wiKSkuVFlQRV9BTElBU19ERUNMQVJBVElPTjtcbiAgdmFyIERpcmVjdEV4cG9ydFZpc2l0b3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIERpcmVjdEV4cG9ydFZpc2l0b3IoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihEaXJlY3RFeHBvcnRWaXNpdG9yKS5jYWxsKHRoaXMsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgdGhpcy5uYW1lZEV4cG9ydHMgPSBbXTtcbiAgICAgIHRoaXMuc3RhckV4cG9ydHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKERpcmVjdEV4cG9ydFZpc2l0b3IsIHtcbiAgICAgIGFkZEV4cG9ydDogZnVuY3Rpb24obmFtZSwgdHJlZSkge1xuICAgICAgICB0aGlzLm5hbWVkRXhwb3J0cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgbW9kdWxlU3BlY2lmaWVyOiB0aGlzLm1vZHVsZVNwZWNpZmllclxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cG9ydFN0YXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5zdGFyRXhwb3J0cy5wdXNoKHRoaXMubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgIH0sXG4gICAgICBoYXNFeHBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRFeHBvcnRzLmxlbmd0aCAhPT0gMCB8fCB0aGlzLnN0YXJFeHBvcnRzLmxlbmd0aCAhPT0gMDtcbiAgICAgIH0sXG4gICAgICBnZXROb25UeXBlTmFtZWRFeHBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZWRFeHBvcnRzLmZpbHRlcihmdW5jdGlvbihleHApIHtcbiAgICAgICAgICByZXR1cm4gZXhwLnRyZWUudHlwZSAhPT0gVFlQRV9BTElBU19ERUNMQVJBVElPTjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShFeHBvcnRWaXNpdG9yKTtcbiAgcmV0dXJuIHtnZXQgRGlyZWN0RXhwb3J0VmlzaXRvcigpIHtcbiAgICAgIHJldHVybiBEaXJlY3RFeHBvcnRWaXNpdG9yO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFub25CbG9jayA9ICRfXzUuQW5vbkJsb2NrLFxuICAgICAgSW1wb3J0RGVjbGFyYXRpb24gPSAkX181LkltcG9ydERlY2xhcmF0aW9uLFxuICAgICAgSW1wb3J0U3BlY2lmaWVyID0gJF9fNS5JbXBvcnRTcGVjaWZpZXIsXG4gICAgICBJbXBvcnRTcGVjaWZpZXJTZXQgPSAkX181LkltcG9ydFNwZWNpZmllclNldCxcbiAgICAgIE1vZHVsZSA9ICRfXzUuTW9kdWxlO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW1wb3J0U2ltcGxpZnlpbmdUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFOT05fQkxPQ0sgPSAkX183LkFOT05fQkxPQ0ssXG4gICAgICBJTVBPUlRfQ0xBVVNFX1BBSVIgPSAkX183LklNUE9SVF9DTEFVU0VfUEFJUixcbiAgICAgIElNUE9SVF9ERUNMQVJBVElPTiA9ICRfXzcuSU1QT1JUX0RFQ0xBUkFUSU9OLFxuICAgICAgSU1QT1JUX1NQRUNJRklFUl9TRVQgPSAkX183LklNUE9SVF9TUEVDSUZJRVJfU0VULFxuICAgICAgSU1QT1JURURfQklORElORyA9ICRfXzcuSU1QT1JURURfQklORElORyxcbiAgICAgIE5BTUVfU1BBQ0VfSU1QT1JUID0gJF9fNy5OQU1FX1NQQUNFX0lNUE9SVDtcbiAgdmFyIGNyZWF0ZUlkZW50aWZpZXJUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIuanNcIikpLmNyZWF0ZUlkZW50aWZpZXJUb2tlbjtcbiAgdmFyIEltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihJbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSW1wb3J0U2ltcGxpZnlpbmdUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtTW9kdWxlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18yO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuc2NyaXB0SXRlbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHRyZWUuc2NyaXB0SXRlbUxpc3RbaV07XG4gICAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgSU1QT1JUX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdGhpcy50cmFuc2Zvcm1BbnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkLnR5cGUgPT09IEFOT05fQkxPQ0spIHtcbiAgICAgICAgICAgICAgICAgICgkX18yID0gc3RhdGVtZW50cykucHVzaC5hcHBseSgkX18yLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHRyYW5zZm9ybWVkLnN0YXRlbWVudHMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHRyYW5zZm9ybWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bGUodHJlZS5sb2NhdGlvbiwgc3RhdGVtZW50cywgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaW1wb3J0Q2xhdXNlID0gdHJlZS5pbXBvcnRDbGF1c2U7XG4gICAgICAgIGlmIChpbXBvcnRDbGF1c2UgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgc2V0ID0gbmV3IEltcG9ydFNwZWNpZmllclNldChudWxsLCBbXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnREZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBzZXQsIHRyZWUubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0Q2xhdXNlLnR5cGUgPT09IE5BTUVfU1BBQ0VfSU1QT1JUKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcG9ydENsYXVzZS50eXBlID09PSBJTVBPUlRFRF9CSU5ESU5HKSB7XG4gICAgICAgICAgdmFyIHNwZWNpZmllciA9IHRoaXMudHJhbnNmb3JtQW55KGltcG9ydENsYXVzZSk7XG4gICAgICAgICAgdmFyIHNldCRfXzMgPSBuZXcgSW1wb3J0U3BlY2lmaWVyU2V0KG51bGwsIFtzcGVjaWZpZXJdKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEltcG9ydERlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHNldCRfXzMsIHRyZWUubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0Q2xhdXNlLnR5cGUgPT09IElNUE9SVF9DTEFVU0VfUEFJUikge1xuICAgICAgICAgIHZhciAkX18xID0gaW1wb3J0Q2xhdXNlLFxuICAgICAgICAgICAgICBmaXJzdCA9ICRfXzEuZmlyc3QsXG4gICAgICAgICAgICAgIHNlY29uZCA9ICRfXzEuc2Vjb25kO1xuICAgICAgICAgIGlmIChzZWNvbmQudHlwZSA9PT0gSU1QT1JUX1NQRUNJRklFUl9TRVQpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0U3BlY2lmaWVyID0gdGhpcy50cmFuc2Zvcm1BbnkoZmlyc3QpO1xuICAgICAgICAgICAgdmFyIHNwZWNpZmllcnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKFtkZWZhdWx0U3BlY2lmaWVyXSwgc2Vjb25kLnNwZWNpZmllcnMpO1xuICAgICAgICAgICAgdmFyIHNldCRfXzQgPSBuZXcgSW1wb3J0U3BlY2lmaWVyU2V0KGZpcnN0LmxvY2F0aW9uLCBzcGVjaWZpZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1wb3J0RGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgc2V0JF9fNCwgdHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlyc3RJbXBvcnQgPSBuZXcgSW1wb3J0RGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgZmlyc3QsIHRyZWUubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgICBmaXJzdEltcG9ydCA9IHRoaXMudHJhbnNmb3JtQW55KGZpcnN0SW1wb3J0KTtcbiAgICAgICAgICB2YXIgc2Vjb25kSW1wb3J0ID0gbmV3IEltcG9ydERlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHNlY29uZCwgdHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIFtmaXJzdEltcG9ydCwgc2Vjb25kSW1wb3J0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBJbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnRlZEJpbmRpbmc6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4oJ2RlZmF1bHQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBvcnRTcGVjaWZpZXIodHJlZS5sb2NhdGlvbiwgdHJlZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IEltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gSW1wb3J0U2ltcGxpZnlpbmdUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy91dGlsL3VybC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3V0aWwvdXJsLmpzXCI7XG4gIHZhciBjYW5vbmljYWxpemVVcmwgPSAkdHJhY2V1clJ1bnRpbWUuY2Fub25pY2FsaXplVXJsO1xuICB2YXIgaXNBYnNvbHV0ZSA9ICR0cmFjZXVyUnVudGltZS5pc0Fic29sdXRlO1xuICB2YXIgcmVtb3ZlRG90U2VnbWVudHMgPSAkdHJhY2V1clJ1bnRpbWUucmVtb3ZlRG90U2VnbWVudHM7XG4gIHZhciByZXNvbHZlVXJsID0gJHRyYWNldXJSdW50aW1lLnJlc29sdmVVcmw7XG4gIHJldHVybiB7XG4gICAgZ2V0IGNhbm9uaWNhbGl6ZVVybCgpIHtcbiAgICAgIHJldHVybiBjYW5vbmljYWxpemVVcmw7XG4gICAgfSxcbiAgICBnZXQgaXNBYnNvbHV0ZSgpIHtcbiAgICAgIHJldHVybiBpc0Fic29sdXRlO1xuICAgIH0sXG4gICAgZ2V0IHJlbW92ZURvdFNlZ21lbnRzKCkge1xuICAgICAgcmV0dXJuIHJlbW92ZURvdFNlZ21lbnRzO1xuICAgIH0sXG4gICAgZ2V0IHJlc29sdmVVcmwoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybDtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Ta2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdC5qc1wiO1xuICB2YXIgJF9fMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQuanNcIikpLFxuICAgICAgQXJyb3dGdW5jdGlvbiA9ICRfXzEuQXJyb3dGdW5jdGlvbixcbiAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAkX18xLkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb24gPSAkX18xLkZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgIEdldEFjY2Vzc29yID0gJF9fMS5HZXRBY2Nlc3NvcixcbiAgICAgIE1ldGhvZCA9ICRfXzEuTWV0aG9kLFxuICAgICAgU2V0QWNjZXNzb3IgPSAkX18xLlNldEFjY2Vzc29yO1xuICBmdW5jdGlvbiBTa2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lcikge1xuICAgIHJldHVybiBmdW5jdGlvbigkX19zdXBlcikge1xuICAgICAgZnVuY3Rpb24gU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyKCkge1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTa2lwRnVuY3Rpb25zVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyLCB7XG4gICAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgICAgaWYgKGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgdHJlZS5mdW5jdGlvbktpbmQsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS50eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgdHJlZS5ib2R5KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtU2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFNldEFjY2Vzc29yKHRyZWUubG9jYXRpb24sIHRyZWUuaXNTdGF0aWMsIG5hbWUsIHRyZWUucGFyYW1ldGVyTGlzdCwgYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybUdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBuYW1lLCBhbm5vdGF0aW9ucywgdHJlZS5ib2R5KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtTWV0aG9kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdHJlZS5uYW1lICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5mdW5jdGlvbktpbmQsIG5hbWUsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS50eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIHRyZWUuYm9keSwgdHJlZS5kZWJ1Z05hbWUpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1BcnJvd0Z1bmN0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHt9LCAkX19zdXBlcik7XG4gICAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBTa2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBbm9uQmxvY2sgPSAkX184LkFub25CbG9jayxcbiAgICAgIEJpbmRpbmdFbGVtZW50ID0gJF9fOC5CaW5kaW5nRWxlbWVudCxcbiAgICAgIEVtcHR5U3RhdGVtZW50ID0gJF9fOC5FbXB0eVN0YXRlbWVudCxcbiAgICAgIExpdGVyYWxQcm9wZXJ0eU5hbWUgPSAkX184LkxpdGVyYWxQcm9wZXJ0eU5hbWUsXG4gICAgICBNb2R1bGUgPSAkX184Lk1vZHVsZSxcbiAgICAgIE9iamVjdFBhdHRlcm4gPSAkX184Lk9iamVjdFBhdHRlcm4sXG4gICAgICBPYmplY3RQYXR0ZXJuRmllbGQgPSAkX184Lk9iamVjdFBhdHRlcm5GaWVsZCxcbiAgICAgIFNjcmlwdCA9ICRfXzguU2NyaXB0O1xuICB2YXIgRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyO1xuICB2YXIgRGlyZWN0RXhwb3J0VmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL21vZHVsZS9EaXJlY3RFeHBvcnRWaXNpdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuRGlyZWN0RXhwb3J0VmlzaXRvcjtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBJbXBvcnRTaW1wbGlmeWluZ1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW1wb3J0U2ltcGxpZnlpbmdUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLkltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXI7XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciAkX18xNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQ0xBU1NfREVDTEFSQVRJT04gPSAkX18xNC5DTEFTU19ERUNMQVJBVElPTixcbiAgICAgIEVYUE9SVF9ERUZBVUxUID0gJF9fMTQuRVhQT1JUX0RFRkFVTFQsXG4gICAgICBFWFBPUlRfU1BFQ0lGSUVSID0gJF9fMTQuRVhQT1JUX1NQRUNJRklFUixcbiAgICAgIEZPUldBUkRfREVGQVVMVF9FWFBPUlQgPSAkX18xNC5GT1JXQVJEX0RFRkFVTFRfRVhQT1JULFxuICAgICAgRlVOQ1RJT05fREVDTEFSQVRJT04gPSAkX18xNC5GVU5DVElPTl9ERUNMQVJBVElPTixcbiAgICAgIElNUE9SVF9TUEVDSUZJRVJfU0VUID0gJF9fMTQuSU1QT1JUX1NQRUNJRklFUl9TRVQsXG4gICAgICBJTVBPUlRfVFlQRV9DTEFVU0UgPSAkX18xNC5JTVBPUlRfVFlQRV9DTEFVU0UsXG4gICAgICBOQU1FX1NQQUNFX0VYUE9SVCA9ICRfXzE0Lk5BTUVfU1BBQ0VfRVhQT1JUO1xuICB2YXIgVkFSID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5WQVI7XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5hc3NlcnQ7XG4gIHZhciAkX18xNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi91dGlsL3VybC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgcmVzb2x2ZVVybCA9ICRfXzE3LnJlc29sdmVVcmwsXG4gICAgICBjYW5vbmljYWxpemVVcmwgPSAkX18xNy5jYW5vbmljYWxpemVVcmw7XG4gIHZhciAkX18xOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUFyZ3VtZW50TGlzdCA9ICRfXzE4LmNyZWF0ZUFyZ3VtZW50TGlzdCxcbiAgICAgIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX18xOC5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50LFxuICAgICAgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18xOC5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJUb2tlbiA9ICRfXzE4LmNyZWF0ZUlkZW50aWZpZXJUb2tlbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX18xOC5jcmVhdGVNZW1iZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlT2JqZWN0TGl0ZXJhbCA9ICRfXzE4LmNyZWF0ZU9iamVjdExpdGVyYWwsXG4gICAgICBjcmVhdGVVc2VTdHJpY3REaXJlY3RpdmUgPSAkX18xOC5jcmVhdGVVc2VTdHJpY3REaXJlY3RpdmUsXG4gICAgICBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudCA9ICRfXzE4LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50LFxuICAgICAgY3JlYXRlVm9pZDAgPSAkX18xOC5jcmVhdGVWb2lkMDtcbiAgdmFyICRfXzE5ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbiA9ICRfXzE5LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uID0gJF9fMTkucGFyc2VQcm9wZXJ0eURlZmluaXRpb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzE5LnBhcnNlU3RhdGVtZW50LFxuICAgICAgcGFyc2VTdGF0ZW1lbnRzID0gJF9fMTkucGFyc2VTdGF0ZW1lbnRzO1xuICB2YXIgU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ta2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkucHJlcGVuZFN0YXRlbWVudHM7XG4gIGZ1bmN0aW9uIHJlbW92ZVVzZVN0cmljdERpcmVjdGl2ZXModHJlZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmVlLnNjcmlwdEl0ZW1MaXN0LmZpbHRlcihmdW5jdGlvbih0cmVlKSB7XG4gICAgICByZXR1cm4gIXRyZWUuaXNVc2VTdHJpY3REaXJlY3RpdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1vZHVsZSh0cmVlLmxvY2F0aW9uLCByZXN1bHQsIHRyZWUubW9kdWxlTmFtZSk7XG4gIH1cbiAgdmFyIERlc3RydWN0SW1wb3J0VmFyU3RhdGVtZW50ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZXN0cnVjdEltcG9ydFZhclN0YXRlbWVudCgpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKERlc3RydWN0SW1wb3J0VmFyU3RhdGVtZW50KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRGVzdHJ1Y3RJbXBvcnRWYXJTdGF0ZW1lbnQsIHtjcmVhdGVHdWFyZGVkRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KERlc3RydWN0dXJpbmdUcmFuc2Zvcm1lcik7XG4gIHZhciBNb2R1bGVUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTW9kdWxlVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKE1vZHVsZVRyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZXhwb3J0VmlzaXRvciA9IG5ldyBEaXJlY3RFeHBvcnRWaXNpdG9yKCk7XG4gICAgICB0aGlzLmltcG9ydFNpbXBsaWZpZXJfID0gbmV3IEltcG9ydFNpbXBsaWZ5aW5nVHJhbnNmb3JtZXIoKTtcbiAgICAgIHRoaXMubW9kdWxlTmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNb2R1bGVUcmFuc2Zvcm1lciwge1xuICAgICAgZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVOYW1lOiBmdW5jdGlvbihtb2R1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiAnJF9fJyArIG1vZHVsZU5hbWUucmVwbGFjZSgvW15hLXpBLVowLTkkXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuICdfJyArIFN0cmluZyhjLmNoYXJDb2RlQXQoMCkpICsgJ18nO1xuICAgICAgICB9KSArICdfXyc7XG4gICAgICB9LFxuICAgICAgZ2V0TW9kdWxlTmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZS5tb2R1bGVOYW1lO1xuICAgICAgfSxcbiAgICAgIGdldFRlbXBWYXJOYW1lRm9yTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbihtb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtb2R1bGVTcGVjaWZpZXIudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnLicgJiYgdGhpcy5tb2R1bGVOYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHJlc29sdmVVcmwodGhpcy5tb2R1bGVOYW1lLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gY2Fub25pY2FsaXplVXJsKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRlbXBWYXJOYW1lRm9yTW9kdWxlTmFtZShuYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TY3JpcHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVOYW1lID0gdHJlZS5tb2R1bGVOYW1lO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIE1vZHVsZVRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1TY3JpcHRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Nb2R1bGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdHJlZSA9IHJlbW92ZVVzZVN0cmljdERpcmVjdGl2ZXModHJlZSk7XG4gICAgICAgIHRyZWUgPSB0aGlzLmltcG9ydFNpbXBsaWZpZXJfLnRyYW5zZm9ybU1vZHVsZSh0cmVlKTtcbiAgICAgICAgdmFyIHJlcGxhY2VUaGlzID0gbmV3IFJlcGxhY2VUaGlzKCk7XG4gICAgICAgIHRyZWUgPSByZXBsYWNlVGhpcy50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgIHRoaXMubW9kdWxlTmFtZSA9IHRoaXMuZ2V0TW9kdWxlTmFtZSh0cmVlKTtcbiAgICAgICAgdGhpcy5wdXNoVGVtcFNjb3BlKCk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuc2NyaXB0SXRlbUxpc3QpO1xuICAgICAgICBzdGF0ZW1lbnRzID0gdGhpcy5hZGRFeHBvcnRTdGF0ZW1lbnQoc3RhdGVtZW50cyk7XG4gICAgICAgIHZhciBydW50aW1lSW1wb3J0cyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0aGlzLmdldFJ1bnRpbWVJbXBvcnRzKCkpO1xuICAgICAgICBzdGF0ZW1lbnRzID0gcHJlcGVuZFN0YXRlbWVudHMuYXBwbHkoKHZvaWQgMCksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3N0YXRlbWVudHNdLCBydW50aW1lSW1wb3J0cykpO1xuICAgICAgICB0aGlzLnBvcFRlbXBTY29wZSgpO1xuICAgICAgICBzdGF0ZW1lbnRzID0gdGhpcy53cmFwTW9kdWxlKHRoaXMubW9kdWxlUHJvbG9nKCkuY29uY2F0KHN0YXRlbWVudHMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY3JpcHQodHJlZS5sb2NhdGlvbiwgc3RhdGVtZW50cywgbnVsbCk7XG4gICAgICB9LFxuICAgICAgbW9kdWxlUHJvbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbY3JlYXRlVXNlU3RyaWN0RGlyZWN0aXZlKCldO1xuICAgICAgICBpZiAodGhpcy5tb2R1bGVOYW1lKSB7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJ2YXIgX19tb2R1bGVOYW1lID0gXCIsIFwiO1wiXSksIHRoaXMubW9kdWxlTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIHdyYXBNb2R1bGU6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIGZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1PcHRpb25zLnJlcXVpcmUpIHtcbiAgICAgICAgICBmdW5jdGlvbkV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImZ1bmN0aW9uKHJlcXVpcmUpIHtcXG4gICAgICAgIFwiLCBcIlxcbiAgICAgIH1cIl0pLCBzdGF0ZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmdW5jdGlvbkV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImZ1bmN0aW9uKCkge1xcbiAgICAgICAgXCIsIFwiXFxuICAgICAgfVwiXSksIHN0YXRlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkdHJhY2V1clJ1bnRpbWUuTW9kdWxlU3RvcmUuZ2V0QW5vbnltb3VzTW9kdWxlKFxcbiAgICAgICAgICAgICAgXCIsIFwiKTtcIl0pLCBmdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcIiwgXCIsIFtdLCBcIiwgXCIpO1wiXSksIHRoaXMubW9kdWxlTmFtZSwgZnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICBnZXRHZXR0ZXJFeHBvcnQ6IGZ1bmN0aW9uKGV4cCkge1xuICAgICAgICB2YXIgcmV0dXJuRXhwcmVzc2lvbiA9IHRoaXMuZ2V0R2V0dGVyRXhwb3J0UmV0dXJuRXhwcmVzc2lvbihleHApO1xuICAgICAgICByZXR1cm4gcGFyc2VQcm9wZXJ0eURlZmluaXRpb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImdldCBcIiwgXCIoKSB7IHJldHVybiBcIiwgXCI7IH1cIl0pLCBleHAubmFtZSwgcmV0dXJuRXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgZ2V0R2V0dGVyRXhwb3J0UmV0dXJuRXhwcmVzc2lvbjogZnVuY3Rpb24oJF9fNCkge1xuICAgICAgICB2YXIgJF9fNSA9ICRfXzQsXG4gICAgICAgICAgICBuYW1lID0gJF9fNS5uYW1lLFxuICAgICAgICAgICAgdHJlZSA9ICRfXzUudHJlZSxcbiAgICAgICAgICAgIG1vZHVsZVNwZWNpZmllciA9ICRfXzUubW9kdWxlU3BlY2lmaWVyO1xuICAgICAgICB2YXIgcmV0dXJuRXhwcmVzc2lvbjtcbiAgICAgICAgc3dpdGNoICh0cmVlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEVYUE9SVF9ERUZBVUxUOlxuICAgICAgICAgICAgc3dpdGNoICh0cmVlLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIENMQVNTX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgICBjYXNlIEZVTkNUSU9OX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0cmVlLmV4cHJlc3Npb24ubmFtZSk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKCckX19kZWZhdWx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYUE9SVF9TUEVDSUZJRVI6XG4gICAgICAgICAgICBpZiAobW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgIHZhciBpZE5hbWUgPSB0aGlzLmdldFRlbXBWYXJOYW1lRm9yTW9kdWxlU3BlY2lmaWVyKG1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGlkTmFtZSwgdHJlZS5saHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRyZWUubGhzKTtcbiAgICAgICAgICBjYXNlIE5BTUVfU1BBQ0VfRVhQT1JUOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaWROYW1lJF9fNiA9IHRoaXMuZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVTcGVjaWZpZXIobW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKGlkTmFtZSRfXzYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgRk9SV0FSRF9ERUZBVUxUX0VYUE9SVDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGlkTmFtZSRfXzcgPSB0aGlzLmdldFRlbXBWYXJOYW1lRm9yTW9kdWxlU3BlY2lmaWVyKG1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGlkTmFtZSRfXzcsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydFZpc2l0b3IuZ2V0Tm9uVHlwZU5hbWVkRXhwb3J0cygpLm1hcChmdW5jdGlvbihleHApIHtcbiAgICAgICAgICByZXR1cm4gJF9fMy5nZXRHZXR0ZXJFeHBvcnQoZXhwKTtcbiAgICAgICAgfSkuY29uY2F0KHRoaXMuZXhwb3J0VmlzaXRvci5uYW1lZEV4cG9ydHMubWFwKGZ1bmN0aW9uKGV4cCkge1xuICAgICAgICAgIHJldHVybiAkX18zLmdldFNldHRlckV4cG9ydChleHApO1xuICAgICAgICB9KSkuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U2V0dGVyRXhwb3J0OiBmdW5jdGlvbigkX180KSB7XG4gICAgICAgIHZhciAkX181ID0gJF9fNCxcbiAgICAgICAgICAgIG5hbWUgPSAkX181Lm5hbWUsXG4gICAgICAgICAgICB0cmVlID0gJF9fNS50cmVlLFxuICAgICAgICAgICAgbW9kdWxlU3BlY2lmaWVyID0gJF9fNS5tb2R1bGVTcGVjaWZpZXI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydE9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBleHBvcnRPYmplY3QgPSBjcmVhdGVPYmplY3RMaXRlcmFsKHRoaXMuZ2V0RXhwb3J0UHJvcGVydGllcygpKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhckV4cG9ydHMoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4cG9ydFN0YXIoZXhwb3J0T2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0T2JqZWN0O1xuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydFN0YXI6IGZ1bmN0aW9uKGV4cG9ydE9iamVjdCkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFyRXhwb3J0cyA9IHRoaXMuZXhwb3J0VmlzaXRvci5zdGFyRXhwb3J0cztcbiAgICAgICAgdmFyIHN0YXJJZGVudHMgPSBzdGFyRXhwb3J0cy5tYXAoZnVuY3Rpb24obW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKCRfXzMuZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVTcGVjaWZpZXIobW9kdWxlU3BlY2lmaWVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYXJncyA9IGNyZWF0ZUFyZ3VtZW50TGlzdCgkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKFtleHBvcnRPYmplY3RdLCBzdGFySWRlbnRzKSk7XG4gICAgICAgIHZhciBydW50aW1lID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignZXhwb3J0U3RhcicpO1xuICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcIiwgXCIoXCIsIFwiKVwiXSksIHJ1bnRpbWUsIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFkZEV4cG9ydFN0YXRlbWVudDogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgZXhwb3J0T2JqZWN0ID0gdGhpcy5nZXRFeHBvcnRPYmplY3QoKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJyZXR1cm4gXCIsIFwiXCJdKSwgZXhwb3J0T2JqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGhhc0V4cG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRWaXNpdG9yLmhhc0V4cG9ydHMoKTtcbiAgICAgIH0sXG4gICAgICBoYXNTdGFyRXhwb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydFZpc2l0b3Iuc3RhckV4cG9ydHMubGVuZ3RoID4gMDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmV4cG9ydFZpc2l0b3IudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmRlY2xhcmF0aW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWZhdWx0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHN3aXRjaCAodHJlZS5leHByZXNzaW9uLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIENMQVNTX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgIGNhc2UgRlVOQ1RJT05fREVDTEFSQVRJT046XG4gICAgICAgICAgICByZXR1cm4gdHJlZS5leHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1widmFyICRfX2RlZmF1bHQgPSBcIiwgXCJcIl0pLCB0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBtb2R1bGVTcGVjaWZpZXIgPSB0cmVlLm1vZHVsZVNwZWNpZmllcjtcbiAgICAgICAgaWYgKG1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkobW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgICB2YXIgaWROYW1lID0gdGhpcy5nZXRUZW1wVmFyTmFtZUZvck1vZHVsZVNwZWNpZmllcihtb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChWQVIsIGlkTmFtZSwgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5tb2R1bGVOYW1lKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0cmVlLnRva2VuLnByb2Nlc3NlZFZhbHVlO1xuICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKFxcbiAgICAgICR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLCBcIiwgXCIsIFwiKSk7XCJdKSwgbmFtZSwgdGhpcy5tb2R1bGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5pbXBvcnRDbGF1c2UudHlwZSA9PT0gSU1QT1JUX1RZUEVfQ0xBVVNFKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLmltcG9ydENsYXVzZS50eXBlID09PSBJTVBPUlRfU1BFQ0lGSUVSX1NFVCAmJiB0cmVlLmltcG9ydENsYXVzZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KHRoaXMudHJhbnNmb3JtQW55KHRyZWUubW9kdWxlU3BlY2lmaWVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmltcG9ydENsYXVzZSk7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgdmFyIHZhclN0YXRlbWVudCA9IGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFZBUiwgYmluZGluZywgaW5pdGlhbGl6ZXIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybU9wdGlvbnMuZGVzdHJ1Y3R1cmluZyB8fCAhdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucy5kZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgdmFyIGRlc3RydWN0dXJpbmdUcmFuc2Zvcm1lciA9IG5ldyBEZXN0cnVjdEltcG9ydFZhclN0YXRlbWVudCh0aGlzLmlkZW50aWZpZXJHZW5lcmF0b3IsIHRoaXMucmVwb3J0ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgdmFyU3RhdGVtZW50ID0gdmFyU3RhdGVtZW50LnRyYW5zZm9ybShkZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJTdGF0ZW1lbnQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW1wb3J0U3BlY2lmaWVyU2V0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zcGVjaWZpZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RQYXR0ZXJuKG51bGwsIGZpZWxkcyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTmFtZVNwYWNlSW1wb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlLmJpbmRpbmcuYmluZGluZztcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0cmVlLmJpbmRpbmcuYmluZGluZztcbiAgICAgICAgdmFyIGJpbmRpbmdFbGVtZW50ID0gbmV3IEJpbmRpbmdFbGVtZW50KGJpbmRpbmcubG9jYXRpb24sIGJpbmRpbmcsIG51bGwpO1xuICAgICAgICBpZiAodHJlZS5uYW1lKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBuZXcgTGl0ZXJhbFByb3BlcnR5TmFtZSh0cmVlLm5hbWUubG9jYXRpb24sIHRyZWUubmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RQYXR0ZXJuRmllbGQodHJlZS5sb2NhdGlvbiwgbmFtZSwgYmluZGluZ0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nRWxlbWVudDtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChUZW1wVmFyVHJhbnNmb3JtZXIpKTtcbiAgdmFyIFJlcGxhY2VUaGlzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBSZXBsYWNlVGhpcygpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFJlcGxhY2VUaGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUmVwbGFjZVRoaXMsIHt0cmFuc2Zvcm1UaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVm9pZDAoKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFNraXBGdW5jdGlvbnNUcmFuc2Zvcm1lclRyYWl0KFBhcnNlVHJlZVRyYW5zZm9ybWVyKSk7XG4gIHJldHVybiB7Z2V0IE1vZHVsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIE1vZHVsZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dsb2JhbFRoaXMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nbG9iYWxUaGlzLmpzXCI7XG4gIHZhciBwYXJzZUV4cHJlc3Npb24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2xvYmFsVGhpcy5qc1wiKSkucGFyc2VFeHByZXNzaW9uO1xuICB2YXIgZXhwcjtcbiAgZnVuY3Rpb24gZ2xvYmFsVGhpcygpIHtcbiAgICBpZiAoIWV4cHIpXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJSZWZsZWN0Lmdsb2JhbFwiXSkpO1xuICAgIHJldHVybiBleHByO1xuICB9XG4gIHZhciAkX19kZWZhdWx0ID0gZ2xvYmFsVGhpcztcbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiAkX19kZWZhdWx0O1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FtZFRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW1kVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIE1vZHVsZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTW9kdWxlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FtZFRyYW5zZm9ybWVyLmpzXCIpKS5Nb2R1bGVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BbWRUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzMuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVGb3JtYWxQYXJhbWV0ZXIgPSAkX18zLmNyZWF0ZUZvcm1hbFBhcmFtZXRlcixcbiAgICAgIGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbiA9ICRfXzMuY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuO1xuICB2YXIgZ2xvYmFsVGhpcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2dsb2JhbFRoaXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FtZFRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fNSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BbWRUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX181LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fNS5wYXJzZVN0YXRlbWVudCxcbiAgICAgIHBhcnNlU3RhdGVtZW50cyA9ICRfXzUucGFyc2VTdGF0ZW1lbnRzLFxuICAgICAgcGFyc2VQcm9wZXJ0eURlZmluaXRpb24gPSAkX181LnBhcnNlUHJvcGVydHlEZWZpbml0aW9uO1xuICB2YXIgJF9fNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW1kVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRm9ybWFsUGFyYW1ldGVyTGlzdCA9ICRfXzYuRm9ybWFsUGFyYW1ldGVyTGlzdCxcbiAgICAgIEZ1bmN0aW9uQm9keSA9ICRfXzYuRnVuY3Rpb25Cb2R5LFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNi5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBBbWRUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQW1kVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQW1kVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgIHRoaXMuYW5vbnltb3VzTW9kdWxlID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5idW5kbGUgJiYgb3B0aW9ucy5tb2R1bGVOYW1lICE9PSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQW1kVHJhbnNmb3JtZXIsIHtcbiAgICAgIGdldE1vZHVsZU5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5vbnltb3VzTW9kdWxlKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdHJlZS5tb2R1bGVOYW1lO1xuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbWRUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwiZ2V0RXhwb3J0UHJvcGVydGllc1wiKS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5leHBvcnRWaXNpdG9yLmhhc0V4cG9ydHMoKSlcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocGFyc2VQcm9wZXJ0eURlZmluaXRpb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIl9fZXNNb2R1bGU6IHRydWVcIl0pKSk7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSxcbiAgICAgIG1vZHVsZVByb2xvZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2NhbHMgPSB0aGlzLmRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24oZGVwKSB7XG4gICAgICAgICAgdmFyIGxvY2FsID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oZGVwLmxvY2FsKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImlmICghXCIsIFwiIHx8ICFcIiwgXCIuX19lc01vZHVsZSlcXG4gICAgICAgICAgICBcIiwgXCIgPSB7ZGVmYXVsdDogXCIsIFwifVwiXSksIGxvY2FsLCBsb2NhbCwgbG9jYWwsIGxvY2FsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQW1kVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcIm1vZHVsZVByb2xvZ1wiKS5jYWxsKHRoaXMpLmNvbmNhdChsb2NhbHMpO1xuICAgICAgfSxcbiAgICAgIHdyYXBNb2R1bGU6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIGRlcFBhdGhzID0gdGhpcy5kZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uKGRlcCkge1xuICAgICAgICAgIHJldHVybiBkZXAucGF0aDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmb3JtYWxzID0gdGhpcy5kZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uKGRlcCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVGb3JtYWxQYXJhbWV0ZXIoZGVwLmxvY2FsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gbmV3IEZvcm1hbFBhcmFtZXRlckxpc3QobnVsbCwgZm9ybWFscyk7XG4gICAgICAgIHZhciBib2R5ID0gbmV3IEZ1bmN0aW9uQm9keShudWxsLCBzdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIG51bGwsIG51bGwsIHBhcmFtZXRlckxpc3QsIG51bGwsIFtdLCBib2R5KTtcbiAgICAgICAgaWYgKHRoaXMubW9kdWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImRlZmluZShcIiwgXCIsIFwiLCBcIiwgXCIsIFwiKTtcIl0pLCB0aGlzLm1vZHVsZU5hbWUsIGRlcFBhdGhzLCBmdW5jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJkZWZpbmUoXCIsIFwiLCBcIiwgXCIpO1wiXSksIGRlcFBhdGhzLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbG9jYWxOYW1lID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cmVlLnRva2VuLnByb2Nlc3NlZFZhbHVlO1xuICAgICAgICB2YXIgc3RyaW5nTGl0ZXJhbCA9IGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbih2YWx1ZS5yZXBsYWNlKC9cXC5qcyQvLCAnJykpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBzdHJpbmdMaXRlcmFsLFxuICAgICAgICAgIGxvY2FsOiBsb2NhbE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihsb2NhbE5hbWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oTW9kdWxlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBBbWRUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBBbWRUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvUHJvcE5hbWUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zdGF0aWNzZW1hbnRpY3MvUHJvcE5hbWUuanNcIjtcbiAgdmFyICRfXzAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N0YXRpY3NlbWFudGljcy9Qcm9wTmFtZS5qc1wiKSksXG4gICAgICBDT01QVVRFRF9QUk9QRVJUWV9OQU1FID0gJF9fMC5DT01QVVRFRF9QUk9QRVJUWV9OQU1FLFxuICAgICAgR0VUX0FDQ0VTU09SID0gJF9fMC5HRVRfQUNDRVNTT1IsXG4gICAgICBMSVRFUkFMX1BST1BFUlRZX05BTUUgPSAkX18wLkxJVEVSQUxfUFJPUEVSVFlfTkFNRSxcbiAgICAgIE1FVEhPRCA9ICRfXzAuTUVUSE9ELFxuICAgICAgUFJPUEVSVFlfTkFNRV9BU1NJR05NRU5UID0gJF9fMC5QUk9QRVJUWV9OQU1FX0FTU0lHTk1FTlQsXG4gICAgICBQUk9QRVJUWV9OQU1FX1NIT1JUSEFORCA9ICRfXzAuUFJPUEVSVFlfTkFNRV9TSE9SVEhBTkQsXG4gICAgICBTRVRfQUNDRVNTT1IgPSAkX18wLlNFVF9BQ0NFU1NPUjtcbiAgdmFyIElERU5USUZJRVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3RhdGljc2VtYW50aWNzL1Byb3BOYW1lLmpzXCIpKS5JREVOVElGSUVSO1xuICBmdW5jdGlvbiBwcm9wTmFtZSh0cmVlKSB7XG4gICAgc3dpdGNoICh0cmVlLnR5cGUpIHtcbiAgICAgIGNhc2UgTElURVJBTF9QUk9QRVJUWV9OQU1FOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdHJlZS5saXRlcmFsVG9rZW47XG4gICAgICAgICAgaWYgKHRva2VuLmlzS2V5d29yZCgpIHx8IHRva2VuLnR5cGUgPT09IElERU5USUZJRVIpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHRyZWUubGl0ZXJhbFRva2VuLnByb2Nlc3NlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDT01QVVRFRF9QUk9QRVJUWV9OQU1FOlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICBjYXNlIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EOlxuICAgICAgICByZXR1cm4gdHJlZS5uYW1lLnRvU3RyaW5nKCk7XG4gICAgICBjYXNlIE1FVEhPRDpcbiAgICAgIGNhc2UgUFJPUEVSVFlfTkFNRV9BU1NJR05NRU5UOlxuICAgICAgY2FzZSBHRVRfQUNDRVNTT1I6XG4gICAgICBjYXNlIFNFVF9BQ0NFU1NPUjpcbiAgICAgICAgcmV0dXJuIHByb3BOYW1lKHRyZWUubmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Z2V0IHByb3BOYW1lKCkge1xuICAgICAgcmV0dXJuIHByb3BOYW1lO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Fubm90YXRpb25zVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bbm5vdGF0aW9uc1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bbm5vdGF0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIENPTlNUUlVDVE9SID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuQ09OU1RSVUNUT1I7XG4gIHZhciBTVFJJTkcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuU1RSSU5HO1xuICB2YXIgJF9fOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBbm9uQmxvY2sgPSAkX184LkFub25CbG9jayxcbiAgICAgIENsYXNzRGVjbGFyYXRpb24gPSAkX184LkNsYXNzRGVjbGFyYXRpb24sXG4gICAgICBFeHBvcnREZWNsYXJhdGlvbiA9ICRfXzguRXhwb3J0RGVjbGFyYXRpb24sXG4gICAgICBGb3JtYWxQYXJhbWV0ZXIgPSAkX184LkZvcm1hbFBhcmFtZXRlcixcbiAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24gPSAkX184LkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBHZXRBY2Nlc3NvciA9ICRfXzguR2V0QWNjZXNzb3IsXG4gICAgICBMaXRlcmFsRXhwcmVzc2lvbiA9ICRfXzguTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBNZXRob2QgPSAkX184Lk1ldGhvZCxcbiAgICAgIFNldEFjY2Vzc29yID0gJF9fOC5TZXRBY2Nlc3NvcjtcbiAgdmFyIHByb3BOYW1lID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N0YXRpY3NlbWFudGljcy9Qcm9wTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkucHJvcE5hbWU7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Fubm90YXRpb25zVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXJndW1lbnRMaXN0ID0gJF9fMTAuY3JlYXRlQXJndW1lbnRMaXN0LFxuICAgICAgY3JlYXRlQXJyYXlMaXRlcmFsID0gJF9fMTAuY3JlYXRlQXJyYXlMaXRlcmFsLFxuICAgICAgY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCA9ICRfXzEwLmNyZWF0ZUFzc2lnbm1lbnRTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzEwLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzEwLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOZXdFeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlTmV3RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbiA9ICRfXzEwLmNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbjtcbiAgdmFyICRfXzExID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Fubm90YXRpb25zVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgcGFyc2VFeHByZXNzaW9uID0gJF9fMTEucGFyc2VFeHByZXNzaW9uLFxuICAgICAgcGFyc2VTdGF0ZW1lbnQgPSAkX18xMS5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIEFubm90YXRpb25zU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uc1Njb3BlKCkge1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBudWxsO1xuICAgICAgdGhpcy5pc0V4cG9ydCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMubWV0YWRhdGEgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFubm90YXRpb25zU2NvcGUsIHtnZXQgaW5DbGFzc1Njb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc05hbWUgIT09IG51bGw7XG4gICAgICB9fSwge30pO1xuICB9KCk7XG4gIHZhciBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQW5ub3RhdGlvbnNUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuc3RhY2tfID0gW25ldyBBbm5vdGF0aW9uc1Njb3BlKCldO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQW5ub3RhdGlvbnNUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzM7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaEFubm90YXRpb25TY29wZV8oKTtcbiAgICAgICAgc2NvcGUuaXNFeHBvcnQgPSB0cnVlO1xuICAgICAgICAoJF9fMyA9IHNjb3BlLmFubm90YXRpb25zKS5wdXNoLmFwcGx5KCRfXzMsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodHJlZS5hbm5vdGF0aW9ucykpO1xuICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmRlY2xhcmF0aW9uKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uICE9PSB0cmVlLmRlY2xhcmF0aW9uIHx8IHRyZWUuYW5ub3RhdGlvbnMubGVuZ3RoID4gMClcbiAgICAgICAgICB0cmVlID0gbmV3IEV4cG9ydERlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIGRlY2xhcmF0aW9uLCBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZE1ldGFkYXRhXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zLFxuICAgICAgICAgICAgJF9fNDtcbiAgICAgICAgdmFyIGVsZW1lbnRzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXhwb3J0QW5ub3RhdGlvbnMgPSB0aGlzLnNjb3BlLmlzRXhwb3J0ID8gdGhpcy5zY29wZS5hbm5vdGF0aW9ucyA6IFtdO1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnB1c2hBbm5vdGF0aW9uU2NvcGVfKCk7XG4gICAgICAgIHNjb3BlLmNsYXNzTmFtZSA9IHRyZWUubmFtZTtcbiAgICAgICAgKCRfXzMgPSBzY29wZS5hbm5vdGF0aW9ucykucHVzaC5hcHBseSgkX18zLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGV4cG9ydEFubm90YXRpb25zLCB0cmVlLmFubm90YXRpb25zKSk7XG4gICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAoJF9fNCA9IHNjb3BlLm1ldGFkYXRhKS51bnNoaWZ0LmFwcGx5KCRfXzQsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodGhpcy50cmFuc2Zvcm1NZXRhZGF0YV8oY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5uYW1lKSwgc2NvcGUuYW5ub3RhdGlvbnMsIHNjb3BlLmNvbnN0cnVjdG9yUGFyYW1ldGVycykpKTtcbiAgICAgICAgaWYgKHRyZWUuYW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyZWUgPSBuZXcgQ2xhc3NEZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuc3VwZXJDbGFzcywgdHJlZS5lbGVtZW50cywgW10sIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZE1ldGFkYXRhXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zLFxuICAgICAgICAgICAgJF9fNDtcbiAgICAgICAgdmFyIGV4cG9ydEFubm90YXRpb25zID0gdGhpcy5zY29wZS5pc0V4cG9ydCA/IHRoaXMuc2NvcGUuYW5ub3RhdGlvbnMgOiBbXTtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5wdXNoQW5ub3RhdGlvblNjb3BlXygpO1xuICAgICAgICAoJF9fMyA9IHNjb3BlLmFubm90YXRpb25zKS5wdXNoLmFwcGx5KCRfXzMsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoZXhwb3J0QW5ub3RhdGlvbnMsIHRyZWUuYW5ub3RhdGlvbnMpKTtcbiAgICAgICAgKCRfXzQgPSBzY29wZS5tZXRhZGF0YSkucHVzaC5hcHBseSgkX180LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHRoaXMudHJhbnNmb3JtTWV0YWRhdGFfKGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRyZWUubmFtZSksIHNjb3BlLmFubm90YXRpb25zLCB0cmVlLnBhcmFtZXRlckxpc3QucGFyYW1ldGVycykpKTtcbiAgICAgICAgdHJlZSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIGlmICh0cmVlLmFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0cmVlID0gbmV3IEZ1bmN0aW9uRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCBbXSwgdHJlZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmRNZXRhZGF0YV8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9ybWFsUGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0cmVlID0gbmV3IEZvcm1hbFBhcmFtZXRlcih0cmVlLmxvY2F0aW9uLCB0cmVlLnBhcmFtZXRlciwgdHJlZS50eXBlQW5ub3RhdGlvbiwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9ybWFsUGFyYW1ldGVyXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtR2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzM7XG4gICAgICAgIGlmICghdGhpcy5zY29wZS5pbkNsYXNzU2NvcGUpXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1HZXRBY2Nlc3NvclwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAoJF9fMyA9IHRoaXMuc2NvcGUubWV0YWRhdGEpLnB1c2guYXBwbHkoJF9fMywgJHRyYWNldXJSdW50aW1lLnNwcmVhZCh0aGlzLnRyYW5zZm9ybU1ldGFkYXRhXyh0aGlzLnRyYW5zZm9ybUFjY2Vzc29yXyh0cmVlLCB0aGlzLnNjb3BlLmNsYXNzTmFtZSwgJ2dldCcpLCB0cmVlLmFubm90YXRpb25zLCBbXSkpKTtcbiAgICAgICAgaWYgKHRyZWUuYW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyZWUgPSBuZXcgR2V0QWNjZXNzb3IodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5uYW1lLCB0cmVlLnR5cGVBbm5vdGF0aW9uLCBbXSwgdHJlZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFubm90YXRpb25zVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUdldEFjY2Vzc29yXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzM7XG4gICAgICAgIGlmICghdGhpcy5zY29wZS5pbkNsYXNzU2NvcGUpXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1TZXRBY2Nlc3NvclwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAoJF9fMyA9IHRoaXMuc2NvcGUubWV0YWRhdGEpLnB1c2guYXBwbHkoJF9fMywgJHRyYWNldXJSdW50aW1lLnNwcmVhZCh0aGlzLnRyYW5zZm9ybU1ldGFkYXRhXyh0aGlzLnRyYW5zZm9ybUFjY2Vzc29yXyh0cmVlLCB0aGlzLnNjb3BlLmNsYXNzTmFtZSwgJ3NldCcpLCB0cmVlLmFubm90YXRpb25zLCB0cmVlLnBhcmFtZXRlckxpc3QucGFyYW1ldGVycykpKTtcbiAgICAgICAgdmFyIHBhcmFtZXRlckxpc3QgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICBpZiAocGFyYW1ldGVyTGlzdCAhPT0gdHJlZS5wYXJhbWV0ZXJMaXN0IHx8IHRyZWUuYW5ub3RhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRyZWUgPSBuZXcgU2V0QWNjZXNzb3IodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5uYW1lLCBwYXJhbWV0ZXJMaXN0LCBbXSwgdHJlZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFubm90YXRpb25zVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVNldEFjY2Vzc29yXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWV0aG9kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zLFxuICAgICAgICAgICAgJF9fNDtcbiAgICAgICAgaWYgKCF0aGlzLnNjb3BlLmluQ2xhc3NTY29wZSlcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFubm90YXRpb25zVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybU1ldGhvZFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICBpZiAoIXRyZWUuaXNTdGF0aWMgJiYgcHJvcE5hbWUodHJlZSkgPT09IENPTlNUUlVDVE9SKSB7XG4gICAgICAgICAgKCRfXzMgPSB0aGlzLnNjb3BlLmFubm90YXRpb25zKS5wdXNoLmFwcGx5KCRfXzMsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodHJlZS5hbm5vdGF0aW9ucykpO1xuICAgICAgICAgIHRoaXMuc2NvcGUuY29uc3RydWN0b3JQYXJhbWV0ZXJzID0gdHJlZS5wYXJhbWV0ZXJMaXN0LnBhcmFtZXRlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKCRfXzQgPSB0aGlzLnNjb3BlLm1ldGFkYXRhKS5wdXNoLmFwcGx5KCRfXzQsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodGhpcy50cmFuc2Zvcm1NZXRhZGF0YV8odGhpcy50cmFuc2Zvcm1Qcm9wZXJ0eU1ldGhvZF8odHJlZSwgdGhpcy5zY29wZS5jbGFzc05hbWUpLCB0cmVlLmFubm90YXRpb25zLCB0cmVlLnBhcmFtZXRlckxpc3QucGFyYW1ldGVycykpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJMaXN0ICE9PSB0cmVlLnBhcmFtZXRlckxpc3QgfHwgdHJlZS5hbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdHJlZSA9IG5ldyBNZXRob2QodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5mdW5jdGlvbktpbmQsIHRyZWUubmFtZSwgcGFyYW1ldGVyTGlzdCwgdHJlZS50eXBlQW5ub3RhdGlvbiwgW10sIHRyZWUuYm9keSwgdHJlZS5kZWJ1Z05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTWV0aG9kXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgYXBwZW5kTWV0YWRhdGFfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLnN0YWNrXy5wb3AoKS5tZXRhZGF0YTtcbiAgICAgICAgaWYgKG1ldGFkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5zY29wZS5pc0V4cG9ydCkge1xuICAgICAgICAgICAgKCRfXzMgPSB0aGlzLnNjb3BlLm1ldGFkYXRhKS5wdXNoLmFwcGx5KCRfXzMsICR0cmFjZXVyUnVudGltZS5zcHJlYWQobWV0YWRhdGEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJlZSA9IG5ldyBBbm9uQmxvY2sobnVsbCwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChbdHJlZV0sIG1ldGFkYXRhKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzUmVmZXJlbmNlXzogZnVuY3Rpb24odHJlZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihjbGFzc05hbWUpO1xuICAgICAgICBpZiAoIXRyZWUuaXNTdGF0aWMpXG4gICAgICAgICAgcGFyZW50ID0gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQsICdwcm90b3R5cGUnKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Qcm9wZXJ0eU1ldGhvZF86IGZ1bmN0aW9uKHRyZWUsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbih0aGlzLnRyYW5zZm9ybUNsYXNzUmVmZXJlbmNlXyh0cmVlLCBjbGFzc05hbWUpLCB0cmVlLm5hbWUubGl0ZXJhbFRva2VuKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BY2Nlc3Nvcl86IGZ1bmN0aW9uKHRyZWUsIGNsYXNzTmFtZSwgYWNjZXNzb3IpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBjcmVhdGVBcmd1bWVudExpc3QoW3RoaXMudHJhbnNmb3JtQ2xhc3NSZWZlcmVuY2VfKHRyZWUsIGNsYXNzTmFtZSksIHRoaXMuY3JlYXRlTGl0ZXJhbFN0cmluZ0V4cHJlc3Npb25fKHRyZWUubmFtZSldKTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXCIsIFwiKVwiXSksIGFyZ3MpO1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbihkZXNjcmlwdG9yLCBhY2Nlc3Nvcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUGFyYW1ldGVyc186IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICB2YXIgaGFzUGFyYW1ldGVyTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgdmFyICRfXzM7XG4gICAgICAgICAgdmFyIG1ldGFkYXRhID0gW107XG4gICAgICAgICAgaWYgKHBhcmFtLnR5cGVBbm5vdGF0aW9uKVxuICAgICAgICAgICAgbWV0YWRhdGEucHVzaCgkX18yLnRyYW5zZm9ybUFueShwYXJhbS50eXBlQW5ub3RhdGlvbikpO1xuICAgICAgICAgIGlmIChwYXJhbS5hbm5vdGF0aW9ucyAmJiBwYXJhbS5hbm5vdGF0aW9ucy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgKCRfXzMgPSBtZXRhZGF0YSkucHVzaC5hcHBseSgkX18zLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKCRfXzIudHJhbnNmb3JtQW5ub3RhdGlvbnNfKHBhcmFtLmFubm90YXRpb25zKSkpO1xuICAgICAgICAgIGlmIChtZXRhZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBoYXNQYXJhbWV0ZXJNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlMaXRlcmFsKG1ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5TGl0ZXJhbChbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFzUGFyYW1ldGVyTWV0YWRhdGEgPyBwYXJhbWV0ZXJzIDogW107XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQW5ub3RhdGlvbnNfOiBmdW5jdGlvbihhbm5vdGF0aW9ucykge1xuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnMubWFwKGZ1bmN0aW9uKGFubm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3RXhwcmVzc2lvbihhbm5vdGF0aW9uLm5hbWUsIGFubm90YXRpb24uYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGFkYXRhXzogZnVuY3Rpb24odGFyZ2V0LCBhbm5vdGF0aW9ucywgcGFyYW1ldGVycykge1xuICAgICAgICB2YXIgbWV0YWRhdGFTdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGlmIChhbm5vdGF0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1Bbm5vdGF0aW9uc18oYW5ub3RhdGlvbnMpO1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZXRhZGF0YVN0YXRlbWVudHMucHVzaCh0aGlzLmNyZWF0ZURlZmluZVByb3BlcnR5U3RhdGVtZW50Xyh0YXJnZXQsICdhbm5vdGF0aW9ucycsIGNyZWF0ZUFycmF5TGl0ZXJhbChhbm5vdGF0aW9ucykpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzID0gdGhpcy50cmFuc2Zvcm1QYXJhbWV0ZXJzXyhwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBpZiAocGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZXRhZGF0YVN0YXRlbWVudHMucHVzaCh0aGlzLmNyZWF0ZURlZmluZVByb3BlcnR5U3RhdGVtZW50Xyh0YXJnZXQsICdwYXJhbWV0ZXJzJywgY3JlYXRlQXJyYXlMaXRlcmFsKHBhcmFtZXRlcnMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhZGF0YVN0YXRlbWVudHM7XG4gICAgICB9LFxuICAgICAgY3JlYXRlRGVmaW5lUHJvcGVydHlTdGF0ZW1lbnRfOiBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiwgXCIsIFwiLCBcIixcXG4gICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBcIiwgXCJ9fSk7XCJdKSwgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUxpdGVyYWxTdHJpbmdFeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0cmVlLmxpdGVyYWxUb2tlbjtcbiAgICAgICAgaWYgKHRyZWUubGl0ZXJhbFRva2VuLnR5cGUgIT09IFNUUklORylcbiAgICAgICAgICB0b2tlbiA9IGNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbih0cmVlLmxpdGVyYWxUb2tlbi52YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24obnVsbCwgdG9rZW4pO1xuICAgICAgfSxcbiAgICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tfW3RoaXMuc3RhY2tfLmxlbmd0aCAtIDFdO1xuICAgICAgfSxcbiAgICAgIHB1c2hBbm5vdGF0aW9uU2NvcGVfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gbmV3IEFubm90YXRpb25zU2NvcGUoKTtcbiAgICAgICAgdGhpcy5zdGFja18ucHVzaChzY29wZSk7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBBbm5vdGF0aW9uc1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRJbkZ1bmN0aW9uU2NvcGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GaW5kSW5GdW5jdGlvblNjb3BlLmpzXCI7XG4gIHZhciBGaW5kVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ZpbmRWaXNpdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GaW5kSW5GdW5jdGlvblNjb3BlLmpzXCIpKS5GaW5kVmlzaXRvcjtcbiAgdmFyIEZpbmRJbkZ1bmN0aW9uU2NvcGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZpbmRJbkZ1bmN0aW9uU2NvcGUoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5kSW5GdW5jdGlvblNjb3BlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRmluZEluRnVuY3Rpb25TY29wZSwge1xuICAgICAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0TGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRWaXNpdG9yKTtcbiAgcmV0dXJuIHtnZXQgRmluZEluRnVuY3Rpb25TY29wZSgpIHtcbiAgICAgIHJldHVybiBGaW5kSW5GdW5jdGlvblNjb3BlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy91dGlsLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL3V0aWwuanNcIjtcbiAgdmFyICRfXzAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy91dGlsLmpzXCIpKSxcbiAgICAgIElERU5USUZJRVJfRVhQUkVTU0lPTiA9ICRfXzAuSURFTlRJRklFUl9FWFBSRVNTSU9OLFxuICAgICAgTElURVJBTF9FWFBSRVNTSU9OID0gJF9fMC5MSVRFUkFMX0VYUFJFU1NJT04sXG4gICAgICBQQVJFTl9FWFBSRVNTSU9OID0gJF9fMC5QQVJFTl9FWFBSRVNTSU9OLFxuICAgICAgVU5BUllfRVhQUkVTU0lPTiA9ICRfXzAuVU5BUllfRVhQUkVTU0lPTjtcbiAgdmFyIFVOREVGSU5FRCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUHJlZGVmaW5lZE5hbWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy91dGlsLmpzXCIpKS5VTkRFRklORUQ7XG4gIHZhciBWT0lEID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy91dGlsLmpzXCIpKS5WT0lEO1xuICBmdW5jdGlvbiBoYXNVc2VTdHJpY3QobGlzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFsaXN0W2ldLmlzRGlyZWN0aXZlUHJvbG9ndWUoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGxpc3RbaV0uaXNVc2VTdHJpY3REaXJlY3RpdmUoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh0cmVlKSB7XG4gICAgaWYgKHRyZWUudHlwZSA9PT0gUEFSRU5fRVhQUkVTU0lPTilcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZCh0cmVlLmV4cHJlc3Npb24pO1xuICAgIHJldHVybiB0cmVlLnR5cGUgPT09IElERU5USUZJRVJfRVhQUkVTU0lPTiAmJiB0cmVlLmlkZW50aWZpZXJUb2tlbi52YWx1ZSA9PT0gVU5ERUZJTkVEO1xuICB9XG4gIGZ1bmN0aW9uIGlzVm9pZEV4cHJlc3Npb24odHJlZSkge1xuICAgIGlmICh0cmVlLnR5cGUgPT09IFBBUkVOX0VYUFJFU1NJT04pXG4gICAgICByZXR1cm4gaXNWb2lkRXhwcmVzc2lvbih0cmVlLmV4cHJlc3Npb24pO1xuICAgIHJldHVybiB0cmVlLnR5cGUgPT09IFVOQVJZX0VYUFJFU1NJT04gJiYgdHJlZS5vcGVyYXRvci50eXBlID09PSBWT0lEICYmIGlzTGl0ZXJhbEV4cHJlc3Npb24odHJlZS5vcGVyYW5kKTtcbiAgfVxuICBmdW5jdGlvbiBpc0xpdGVyYWxFeHByZXNzaW9uKHRyZWUpIHtcbiAgICBpZiAodHJlZS50eXBlID09PSBQQVJFTl9FWFBSRVNTSU9OKVxuICAgICAgcmV0dXJuIGlzTGl0ZXJhbEV4cHJlc3Npb24odHJlZS5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gdHJlZS50eXBlID09PSBMSVRFUkFMX0VYUFJFU1NJT047XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgaGFzVXNlU3RyaWN0KCkge1xuICAgICAgcmV0dXJuIGhhc1VzZVN0cmljdDtcbiAgICB9LFxuICAgIGdldCBpc1VuZGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldCBpc1ZvaWRFeHByZXNzaW9uKCkge1xuICAgICAgcmV0dXJuIGlzVm9pZEV4cHJlc3Npb247XG4gICAgfSxcbiAgICBnZXQgaXNMaXRlcmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHJldHVybiBpc0xpdGVyYWxFeHByZXNzaW9uO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvaXNUcmVlU3RyaWN0LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL2lzVHJlZVN0cmljdC5qc1wiO1xuICB2YXIgJF9fMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL2lzVHJlZVN0cmljdC5qc1wiKSksXG4gICAgICBBUlJPV19GVU5DVElPTiA9ICRfXzAuQVJST1dfRlVOQ1RJT04sXG4gICAgICBDTEFTU19ERUNMQVJBVElPTiA9ICRfXzAuQ0xBU1NfREVDTEFSQVRJT04sXG4gICAgICBDTEFTU19FWFBSRVNTSU9OID0gJF9fMC5DTEFTU19FWFBSRVNTSU9OLFxuICAgICAgRlVOQ1RJT05fQk9EWSA9ICRfXzAuRlVOQ1RJT05fQk9EWSxcbiAgICAgIEZVTkNUSU9OX0RFQ0xBUkFUSU9OID0gJF9fMC5GVU5DVElPTl9ERUNMQVJBVElPTixcbiAgICAgIEZVTkNUSU9OX0VYUFJFU1NJT04gPSAkX18wLkZVTkNUSU9OX0VYUFJFU1NJT04sXG4gICAgICBHRVRfQUNDRVNTT1IgPSAkX18wLkdFVF9BQ0NFU1NPUixcbiAgICAgIE1FVEhPRCA9ICRfXzAuTUVUSE9ELFxuICAgICAgTU9EVUxFID0gJF9fMC5NT0RVTEUsXG4gICAgICBTQ1JJUFQgPSAkX18wLlNDUklQVCxcbiAgICAgIFNFVF9BQ0NFU1NPUiA9ICRfXzAuU0VUX0FDQ0VTU09SO1xuICB2YXIgaGFzVXNlU3RyaWN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL2lzVHJlZVN0cmljdC5qc1wiKSkuaGFzVXNlU3RyaWN0O1xuICBmdW5jdGlvbiBpc1RyZWVTdHJpY3QodHJlZSkge1xuICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICBjYXNlIENMQVNTX0RFQ0xBUkFUSU9OOlxuICAgICAgY2FzZSBDTEFTU19FWFBSRVNTSU9OOlxuICAgICAgY2FzZSBNT0RVTEU6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBGVU5DVElPTl9CT0RZOlxuICAgICAgICByZXR1cm4gaGFzVXNlU3RyaWN0KHRyZWUuc3RhdGVtZW50cyk7XG4gICAgICBjYXNlIEZVTkNUSU9OX0VYUFJFU1NJT046XG4gICAgICBjYXNlIEZVTkNUSU9OX0RFQ0xBUkFUSU9OOlxuICAgICAgY2FzZSBNRVRIT0Q6XG4gICAgICAgIHJldHVybiBpc1RyZWVTdHJpY3QodHJlZS5ib2R5KTtcbiAgICAgIGNhc2UgQVJST1dfRlVOQ1RJT046XG4gICAgICAgIGlmICh0cmVlLmJvZHkudHlwZSA9PT0gRlVOQ1RJT05fQk9EWSkge1xuICAgICAgICAgIHJldHVybiBpc1RyZWVTdHJpY3QodHJlZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlIEdFVF9BQ0NFU1NPUjpcbiAgICAgIGNhc2UgU0VUX0FDQ0VTU09SOlxuICAgICAgICByZXR1cm4gaXNUcmVlU3RyaWN0KHRyZWUuYm9keSk7XG4gICAgICBjYXNlIFNDUklQVDpcbiAgICAgICAgcmV0dXJuIGhhc1VzZVN0cmljdCh0cmVlLnNjcmlwdEl0ZW1MaXN0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtnZXQgaXNUcmVlU3RyaWN0KCkge1xuICAgICAgcmV0dXJuIGlzVHJlZVN0cmljdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGUuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZS5qc1wiKSksXG4gICAgICBCTE9DSyA9ICRfXzIuQkxPQ0ssXG4gICAgICBDQVRDSCA9ICRfXzIuQ0FUQ0gsXG4gICAgICBGVU5DVElPTl9FWFBSRVNTSU9OID0gJF9fMi5GVU5DVElPTl9FWFBSRVNTSU9OO1xuICB2YXIgU3RyaW5nTWFwID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nTWFwLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGUuanNcIikpLlN0cmluZ01hcDtcbiAgdmFyIFZBUiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGUuanNcIikpLlZBUjtcbiAgdmFyIGlzVHJlZVN0cmljdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2lzVHJlZVN0cmljdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlLmpzXCIpKS5pc1RyZWVTdHJpY3Q7XG4gIGZ1bmN0aW9uIHJlcG9ydER1cGxpY2F0ZVZhcihyZXBvcnRlciwgdHJlZSwgbmFtZSkge1xuICAgIHJlcG9ydGVyLnJlcG9ydEVycm9yKHRyZWUubG9jYXRpb24sIChcIkR1cGxpY2F0ZSBkZWNsYXJhdGlvbiwgXCIgKyBuYW1lKSk7XG4gIH1cbiAgdmFyIFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2NvcGUocGFyZW50LCB0cmVlKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXyA9IG5ldyBTdHJpbmdNYXAoKTtcbiAgICAgIHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18gPSBuZXcgU3RyaW5nTWFwKCk7XG4gICAgICB0aGlzLnN0cmljdE1vZGUgPSBwYXJlbnQgJiYgcGFyZW50LnN0cmljdE1vZGUgfHwgaXNUcmVlU3RyaWN0KHRyZWUpO1xuICAgICAgdGhpcy5pbkdlbmVyYXRvciA9IHBhcmVudCA/IHBhcmVudC5pbkdlbmVyYXRvciB8fCBmYWxzZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2NvcGUsIHtcbiAgICAgIGFkZEJpbmRpbmc6IGZ1bmN0aW9uKHRyZWUsIHR5cGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBWQVIpIHtcbiAgICAgICAgICB0aGlzLmFkZFZhcih0cmVlLCByZXBvcnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGREZWNsYXJhdGlvbih0cmVlLCB0eXBlLCByZXBvcnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGRWYXI6IGZ1bmN0aW9uKHRyZWUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHZhciBuYW1lID0gdHJlZS5nZXRTdHJpbmdWYWx1ZSgpO1xuICAgICAgICBpZiAodGhpcy5sZXhpY2FsRGVjbGFyYXRpb25zXy5oYXMobmFtZSkgJiYgIXRoaXMuaXNGdW5jdGlvbkV4cHJlc3Npb25OYW1lKG5hbWUpKSB7XG4gICAgICAgICAgcmVwb3J0RHVwbGljYXRlVmFyKHJlcG9ydGVyLCB0cmVlLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18uc2V0KG5hbWUsIHtcbiAgICAgICAgICB0eXBlOiBWQVIsXG4gICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICBzY29wZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFyU2NvcGUgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5hZGRWYXIodHJlZSwgcmVwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUsIHR5cGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHZhciBuYW1lID0gdHJlZS5nZXRTdHJpbmdWYWx1ZSgpO1xuICAgICAgICBpZiAoKHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18uaGFzKG5hbWUpIHx8IHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLmhhcyhuYW1lKSkgJiYgIXRoaXMuaXNGdW5jdGlvbkV4cHJlc3Npb25OYW1lKG5hbWUpKSB7XG4gICAgICAgICAgcmVwb3J0RHVwbGljYXRlVmFyKHJlcG9ydGVyLCB0cmVlLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZXhpY2FsRGVjbGFyYXRpb25zXy5zZXQobmFtZSwge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICBzY29wZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZW5hbWVCaW5kaW5nOiBmdW5jdGlvbihvbGROYW1lLCBuZXdUcmVlLCBuZXdUeXBlLCByZXBvcnRlcikge1xuICAgICAgICB2YXIgbmFtZSA9IG5ld1RyZWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT09IFZBUikge1xuICAgICAgICAgIGlmICh0aGlzLmxleGljYWxEZWNsYXJhdGlvbnNfLmhhcyhvbGROYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5sZXhpY2FsRGVjbGFyYXRpb25zXy5kZWxldGUob2xkTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFkZFZhcihuZXdUcmVlLCByZXBvcnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLmhhcyhvbGROYW1lKSkge1xuICAgICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLmRlbGV0ZShvbGROYW1lKTtcbiAgICAgICAgICB0aGlzLmFkZERlY2xhcmF0aW9uKG5ld1RyZWUsIG5ld1R5cGUsIHJlcG9ydGVyKTtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNWYXJTY29wZSAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVuYW1lQmluZGluZyhvbGROYW1lLCBuZXdUcmVlLCBuZXdUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQgaXNWYXJTY29wZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRyZWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgQkxPQ0s6XG4gICAgICAgICAgY2FzZSBDQVRDSDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBnZXRWYXJTY29wZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFyU2NvcGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0VmFyU2NvcGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBpc0Z1bmN0aW9uRXhwcmVzc2lvbk5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmdldEJpbmRpbmdCeU5hbWUobmFtZSk7XG4gICAgICAgIHJldHVybiBiICYmIGIuc2NvcGUudHJlZS50eXBlID09PSBGVU5DVElPTl9FWFBSRVNTSU9OICYmIGIuc2NvcGUudHJlZS5uYW1lID09PSBiLnRyZWU7XG4gICAgICB9LFxuICAgICAgZ2V0QmluZGluZzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRyZWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0J5TmFtZShuYW1lKTtcbiAgICAgIH0sXG4gICAgICBnZXRCaW5kaW5nQnlOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18uZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoYiAmJiB0aGlzLmlzVmFyU2NvcGUpIHtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICBiID0gdGhpcy5sZXhpY2FsRGVjbGFyYXRpb25zXy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEJpbmRpbmdCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0QWxsQmluZGluZ05hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18ua2V5c0FzU2V0KCk7XG4gICAgICAgIHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgIH0sXG4gICAgICBnZXRWYXJpYWJsZUJpbmRpbmdOYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXy5rZXlzQXNTZXQoKTtcbiAgICAgIH0sXG4gICAgICBnZXRMZXhpY2FsQmluZGluZ05hbWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18ua2V5c0FzU2V0KCk7XG4gICAgICB9LFxuICAgICAgaGFzQmluZGluZ05hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18uaGFzKG5hbWUpIHx8IHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLmhhcyhuYW1lKTtcbiAgICAgIH0sXG4gICAgICBoYXNMZXhpY2FsQmluZGluZ05hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV4aWNhbERlY2xhcmF0aW9uc18uaGFzKG5hbWUpO1xuICAgICAgfSxcbiAgICAgIGhhc1ZhcmlhYmxlQmluZGluZ05hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLmhhcyhuYW1lKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgU2NvcGUoKSB7XG4gICAgICByZXR1cm4gU2NvcGU7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlVmlzaXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZVZpc2l0b3IuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1BhcnNlVHJlZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZVZpc2l0b3IuanNcIikpLlBhcnNlVHJlZVZpc2l0b3I7XG4gIHZhciBWQVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlVmlzaXRvci5qc1wiKSkuVkFSO1xuICB2YXIgU2NvcGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TY29wZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlVmlzaXRvci5qc1wiKSkuU2NvcGU7XG4gIHZhciAkX182ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGVWaXNpdG9yLmpzXCIpKSxcbiAgICAgIENPTVBSRUhFTlNJT05fRk9SID0gJF9fNi5DT01QUkVIRU5TSU9OX0ZPUixcbiAgICAgIFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgPSAkX182LlZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1Q7XG4gIHZhciBTY29wZVZpc2l0b3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNjb3BlVmlzaXRvcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFNjb3BlVmlzaXRvcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMubWFwXyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgdGhpcy53aXRoQmxvY2tDb3VudGVyXyA9IDA7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTY29wZVZpc2l0b3IsIHtcbiAgICAgIGdldFNjb3BlRm9yVHJlZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBfLmdldCh0cmVlKTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVTY29wZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMuc2NvcGUsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHB1c2hTY29wZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmNyZWF0ZVNjb3BlKHRyZWUpO1xuICAgICAgICB0aGlzLm1hcF8uc2V0KHRyZWUsIHNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgIH0sXG4gICAgICBwb3BTY29wZTogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT09IHNjb3BlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY29wZVZpc2l0b3Igc2NvcGUgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgfSxcbiAgICAgIHZpc2l0U2NyaXB0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVWaXNpdG9yLnByb3RvdHlwZSwgXCJ2aXNpdFNjcmlwdFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1vZHVsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSh0cmVlKTtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVmlzaXRvci5wcm90b3R5cGUsIFwidmlzaXRNb2R1bGVcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdGhpcy5wb3BTY29wZShzY29wZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSh0cmVlKTtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVmlzaXRvci5wcm90b3R5cGUsIFwidmlzaXRCbG9ja1wiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENhdGNoOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuY2F0Y2hCb2R5LnN0YXRlbWVudHMpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uQm9keUZvclNjb3BlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IHRyZWUucGFyYW1ldGVyTGlzdDtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkocGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHNjb3BlLmluR2VuZXJhdG9yID0gdHJlZS5mdW5jdGlvbktpbmQgJiYgdHJlZS5pc0dlbmVyYXRvcigpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICAgIHRoaXMucG9wU2NvcGUoc2NvcGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkJvZHlGb3JTY29wZSh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb25Cb2R5Rm9yU2NvcGUodHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJvd0Z1bmN0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkJvZHlGb3JTY29wZSh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkJvZHlGb3JTY29wZSh0cmVlLCBudWxsKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkJvZHlGb3JTY29wZSh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb25Cb2R5Rm9yU2NvcGUodHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIHRoaXMucG9wU2NvcGUoc2NvcGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICBpZiAodHJlZS5uYW1lKSB7XG4gICAgICAgICAgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSh0cmVlKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIGlmICh0cmVlLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0V2l0aFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud2l0aEJsb2NrQ291bnRlcl8rKztcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJvZHkpO1xuICAgICAgICB0aGlzLndpdGhCbG9ja0NvdW50ZXJfLS07XG4gICAgICB9LFxuICAgICAgZ2V0IGluV2l0aEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoQmxvY2tDb3VudGVyXyA+IDA7XG4gICAgICB9LFxuICAgICAgdmlzaXRMb29wXzogZnVuY3Rpb24odHJlZSwgZnVuYykge1xuICAgICAgICBpZiAodHJlZS5pbml0aWFsaXplci50eXBlICE9PSBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUIHx8IHRyZWUuaW5pdGlhbGl6ZXIuZGVjbGFyYXRpb25UeXBlID09PSBWQVIpIHtcbiAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRoaXMucG9wU2NvcGUoc2NvcGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzEgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpc2l0TG9vcF8odHJlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18xLCBTY29wZVZpc2l0b3IucHJvdG90eXBlLCBcInZpc2l0Rm9ySW5TdGF0ZW1lbnRcIikuY2FsbCgkX18xLCB0cmVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JPZlN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMSA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlzaXRMb29wXyh0cmVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KCRfXzEsIFNjb3BlVmlzaXRvci5wcm90b3R5cGUsIFwidmlzaXRGb3JPZlN0YXRlbWVudFwiKS5jYWxsKCRfXzEsIHRyZWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMSA9IHRoaXM7XG4gICAgICAgIGlmICghdHJlZS5pbml0aWFsaXplcikge1xuICAgICAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTY29wZVZpc2l0b3IucHJvdG90eXBlLCBcInZpc2l0Rm9yU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdExvb3BfKHRyZWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18xLCBTY29wZVZpc2l0b3IucHJvdG90eXBlLCBcInZpc2l0Rm9yU3RhdGVtZW50XCIpLmNhbGwoJF9fMSwgdHJlZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdENvbXByZWhlbnNpb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmNvbXByZWhlbnNpb25MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNjb3BlID0gbnVsbDtcbiAgICAgICAgICBpZiAodHJlZS5jb21wcmVoZW5zaW9uTGlzdFtpXS50eXBlID09PSBDT01QUkVIRU5TSU9OX0ZPUikge1xuICAgICAgICAgICAgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSh0cmVlLmNvbXByZWhlbnNpb25MaXN0W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb21wcmVoZW5zaW9uTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBmb3IgKHZhciBpJF9fMiA9IHNjb3Blcy5sZW5ndGggLSAxOyBpJF9fMiA+PSAwOyBpJF9fMi0tKSB7XG4gICAgICAgICAgaWYgKHNjb3Blc1tpJF9fMl0pIHtcbiAgICAgICAgICAgIHRoaXMucG9wU2NvcGUoc2NvcGVzW2kkX18yXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJheUNvbXByZWhlbnNpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdENvbXByZWhlbnNpb25fKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0R2VuZXJhdG9yQ29tcHJlaGVuc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q29tcHJlaGVuc2lvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQcmVkZWZpbmVkVHlwZTogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdFR5cGVBcmd1bWVudHM6IGZ1bmN0aW9uKHRyZWUpIHt9LFxuICAgICAgdmlzaXRGdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHRyZWUpIHt9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVWaXNpdG9yKTtcbiAgcmV0dXJuIHtnZXQgU2NvcGVWaXNpdG9yKCkge1xuICAgICAgcmV0dXJuIFNjb3BlVmlzaXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGVDaGFpbkJ1aWxkZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGVDaGFpbkJ1aWxkZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlQ2hhaW5CdWlsZGVyLmpzXCIpKSxcbiAgICAgIENPTlNUID0gJF9fMS5DT05TVCxcbiAgICAgIExFVCA9ICRfXzEuTEVULFxuICAgICAgVkFSID0gJF9fMS5WQVI7XG4gIHZhciBTY29wZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TY29wZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZUNoYWluQnVpbGRlci5qc1wiKSkuU2NvcGVWaXNpdG9yO1xuICB2YXIgU2NvcGVDaGFpbkJ1aWxkZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNjb3BlQ2hhaW5CdWlsZGVyKHJlcG9ydGVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTY29wZUNoYWluQnVpbGRlcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucmVwb3J0ZXIgPSByZXBvcnRlcjtcbiAgICAgIHRoaXMuZGVjbGFyYXRpb25UeXBlXyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTY29wZUNoYWluQnVpbGRlciwge1xuICAgICAgdmlzaXRDYXRjaDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnB1c2hTY29wZSh0cmVlKTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvblR5cGVfID0gTEVUO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuY2F0Y2hCb2R5LnN0YXRlbWVudHMpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydGVkQmluZGluZzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBDT05TVDtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlQ2hhaW5CdWlsZGVyLnByb3RvdHlwZSwgXCJ2aXNpdEltcG9ydGVkQmluZGluZ1wiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbkxpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvblR5cGVfID0gdHJlZS5kZWNsYXJhdGlvblR5cGU7XG4gICAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTY29wZUNoYWluQnVpbGRlci5wcm90b3R5cGUsIFwidmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uTGlzdFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QmluZGluZ0lkZW50aWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlVmFyaWFibGUodHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgIGlmICh0cmVlLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBDT05TVDtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICBzY29wZS5pbkdlbmVyYXRvciA9IHRyZWUuaXNHZW5lcmF0b3IoKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJvZHkpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvcm1hbFBhcmFtZXRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBWQVI7XG4gICAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTY29wZUNoYWluQnVpbGRlci5wcm90b3R5cGUsIFwidmlzaXRGb3JtYWxQYXJhbWV0ZXJcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zY29wZS5pc1ZhclNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBWQVI7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY29wZS5zdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIHZhciB2YXJTY29wZSA9IHRoaXMuc2NvcGUuZ2V0VmFyU2NvcGUoKTtcbiAgICAgICAgICAgICAgaWYgKHZhclNjb3BlKSB7XG4gICAgICAgICAgICAgICAgdmFyU2NvcGUuYWRkVmFyKHRyZWUubmFtZSwgdGhpcy5yZXBvcnRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25UeXBlXyA9IExFVDtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uQm9keUZvclNjb3BlKHRyZWUsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uVHlwZV8gPSBMRVQ7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25UeXBlXyA9IENPTlNUO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZWxlbWVudHMpO1xuICAgICAgICB0aGlzLnBvcFNjb3BlKHNjb3BlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBzY29wZTtcbiAgICAgICAgaWYgKHRyZWUubmFtZSkge1xuICAgICAgICAgIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblR5cGVfID0gQ09OU1Q7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZWxlbWVudHMpO1xuICAgICAgICBpZiAodHJlZS5uYW1lKSB7XG4gICAgICAgICAgdGhpcy5wb3BTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdENvbXByZWhlbnNpb25Gb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvblR5cGVfID0gTEVUO1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVDaGFpbkJ1aWxkZXIucHJvdG90eXBlLCBcInZpc2l0Q29tcHJlaGVuc2lvbkZvclwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIGRlY2xhcmVWYXJpYWJsZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnNjb3BlLmFkZEJpbmRpbmcodHJlZSwgdGhpcy5kZWNsYXJhdGlvblR5cGVfLCB0aGlzLnJlcG9ydGVyKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFNjb3BlVmlzaXRvcik7XG4gIHJldHVybiB7Z2V0IFNjb3BlQ2hhaW5CdWlsZGVyKCkge1xuICAgICAgcmV0dXJuIFNjb3BlQ2hhaW5CdWlsZGVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9WYXJpYWJsZUJpbmRlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9WYXJpYWJsZUJpbmRlci5qc1wiO1xuICB2YXIgU2NvcGVDaGFpbkJ1aWxkZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TY29wZUNoYWluQnVpbGRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1ZhcmlhYmxlQmluZGVyLmpzXCIpKS5TY29wZUNoYWluQnVpbGRlcjtcbiAgZnVuY3Rpb24gdmFyaWFibGVzSW5CbG9jayh0cmVlKSB7XG4gICAgdmFyIGluY2x1ZGVGdW5jdGlvblNjb3BlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBidWlsZGVyID0gbmV3IFNjb3BlQ2hhaW5CdWlsZGVyKG51bGwpO1xuICAgIGJ1aWxkZXIudmlzaXRBbnkodHJlZSk7XG4gICAgdmFyIHNjb3BlID0gYnVpbGRlci5nZXRTY29wZUZvclRyZWUodHJlZSk7XG4gICAgdmFyIG5hbWVzID0gc2NvcGUuZ2V0TGV4aWNhbEJpbmRpbmdOYW1lcygpO1xuICAgIGlmICghaW5jbHVkZUZ1bmN0aW9uU2NvcGUpIHtcbiAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG4gICAgdmFyIHZhcmlhYmxlQmluZGluZ05hbWVzID0gc2NvcGUuZ2V0VmFyaWFibGVCaW5kaW5nTmFtZXMoKTtcbiAgICB2YXJpYWJsZUJpbmRpbmdOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lcy5hZGQobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5hbWVzO1xuICB9XG4gIGZ1bmN0aW9uIHZhcmlhYmxlc0luRnVuY3Rpb24odHJlZSkge1xuICAgIHZhciBidWlsZGVyID0gbmV3IFNjb3BlQ2hhaW5CdWlsZGVyKG51bGwpO1xuICAgIGJ1aWxkZXIudmlzaXRBbnkodHJlZSk7XG4gICAgdmFyIHNjb3BlID0gYnVpbGRlci5nZXRTY29wZUZvclRyZWUodHJlZSk7XG4gICAgcmV0dXJuIHNjb3BlLmdldEFsbEJpbmRpbmdOYW1lcygpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0IHZhcmlhYmxlc0luQmxvY2soKSB7XG4gICAgICByZXR1cm4gdmFyaWFibGVzSW5CbG9jaztcbiAgICB9LFxuICAgIGdldCB2YXJpYWJsZXNJbkZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhcmlhYmxlc0luRnVuY3Rpb247XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Njb3BlVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TY29wZVRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2NvcGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBUkdVTUVOVFMgPSAkX180LkFSR1VNRU5UUyxcbiAgICAgIFRISVMgPSAkX180LlRISVM7XG4gIHZhciBGaW5kSW5GdW5jdGlvblNjb3BlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmluZEluRnVuY3Rpb25TY29wZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2NvcGVUcmFuc2Zvcm1lci5qc1wiKSkuRmluZEluRnVuY3Rpb25TY29wZTtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Njb3BlVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2NvcGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uID0gJF9fNy5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNy5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBHZXRBY2Nlc3NvciA9ICRfXzcuR2V0QWNjZXNzb3IsXG4gICAgICBNZXRob2QgPSAkX183Lk1ldGhvZCxcbiAgICAgIFNldEFjY2Vzc29yID0gJF9fNy5TZXRBY2Nlc3NvcjtcbiAgdmFyIFN0cmluZ1NldCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi91dGlsL1N0cmluZ1NldC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2NvcGVUcmFuc2Zvcm1lci5qc1wiKSkuU3RyaW5nU2V0O1xuICB2YXIgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU2NvcGVUcmFuc2Zvcm1lci5qc1wiKSkuVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVDtcbiAgdmFyIFZBUiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TY29wZVRyYW5zZm9ybWVyLmpzXCIpKS5WQVI7XG4gIHZhciAkX18xMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zZW1hbnRpY3MvVmFyaWFibGVCaW5kZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Njb3BlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgdmFyaWFibGVzSW5CbG9jayA9ICRfXzExLnZhcmlhYmxlc0luQmxvY2ssXG4gICAgICB2YXJpYWJsZXNJbkZ1bmN0aW9uID0gJF9fMTEudmFyaWFibGVzSW5GdW5jdGlvbjtcbiAgdmFyIEZpbmROYW1lcyA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRmluZE5hbWVzKG5hbWVzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5kTmFtZXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGaW5kTmFtZXMsIHt2aXNpdEJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMubmFtZXMuYWRkKHRyZWUuZ2V0U3RyaW5nVmFsdWUoKSk7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShGaW5kSW5GdW5jdGlvblNjb3BlKTtcbiAgZnVuY3Rpb24gZ2V0TGV4aWNhbEJpbmRpbmdOYW1lcyh0cmVlKSB7XG4gICAgdmFyIG5hbWVzID0gbmV3IFN0cmluZ1NldCgpO1xuICAgIGlmICh0cmVlICE9PSBudWxsICYmIHRyZWUudHlwZSA9PT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCAmJiB0cmVlLmRlY2xhcmF0aW9uVHlwZSAhPT0gVkFSKSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBGaW5kTmFtZXMobmFtZXMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aXNpdG9yLnZpc2l0QW55KHRyZWUuZGVjbGFyYXRpb25zW2ldLmx2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfVxuICB2YXIgU2NvcGVUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gU2NvcGVUcmFuc2Zvcm1lcih2YXJOYW1lKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTY29wZVRyYW5zZm9ybWVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy52YXJOYW1lXyA9IHZhck5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTY29wZVRyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1CbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodmFyaWFibGVzSW5CbG9jayh0cmVlKS5oYXModGhpcy52YXJOYW1lXykpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJsb2NrXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgc2FtZVRyZWVJZk5hbWVJbkxvb3BJbml0aWFsaXplcl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gZ2V0TGV4aWNhbEJpbmRpbmdOYW1lcyh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgaWYgKG5hbWVzLmhhcyh0aGlzLnZhck5hbWVfKSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lVHJlZUlmTmFtZUluTG9vcEluaXRpYWxpemVyXyh0cmVlKSB8fCAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9yU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZVRyZWVJZk5hbWVJbkxvb3BJbml0aWFsaXplcl8odHJlZSkgfHwgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZvckluU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZVRyZWVJZk5hbWVJbkxvb3BJbml0aWFsaXplcl8odHJlZSkgfHwgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZvck9mU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZVRyZWVJZk5hbWVJbkxvb3BJbml0aWFsaXplcl8odHJlZSkgfHwgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNjb3BlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZvck9uU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVGhpc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyTmFtZV8gIT09IFRISVMpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtVGhpc0V4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1QYXJhbWV0ZXJMaXN0QW5kQm9keV86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0RG9Ob3RSZWN1cnNlKHRyZWUpKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhcmFtZXRlckxpc3Q6IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCksXG4gICAgICAgICAgYm9keTogdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXMudHJhbnNmb3JtUGFyYW1ldGVyTGlzdEFuZEJvZHlfKHRyZWUpLFxuICAgICAgICAgICAgcGFyYW1ldGVyTGlzdCA9ICRfXzMucGFyYW1ldGVyTGlzdCxcbiAgICAgICAgICAgIGJvZHkgPSAkX18zLmJvZHk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIHR5cGVBbm5vdGF0aW9uID09PSB0cmVlLnR5cGVBbm5vdGF0aW9uICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBuYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgcGFyYW1ldGVyTGlzdCwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXMudHJhbnNmb3JtUGFyYW1ldGVyTGlzdEFuZEJvZHlfKHRyZWUpLFxuICAgICAgICAgICAgcGFyYW1ldGVyTGlzdCA9ICRfXzMucGFyYW1ldGVyTGlzdCxcbiAgICAgICAgICAgIGJvZHkgPSAkX18zLmJvZHk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIHR5cGVBbm5vdGF0aW9uID09PSB0cmVlLnR5cGVBbm5vdGF0aW9uICYmIGFubm90YXRpb25zID09PSB0cmVlLmFubm90YXRpb25zICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG5hbWUsIHRyZWUuZnVuY3Rpb25LaW5kLCBwYXJhbWV0ZXJMaXN0LCB0eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciB0eXBlQW5ub3RhdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgIHZhciAkX18zID0gdGhpcy50cmFuc2Zvcm1QYXJhbWV0ZXJMaXN0QW5kQm9keV8odHJlZSksXG4gICAgICAgICAgICBwYXJhbWV0ZXJMaXN0ID0gJF9fMy5wYXJhbWV0ZXJMaXN0LFxuICAgICAgICAgICAgYm9keSA9ICRfXzMuYm9keTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHRyZWUubmFtZSAmJiB0eXBlQW5ub3RhdGlvbiA9PT0gdHJlZS50eXBlQW5ub3RhdGlvbiAmJiBhbm5vdGF0aW9ucyA9PT0gdHJlZS5hbm5vdGF0aW9ucyAmJiBwYXJhbWV0ZXJMaXN0ID09PSB0cmVlLnBhcmFtZXRlckxpc3QgJiYgYm9keSA9PT0gdHJlZS5ib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5mdW5jdGlvbktpbmQsIG5hbWUsIHBhcmFtZXRlckxpc3QsIHR5cGVBbm5vdGF0aW9uLCBhbm5vdGF0aW9ucywgYm9keSwgdHJlZS5kZWJ1Z05hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmdldERvTm90UmVjdXJzZSh0cmVlKSA/IHRyZWUuYm9keSA6IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgdHlwZUFubm90YXRpb24gPT09IHRyZWUudHlwZUFubm90YXRpb24gJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMgJiYgYm9keSA9PT0gdHJlZS5ib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBuYW1lLCB0eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXMudHJhbnNmb3JtUGFyYW1ldGVyTGlzdEFuZEJvZHlfKHRyZWUpLFxuICAgICAgICAgICAgcGFyYW1ldGVyTGlzdCA9ICRfXzMucGFyYW1ldGVyTGlzdCxcbiAgICAgICAgICAgIGJvZHkgPSAkX18zLmJvZHk7XG4gICAgICAgIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgYW5ub3RhdGlvbnMgPT09IHRyZWUuYW5ub3RhdGlvbnMgJiYgcGFyYW1ldGVyTGlzdCA9PT0gdHJlZS5wYXJhbWV0ZXJMaXN0ICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2V0QWNjZXNzb3IodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgbmFtZSwgcGFyYW1ldGVyTGlzdCwgYW5ub3RhdGlvbnMsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIGdldERvTm90UmVjdXJzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJOYW1lXyA9PT0gQVJHVU1FTlRTIHx8IHRoaXMudmFyTmFtZV8gPT09IFRISVMgfHwgdmFyaWFibGVzSW5GdW5jdGlvbih0cmVlKS5oYXModGhpcy52YXJOYW1lXyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2F0Y2g6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0cmVlLmJpbmRpbmcuaXNQYXR0ZXJuKCkgJiYgdGhpcy52YXJOYW1lXyA9PT0gdHJlZS5iaW5kaW5nLmlkZW50aWZpZXJUb2tlbi52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQ2F0Y2hcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgU2NvcGVUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBTY29wZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FscGhhUmVuYW1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FscGhhUmVuYW1lci5qc1wiO1xuICB2YXIgU2NvcGVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Njb3BlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FscGhhUmVuYW1lci5qc1wiKSkuU2NvcGVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FscGhhUmVuYW1lci5qc1wiKSksXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uID0gJF9fMi5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fMi5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBUSElTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQWxwaGFSZW5hbWVyLmpzXCIpKS5USElTO1xuICB2YXIgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BbHBoYVJlbmFtZXIuanNcIikpLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uO1xuICB2YXIgQWxwaGFSZW5hbWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBbHBoYVJlbmFtZXIodmFyTmFtZSwgbmV3TmFtZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQWxwaGFSZW5hbWVyKS5jYWxsKHRoaXMsIHZhck5hbWUpO1xuICAgICAgdGhpcy5uZXdOYW1lXyA9IG5ld05hbWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBbHBoYVJlbmFtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhck5hbWVfID09PSB0cmVlLmlkZW50aWZpZXJUb2tlbi52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLm5ld05hbWVfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhck5hbWVfICE9PSBUSElTKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGhpcy5uZXdOYW1lXyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy52YXJOYW1lXyA9PT0gdHJlZS5uYW1lKSB7XG4gICAgICAgICAgdHJlZSA9IG5ldyBGdW5jdGlvbkRlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHRoaXMubmV3TmFtZV8sIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIHRyZWUudHlwZUFubm90YXRpb24sIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbHBoYVJlbmFtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyTmFtZV8gPT09IHRyZWUubmFtZSkge1xuICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRoaXMubmV3TmFtZV8sIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIHRyZWUudHlwZUFubm90YXRpb24sIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBbHBoYVJlbmFtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHtyZW5hbWU6IGZ1bmN0aW9uKHRyZWUsIHZhck5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbHBoYVJlbmFtZXIodmFyTmFtZSwgbmV3TmFtZSkudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgfX0sICRfX3N1cGVyKTtcbiAgfShTY29wZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgQWxwaGFSZW5hbWVyKCkge1xuICAgICAgcmV0dXJuIEFscGhhUmVuYW1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GaW5kVGhpc09yQXJndW1lbnRzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZFRoaXNPckFyZ3VtZW50cy5qc1wiO1xuICB2YXIgQVJHVU1FTlRTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZFRoaXNPckFyZ3VtZW50cy5qc1wiKSkuQVJHVU1FTlRTO1xuICB2YXIgRmluZEluRnVuY3Rpb25TY29wZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ZpbmRJbkZ1bmN0aW9uU2NvcGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRUaGlzT3JBcmd1bWVudHMuanNcIikpLkZpbmRJbkZ1bmN0aW9uU2NvcGU7XG4gIHZhciBGaW5kVGhpc09yQXJndW1lbnRzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGaW5kVGhpc09yQXJndW1lbnRzKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRmluZFRoaXNPckFyZ3VtZW50cykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZm91bmRUaGlzID0gZmFsc2U7XG4gICAgICB0aGlzLmZvdW5kQXJndW1lbnRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGaW5kVGhpc09yQXJndW1lbnRzLCB7XG4gICAgICB2aXNpdFRoaXNFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmRUaGlzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb3VuZCA9IHRoaXMuZm91bmRBcmd1bWVudHM7XG4gICAgICB9LFxuICAgICAgdmlzaXRJZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5pZGVudGlmaWVyVG9rZW4udmFsdWUgPT09IEFSR1VNRU5UUykge1xuICAgICAgICAgIHRoaXMuZm91bmRBcmd1bWVudHMgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZm91bmQgPSB0aGlzLmZvdW5kVGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oRmluZEluRnVuY3Rpb25TY29wZSk7XG4gIHJldHVybiB7Z2V0IEZpbmRUaGlzT3JBcmd1bWVudHMoKSB7XG4gICAgICByZXR1cm4gRmluZFRoaXNPckFyZ3VtZW50cztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIjtcbiAgdmFyICRfXzAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIikpLFxuICAgICAgQVJHVU1FTlRTID0gJF9fMC5BUkdVTUVOVFMsXG4gICAgICBUSElTID0gJF9fMC5USElTO1xuICB2YXIgQWxwaGFSZW5hbWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQWxwaGFSZW5hbWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIikpLkFscGhhUmVuYW1lcjtcbiAgdmFyIEZpbmRUaGlzT3JBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kVGhpc09yQXJndW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIikpLkZpbmRUaGlzT3JBcmd1bWVudHM7XG4gIGZ1bmN0aW9uIGFscGhhUmVuYW1lVGhpc0FuZEFyZ3VtZW50cyh0ZW1wVmFyVHJhbnNmb3JtZXIsIHRyZWUpIHtcbiAgICB2YXIgZmluZGVyID0gbmV3IEZpbmRUaGlzT3JBcmd1bWVudHMoKTtcbiAgICBmaW5kZXIudmlzaXRBbnkodHJlZSk7XG4gICAgaWYgKGZpbmRlci5mb3VuZEFyZ3VtZW50cykge1xuICAgICAgdmFyIGFyZ3VtZW50c1RlbXBOYW1lID0gdGVtcFZhclRyYW5zZm9ybWVyLmFkZFRlbXBWYXJGb3JBcmd1bWVudHMoKTtcbiAgICAgIHRyZWUgPSBBbHBoYVJlbmFtZXIucmVuYW1lKHRyZWUsIEFSR1VNRU5UUywgYXJndW1lbnRzVGVtcE5hbWUpO1xuICAgIH1cbiAgICBpZiAoZmluZGVyLmZvdW5kVGhpcykge1xuICAgICAgdmFyIHRoaXNUZW1wTmFtZSA9IHRlbXBWYXJUcmFuc2Zvcm1lci5hZGRUZW1wVmFyRm9yVGhpcygpO1xuICAgICAgdHJlZSA9IEFscGhhUmVuYW1lci5yZW5hbWUodHJlZSwgVEhJUywgdGhpc1RlbXBOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG4gIH1cbiAgcmV0dXJuIHtnZXQgZGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBhbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHM7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBhbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIpKS5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgJF9fNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Db21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgTEVUID0gJF9fNC5MRVQsXG4gICAgICBTVEFSID0gJF9fNC5TVEFSLFxuICAgICAgVkFSID0gJF9fNC5WQVI7XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Db21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQ09NUFJFSEVOU0lPTl9GT1IgPSAkX181LkNPTVBSRUhFTlNJT05fRk9SLFxuICAgICAgQ09NUFJFSEVOU0lPTl9JRiA9ICRfXzUuQ09NUFJFSEVOU0lPTl9JRjtcbiAgdmFyIFRva2VuID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIpKS5Ub2tlbjtcbiAgdmFyICRfXzcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Db21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24gPSAkX183LmNyZWF0ZUNhbGxFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlRW1wdHlQYXJhbWV0ZXJMaXN0ID0gJF9fNy5jcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QsXG4gICAgICBjcmVhdGVGb3JPZlN0YXRlbWVudCA9ICRfXzcuY3JlYXRlRm9yT2ZTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX183LmNyZWF0ZUZ1bmN0aW9uQm9keSxcbiAgICAgIGNyZWF0ZUlmU3RhdGVtZW50ID0gJF9fNy5jcmVhdGVJZlN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlUGFyZW5FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX183LmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0O1xuICB2YXIgQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIsIHt0cmFuc2Zvcm1Db21wcmVoZW5zaW9uOiBmdW5jdGlvbih0cmVlLCBzdGF0ZW1lbnQsIGlzR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHNbM107XG4gICAgICAgIHZhciBzdWZmaXggPSBhcmd1bWVudHNbNF07XG4gICAgICAgIHZhciBiaW5kaW5nS2luZCA9IGlzR2VuZXJhdG9yIHx8ICF0aGlzLm9wdGlvbnMuYmxvY2tCaW5kaW5nID8gVkFSIDogTEVUO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHByZWZpeCA/IFtwcmVmaXhdIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0cmVlLmNvbXByZWhlbnNpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSB0cmVlLmNvbXByZWhlbnNpb25MaXN0W2ldO1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIENPTVBSRUhFTlNJT05fSUY6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KGl0ZW0uZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gY3JlYXRlSWZTdGF0ZW1lbnQoZXhwcmVzc2lvbiwgc3RhdGVtZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDT01QUkVIRU5TSU9OX0ZPUjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkoaXRlbS5sZWZ0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLnRyYW5zZm9ybUFueShpdGVtLml0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChiaW5kaW5nS2luZCwgbGVmdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gY3JlYXRlRm9yT2ZTdGF0ZW1lbnQoaW5pdGlhbGl6ZXIsIGl0ZXJhdG9yLCBzdGF0ZW1lbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnQgPSBhbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHModGhpcywgc3RhdGVtZW50KTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIGlmIChzdWZmaXgpXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHN1ZmZpeCk7XG4gICAgICAgIHZhciBmdW5jdGlvbktpbmQgPSBpc0dlbmVyYXRvciA/IG5ldyBUb2tlbihTVEFSLCBudWxsKSA6IG51bGw7XG4gICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBudWxsLCBmdW5jdGlvbktpbmQsIGNyZWF0ZUVtcHR5UGFyYW1ldGVyTGlzdCgpLCBudWxsLCBbXSwgY3JlYXRlRnVuY3Rpb25Cb2R5KHN0YXRlbWVudHMpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihjcmVhdGVDYWxsRXhwcmVzc2lvbihmdW5jKSk7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShUZW1wVmFyVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FycmF5Q29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIENvbXByZWhlbnNpb25UcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0NvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLkNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uO1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLnBhcnNlU3RhdGVtZW50O1xuICB2YXIgQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFycmF5Q29tcHJlaGVuc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBcnJheUNvbXByZWhlbnNpb25UcmFuc2Zvcm1lciwge3RyYW5zZm9ybUFycmF5Q29tcHJlaGVuc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnB1c2hUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgaW5kZXggPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmdldFRlbXBJZGVudGlmaWVyKCkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgdmFyIHRlbXBWYXJzU3RhdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1widmFyIFwiLCBcIiA9IDAsIFwiLCBcIiA9IFtdO1wiXSksIGluZGV4LCByZXN1bHQpO1xuICAgICAgICB2YXIgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIltcIiwgXCIrK10gPSBcIiwgXCI7XCJdKSwgcmVzdWx0LCBpbmRleCwgZXhwcmVzc2lvbik7XG4gICAgICAgIHZhciByZXR1cm5TdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wicmV0dXJuIFwiLCBcIjtcIl0pLCByZXN1bHQpO1xuICAgICAgICB2YXIgZnVuY3Rpb25LaW5kID0gbnVsbDtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc2Zvcm1Db21wcmVoZW5zaW9uKHRyZWUsIHN0YXRlbWVudCwgZnVuY3Rpb25LaW5kLCB0ZW1wVmFyc1N0YXRhdGVtZW50LCByZXR1cm5TdGF0ZW1lbnQpO1xuICAgICAgICB0aGlzLnBvcFRlbXBTY29wZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gQXJyYXlDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyZW5UcmFpdC5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcmVuVHJhaXQuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcmVuVHJhaXQuanNcIikpLFxuICAgICAgQXJndW1lbnRMaXN0ID0gJF9fMi5Bcmd1bWVudExpc3QsXG4gICAgICBBcnJheUxpdGVyYWwgPSAkX18yLkFycmF5TGl0ZXJhbCxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb24gPSAkX18yLkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAkX18yLkNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX18yLkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBOZXdFeHByZXNzaW9uID0gJF9fMi5OZXdFeHByZXNzaW9uLFxuICAgICAgUGFyZW5FeHByZXNzaW9uID0gJF9fMi5QYXJlbkV4cHJlc3Npb24sXG4gICAgICBQcm9wZXJ0eU5hbWVBc3NpZ25tZW50ID0gJF9fMi5Qcm9wZXJ0eU5hbWVBc3NpZ25tZW50LFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbiA9ICRfXzIuVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1BhcmVuVHJhaXQuanNcIikpLFxuICAgICAgQ0FMTF9FWFBSRVNTSU9OID0gJF9fMy5DQUxMX0VYUFJFU1NJT04sXG4gICAgICBDT01NQV9FWFBSRVNTSU9OID0gJF9fMy5DT01NQV9FWFBSRVNTSU9OLFxuICAgICAgRlVOQ1RJT05fRVhQUkVTU0lPTiA9ICRfXzMuRlVOQ1RJT05fRVhQUkVTU0lPTixcbiAgICAgIE9CSkVDVF9MSVRFUkFMID0gJF9fMy5PQkpFQ1RfTElURVJBTCxcbiAgICAgIE9CSkVDVF9QQVRURVJOID0gJF9fMy5PQkpFQ1RfUEFUVEVSTixcbiAgICAgIFRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzMuVEVNUExBVEVfTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgWUlFTERfRVhQUkVTU0lPTiA9ICRfXzMuWUlFTERfRVhQUkVTU0lPTjtcbiAgZnVuY3Rpb24gd3JhcCh0cmVlKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJlbkV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZSk7XG4gIH1cbiAgZnVuY3Rpb24gUGFyZW5UcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lckNsYXNzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgICBmdW5jdGlvbiAkX18wKCkge1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcigkX18wKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKCRfXzAsIHtcbiAgICAgICAgdHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHZhciBsdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgICAgaWYgKGluaXRpYWxpemVyICE9PSBudWxsICYmIGluaXRpYWxpemVyLnR5cGUgPT09IENPTU1BX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVyID0gd3JhcChpbml0aWFsaXplcik7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmVlLmx2YWx1ZSA9PT0gbHZhbHVlICYmIHRyZWUudHlwZUFubm90YXRpb24gPT09IHR5cGVBbm5vdGF0aW9uICYmIHRyZWUuaW5pdGlhbGl6ZXIgPT09IGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZURlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIGx2YWx1ZSwgdHlwZUFubm90YXRpb24sIGluaXRpYWxpemVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBPQkpFQ1RfTElURVJBTDpcbiAgICAgICAgICAgIGNhc2UgT0JKRUNUX1BBVFRFUk46XG4gICAgICAgICAgICBjYXNlIEZVTkNUSU9OX0VYUFJFU1NJT046XG4gICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyZWUuZXhwcmVzc2lvbiA9PT0gZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYXJncyk7XG4gICAgICAgICAgc3dpdGNoIChvcGVyYW5kLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ0FMTF9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgY2FzZSBURU1QTEFURV9MSVRFUkFMX0VYUFJFU1NJT046XG4gICAgICAgICAgICAgIG9wZXJhbmQgPSB3cmFwKG9wZXJhbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlcmFuZCA9PT0gdHJlZS5vcGVyYW5kICYmIGFyZ3MgPT09IHRyZWUuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTmV3RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBvcGVyYW5kLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtRXhwcmVzc2lvbkxpc3RfOiBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KGxpc3QpO1xuICAgICAgICAgIHZhciBuZXdMaXN0ID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gbnVsbCAmJiBleHByZXNzaW9uLnR5cGUgPT09IENPTU1BX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHdyYXAoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmIChuZXdMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3TGlzdCA9IGV4cHJlc3Npb25zLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld0xpc3QucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3TGlzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdMaXN0LnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdMaXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3TGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1Bcmd1bWVudExpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudHJhbnNmb3JtRXhwcmVzc2lvbkxpc3RfKHRyZWUuYXJncyk7XG4gICAgICAgICAgaWYgKHRyZWUuYXJncyA9PT0gYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQXJndW1lbnRMaXN0KHRyZWUubG9jYXRpb24sIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1BcnJheUxpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUV4cHJlc3Npb25MaXN0Xyh0cmVlLmVsZW1lbnRzKTtcbiAgICAgICAgICBpZiAodHJlZS5lbGVtZW50cyA9PT0gZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEFycmF5TGl0ZXJhbCh0cmVlLmxvY2F0aW9uLCBlbGVtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZm9ybVByb3BlcnR5TmFtZUFzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IENPTU1BX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSB0cmVlLm5hbWUgJiYgdmFsdWUgPT09IHRyZWUudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5TmFtZUFzc2lnbm1lbnQodHJlZS5sb2NhdGlvbiwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1CaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmxlZnQpO1xuICAgICAgICAgIHZhciByaWdodCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICAgIGlmIChjb21tYU9yWWllbGQobGVmdC50eXBlKSkge1xuICAgICAgICAgICAgbGVmdCA9IHdyYXAobGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYU9yWWllbGQocmlnaHQudHlwZSkpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gd3JhcChyaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZWZ0ID09PSB0cmVlLmxlZnQgJiYgcmlnaHQgPT09IHRyZWUucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbGVmdCwgdHJlZS5vcGVyYXRvciwgcmlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1Db25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5jb25kaXRpb24pO1xuICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJpZ2h0KTtcbiAgICAgICAgICBpZiAoY29tbWFPcllpZWxkKGNvbmRpdGlvbi50eXBlKSkge1xuICAgICAgICAgICAgY29uZGl0aW9uID0gd3JhcChjb25kaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVmdC50eXBlID09IENPTU1BX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgIGxlZnQgPSB3cmFwKGxlZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmlnaHQudHlwZSA9PSBDT01NQV9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICByaWdodCA9IHdyYXAocmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29uZGl0aW9uID09PSB0cmVlLmNvbmRpdGlvbiAmJiBsZWZ0ID09PSB0cmVlLmxlZnQgJiYgcmlnaHQgPT09IHRyZWUucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBjb25kaXRpb24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSwge30sICRfX3N1cGVyKTtcbiAgICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyQ2xhc3MpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbW1hT3JZaWVsZCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IENPTU1BX0VYUFJFU1NJT04gfHwgdHlwZSA9PSBZSUVMRF9FWFBSRVNTSU9OO1xuICB9XG4gIHJldHVybiB7Z2V0IFBhcmVuVHJhaXQoKSB7XG4gICAgICByZXR1cm4gUGFyZW5UcmFpdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQVJHVU1FTlRTID0gJF9fMS5BUkdVTUVOVFMsXG4gICAgICBDT05TVFJVQ1RPUiA9ICRfXzEuQ09OU1RSVUNUT1IsXG4gICAgICBUSElTID0gJF9fMS5USElTO1xuICB2YXIgQWxwaGFSZW5hbWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQWxwaGFSZW5hbWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIuanNcIikpLkFscGhhUmVuYW1lcjtcbiAgdmFyIEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLmpzXCIpKS5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Fycm93RnVuY3Rpb25UcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgUGFyZW5UcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcmVuVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Fycm93RnVuY3Rpb25UcmFuc2Zvcm1lci5qc1wiKSkuUGFyZW5UcmFpdDtcbiAgdmFyIGFscGhhUmVuYW1lVGhpc0FuZEFyZ3VtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2FscGhhUmVuYW1lVGhpc0FuZEFyZ3VtZW50cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEZVTkNUSU9OX0JPRFkgPSAkX183LkZVTkNUSU9OX0JPRFksXG4gICAgICBMSVRFUkFMX1BST1BFUlRZX05BTUUgPSAkX183LkxJVEVSQUxfUFJPUEVSVFlfTkFNRTtcbiAgdmFyIEZpbmRUaGlzT3JBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kVGhpc09yQXJndW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIuanNcIikpLkZpbmRUaGlzT3JBcmd1bWVudHM7XG4gIHZhciAkX185ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gJF9fOS5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbiA9ICRfXzkuY3JlYXRlQ29tbWFFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlRnVuY3Rpb25Cb2R5ID0gJF9fOS5jcmVhdGVGdW5jdGlvbkJvZHksXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzkuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQgPSAkX185LmNyZWF0ZVJldHVyblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZVRoaXNFeHByZXNzaW9uID0gJF9fOS5jcmVhdGVUaGlzRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gY29udmVydENvbmNpc2VCb2R5KHRyZWUpIHtcbiAgICBpZiAodHJlZS50eXBlICE9PSBGVU5DVElPTl9CT0RZKVxuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uQm9keShbY3JlYXRlUmV0dXJuU3RhdGVtZW50KHRyZWUpXSk7XG4gICAgcmV0dXJuIHRyZWU7XG4gIH1cbiAgdmFyIEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbkRlcml2ZWRDbGFzc18gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5Db25zdHJ1Y3Rvcl8gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtQXJyb3dGdW5jdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy5pbkRlcml2ZWRDbGFzc18gJiYgdGhpcy5pbkNvbnN0cnVjdG9yXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVVzaW5nQ29tbWFFeHByZXNzaW9uXyh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Vc2luZ1RlbXBWYXJfKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVVzaW5nQ29tbWFFeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZmluZGVyID0gbmV3IEZpbmRUaGlzT3JBcmd1bWVudHMoKTtcbiAgICAgICAgdmFyIGFyZ3VtZW50c1RlbXBOYW1lLFxuICAgICAgICAgICAgdGhpc1RlbXBOYW1lO1xuICAgICAgICBmaW5kZXIudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIGlmIChmaW5kZXIuZm91bmRBcmd1bWVudHMpIHtcbiAgICAgICAgICBhcmd1bWVudHNUZW1wTmFtZSA9IHRoaXMuYWRkVGVtcFZhcigpO1xuICAgICAgICAgIHRyZWUgPSBBbHBoYVJlbmFtZXIucmVuYW1lKHRyZWUsIEFSR1VNRU5UUywgYXJndW1lbnRzVGVtcE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5kZXIuZm91bmRUaGlzKSB7XG4gICAgICAgICAgdGhpc1RlbXBOYW1lID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgICAgdHJlZSA9IEFscGhhUmVuYW1lci5yZW5hbWUodHJlZSwgVEhJUywgdGhpc1RlbXBOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgYm9keSA9IGNvbnZlcnRDb25jaXNlQm9keShib2R5KTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uRXhwcmVzc2lvbiA9IG5ldyBGdW5jdGlvbkV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbnVsbCwgdHJlZS5mdW5jdGlvbktpbmQsIHBhcmFtZXRlckxpc3QsIG51bGwsIFtdLCBib2R5KTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGlmIChhcmd1bWVudHNUZW1wTmFtZSkge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24oY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oYXJndW1lbnRzVGVtcE5hbWUpLCBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihBUkdVTUVOVFMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNUZW1wTmFtZSkge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24oY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGhpc1RlbXBOYW1lKSwgY3JlYXRlVGhpc0V4cHJlc3Npb24oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVXNpbmdUZW1wVmFyXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgYWxwaGFSZW5hbWVkID0gYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KGFscGhhUmVuYW1lZC5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueShhbHBoYVJlbmFtZWQuYm9keSk7XG4gICAgICAgIGJvZHkgPSBjb252ZXJ0Q29uY2lzZUJvZHkoYm9keSk7XG4gICAgICAgIHZhciBmdW5jdGlvbkV4cHJlc3Npb24gPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG51bGwsIHRyZWUuZnVuY3Rpb25LaW5kLCBwYXJhbWV0ZXJMaXN0LCBudWxsLCBbXSwgYm9keSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbkRlcml2ZWRDbGFzcyA9IHRoaXMuaW5EZXJpdmVkQ2xhc3NfO1xuICAgICAgICB0aGlzLmluRGVyaXZlZENsYXNzXyA9IHRyZWUuc3VwZXJDbGFzcyAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUNsYXNzRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLmluRGVyaXZlZENsYXNzXyA9IGluRGVyaXZlZENsYXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluRGVyaXZlZENsYXNzID0gdGhpcy5pbkRlcml2ZWRDbGFzc187XG4gICAgICAgIHRoaXMuaW5EZXJpdmVkQ2xhc3NfID0gdHJlZS5zdXBlckNsYXNzICE9PSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLmluRGVyaXZlZENsYXNzXyA9IGluRGVyaXZlZENsYXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaW5Db25zdHJ1Y3RvciA9IHRoaXMuaW5Db25zdHJ1Y3Rvcl87XG4gICAgICAgIHRoaXMuaW5Db25zdHJ1Y3Rvcl8gPSAhdHJlZS5pc1N0YXRpYyAmJiB0cmVlLmZ1bmN0aW9uS2luZCA9PT0gbnVsbCAmJiB0cmVlLm5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FICYmIHRyZWUubmFtZS5saXRlcmFsVG9rZW4udmFsdWUgPT09IENPTlNUUlVDVE9SO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTWV0aG9kXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHRoaXMuaW5Db25zdHJ1Y3Rvcl8gPSBpbkNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm06IGZ1bmN0aW9uKHRlbXBWYXJUcmFuc2Zvcm1lciwgdHJlZSkge1xuICAgICAgICB0cmVlID0gYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzKHRlbXBWYXJUcmFuc2Zvcm1lciwgdHJlZSk7XG4gICAgICAgIHZhciBib2R5ID0gY29udmVydENvbmNpc2VCb2R5KHRyZWUuYm9keSk7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG51bGwsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIG51bGwsIFtdLCBib2R5KTtcbiAgICAgIH19LCAkX19zdXBlcik7XG4gIH0oUGFyZW5UcmFpdChUZW1wVmFyVHJhbnNmb3JtZXIpKTtcbiAgcmV0dXJuIHtnZXQgQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXJndW1lbnRMaXN0ID0gJF9fMi5jcmVhdGVBcmd1bWVudExpc3QsXG4gICAgICBjcmVhdGVCbG9jayA9ICRfXzIuY3JlYXRlQmxvY2ssXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18yLmNyZWF0ZUZ1bmN0aW9uQm9keSxcbiAgICAgIGlkID0gJF9fMi5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX18yLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzIuY3JlYXRlVGhpc0V4cHJlc3Npb24sXG4gICAgICBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fMi5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX18yLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX18yLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VTdGF0ZW1lbnQ7XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLlRlbXBWYXJUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQXdhaXRFeHByZXNzaW9uID0gJF9fNi5Bd2FpdEV4cHJlc3Npb24sXG4gICAgICBCbG9jayA9ICRfXzYuQmxvY2ssXG4gICAgICBDYWxsRXhwcmVzc2lvbiA9ICRfXzYuQ2FsbEV4cHJlc3Npb24sXG4gICAgICBDYXRjaCA9ICRfXzYuQ2F0Y2g7XG4gIHZhciBTa2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1NraXBGdW5jdGlvbnNUcmFuc2Zvcm1lclRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgQVJHVU1FTlRTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiKSkuQVJHVU1FTlRTO1xuICB2YXIgVkFSID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLlZBUjtcbiAgdmFyIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18gPSBbXTtcbiAgICAgIHRoaXMuY3R4XyA9IGlkKHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1ZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGFyZ0xpc3QgPSBjcmVhdGVBcmd1bWVudExpc3QoW3RyZWUuZXhwcmVzc2lvbl0pO1xuICAgICAgICBpZiAodHJlZS5pc1lpZWxkRm9yKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBd2FpdEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbmV3IENhbGxFeHByZXNzaW9uKG51bGwsIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24odGhpcy5jdHhfLCAneWllbGRGb3InKSwgYXJnTGlzdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbih0aGlzLmN0eF8sICd5aWVsZCcpLCBhcmdMaXN0KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYXRjaDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgYm9keSA9IHRyZWUuY2F0Y2hCb2R5O1xuICAgICAgICBib2R5ID0gbmV3IEJsb2NrKGJvZHkubG9jYXRpb24sICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3BhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIGlmIChcIiwgXCIuaW5SZXR1cm4pIHtcXG4gICAgICAgICAgdGhyb3cgdW5kZWZpbmVkO1xcbiAgICAgICAgfVwiXSksIHRoaXMuY3R4XyldLCBib2R5LnN0YXRlbWVudHMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRjaCh0cmVlLmxvY2F0aW9uLCB0cmVlLmJpbmRpbmcsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFzeW5jR2VuZXJhdG9yQm9keV86IGZ1bmN0aW9uKHRyZWUsIG5hbWUpIHtcbiAgICAgICAgdHJlZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgICB0cmVlID0gYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gY3JlYXRlQmxvY2sodHJlZS5zdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIGNyZWF0ZUFzeW5jR2VuZXJhdG9ySW5zdGFuY2UgPSB0aGlzLmdldFJ1bnRpbWVFeHByZXNzaW9uKCdjcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlJyk7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICByZXR1cm4gXCIsIFwiKFxcbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIChcIiwgXCIpIHtcXG4gICAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgfSwgXCIsIFwiKTtcIl0pLCBjcmVhdGVBc3luY0dlbmVyYXRvckluc3RhbmNlLCB0aGlzLmN0eF8sIGJvZHksIG5hbWUpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uQm9keShzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBhZGRUZW1wVmFyRm9yQXJndW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRtcFZhck5hbWUgPSB0aGlzLmdldFRlbXBJZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLnB1c2goY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbih0bXBWYXJOYW1lLCBpZChBUkdVTUVOVFMpKSk7XG4gICAgICAgIHJldHVybiB0bXBWYXJOYW1lO1xuICAgICAgfSxcbiAgICAgIGFkZFRlbXBWYXJGb3JUaGlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRtcFZhck5hbWUgPSB0aGlzLmdldFRlbXBJZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLnB1c2goY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbih0bXBWYXJOYW1lLCBjcmVhdGVUaGlzRXhwcmVzc2lvbigpKSk7XG4gICAgICAgIHJldHVybiB0bXBWYXJOYW1lO1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm1Bc3luY0dlbmVyYXRvckJvZHk6IGZ1bmN0aW9uKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zLCBib2R5LCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucykudHJhbnNmb3JtQXN5bmNHZW5lcmF0b3JCb2R5Xyhib2R5LCBuYW1lKTtcbiAgICAgIH19LCAkX19zdXBlcik7XG4gIH0oU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQoSW1wb3J0UnVudGltZVRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpKTtcbiAgcmV0dXJuIHtnZXQgQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBBc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiO1xuICB2YXIgQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiKSkuQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1lcjtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fMy5Bbm9uQmxvY2ssXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uID0gJF9fMy5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fMy5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgY3JlYXRlQmluZGluZ0lkZW50aWZpZXIgPSAkX181LmNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyLFxuICAgICAgaWQgPSAkX181LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlSWRlbnRpZmllclRva2VuID0gJF9fNS5jcmVhdGVJZGVudGlmaWVyVG9rZW47XG4gIHZhciAkX182ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0FzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX182LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fNi5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcyA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1PcHRpb25zXyA9IG9wdGlvbnMudHJhbnNmb3JtT3B0aW9ucztcbiAgICAgIHRoaXMuaW5CbG9ja18gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcywge1xuICAgICAgbmVlZHNUcmFuc2Zvcm1fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU9wdGlvbnNfLmFzeW5jR2VuZXJhdG9ycyAmJiB0cmVlLmlzQXN5bmNHZW5lcmF0b3IoKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWVkc1RyYW5zZm9ybV8odHJlZSkpXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyIG5hbWVJZEV4cHJlc3Npb24gPSBpZCh0cmVlLm5hbWUuaWRlbnRpZmllclRva2VuKTtcbiAgICAgICAgdmFyIGluaXRBc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignaW5pdEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24nKTtcbiAgICAgICAgdmFyIHNldHVwUHJvdG90eXBlRXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCBpbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbiwgbmFtZUlkRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB0bXBWYXIgPSBpZCh0aGlzLmluQmxvY2tfID8gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpIDogdGhpcy5hZGRUZW1wVmFyKHNldHVwUHJvdG90eXBlRXhwcmVzc2lvbikpO1xuICAgICAgICB2YXIgZnVuY0RlY2wgPSB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uXyh0cmVlLCBGdW5jdGlvbkRlY2xhcmF0aW9uLCB0bXBWYXIpO1xuICAgICAgICBpZiAoIXRoaXMuaW5CbG9ja18pXG4gICAgICAgICAgcmV0dXJuIGZ1bmNEZWNsO1xuICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBbZnVuY0RlY2wsIHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJ2YXIgXCIsIFwiID0gXCIsIFwiXCJdKSwgdG1wVmFyLCBzZXR1cFByb3RvdHlwZUV4cHJlc3Npb24pXSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWVkc1RyYW5zZm9ybV8odHJlZSkpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIGlmICghdHJlZS5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbih0aGlzLmdldFRlbXBJZGVudGlmaWVyKCkpO1xuICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKG5hbWUpLCB0cmVlLmZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCB0cmVlLmFubm90YXRpb25zLCB0cmVlLmJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSB0cmVlLm5hbWUuaWRlbnRpZmllclRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jdGlvbkV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uXyh0cmVlLCBGdW5jdGlvbkV4cHJlc3Npb24sIGlkKG5hbWUpKTtcbiAgICAgICAgdmFyIGluaXRBc3luY0dlbmVyYXRvckZ1bmN0aW9uID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignaW5pdEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCBpbml0QXN5bmNHZW5lcmF0b3JGdW5jdGlvbiwgZnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbl86IGZ1bmN0aW9uKHRyZWUsIGNvbnN0cnVjdG9yLCBuYW1lRXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgYm9keSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MucHJvdG90eXBlLCBcInRyYW5zZm9ybUFueVwiKS5jYWxsKHRoaXMsIHRyZWUuYm9keSk7XG4gICAgICAgIGJvZHkgPSBBc3luY0dlbmVyYXRvclRyYW5zZm9ybWVyLnRyYW5zZm9ybUFzeW5jR2VuZXJhdG9yQm9keSh0aGlzLmlkZW50aWZpZXJHZW5lcmF0b3IsIHRoaXMucmVwb3J0ZXIsIHRoaXMub3B0aW9ucywgYm9keSwgbmFtZUV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgZnVuY3Rpb25LaW5kID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHJ1Y3Rvcih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIGZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uIHx8IG51bGwsIHRyZWUuYW5ub3RhdGlvbnMgfHwgbnVsbCwgYm9keSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmxvY2s6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluQmxvY2sgPSB0aGlzLmluQmxvY2tfO1xuICAgICAgICB0aGlzLmluQmxvY2tfID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJ2ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5wcm90b3R5cGUsIFwidHJhbnNmb3JtQmxvY2tcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdGhpcy5pbkJsb2NrXyA9IGluQmxvY2s7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChUZW1wVmFyVHJhbnNmb3JtZXIpKTtcbiAgcmV0dXJuIHtnZXQgQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzKCkge1xuICAgICAgcmV0dXJuIEFzeW5jR2VuZXJhdG9yVHJhbnNmb3JtUGFzcztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GaW5kQXJndW1lbnRzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZEFyZ3VtZW50cy5qc1wiO1xuICB2YXIgQVJHVU1FTlRTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRmluZEFyZ3VtZW50cy5qc1wiKSkuQVJHVU1FTlRTO1xuICB2YXIgRmluZEluRnVuY3Rpb25TY29wZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ZpbmRJbkZ1bmN0aW9uU2NvcGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRBcmd1bWVudHMuanNcIikpLkZpbmRJbkZ1bmN0aW9uU2NvcGU7XG4gIHZhciBGaW5kQXJndW1lbnRzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGaW5kQXJndW1lbnRzKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRmluZEFyZ3VtZW50cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZpbmRBcmd1bWVudHMsIHt2aXNpdElkZW50aWZpZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmlkZW50aWZpZXJUb2tlbi52YWx1ZSA9PT0gQVJHVU1FTlRTKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRJbkZ1bmN0aW9uU2NvcGUpO1xuICByZXR1cm4ge2dldCBkZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIEZpbmRBcmd1bWVudHM7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBBUkdVTUVOVFMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLkFSR1VNRU5UUztcbiAgdmFyIEZpbmRBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kQXJndW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRnVuY3Rpb25Cb2R5ID0gJF9fMy5GdW5jdGlvbkJvZHksXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uID0gJF9fMy5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fMy5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBNZXRob2QgPSAkX18zLk1ldGhvZCxcbiAgICAgIFlpZWxkRXhwcmVzc2lvbiA9ICRfXzMuWWllbGRFeHByZXNzaW9uO1xuICB2YXIgSW1wb3J0UnVudGltZVRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBQYXJlblRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyZW5UcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5QYXJlblRyYWl0O1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU51bGxMaXRlcmFsID0gJF9fOC5jcmVhdGVOdWxsTGl0ZXJhbDtcbiAgdmFyIEFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbkFzeW5jRnVuY3Rpb25fID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1GdW5jdGlvblNoYXJlZF8odHJlZSwgRnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1GdW5jdGlvblNoYXJlZF8odHJlZSwgRnVuY3Rpb25FeHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25TaGFyZWRfOiBmdW5jdGlvbih0cmVlLCBjdG9yKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIHR5cGVBbm5vdGF0aW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFzeW5jQm9keV8odHJlZS5ib2R5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgbnVsbCwgcGFyYW1ldGVyTGlzdCwgdHlwZUFubm90YXRpb24sIGFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bc3luY0JvZHlfOiBmdW5jdGlvbihib2R5KSB7XG4gICAgICAgIHZhciBpbkFzeW5jRnVuY3Rpb24gPSB0aGlzLmluQXN5bmNGdW5jdGlvbl87XG4gICAgICAgIHRoaXMuaW5Bc3luY0Z1bmN0aW9uXyA9IHRydWU7XG4gICAgICAgIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uQm9keShib2R5KTtcbiAgICAgICAgdmFyIHNwYXduID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignc3Bhd24nKTtcbiAgICAgICAgYm9keSA9IHdyYXBCb2R5SW5TcGF3bihib2R5LCBzcGF3bik7XG4gICAgICAgIHRoaXMuaW5Bc3luY0Z1bmN0aW9uXyA9IGluQXN5bmNGdW5jdGlvbjtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWV0aG9kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFzeW5jQm9keV8odHJlZS5ib2R5KTtcbiAgICAgICAgICByZXR1cm4gbmV3IE1ldGhvZCh0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBudWxsLCBuYW1lLCBwYXJhbWV0ZXJMaXN0LCB0eXBlQW5ub3RhdGlvbiwgYW5ub3RhdGlvbnMsIGJvZHksIHRyZWUuZGVidWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTWV0aG9kXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLmluQXN5bmNGdW5jdGlvbl8pIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBZaWVsZEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgZXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Bd2FpdEV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChQYXJlblRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpKTtcbiAgZnVuY3Rpb24gd3JhcEJvZHlJblNwYXduKGJvZHksIHNwYXduKSB7XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgRmluZEFyZ3VtZW50cygpO1xuICAgIHZpc2l0b3IudmlzaXRBbnkoYm9keSk7XG4gICAgdmFyIGFyZ0V4cHIgPSB2aXNpdG9yLmZvdW5kID8gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oQVJHVU1FTlRTKSA6IGNyZWF0ZU51bGxMaXRlcmFsKCk7XG4gICAgdmFyIHN0YXRlbWVudCA9IHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJyZXR1cm4gXCIsIFwiKHRoaXMsIFwiLCBcIiwgZnVuY3Rpb24qKCkgeyBcIiwgXCIgfSk7XCJdKSwgc3Bhd24sIGFyZ0V4cHIsIGJvZHkpO1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25Cb2R5KGJvZHkubG9jYXRpb24sIFtzdGF0ZW1lbnRdKTtcbiAgfVxuICByZXR1cm4ge2dldCBBc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRJZGVudGlmaWVycy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRJZGVudGlmaWVycy5qc1wiO1xuICB2YXIgU2NvcGVWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy9TY29wZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZpbmRJZGVudGlmaWVycy5qc1wiKSkuU2NvcGVWaXNpdG9yO1xuICB2YXIgRmluZElkZW50aWZpZXJzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGaW5kSWRlbnRpZmllcnModHJlZSwgZmlsdGVyRnVuY3Rpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEZpbmRJZGVudGlmaWVycykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZmlsdGVyRnVuY3Rpb25fID0gZmlsdGVyRnVuY3Rpb247XG4gICAgICB0aGlzLmZvdW5kXyA9IGZhbHNlO1xuICAgICAgdGhpcy52aXNpdEFueSh0cmVlKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZpbmRJZGVudGlmaWVycywge1xuICAgICAgdmlzaXRJZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGdW5jdGlvbl8odHJlZS5pZGVudGlmaWVyVG9rZW4udmFsdWUsIHRoaXMuc2NvcGUudHJlZSkpIHtcbiAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldCBmb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRfO1xuICAgICAgfSxcbiAgICAgIHNldCBmb3VuZCh2KSB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdGhpcy5mb3VuZF8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBbnk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgIXRoaXMuZm91bmRfICYmIHRyZWUgJiYgdHJlZS52aXNpdCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdExpc3Q6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgIXRoaXMuZm91bmRfICYmIGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QW55KGxpc3RbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oU2NvcGVWaXNpdG9yKTtcbiAgcmV0dXJuIHtnZXQgRmluZElkZW50aWZpZXJzKCkge1xuICAgICAgcmV0dXJuIEZpbmRJZGVudGlmaWVycztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBhbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMuanNcIikpLnBhcnNlU3RhdGVtZW50O1xuICB2YXIgJF9fNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fNi5Bbm9uQmxvY2ssXG4gICAgICBCcmVha1N0YXRlbWVudCA9ICRfXzYuQnJlYWtTdGF0ZW1lbnQsXG4gICAgICBDb250aW51ZVN0YXRlbWVudCA9ICRfXzYuQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICBGb3JtYWxQYXJhbWV0ZXJMaXN0ID0gJF9fNi5Gb3JtYWxQYXJhbWV0ZXJMaXN0LFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNi5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQgPSAkX182LlJldHVyblN0YXRlbWVudCxcbiAgICAgIFlpZWxkRXhwcmVzc2lvbiA9ICRfXzYuWWllbGRFeHByZXNzaW9uO1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUFyZ3VtZW50TGlzdCA9ICRfXzcuY3JlYXRlQXJndW1lbnRMaXN0LFxuICAgICAgY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCA9ICRfXzcuY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gJF9fNy5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUJsb2NrID0gJF9fNy5jcmVhdGVCbG9jayxcbiAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uID0gJF9fNy5jcmVhdGVDYWxsRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUNhc2VDbGF1c2UgPSAkX183LmNyZWF0ZUNhc2VDbGF1c2UsXG4gICAgICBjcmVhdGVEZWZhdWx0Q2xhdXNlID0gJF9fNy5jcmVhdGVEZWZhdWx0Q2xhdXNlLFxuICAgICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzcuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uQm9keSA9ICRfXzcuY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNy5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdW1iZXJMaXRlcmFsID0gJF9fNy5jcmVhdGVOdW1iZXJMaXRlcmFsLFxuICAgICAgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3IgPSAkX183LmNyZWF0ZU9iamVjdExpdGVyYWxGb3JEZXNjcmlwdG9yLFxuICAgICAgY3JlYXRlU3dpdGNoU3RhdGVtZW50ID0gJF9fNy5jcmVhdGVTd2l0Y2hTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlVGhpc0V4cHJlc3Npb24sXG4gICAgICBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fNy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX183LmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX183LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50LFxuICAgICAgY3JlYXRlVm9pZDAgPSAkX183LmNyZWF0ZVZvaWQwO1xuICB2YXIgQVJHVU1FTlRTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMuanNcIikpLkFSR1VNRU5UUztcbiAgdmFyIFNraXBGdW5jdGlvbnNUcmFuc2Zvcm1lclRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0ZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiKSkuU3RyaW5nU2V0O1xuICB2YXIgVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiKSkuVG9rZW47XG4gIHZhciAkX18xMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiKSksXG4gICAgICBTVEFSID0gJF9fMTIuU1RBUixcbiAgICAgIFZBUiA9ICRfXzEyLlZBUjtcbiAgdmFyIEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucyhpZEdlbmVyYXRvciwgcmVxdWVzdFBhcmVudExhYmVsKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucykuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaWRHZW5lcmF0b3JfID0gaWRHZW5lcmF0b3I7XG4gICAgICB0aGlzLmluTG9vcF8gPSAwO1xuICAgICAgdGhpcy5pbkJyZWFrYmxlXyA9IDA7XG4gICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXyA9IFtdO1xuICAgICAgdGhpcy5leHRyYWN0ZWRTdGF0ZW1lbnRzXyA9IFtdO1xuICAgICAgdGhpcy5yZXF1ZXN0UGFyZW50TGFiZWxfID0gcmVxdWVzdFBhcmVudExhYmVsO1xuICAgICAgdGhpcy5sYWJlbGxlZFN0YXRlbWVudHNfID0gbmV3IFN0cmluZ1NldCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMsIHtcbiAgICAgIGNyZWF0ZUlJRkU6IGZ1bmN0aW9uKGJvZHksIHBhcmFtTGlzdCwgYXJnc0xpc3QsIGluR2VuZXJhdG9yKSB7XG4gICAgICAgIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueShib2R5KTtcbiAgICAgICAgYm9keSA9IGFscGhhUmVuYW1lVGhpc0FuZEFyZ3VtZW50cyh0aGlzLCBib2R5KTtcbiAgICAgICAgdmFyIHRtcEZuTmFtZSA9IHRoaXMuaWRHZW5lcmF0b3JfLmdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgZnVuY3Rpb25LaW5kID0gaW5HZW5lcmF0b3IgPyBuZXcgVG9rZW4oU1RBUiwgbnVsbCkgOiBudWxsO1xuICAgICAgICB2YXIgZnVuY3Rpb25FeHByZXNzaW9uID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBudWxsLCBmdW5jdGlvbktpbmQsIG5ldyBGb3JtYWxQYXJhbWV0ZXJMaXN0KG51bGwsIHBhcmFtTGlzdCksIG51bGwsIFtdLCBjcmVhdGVGdW5jdGlvbkJvZHkoYm9keS5zdGF0ZW1lbnRzIHx8IFtib2R5XSkpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXy5wdXNoKGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24odG1wRm5OYW1lLCBmdW5jdGlvbkV4cHJlc3Npb24pKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRtcEZuTmFtZSksIGNyZWF0ZUFyZ3VtZW50TGlzdChhcmdzTGlzdCkpO1xuICAgICAgICBpZiAoaW5HZW5lcmF0b3IpIHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGwgPSBuZXcgWWllbGRFeHByZXNzaW9uKG51bGwsIGZ1bmN0aW9uQ2FsbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb3BCb2R5ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGVkU3RhdGVtZW50c18ubGVuZ3RoIHx8IHRoaXMuaGFzUmV0dXJucykge1xuICAgICAgICAgIHZhciB0bXBWYXJOYW1lID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGhpcy5pZEdlbmVyYXRvcl8uZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyKCkpO1xuICAgICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLnB1c2goY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbih0bXBWYXJOYW1lLCBudWxsKSk7XG4gICAgICAgICAgdmFyIG1heWJlUmV0dXJuO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1JldHVybnMpIHtcbiAgICAgICAgICAgIG1heWJlUmV0dXJuID0gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImlmICh0eXBlb2YgXCIsIFwiID09PSBcXFwib2JqZWN0XFxcIilcXG4gICAgICAgICAgICByZXR1cm4gXCIsIFwiLnY7XCJdKSwgdG1wVmFyTmFtZSwgdG1wVmFyTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmV4dHJhY3RlZFN0YXRlbWVudHNfLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNhc2VDbGF1c2VzID0gdGhpcy5leHRyYWN0ZWRTdGF0ZW1lbnRzXy5tYXAoZnVuY3Rpb24oc3RhdGVtZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FzZUNsYXVzZShjcmVhdGVOdW1iZXJMaXRlcmFsKGluZGV4KSwgW3N0YXRlbWVudF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWF5YmVSZXR1cm4pIHtcbiAgICAgICAgICAgICAgY2FzZUNsYXVzZXMucHVzaChjcmVhdGVEZWZhdWx0Q2xhdXNlKFttYXliZVJldHVybl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvb3BCb2R5ID0gY3JlYXRlQmxvY2soW2NyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG1wVmFyTmFtZSwgZnVuY3Rpb25DYWxsKSksIGNyZWF0ZVN3aXRjaFN0YXRlbWVudCh0bXBWYXJOYW1lLCBjYXNlQ2xhdXNlcyldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9vcEJvZHkgPSBjcmVhdGVCbG9jayhbY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXBWYXJOYW1lLCBmdW5jdGlvbkNhbGwpKSwgbWF5YmVSZXR1cm5dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcEJvZHkgPSBjcmVhdGVCbG9jayhbY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChmdW5jdGlvbkNhbGwpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YXJpYWJsZVN0YXRlbWVudHM6IGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFZBUiwgdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18pKSxcbiAgICAgICAgICBsb29wQm9keTogbG9vcEJvZHlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZGRUZW1wVmFyRm9yQXJndW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRtcFZhck5hbWUgPSB0aGlzLmlkR2VuZXJhdG9yXy5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZURlY2xhcmF0aW9uc18ucHVzaChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHRtcFZhck5hbWUsIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKEFSR1VNRU5UUykpKTtcbiAgICAgICAgcmV0dXJuIHRtcFZhck5hbWU7XG4gICAgICB9LFxuICAgICAgYWRkVGVtcFZhckZvclRoaXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG1wVmFyTmFtZSA9IHRoaXMuaWRHZW5lcmF0b3JfLmdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXy5wdXNoKGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24odG1wVmFyTmFtZSwgY3JlYXRlVGhpc0V4cHJlc3Npb24oKSkpO1xuICAgICAgICByZXR1cm4gdG1wVmFyTmFtZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bbnk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUpIHtcbiAgICAgICAgICBpZiAodHJlZS5pc0JyZWFrYWJsZVN0YXRlbWVudCgpKVxuICAgICAgICAgICAgdGhpcy5pbkJyZWFrYmxlXysrO1xuICAgICAgICAgIGlmICh0cmVlLmlzSXRlcmF0aW9uU3RhdGVtZW50KCkpXG4gICAgICAgICAgICB0aGlzLmluTG9vcF8rKztcbiAgICAgICAgICB0cmVlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1BbnlcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICBpZiAodHJlZS5pc0JyZWFrYWJsZVN0YXRlbWVudCgpKVxuICAgICAgICAgICAgdGhpcy5pbkJyZWFrYmxlXy0tO1xuICAgICAgICAgIGlmICh0cmVlLmlzSXRlcmF0aW9uU3RhdGVtZW50KCkpXG4gICAgICAgICAgICB0aGlzLmluTG9vcF8tLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1SZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXR1cm5TdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3Ioe3Y6IHRyZWUuZXhwcmVzc2lvbiB8fCBjcmVhdGVWb2lkMCgpfSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFicnVwdENvbXBsZXRpb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZXh0cmFjdGVkU3RhdGVtZW50c18ucHVzaCh0cmVlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5leHRyYWN0ZWRTdGF0ZW1lbnRzXy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInJldHVybiBcIiwgXCI7XCJdKSwgaW5kZXgpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdHJlZS5uYW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5CcmVha2JsZV8pIHtcbiAgICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMucHJvdG90eXBlLCBcInRyYW5zZm9ybUJyZWFrU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgQnJlYWtTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgdGhpcy5yZXF1ZXN0UGFyZW50TGFiZWxfKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsbGVkU3RhdGVtZW50c18uaGFzKHRyZWUubmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1CcmVha1N0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFicnVwdENvbXBsZXRpb25fKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdHJlZS5uYW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5Mb29wXykge1xuICAgICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBGbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5wcm90b3R5cGUsIFwidHJhbnNmb3JtQ29udGludWVTdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJlZSA9IG5ldyBDb250aW51ZVN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCB0aGlzLnJlcXVlc3RQYXJlbnRMYWJlbF8oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxsZWRTdGF0ZW1lbnRzXy5oYXModHJlZS5uYW1lLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMucHJvdG90eXBlLCBcInRyYW5zZm9ybUNvbnRpbnVlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQWJydXB0Q29tcGxldGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGFiZWxsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5sYWJlbGxlZFN0YXRlbWVudHNfLmFkZCh0cmVlLm5hbWUudmFsdWUpO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVZhcmlhYmxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgaWYgKHRyZWUuZGVjbGFyYXRpb25zLmRlY2xhcmF0aW9uVHlwZSA9PT0gVkFSKSB7XG4gICAgICAgICAgdmFyIGFzc2lnbm1lbnRzID0gW107XG4gICAgICAgICAgdHJlZS5kZWNsYXJhdGlvbnMuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24odmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlRGVjbGFyYXRpb24ubHZhbHVlLmdldFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQoJF9fMiwgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMucHJvdG90eXBlLCBcInRyYW5zZm9ybUFueVwiKS5jYWxsKCRfXzIsIHZhcmlhYmxlRGVjbGFyYXRpb24uaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgJF9fMi52YXJpYWJsZURlY2xhcmF0aW9uc18ucHVzaChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHZhcmlhYmxlTmFtZSwgbnVsbCkpO1xuICAgICAgICAgICAgYXNzaWdubWVudHMucHVzaChjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50KGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHZhcmlhYmxlTmFtZSksIGluaXRpYWxpemVyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgYXNzaWdubWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMucHJvdG90eXBlLCBcInRyYW5zZm9ybVZhcmlhYmxlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9XG4gICAgfSwge2NyZWF0ZUlJRkU6IGZ1bmN0aW9uKGlkR2VuZXJhdG9yLCBib2R5LCBwYXJhbUxpc3QsIGFyZ3NMaXN0LCByZXF1ZXN0UGFyZW50TGFiZWwsIGluR2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMoaWRHZW5lcmF0b3IsIHJlcXVlc3RQYXJlbnRMYWJlbCkuY3JlYXRlSUlGRShib2R5LCBwYXJhbUxpc3QsIGFyZ3NMaXN0LCBpbkdlbmVyYXRvcik7XG4gICAgICB9fSwgJF9fc3VwZXIpO1xuICB9KFNraXBGdW5jdGlvbnNUcmFuc2Zvcm1lclRyYWl0KFBhcnNlVHJlZVRyYW5zZm9ybWVyKSk7XG4gIHJldHVybiB7Z2V0IEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zKCkge1xuICAgICAgcmV0dXJuIEZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZVJlZmVyZW5jZXMuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGVSZWZlcmVuY2VzLmpzXCI7XG4gIHZhciBTY29wZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Njb3BlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvU2NvcGVSZWZlcmVuY2VzLmpzXCIpKS5TY29wZTtcbiAgdmFyIFN0cmluZ1NldCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi91dGlsL1N0cmluZ1NldC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlUmVmZXJlbmNlcy5qc1wiKSkuU3RyaW5nU2V0O1xuICB2YXIgU2NvcGVSZWZlcmVuY2VzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTY29wZVJlZmVyZW5jZXMocGFyZW50LCB0cmVlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTY29wZVJlZmVyZW5jZXMpLmNhbGwodGhpcywgcGFyZW50LCB0cmVlKTtcbiAgICAgIHRoaXMuZnJlZVZhcnNfID0gbmV3IFN0cmluZ1NldCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2NvcGVSZWZlcmVuY2VzLCB7XG4gICAgICBhZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5mcmVlVmFyc18uYWRkKG5hbWUpO1xuICAgICAgfSxcbiAgICAgIGhhc0ZyZWVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmVlVmFyc18uaGFzKG5hbWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oU2NvcGUpO1xuICByZXR1cm4ge2dldCBTY29wZVJlZmVyZW5jZXMoKSB7XG4gICAgICByZXR1cm4gU2NvcGVSZWZlcmVuY2VzO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMuanNcIjtcbiAgdmFyIFNjb3BlQ2hhaW5CdWlsZGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU2NvcGVDaGFpbkJ1aWxkZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzLmpzXCIpKS5TY29wZUNoYWluQnVpbGRlcjtcbiAgdmFyIFNjb3BlUmVmZXJlbmNlcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Njb3BlUmVmZXJlbmNlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL1Njb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMuanNcIikpLlNjb3BlUmVmZXJlbmNlcztcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzLmpzXCIpKSxcbiAgICAgIEZVTkNUSU9OX0RFQ0xBUkFUSU9OID0gJF9fMy5GVU5DVElPTl9ERUNMQVJBVElPTixcbiAgICAgIEZVTkNUSU9OX0VYUFJFU1NJT04gPSAkX18zLkZVTkNUSU9OX0VYUFJFU1NJT04sXG4gICAgICBHRVRfQUNDRVNTT1IgPSAkX18zLkdFVF9BQ0NFU1NPUixcbiAgICAgIElERU5USUZJRVJfRVhQUkVTU0lPTiA9ICRfXzMuSURFTlRJRklFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVUSE9EID0gJF9fMy5NRVRIT0QsXG4gICAgICBNT0RVTEUgPSAkX18zLk1PRFVMRSxcbiAgICAgIFNFVF9BQ0NFU1NPUiA9ICRfXzMuU0VUX0FDQ0VTU09SO1xuICB2YXIgVFlQRU9GID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9TY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzLmpzXCIpKS5UWVBFT0Y7XG4gIGZ1bmN0aW9uIGhhc0FyZ3VtZW50c0luU2NvcGUoc2NvcGUpIHtcbiAgICBmb3IgKDsgc2NvcGU7IHNjb3BlID0gc2NvcGUucGFyZW50KSB7XG4gICAgICBzd2l0Y2ggKHNjb3BlLnRyZWUudHlwZSkge1xuICAgICAgICBjYXNlIEZVTkNUSU9OX0RFQ0xBUkFUSU9OOlxuICAgICAgICBjYXNlIEZVTkNUSU9OX0VYUFJFU1NJT046XG4gICAgICAgIGNhc2UgR0VUX0FDQ0VTU09SOlxuICAgICAgICBjYXNlIE1FVEhPRDpcbiAgICAgICAgY2FzZSBTRVRfQUNDRVNTT1I6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpbk1vZHVsZVNjb3BlKHNjb3BlKSB7XG4gICAgZm9yICg7IHNjb3BlOyBzY29wZSA9IHNjb3BlLnBhcmVudCkge1xuICAgICAgaWYgKHNjb3BlLnRyZWUudHlwZSA9PT0gTU9EVUxFKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIFNjb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNjb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcywge1xuICAgICAgY3JlYXRlU2NvcGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZVJlZmVyZW5jZXModGhpcy5zY29wZSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy5pbldpdGhCbG9jaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgICAgICB2YXIgbmFtZSA9IHRyZWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdhcmd1bWVudHMnICYmIGhhc0FyZ3VtZW50c0luU2NvcGUoc2NvcGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnX19tb2R1bGVOYW1lJyAmJiBpbk1vZHVsZVNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmVyZW5jZUZvdW5kKHRyZWUsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFRZUEVPRiAmJiB0cmVlLm9wZXJhbmQudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICAgICAgICB2YXIgYmluZGluZyA9IHNjb3BlLmdldEJpbmRpbmcodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgICAgIHNjb3BlLmFkZFZhcih0cmVlLm9wZXJhbmQsIHRoaXMucmVwb3J0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcy5wcm90b3R5cGUsIFwidmlzaXRVbmFyeUV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlZmVyZW5jZUZvdW5kOiBmdW5jdGlvbih0cmVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuc2NvcGUuYWRkUmVmZXJlbmNlKG5hbWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oU2NvcGVDaGFpbkJ1aWxkZXIpO1xuICByZXR1cm4ge2dldCBTY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzKCkge1xuICAgICAgcmV0dXJuIFNjb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXM7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9CbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgQWxwaGFSZW5hbWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQWxwaGFSZW5hbWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9CbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5qc1wiKSkuQWxwaGFSZW5hbWVyO1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQU5PTl9CTE9DSyA9ICRfXzcuQU5PTl9CTE9DSyxcbiAgICAgIEJJTkRJTkdfSURFTlRJRklFUiA9ICRfXzcuQklORElOR19JREVOVElGSUVSLFxuICAgICAgRk9SX0lOX1NUQVRFTUVOVCA9ICRfXzcuRk9SX0lOX1NUQVRFTUVOVCxcbiAgICAgIEZPUl9PRl9TVEFURU1FTlQgPSAkX183LkZPUl9PRl9TVEFURU1FTlQsXG4gICAgICBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUID0gJF9fNy5WQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUO1xuICB2YXIgJF9fOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fOC5Bbm9uQmxvY2ssXG4gICAgICBCaW5kaW5nRWxlbWVudCA9ICRfXzguQmluZGluZ0VsZW1lbnQsXG4gICAgICBCaW5kaW5nSWRlbnRpZmllciA9ICRfXzguQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBCbG9jayA9ICRfXzguQmxvY2ssXG4gICAgICBDYXRjaCA9ICRfXzguQ2F0Y2gsXG4gICAgICBEb1doaWxlU3RhdGVtZW50ID0gJF9fOC5Eb1doaWxlU3RhdGVtZW50LFxuICAgICAgRm9ySW5TdGF0ZW1lbnQgPSAkX184LkZvckluU3RhdGVtZW50LFxuICAgICAgRm9yU3RhdGVtZW50ID0gJF9fOC5Gb3JTdGF0ZW1lbnQsXG4gICAgICBGb3JtYWxQYXJhbWV0ZXIgPSAkX184LkZvcm1hbFBhcmFtZXRlcixcbiAgICAgIEZ1bmN0aW9uQm9keSA9ICRfXzguRnVuY3Rpb25Cb2R5LFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fOC5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBMYWJlbGxlZFN0YXRlbWVudCA9ICRfXzguTGFiZWxsZWRTdGF0ZW1lbnQsXG4gICAgICBMaXRlcmFsUHJvcGVydHlOYW1lID0gJF9fOC5MaXRlcmFsUHJvcGVydHlOYW1lLFxuICAgICAgTW9kdWxlID0gJF9fOC5Nb2R1bGUsXG4gICAgICBPYmplY3RQYXR0ZXJuRmllbGQgPSAkX184Lk9iamVjdFBhdHRlcm5GaWVsZCxcbiAgICAgIFNjcmlwdCA9ICRfXzguU2NyaXB0LFxuICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbiA9ICRfXzguVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gJF9fOC5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIFZhcmlhYmxlU3RhdGVtZW50ID0gJF9fOC5WYXJpYWJsZVN0YXRlbWVudCxcbiAgICAgIFdoaWxlU3RhdGVtZW50ID0gJF9fOC5XaGlsZVN0YXRlbWVudDtcbiAgdmFyIElkZW50aWZpZXJUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvSWRlbnRpZmllclRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9CbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5qc1wiKSkuSWRlbnRpZmllclRva2VuO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgVkFSID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Jsb2NrQmluZGluZ1RyYW5zZm9ybWVyLmpzXCIpKS5WQVI7XG4gIHZhciAkX18xMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Jsb2NrQmluZGluZ1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyID0gJF9fMTIuY3JlYXRlQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzEyLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlSWRlbnRpZmllclRva2VuID0gJF9fMTIuY3JlYXRlSWRlbnRpZmllclRva2VuO1xuICB2YXIgRmluZElkZW50aWZpZXJzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmluZElkZW50aWZpZXJzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9CbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5qc1wiKSkuRmluZElkZW50aWZpZXJzO1xuICB2YXIgRmluZFZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLkZpbmRWaXNpdG9yO1xuICB2YXIgRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GbkV4dHJhY3RBYnJ1cHRDb21wbGV0aW9ucy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLkZuRXh0cmFjdEFicnVwdENvbXBsZXRpb25zO1xuICB2YXIgU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zZW1hbnRpY3MvU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLlNjb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXM7XG4gIHZhciBwYXJzZUV4cHJlc3Npb24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIikpLnBhcnNlRXhwcmVzc2lvbjtcbiAgdmFyIHByZXBlbmRTdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUHJlcGVuZFN0YXRlbWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Jsb2NrQmluZGluZ1RyYW5zZm9ybWVyLmpzXCIpKS5wcmVwZW5kU3RhdGVtZW50cztcbiAgZnVuY3Rpb24gdmFyTmVlZHNJbml0aWFsaXplcih0cmVlLCBsb29wVHJlZSkge1xuICAgIGlmIChsb29wVHJlZSA9PT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgdHlwZSA9IGxvb3BUcmVlLnR5cGU7XG4gICAgaWYgKHR5cGUgIT09IEZPUl9JTl9TVEFURU1FTlQgJiYgdHlwZSAhPT0gRk9SX09GX1NUQVRFTUVOVClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBsb29wVHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnNbMF0gIT09IHRyZWU7XG4gIH1cbiAgdmFyIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lcihpZEdlbmVyYXRvciwgcmVwb3J0ZXIsIHRyZWUpIHtcbiAgICAgIHZhciBzY29wZUJ1aWxkZXIgPSBhcmd1bWVudHNbM107XG4gICAgICB2YXIgbGF0ZXN0U2NvcGUgPSBhcmd1bWVudHNbNF07XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaWRHZW5lcmF0b3JfID0gaWRHZW5lcmF0b3I7XG4gICAgICB0aGlzLnJlcG9ydGVyXyA9IHJlcG9ydGVyO1xuICAgICAgaWYgKCFzY29wZUJ1aWxkZXIpIHtcbiAgICAgICAgc2NvcGVCdWlsZGVyID0gbmV3IFNjb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMocmVwb3J0ZXIpO1xuICAgICAgICBzY29wZUJ1aWxkZXIudmlzaXRBbnkodHJlZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNjb3BlQnVpbGRlcl8gPSBzY29wZUJ1aWxkZXI7XG4gICAgICB0aGlzLmxhYmVsbGVkTG9vcHNfID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5wcmVwZW5kU3RhdGVtZW50XyA9IFtdO1xuICAgICAgdGhpcy5wcmVwZW5kQmxvY2tTdGF0ZW1lbnRfID0gW107XG4gICAgICB0aGlzLmJsb2NrUmVuYW1lc18gPSBbXTtcbiAgICAgIHRoaXMucm9vdFRyZWVfID0gdHJlZTtcbiAgICAgIGlmIChsYXRlc3RTY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlXyA9IGxhdGVzdFNjb3BlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZWRWYXJzXyA9IHRoaXMuc2NvcGVfLmdldEFsbEJpbmRpbmdOYW1lcygpO1xuICAgICAgdGhpcy5tYXliZVJlbmFtZV8gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5PYmplY3RQYXR0ZXJuXyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50TG9vcFRyZWVfID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLCB7XG4gICAgICBnZXRWYXJpYWJsZU5hbWVfOiBmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICB2YXIgbHZhbHVlID0gdmFyaWFibGUubHZhbHVlO1xuICAgICAgICBpZiAobHZhbHVlLnR5cGUgPT09IEJJTkRJTkdfSURFTlRJRklFUikge1xuICAgICAgICAgIHJldHVybiBsdmFsdWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZGVzdHJ1Y3R1cmluZyBkZWNsYXJhdGlvbiBmb3VuZC4nKTtcbiAgICAgIH0sXG4gICAgICBmbHVzaFJlbmFtZXM6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdHJlZSA9IHJlbmFtZUFsbCh0aGlzLmJsb2NrUmVuYW1lc18sIHRyZWUpO1xuICAgICAgICB0aGlzLmJsb2NrUmVuYW1lc18ubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgcHVzaFNjb3BlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVCdWlsZGVyXy5nZXRTY29wZUZvclRyZWUodHJlZSk7XG4gICAgICAgIGlmICghc2NvcGUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lciB0cmVlIHdpdGggbm8gc2NvcGUnKTtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVfKVxuICAgICAgICAgIHRoaXMuc2NvcGVfLmJsb2NrQmluZGluZ1JlbmFtZXMgPSB0aGlzLmJsb2NrUmVuYW1lc187XG4gICAgICAgIHRoaXMuc2NvcGVfID0gc2NvcGU7XG4gICAgICAgIHRoaXMuYmxvY2tSZW5hbWVzXyA9IFtdO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9LFxuICAgICAgcG9wU2NvcGU6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlXyAhPT0gc2NvcGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrQmluZGluZ1RyYW5zZm9ybWVyIHNjb3BlIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY29wZV8gPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgIHRoaXMuYmxvY2tSZW5hbWVzXyA9IHRoaXMuc2NvcGVfICYmIHRoaXMuc2NvcGVfLmJsb2NrQmluZGluZ1JlbmFtZXMgfHwgW107XG4gICAgICB9LFxuICAgICAgcmV2aXNpdFRyZWVGb3JTY29wZXM6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5zY29wZUJ1aWxkZXJfLnNjb3BlID0gdGhpcy5zY29wZV87XG4gICAgICAgIHRoaXMuc2NvcGVCdWlsZGVyXy52aXNpdEFueSh0cmVlKTtcbiAgICAgICAgdGhpcy5zY29wZUJ1aWxkZXJfLnNjb3BlID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBuZWVkc1JlbmFtZV86IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlZFZhcnNfLmhhcyhuYW1lKSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5zY29wZV87XG4gICAgICAgIHZhciBwYXJlbnQgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHNjb3BlLmlzVmFyU2NvcGUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgdmFyU2NvcGUgPSBzY29wZS5nZXRWYXJTY29wZSgpO1xuICAgICAgICBpZiAodmFyU2NvcGUgJiYgdmFyU2NvcGUuaGFzRnJlZVZhcmlhYmxlKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudEJpbmRpbmcgPSBwYXJlbnQuZ2V0QmluZGluZ0J5TmFtZShuYW1lKTtcbiAgICAgICAgaWYgKCFwYXJlbnRCaW5kaW5nKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGN1cnJlbnRCaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZ0J5TmFtZShuYW1lKTtcbiAgICAgICAgaWYgKGN1cnJlbnRCaW5kaW5nLnRyZWUgPT09IHBhcmVudEJpbmRpbmcudHJlZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIG5ld05hbWVGcm9tT3JpZzogZnVuY3Rpb24ob3JpZ05hbWUsIHJlbmFtZXMpIHtcbiAgICAgICAgdmFyIG5ld05hbWU7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzUmVuYW1lXyhvcmlnTmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lID0gb3JpZ05hbWUgKyB0aGlzLmlkR2VuZXJhdG9yXy5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICByZW5hbWVzLnB1c2gobmV3IFJlbmFtZShvcmlnTmFtZSwgbmV3TmFtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXNlZFZhcnNfLmFkZChvcmlnTmFtZSk7XG4gICAgICAgICAgbmV3TmFtZSA9IG9yaWdOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdOYW1lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZSA9PT0gdGhpcy5yb290VHJlZV8gfHwgIXRoaXMucm9vdFRyZWVfKSB7XG4gICAgICAgICAgdHJlZSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25Cb2R5XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgICAgaWYgKHRoaXMucHJlcGVuZFN0YXRlbWVudF8ubGVuZ3RoIHx8IHRoaXMuYmxvY2tSZW5hbWVzXy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gcHJlcGVuZFN0YXRlbWVudHMuYXBwbHkoKHZvaWQgMCksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RyZWUuc3RhdGVtZW50c10sIHRoaXMucHJlcGVuZFN0YXRlbWVudF8pKTtcbiAgICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25Cb2R5KHRyZWUubG9jYXRpb24sIHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgdHJlZSA9IHRoaXMuZmx1c2hSZW5hbWVzKHRyZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZnVuY3Rpb25UcmFuc2Zvcm0gPSBuZXcgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIodGhpcy5pZEdlbmVyYXRvcl8sIHRoaXMucmVwb3J0ZXJfLCB0cmVlLCB0aGlzLnNjb3BlQnVpbGRlcl8sIHRoaXMuc2NvcGVfKTtcbiAgICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5VHJlZSA9IGZ1bmN0aW9uVHJhbnNmb3JtLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgICBpZiAoZnVuY3Rpb25Cb2R5VHJlZSA9PT0gdHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25Cb2R5KHRyZWUubG9jYXRpb24sIGZ1bmN0aW9uQm9keVRyZWUuc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU2NyaXB0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlID09PSB0aGlzLnJvb3RUcmVlXyB8fCAhdGhpcy5yb290VHJlZV8pIHtcbiAgICAgICAgICB0cmVlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1TY3JpcHRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICBpZiAodGhpcy5wcmVwZW5kU3RhdGVtZW50Xy5sZW5ndGggfHwgdGhpcy5ibG9ja1JlbmFtZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdEl0ZW1MaXN0ID0gcHJlcGVuZFN0YXRlbWVudHMuYXBwbHkoKHZvaWQgMCksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RyZWUuc2NyaXB0SXRlbUxpc3RdLCB0aGlzLnByZXBlbmRTdGF0ZW1lbnRfKSk7XG4gICAgICAgICAgICB0cmVlID0gbmV3IFNjcmlwdCh0cmVlLmxvY2F0aW9uLCBzY3JpcHRJdGVtTGlzdCwgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLmZsdXNoUmVuYW1lcyh0cmVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uVHJhbnNmb3JtID0gbmV3IEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyKHRoaXMuaWRHZW5lcmF0b3JfLCB0aGlzLnJlcG9ydGVyXywgdHJlZSwgdGhpcy5zY29wZUJ1aWxkZXJfKTtcbiAgICAgICAgICB2YXIgbmV3VHJlZSA9IGZ1bmN0aW9uVHJhbnNmb3JtLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gdHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyZWUgPSBuZXcgU2NyaXB0KHRyZWUubG9jYXRpb24sIG5ld1RyZWUuc2NyaXB0SXRlbUxpc3QsIHRyZWUubW9kdWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTW9kdWxlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlID09PSB0aGlzLnJvb3RUcmVlXyB8fCAhdGhpcy5yb290VHJlZV8pIHtcbiAgICAgICAgICB0cmVlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Nb2R1bGVcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICBpZiAodGhpcy5wcmVwZW5kU3RhdGVtZW50Xy5sZW5ndGggfHwgdGhpcy5ibG9ja1JlbmFtZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdEl0ZW1MaXN0ID0gcHJlcGVuZFN0YXRlbWVudHMuYXBwbHkoKHZvaWQgMCksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RyZWUuc2NyaXB0SXRlbUxpc3RdLCB0aGlzLnByZXBlbmRTdGF0ZW1lbnRfKSk7XG4gICAgICAgICAgICB0cmVlID0gbmV3IE1vZHVsZSh0cmVlLmxvY2F0aW9uLCBzY3JpcHRJdGVtTGlzdCwgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLmZsdXNoUmVuYW1lcyh0cmVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZ1bmN0aW9uVHJhbnNmb3JtID0gbmV3IEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyKHRoaXMuaWRHZW5lcmF0b3JfLCB0aGlzLnJlcG9ydGVyXywgdHJlZSwgdGhpcy5zY29wZUJ1aWxkZXJfKTtcbiAgICAgICAgICB2YXIgbmV3VHJlZSA9IGZ1bmN0aW9uVHJhbnNmb3JtLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gdHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyZWUgPSBuZXcgTW9kdWxlKHRyZWUubG9jYXRpb24sIG5ld1RyZWUuc2NyaXB0SXRlbUxpc3QsIHRyZWUubW9kdWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb25zKTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy50eXBlID09PSBBTk9OX0JMT0NLKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjbGFyYXRpb25zID09PSB0cmVlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgZGVjbGFyYXRpb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1WYXJpYWJsZURlY2xhcmF0aW9uTGlzdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5kZWNsYXJhdGlvblR5cGUgPT09IFZBUikge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZVJlbmFtZV8gPSAhdGhpcy5zY29wZV8uaXNWYXJTY29wZTtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmRlY2xhcmF0aW9ucyk7XG4gICAgICAgIHRoaXMubWF5YmVSZW5hbWVfID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodHJlZS5sb2NhdGlvbiwgVkFSLCBkZWNsYXJhdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG1heWJlUmVuYW1lID0gdGhpcy5tYXliZVJlbmFtZV87XG4gICAgICAgIHZhciBsdmFsdWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICAgIHRoaXMubWF5YmVSZW5hbWVfID0gZmFsc2U7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IG51bGw7XG4gICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YXJOZWVkc0luaXRpYWxpemVyKHRyZWUsIHRoaXMuY3VycmVudExvb3BUcmVlXykpIHtcbiAgICAgICAgICBpbml0aWFsaXplciA9IHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1widm9pZCAwXCJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXliZVJlbmFtZV8gPSBtYXliZVJlbmFtZTtcbiAgICAgICAgaWYgKHRyZWUubHZhbHVlID09PSBsdmFsdWUgJiYgdHJlZS5pbml0aWFsaXplciA9PT0gaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgbHZhbHVlLCB0cmVlLnR5cGVBbm5vdGF0aW9uLCBpbml0aWFsaXplcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmluZGluZ0lkZW50aWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMubWF5YmVSZW5hbWVfKSB7XG4gICAgICAgICAgdmFyIG9yaWdOYW1lID0gdHJlZS5nZXRTdHJpbmdWYWx1ZSgpO1xuICAgICAgICAgIHZhciBuZXdOYW1lID0gdGhpcy5uZXdOYW1lRnJvbU9yaWcob3JpZ05hbWUsIHRoaXMuYmxvY2tSZW5hbWVzXyk7XG4gICAgICAgICAgaWYgKG9yaWdOYW1lID09PSBuZXdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1Rva2VuID0gbmV3IElkZW50aWZpZXJUb2tlbih0cmVlLmxvY2F0aW9uLCBuZXdOYW1lKTtcbiAgICAgICAgICB2YXIgYmluZGluZ0lkZW50aWZpZXIgPSBuZXcgQmluZGluZ0lkZW50aWZpZXIodHJlZS5sb2NhdGlvbiwgbmV3VG9rZW4pO1xuICAgICAgICAgIHRoaXMuc2NvcGVfLnJlbmFtZUJpbmRpbmcob3JpZ05hbWUsIGJpbmRpbmdJZGVudGlmaWVyLCBWQVIsIHRoaXMucmVwb3J0ZXJfKTtcbiAgICAgICAgICByZXR1cm4gYmluZGluZ0lkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQmluZGluZ0lkZW50aWZpZXJcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbWF5YmVSZW5hbWUgPSB0aGlzLm1heWJlUmVuYW1lXztcbiAgICAgICAgdmFyIGluT2JqZWN0UGF0dGVybiA9IHRoaXMuaW5PYmplY3RQYXR0ZXJuXztcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJpbmRpbmcpO1xuICAgICAgICB0aGlzLm1heWJlUmVuYW1lXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluT2JqZWN0UGF0dGVybl8gPSBmYWxzZTtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMubWF5YmVSZW5hbWVfID0gbWF5YmVSZW5hbWU7XG4gICAgICAgIHRoaXMuaW5PYmplY3RQYXR0ZXJuXyA9IGluT2JqZWN0UGF0dGVybjtcbiAgICAgICAgaWYgKHRyZWUuYmluZGluZyA9PT0gYmluZGluZyAmJiB0cmVlLmluaXRpYWxpemVyID09PSBpbml0aWFsaXplcikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaW5kaW5nRWxlbWVudCA9IG5ldyBCaW5kaW5nRWxlbWVudCh0cmVlLmxvY2F0aW9uLCBiaW5kaW5nLCBpbml0aWFsaXplcik7XG4gICAgICAgIGlmICh0aGlzLmluT2JqZWN0UGF0dGVybl8gJiYgdHJlZS5iaW5kaW5nICE9PSBiaW5kaW5nICYmIHRyZWUuYmluZGluZy50eXBlID09PSBCSU5ESU5HX0lERU5USUZJRVIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE9iamVjdFBhdHRlcm5GaWVsZCh0cmVlLmxvY2F0aW9uLCBuZXcgTGl0ZXJhbFByb3BlcnR5TmFtZSh0cmVlLmxvY2F0aW9uLCB0cmVlLmJpbmRpbmcuaWRlbnRpZmllclRva2VuKSwgYmluZGluZ0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nRWxlbWVudDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1PYmplY3RQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbk9iamVjdFBhdHRlcm4gPSB0aGlzLmluT2JqZWN0UGF0dGVybl87XG4gICAgICAgIHRoaXMuaW5PYmplY3RQYXR0ZXJuXyA9IHRydWU7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtT2JqZWN0UGF0dGVyblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLmluT2JqZWN0UGF0dGVybl8gPSBpbk9iamVjdFBhdHRlcm47XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1PYmplY3RQYXR0ZXJuRmllbGQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLmluT2JqZWN0UGF0dGVybl8gPSBmYWxzZTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmluT2JqZWN0UGF0dGVybl8gPSB0cnVlO1xuICAgICAgICBpZiAodHJlZS5uYW1lID09PSBuYW1lICYmIHRyZWUuZWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0UGF0dGVybkZpZWxkKHRyZWUubG9jYXRpb24sIG5hbWUsIGVsZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJsb2NrOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICB2YXIgb3V0ZXJQcmVwZW5kcyA9IHRoaXMucHJlcGVuZEJsb2NrU3RhdGVtZW50XztcbiAgICAgICAgdGhpcy5wcmVwZW5kQmxvY2tTdGF0ZW1lbnRfID0gW107XG4gICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJsb2NrXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIGlmICh0aGlzLnByZXBlbmRCbG9ja1N0YXRlbWVudF8ubGVuZ3RoKSB7XG4gICAgICAgICAgdHJlZSA9IG5ldyBCbG9jayh0cmVlLmxvY2F0aW9uLCBwcmVwZW5kU3RhdGVtZW50cy5hcHBseSgodm9pZCAwKSwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChbdHJlZS5zdGF0ZW1lbnRzXSwgdGhpcy5wcmVwZW5kQmxvY2tTdGF0ZW1lbnRfKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGVuZEJsb2NrU3RhdGVtZW50XyA9IG91dGVyUHJlcGVuZHM7XG4gICAgICAgIHRyZWUgPSB0aGlzLmZsdXNoUmVuYW1lcyh0cmVlKTtcbiAgICAgICAgdGhpcy5wb3BTY29wZShzY29wZSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNhdGNoOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYmluZGluZyk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuY2F0Y2hCb2R5LnN0YXRlbWVudHMpO1xuICAgICAgICBpZiAoYmluZGluZyAhPT0gdHJlZS5iaW5kaW5nIHx8IHN0YXRlbWVudHMgIT09IHRyZWUuY2F0Y2hCb2R5LnN0YXRlbWVudHMpIHtcbiAgICAgICAgICB0cmVlID0gbmV3IENhdGNoKHRyZWUubG9jYXRpb24sIGJpbmRpbmcsIG5ldyBCbG9jayh0cmVlLmNhdGNoQm9keS5sb2NhdGlvbiwgc3RhdGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIHRyZWUgPSB0aGlzLmZsdXNoUmVuYW1lcyh0cmVlKTtcbiAgICAgICAgdGhpcy5wb3BTY29wZShzY29wZSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRm9yU2NvcGVfOiBmdW5jdGlvbihmdW5jLCB0cmVlKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMucHVzaFNjb3BlKHRyZWUpO1xuICAgICAgICB0cmVlID0gZnVuYygpO1xuICAgICAgICB0cmVlID0gdGhpcy5mbHVzaFJlbmFtZXModHJlZSk7XG4gICAgICAgIHRoaXMucG9wU2NvcGUoc2NvcGUpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1HZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uRm9yU2NvcGVfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQoJF9fMywgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUdldEFjY2Vzc29yXCIpLmNhbGwoJF9fMywgdHJlZSk7XG4gICAgICAgIH0sIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRnVuY3Rpb25Gb3JTY29wZV8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18zLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtU2V0QWNjZXNzb3JcIikuY2FsbCgkX18zLCB0cmVlKTtcbiAgICAgICAgfSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRnVuY3Rpb25Gb3JTY29wZV8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18zLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uXCIpLmNhbGwoJF9fMywgdHJlZSk7XG4gICAgICAgIH0sIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2NvcGVfLmlzVmFyU2NvcGUpIHtcbiAgICAgICAgICB2YXIgb3JpZ05hbWUgPSB0cmVlLm5hbWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICB2YXIgbmV3TmFtZSA9IHRoaXMubmV3TmFtZUZyb21PcmlnKG9yaWdOYW1lLCB0aGlzLmJsb2NrUmVuYW1lc18pO1xuICAgICAgICAgIHZhciBmdW5jdGlvbkV4cHJlc3Npb24gPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG51bGwsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIHRyZWUudHlwZUFubm90YXRpb24sIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgICAgdGhpcy5yZXZpc2l0VHJlZUZvclNjb3BlcyhmdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgICAgICAgIGZ1bmN0aW9uRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KGZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIGJpbmRpbmdJZGVudGlmaWVyID0gY3JlYXRlQmluZGluZ0lkZW50aWZpZXIobmV3TmFtZSk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IG5ldyBWYXJpYWJsZVN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QodHJlZS5sb2NhdGlvbiwgVkFSLCBbbmV3IFZhcmlhYmxlRGVjbGFyYXRpb24odHJlZS5sb2NhdGlvbiwgYmluZGluZ0lkZW50aWZpZXIsIG51bGwsIGZ1bmN0aW9uRXhwcmVzc2lvbildKSk7XG4gICAgICAgICAgdGhpcy5zY29wZV8ucmVuYW1lQmluZGluZyhvcmlnTmFtZSwgYmluZGluZ0lkZW50aWZpZXIsIFZBUiwgdGhpcy5yZXBvcnRlcl8pO1xuICAgICAgICAgIHRoaXMucHJlcGVuZEJsb2NrU3RhdGVtZW50Xy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uRm9yU2NvcGVfKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQoJF9fMywgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb25cIikuY2FsbCgkX18zLCB0cmVlKTtcbiAgICAgICAgfSwgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTG9vcF86IGZ1bmN0aW9uKGZ1bmMsIHRyZWUsIGxvb3BGYWN0b3J5KSB7XG4gICAgICAgIHZhciAkX18zID0gdGhpcztcbiAgICAgICAgdmFyIHNjb3BlLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZXJJc0Jsb2NrQmluZGluZztcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIgJiYgdHJlZS5pbml0aWFsaXplci50eXBlID09PSBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUICYmIHRyZWUuaW5pdGlhbGl6ZXIuZGVjbGFyYXRpb25UeXBlICE9PSBWQVIpIHtcbiAgICAgICAgICBpbml0aWFsaXplcklzQmxvY2tCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbGl6ZXJJc0Jsb2NrQmluZGluZykge1xuICAgICAgICAgIHNjb3BlID0gdGhpcy5wdXNoU2NvcGUodHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbmRlciA9IG5ldyBGaW5kQmxvY2tCaW5kaW5nSW5Mb29wKHRyZWUsIHRoaXMuc2NvcGVCdWlsZGVyXyk7XG4gICAgICAgIGZpbmRlci52aXNpdEFueSh0cmVlKTtcbiAgICAgICAgaWYgKCFmaW5kZXIuZm91bmQpIHtcbiAgICAgICAgICB2YXIgY2FsbEZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TG9vcFRyZWUgPSAkX18zLmN1cnJlbnRMb29wVHJlZV87XG4gICAgICAgICAgICAkX18zLmN1cnJlbnRMb29wVHJlZV8gPSB0cmVlO1xuICAgICAgICAgICAgdmFyIHJ2ID0gZnVuYyh0cmVlKTtcbiAgICAgICAgICAgICRfXzMuY3VycmVudExvb3BUcmVlXyA9IGN1cnJlbnRMb29wVHJlZTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICghaW5pdGlhbGl6ZXJJc0Jsb2NrQmluZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxGdW5jKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW5hbWVzID0gW107XG4gICAgICAgICAgdmFyIGluaXRpYWxpemVyID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KG51bGwsIFZBUiwgdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ05hbWUgPSAkX18zLmdldFZhcmlhYmxlTmFtZV8oZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgdmFyIG5ld05hbWUgPSAkX18zLm5ld05hbWVGcm9tT3JpZyhvcmlnTmFtZSwgcmVuYW1lcyk7XG4gICAgICAgICAgICB2YXIgYmluZGluZ0lkZW50aWZpZXIgPSBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcihuZXdOYW1lKTtcbiAgICAgICAgICAgICRfXzMuc2NvcGVfLnJlbmFtZUJpbmRpbmcob3JpZ05hbWUsIGJpbmRpbmdJZGVudGlmaWVyLCBWQVIsICRfXzMucmVwb3J0ZXJfKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbihudWxsLCBiaW5kaW5nSWRlbnRpZmllciwgbnVsbCwgZGVjbGFyYXRpb24uaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpbml0aWFsaXplciA9IHJlbmFtZUFsbChyZW5hbWVzLCBpbml0aWFsaXplcik7XG4gICAgICAgICAgdHJlZSA9IGxvb3BGYWN0b3J5KGluaXRpYWxpemVyLCByZW5hbWVzLCByZW5hbWVBbGwocmVuYW1lcywgdHJlZS5ib2R5KSk7XG4gICAgICAgICAgdGhpcy5yZXZpc2l0VHJlZUZvclNjb3Blcyh0cmVlKTtcbiAgICAgICAgICB0cmVlID0gY2FsbEZ1bmMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaWlmZVBhcmFtZXRlckxpc3QgPSBbXTtcbiAgICAgICAgICB2YXIgaWlmZUFyZ3VtZW50TGlzdCA9IFtdO1xuICAgICAgICAgIHZhciByZW5hbWVzJF9fNCA9IFtdO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciRfXzUgPSBudWxsO1xuICAgICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICBpZiAodHJlZS5pbml0aWFsaXplci50eXBlID09PSBWQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNUICYmIHRyZWUuaW5pdGlhbGl6ZXIuZGVjbGFyYXRpb25UeXBlICE9PSBWQVIpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZXIkX181ID0gbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KG51bGwsIFZBUiwgdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdOYW1lID0gJF9fMy5nZXRWYXJpYWJsZU5hbWVfKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9ICRfXzMubmV3TmFtZUZyb21PcmlnKG9yaWdOYW1lLCByZW5hbWVzJF9fNCk7XG4gICAgICAgICAgICAgICAgaWlmZUFyZ3VtZW50TGlzdC5wdXNoKGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKG5ld05hbWUpKTtcbiAgICAgICAgICAgICAgICBpaWZlUGFyYW1ldGVyTGlzdC5wdXNoKG5ldyBGb3JtYWxQYXJhbWV0ZXIobnVsbCwgbmV3IEJpbmRpbmdFbGVtZW50KG51bGwsIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKG9yaWdOYW1lKSwgbnVsbCksIG51bGwsIFtdKSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdJZGVudGlmaWVyID0gY3JlYXRlQmluZGluZ0lkZW50aWZpZXIobmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgJF9fMy5zY29wZV8ucmVuYW1lQmluZGluZyhvcmlnTmFtZSwgYmluZGluZ0lkZW50aWZpZXIsIFZBUiwgJF9fMy5yZXBvcnRlcl8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbihudWxsLCBiaW5kaW5nSWRlbnRpZmllciwgbnVsbCwgZGVjbGFyYXRpb24uaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGluaXRpYWxpemVyJF9fNSA9IHJlbmFtZUFsbChyZW5hbWVzJF9fNCwgaW5pdGlhbGl6ZXIkX181KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluaXRpYWxpemVyJF9fNSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbG9vcExhYmVsID0gdGhpcy5sYWJlbGxlZExvb3BzXy5nZXQodHJlZSk7XG4gICAgICAgICAgdmFyIGlpZmVJbmZvID0gRm5FeHRyYWN0QWJydXB0Q29tcGxldGlvbnMuY3JlYXRlSUlGRSh0aGlzLmlkR2VuZXJhdG9yXywgdHJlZS5ib2R5LCBpaWZlUGFyYW1ldGVyTGlzdCwgaWlmZUFyZ3VtZW50TGlzdCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9vcExhYmVsID0gbG9vcExhYmVsIHx8IGNyZWF0ZUlkZW50aWZpZXJUb2tlbigkX18zLmlkR2VuZXJhdG9yXy5nZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXIoKSk7XG4gICAgICAgICAgfSwgdGhpcy5zY29wZV8uaW5HZW5lcmF0b3IpO1xuICAgICAgICAgIHRyZWUgPSBsb29wRmFjdG9yeShpbml0aWFsaXplciRfXzUsIHJlbmFtZXMkX180LCBpaWZlSW5mby5sb29wQm9keSk7XG4gICAgICAgICAgaWYgKGxvb3BMYWJlbCkge1xuICAgICAgICAgICAgdHJlZSA9IG5ldyBMYWJlbGxlZFN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBsb29wTGFiZWwsIHRyZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmVlID0gbmV3IEFub25CbG9jayh0cmVlLmxvY2F0aW9uLCBbaWlmZUluZm8udmFyaWFibGVTdGF0ZW1lbnRzLCB0cmVlXSk7XG4gICAgICAgICAgdGhpcy5yZXZpc2l0VHJlZUZvclNjb3Blcyh0cmVlKTtcbiAgICAgICAgICB0cmVlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxpemVySXNCbG9ja0JpbmRpbmcpIHtcbiAgICAgICAgICB0cmVlID0gdGhpcy5mbHVzaFJlbmFtZXModHJlZSk7XG4gICAgICAgICAgdGhpcy5wb3BTY29wZShzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Mb29wXyhmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18zLCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9ySW5TdGF0ZW1lbnRcIikuY2FsbCgkX18zLCB0KTtcbiAgICAgICAgfSwgdHJlZSwgZnVuY3Rpb24oaW5pdGlhbGl6ZXIsIHJlbmFtZXMsIGJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvckluU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGluaXRpYWxpemVyLCByZW5hbWVBbGwocmVuYW1lcywgdHJlZS5jb2xsZWN0aW9uKSwgYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUxvb3BfKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KCRfXzMsIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Gb3JTdGF0ZW1lbnRcIikuY2FsbCgkX18zLCB0KTtcbiAgICAgICAgfSwgdHJlZSwgZnVuY3Rpb24oaW5pdGlhbGl6ZXIsIHJlbmFtZXMsIGJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvclN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBpbml0aWFsaXplciwgcmVuYW1lQWxsKHJlbmFtZXMsIHRyZWUuY29uZGl0aW9uKSwgcmVuYW1lQWxsKHJlbmFtZXMsIHRyZWUuaW5jcmVtZW50KSwgYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTG9vcF8oZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQoJF9fMywgQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVdoaWxlU3RhdGVtZW50XCIpLmNhbGwoJF9fMywgdCk7XG4gICAgICAgIH0sIHRyZWUsIGZ1bmN0aW9uKGluaXRpYWxpemVyLCByZW5hbWVzLCBib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXaGlsZVN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCByZW5hbWVBbGwocmVuYW1lcywgdHJlZS5jb25kaXRpb24pLCBib2R5KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUxvb3BfKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KCRfXzMsIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Eb1doaWxlU3RhdGVtZW50XCIpLmNhbGwoJF9fMywgdCk7XG4gICAgICAgIH0sIHRyZWUsIGZ1bmN0aW9uKGluaXRpYWxpemVyLCByZW5hbWVzLCBib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEb1doaWxlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGJvZHksIHJlbmFtZUFsbChyZW5hbWVzLCB0cmVlLmNvbmRpdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5zdGF0ZW1lbnQuaXNJdGVyYXRpb25TdGF0ZW1lbnQoKSkge1xuICAgICAgICAgIHRoaXMubGFiZWxsZWRMb29wc18uc2V0KHRyZWUuc3RhdGVtZW50LCB0cmVlLm5hbWUudmFsdWUpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN0YXRlbWVudCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZW1lbnQuaXNTdGF0ZW1lbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlbWVudCA9PT0gdHJlZS5zdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IExhYmVsbGVkU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICB2YXIgUmVuYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVuYW1lKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgIHRoaXMub2xkTmFtZSA9IG9sZE5hbWU7XG4gICAgICB0aGlzLm5ld05hbWUgPSBuZXdOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUmVuYW1lLCB7fSwge30pO1xuICB9KCk7XG4gIGZ1bmN0aW9uIHJlbmFtZUFsbChyZW5hbWVzLCB0cmVlKSB7XG4gICAgcmVuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHJlbmFtZSkge1xuICAgICAgdHJlZSA9IEFscGhhUmVuYW1lci5yZW5hbWUodHJlZSwgcmVuYW1lLm9sZE5hbWUsIHJlbmFtZS5uZXdOYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfVxuICB2YXIgRmluZEJsb2NrQmluZGluZ0luTG9vcCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRmluZEJsb2NrQmluZGluZ0luTG9vcCh0cmVlLCBzY29wZUJ1aWxkZXIpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEZpbmRCbG9ja0JpbmRpbmdJbkxvb3ApLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNjb3BlQnVpbGRlcl8gPSBzY29wZUJ1aWxkZXI7XG4gICAgICB0aGlzLnRvcFNjb3BlXyA9IHNjb3BlQnVpbGRlci5nZXRTY29wZUZvclRyZWUodHJlZSkgfHwgc2NvcGVCdWlsZGVyLmdldFNjb3BlRm9yVHJlZSh0cmVlLmJvZHkpO1xuICAgICAgdGhpcy5vdXRPZlNjb3BlXyA9IG51bGw7XG4gICAgICB0aGlzLmFjY2VwdExvb3BfID0gdHJlZS5pc0l0ZXJhdGlvblN0YXRlbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRmluZEJsb2NrQmluZGluZ0luTG9vcCwge1xuICAgICAgdmlzaXRGb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlzaXRMb29wXyh0cmVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KCRfXzMsIEZpbmRCbG9ja0JpbmRpbmdJbkxvb3AucHJvdG90eXBlLCBcInZpc2l0Rm9ySW5TdGF0ZW1lbnRcIikuY2FsbCgkX18zLCB0cmVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpc2l0TG9vcF8odHJlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18zLCBGaW5kQmxvY2tCaW5kaW5nSW5Mb29wLnByb3RvdHlwZSwgXCJ2aXNpdEZvclN0YXRlbWVudFwiKS5jYWxsKCRfXzMsIHRyZWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18zID0gdGhpcztcbiAgICAgICAgdGhpcy52aXNpdExvb3BfKHRyZWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQoJF9fMywgRmluZEJsb2NrQmluZGluZ0luTG9vcC5wcm90b3R5cGUsIFwidmlzaXRXaGlsZVN0YXRlbWVudFwiKS5jYWxsKCRfXzMsIHRyZWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpc2l0TG9vcF8odHJlZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18zLCBGaW5kQmxvY2tCaW5kaW5nSW5Mb29wLnByb3RvdHlwZSwgXCJ2aXNpdERvV2hpbGVTdGF0ZW1lbnRcIikuY2FsbCgkX18zLCB0cmVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRMb29wXzogZnVuY3Rpb24odHJlZSwgZnVuYykge1xuICAgICAgICBpZiAodGhpcy5hY2NlcHRMb29wXykge1xuICAgICAgICAgIHRoaXMuYWNjZXB0TG9vcF8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vdXRPZlNjb3BlXykge1xuICAgICAgICAgIHRoaXMub3V0T2ZTY29wZV8gPSB0aGlzLnNjb3BlQnVpbGRlcl8uZ2V0U2NvcGVGb3JUcmVlKHRyZWUpIHx8IHRoaXMuc2NvcGVCdWlsZGVyXy5nZXRTY29wZUZvclRyZWUodHJlZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jKCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJvd0Z1bmN0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZvdW5kID0gbmV3IEZpbmRJZGVudGlmaWVycyh0cmVlLCBmdW5jdGlvbihpZGVudGlmaWVyVG9rZW4sIGlkZW50U2NvcGUpIHtcbiAgICAgICAgICBpZGVudFNjb3BlID0gJF9fMy5zY29wZUJ1aWxkZXJfLmdldFNjb3BlRm9yVHJlZShpZGVudFNjb3BlKTtcbiAgICAgICAgICB2YXIgZm5TY29wZSA9ICRfXzMub3V0T2ZTY29wZV8gfHwgJF9fMy5zY29wZUJ1aWxkZXJfLmdldFNjb3BlRm9yVHJlZSh0cmVlKTtcbiAgICAgICAgICBpZiAoaWRlbnRTY29wZS5oYXNMZXhpY2FsQmluZGluZ05hbWUoaWRlbnRpZmllclRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoaWRlbnRTY29wZSAhPT0gZm5TY29wZSAmJiAoaWRlbnRTY29wZSA9IGlkZW50U2NvcGUucGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGlkZW50U2NvcGUuaGFzTGV4aWNhbEJpbmRpbmdOYW1lKGlkZW50aWZpZXJUb2tlbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoZm5TY29wZSA9IGZuU2NvcGUucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoZm5TY29wZS5oYXNMZXhpY2FsQmluZGluZ05hbWUoaWRlbnRpZmllclRva2VuKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmblNjb3BlLmhhc1ZhcmlhYmxlQmluZGluZ05hbWUoaWRlbnRpZmllclRva2VuKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm5TY29wZSA9PT0gJF9fMy50b3BTY29wZV8pXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLmZvdW5kO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oRmluZFZpc2l0b3IpO1xuICByZXR1cm4ge2dldCBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBCbG9ja0JpbmRpbmdUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NYWtlU3RyaWN0VHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NYWtlU3RyaWN0VHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01ha2VTdHJpY3RUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBGdW5jdGlvbkJvZHkgPSAkX18xLkZ1bmN0aW9uQm9keSxcbiAgICAgIFNjcmlwdCA9ICRfXzEuU2NyaXB0O1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWFrZVN0cmljdFRyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIGNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01ha2VTdHJpY3RUcmFuc2Zvcm1lci5qc1wiKSkuY3JlYXRlVXNlU3RyaWN0RGlyZWN0aXZlO1xuICB2YXIgaGFzVXNlU3RyaWN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy91dGlsLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NYWtlU3RyaWN0VHJhbnNmb3JtZXIuanNcIikpLmhhc1VzZVN0cmljdDtcbiAgZnVuY3Rpb24gcHJlcGVuZChzdGF0ZW1lbnRzKSB7XG4gICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW2NyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSgpXSwgc3RhdGVtZW50cyk7XG4gIH1cbiAgdmFyIE1ha2VTdHJpY3RUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTWFrZVN0cmljdFRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTWFrZVN0cmljdFRyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTWFrZVN0cmljdFRyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1TY3JpcHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKGhhc1VzZVN0cmljdCh0cmVlLnNjcmlwdEl0ZW1MaXN0KSlcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY3JpcHQodHJlZS5sb2NhdGlvbiwgcHJlcGVuZCh0cmVlLnNjcmlwdEl0ZW1MaXN0KSwgdHJlZS5tb2R1bGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkJvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKGhhc1VzZVN0cmljdCh0cmVlLnN0YXRlbWVudHMpKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQm9keSh0cmVlLmxvY2F0aW9uLCBwcmVwZW5kKHRyZWUuc3RhdGVtZW50cykpO1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm1UcmVlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFrZVN0cmljdFRyYW5zZm9ybWVyKCkudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgfX0sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IE1ha2VTdHJpY3RUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBNYWtlU3RyaWN0VHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xhc3NUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIENPTlNUUlVDVE9SID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xhc3NUcmFuc2Zvcm1lci5qc1wiKSkuQ09OU1RSVUNUT1I7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbGFzc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFub25CbG9jayA9ICRfXzMuQW5vbkJsb2NrLFxuICAgICAgQ2xhc3NFeHByZXNzaW9uID0gJF9fMy5DbGFzc0V4cHJlc3Npb24sXG4gICAgICBFeHBvcnREZWNsYXJhdGlvbiA9ICRfXzMuRXhwb3J0RGVjbGFyYXRpb24sXG4gICAgICBFeHBvcnRTcGVjaWZpZXIgPSAkX18zLkV4cG9ydFNwZWNpZmllcixcbiAgICAgIEV4cG9ydFNwZWNpZmllclNldCA9ICRfXzMuRXhwb3J0U3BlY2lmaWVyU2V0LFxuICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbiA9ICRfXzMuRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICRfXzMuRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgR2V0QWNjZXNzb3IgPSAkX18zLkdldEFjY2Vzc29yLFxuICAgICAgTWV0aG9kID0gJF9fMy5NZXRob2QsXG4gICAgICBOYW1lZEV4cG9ydCA9ICRfXzMuTmFtZWRFeHBvcnQsXG4gICAgICBTZXRBY2Nlc3NvciA9ICRfXzMuU2V0QWNjZXNzb3I7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbGFzc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIENMQVNTX0RFQ0xBUkFUSU9OID0gJF9fNC5DTEFTU19ERUNMQVJBVElPTixcbiAgICAgIENPTVBVVEVEX1BST1BFUlRZX05BTUUgPSAkX180LkNPTVBVVEVEX1BST1BFUlRZX05BTUUsXG4gICAgICBFWFBPUlRfREVGQVVMVCA9ICRfXzQuRVhQT1JUX0RFRkFVTFQsXG4gICAgICBHRVRfQUNDRVNTT1IgPSAkX180LkdFVF9BQ0NFU1NPUixcbiAgICAgIExJVEVSQUxfUFJPUEVSVFlfTkFNRSA9ICRfXzQuTElURVJBTF9QUk9QRVJUWV9OQU1FLFxuICAgICAgTUVUSE9EID0gJF9fNC5NRVRIT0QsXG4gICAgICBTRVRfQUNDRVNTT1IgPSAkX180LlNFVF9BQ0NFU1NPUjtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xhc3NUcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgJF9fNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbGFzc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIENPTlNUID0gJF9fNi5DT05TVCxcbiAgICAgIExFVCA9ICRfXzYuTEVULFxuICAgICAgVkFSID0gJF9fNi5WQVIsXG4gICAgICBTVFJJTkcgPSAkX182LlNUUklORztcbiAgdmFyIE1ha2VTdHJpY3RUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL01ha2VTdHJpY3RUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xhc3NUcmFuc2Zvcm1lci5qc1wiKSkuTWFrZVN0cmljdFRyYW5zZm9ybWVyO1xuICB2YXIgUGFyZW5UcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcmVuVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIikpLlBhcmVuVHJhaXQ7XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQmluZGluZ0lkZW50aWZpZXIgPSAkX18xMC5jcmVhdGVCaW5kaW5nSWRlbnRpZmllcixcbiAgICAgIGlkID0gJF9fMTAuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyVG9rZW4gPSAkX18xMC5jcmVhdGVJZGVudGlmaWVyVG9rZW4sXG4gICAgICBjcmVhdGVPYmplY3RMaXRlcmFsID0gJF9fMTAuY3JlYXRlT2JqZWN0TGl0ZXJhbCxcbiAgICAgIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMTAuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQ7XG4gIHZhciBoYXNVc2VTdHJpY3QgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc2VtYW50aWNzL3V0aWwuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIikpLmhhc1VzZVN0cmljdDtcbiAgdmFyICRfXzEyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NsYXNzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgcGFyc2VFeHByZXNzaW9uID0gJF9fMTIucGFyc2VFeHByZXNzaW9uLFxuICAgICAgcGFyc2VQcm9wZXJ0eURlZmluaXRpb24gPSAkX18xMi5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fMTIucGFyc2VTdGF0ZW1lbnQ7XG4gIGZ1bmN0aW9uIG1ldGhvZE5hbWVGcm9tVHJlZSh0cmVlKSB7XG4gICAgaWYgKHRyZWUudHlwZSA9PT0gQ09NUFVURURfUFJPUEVSVFlfTkFNRSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHJlZS5saXRlcmFsVG9rZW4gJiYgdHJlZS5saXRlcmFsVG9rZW4udHlwZSA9PT0gU1RSSU5HKSB7XG4gICAgICByZXR1cm4gdHJlZS5nZXRTdHJpbmdWYWx1ZSgpLnN1YnN0cigxLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLmdldFN0cmluZ1ZhbHVlKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NNZXRob2REZWJ1Z05hbWUoY2xhc3NOYW1lLCBtZXRob2ROYW1lLCBpc1N0YXRpYykge1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKCckX18nICsgY2xhc3NOYW1lICsgJ18nICsgbWV0aG9kTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcignJF9fJyArIGNsYXNzTmFtZSArICdfcHJvdG90eXBlXycgKyBtZXRob2ROYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbkV4cHJlc3Npb25Ub0RlY2xhcmF0aW9uKHRyZWUsIG5hbWUpIHtcbiAgICBpZiAodHJlZS5uYW1lID09PSBudWxsKSB7XG4gICAgICBuYW1lID0gY3JlYXRlQmluZGluZ0lkZW50aWZpZXIobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSB0cmVlLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBuYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCB0cmVlLmFubm90YXRpb25zLCB0cmVlLmJvZHkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVN0YXRpY01vZGlmaWVyKHRyZWUpIHtcbiAgICBzd2l0Y2ggKHRyZWUudHlwZSkge1xuICAgICAgY2FzZSBHRVRfQUNDRVNTT1I6XG4gICAgICAgIHJldHVybiBuZXcgR2V0QWNjZXNzb3IodHJlZS5sb2NhdGlvbiwgZmFsc2UsIHRyZWUubmFtZSwgdHJlZS50eXBlQW5ub3RhdGlvbiwgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS5ib2R5KTtcbiAgICAgIGNhc2UgU0VUX0FDQ0VTU09SOlxuICAgICAgICByZXR1cm4gbmV3IFNldEFjY2Vzc29yKHRyZWUubG9jYXRpb24sIGZhbHNlLCB0cmVlLm5hbWUsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS5ib2R5KTtcbiAgICAgIGNhc2UgTUVUSE9EOlxuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZCh0cmVlLmxvY2F0aW9uLCBmYWxzZSwgdHJlZS5mdW5jdGlvbktpbmQsIHRyZWUubmFtZSwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCB0cmVlLmFubm90YXRpb25zLCB0cmVlLmJvZHksIHRyZWUuZGVidWdOYW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcih0cmVlKSB7XG4gICAgaWYgKHRyZWUudHlwZSAhPT0gTUVUSE9EIHx8IHRyZWUuaXNTdGF0aWMgfHwgdHJlZS5mdW5jdGlvbktpbmQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0cmVlLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FICYmIG5hbWUubGl0ZXJhbFRva2VuLnZhbHVlID09PSBDT05TVFJVQ1RPUjtcbiAgfVxuICB2YXIgQ2xhc3NUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ2xhc3NUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCBpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnN0cmljdENvdW50XyA9IDA7XG4gICAgICB0aGlzLnN0YXRlXyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDbGFzc1RyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1Nb2R1bGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5zdHJpY3RDb3VudF8gPSAxO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENsYXNzVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybU1vZHVsZVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnN0cmljdENvdW50XyA9IGhhc1VzZVN0cmljdCh0cmVlLnNjcmlwdEl0ZW1MaXN0KSA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENsYXNzVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVNjcmlwdFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdXNlU3RyaWN0ID0gaGFzVXNlU3RyaWN0KHRyZWUuc3RhdGVtZW50cykgPyAxIDogMDtcbiAgICAgICAgdGhpcy5zdHJpY3RDb3VudF8gKz0gdXNlU3RyaWN0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENsYXNzVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uQm9keVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLnN0cmljdENvdW50XyAtPSB1c2VTdHJpY3Q7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgbWFrZVN0cmljdF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaWN0Q291bnRfKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4gTWFrZVN0cmljdFRyYW5zZm9ybWVyLnRyYW5zZm9ybVRyZWUodHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgY2xhc3NFeHByZXNzaW9uID0gbmV3IENsYXNzRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuc3VwZXJDbGFzcywgdHJlZS5lbGVtZW50cywgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uKGNsYXNzRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciB1c2VMZXQgPSAhdGhpcy5vcHRpb25zLnRyYW5zZm9ybU9wdGlvbnMuYmxvY2tCaW5kaW5nICYmIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMuYmxvY2tCaW5kaW5nO1xuICAgICAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQodXNlTGV0ID8gTEVUIDogVkFSLCB0cmVlLm5hbWUsIHRyYW5zZm9ybWVkKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdmFyIHByb3RvRWxlbWVudHMgPSBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIGlmICh0cmVlLmlzU3RhdGljKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yKHRyZWUpKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRyZWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0YXRpY0VsZW1lbnRzID0gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZS5pc1N0YXRpYztcbiAgICAgICAgfSkubWFwKHJlbW92ZVN0YXRpY01vZGlmaWVyKTtcbiAgICAgICAgdmFyIHByb3RvT2JqZWN0ID0gY3JlYXRlT2JqZWN0TGl0ZXJhbChwcm90b0VsZW1lbnRzKTtcbiAgICAgICAgdmFyIHN0YXRpY09iamVjdCA9IGNyZWF0ZU9iamVjdExpdGVyYWwoc3RhdGljRWxlbWVudHMpO1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmdldERlZmF1bHRDb25zdHJ1Y3Rvcl8odHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgbnVsbCwgY29uc3RydWN0b3IucGFyYW1ldGVyTGlzdCwgbnVsbCwgYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yLmJvZHkpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIGNyZWF0ZUNsYXNzID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignY3JlYXRlQ2xhc3MnKTtcbiAgICAgICAgaWYgKHRyZWUubmFtZSkge1xuICAgICAgICAgIHZhciBmdW5jdGlvblN0YXRlbWVudDtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW47XG4gICAgICAgICAgdmFyIG5hbWVJZCA9IGlkKChcIlwiICsgbmFtZSkpO1xuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnRyYW5zZm9ybU9wdGlvbnMuYmxvY2tCaW5kaW5nICYmIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMuYmxvY2tCaW5kaW5nKSB7XG4gICAgICAgICAgICBmdW5jdGlvblN0YXRlbWVudCA9IGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KENPTlNULCB0cmVlLm5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uRXhwcmVzc2lvblRvRGVjbGFyYXRpb24oZnVuYywgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJmdW5jdGlvbigkX19zdXBlcikge1xcbiAgICAgICAgICBcIiwgXCI7XFxuICAgICAgICAgIHJldHVybiAoXCIsIFwiKShcIiwgXCIsIFwiLCBcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIFwiLCAkX19zdXBlcik7XFxuICAgICAgICB9KFwiLCBcIilcIl0pLCBmdW5jdGlvblN0YXRlbWVudCwgY3JlYXRlQ2xhc3MsIG5hbWVJZCwgcHJvdG9PYmplY3QsIHN0YXRpY09iamVjdCwgc3VwZXJDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBcIiwgXCI7XFxuICAgICAgICAgIHJldHVybiAoXCIsIFwiKShcIiwgXCIsIFwiLCBcIiwgXCIsIFwiKTtcXG4gICAgICAgIH0oKVwiXSksIGZ1bmN0aW9uU3RhdGVtZW50LCBjcmVhdGVDbGFzcywgbmFtZUlkLCBwcm90b09iamVjdCwgc3RhdGljT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIihcIiwgXCIpKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIilcIl0pLCBjcmVhdGVDbGFzcywgZnVuYywgcHJvdG9PYmplY3QsIHN0YXRpY09iamVjdCwgc3VwZXJDbGFzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIihcIiwgXCIpKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIpXCJdKSwgY3JlYXRlQ2xhc3MsIGZ1bmMsIHByb3RvT2JqZWN0LCBzdGF0aWNPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU3RyaWN0XyhleHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5kZWNsYXJhdGlvbi50eXBlID09PSBFWFBPUlRfREVGQVVMVCAmJiB0cmVlLmRlY2xhcmF0aW9uLmV4cHJlc3Npb24udHlwZSA9PT0gQ0xBU1NfREVDTEFSQVRJT04pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHBvcnREZWZhdWx0Q2xhc3NfKHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ2xhc3NUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWZhdWx0Q2xhc3NfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdHJlZS5leHByZXNzaW9uLm5hbWUuaWRlbnRpZmllclRva2VuO1xuICAgICAgICB2YXIgc3BlY2lmaWVyID0gbmV3IEV4cG9ydFNwZWNpZmllcihuYW1lLmxvY2F0aW9uLCBuYW1lLCBjcmVhdGVJZGVudGlmaWVyVG9rZW4oJ2RlZmF1bHQnKSk7XG4gICAgICAgIHZhciBleHBvcnRUcmVlID0gbmV3IEV4cG9ydFNwZWNpZmllclNldChuYW1lLmxvY2F0aW9uLCBbc3BlY2lmaWVyXSk7XG4gICAgICAgIHZhciBuYW1lZCA9IG5ldyBOYW1lZEV4cG9ydChuYW1lLmxvY2F0aW9uLCBleHBvcnRUcmVlLCBudWxsKTtcbiAgICAgICAgdmFyIGV4cCA9IG5ldyBFeHBvcnREZWNsYXJhdGlvbihuYW1lLmxvY2F0aW9uLCBuYW1lZCwgW10pO1xuICAgICAgICB2YXIgY2xhc3NUcmVlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW2NsYXNzVHJlZSwgZXhwXSk7XG4gICAgICB9LFxuICAgICAgZ2V0RGVmYXVsdENvbnN0cnVjdG9yXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBpZCh0cmVlLm5hbWUuaWRlbnRpZmllclRva2VuKTtcbiAgICAgICAgICB2YXIgc3VwZXJDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ3N1cGVyQ29uc3RydWN0b3InKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VQcm9wZXJ0eURlZmluaXRpb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImNvbnN0cnVjdG9yKCkge1xcbiAgICAgICAgXCIsIFwiKFwiLCBcIikuYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbiAgICAgIH1cIl0pLCBzdXBlckNvbnN0cnVjdG9yLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VQcm9wZXJ0eURlZmluaXRpb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImNvbnN0cnVjdG9yKCkge31cIl0pKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChQYXJlblRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpKTtcbiAgcmV0dXJuIHtnZXQgQ2xhc3NUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBDbGFzc1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Nsb3N1cmVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Nsb3N1cmVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgTW9kdWxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xvc3VyZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5Nb2R1bGVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX180LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzQuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVByb3BlcnR5TmFtZUFzc2lnbm1lbnQgPSAkX180LmNyZWF0ZVByb3BlcnR5TmFtZUFzc2lnbm1lbnQ7XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRVhQT1JUX0RFRkFVTFQgPSAkX181LkVYUE9SVF9ERUZBVUxULFxuICAgICAgRVhQT1JUX1NQRUNJRklFUiA9ICRfXzUuRVhQT1JUX1NQRUNJRklFUjtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xvc3VyZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbiA9ICRfXzYucGFyc2VFeHByZXNzaW9uLFxuICAgICAgcGFyc2VTdGF0ZW1lbnQgPSAkX182LnBhcnNlU3RhdGVtZW50LFxuICAgICAgcGFyc2VTdGF0ZW1lbnRzID0gJF9fNi5wYXJzZVN0YXRlbWVudHM7XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICB2YXIgQ2xvc3VyZU1vZHVsZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIsIHtcbiAgICAgIG1vZHVsZVByb2xvZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2R1bGVOYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zdXJlIG1vZHVsZXMgKGdvb2cubW9kdWxlKSByZXF1aXJlIGEgbW9kdWxlTmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImdvb2cubW9kdWxlKFwiLCBcIik7XCJdKSwgdGhpcy5tb2R1bGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICB3cmFwTW9kdWxlOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1N0YXJFeHBvcnRzKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3N1cmUgbW9kdWxlcyAoZ29vZy5tb2R1bGUpIGRvIG5vdCBzdXBwb3J0IFwiZXhwb3J0ICpcIicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGFkZEV4cG9ydFN0YXRlbWVudDogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXhwb3J0cygpKVxuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICB2YXIgZXhwb3J0T2JqZWN0ID0gdGhpcy5nZXRFeHBvcnRPYmplY3QoKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJleHBvcnRzID0gXCIsIFwiXCJdKSwgZXhwb3J0T2JqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGdldEdldHRlckV4cG9ydDogZnVuY3Rpb24oJF9fMSkge1xuICAgICAgICB2YXIgJF9fMiA9ICRfXzEsXG4gICAgICAgICAgICBuYW1lID0gJF9fMi5uYW1lLFxuICAgICAgICAgICAgdHJlZSA9ICRfXzIudHJlZSxcbiAgICAgICAgICAgIG1vZHVsZVNwZWNpZmllciA9ICRfXzIubW9kdWxlU3BlY2lmaWVyO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgc3dpdGNoICh0cmVlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEVYUE9SVF9ERUZBVUxUOlxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKCckX19kZWZhdWx0Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYUE9SVF9TUEVDSUZJRVI6XG4gICAgICAgICAgICBpZiAobW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgIHZhciBpZE5hbWUgPSB0aGlzLmdldFRlbXBWYXJOYW1lRm9yTW9kdWxlU3BlY2lmaWVyKG1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGlkTmFtZSwgdHJlZS5saHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGNyZWF0ZVByb3BlcnR5TmFtZUFzc2lnbm1lbnQobmFtZSwgdHJlZS5saHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihuYW1lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KG5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IHRyZWUudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImdvb2cucmVxdWlyZShcIiwgXCIpXCJdKSwgbW9kdWxlTmFtZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShNb2R1bGVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IENsb3N1cmVNb2R1bGVUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBDbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tbW9uSnNNb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIE1vZHVsZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTW9kdWxlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLk1vZHVsZVRyYW5zZm9ybWVyO1xuICB2YXIgTkFNRURfRVhQT1JUID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Db21tb25Kc01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5OQU1FRF9FWFBPUlQ7XG4gIHZhciBBbm9uQmxvY2sgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLkFub25CbG9jaztcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tbW9uSnNNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX182LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uID0gJF9fNi5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fNi5wYXJzZVN0YXRlbWVudDtcbiAgdmFyICRfXzcgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Db21tb25Kc01vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX183LmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVPYmplY3RMaXRlcmFsID0gJF9fNy5jcmVhdGVPYmplY3RMaXRlcmFsLFxuICAgICAgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3IgPSAkX183LmNyZWF0ZU9iamVjdExpdGVyYWxGb3JEZXNjcmlwdG9yLFxuICAgICAgY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudCA9ICRfXzcuY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudDtcbiAgdmFyIHByZXBlbmRTdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUHJlcGVuZFN0YXRlbWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0NvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICB2YXIgRmluZFZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ29tbW9uSnNNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuRmluZFZpc2l0b3I7XG4gIHZhciBDb21tb25Kc01vZHVsZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb21tb25Kc01vZHVsZVRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hbm9ueW1vdXNNb2R1bGUgPSBvcHRpb25zICYmICFvcHRpb25zLmJ1bmRsZSAmJiBvcHRpb25zLm1vZHVsZU5hbWUgIT09IHRydWU7XG4gICAgICB0aGlzLm5hbWVkRXhwb3J0c1dpdGhNb2R1bGVTcGVjaWZpZXJzXyA9IFtdO1xuICAgICAgdGhpcy5pc0ltcG9ydGluZ0RlZmF1bHRfID0gZmFsc2U7XG4gICAgICB0aGlzLm5lZWRzSW50ZXJvcFJlcXVpcmVfID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb21tb25Kc01vZHVsZVRyYW5zZm9ybWVyLCB7XG4gICAgICBnZXRNb2R1bGVOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFub255bW91c01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyZWUubW9kdWxlTmFtZTtcbiAgICAgIH0sXG4gICAgICB3cmFwTW9kdWxlOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzSW50ZXJvcFJlcXVpcmVfKSB7XG4gICAgICAgICAgdmFyIHJlcSA9IHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJmdW5jdGlvbiAkX19pbnRlcm9wUmVxdWlyZShpZCkge1xcbiAgICAgICAgaWQgPSByZXF1aXJlKGlkKTtcXG4gICAgICAgIHJldHVybiBpZCAmJiBpZC5fX2VzTW9kdWxlICYmIGlkIHx8IHtkZWZhdWx0OiBpZH07XFxuICAgICAgfVwiXSkpO1xuICAgICAgICAgIHJldHVybiBwcmVwZW5kU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCByZXEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGFkZEV4cG9ydFN0YXRlbWVudDogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXhwb3J0cygpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc2NyID0gdGhpcy5nZXRFeHBvcnREZXNjcmlwdG9ycygpO1xuICAgICAgICB2YXIgZXhwb3J0T2JqZWN0ID0gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtb2R1bGUuZXhwb3J0cywgXCIsIFwiKVwiXSksIGRlc2NyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhckV4cG9ydHMoKSkge1xuICAgICAgICAgIGV4cG9ydE9iamVjdCA9IHRoaXMuZ2V0RXhwb3J0U3RhcihleHBvcnRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVwZW5kU3RhdGVtZW50cy5hcHBseSgodm9pZCAwKSwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChbc3RhdGVtZW50c10sIHRoaXMubmFtZWRFeHBvcnRzV2l0aE1vZHVsZVNwZWNpZmllcnNfLCBbY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChleHBvcnRPYmplY3QpXSkpO1xuICAgICAgfSxcbiAgICAgIGdldEV4cG9ydERlc2NyaXB0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZXhwb3J0VmlzaXRvci5nZXROb25UeXBlTmFtZWRFeHBvcnRzKCkubWFwKGZ1bmN0aW9uKGV4cCkge1xuICAgICAgICAgIHZhciBmID0gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJmdW5jdGlvbigpIHsgcmV0dXJuIFwiLCBcIjsgfVwiXSksICRfXzIuZ2V0R2V0dGVyRXhwb3J0UmV0dXJuRXhwcmVzc2lvbihleHApKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudChleHAubmFtZSwgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BlcnRpZXMudW5zaGlmdChwYXJzZVByb3BlcnR5RGVmaW5pdGlvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiX19lc01vZHVsZToge3ZhbHVlOiB0cnVlfVwiXSkpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdExpdGVyYWwocHJvcGVydGllcyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja0ZvckRlZmF1bHRJbXBvcnRfKHRyZWUpO1xuICAgICAgICB0aGlzLmV4cG9ydFZpc2l0b3IudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICBpZiAodHJlZS5kZWNsYXJhdGlvbi50eXBlID09IE5BTUVEX0VYUE9SVCAmJiB0cmVlLmRlY2xhcmF0aW9uLm1vZHVsZVNwZWNpZmllciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubmFtZWRFeHBvcnRzV2l0aE1vZHVsZVNwZWNpZmllcnNfLnB1c2godHJhbnNmb3JtZWQpO1xuICAgICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja0ZvckRlZmF1bHRJbXBvcnRfKHRyZWUpO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUltcG9ydERlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgY2hlY2tGb3JEZWZhdWx0SW1wb3J0XzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZmluZGVyID0gbmV3IEZpbmREZWZhdWx0KCk7XG4gICAgICAgIGZpbmRlci52aXNpdEFueSh0cmVlKTtcbiAgICAgICAgdGhpcy5pc0ltcG9ydGluZ0RlZmF1bHRfID0gZmluZGVyLmZvdW5kO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IHRyZWUudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlzSW1wb3J0aW5nRGVmYXVsdF8pIHtcbiAgICAgICAgICB0aGlzLm5lZWRzSW50ZXJvcFJlcXVpcmVfID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkX19pbnRlcm9wUmVxdWlyZShcIiwgXCIpXCJdKSwgbW9kdWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wicmVxdWlyZShcIiwgXCIpXCJdKSwgbW9kdWxlTmFtZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShNb2R1bGVUcmFuc2Zvcm1lcik7XG4gIHZhciBGaW5kRGVmYXVsdCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRmluZERlZmF1bHQoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5kRGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZpbmREZWZhdWx0LCB7XG4gICAgICB2aXNpdEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJlZS5uYW1lICE9PSBudWxsICYmIHRyZWUubmFtZS52YWx1ZSA9PT0gJ2RlZmF1bHQnO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZVNwYWNlSW1wb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZVNwYWNlRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cmVlLmxocyAhPT0gbnVsbCAmJiB0cmVlLmxocy52YWx1ZSA9PT0gJ2RlZmF1bHQnO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oRmluZFZpc2l0b3IpO1xuICByZXR1cm4ge2dldCBDb21tb25Kc01vZHVsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIENvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgRnVuY3Rpb25Cb2R5ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiKSkuRnVuY3Rpb25Cb2R5O1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgcHJlcGVuZFN0YXRlbWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QcmVwZW5kU3RhdGVtZW50cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIFBhcmFtZXRlclRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQYXJhbWV0ZXJUcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFBhcmFtZXRlclRyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUGFyYW1ldGVyVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUFycm93RnVuY3Rpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgc3RhY2sucHVzaChbXSk7XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGFyYW1ldGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUFycm93RnVuY3Rpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW10pO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcmFtZXRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW10pO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcmFtZXRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1HZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBzdGFjay5wdXNoKFtdKTtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQYXJhbWV0ZXJUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtR2V0QWNjZXNzb3JcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBzdGFjay5wdXNoKFtdKTtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQYXJhbWV0ZXJUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtU2V0QWNjZXNzb3JcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgc3RhY2sucHVzaChbXSk7XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGFyYW1ldGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybU1ldGhvZFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtZWRUcmVlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcmFtZXRlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkJvZHlcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFzdGF0ZW1lbnRzLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRUcmVlO1xuICAgICAgICBzdGF0ZW1lbnRzID0gcHJlcGVuZFN0YXRlbWVudHMuYXBwbHkoKHZvaWQgMCksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RyYW5zZm9ybWVkVHJlZS5zdGF0ZW1lbnRzXSwgc3RhdGVtZW50cykpO1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQm9keSh0cmFuc2Zvcm1lZFRyZWUubG9jYXRpb24sIHN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIGdldCBwYXJhbWV0ZXJTdGF0ZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29uc3RydWN0b3JUeXBlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uVHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRlbXBWYXJUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IFBhcmFtZXRlclRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFBhcmFtZXRlclRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0RlZmF1bHRQYXJhbWV0ZXJzVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy91dGlsLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGlzVW5kZWZpbmVkID0gJF9fMS5pc1VuZGVmaW5lZCxcbiAgICAgIGlzVm9pZEV4cHJlc3Npb24gPSAkX18xLmlzVm9pZEV4cHJlc3Npb247XG4gIHZhciBGb3JtYWxQYXJhbWV0ZXJMaXN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyLmpzXCIpKS5Gb3JtYWxQYXJhbWV0ZXJMaXN0O1xuICB2YXIgUGFyYW1ldGVyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRGVmYXVsdFBhcmFtZXRlcnNUcmFuc2Zvcm1lci5qc1wiKSkuUGFyYW1ldGVyVHJhbnNmb3JtZXI7XG4gIHZhciBBUkdVTUVOVFMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyLmpzXCIpKS5BUkdVTUVOVFM7XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0RlZmF1bHRQYXJhbWV0ZXJzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgTk9UX0VRVUFMX0VRVUFMID0gJF9fNS5OT1RfRVFVQUxfRVFVQUwsXG4gICAgICBWQVIgPSAkX181LlZBUjtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9EZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24gPSAkX182LmNyZWF0ZUJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24gPSAkX182LmNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uID0gJF9fNi5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU1lbWJlckxvb2t1cEV4cHJlc3Npb24gPSAkX182LmNyZWF0ZU1lbWJlckxvb2t1cEV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdW1iZXJMaXRlcmFsID0gJF9fNi5jcmVhdGVOdW1iZXJMaXRlcmFsLFxuICAgICAgY3JlYXRlT3BlcmF0b3JUb2tlbiA9ICRfXzYuY3JlYXRlT3BlcmF0b3JUb2tlbixcbiAgICAgIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50ID0gJF9fNi5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZVZvaWQwID0gJF9fNi5jcmVhdGVWb2lkMDtcbiAgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdEFzc2lnbm1lbnQoaW5kZXgsIGJpbmRpbmcsIGluaXRpYWxpemVyKSB7XG4gICAgdmFyIGFyZ3VtZW50c0V4cHJlc3Npb24gPSBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uKGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKEFSR1VNRU5UUyksIGNyZWF0ZU51bWJlckxpdGVyYWwoaW5kZXgpKTtcbiAgICB2YXIgYXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgaWYgKGluaXRpYWxpemVyID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKGluaXRpYWxpemVyKSB8fCBpc1ZvaWRFeHByZXNzaW9uKGluaXRpYWxpemVyKSkge1xuICAgICAgYXNzaWdubWVudEV4cHJlc3Npb24gPSBhcmd1bWVudHNFeHByZXNzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbihjcmVhdGVCaW5hcnlFeHByZXNzaW9uKGFyZ3VtZW50c0V4cHJlc3Npb24sIGNyZWF0ZU9wZXJhdG9yVG9rZW4oTk9UX0VRVUFMX0VRVUFMKSwgY3JlYXRlVm9pZDAoKSksIGFyZ3VtZW50c0V4cHJlc3Npb24sIGluaXRpYWxpemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFZBUiwgYmluZGluZywgYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICB9XG4gIHZhciBEZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRGVmYXVsdFBhcmFtZXRlcnNUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKERlZmF1bHRQYXJhbWV0ZXJzVHJhbnNmb3JtZXIsIHt0cmFuc2Zvcm1Gb3JtYWxQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWZhdWx0VG9VbmRlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnBhcmFtZXRlcnNbaV0pO1xuICAgICAgICAgIGlmIChwYXJhbSAhPT0gdHJlZS5wYXJhbWV0ZXJzW2ldKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHBhcmFtLmlzUmVzdFBhcmFtZXRlcigpIHx8ICFwYXJhbS5wYXJhbWV0ZXIuaW5pdGlhbGl6ZXIgJiYgIWRlZmF1bHRUb1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFRvVW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJhbWV0ZXJTdGF0ZW1lbnRzLnB1c2goY3JlYXRlRGVmYXVsdEFzc2lnbm1lbnQoaSwgcGFyYW0ucGFyYW1ldGVyLmJpbmRpbmcsIHBhcmFtLnBhcmFtZXRlci5pbml0aWFsaXplcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYW5nZWQpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWFsUGFyYW1ldGVyTGlzdCh0cmVlLmxvY2F0aW9uLCBwYXJhbWV0ZXJzKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcmFtZXRlclRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgRGVmYXVsdFBhcmFtZXRlcnNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0UGFyYW1ldGVyc1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2Fzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9hc3NpZ25tZW50T3BlcmF0b3JUb0JpbmFyeU9wZXJhdG9yLmpzXCI7XG4gIHZhciAkX18wID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2Fzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3IuanNcIikpLFxuICAgICAgQU1QRVJTQU5EID0gJF9fMC5BTVBFUlNBTkQsXG4gICAgICBBTVBFUlNBTkRfRVFVQUwgPSAkX18wLkFNUEVSU0FORF9FUVVBTCxcbiAgICAgIEJBUiA9ICRfXzAuQkFSLFxuICAgICAgQkFSX0VRVUFMID0gJF9fMC5CQVJfRVFVQUwsXG4gICAgICBDQVJFVCA9ICRfXzAuQ0FSRVQsXG4gICAgICBDQVJFVF9FUVVBTCA9ICRfXzAuQ0FSRVRfRVFVQUwsXG4gICAgICBMRUZUX1NISUZUID0gJF9fMC5MRUZUX1NISUZULFxuICAgICAgTEVGVF9TSElGVF9FUVVBTCA9ICRfXzAuTEVGVF9TSElGVF9FUVVBTCxcbiAgICAgIE1JTlVTID0gJF9fMC5NSU5VUyxcbiAgICAgIE1JTlVTX0VRVUFMID0gJF9fMC5NSU5VU19FUVVBTCxcbiAgICAgIFBFUkNFTlQgPSAkX18wLlBFUkNFTlQsXG4gICAgICBQRVJDRU5UX0VRVUFMID0gJF9fMC5QRVJDRU5UX0VRVUFMLFxuICAgICAgUExVUyA9ICRfXzAuUExVUyxcbiAgICAgIFBMVVNfRVFVQUwgPSAkX18wLlBMVVNfRVFVQUwsXG4gICAgICBSSUdIVF9TSElGVCA9ICRfXzAuUklHSFRfU0hJRlQsXG4gICAgICBSSUdIVF9TSElGVF9FUVVBTCA9ICRfXzAuUklHSFRfU0hJRlRfRVFVQUwsXG4gICAgICBTTEFTSCA9ICRfXzAuU0xBU0gsXG4gICAgICBTTEFTSF9FUVVBTCA9ICRfXzAuU0xBU0hfRVFVQUwsXG4gICAgICBTVEFSID0gJF9fMC5TVEFSLFxuICAgICAgU1RBUl9FUVVBTCA9ICRfXzAuU1RBUl9FUVVBTCxcbiAgICAgIFNUQVJfU1RBUiA9ICRfXzAuU1RBUl9TVEFSLFxuICAgICAgU1RBUl9TVEFSX0VRVUFMID0gJF9fMC5TVEFSX1NUQVJfRVFVQUwsXG4gICAgICBVTlNJR05FRF9SSUdIVF9TSElGVCA9ICRfXzAuVU5TSUdORURfUklHSFRfU0hJRlQsXG4gICAgICBVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTCA9ICRfXzAuVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUw7XG4gIGZ1bmN0aW9uIGFzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3IodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBTVEFSX0VRVUFMOlxuICAgICAgICByZXR1cm4gU1RBUjtcbiAgICAgIGNhc2UgU1RBUl9TVEFSX0VRVUFMOlxuICAgICAgICByZXR1cm4gU1RBUl9TVEFSO1xuICAgICAgY2FzZSBTTEFTSF9FUVVBTDpcbiAgICAgICAgcmV0dXJuIFNMQVNIO1xuICAgICAgY2FzZSBQRVJDRU5UX0VRVUFMOlxuICAgICAgICByZXR1cm4gUEVSQ0VOVDtcbiAgICAgIGNhc2UgUExVU19FUVVBTDpcbiAgICAgICAgcmV0dXJuIFBMVVM7XG4gICAgICBjYXNlIE1JTlVTX0VRVUFMOlxuICAgICAgICByZXR1cm4gTUlOVVM7XG4gICAgICBjYXNlIExFRlRfU0hJRlRfRVFVQUw6XG4gICAgICAgIHJldHVybiBMRUZUX1NISUZUO1xuICAgICAgY2FzZSBSSUdIVF9TSElGVF9FUVVBTDpcbiAgICAgICAgcmV0dXJuIFJJR0hUX1NISUZUO1xuICAgICAgY2FzZSBVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTDpcbiAgICAgICAgcmV0dXJuIFVOU0lHTkVEX1JJR0hUX1NISUZUO1xuICAgICAgY2FzZSBBTVBFUlNBTkRfRVFVQUw6XG4gICAgICAgIHJldHVybiBBTVBFUlNBTkQ7XG4gICAgICBjYXNlIENBUkVUX0VRVUFMOlxuICAgICAgICByZXR1cm4gQ0FSRVQ7XG4gICAgICBjYXNlIEJBUl9FUVVBTDpcbiAgICAgICAgcmV0dXJuIEJBUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgIH1cbiAgfVxuICB2YXIgJF9fZGVmYXVsdCA9IGFzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3I7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fZGVmYXVsdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX18xMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0V4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24gPSAkX18xMy5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbiA9ICRfXzEzLmNyZWF0ZUNvbW1hRXhwcmVzc2lvbixcbiAgICAgIGlkID0gJF9fMTMuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJFeHByZXNzaW9uID0gJF9fMTMuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU51bWJlckxpdGVyYWwgPSAkX18xMy5jcmVhdGVOdW1iZXJMaXRlcmFsLFxuICAgICAgY3JlYXRlT3BlcmF0b3JUb2tlbiA9ICRfXzEzLmNyZWF0ZU9wZXJhdG9yVG9rZW4sXG4gICAgICBjcmVhdGVQYXJlbkV4cHJlc3Npb24gPSAkX18xMy5jcmVhdGVQYXJlbkV4cHJlc3Npb247XG4gIHZhciAkX18xNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFORCA9ICRfXzE0LkFORCxcbiAgICAgIEVRVUFMID0gJF9fMTQuRVFVQUwsXG4gICAgICBNSU5VUyA9ICRfXzE0Lk1JTlVTLFxuICAgICAgTUlOVVNfRVFVQUwgPSAkX18xNC5NSU5VU19FUVVBTCxcbiAgICAgIE1JTlVTX01JTlVTID0gJF9fMTQuTUlOVVNfTUlOVVMsXG4gICAgICBPUiA9ICRfXzE0Lk9SLFxuICAgICAgUExVUyA9ICRfXzE0LlBMVVMsXG4gICAgICBQTFVTX0VRVUFMID0gJF9fMTQuUExVU19FUVVBTCxcbiAgICAgIFBMVVNfUExVUyA9ICRfXzE0LlBMVVNfUExVUztcbiAgdmFyICRfXzE1ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIENPTU1BX0VYUFJFU1NJT04gPSAkX18xNS5DT01NQV9FWFBSRVNTSU9OLFxuICAgICAgSURFTlRJRklFUl9FWFBSRVNTSU9OID0gJF9fMTUuSURFTlRJRklFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0VYUFJFU1NJT04gPSAkX18xNS5NRU1CRVJfRVhQUkVTU0lPTixcbiAgICAgIE1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTiA9ICRfXzE1Lk1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTixcbiAgICAgIFBST1BFUlRZX05BTUVfQVNTSUdOTUVOVCA9ICRfXzE1LlBST1BFUlRZX05BTUVfQVNTSUdOTUVOVCxcbiAgICAgIFNQUkVBRF9FWFBSRVNTSU9OID0gJF9fMTUuU1BSRUFEX0VYUFJFU1NJT04sXG4gICAgICBURU1QTEFURV9MSVRFUkFMX1BPUlRJT04gPSAkX18xNS5URU1QTEFURV9MSVRFUkFMX1BPUlRJT047XG4gIHZhciAkX18xNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBcmd1bWVudExpc3QgPSAkX18xNi5Bcmd1bWVudExpc3QsXG4gICAgICBBcnJheUxpdGVyYWwgPSAkX18xNi5BcnJheUxpdGVyYWwsXG4gICAgICBBd2FpdEV4cHJlc3Npb24gPSAkX18xNi5Bd2FpdEV4cHJlc3Npb24sXG4gICAgICBCaW5hcnlFeHByZXNzaW9uID0gJF9fMTYuQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgIENhbGxFeHByZXNzaW9uID0gJF9fMTYuQ2FsbEV4cHJlc3Npb24sXG4gICAgICBDbGFzc0V4cHJlc3Npb24gPSAkX18xNi5DbGFzc0V4cHJlc3Npb24sXG4gICAgICBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAkX18xNi5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICBNZW1iZXJFeHByZXNzaW9uID0gJF9fMTYuTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIE1lbWJlckxvb2t1cEV4cHJlc3Npb24gPSAkX18xNi5NZW1iZXJMb29rdXBFeHByZXNzaW9uLFxuICAgICAgTmV3RXhwcmVzc2lvbiA9ICRfXzE2Lk5ld0V4cHJlc3Npb24sXG4gICAgICBPYmplY3RMaXRlcmFsID0gJF9fMTYuT2JqZWN0TGl0ZXJhbCxcbiAgICAgIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQgPSAkX18xNi5Qcm9wZXJ0eU5hbWVBc3NpZ25tZW50LFxuICAgICAgU3ByZWFkRXhwcmVzc2lvbiA9ICRfXzE2LlNwcmVhZEV4cHJlc3Npb24sXG4gICAgICBUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uID0gJF9fMTYuVGVtcGxhdGVMaXRlcmFsRXhwcmVzc2lvbixcbiAgICAgIFRlbXBsYXRlU3Vic3RpdHV0aW9uID0gJF9fMTYuVGVtcGxhdGVTdWJzdGl0dXRpb24sXG4gICAgICBVbmFyeUV4cHJlc3Npb24gPSAkX18xNi5VbmFyeUV4cHJlc3Npb24sXG4gICAgICBZaWVsZEV4cHJlc3Npb24gPSAkX18xNi5ZaWVsZEV4cHJlc3Npb247XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0V4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIikpLmFzc2VydDtcbiAgdmFyIGFzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hc3NpZ25tZW50T3BlcmF0b3JUb0JpbmFyeU9wZXJhdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgQ29tbWFFeHByZXNzaW9uQnVpbGRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIENvbW1hRXhwcmVzc2lvbkJ1aWxkZXIodGVtcFZhcikge1xuICAgICAgdGhpcy50ZW1wVmFyID0gdGVtcFZhcjtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKENvbW1hRXhwcmVzc2lvbkJ1aWxkZXIsIHtcbiAgICAgIGFkZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMjtcbiAgICAgICAgaWYgKHRyZWUudHlwZSA9PT0gQ09NTUFfRVhQUkVTU0lPTilcbiAgICAgICAgICAoJF9fMiA9IHRoaXMuZXhwcmVzc2lvbnMpLnB1c2guYXBwbHkoJF9fMiwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyh0cmVlKSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBidWlsZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdGVtcFZhciA9IHRoaXMudGVtcFZhcjtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRlbXBWYXIsIHRyZWUpLCB0ZW1wVmFyKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbih0aGlzLmV4cHJlc3Npb25zKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgZnVuY3Rpb24gZ2V0UmVzdWx0KHRyZWUpIHtcbiAgICBpZiAodHJlZS50eXBlID09PSBDT01NQV9FWFBSRVNTSU9OKVxuICAgICAgcmV0dXJuIHRyZWUuZXhwcmVzc2lvbnNbdHJlZS5leHByZXNzaW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRFeHByZXNzaW9ucyh0cmVlKSB7XG4gICAgaWYgKHRyZWUudHlwZSA9PT0gQ09NTUFfRVhQUkVTU0lPTilcbiAgICAgIHJldHVybiB0cmVlLmV4cHJlc3Npb25zLnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIodGVtcFZhclRyYW5zZm9ybWVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50ZW1wVmFyVHJhbnNmb3JtZXJfID0gdGVtcFZhclRyYW5zZm9ybWVyO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lciwge1xuICAgICAgYWRkVGVtcFZhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0bXBJZCA9IHRoaXMudGVtcFZhclRyYW5zZm9ybWVyXy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHJldHVybiBpZCh0bXBJZCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFBMVVNfUExVUylcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1VbmFyeU51bWVyaWNfKHRyZWUsIFBMVVNfRVFVQUwpO1xuICAgICAgICBpZiAodHJlZS5vcGVyYXRvci50eXBlID09PSBNSU5VU19NSU5VUylcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1VbmFyeU51bWVyaWNfKHRyZWUsIE1JTlVTX0VRVUFMKTtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICBpZiAob3BlcmFuZCA9PT0gdHJlZS5vcGVyYW5kKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKG9wZXJhbmQpLCBbbmV3IFVuYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm9wZXJhdG9yLCBnZXRSZXN1bHQob3BlcmFuZCkpXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVVuYXJ5TnVtZXJpY186IGZ1bmN0aW9uKHRyZWUsIG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFueShuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm9wZXJhbmQsIGNyZWF0ZU9wZXJhdG9yVG9rZW4ob3BlcmF0b3IpLCBjcmVhdGVOdW1iZXJMaXRlcmFsKDEpKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZC50eXBlID09PSBNRU1CRVJfRVhQUkVTU0lPTilcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb3N0Zml4TWVtYmVyRXhwcmVzc2lvbl8odHJlZSk7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OKVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVBvc3RmaXhNZW1iZXJMb29rdXBFeHByZXNzaW9uXyh0cmVlKTtcbiAgICAgICAgYXNzZXJ0KHRyZWUub3BlcmFuZC50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04pO1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRyZWUub3BlcmFuZDtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuYWRkVGVtcFZhcigpO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFBMVVNfUExVUyA/IFBMVVMgOiBNSU5VUztcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW2NyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRtcCwgb3BlcmFuZCksIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhbmQsIG5ldyBCaW5hcnlFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRtcCwgY3JlYXRlT3BlcmF0b3JUb2tlbihvcGVyYXRvciksIGNyZWF0ZU51bWJlckxpdGVyYWwoMSkpKSwgdG1wXTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUG9zdGZpeE1lbWJlckV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBtZW1iZXJOYW1lID0gdHJlZS5vcGVyYW5kLm1lbWJlck5hbWU7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kLm9wZXJhbmQpO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBtZW1iZXJFeHByZXNzaW9uID0gbmV3IE1lbWJlckV4cHJlc3Npb24odHJlZS5vcGVyYW5kLmxvY2F0aW9uLCBnZXRSZXN1bHQob3BlcmFuZCksIG1lbWJlck5hbWUpO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFBMVVNfUExVUyA/IFBMVVMgOiBNSU5VUztcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhvcGVyYW5kKSwgW2NyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRtcCwgbWVtYmVyRXhwcmVzc2lvbiksIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG1lbWJlckV4cHJlc3Npb24sIG5ldyBCaW5hcnlFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRtcCwgY3JlYXRlT3BlcmF0b3JUb2tlbihvcGVyYXRvciksIGNyZWF0ZU51bWJlckxpdGVyYWwoMSkpKSwgdG1wXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVBvc3RmaXhNZW1iZXJMb29rdXBFeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub3BlcmFuZC5tZW1iZXJFeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQub3BlcmFuZCk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmFkZFRlbXBWYXIoKTtcbiAgICAgICAgdmFyIG1lbWJlckxvb2t1cEV4cHJlc3Npb24gPSBuZXcgTWVtYmVyTG9va3VwRXhwcmVzc2lvbihudWxsLCBnZXRSZXN1bHQob3BlcmFuZCksIGdldFJlc3VsdChtZW1iZXJFeHByZXNzaW9uKSk7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRyZWUub3BlcmF0b3IudHlwZSA9PT0gUExVU19QTFVTID8gUExVUyA6IE1JTlVTO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKG9wZXJhbmQpLCBnZXRFeHByZXNzaW9ucyhtZW1iZXJFeHByZXNzaW9uKSwgW2NyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRtcCwgbWVtYmVyTG9va3VwRXhwcmVzc2lvbiksIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG1lbWJlckxvb2t1cEV4cHJlc3Npb24sIG5ldyBCaW5hcnlFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRtcCwgY3JlYXRlT3BlcmF0b3JUb2tlbihvcGVyYXRvciksIGNyZWF0ZU51bWJlckxpdGVyYWwoMSkpKSwgdG1wXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVlpZWxkRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKS5idWlsZChuZXcgWWllbGRFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG51bGwsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tYUV4cHJlc3Npb25CdWlsZGVyXygpLmFkZChleHByZXNzaW9uKS5idWlsZChuZXcgWWllbGRFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGdldFJlc3VsdChleHByZXNzaW9uKSwgdHJlZS5pc1lpZWxkRm9yKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKS5hZGQoZXhwcmVzc2lvbikuYnVpbGQobmV3IEF3YWl0RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBnZXRSZXN1bHQoZXhwcmVzc2lvbikpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1QYXJlbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdHJlZS5leHByZXNzaW9uKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0UmVzdWx0KGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IElERU5USUZJRVJfRVhQUkVTU0lPTilcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKS5hZGQoZXhwcmVzc2lvbikuYnVpbGQocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db21tYUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgPT09IHRyZWUuZXhwcmVzc2lvbnMpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHZhciBidWlsZGVyID0gbmV3IENvbW1hRXhwcmVzc2lvbkJ1aWxkZXIobnVsbCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWlsZGVyLmFkZChleHByZXNzaW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGJ1aWxkZXIuZXhwcmVzc2lvbnMsIFtnZXRSZXN1bHQoZXhwcmVzc2lvbnNbZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV0pXSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tYUV4cHJlc3Npb25CdWlsZGVyXygpLmFkZChvcGVyYW5kKS5idWlsZChuZXcgTWVtYmVyRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBnZXRSZXN1bHQob3BlcmFuZCksIHRyZWUubWVtYmVyTmFtZSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlckxvb2t1cEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB2YXIgbWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNvbW1hRXhwcmVzc2lvbkJ1aWxkZXJfKCkuYWRkKG9wZXJhbmQpLmFkZChtZW1iZXJFeHByZXNzaW9uKS5idWlsZChuZXcgTWVtYmVyTG9va3VwRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBnZXRSZXN1bHQob3BlcmFuZCksIGdldFJlc3VsdChtZW1iZXJFeHByZXNzaW9uKSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmF0b3IuaXNBc3NpZ25tZW50T3BlcmF0b3IoKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Bc3NpZ25tZW50RXhwcmVzc2lvbl8odHJlZSk7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIGlmIChsZWZ0ID09PSB0cmVlLmxlZnQgJiYgcmlnaHQgPT09IHRyZWUucmlnaHQpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhdG9yLnR5cGUgPT09IE9SKVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU9yXyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhdG9yLnR5cGUgPT09IEFORClcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BbmRfKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhsZWZ0KSwgZ2V0RXhwcmVzc2lvbnMocmlnaHQpLCBbbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgZ2V0UmVzdWx0KGxlZnQpLCB0cmVlLm9wZXJhdG9yLCBnZXRSZXN1bHQocmlnaHQpKV0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29tbWFFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bc3NpZ25tZW50RXhwcmVzc2lvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSB0cmVlLmxlZnQ7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IE1FTUJFUl9FWFBSRVNTSU9OKVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFzc2lnbk1lbWJlckV4cHJlc3Npb25fKHRyZWUpO1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04pXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXNzaWduTWVtYmVyTG9va3VwRXhwcmVzc2lvbl8odHJlZSk7XG4gICAgICAgIGFzc2VydCh0cmVlLmxlZnQudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OKTtcbiAgICAgICAgaWYgKHRyZWUub3BlcmF0b3IudHlwZSA9PT0gRVFVQUwpIHtcbiAgICAgICAgICBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkobGVmdCk7XG4gICAgICAgICAgdmFyIHJpZ2h0JF9fMyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKHJpZ2h0JF9fMyksIFtjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZWZ0LCBnZXRSZXN1bHQocmlnaHQkX18zKSksIGdldFJlc3VsdChyaWdodCRfXzMpXSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyRfXzQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBiaW5vcCA9IGNyZWF0ZU9wZXJhdG9yVG9rZW4oYXNzaWdubWVudE9wZXJhdG9yVG9CaW5hcnlPcGVyYXRvcih0cmVlLm9wZXJhdG9yLnR5cGUpKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhyaWdodCksIFtjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXAsIG5ldyBCaW5hcnlFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGxlZnQsIGJpbm9wLCBnZXRSZXN1bHQocmlnaHQpKSksIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxlZnQsIHRtcCksIHRtcF0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29tbWFFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bc3NpZ25NZW1iZXJFeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbGVmdCA9IHRyZWUubGVmdDtcbiAgICAgICAgaWYgKHRyZWUub3BlcmF0b3IudHlwZSA9PT0gRVFVQUwpIHtcbiAgICAgICAgICB2YXIgb3BlcmFuZCRfXzUgPSB0aGlzLnRyYW5zZm9ybUFueShsZWZ0Lm9wZXJhbmQpO1xuICAgICAgICAgIHZhciByaWdodCRfXzYgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJpZ2h0KTtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMkX183ID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhvcGVyYW5kJF9fNSksIGdldEV4cHJlc3Npb25zKHJpZ2h0JF9fNiksIFtuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBuZXcgTWVtYmVyRXhwcmVzc2lvbihsZWZ0LmxvY2F0aW9uLCBnZXRSZXN1bHQob3BlcmFuZCRfXzUpLCBsZWZ0Lm1lbWJlck5hbWUpLCB0cmVlLm9wZXJhdG9yLCBnZXRSZXN1bHQocmlnaHQkX182KSksIGdldFJlc3VsdChyaWdodCRfXzYpXSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyRfXzcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkobGVmdC5vcGVyYW5kKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmFkZFRlbXBWYXIoKTtcbiAgICAgICAgdmFyIG1lbWJlckV4cHJlc3Npb24gPSBuZXcgTWVtYmVyRXhwcmVzc2lvbihsZWZ0LmxvY2F0aW9uLCBnZXRSZXN1bHQob3BlcmFuZCksIGxlZnQubWVtYmVyTmFtZSk7XG4gICAgICAgIHZhciB0bXAyID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBiaW5vcCA9IGNyZWF0ZU9wZXJhdG9yVG9rZW4oYXNzaWdubWVudE9wZXJhdG9yVG9CaW5hcnlPcGVyYXRvcih0cmVlLm9wZXJhdG9yLnR5cGUpKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhvcGVyYW5kKSwgZ2V0RXhwcmVzc2lvbnMocmlnaHQpLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG1wLCBtZW1iZXJFeHByZXNzaW9uKSwgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG1wMiwgbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdG1wLCBiaW5vcCwgZ2V0UmVzdWx0KHJpZ2h0KSkpLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihtZW1iZXJFeHByZXNzaW9uLCB0bXAyKSwgdG1wMl0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29tbWFFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bc3NpZ25NZW1iZXJMb29rdXBFeHByZXNzaW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbGVmdCA9IHRyZWUubGVmdDtcbiAgICAgICAgaWYgKHRyZWUub3BlcmF0b3IudHlwZSA9PT0gRVFVQUwpIHtcbiAgICAgICAgICB2YXIgb3BlcmFuZCRfXzggPSB0aGlzLnRyYW5zZm9ybUFueShsZWZ0Lm9wZXJhbmQpO1xuICAgICAgICAgIHZhciBtZW1iZXJFeHByZXNzaW9uJF9fOSA9IHRoaXMudHJhbnNmb3JtQW55KGxlZnQubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHJpZ2h0JF9fMTAgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJpZ2h0KTtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMkX18xMSA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMob3BlcmFuZCRfXzgpLCBnZXRFeHByZXNzaW9ucyhtZW1iZXJFeHByZXNzaW9uJF9fOSksIGdldEV4cHJlc3Npb25zKHJpZ2h0JF9fMTApLCBbbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbmV3IE1lbWJlckxvb2t1cEV4cHJlc3Npb24obGVmdC5sb2NhdGlvbiwgZ2V0UmVzdWx0KG9wZXJhbmQkX184KSwgZ2V0UmVzdWx0KG1lbWJlckV4cHJlc3Npb24kX185KSksIHRyZWUub3BlcmF0b3IsIGdldFJlc3VsdChyaWdodCRfXzEwKSksIGdldFJlc3VsdChyaWdodCRfXzEwKV0pO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMkX18xMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueShsZWZ0Lm9wZXJhbmQpO1xuICAgICAgICB2YXIgbWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KGxlZnQubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBtZW1iZXJMb29rdXBFeHByZXNzaW9uID0gbmV3IE1lbWJlckxvb2t1cEV4cHJlc3Npb24obGVmdC5sb2NhdGlvbiwgZ2V0UmVzdWx0KG9wZXJhbmQpLCBnZXRSZXN1bHQobWVtYmVyRXhwcmVzc2lvbikpO1xuICAgICAgICB2YXIgdG1wMiA9IHRoaXMuYWRkVGVtcFZhcigpO1xuICAgICAgICB2YXIgYmlub3AgPSBjcmVhdGVPcGVyYXRvclRva2VuKGFzc2lnbm1lbnRPcGVyYXRvclRvQmluYXJ5T3BlcmF0b3IodHJlZS5vcGVyYXRvci50eXBlKSk7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMob3BlcmFuZCksIGdldEV4cHJlc3Npb25zKG1lbWJlckV4cHJlc3Npb24pLCBnZXRFeHByZXNzaW9ucyhyaWdodCksIFtjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXAsIG1lbWJlckxvb2t1cEV4cHJlc3Npb24pLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXAyLCBuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0bXAsIGJpbm9wLCBnZXRSZXN1bHQocmlnaHQpKSksIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG1lbWJlckxvb2t1cEV4cHJlc3Npb24sIHRtcDIpLCB0bXAyXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycmF5TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIGlmIChlbGVtZW50cyA9PT0gdHJlZS5lbGVtZW50cylcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSB0aGlzLmNyZWF0ZUNvbW1hRXhwcmVzc2lvbkJ1aWxkZXJfKCk7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWlsZGVyLmFkZChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGdldFJlc3VsdChlbGVtZW50c1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmJ1aWxkKG5ldyBBcnJheUxpdGVyYWwodHJlZS5sb2NhdGlvbiwgcmVzdWx0cykpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdExpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZUFuZFZhbHVlcyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVBbmRWYWx1ZXMgPT09IHRyZWUucHJvcGVydHlOYW1lQW5kVmFsdWVzKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB2YXIgYnVpbGRlciA9IHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVBbmRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydHlOYW1lQW5kVmFsdWVzW2ldLnR5cGUgPT09IFBST1BFUlRZX05BTUVfQVNTSUdOTUVOVCkge1xuICAgICAgICAgICAgYnVpbGRlci5hZGQocHJvcGVydHlOYW1lQW5kVmFsdWVzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgUHJvcGVydHlOYW1lQXNzaWdubWVudChwcm9wZXJ0eU5hbWVBbmRWYWx1ZXNbaV0ubG9jYXRpb24sIHByb3BlcnR5TmFtZUFuZFZhbHVlc1tpXS5uYW1lLCBnZXRSZXN1bHQocHJvcGVydHlOYW1lQW5kVmFsdWVzW2ldLnZhbHVlKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocHJvcGVydHlOYW1lQW5kVmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYnVpbGQobmV3IE9iamVjdExpdGVyYWwodHJlZS5sb2NhdGlvbiwgcmVzdWx0cykpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIGlmICghb3BlcmFuZCAmJiBvcGVyYW5kID09PSB0cmVlLm9wZXJhbmQgJiYgZWxlbWVudHMgPT09IHRyZWUuZWxlbWVudHMpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHZhciBidWlsZGVyID0gdGhpcy5jcmVhdGVDb21tYUV4cHJlc3Npb25CdWlsZGVyXygpO1xuICAgICAgICBpZiAob3BlcmFuZClcbiAgICAgICAgICBidWlsZGVyLmFkZChvcGVyYW5kKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlbGVtZW50c1tpXS50eXBlID09PSBURU1QTEFURV9MSVRFUkFMX1BPUlRJT04pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gZWxlbWVudHNbaV0uZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGdldFJlc3VsdChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgVGVtcGxhdGVTdWJzdGl0dXRpb24oZXhwcmVzc2lvbi5sb2NhdGlvbiwgcmVzdWx0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmJ1aWxkKG5ldyBUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIG9wZXJhbmQgJiYgZ2V0UmVzdWx0KG9wZXJhbmQpLCByZXN1bHRzKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZC50eXBlID09PSBNRU1CRVJfRVhQUkVTU0lPTilcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1DYWxsTWVtYmVyRXhwcmVzc2lvbl8odHJlZSk7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OKVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUNhbGxNZW1iZXJMb29rdXBFeHByZXNzaW9uXyh0cmVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQ2FsbEFuZE5ld18odHJlZSwgQ2FsbEV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQ2FsbEFuZE5ld18odHJlZSwgTmV3RXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2FsbEFuZE5ld186IGZ1bmN0aW9uKHRyZWUsIGN0b3IpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYXJncyk7XG4gICAgICAgIHZhciBidWlsZGVyID0gdGhpcy5jcmVhdGVDb21tYUV4cHJlc3Npb25CdWlsZGVyXygpLmFkZChvcGVyYW5kKTtcbiAgICAgICAgdmFyIGFyZ1Jlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJncy5hcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGQoYXJnKTtcbiAgICAgICAgICBhcmdSZXN1bHRzLnB1c2goZ2V0UmVzdWx0KGFyZykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYnVpbGQobmV3IGN0b3IodHJlZS5sb2NhdGlvbiwgZ2V0UmVzdWx0KG9wZXJhbmQpLCBuZXcgQXJndW1lbnRMaXN0KGFyZ3MubG9jYXRpb24sIGFyZ1Jlc3VsdHMpKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2FsbE1lbWJlckV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBtZW1iZXJOYW1lID0gdHJlZS5vcGVyYW5kLm1lbWJlck5hbWU7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kLm9wZXJhbmQpO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBtZW1iZXJFeHByZXNzc2lvbiA9IG5ldyBNZW1iZXJFeHByZXNzaW9uKHRyZWUub3BlcmFuZC5sb2NhdGlvbiwgZ2V0UmVzdWx0KG9wZXJhbmQpLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmFyZ3MpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKG9wZXJhbmQpLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG1wLCBtZW1iZXJFeHByZXNzc2lvbildKTtcbiAgICAgICAgdmFyIGFyZ1Jlc3VsdHMgPSBbZ2V0UmVzdWx0KG9wZXJhbmQpXTtcbiAgICAgICAgYXJncy5hcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgdmFyICRfXzI7XG4gICAgICAgICAgKCRfXzIgPSBleHByZXNzaW9ucykucHVzaC5hcHBseSgkX18yLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKGFyZykpKTtcbiAgICAgICAgICBhcmdSZXN1bHRzLnB1c2goZ2V0UmVzdWx0KGFyZykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNhbGxFeHByZXNzaW9uID0gbmV3IENhbGxFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24odG1wLCAnY2FsbCcpLCBuZXcgQXJndW1lbnRMaXN0KGFyZ3MubG9jYXRpb24sIGFyZ1Jlc3VsdHMpKTtcbiAgICAgICAgdmFyIHRtcDIgPSB0aGlzLmFkZFRlbXBWYXIoKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXAyLCBjYWxsRXhwcmVzc2lvbiksIHRtcDIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29tbWFFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYWxsTWVtYmVyTG9va3VwRXhwcmVzc2lvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQub3BlcmFuZCk7XG4gICAgICAgIHZhciBtZW1iZXJFeHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBsb29rdXBFeHByZXNzc2lvbiA9IG5ldyBNZW1iZXJMb29rdXBFeHByZXNzaW9uKHRyZWUub3BlcmFuZC5sb2NhdGlvbiwgZ2V0UmVzdWx0KG9wZXJhbmQpLCBnZXRSZXN1bHQobWVtYmVyRXhwcmVzc2lvbikpO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYXJncyk7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMob3BlcmFuZCksIGdldEV4cHJlc3Npb25zKG1lbWJlckV4cHJlc3Npb24pLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odG1wLCBsb29rdXBFeHByZXNzc2lvbildKTtcbiAgICAgICAgdmFyIGFyZ1Jlc3VsdHMgPSBbZ2V0UmVzdWx0KG9wZXJhbmQpXTtcbiAgICAgICAgYXJncy5hcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpKSB7XG4gICAgICAgICAgdmFyICRfXzI7XG4gICAgICAgICAgKCRfXzIgPSBleHByZXNzaW9ucykucHVzaC5hcHBseSgkX18yLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKGFyZykpKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0UmVzdWx0KGFyZyk7XG4gICAgICAgICAgaWYgKHRyZWUuYXJncy5hcmdzW2ldLnR5cGUgPT09IFNQUkVBRF9FWFBSRVNTSU9OKVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFNwcmVhZEV4cHJlc3Npb24oYXJnLmxvY2F0aW9uLCByZXN1bHQpO1xuICAgICAgICAgIGFyZ1Jlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNhbGxFeHByZXNzaW9uID0gbmV3IENhbGxFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24odG1wLCAnY2FsbCcpLCBuZXcgQXJndW1lbnRMaXN0KGFyZ3MubG9jYXRpb24sIGFyZ1Jlc3VsdHMpKTtcbiAgICAgICAgdmFyIHRtcDIgPSB0aGlzLmFkZFRlbXBWYXIoKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0bXAyLCBjYWxsRXhwcmVzc2lvbiksIHRtcDIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29tbWFFeHByZXNzaW9uKGV4cHJlc3Npb25zKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY29uZGl0aW9uKTtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmxlZnQpO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJpZ2h0KTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdHJlZS5jb25kaXRpb24gJiYgbGVmdCA9PT0gdHJlZS5sZWZ0ICYmIHJpZ2h0ID09PSB0cmVlLnJpZ2h0KVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBsZWZ0VHJlZSA9IGNyZWF0ZUNvbW1hRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKGxlZnQpLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24ocmVzLCBnZXRSZXN1bHQobGVmdCkpXSkpO1xuICAgICAgICB2YXIgcmlnaHRUcmVlID0gY3JlYXRlQ29tbWFFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMocmlnaHQpLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24ocmVzLCBnZXRSZXN1bHQocmlnaHQpKV0pKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhjb25kaXRpb24pLCBbbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBnZXRSZXN1bHQoY29uZGl0aW9uKSwgY3JlYXRlUGFyZW5FeHByZXNzaW9uKGxlZnRUcmVlKSwgY3JlYXRlUGFyZW5FeHByZXNzaW9uKHJpZ2h0VHJlZSkpLCByZXNdKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtT3JfOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5hZGRUZW1wVmFyKCk7XG4gICAgICAgIHZhciBsZWZ0VHJlZSA9IGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24ocmVzLCBnZXRSZXN1bHQobGVmdCkpXSk7XG4gICAgICAgIHZhciByaWdodFRyZWUgPSBjcmVhdGVDb21tYUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLnNwcmVhZChnZXRFeHByZXNzaW9ucyhyaWdodCksIFtjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihyZXMsIGdldFJlc3VsdChyaWdodCkpXSkpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKGxlZnQpLCBbbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbihsZWZ0LmxvY2F0aW9uLCBnZXRSZXN1bHQobGVmdCksIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihsZWZ0VHJlZSksIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihyaWdodFRyZWUpKSwgcmVzXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFuZF86IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciByZXMgPSB0aGlzLmFkZFRlbXBWYXIoKTtcbiAgICAgICAgdmFyIGxlZnRUcmVlID0gY3JlYXRlQ29tbWFFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMocmlnaHQpLCBbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24ocmVzLCBnZXRSZXN1bHQocmlnaHQpKV0pKTtcbiAgICAgICAgdmFyIHJpZ2h0VHJlZSA9IGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihbY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24ocmVzLCBnZXRSZXN1bHQobGVmdCkpXSk7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQoZ2V0RXhwcmVzc2lvbnMobGVmdCksIFtuZXcgQ29uZGl0aW9uYWxFeHByZXNzaW9uKGxlZnQubG9jYXRpb24sIGdldFJlc3VsdChsZWZ0KSwgY3JlYXRlUGFyZW5FeHByZXNzaW9uKGxlZnRUcmVlKSwgY3JlYXRlUGFyZW5FeHByZXNzaW9uKHJpZ2h0VHJlZSkpLCByZXNdKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU3ByZWFkRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB0cmVlLmV4cHJlc3Npb24pXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXRSZXN1bHQoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSAhPT0gU1BSRUFEX0VYUFJFU1NJT04pXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IFNwcmVhZEV4cHJlc3Npb24ocmVzdWx0LmxvY2F0aW9uLCByZXN1bHQpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGdldEV4cHJlc3Npb25zKGV4cHJlc3Npb24pLCBbcmVzdWx0XSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21tYUV4cHJlc3Npb25CdWlsZGVyXygpLmJ1aWxkKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycm93RnVuY3Rpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKS5idWlsZCh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICBpZiAoc3VwZXJDbGFzcyA9PT0gdHJlZS5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKS5idWlsZCh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVpbGRlciA9IHRoaXMuY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl8oKTtcbiAgICAgICAgYnVpbGRlci5hZGQoc3VwZXJDbGFzcyk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmJ1aWxkKG5ldyBDbGFzc0V4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCBnZXRSZXN1bHQoc3VwZXJDbGFzcyksIHRyZWUuZWxlbWVudHMsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUudHlwZVBhcmFtZXRlcnMpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkJvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgY3JlYXRlQ29tbWFFeHByZXNzaW9uQnVpbGRlcl86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1hRXhwcmVzc2lvbkJ1aWxkZXIodGhpcy5hZGRUZW1wVmFyKCkpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBFeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwb25lbnRpYXRpb25UcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0V4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyLmpzXCIpKS5FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyO1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9FeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciBQYXJlblRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyZW5UcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwb25lbnRpYXRpb25UcmFuc2Zvcm1lci5qc1wiKSkuUGFyZW5UcmFpdDtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRXhwb25lbnRpYXRpb25UcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBTVEFSX1NUQVIgPSAkX180LlNUQVJfU1RBUixcbiAgICAgIFNUQVJfU1RBUl9FUVVBTCA9ICRfXzQuU1RBUl9TVEFSX0VRVUFMO1xuICB2YXIgcGFyc2VFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0V4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIuanNcIikpLnBhcnNlRXhwcmVzc2lvbjtcbiAgdmFyIEV4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEV4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRXhwb25lbnRpYXRpb25UcmFuc2Zvcm1lciwge3RyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgc3dpdGNoICh0cmVlLm9wZXJhdG9yLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNUQVJfU1RBUjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmxlZnQpO1xuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiTWF0aC5wb3coXCIsIFwiLCBcIiwgXCIpXCJdKSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgU1RBUl9TVEFSX0VRVUFMOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXhwbG9kZWQgPSBuZXcgRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lcih0aGlzKS50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFueShleHBsb2RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBFeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1CaW5hcnlFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJlblRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpO1xuICByZXR1cm4ge2dldCBFeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEV4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm9yT2ZUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zvck9mVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zvck9mVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRk9SX09GX1NUQVRFTUVOVCA9ICRfXzEuRk9SX09GX1NUQVRFTUVOVCxcbiAgICAgIFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgPSAkX18xLlZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QsXG4gICAgICBMQUJFTExFRF9TVEFURU1FTlQgPSAkX18xLkxBQkVMTEVEX1NUQVRFTUVOVDtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm9yT2ZUcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgJF9fMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zvck9mVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgaWQgPSAkX18zLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzMuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudDtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm9yT2ZUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzQucGFyc2VTdGF0ZW1lbnQsXG4gICAgICBwYXJzZVN0YXRlbWVudHMgPSAkX180LnBhcnNlU3RhdGVtZW50cztcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zvck9mVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fNS5Bbm9uQmxvY2ssXG4gICAgICBMYWJlbGxlZFN0YXRlbWVudCA9ICRfXzUuTGFiZWxsZWRTdGF0ZW1lbnQ7XG4gIHZhciBGb3JPZlRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGb3JPZlRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRm9yT2ZUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvck9mVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUZvck9mU3RhdGVtZW50OiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Gb3JPZlN0YXRlbWVudF8ob3JpZ2luYWwsIFtdKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JPZlN0YXRlbWVudF86IGZ1bmN0aW9uKG9yaWdpbmFsLCBsYWJlbFNldCkge1xuICAgICAgICB2YXIgdHJlZSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBGb3JPZlRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Gb3JPZlN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIG9yaWdpbmFsKTtcbiAgICAgICAgdmFyIGl0ZXIgPSBpZCh0aGlzLmdldFRlbXBJZGVudGlmaWVyKCkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gaWQodGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgdmFyIGxhYmVsID0gaWQodGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSBpZCh0aGlzLmdldFRlbXBJZGVudGlmaWVyKCkpO1xuICAgICAgICB2YXIgdGhyb3dDb21wbGV0aW9uID0gaWQodGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IGlkKHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgICAgIHZhciBleCA9IGlkKHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgICAgIHZhciBsYWJlbGxlZFN0YXRlbWVudDtcbiAgICAgICAgdmFyIGlubmVyU3RhdGVtZW50O1xuICAgICAgICB2YXIgYXNzaWdubWVudDtcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIudHlwZSA9PT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCkge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudCh0cmVlLmluaXRpYWxpemVyLmRlY2xhcmF0aW9uVHlwZSwgdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnNbMF0ubHZhbHVlLCBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKHJlc3VsdCwgJ3ZhbHVlJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiID0gXCIsIFwiLnZhbHVlO1wiXSksIHRyZWUuaW5pdGlhbGl6ZXIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICBmb3IgKHZhciBcIiwgXCIsXFxuICAgICAgICAgICAgICAgICBcIiwgXCIgPSAoXCIsIFwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XFxuICAgICAgICAgICAgICEoXCIsIFwiID0gKFwiLCBcIiA9IFwiLCBcIi5uZXh0KCkpLmRvbmUpO1xcbiAgICAgICAgICAgICBcIiwgXCIgPSB0cnVlKSB7XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIH1cIl0pLCByZXN1bHQsIGl0ZXIsIHRyZWUuY29sbGVjdGlvbiwgbm9ybWFsQ29tcGxldGlvbiwgcmVzdWx0LCBpdGVyLCBub3JtYWxDb21wbGV0aW9uLCBhc3NpZ25tZW50LCB0cmVlLmJvZHkpO1xuICAgICAgICB3aGlsZSAobGFiZWxsZWRTdGF0ZW1lbnQgPSBsYWJlbFNldC5wb3AoKSkge1xuICAgICAgICAgIGlubmVyU3RhdGVtZW50ID0gbmV3IExhYmVsbGVkU3RhdGVtZW50KGxhYmVsbGVkU3RhdGVtZW50LmxvY2F0aW9uLCBsYWJlbGxlZFN0YXRlbWVudC5uYW1lLCBpbm5lclN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIHZhciBcIiwgXCIgPSB0cnVlO1xcbiAgICAgICAgdmFyIFwiLCBcIiA9IGZhbHNlO1xcbiAgICAgICAgdmFyIFwiLCBcIiA9IHVuZGVmaW5lZDtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgfSBjYXRjaCAoXCIsIFwiKSB7XFxuICAgICAgICAgIFwiLCBcIiA9IHRydWU7XFxuICAgICAgICAgIFwiLCBcIiA9IFwiLCBcIjtcXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKCFcIiwgXCIgJiYgXCIsIFwiLnJldHVybiAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICBcIiwgXCIucmV0dXJuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICAgIGlmIChcIiwgXCIpIHtcXG4gICAgICAgICAgICAgIHRocm93IFwiLCBcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cIl0pLCBub3JtYWxDb21wbGV0aW9uLCB0aHJvd0NvbXBsZXRpb24sIGV4Y2VwdGlvbiwgaW5uZXJTdGF0ZW1lbnQsIGV4LCB0aHJvd0NvbXBsZXRpb24sIGV4Y2VwdGlvbiwgZXgsIG5vcm1hbENvbXBsZXRpb24sIGl0ZXIsIGl0ZXIsIHRocm93Q29tcGxldGlvbiwgZXhjZXB0aW9uKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGFiZWxsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGxhYmVsU2V0ID0gW3RyZWVdO1xuICAgICAgICB2YXIgc3RhdGVtZW50ID0gdHJlZS5zdGF0ZW1lbnQ7XG4gICAgICAgIHdoaWxlIChzdGF0ZW1lbnQudHlwZSA9PT0gTEFCRUxMRURfU1RBVEVNRU5UKSB7XG4gICAgICAgICAgbGFiZWxTZXQucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgICAgIHN0YXRlbWVudCA9IHN0YXRlbWVudC5zdGF0ZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlbWVudC50eXBlICE9PSBGT1JfT0ZfU1RBVEVNRU5UKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBGb3JPZlRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZvck9mU3RhdGVtZW50XyhzdGF0ZW1lbnQsIGxhYmVsU2V0KTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRlbXBWYXJUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IEZvck9mVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gRm9yT2ZUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Jbm5lckZvck9uVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Jbm5lckZvck9uVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubmVyRm9yT25UcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBhbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9hbHBoYVJlbmFtZVRoaXNBbmRBcmd1bWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubmVyRm9yT25UcmFuc2Zvcm1lci5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QbGFjZWhvbGRlclBhcnNlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fNC5wYXJzZVN0YXRlbWVudCxcbiAgICAgIHBhcnNlU3RhdGVtZW50cyA9ICRfXzQucGFyc2VTdGF0ZW1lbnRzO1xuICB2YXIgJF9fNSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFub25CbG9jayA9ICRfXzUuQW5vbkJsb2NrLFxuICAgICAgQmxvY2sgPSAkX181LkJsb2NrLFxuICAgICAgQ29udGludWVTdGF0ZW1lbnQgPSAkX181LkNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgTGFiZWxsZWRTdGF0ZW1lbnQgPSAkX181LkxhYmVsbGVkU3RhdGVtZW50LFxuICAgICAgUmV0dXJuU3RhdGVtZW50ID0gJF9fNS5SZXR1cm5TdGF0ZW1lbnQ7XG4gIHZhciBTdHJpbmdTZXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9TdHJpbmdTZXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubmVyRm9yT25UcmFuc2Zvcm1lci5qc1wiKSkuU3RyaW5nU2V0O1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubmVyRm9yT25UcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50ID0gJF9fNy5jcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50LFxuICAgICAgY3JlYXRlQ2FzZUNsYXVzZSA9ICRfXzcuY3JlYXRlQ2FzZUNsYXVzZSxcbiAgICAgIGNyZWF0ZURlZmF1bHRDbGF1c2UgPSAkX183LmNyZWF0ZURlZmF1bHRDbGF1c2UsXG4gICAgICBpZCA9ICRfXzcuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdW1iZXJMaXRlcmFsID0gJF9fNy5jcmVhdGVOdW1iZXJMaXRlcmFsLFxuICAgICAgY3JlYXRlU3dpdGNoU3RhdGVtZW50ID0gJF9fNy5jcmVhdGVTd2l0Y2hTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlVGhpc0V4cHJlc3Npb24sXG4gICAgICBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudCA9ICRfXzcuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fNy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX183LmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgY3JlYXRlVm9pZDAgPSAkX183LmNyZWF0ZVZvaWQwO1xuICB2YXIgU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ta2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgQVJHVU1FTlRTID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKS5BUkdVTUVOVFM7XG4gIHZhciBWQVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKS5WQVI7XG4gIHZhciAkX18xMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgPSAkX18xMS5WQVJJQUJMRV9ERUNMQVJBVElPTl9MSVNULFxuICAgICAgQkxPQ0sgPSAkX18xMS5CTE9DSztcbiAgdmFyIElubmVyRm9yT25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gSW5uZXJGb3JPblRyYW5zZm9ybWVyKHRlbXBJZEdlbmVyYXRvciwgbGFiZWxTZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciAkX18xO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW5uZXJGb3JPblRyYW5zZm9ybWVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5pZEdlbmVyYXRvcl8gPSB0ZW1wSWRHZW5lcmF0b3I7XG4gICAgICB0aGlzLmluTG9vcF8gPSAwO1xuICAgICAgdGhpcy5pbkJyZWFrYmxlXyA9IDA7XG4gICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXyA9IFtdO1xuICAgICAgdGhpcy5leHRyYWN0ZWRTdGF0ZW1lbnRzXyA9IFtdO1xuICAgICAgdGhpcy5sYWJlbFNldF8gPSBsYWJlbFNldDtcbiAgICAgIHRoaXMubGFiZWxsZWRTdGF0ZW1lbnRzXyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXJfID0gaWQodGhpcy5pZEdlbmVyYXRvcl8uZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgICB0aGlzLnJlc3VsdF8gPSBpZCh0aGlzLmlkR2VuZXJhdG9yXy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgIHRoaXMucGFyZW50TGFiZWxzXyA9IG5ldyBTdHJpbmdTZXQoKTtcbiAgICAgIHRoaXMubGFiZWxTZXRfLmZvckVhY2goKCRfXzEgPSB0aGlzLCBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICRfXzEucGFyZW50TGFiZWxzXy5hZGQodHJlZS5uYW1lLnZhbHVlKTtcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbm5lckZvck9uVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpZCh0aGlzLmlkR2VuZXJhdG9yXy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgdmFyIGFzc2lnbm1lbnQ7XG4gICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyLnR5cGUgPT09IFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QpIHtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQodHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvblR5cGUsIHRyZWUuaW5pdGlhbGl6ZXIuZGVjbGFyYXRpb25zWzBdLmx2YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgIFwiLCBcIiA9IFwiLCBcIjtcIl0pLCB0cmVlLmluaXRpYWxpemVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIGlmICh0cmVlLmJvZHkudHlwZSA9PT0gQkxPQ0spIHtcbiAgICAgICAgICBib2R5ID0gbmV3IEJsb2NrKHRyZWUuYm9keS5sb2NhdGlvbiwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChbYXNzaWdubWVudF0sIHRyZWUuYm9keS5zdGF0ZW1lbnRzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9keSA9IG5ldyBCbG9jayhudWxsLCBbYXNzaWdubWVudCwgdHJlZS5ib2R5XSk7XG4gICAgICAgIH1cbiAgICAgICAgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KGJvZHkpO1xuICAgICAgICBib2R5ID0gYWxwaGFSZW5hbWVUaGlzQW5kQXJndW1lbnRzKHRoaXMsIGJvZHkpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXy5wdXNoKGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24odGhpcy5yZXN1bHRfLCBjcmVhdGVWb2lkMCgpKSk7XG4gICAgICAgIHZhciBjYXNlQ2xhdXNlcyA9IHRoaXMuZXh0cmFjdGVkU3RhdGVtZW50c18ubWFwKGZ1bmN0aW9uKHN0YXRlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FzZUNsYXVzZShjcmVhdGVOdW1iZXJMaXRlcmFsKGluZGV4KSwgW3N0YXRlbWVudF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FzZUNsYXVzZXMucHVzaChjcmVhdGVDYXNlQ2xhdXNlKGNyZWF0ZVZvaWQwKCksIFtuZXcgQ29udGludWVTdGF0ZW1lbnQobnVsbCwgbnVsbCldKSk7XG4gICAgICAgIGNhc2VDbGF1c2VzLnB1c2goY3JlYXRlRGVmYXVsdENsYXVzZShwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgcmV0dXJuIFwiLCBcIi52O1wiXSksIHRoaXMucmVzdWx0XykpKTtcbiAgICAgICAgdmFyIHN3aXRjaFN0YXRlbWVudCA9IGNyZWF0ZVN3aXRjaFN0YXRlbWVudCh0aGlzLnJlc3VsdF8sIGNhc2VDbGF1c2VzKTtcbiAgICAgICAgdmFyIG9ic2VydmVGb3JFYWNoID0gdGhpcy5pZEdlbmVyYXRvcl8uZ2V0UnVudGltZUV4cHJlc3Npb24oJ29ic2VydmVGb3JFYWNoJyk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICBkbyB7XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIGF3YWl0IFwiLCBcIihcXG4gICAgICAgICAgICAgIFwiLCBcIltTeW1ib2wub2JzZXJ2ZXJdLmJpbmQoXCIsIFwiKSxcXG4gICAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIChcIiwgXCIpIHtcXG4gICAgICAgICAgICAgICAgdmFyIFwiLCBcIiA9IHRoaXM7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgICBcIiwgXCIudGhyb3coZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIH0gd2hpbGUgKGZhbHNlKTtcIl0pLCBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfKSksIG9ic2VydmVGb3JFYWNoLCB0cmVlLm9ic2VydmFibGUsIHRyZWUub2JzZXJ2YWJsZSwgdmFsdWUsIHRoaXMub2JzZXJ2ZXJfLCBib2R5LCB0aGlzLm9ic2VydmVyXywgc3dpdGNoU3RhdGVtZW50KTtcbiAgICAgICAgdmFyIGxhYmVsbGVkU3RhdGVtZW50O1xuICAgICAgICB3aGlsZSAobGFiZWxsZWRTdGF0ZW1lbnQgPSB0aGlzLmxhYmVsU2V0Xy5wb3AoKSkge1xuICAgICAgICAgIHN0YXRlbWVudCA9IG5ldyBMYWJlbGxlZFN0YXRlbWVudChsYWJlbGxlZFN0YXRlbWVudC5sb2NhdGlvbiwgbGFiZWxsZWRTdGF0ZW1lbnQubmFtZSwgc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xuICAgICAgfSxcbiAgICAgIGFkZFRlbXBWYXJGb3JBcmd1bWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG1wVmFyTmFtZSA9IHRoaXMuaWRHZW5lcmF0b3JfLmdlbmVyYXRlVW5pcXVlSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGVjbGFyYXRpb25zXy5wdXNoKGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24odG1wVmFyTmFtZSwgaWQoQVJHVU1FTlRTKSkpO1xuICAgICAgICByZXR1cm4gdG1wVmFyTmFtZTtcbiAgICAgIH0sXG4gICAgICBhZGRUZW1wVmFyRm9yVGhpczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0bXBWYXJOYW1lID0gdGhpcy5pZEdlbmVyYXRvcl8uZ2VuZXJhdGVVbmlxdWVJZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVEZWNsYXJhdGlvbnNfLnB1c2goY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbih0bXBWYXJOYW1lLCBjcmVhdGVUaGlzRXhwcmVzc2lvbigpKSk7XG4gICAgICAgIHJldHVybiB0bXBWYXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFueTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZSkge1xuICAgICAgICAgIGlmICh0cmVlLmlzQnJlYWthYmxlU3RhdGVtZW50KCkpXG4gICAgICAgICAgICB0aGlzLmluQnJlYWtibGVfKys7XG4gICAgICAgICAgaWYgKHRyZWUuaXNJdGVyYXRpb25TdGF0ZW1lbnQoKSlcbiAgICAgICAgICAgIHRoaXMuaW5Mb29wXysrO1xuICAgICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5uZXJGb3JPblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1BbnlcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgICBpZiAodHJlZS5pc0JyZWFrYWJsZVN0YXRlbWVudCgpKVxuICAgICAgICAgICAgdGhpcy5pbkJyZWFrYmxlXy0tO1xuICAgICAgICAgIGlmICh0cmVlLmlzSXRlcmF0aW9uU3RhdGVtZW50KCkpXG4gICAgICAgICAgICB0aGlzLmluTG9vcF8tLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1SZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sodHJlZS5sb2NhdGlvbiwgcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIFwiLCBcIi5yZXR1cm4oKTtcXG4gICAgICAgIFwiLCBcIiA9IHt2OiBcIiwgXCJ9O1xcbiAgICAgICAgcmV0dXJuO1wiXSksIHRoaXMub2JzZXJ2ZXJfLCB0aGlzLnJlc3VsdF8sICh0cmVlLmV4cHJlc3Npb24gfHwgY3JlYXRlVm9pZDAoKSkpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BYnJ1cHRDb21wbGV0aW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmV4dHJhY3RlZFN0YXRlbWVudHNfLnB1c2godHJlZSk7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZXh0cmFjdGVkU3RhdGVtZW50c18ubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgIFwiLCBcIi5yZXR1cm4oKTtcXG4gICAgICAgIFwiLCBcIiA9IFwiLCBcIjtcXG4gICAgICAgIHJldHVybjtcIl0pLCB0aGlzLm9ic2VydmVyXywgdGhpcy5yZXN1bHRfLCBpbmRleCkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdHJlZS5uYW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5CcmVha2JsZV8pIHtcbiAgICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5uZXJGb3JPblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1CcmVha1N0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BYnJ1cHRDb21wbGV0aW9uXyhuZXcgQ29udGludWVTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgbnVsbCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhYmVsbGVkU3RhdGVtZW50c18uaGFzKHRyZWUubmFtZS52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIElubmVyRm9yT25UcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQnJlYWtTdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BYnJ1cHRDb21wbGV0aW9uXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoIXRyZWUubmFtZSkge1xuICAgICAgICAgIGlmICh0aGlzLmluTG9vcF8pIHtcbiAgICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5uZXJGb3JPblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Db250aW51ZVN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYWJlbGxlZFN0YXRlbWVudHNfLmhhcyh0cmVlLm5hbWUudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBJbm5lckZvck9uVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUNvbnRpbnVlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50TGFiZWxzXy5oYXModHJlZS5uYW1lLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFicnVwdENvbXBsZXRpb25fKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxhYmVsbGVkU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMubGFiZWxsZWRTdGF0ZW1lbnRzXy5hZGQodHJlZS5uYW1lLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBJbm5lckZvck9uVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUxhYmVsbGVkU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzEgPSB0aGlzO1xuICAgICAgICBpZiAodHJlZS5kZWNsYXJhdGlvbnMuZGVjbGFyYXRpb25UeXBlID09PSBWQVIpIHtcbiAgICAgICAgICB2YXIgYXNzaWdubWVudHMgPSBbXTtcbiAgICAgICAgICB0cmVlLmRlY2xhcmF0aW9ucy5kZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbih2YXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gdmFyaWFibGVEZWNsYXJhdGlvbi5sdmFsdWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCgkX18xLCBJbm5lckZvck9uVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUFueVwiKS5jYWxsKCRfXzEsIHZhcmlhYmxlRGVjbGFyYXRpb24uaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgJF9fMS52YXJpYWJsZURlY2xhcmF0aW9uc18ucHVzaChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKHZhcmlhYmxlTmFtZSwgbnVsbCkpO1xuICAgICAgICAgICAgYXNzaWdubWVudHMucHVzaChjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50KGlkKHZhcmlhYmxlTmFtZSksIGluaXRpYWxpemVyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgYXNzaWdubWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5uZXJGb3JPblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1WYXJpYWJsZVN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm06IGZ1bmN0aW9uKHRlbXBJZEdlbmVyYXRvciwgdHJlZSwgbGFiZWxTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbm5lckZvck9uVHJhbnNmb3JtZXIodGVtcElkR2VuZXJhdG9yLCBsYWJlbFNldCkudHJhbnNmb3JtKHRyZWUpO1xuICAgICAgfX0sICRfX3N1cGVyKTtcbiAgfShTa2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lcikpO1xuICByZXR1cm4ge2dldCBJbm5lckZvck9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gSW5uZXJGb3JPblRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zvck9uVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gb3JPblRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gb3JPblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEZPUl9PTl9TVEFURU1FTlQgPSAkX18xLkZPUl9PTl9TVEFURU1FTlQsXG4gICAgICBMQUJFTExFRF9TVEFURU1FTlQgPSAkX18xLkxBQkVMTEVEX1NUQVRFTUVOVDtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm9yT25UcmFuc2Zvcm1lci5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRm9yT25UcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgSW5uZXJGb3JPblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW5uZXJGb3JPblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gb3JPblRyYW5zZm9ybWVyLmpzXCIpKS5Jbm5lckZvck9uVHJhbnNmb3JtZXI7XG4gIHZhciBGb3JPblRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGb3JPblRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRm9yT25UcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvck9uVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUZvck9uU3RhdGVtZW50OiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Gb3JPblN0YXRlbWVudF8ob3JpZ2luYWwsIFtdKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JPblN0YXRlbWVudF86IGZ1bmN0aW9uKG9yaWdpbmFsLCBsYWJlbFNldCkge1xuICAgICAgICByZXR1cm4gSW5uZXJGb3JPblRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0aGlzLCAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgRm9yT25UcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9yT25TdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCBvcmlnaW5hbCksIGxhYmVsU2V0KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbGFiZWxTZXQgPSBbdHJlZV07XG4gICAgICAgIHZhciBzdGF0ZW1lbnQ7XG4gICAgICAgIGZvciAoc3RhdGVtZW50ID0gdHJlZS5zdGF0ZW1lbnQ7IHN0YXRlbWVudC50eXBlID09PSBMQUJFTExFRF9TVEFURU1FTlQ7IHN0YXRlbWVudCA9IHN0YXRlbWVudC5zdGF0ZW1lbnQpIHtcbiAgICAgICAgICBsYWJlbFNldC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlbWVudC50eXBlICE9PSBGT1JfT05fU1RBVEVNRU5UKSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBGb3JPblRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MYWJlbGxlZFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZvck9uU3RhdGVtZW50XyhzdGF0ZW1lbnQsIGxhYmVsU2V0KTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChUZW1wVmFyVHJhbnNmb3JtZXIpKTtcbiAgcmV0dXJuIHtnZXQgRm9yT25UcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBGb3JPblRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9HZW5lcmF0b3JDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIuanNcIikpLkNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIHBhcnNlU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VTdGF0ZW1lbnQ7XG4gIHZhciBHZW5lcmF0b3JDb21wcmVoZW5zaW9uVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lciwge3RyYW5zZm9ybUdlbmVyYXRvckNvbXByZWhlbnNpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgc3RhdGVtZW50ID0gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInlpZWxkIFwiLCBcIlwiXSksIGV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Db21wcmVoZW5zaW9uKHRyZWUsIHN0YXRlbWVudCwgaXNHZW5lcmF0b3IpO1xuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgR2VuZXJhdG9yQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3RhdGUuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1N0YXRlLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50ID0gJF9fMS5jcmVhdGVBc3NpZ25TdGF0ZVN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUJyZWFrU3RhdGVtZW50ID0gJF9fMS5jcmVhdGVCcmVha1N0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUNhc2VDbGF1c2UgPSAkX18xLmNyZWF0ZUNhc2VDbGF1c2UsXG4gICAgICBjcmVhdGVOdW1iZXJMaXRlcmFsID0gJF9fMS5jcmVhdGVOdW1iZXJMaXRlcmFsO1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9TdGF0ZS5qc1wiKSkucGFyc2VTdGF0ZW1lbnQ7XG4gIHZhciBTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlKGlkKSB7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTdGF0ZSwge1xuICAgICAgdHJhbnNmb3JtTWFjaGluZVN0YXRlOiBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBtYWNoaW5lRW5kU3RhdGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDYXNlQ2xhdXNlKGNyZWF0ZU51bWJlckxpdGVyYWwodGhpcy5pZCksIHRoaXMudHJhbnNmb3JtKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSwgcmVwb3J0ZXIpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CcmVhazogZnVuY3Rpb24obGFiZWxTZXQsIGJyZWFrU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQnJlYWtPckNvbnRpbnVlOiBmdW5jdGlvbihsYWJlbFNldCkge1xuICAgICAgICB2YXIgYnJlYWtTdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGNvbnRpbnVlU3RhdGUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICBTdGF0ZS5TVEFSVF9TVEFURSA9IDA7XG4gIFN0YXRlLklOVkFMSURfU1RBVEUgPSAtMTtcbiAgU3RhdGUuRU5EX1NUQVRFID0gLTI7XG4gIFN0YXRlLlJFVEhST1dfU1RBVEUgPSAtMztcbiAgU3RhdGUuZ2VuZXJhdGVKdW1wID0gZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgZmFsbFRocm91Z2hTdGF0ZSkge1xuICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKFN0YXRlLmdlbmVyYXRlQXNzaWduU3RhdGUoZW5jbG9zaW5nRmluYWxseSwgZmFsbFRocm91Z2hTdGF0ZSksIFtjcmVhdGVCcmVha1N0YXRlbWVudCgpXSk7XG4gIH07XG4gIFN0YXRlLmdlbmVyYXRlQXNzaWduU3RhdGUgPSBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBmYWxsVGhyb3VnaFN0YXRlKSB7XG4gICAgdmFyIGFzc2lnblN0YXRlO1xuICAgIGlmIChTdGF0ZS5pc0ZpbmFsbHlFeGl0KGVuY2xvc2luZ0ZpbmFsbHksIGZhbGxUaHJvdWdoU3RhdGUpKSB7XG4gICAgICBhc3NpZ25TdGF0ZSA9IGdlbmVyYXRlQXNzaWduU3RhdGVPdXRPZkZpbmFsbHkoZW5jbG9zaW5nRmluYWxseSwgZmFsbFRocm91Z2hTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblN0YXRlID0gW2NyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50KGZhbGxUaHJvdWdoU3RhdGUpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnblN0YXRlO1xuICB9O1xuICBTdGF0ZS5pc0ZpbmFsbHlFeGl0ID0gZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gISFlbmNsb3NpbmdGaW5hbGx5ICYmIGVuY2xvc2luZ0ZpbmFsbHkudHJ5U3RhdGVzLmluZGV4T2YoZGVzdGluYXRpb24pIDwgMDtcbiAgfTtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVBc3NpZ25TdGF0ZU91dE9mRmluYWxseShlbmNsb3NpbmdGaW5hbGx5LCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBmaW5hbGx5U3RhdGUgPSBlbmNsb3NpbmdGaW5hbGx5LmZpbmFsbHlTdGF0ZTtcbiAgICByZXR1cm4gW2NyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50KGZpbmFsbHlTdGF0ZSksIHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkY3R4LmZpbmFsbHlGYWxsVGhyb3VnaCA9IFwiLCBcIlwiXSksIGRlc3RpbmF0aW9uKV07XG4gIH1cbiAgU3RhdGUucmVwbGFjZVN0YXRlTGlzdCA9IGZ1bmN0aW9uKG9sZFN0YXRlcywgb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0ZXMucHVzaChTdGF0ZS5yZXBsYWNlU3RhdGVJZChvbGRTdGF0ZXNbaV0sIG9sZFN0YXRlLCBuZXdTdGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9O1xuICBTdGF0ZS5yZXBsYWNlU3RhdGVJZCA9IGZ1bmN0aW9uKGN1cnJlbnQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyZW50ID09PSBvbGRTdGF0ZSA/IG5ld1N0YXRlIDogY3VycmVudDtcbiAgfTtcbiAgU3RhdGUucmVwbGFjZUFsbFN0YXRlcyA9IGZ1bmN0aW9uKGV4Y2VwdGlvbkJsb2Nrcywgb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjZXB0aW9uQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChleGNlcHRpb25CbG9ja3NbaV0ucmVwbGFjZVN0YXRlKG9sZFN0YXRlLCBuZXdTdGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge2dldCBTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXdhaXRTdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bd2FpdFN0YXRlLmpzXCI7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXdhaXRTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBwYXJzZVN0YXRlbWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bd2FpdFN0YXRlLmpzXCIpKS5wYXJzZVN0YXRlbWVudHM7XG4gIHZhciBBd2FpdFN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBd2FpdFN0YXRlKGlkLCBjYWxsYmFja1N0YXRlLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihBd2FpdFN0YXRlKS5jYWxsKHRoaXMsIGlkKSwgdGhpcy5jYWxsYmFja1N0YXRlID0gY2FsbGJhY2tTdGF0ZTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBd2FpdFN0YXRlLCB7XG4gICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEF3YWl0U3RhdGUoU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5pZCwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5jYWxsYmFja1N0YXRlLCBvbGRTdGF0ZSwgbmV3U3RhdGUpLCB0aGlzLmV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgbWFjaGluZUVuZFN0YXRlLCByZXBvcnRlcikge1xuICAgICAgICB2YXIgJF9fMTtcbiAgICAgICAgdmFyIHN0YXRlSWQsXG4gICAgICAgICAgICBzdGF0ZW1lbnRzO1xuICAgICAgICBpZiAoU3RhdGUuaXNGaW5hbGx5RXhpdChlbmNsb3NpbmdGaW5hbGx5LCB0aGlzLmNhbGxiYWNrU3RhdGUpKSB7XG4gICAgICAgICAgc3RhdGVJZCA9IGVuY2xvc2luZ0ZpbmFsbHkuZmluYWxseVN0YXRlO1xuICAgICAgICAgIHN0YXRlbWVudHMgPSBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHguZmluYWxseUZhbGxUaHJvdWdoID0gXCIsIFwiXCJdKSwgdGhpcy5jYWxsYmFja1N0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZUlkID0gdGhpcy5jYWxsYmFja1N0YXRlO1xuICAgICAgICAgIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAoJF9fMSA9IHN0YXRlbWVudHMpLnB1c2guYXBwbHkoJF9fMSwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlByb21pc2UucmVzb2x2ZShcIiwgXCIpLnRoZW4oXFxuICAgICAgICAgICRjdHguY3JlYXRlQ2FsbGJhY2soXCIsIFwiKSwgJGN0eC5lcnJiYWNrKTtcXG4gICAgICAgICAgcmV0dXJuO1wiXSksIHRoaXMuZXhwcmVzc2lvbiwgc3RhdGVJZCkpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IEF3YWl0U3RhdGUoKSB7XG4gICAgICByZXR1cm4gQXdhaXRTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRmFsbFRocm91Z2hTdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9GYWxsVGhyb3VnaFN0YXRlLmpzXCI7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRmFsbFRocm91Z2hTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBGYWxsVGhyb3VnaFN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGYWxsVGhyb3VnaFN0YXRlKGlkLCBmYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZW1lbnRzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGYWxsVGhyb3VnaFN0YXRlKS5jYWxsKHRoaXMsIGlkKTtcbiAgICAgIHRoaXMuZmFsbFRocm91Z2hTdGF0ZSA9IGZhbGxUaHJvdWdoU3RhdGU7XG4gICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRmFsbFRocm91Z2hTdGF0ZSwge1xuICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWxsVGhyb3VnaFN0YXRlKFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSksIFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuZmFsbFRocm91Z2hTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5zdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSwgcmVwb3J0ZXIpIHtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zcHJlYWQodGhpcy5zdGF0ZW1lbnRzLCBTdGF0ZS5nZW5lcmF0ZUp1bXAoZW5jbG9zaW5nRmluYWxseSwgdGhpcy5mYWxsVGhyb3VnaFN0YXRlKSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IEZhbGxUaHJvdWdoU3RhdGUoKSB7XG4gICAgICByZXR1cm4gRmFsbFRocm91Z2hTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQnJlYWtTdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9CcmVha1N0YXRlLmpzXCI7XG4gIHZhciBGYWxsVGhyb3VnaFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmFsbFRocm91Z2hTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0JyZWFrU3RhdGUuanNcIikpLkZhbGxUaHJvdWdoU3RhdGU7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQnJlYWtTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBCcmVha1N0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCcmVha1N0YXRlKGlkLCBsYWJlbCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQnJlYWtTdGF0ZSkuY2FsbCh0aGlzLCBpZCk7XG4gICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShCcmVha1N0YXRlLCB7XG4gICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJyZWFrU3RhdGUoU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5pZCwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5sYWJlbCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBtYWNoaW5lRW5kU3RhdGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlc2Ugc2hvdWxkIGJlIHJlbW92ZWQgYmVmb3JlIHRoZSB0cmFuc2Zvcm0gc3RlcCcpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrOiBmdW5jdGlvbihsYWJlbFNldCkge1xuICAgICAgICB2YXIgYnJlYWtTdGF0ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG5ldyBGYWxsVGhyb3VnaFN0YXRlKHRoaXMuaWQsIGJyZWFrU3RhdGUsIFtdKTtcbiAgICAgICAgaWYgKGxhYmVsU2V0Lmhhcyh0aGlzLmxhYmVsKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRmFsbFRocm91Z2hTdGF0ZSh0aGlzLmlkLCBsYWJlbFNldC5nZXQodGhpcy5sYWJlbCkuZmFsbFRocm91Z2hTdGF0ZSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrT3JDb250aW51ZTogZnVuY3Rpb24obGFiZWxTZXQpIHtcbiAgICAgICAgdmFyIGJyZWFrU3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjb250aW51ZVN0YXRlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1CcmVhayhsYWJlbFNldCwgYnJlYWtTdGF0ZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IEJyZWFrU3RhdGUoKSB7XG4gICAgICByZXR1cm4gQnJlYWtTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ29udGludWVTdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Db250aW51ZVN0YXRlLmpzXCI7XG4gIHZhciBGYWxsVGhyb3VnaFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmFsbFRocm91Z2hTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NvbnRpbnVlU3RhdGUuanNcIikpLkZhbGxUaHJvdWdoU3RhdGU7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ29udGludWVTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBDb250aW51ZVN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDb250aW51ZVN0YXRlKGlkLCBsYWJlbCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ29udGludWVTdGF0ZSkuY2FsbCh0aGlzLCBpZCk7XG4gICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb250aW51ZVN0YXRlLCB7XG4gICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRpbnVlU3RhdGUoU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5pZCwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5sYWJlbCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBtYWNoaW5lRW5kU3RhdGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlc2Ugc2hvdWxkIGJlIHJlbW92ZWQgYmVmb3JlIHRoZSB0cmFuc2Zvcm0gc3RlcCcpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrT3JDb250aW51ZTogZnVuY3Rpb24obGFiZWxTZXQpIHtcbiAgICAgICAgdmFyIGJyZWFrU3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjb250aW51ZVN0YXRlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5sYWJlbCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gbmV3IEZhbGxUaHJvdWdoU3RhdGUodGhpcy5pZCwgY29udGludWVTdGF0ZSwgW10pO1xuICAgICAgICBpZiAobGFiZWxTZXQuaGFzKHRoaXMubGFiZWwpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBGYWxsVGhyb3VnaFN0YXRlKHRoaXMuaWQsIGxhYmVsU2V0LmdldCh0aGlzLmxhYmVsKS5jb250aW51ZVN0YXRlLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IENvbnRpbnVlU3RhdGUoKSB7XG4gICAgICByZXR1cm4gQ29udGludWVTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvVHJ5U3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvVHJ5U3RhdGUuanNcIjtcbiAgdmFyIFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9UcnlTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBLaW5kID0ge1xuICAgIENBVENIOiAnY2F0Y2gnLFxuICAgIEZJTkFMTFk6ICdmaW5hbGx5J1xuICB9O1xuICB2YXIgVHJ5U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBUcnlTdGF0ZShraW5kLCB0cnlTdGF0ZXMsIG5lc3RlZFRyeXMpIHtcbiAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICB0aGlzLnRyeVN0YXRlcyA9IHRyeVN0YXRlcztcbiAgICAgIHRoaXMubmVzdGVkVHJ5cyA9IG5lc3RlZFRyeXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUcnlTdGF0ZSwge1xuICAgICAgcmVwbGFjZUFsbFN0YXRlczogZnVuY3Rpb24ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIHJldHVybiBTdGF0ZS5yZXBsYWNlU3RhdGVMaXN0KHRoaXMudHJ5U3RhdGVzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2VOZXN0ZWRUcnlzOiBmdW5jdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmVzdGVkVHJ5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN0YXRlcy5wdXNoKHRoaXMubmVzdGVkVHJ5c1tpXS5yZXBsYWNlU3RhdGUob2xkU3RhdGUsIG5ld1N0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlcztcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgVHJ5U3RhdGUuS2luZCA9IEtpbmQ7XG4gIHJldHVybiB7Z2V0IFRyeVN0YXRlKCkge1xuICAgICAgcmV0dXJuIFRyeVN0YXRlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9TdGF0ZU1hY2hpbmUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvU3RhdGVNYWNoaW5lLmpzXCI7XG4gIHZhciBQYXJzZVRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC90cmVlcy9TdGF0ZU1hY2hpbmUuanNcIikpLlBhcnNlVHJlZTtcbiAgdmFyIFNUQVRFX01BQ0hJTkUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvU3RhdGVNYWNoaW5lLmpzXCIpKS5TVEFURV9NQUNISU5FO1xuICB2YXIgU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvdHJlZXMvU3RhdGVNYWNoaW5lLmpzXCIpKS5TdGF0ZTtcbiAgdmFyIFRyeVN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9UcnlTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L3RyZWVzL1N0YXRlTWFjaGluZS5qc1wiKSkuVHJ5U3RhdGU7XG4gIGZ1bmN0aW9uIGFkZENhdGNoT3JGaW5hbGx5U3RhdGVzKGtpbmQsIGVuY2xvc2luZ01hcCwgdHJ5U3RhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cnlTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cnlTdGF0ZSA9IHRyeVN0YXRlc1tpXTtcbiAgICAgIGlmICh0cnlTdGF0ZS5raW5kID09PSBraW5kKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHJ5U3RhdGUudHJ5U3RhdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGlkID0gdHJ5U3RhdGUudHJ5U3RhdGVzW2pdO1xuICAgICAgICAgIGVuY2xvc2luZ01hcFtpZF0gPSB0cnlTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQ2F0Y2hPckZpbmFsbHlTdGF0ZXMoa2luZCwgZW5jbG9zaW5nTWFwLCB0cnlTdGF0ZS5uZXN0ZWRUcnlzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWRkQWxsQ2F0Y2hTdGF0ZXModHJ5U3RhdGVzLCBjYXRjaGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cnlTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0cnlTdGF0ZSA9IHRyeVN0YXRlc1tpXTtcbiAgICAgIGlmICh0cnlTdGF0ZS5raW5kID09PSBUcnlTdGF0ZS5LaW5kLkNBVENIKSB7XG4gICAgICAgIGNhdGNoZXMucHVzaCh0cnlTdGF0ZSk7XG4gICAgICB9XG4gICAgICBhZGRBbGxDYXRjaFN0YXRlcyh0cnlTdGF0ZS5uZXN0ZWRUcnlzLCBjYXRjaGVzKTtcbiAgICB9XG4gIH1cbiAgdmFyIFN0YXRlTWFjaGluZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVNYWNoaW5lKHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIHN0YXRlcywgZXhjZXB0aW9uQmxvY2tzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTdGF0ZU1hY2hpbmUpLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB0aGlzLnN0YXJ0U3RhdGUgPSBzdGFydFN0YXRlO1xuICAgICAgdGhpcy5mYWxsVGhyb3VnaFN0YXRlID0gZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGVzID0gc3RhdGVzO1xuICAgICAgdGhpcy5leGNlcHRpb25CbG9ja3MgPSBleGNlcHRpb25CbG9ja3M7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTdGF0ZU1hY2hpbmUsIHtcbiAgICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gU1RBVEVfTUFDSElORTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zZm9ybWVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1TdGF0ZU1hY2hpbmUodGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdFN0YXRlTWFjaGluZSh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBnZXRBbGxTdGF0ZUlEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc3RhdGVzW2ldLmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIGdldEVuY2xvc2luZ0ZpbmFsbHlNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5jbG9zaW5nTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgYWRkQ2F0Y2hPckZpbmFsbHlTdGF0ZXMoVHJ5U3RhdGUuS2luZC5GSU5BTExZLCBlbmNsb3NpbmdNYXAsIHRoaXMuZXhjZXB0aW9uQmxvY2tzKTtcbiAgICAgICAgcmV0dXJuIGVuY2xvc2luZ01hcDtcbiAgICAgIH0sXG4gICAgICBhbGxDYXRjaFN0YXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXRjaGVzID0gW107XG4gICAgICAgIGFkZEFsbENhdGNoU3RhdGVzKHRoaXMuZXhjZXB0aW9uQmxvY2tzLCBjYXRjaGVzKTtcbiAgICAgICAgcmV0dXJuIGNhdGNoZXM7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZVN0YXRlSWQ6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZShTdGF0ZS5yZXBsYWNlU3RhdGVJZCh0aGlzLnN0YXJ0U3RhdGUsIG9sZFN0YXRlLCBuZXdTdGF0ZSksIFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuZmFsbFRocm91Z2hTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZUFsbFN0YXRlcyh0aGlzLnN0YXRlcywgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZUFsbFN0YXRlcyh0aGlzLmV4Y2VwdGlvbkJsb2Nrcywgb2xkU3RhdGUsIG5ld1N0YXRlKSk7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZVN0YXJ0U3RhdGU6IGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VTdGF0ZUlkKHRoaXMuc3RhcnRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2VGYWxsVGhyb3VnaFN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU3RhdGVJZCh0aGlzLmZhbGxUaHJvdWdoU3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uKG5leHRNYWNoaW5lKSB7XG4gICAgICAgIHZhciBzdGF0ZXMgPSAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHRoaXMuc3RhdGVzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0TWFjaGluZS5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgb3RoZXJTdGF0ZSA9IG5leHRNYWNoaW5lLnN0YXRlc1tpXTtcbiAgICAgICAgICBzdGF0ZXMucHVzaChvdGhlclN0YXRlLnJlcGxhY2VTdGF0ZShuZXh0TWFjaGluZS5zdGFydFN0YXRlLCB0aGlzLmZhbGxUaHJvdWdoU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXhjZXB0aW9uQmxvY2tzID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZCh0aGlzLmV4Y2VwdGlvbkJsb2Nrcyk7XG4gICAgICAgIGZvciAodmFyIGkkX18xID0gMDsgaSRfXzEgPCBuZXh0TWFjaGluZS5leGNlcHRpb25CbG9ja3MubGVuZ3RoOyBpJF9fMSsrKSB7XG4gICAgICAgICAgdmFyIHRyeVN0YXRlID0gbmV4dE1hY2hpbmUuZXhjZXB0aW9uQmxvY2tzW2kkX18xXTtcbiAgICAgICAgICBleGNlcHRpb25CbG9ja3MucHVzaCh0cnlTdGF0ZS5yZXBsYWNlU3RhdGUobmV4dE1hY2hpbmUuc3RhcnRTdGF0ZSwgdGhpcy5mYWxsVGhyb3VnaFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUodGhpcy5zdGFydFN0YXRlLCBuZXh0TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZXMsIGV4Y2VwdGlvbkJsb2Nrcyk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWUpO1xuICByZXR1cm4ge2dldCBTdGF0ZU1hY2hpbmUoKSB7XG4gICAgICByZXR1cm4gU3RhdGVNYWNoaW5lO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9CcmVha0NvbnRpbnVlVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBCcmVha1N0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQnJlYWtTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0JyZWFrQ29udGludWVUcmFuc2Zvcm1lci5qc1wiKSkuQnJlYWtTdGF0ZTtcbiAgdmFyIENvbnRpbnVlU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Db250aW51ZVN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyLmpzXCIpKS5Db250aW51ZVN0YXRlO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9CcmVha0NvbnRpbnVlVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgU3RhdGVNYWNoaW5lID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9TdGF0ZU1hY2hpbmUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9CcmVha0NvbnRpbnVlVHJhbnNmb3JtZXIuanNcIikpLlN0YXRlTWFjaGluZTtcbiAgZnVuY3Rpb24gc2FmZUdldExhYmVsKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS5uYW1lID8gdHJlZS5uYW1lLnZhbHVlIDogbnVsbDtcbiAgfVxuICB2YXIgQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCcmVha0NvbnRpbnVlVHJhbnNmb3JtZXIoc3RhdGVBbGxvY2F0b3IpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEJyZWFrQ29udGludWVUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQnJlYWtzXyA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlQWxsb2NhdG9yXyA9IHN0YXRlQWxsb2NhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyLCB7XG4gICAgICBhbGxvY2F0ZVN0YXRlXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlQWxsb2NhdG9yXy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICB9LFxuICAgICAgc3RhdGVUb1N0YXRlTWFjaGluZV86IGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBmYWxsVGhyb3VnaFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlXygpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZShuZXdTdGF0ZS5pZCwgZmFsbFRocm91Z2hTdGF0ZSwgW25ld1N0YXRlXSwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUJyZWFrc18gfHwgdHJlZS5uYW1lID8gdGhpcy5zdGF0ZVRvU3RhdGVNYWNoaW5lXyhuZXcgQnJlYWtTdGF0ZSh0aGlzLmFsbG9jYXRlU3RhdGVfKCksIHNhZmVHZXRMYWJlbCh0cmVlKSkpIDogdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVRvU3RhdGVNYWNoaW5lXyhuZXcgQ29udGludWVTdGF0ZSh0aGlzLmFsbG9jYXRlU3RhdGVfKCksIHNhZmVHZXRMYWJlbCh0cmVlKSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybURvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVN0YXRlTWFjaGluZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Td2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1CcmVha3NfO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUJyZWFrc18gPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBCcmVha0NvbnRpbnVlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVN3aXRjaFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUJyZWFrc18gPSBvbGRTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEJyZWFrQ29udGludWVUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ2F0Y2hTdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DYXRjaFN0YXRlLmpzXCI7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ2F0Y2hTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBUcnlTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RyeVN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ2F0Y2hTdGF0ZS5qc1wiKSkuVHJ5U3RhdGU7XG4gIHZhciBDYXRjaFN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDYXRjaFN0YXRlKGlkZW50aWZpZXIsIGNhdGNoU3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGFsbFN0YXRlcywgbmVzdGVkVHJ5cykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQ2F0Y2hTdGF0ZSkuY2FsbCh0aGlzLCBUcnlTdGF0ZS5LaW5kLkNBVENILCBhbGxTdGF0ZXMsIG5lc3RlZFRyeXMpO1xuICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgIHRoaXMuY2F0Y2hTdGF0ZSA9IGNhdGNoU3RhdGU7XG4gICAgICB0aGlzLmZhbGxUaHJvdWdoU3RhdGUgPSBmYWxsVGhyb3VnaFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ2F0Y2hTdGF0ZSwge3JlcGxhY2VTdGF0ZTogZnVuY3Rpb24ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2F0Y2hTdGF0ZSh0aGlzLmlkZW50aWZpZXIsIFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuY2F0Y2hTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5mYWxsVGhyb3VnaFN0YXRlLCBvbGRTdGF0ZSwgbmV3U3RhdGUpLCB0aGlzLnJlcGxhY2VBbGxTdGF0ZXMob2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5yZXBsYWNlTmVzdGVkVHJ5cyhvbGRTdGF0ZSwgbmV3U3RhdGUpKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRyeVN0YXRlKTtcbiAgcmV0dXJuIHtnZXQgQ2F0Y2hTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBDYXRjaFN0YXRlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Db25kaXRpb25hbFN0YXRlLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NvbmRpdGlvbmFsU3RhdGUuanNcIjtcbiAgdmFyIFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Db25kaXRpb25hbFN0YXRlLmpzXCIpKS5TdGF0ZTtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NvbmRpdGlvbmFsU3RhdGUuanNcIikpLFxuICAgICAgY3JlYXRlQmxvY2sgPSAkX18yLmNyZWF0ZUJsb2NrLFxuICAgICAgY3JlYXRlSWZTdGF0ZW1lbnQgPSAkX18yLmNyZWF0ZUlmU3RhdGVtZW50O1xuICB2YXIgcGFyc2VTdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ29uZGl0aW9uYWxTdGF0ZS5qc1wiKSkucGFyc2VTdGF0ZW1lbnRzO1xuICB2YXIgQ29uZGl0aW9uYWxTdGF0ZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxTdGF0ZShpZCwgaWZTdGF0ZSwgZWxzZVN0YXRlLCBjb25kaXRpb24pIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENvbmRpdGlvbmFsU3RhdGUpLmNhbGwodGhpcywgaWQpO1xuICAgICAgdGhpcy5pZlN0YXRlID0gaWZTdGF0ZTtcbiAgICAgIHRoaXMuZWxzZVN0YXRlID0gZWxzZVN0YXRlO1xuICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb25kaXRpb25hbFN0YXRlLCB7XG4gICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsU3RhdGUoU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5pZCwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5pZlN0YXRlLCBvbGRTdGF0ZSwgbmV3U3RhdGUpLCBTdGF0ZS5yZXBsYWNlU3RhdGVJZCh0aGlzLmVsc2VTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5jb25kaXRpb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgbWFjaGluZUVuZFN0YXRlLCByZXBvcnRlcikge1xuICAgICAgICBpZiAoU3RhdGUuaXNGaW5hbGx5RXhpdChlbmNsb3NpbmdGaW5hbGx5LCB0aGlzLmlmU3RhdGUpIHx8IFN0YXRlLmlzRmluYWxseUV4aXQoZW5jbG9zaW5nRmluYWxseSwgdGhpcy5lbHNlU3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVJZlN0YXRlbWVudCh0aGlzLmNvbmRpdGlvbiwgY3JlYXRlQmxvY2soU3RhdGUuZ2VuZXJhdGVKdW1wKGVuY2xvc2luZ0ZpbmFsbHksIHRoaXMuaWZTdGF0ZSkpLCBjcmVhdGVCbG9jayhTdGF0ZS5nZW5lcmF0ZUp1bXAoZW5jbG9zaW5nRmluYWxseSwgdGhpcy5lbHNlU3RhdGUpKSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHguc3RhdGUgPSAoXCIsIFwiKSA/IFwiLCBcIiA6IFwiLCBcIjtcXG4gICAgICAgIGJyZWFrXCJdKSwgdGhpcy5jb25kaXRpb24sIHRoaXMuaWZTdGF0ZSwgdGhpcy5lbHNlU3RhdGUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oU3RhdGUpO1xuICByZXR1cm4ge2dldCBDb25kaXRpb25hbFN0YXRlKCkge1xuICAgICAgcmV0dXJuIENvbmRpdGlvbmFsU3RhdGU7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0ZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0ZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlLmpzXCI7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRmluYWxseUZhbGxUaHJvdWdoU3RhdGUuanNcIikpLlN0YXRlO1xuICB2YXIgRmluYWxseUZhbGxUaHJvdWdoU3RhdGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRmluYWxseUZhbGxUaHJvdWdoU3RhdGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGaW5hbGx5RmFsbFRocm91Z2hTdGF0ZSwge1xuICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaW5hbGx5RmFsbFRocm91Z2hTdGF0ZShTdGF0ZS5yZXBsYWNlU3RhdGVJZCh0aGlzLmlkLCBvbGRTdGF0ZSwgbmV3U3RhdGUpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NYWNoaW5lU3RhdGU6IGZ1bmN0aW9uKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSwgcmVwb3J0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBtYWNoaW5lRW5kU3RhdGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlc2UgYXJlIGdlbmVyYXRlZCBpbiBhZGRGaW5hbGx5RmFsbFRocm91Z2hEaXNwYXRjaGVzJyk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IEZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlKCkge1xuICAgICAgcmV0dXJuIEZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9GaW5hbGx5U3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRmluYWxseVN0YXRlLmpzXCI7XG4gIHZhciBTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRmluYWxseVN0YXRlLmpzXCIpKS5TdGF0ZTtcbiAgdmFyIFRyeVN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVHJ5U3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9GaW5hbGx5U3RhdGUuanNcIikpLlRyeVN0YXRlO1xuICB2YXIgRmluYWxseVN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5U3RhdGUoZmluYWxseVN0YXRlLCBmYWxsVGhyb3VnaFN0YXRlLCBhbGxTdGF0ZXMsIG5lc3RlZFRyeXMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEZpbmFsbHlTdGF0ZSkuY2FsbCh0aGlzLCBUcnlTdGF0ZS5LaW5kLkZJTkFMTFksIGFsbFN0YXRlcywgbmVzdGVkVHJ5cyk7XG4gICAgICB0aGlzLmZpbmFsbHlTdGF0ZSA9IGZpbmFsbHlTdGF0ZTtcbiAgICAgIHRoaXMuZmFsbFRocm91Z2hTdGF0ZSA9IGZhbGxUaHJvdWdoU3RhdGU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGaW5hbGx5U3RhdGUsIHtyZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbmFsbHlTdGF0ZShTdGF0ZS5yZXBsYWNlU3RhdGVJZCh0aGlzLmZpbmFsbHlTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgU3RhdGUucmVwbGFjZVN0YXRlSWQodGhpcy5mYWxsVGhyb3VnaFN0YXRlLCBvbGRTdGF0ZSwgbmV3U3RhdGUpLCB0aGlzLnJlcGxhY2VBbGxTdGF0ZXMob2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5yZXBsYWNlTmVzdGVkVHJ5cyhvbGRTdGF0ZSwgbmV3U3RhdGUpKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRyeVN0YXRlKTtcbiAgcmV0dXJuIHtnZXQgRmluYWxseVN0YXRlKCkge1xuICAgICAgcmV0dXJuIEZpbmFsbHlTdGF0ZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3RhdGVBbGxvY2F0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3RhdGVBbGxvY2F0b3IuanNcIjtcbiAgdmFyIFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9TdGF0ZUFsbG9jYXRvci5qc1wiKSkuU3RhdGU7XG4gIHZhciBTdGF0ZUFsbG9jYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlQWxsb2NhdG9yKCkge1xuICAgICAgdGhpcy5uZXh0U3RhdGVfID0gU3RhdGUuU1RBUlRfU1RBVEUgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3RhdGVBbGxvY2F0b3IsIHthbGxvY2F0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFN0YXRlXysrO1xuICAgICAgfX0sIHt9KTtcbiAgfSgpO1xuICByZXR1cm4ge2dldCBTdGF0ZUFsbG9jYXRvcigpIHtcbiAgICAgIHJldHVybiBTdGF0ZUFsbG9jYXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3dpdGNoU3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvU3dpdGNoU3RhdGUuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Td2l0Y2hTdGF0ZS5qc1wiKSksXG4gICAgICBDYXNlQ2xhdXNlID0gJF9fMi5DYXNlQ2xhdXNlLFxuICAgICAgRGVmYXVsdENsYXVzZSA9ICRfXzIuRGVmYXVsdENsYXVzZSxcbiAgICAgIFN3aXRjaFN0YXRlbWVudCA9ICRfXzIuU3dpdGNoU3RhdGVtZW50O1xuICB2YXIgU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1N3aXRjaFN0YXRlLmpzXCIpKS5TdGF0ZTtcbiAgdmFyIGNyZWF0ZUJyZWFrU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Td2l0Y2hTdGF0ZS5qc1wiKSkuY3JlYXRlQnJlYWtTdGF0ZW1lbnQ7XG4gIHZhciBTd2l0Y2hDbGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hDbGF1c2UoZmlyc3QsIHNlY29uZCkge1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTd2l0Y2hDbGF1c2UsIHt9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIFN3aXRjaFN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hTdGF0ZShpZCwgZXhwcmVzc2lvbiwgY2xhdXNlcykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3dpdGNoU3RhdGUpLmNhbGwodGhpcywgaWQpO1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIHRoaXMuY2xhdXNlcyA9IGNsYXVzZXM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTd2l0Y2hTdGF0ZSwge1xuICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgdmFyIGNsYXVzZXMgPSB0aGlzLmNsYXVzZXMubWFwKGZ1bmN0aW9uKGNsYXVzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU3dpdGNoQ2xhdXNlKGNsYXVzZS5maXJzdCwgU3RhdGUucmVwbGFjZVN0YXRlSWQoY2xhdXNlLnNlY29uZCwgb2xkU3RhdGUsIG5ld1N0YXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFN3aXRjaFN0YXRlKFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSksIHRoaXMuZXhwcmVzc2lvbiwgY2xhdXNlcyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihlbmNsb3NpbmdGaW5hbGx5LCBtYWNoaW5lRW5kU3RhdGUsIHJlcG9ydGVyKSB7XG4gICAgICAgIHZhciBjbGF1c2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbGF1c2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuY2xhdXNlc1tpXTtcbiAgICAgICAgICBpZiAoY2xhdXNlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjbGF1c2VzLnB1c2gobmV3IERlZmF1bHRDbGF1c2UobnVsbCwgU3RhdGUuZ2VuZXJhdGVKdW1wKGVuY2xvc2luZ0ZpbmFsbHksIGNsYXVzZS5zZWNvbmQpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXVzZXMucHVzaChuZXcgQ2FzZUNsYXVzZShudWxsLCBjbGF1c2UuZmlyc3QsIFN0YXRlLmdlbmVyYXRlSnVtcChlbmNsb3NpbmdGaW5hbGx5LCBjbGF1c2Uuc2Vjb25kKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ldyBTd2l0Y2hTdGF0ZW1lbnQobnVsbCwgdGhpcy5leHByZXNzaW9uLCBjbGF1c2VzKSwgY3JlYXRlQnJlYWtTdGF0ZW1lbnQoKV07XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IFN3aXRjaENsYXVzZSgpIHtcbiAgICAgIHJldHVybiBTd2l0Y2hDbGF1c2U7XG4gICAgfSxcbiAgICBnZXQgU3dpdGNoU3RhdGUoKSB7XG4gICAgICByZXR1cm4gU3dpdGNoU3RhdGU7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0hvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Ib2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX18xID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Ib2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFub25CbG9jayA9ICRfXzEuQW5vbkJsb2NrLFxuICAgICAgQ2F0Y2ggPSAkX18xLkNhdGNoLFxuICAgICAgRnVuY3Rpb25Cb2R5ID0gJF9fMS5GdW5jdGlvbkJvZHksXG4gICAgICBGb3JJblN0YXRlbWVudCA9ICRfXzEuRm9ySW5TdGF0ZW1lbnQsXG4gICAgICBGb3JPZlN0YXRlbWVudCA9ICRfXzEuRm9yT2ZTdGF0ZW1lbnQsXG4gICAgICBGb3JTdGF0ZW1lbnQgPSAkX18xLkZvclN0YXRlbWVudCxcbiAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gJF9fMS5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIFZhcmlhYmxlU3RhdGVtZW50ID0gJF9fMS5WYXJpYWJsZVN0YXRlbWVudDtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0hvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgT0JKRUNUX1BBVFRFUk4gPSAkX18yLk9CSkVDVF9QQVRURVJOLFxuICAgICAgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCA9ICRfXzIuVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVDtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0hvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Ib2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLmpzXCIpKS5TdHJpbmdTZXQ7XG4gIHZhciBWQVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lci5qc1wiKSkuVkFSO1xuICB2YXIgJF9fNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0hvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24gPSAkX182LmNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlQ29tbWFFeHByZXNzaW9uID0gJF9fNi5jcmVhdGVDb21tYUV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50ID0gJF9fNi5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50LFxuICAgICAgaWQgPSAkX182LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fNi5jcmVhdGVQYXJlbkV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fNi5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uO1xuICB2YXIgcHJlcGVuZFN0YXRlbWVudHMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QcmVwZW5kU3RhdGVtZW50cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lci5qc1wiKSkucHJlcGVuZFN0YXRlbWVudHM7XG4gIHZhciBIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyKCkge1xuICAgICAgdmFyIHNob3VsZEhvaXN0RnVuY3Rpb25zID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaG9pc3RlZEZ1bmN0aW9uc18gPSBbXTtcbiAgICAgIHRoaXMuaG9pc3RlZFZhcmlhYmxlc18gPSBuZXcgU3RyaW5nU2V0KCk7XG4gICAgICB0aGlzLmtlZXBCaW5kaW5nSWRlbnRpZmllcnNfID0gZmFsc2U7XG4gICAgICB0aGlzLmluQmxvY2tPckZvcl8gPSBmYWxzZTtcbiAgICAgIHRoaXMuc2hvdWxkSG9pc3RGdW5jdGlvbnNfID0gc2hvdWxkSG9pc3RGdW5jdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkJvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5zdGF0ZW1lbnRzKTtcbiAgICAgICAgaWYgKHN0YXRlbWVudHMgPT09IHRyZWUuc3RhdGVtZW50cylcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgc3RhdGVtZW50cyA9IHRoaXMucHJlcGVuZFZhcmlhYmxlcyhzdGF0ZW1lbnRzKTtcbiAgICAgICAgc3RhdGVtZW50cyA9IHRoaXMucHJlcGVuZEZ1bmN0aW9ucyhzdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJvZHkodHJlZS5sb2NhdGlvbiwgc3RhdGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgYWRkVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5ob2lzdGVkVmFyaWFibGVzXy5hZGQobmFtZSk7XG4gICAgICB9LFxuICAgICAgYWRkRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmhvaXN0ZWRGdW5jdGlvbnNfLnB1c2godHJlZSk7XG4gICAgICB9LFxuICAgICAgaGFzVmFyaWFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhvaXN0ZWRWYXJpYWJsZXNfLmlzRW1wdHkoKTtcbiAgICAgIH0sXG4gICAgICBoYXNGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob2lzdGVkRnVuY3Rpb25zXy5sZW5ndGggPiAwO1xuICAgICAgfSxcbiAgICAgIGdldFZhcmlhYmxlTmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob2lzdGVkVmFyaWFibGVzXy52YWx1ZXNBc0FycmF5KCk7XG4gICAgICB9LFxuICAgICAgZ2V0VmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFyaWFibGVzKCkpXG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5nZXRWYXJpYWJsZU5hbWVzKCkubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihuYW1lLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVTdGF0ZW1lbnQobnVsbCwgbmV3IFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KG51bGwsIFZBUiwgZGVjbGFyYXRpb25zKSk7XG4gICAgICB9LFxuICAgICAgZ2V0RnVuY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9pc3RlZEZ1bmN0aW9uc187XG4gICAgICB9LFxuICAgICAgcHJlcGVuZFZhcmlhYmxlczogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFyaWFibGVzKCkpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIHJldHVybiBwcmVwZW5kU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCB0aGlzLmdldFZhcmlhYmxlU3RhdGVtZW50KCkpO1xuICAgICAgfSxcbiAgICAgIHByZXBlbmRGdW5jdGlvbnM6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0Z1bmN0aW9ucygpKVxuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICByZXR1cm4gcHJlcGVuZFN0YXRlbWVudHMoc3RhdGVtZW50cywgdGhpcy5nZXRGdW5jdGlvbkRlY2xhcmF0aW9ucygpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1WYXJpYWJsZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zID09PSB0cmVlLmRlY2xhcmF0aW9ucylcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBbXSk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMudHlwZSA9PT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVClcbiAgICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGRlY2xhcmF0aW9ucyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGRlY2xhcmF0aW9ucyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbHZhbHVlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sdmFsdWUpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsdmFsdWUsIGluaXRpYWxpemVyKTtcbiAgICAgICAgICBpZiAobHZhbHVlLnR5cGUgPT09IE9CSkVDVF9QQVRURVJOKVxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1PYmplY3RQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBrZWVwQmluZGluZ0lkZW50aWZpZXJzID0gdGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXztcbiAgICAgICAgdGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXyA9IHRydWU7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1PYmplY3RQYXR0ZXJuXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHRoaXMua2VlcEJpbmRpbmdJZGVudGlmaWVyc18gPSBrZWVwQmluZGluZ0lkZW50aWZpZXJzO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXJyYXlQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBrZWVwQmluZGluZ0lkZW50aWZpZXJzID0gdGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXztcbiAgICAgICAgdGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXyA9IHRydWU7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1BcnJheVBhdHRlcm5cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXyA9IGtlZXBCaW5kaW5nSWRlbnRpZmllcnM7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5kaW5nSWRlbnRpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgaWRUb2tlbiA9IHRyZWUuaWRlbnRpZmllclRva2VuO1xuICAgICAgICB0aGlzLmFkZFZhcmlhYmxlKGlkVG9rZW4udmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5rZWVwQmluZGluZ0lkZW50aWZpZXJzXylcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgcmV0dXJuIGlkKGlkVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmRlY2xhcmF0aW9uVHlwZSA9PT0gVkFSIHx8ICF0aGlzLmluQmxvY2tPckZvcl8pIHtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgICAgIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuZmlsdGVyKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNhdGNoOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBjYXRjaEJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNhdGNoQm9keSk7XG4gICAgICAgIGlmIChjYXRjaEJvZHkgPT09IHRyZWUuY2F0Y2hCb2R5KVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICByZXR1cm4gbmV3IENhdGNoKHRyZWUubG9jYXRpb24sIHRyZWUuYmluZGluZywgY2F0Y2hCb2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1Mb29wXyh0cmVlLCBGb3JJblN0YXRlbWVudCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTG9vcF8odHJlZSwgRm9yT2ZTdGF0ZW1lbnQpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvck9uU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUxvb3BfKHRyZWUsIEZvck9mU3RhdGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Mb29wXzogZnVuY3Rpb24odHJlZSwgY3Rvcikge1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUxvb3BJbmluaXRhbGlzZXJfKHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY29sbGVjdGlvbik7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyICYmIGNvbGxlY3Rpb24gPT09IHRyZWUuY29sbGVjdGlvbiAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGN0b3IodHJlZS5sb2NhdGlvbiwgaW5pdGlhbGl6ZXIsIGNvbGxlY3Rpb24sIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxvb3BJbmluaXRhbGlzZXJfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLnR5cGUgIT09IFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgfHwgdHJlZS5kZWNsYXJhdGlvblR5cGUgIT09IFZBUilcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb25zWzBdLmx2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbkJsb2NrT3JGb3IgPSB0aGlzLmluQmxvY2tPckZvcl87XG4gICAgICAgIHRoaXMuaW5CbG9ja09yRm9yXyA9IHRydWU7XG4gICAgICAgIHZhciBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB0aGlzLmluQmxvY2tPckZvcl8gPSBpbkJsb2NrT3JGb3I7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmluY3JlbWVudCk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKGluaXRpYWxpemVyID09PSB0cmVlLmluaXRpYWxpemVyICYmIGNvbmRpdGlvbiA9PT0gdHJlZS5jb25kaXRpb24gJiYgaW5jcmVtZW50ID09PSB0cmVlLmluY3JlbWVudCAmJiBib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvclN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBpbml0aWFsaXplciwgY29uZGl0aW9uLCBpbmNyZW1lbnQsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJsb2NrOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbkJsb2NrT3JGb3IgPSB0aGlzLmluQmxvY2tPckZvcl87XG4gICAgICAgIHRoaXMuaW5CbG9ja09yRm9yXyA9IHRydWU7XG4gICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtQmxvY2tcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdGhpcy5pbkJsb2NrT3JGb3JfID0gaW5CbG9ja09yRm9yO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICBhZGRNYWNoaW5lVmFyaWFibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5tYWNoaW5lVmFyaWFibGVzX1tuYW1lXSA9IHRydWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRIb2lzdEZ1bmN0aW9uc18pIHtcbiAgICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uRGVjbGFyYXRpb24odHJlZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1HZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXJyb3dGdW5jdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db21wcmVoZW5zaW9uRm9yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICB2YXIgJF9fZGVmYXVsdCA9IEhvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXI7XG4gIHJldHVybiB7Z2V0IGRlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gJF9fZGVmYXVsdDtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEFscGhhUmVuYW1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9BbHBoYVJlbmFtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuQWxwaGFSZW5hbWVyO1xuICB2YXIgQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQnJlYWtDb250aW51ZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLkJyZWFrQ29udGludWVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzE5ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQkxPQ0sgPSAkX18xOS5CTE9DSyxcbiAgICAgIENBU0VfQ0xBVVNFID0gJF9fMTkuQ0FTRV9DTEFVU0UsXG4gICAgICBDT05ESVRJT05BTF9FWFBSRVNTSU9OID0gJF9fMTkuQ09ORElUSU9OQUxfRVhQUkVTU0lPTixcbiAgICAgIEVYUFJFU1NJT05fU1RBVEVNRU5UID0gJF9fMTkuRVhQUkVTU0lPTl9TVEFURU1FTlQsXG4gICAgICBQQVJFTl9FWFBSRVNTSU9OID0gJF9fMTkuUEFSRU5fRVhQUkVTU0lPTixcbiAgICAgIFNUQVRFX01BQ0hJTkUgPSAkX18xOS5TVEFURV9NQUNISU5FO1xuICB2YXIgJF9fMjAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBbm9uQmxvY2sgPSAkX18yMC5Bbm9uQmxvY2ssXG4gICAgICBCbG9jayA9ICRfXzIwLkJsb2NrLFxuICAgICAgQ2FzZUNsYXVzZSA9ICRfXzIwLkNhc2VDbGF1c2UsXG4gICAgICBJZlN0YXRlbWVudCA9ICRfXzIwLklmU3RhdGVtZW50LFxuICAgICAgU3dpdGNoU3RhdGVtZW50ID0gJF9fMjAuU3dpdGNoU3RhdGVtZW50O1xuICB2YXIgQ2F0Y2hTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0NhdGNoU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuQ2F0Y2hTdGF0ZTtcbiAgdmFyIENvbmRpdGlvbmFsU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Db25kaXRpb25hbFN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLkNvbmRpdGlvbmFsU3RhdGU7XG4gIHZhciBFeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL0V4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgdmFyIEZhbGxUaHJvdWdoU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GYWxsVGhyb3VnaFN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLkZhbGxUaHJvdWdoU3RhdGU7XG4gIHZhciBGaW5hbGx5RmFsbFRocm91Z2hTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLkZpbmFsbHlGYWxsVGhyb3VnaFN0YXRlO1xuICB2YXIgRmluYWxseVN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmluYWxseVN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLkZpbmFsbHlTdGF0ZTtcbiAgdmFyIEZpbmRJbkZ1bmN0aW9uU2NvcGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vRmluZEluRnVuY3Rpb25TY29wZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NQU1RyYW5zZm9ybWVyLmpzXCIpKS5GaW5kSW5GdW5jdGlvblNjb3BlO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBTdHJpbmdNYXAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vdXRpbC9TdHJpbmdNYXAuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuU3RyaW5nTWFwO1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NQU1RyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuYXNzZXJ0O1xuICB2YXIgJF9fMzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX18zMi5wYXJzZUV4cHJlc3Npb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzMyLnBhcnNlU3RhdGVtZW50LFxuICAgICAgcGFyc2VTdGF0ZW1lbnRzID0gJF9fMzIucGFyc2VTdGF0ZW1lbnRzO1xuICB2YXIgU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NQU1RyYW5zZm9ybWVyLmpzXCIpKS5TdGF0ZTtcbiAgdmFyIFN0YXRlQWxsb2NhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RhdGVBbGxvY2F0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuU3RhdGVBbGxvY2F0b3I7XG4gIHZhciBTdGF0ZU1hY2hpbmUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L3RyZWVzL1N0YXRlTWFjaGluZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NQU1RyYW5zZm9ybWVyLmpzXCIpKS5TdGF0ZU1hY2hpbmU7XG4gIHZhciAkX18zNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N3aXRjaFN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgU3dpdGNoQ2xhdXNlID0gJF9fMzYuU3dpdGNoQ2xhdXNlLFxuICAgICAgU3dpdGNoU3RhdGUgPSAkX18zNi5Td2l0Y2hTdGF0ZTtcbiAgdmFyIFRyeVN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVHJ5U3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9DUFNUcmFuc2Zvcm1lci5qc1wiKSkuVHJ5U3RhdGU7XG4gIHZhciAkX18zOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQ1BTVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWduU3RhdGVTdGF0ZW1lbnQgPSAkX18zOC5jcmVhdGVBc3NpZ25TdGF0ZVN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUJyZWFrU3RhdGVtZW50ID0gJF9fMzguY3JlYXRlQnJlYWtTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVDYXNlQ2xhdXNlID0gJF9fMzguY3JlYXRlQ2FzZUNsYXVzZSxcbiAgICAgIGNyZWF0ZURlZmF1bHRDbGF1c2UgPSAkX18zOC5jcmVhdGVEZWZhdWx0Q2xhdXNlLFxuICAgICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzM4LmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18zOC5jcmVhdGVGdW5jdGlvbkJvZHksXG4gICAgICBpZCA9ICRfXzM4LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzM4LmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdW1iZXJMaXRlcmFsID0gJF9fMzguY3JlYXRlTnVtYmVyTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZVN3aXRjaFN0YXRlbWVudCA9ICRfXzM4LmNyZWF0ZVN3aXRjaFN0YXRlbWVudDtcbiAgdmFyIEhvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0NQU1RyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgTGFiZWxTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExhYmVsU3RhdGUobmFtZSwgY29udGludWVTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuY29udGludWVTdGF0ZSA9IGNvbnRpbnVlU3RhdGU7XG4gICAgICB0aGlzLmZhbGxUaHJvdWdoU3RhdGUgPSBmYWxsVGhyb3VnaFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTGFiZWxTdGF0ZSwge30sIHt9KTtcbiAgfSgpO1xuICB2YXIgTmVlZHNTdGF0ZU1hY2hpbmUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIE5lZWRzU3RhdGVNYWNoaW5lKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTmVlZHNTdGF0ZU1hY2hpbmUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShOZWVkc1N0YXRlTWFjaGluZSwge1xuICAgICAgdmlzaXRCcmVha1N0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U3RhdGVNYWNoaW5lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgfSxcbiAgICAgIHZpc2l0WWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbih0ZWUpIHtcbiAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShGaW5kSW5GdW5jdGlvblNjb3BlKTtcbiAgZnVuY3Rpb24gbmVlZHNTdGF0ZU1hY2hpbmUodHJlZSkge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IE5lZWRzU3RhdGVNYWNoaW5lKCk7XG4gICAgdmlzaXRvci52aXNpdEFueSh0cmVlKTtcbiAgICByZXR1cm4gdmlzaXRvci5mb3VuZDtcbiAgfVxuICB2YXIgSG9pc3RWYXJpYWJsZXMgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEhvaXN0VmFyaWFibGVzKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSG9pc3RWYXJpYWJsZXMpLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShIb2lzdFZhcmlhYmxlcywge1xuICAgICAgcHJlcGVuZFZhcmlhYmxlczogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgIH0sXG4gICAgICBwcmVwZW5kRnVuY3Rpb25zOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcik7XG4gIHZhciBDUFNUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ1BTVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENQU1RyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc3RhdGVBbGxvY2F0b3JfID0gbmV3IFN0YXRlQWxsb2NhdG9yKCk7XG4gICAgICB0aGlzLmxhYmVsU2V0XyA9IG5ldyBTdHJpbmdNYXAoKTtcbiAgICAgIHRoaXMuY3VycmVudExhYmVsXyA9IG51bGw7XG4gICAgICB0aGlzLmhvaXN0VmFyaWFibGVzVHJhbnNmb3JtZXJfID0gbmV3IEhvaXN0VmFyaWFibGVzKCk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDUFNUcmFuc2Zvcm1lciwge1xuICAgICAgZXhwcmVzc2lvbk5lZWRzU3RhdGVNYWNoaW5lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBhbGxvY2F0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVBbGxvY2F0b3JfLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNfKCk7XG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMuY2xlYXJDdXJyZW50TGFiZWxfKCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJsb2NrXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBtYWNoaW5lID0gdGhpcy50cmFuc2Zvcm1TdGF0ZW1lbnRMaXN0Xyh0cmFuc2Zvcm1lZFRyZWUuc3RhdGVtZW50cyk7XG4gICAgICAgIGlmIChtYWNoaW5lID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFRyZWU7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hY2hpbmUuc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBtYWNoaW5lLnN0YXRlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN0YXRlLnRyYW5zZm9ybUJyZWFrT3JDb250aW51ZShsYWJlbHMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUobWFjaGluZS5zdGFydFN0YXRlLCBtYWNoaW5lLmZhbGxUaHJvdWdoU3RhdGUsIHN0YXRlcywgbWFjaGluZS5leGNlcHRpb25CbG9ja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWNoaW5lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnB1c2hUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIG9sZExhYmVscyA9IHRoaXMuY2xlYXJMYWJlbHNfKCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uQm9keVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgbWFjaGluZSA9IHRoaXMudHJhbnNmb3JtU3RhdGVtZW50TGlzdF8odHJhbnNmb3JtZWRUcmVlLnN0YXRlbWVudHMpO1xuICAgICAgICB0aGlzLnJlc3RvcmVMYWJlbHNfKG9sZExhYmVscyk7XG4gICAgICAgIHRoaXMucG9wVGVtcFNjb3BlKCk7XG4gICAgICAgIHJldHVybiBtYWNoaW5lID09PSBudWxsID8gdHJhbnNmb3JtZWRUcmVlIDogbWFjaGluZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TdGF0ZW1lbnRMaXN0XzogZnVuY3Rpb24odHJlZXMpIHtcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICB2YXIgbmV3TWFjaGluZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0cmVlc1tpXS50eXBlID09PSBTVEFURV9NQUNISU5FKSB7XG4gICAgICAgICAgICBncm91cHMucHVzaCh0cmVlc1tpXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZWVkc1N0YXRlTWFjaGluZSh0cmVlc1tpXSkpIHtcbiAgICAgICAgICAgIG5ld01hY2hpbmUgPSB0aGlzLmVuc3VyZVRyYW5zZm9ybWVkXyh0cmVlc1tpXSk7XG4gICAgICAgICAgICBncm91cHMucHVzaChuZXdNYWNoaW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKCEobGFzdCBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgZ3JvdXBzLnB1c2gobGFzdCA9IFtdKTtcbiAgICAgICAgICAgIGxhc3QucHVzaCh0cmVlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAxICYmIGdyb3Vwc1swXSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbWFjaGluZSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkkX18xMSA9IDA7IGkkX18xMSA8IGdyb3Vwcy5sZW5ndGg7IGkkX18xMSsrKSB7XG4gICAgICAgICAgaWYgKGdyb3Vwc1tpJF9fMTFdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIG5ld01hY2hpbmUgPSB0aGlzLnN0YXRlbWVudHNUb1N0YXRlTWFjaGluZV8oZ3JvdXBzW2kkX18xMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdNYWNoaW5lID0gZ3JvdXBzW2kkX18xMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpJF9fMTEgPT09IDApXG4gICAgICAgICAgICBtYWNoaW5lID0gbmV3TWFjaGluZTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYWNoaW5lID0gbWFjaGluZS5hcHBlbmQobmV3TWFjaGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hY2hpbmU7XG4gICAgICB9LFxuICAgICAgbmVlZHNTdGF0ZU1hY2hpbmVfOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmIChzdGF0ZW1lbnRzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWVkc1N0YXRlTWFjaGluZShzdGF0ZW1lbnRzW2ldKSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQoc3RhdGVtZW50cyBpbnN0YW5jZW9mIFN3aXRjaFN0YXRlbWVudCk7XG4gICAgICAgIHJldHVybiBuZWVkc1N0YXRlTWFjaGluZShzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYXNlQ2xhdXNlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUNhc2VDbGF1c2VcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyIG1hY2hpbmUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlbWVudExpc3RfKHJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIG1hY2hpbmUgPT09IG51bGwgPyByZXN1bHQgOiBuZXcgQ2FzZUNsYXVzZShudWxsLCByZXN1bHQuZXhwcmVzc2lvbiwgW21hY2hpbmVdKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Eb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX184O1xuICAgICAgICB2YXIgJF9fNixcbiAgICAgICAgICAgICRfXzc7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc18oKTtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5jbGVhckN1cnJlbnRMYWJlbF8oKTtcbiAgICAgICAgdmFyIG1hY2hpbmUsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICBib2R5O1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUodHJlZS5jb25kaXRpb24pKSB7XG4gICAgICAgICAgKCgkX182ID0gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUodHJlZS5jb25kaXRpb24pLCBtYWNoaW5lID0gJF9fNi5tYWNoaW5lLCBjb25kaXRpb24gPSAkX182LmV4cHJlc3Npb24sICRfXzYpKTtcbiAgICAgICAgICBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENQU1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Eb1doaWxlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgICAgKCgkX183ID0gcmVzdWx0LCBjb25kaXRpb24gPSAkX183LmNvbmRpdGlvbiwgYm9keSA9ICRfXzcuYm9keSwgJF9fNykpO1xuICAgICAgICAgIGlmIChib2R5LnR5cGUgIT09IFNUQVRFX01BQ0hJTkUpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29wQm9keU1hY2hpbmUgPSB0aGlzLmVuc3VyZVRyYW5zZm9ybWVkXyhib2R5KTtcbiAgICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBsb29wQm9keU1hY2hpbmUuc3RhcnRTdGF0ZTtcbiAgICAgICAgdmFyIGNvbmRpdGlvblN0YXRlID0gbG9vcEJvZHlNYWNoaW5lLmZhbGxUaHJvdWdoU3RhdGU7XG4gICAgICAgIHZhciBmYWxsVGhyb3VnaFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRMb29wQm9keVN0YXRlc18obG9vcEJvZHlNYWNoaW5lLCBjb25kaXRpb25TdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgbGFiZWxzLCBzdGF0ZXMpO1xuICAgICAgICBpZiAobWFjaGluZSkge1xuICAgICAgICAgIG1hY2hpbmUgPSBtYWNoaW5lLnJlcGxhY2VTdGFydFN0YXRlKGNvbmRpdGlvblN0YXRlKTtcbiAgICAgICAgICBjb25kaXRpb25TdGF0ZSA9IG1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgICAoJF9fOCA9IHN0YXRlcykucHVzaC5hcHBseSgkX184LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKG1hY2hpbmUuc3RhdGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVzLnB1c2gobmV3IENvbmRpdGlvbmFsU3RhdGUoY29uZGl0aW9uU3RhdGUsIHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGNvbmRpdGlvbikpO1xuICAgICAgICBtYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShzdGFydFN0YXRlLCBmYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZXMsIGxvb3BCb2R5TWFjaGluZS5leGNlcHRpb25CbG9ja3MpO1xuICAgICAgICBpZiAobGFiZWwpXG4gICAgICAgICAgbWFjaGluZSA9IG1hY2hpbmUucmVwbGFjZVN0YXRlSWQoY29uZGl0aW9uU3RhdGUsIGxhYmVsLmNvbnRpbnVlU3RhdGUpO1xuICAgICAgICByZXR1cm4gbWFjaGluZTtcbiAgICAgIH0sXG4gICAgICBhZGRMb29wQm9keVN0YXRlc186IGZ1bmN0aW9uKGxvb3BCb2R5TWFjaGluZSwgY29udGludWVTdGF0ZSwgYnJlYWtTdGF0ZSwgbGFiZWxzLCBzdGF0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29wQm9keU1hY2hpbmUuc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbG9vcEJvZHlNYWNoaW5lLnN0YXRlc1tpXTtcbiAgICAgICAgICBzdGF0ZXMucHVzaChzdGF0ZS50cmFuc2Zvcm1CcmVha09yQ29udGludWUobGFiZWxzLCBicmVha1N0YXRlLCBjb250aW51ZVN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzgsXG4gICAgICAgICAgICAkX185LFxuICAgICAgICAgICAgJF9fMTA7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc18oKTtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5jbGVhckN1cnJlbnRMYWJlbF8oKTtcbiAgICAgICAgdmFyIHRtcDtcbiAgICAgICAgdmFyIGluaXRpYWxpemVyID0gbnVsbCxcbiAgICAgICAgICAgIGluaXRpYWxpemVyTWFjaGluZTtcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUodHJlZS5pbml0aWFsaXplcikpIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZXhwcmVzc2lvblRvU3RhdGVNYWNoaW5lKHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZXIgPSB0bXAuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGluaXRpYWxpemVyTWFjaGluZSA9IHRtcC5tYWNoaW5lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplciA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uZGl0aW9uID0gbnVsbCxcbiAgICAgICAgICAgIGNvbmRpdGlvbk1hY2hpbmU7XG4gICAgICAgIGlmICh0cmVlLmNvbmRpdGlvbikge1xuICAgICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25OZWVkc1N0YXRlTWFjaGluZSh0cmVlLmNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZXhwcmVzc2lvblRvU3RhdGVNYWNoaW5lKHRyZWUuY29uZGl0aW9uKTtcbiAgICAgICAgICAgIGNvbmRpdGlvbiA9IHRtcC5leHByZXNzaW9uO1xuICAgICAgICAgICAgY29uZGl0aW9uTWFjaGluZSA9IHRtcC5tYWNoaW5lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25kaXRpb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSBudWxsLFxuICAgICAgICAgICAgaW5jcmVtZW50TWFjaGluZTtcbiAgICAgICAgaWYgKHRyZWUuaW5jcmVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbk5lZWRzU3RhdGVNYWNoaW5lKHRyZWUuaW5jcmVtZW50KSkge1xuICAgICAgICAgICAgdG1wID0gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUodHJlZS5pbmNyZW1lbnQpO1xuICAgICAgICAgICAgaW5jcmVtZW50ID0gdG1wLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpbmNyZW1lbnRNYWNoaW5lID0gdG1wLm1hY2hpbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluY3JlbWVudCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW5jcmVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJvZHkpO1xuICAgICAgICBpZiAoaW5pdGlhbGl6ZXIgPT09IHRyZWUuaW5pdGlhbGl6ZXIgJiYgY29uZGl0aW9uID09PSB0cmVlLmNvbmRpdGlvbiAmJiBpbmNyZW1lbnQgPT09IHRyZWUuaW5jcmVtZW50ICYmIGJvZHkgPT09IHRyZWUuYm9keSkge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZXJNYWNoaW5lICYmICFjb25kaXRpb25NYWNoaW5lICYmICFpbmNyZW1lbnRNYWNoaW5lICYmIGJvZHkudHlwZSAhPT0gU1RBVEVfTUFDSElORSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRm9yU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGluaXRpYWxpemVyLCBjb25kaXRpb24sIGluY3JlbWVudCwgYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvb3BCb2R5TWFjaGluZSA9IHRoaXMuZW5zdXJlVHJhbnNmb3JtZWRfKGJvZHkpO1xuICAgICAgICB2YXIgYm9keUZhbGxUaHJvdWdoSWQgPSBsb29wQm9keU1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgdmFyIGZhbGxUaHJvdWdoSWQgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXJ0SWQ7XG4gICAgICAgIHZhciBpbml0aWFsaXplclN0YXJ0SWQgPSBpbml0aWFsaXplciA/IHRoaXMuYWxsb2NhdGVTdGF0ZSgpIDogU3RhdGUuSU5WQUxJRF9TVEFURTtcbiAgICAgICAgdmFyIGNvbmRpdGlvblN0YXJ0SWQgPSBpbmNyZW1lbnQgPyB0aGlzLmFsbG9jYXRlU3RhdGUoKSA6IGJvZHlGYWxsVGhyb3VnaElkO1xuICAgICAgICB2YXIgbG9vcFN0YXJ0SWQgPSBsb29wQm9keU1hY2hpbmUuc3RhcnRTdGF0ZTtcbiAgICAgICAgdmFyIGluY3JlbWVudFN0YXJ0SWQgPSBib2R5RmFsbFRocm91Z2hJZDtcbiAgICAgICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgICAgICBpZiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICBzdGFydElkID0gaW5pdGlhbGl6ZXJTdGFydElkO1xuICAgICAgICAgIHZhciBpbml0aWFsaXNlckZhbGxUaHJvdWdoSWQ7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbilcbiAgICAgICAgICAgIGluaXRpYWxpc2VyRmFsbFRocm91Z2hJZCA9IGNvbmRpdGlvblN0YXJ0SWQ7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaW5pdGlhbGlzZXJGYWxsVGhyb3VnaElkID0gbG9vcFN0YXJ0SWQ7XG4gICAgICAgICAgdmFyIHRtcElkID0gaW5pdGlhbGl6ZXJTdGFydElkO1xuICAgICAgICAgIGlmIChpbml0aWFsaXplck1hY2hpbmUpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVyTWFjaGluZSA9IGluaXRpYWxpemVyTWFjaGluZS5yZXBsYWNlU3RhcnRTdGF0ZShpbml0aWFsaXplclN0YXJ0SWQpO1xuICAgICAgICAgICAgdG1wSWQgPSBpbml0aWFsaXplck1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgICAgICgkX184ID0gc3RhdGVzKS5wdXNoLmFwcGx5KCRfXzgsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoaW5pdGlhbGl6ZXJNYWNoaW5lLnN0YXRlcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZXMucHVzaChuZXcgRmFsbFRocm91Z2hTdGF0ZSh0bXBJZCwgaW5pdGlhbGlzZXJGYWxsVGhyb3VnaElkLCBbY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChpbml0aWFsaXplcildKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIGlmICghaW5pdGlhbGl6ZXIpXG4gICAgICAgICAgICBzdGFydElkID0gY29uZGl0aW9uU3RhcnRJZDtcbiAgICAgICAgICB2YXIgdG1wSWQkX18xMiA9IGNvbmRpdGlvblN0YXJ0SWQ7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbk1hY2hpbmUpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbk1hY2hpbmUgPSBjb25kaXRpb25NYWNoaW5lLnJlcGxhY2VTdGFydFN0YXRlKGNvbmRpdGlvblN0YXJ0SWQpO1xuICAgICAgICAgICAgdG1wSWQkX18xMiA9IGNvbmRpdGlvbk1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgICAgICgkX185ID0gc3RhdGVzKS5wdXNoLmFwcGx5KCRfXzksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoY29uZGl0aW9uTWFjaGluZS5zdGF0ZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdGVzLnB1c2gobmV3IENvbmRpdGlvbmFsU3RhdGUodG1wSWQkX18xMiwgbG9vcFN0YXJ0SWQsIGZhbGxUaHJvdWdoSWQsIGNvbmRpdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNyZW1lbnQpIHtcbiAgICAgICAgICB2YXIgaW5jcmVtZW50RmFsbFRocm91Z2hJZDtcbiAgICAgICAgICBpZiAoY29uZGl0aW9uKVxuICAgICAgICAgICAgaW5jcmVtZW50RmFsbFRocm91Z2hJZCA9IGNvbmRpdGlvblN0YXJ0SWQ7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaW5jcmVtZW50RmFsbFRocm91Z2hJZCA9IGxvb3BTdGFydElkO1xuICAgICAgICAgIHZhciB0bXBJZCRfXzEzID0gaW5jcmVtZW50U3RhcnRJZDtcbiAgICAgICAgICBpZiAoaW5jcmVtZW50TWFjaGluZSkge1xuICAgICAgICAgICAgaW5jcmVtZW50TWFjaGluZSA9IGluY3JlbWVudE1hY2hpbmUucmVwbGFjZVN0YXJ0U3RhdGUoaW5jcmVtZW50U3RhcnRJZCk7XG4gICAgICAgICAgICB0bXBJZCRfXzEzID0gaW5jcmVtZW50TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlO1xuICAgICAgICAgICAgKCRfXzEwID0gc3RhdGVzKS5wdXNoLmFwcGx5KCRfXzEwLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGluY3JlbWVudE1hY2hpbmUuc3RhdGVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlcy5wdXNoKG5ldyBGYWxsVGhyb3VnaFN0YXRlKHRtcElkJF9fMTMsIGluY3JlbWVudEZhbGxUaHJvdWdoSWQsIFtjcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KGluY3JlbWVudCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbml0aWFsaXplciAmJiAhY29uZGl0aW9uKVxuICAgICAgICAgIHN0YXJ0SWQgPSBsb29wU3RhcnRJZDtcbiAgICAgICAgdmFyIGNvbnRpbnVlSWQ7XG4gICAgICAgIGlmIChpbmNyZW1lbnQpXG4gICAgICAgICAgY29udGludWVJZCA9IGluY3JlbWVudFN0YXJ0SWQ7XG4gICAgICAgIGVsc2UgaWYgKGNvbmRpdGlvbilcbiAgICAgICAgICBjb250aW51ZUlkID0gY29uZGl0aW9uU3RhcnRJZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvbnRpbnVlSWQgPSBsb29wU3RhcnRJZDtcbiAgICAgICAgaWYgKCFpbmNyZW1lbnQgJiYgIWNvbmRpdGlvbikge1xuICAgICAgICAgIGxvb3BCb2R5TWFjaGluZSA9IGxvb3BCb2R5TWFjaGluZS5yZXBsYWNlRmFsbFRocm91Z2hTdGF0ZShsb29wQm9keU1hY2hpbmUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRMb29wQm9keVN0YXRlc18obG9vcEJvZHlNYWNoaW5lLCBjb250aW51ZUlkLCBmYWxsVGhyb3VnaElkLCBsYWJlbHMsIHN0YXRlcyk7XG4gICAgICAgIHZhciBtYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShzdGFydElkLCBmYWxsVGhyb3VnaElkLCBzdGF0ZXMsIGxvb3BCb2R5TWFjaGluZS5leGNlcHRpb25CbG9ja3MpO1xuICAgICAgICBpZiAobGFiZWwpXG4gICAgICAgICAgbWFjaGluZSA9IG1hY2hpbmUucmVwbGFjZVN0YXRlSWQoY29udGludWVJZCwgbGFiZWwuY29udGludWVTdGF0ZSk7XG4gICAgICAgIHJldHVybiBtYWNoaW5lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvckluU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZvck9mU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZm9yIG9mIHN0YXRlbWVudHMgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIGJlZm9yZSB0aGlzIHBhc3MnKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JZlN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fOCxcbiAgICAgICAgICAgICRfXzksXG4gICAgICAgICAgICAkX18xMDtcbiAgICAgICAgdmFyICRfXzYsXG4gICAgICAgICAgICAkX183O1xuICAgICAgICB2YXIgbWFjaGluZSxcbiAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgIGlmQ2xhdXNlLFxuICAgICAgICAgICAgZWxzZUNsYXVzZTtcbiAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbk5lZWRzU3RhdGVNYWNoaW5lKHRyZWUuY29uZGl0aW9uKSkge1xuICAgICAgICAgICgoJF9fNiA9IHRoaXMuZXhwcmVzc2lvblRvU3RhdGVNYWNoaW5lKHRyZWUuY29uZGl0aW9uKSwgbWFjaGluZSA9ICRfXzYubWFjaGluZSwgY29uZGl0aW9uID0gJF9fNi5leHByZXNzaW9uLCAkX182KSk7XG4gICAgICAgICAgaWZDbGF1c2UgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmlmQ2xhdXNlKTtcbiAgICAgICAgICBlbHNlQ2xhdXNlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5lbHNlQ2xhdXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENQU1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1JZlN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAgICgoJF9fNyA9IHJlc3VsdCwgY29uZGl0aW9uID0gJF9fNy5jb25kaXRpb24sIGlmQ2xhdXNlID0gJF9fNy5pZkNsYXVzZSwgZWxzZUNsYXVzZSA9ICRfXzcuZWxzZUNsYXVzZSwgJF9fNykpO1xuICAgICAgICAgIGlmIChpZkNsYXVzZS50eXBlICE9PSBTVEFURV9NQUNISU5FICYmIChlbHNlQ2xhdXNlID09PSBudWxsIHx8IGVsc2VDbGF1c2UudHlwZSAhPT0gU1RBVEVfTUFDSElORSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmQ2xhdXNlID0gdGhpcy5lbnN1cmVUcmFuc2Zvcm1lZF8oaWZDbGF1c2UpO1xuICAgICAgICBlbHNlQ2xhdXNlID0gdGhpcy5lbnN1cmVUcmFuc2Zvcm1lZF8oZWxzZUNsYXVzZSk7XG4gICAgICAgIHZhciBzdGFydFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBmYWxsVGhyb3VnaFN0YXRlID0gaWZDbGF1c2UuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgdmFyIGlmU3RhdGUgPSBpZkNsYXVzZS5zdGFydFN0YXRlO1xuICAgICAgICB2YXIgZWxzZVN0YXRlID0gZWxzZUNsYXVzZSA9PT0gbnVsbCA/IGZhbGxUaHJvdWdoU3RhdGUgOiBlbHNlQ2xhdXNlLnN0YXJ0U3RhdGU7XG4gICAgICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICAgICAgdmFyIGV4Y2VwdGlvbkJsb2NrcyA9IFtdO1xuICAgICAgICBzdGF0ZXMucHVzaChuZXcgQ29uZGl0aW9uYWxTdGF0ZShzdGFydFN0YXRlLCBpZlN0YXRlLCBlbHNlU3RhdGUsIGNvbmRpdGlvbikpO1xuICAgICAgICAoJF9fOCA9IHN0YXRlcykucHVzaC5hcHBseSgkX184LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGlmQ2xhdXNlLnN0YXRlcykpO1xuICAgICAgICAoJF9fOSA9IGV4Y2VwdGlvbkJsb2NrcykucHVzaC5hcHBseSgkX185LCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGlmQ2xhdXNlLmV4Y2VwdGlvbkJsb2NrcykpO1xuICAgICAgICBpZiAoZWxzZUNsYXVzZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVwbGFjZUFuZEFkZFN0YXRlc18oZWxzZUNsYXVzZS5zdGF0ZXMsIGVsc2VDbGF1c2UuZmFsbFRocm91Z2hTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgc3RhdGVzKTtcbiAgICAgICAgICAoJF9fMTAgPSBleGNlcHRpb25CbG9ja3MpLnB1c2guYXBwbHkoJF9fMTAsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoU3RhdGUucmVwbGFjZUFsbFN0YXRlcyhlbHNlQ2xhdXNlLmV4Y2VwdGlvbkJsb2NrcywgZWxzZUNsYXVzZS5mYWxsVGhyb3VnaFN0YXRlLCBmYWxsVGhyb3VnaFN0YXRlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZk1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIHN0YXRlcywgZXhjZXB0aW9uQmxvY2tzKTtcbiAgICAgICAgaWYgKG1hY2hpbmUpXG4gICAgICAgICAgaWZNYWNoaW5lID0gbWFjaGluZS5hcHBlbmQoaWZNYWNoaW5lKTtcbiAgICAgICAgcmV0dXJuIGlmTWFjaGluZTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVFbXB0eVN0YXRlczogZnVuY3Rpb24ob2xkU3RhdGVzKSB7XG4gICAgICAgIHZhciBlbXB0eVN0YXRlcyA9IFtdLFxuICAgICAgICAgICAgbmV3U3RhdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9sZFN0YXRlc1tpXSBpbnN0YW5jZW9mIEZhbGxUaHJvdWdoU3RhdGUgJiYgb2xkU3RhdGVzW2ldLnN0YXRlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbXB0eVN0YXRlcy5wdXNoKG9sZFN0YXRlc1tpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKG9sZFN0YXRlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkX18xNCA9IDA7IGkkX18xNCA8IG5ld1N0YXRlcy5sZW5ndGg7IGkkX18xNCsrKSB7XG4gICAgICAgICAgbmV3U3RhdGVzW2kkX18xNF0gPSBlbXB0eVN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24oc3RhdGUsICRfXzYpIHtcbiAgICAgICAgICAgIHZhciAkX183ID0gJF9fNixcbiAgICAgICAgICAgICAgICBpZCA9ICRfXzcuaWQsXG4gICAgICAgICAgICAgICAgZmFsbFRocm91Z2hTdGF0ZSA9ICRfXzcuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yZXBsYWNlU3RhdGUoaWQsIGZhbGxUaHJvdWdoU3RhdGUpO1xuICAgICAgICAgIH0sIG5ld1N0YXRlc1tpJF9fMTRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGVzO1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2VBbmRBZGRTdGF0ZXNfOiBmdW5jdGlvbihvbGRTdGF0ZXMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3U3RhdGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbmV3U3RhdGVzLnB1c2gob2xkU3RhdGVzW2ldLnJlcGxhY2VTdGF0ZShvbGRTdGF0ZSwgbmV3U3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxhYmVsbGVkU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzdGFydFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBjb250aW51ZVN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBmYWxsVGhyb3VnaFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBsYWJlbCA9IG5ldyBMYWJlbFN0YXRlKHRyZWUubmFtZS52YWx1ZSwgY29udGludWVTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSk7XG4gICAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmFkZExhYmVsXyhsYWJlbCk7XG4gICAgICAgIHRoaXMuY3VycmVudExhYmVsXyA9IGxhYmVsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5zdGF0ZW1lbnQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSB0cmVlLnN0YXRlbWVudCkge1xuICAgICAgICAgIHJlc3VsdCA9IHRyZWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnR5cGUgPT09IFNUQVRFX01BQ0hJTkUpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZVN0YXJ0U3RhdGUoc3RhcnRTdGF0ZSk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2VGYWxsVGhyb3VnaFN0YXRlKGZhbGxUaHJvdWdoU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZUxhYmVsc18ob2xkTGFiZWxzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBnZXRMYWJlbHNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxTZXRfO1xuICAgICAgfSxcbiAgICAgIHJlc3RvcmVMYWJlbHNfOiBmdW5jdGlvbihvbGRMYWJlbHMpIHtcbiAgICAgICAgdGhpcy5sYWJlbFNldF8gPSBvbGRMYWJlbHM7XG4gICAgICB9LFxuICAgICAgYWRkTGFiZWxfOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgJF9fNSA9IHRoaXM7XG4gICAgICAgIHZhciBvbGRMYWJlbHMgPSB0aGlzLmxhYmVsU2V0XztcbiAgICAgICAgdmFyIGxhYmVsU2V0ID0gbmV3IFN0cmluZ01hcCgpO1xuICAgICAgICB0aGlzLmxhYmVsU2V0Xy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gbGFiZWxTZXRba10gPSAkX181LmxhYmVsU2V0X1trXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxhYmVsU2V0LnNldChsYWJlbC5uYW1lLCBsYWJlbCk7XG4gICAgICAgIHRoaXMubGFiZWxTZXRfID0gbGFiZWxTZXQ7XG4gICAgICAgIHJldHVybiBvbGRMYWJlbHM7XG4gICAgICB9LFxuICAgICAgY2xlYXJMYWJlbHNfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubGFiZWxTZXRfO1xuICAgICAgICB0aGlzLmxhYmVsU2V0XyA9IG5ldyBTdHJpbmdNYXAoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBjbGVhckN1cnJlbnRMYWJlbF86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jdXJyZW50TGFiZWxfO1xuICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbF8gPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fNixcbiAgICAgICAgICAgICRfXzc7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc18oKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBtYWNoaW5lLFxuICAgICAgICAgICAgY2FzZUNsYXVzZXM7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25OZWVkc1N0YXRlTWFjaGluZSh0cmVlLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgKCgkX182ID0gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUodHJlZS5leHByZXNzaW9uKSwgZXhwcmVzc2lvbiA9ICRfXzYuZXhwcmVzc2lvbiwgbWFjaGluZSA9ICRfXzYubWFjaGluZSwgJF9fNikpO1xuICAgICAgICAgIGNhc2VDbGF1c2VzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuY2FzZUNsYXVzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVN3aXRjaFN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICAgIGlmICghbmVlZHNTdGF0ZU1hY2hpbmUocmVzdWx0KSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgKCgkX183ID0gcmVzdWx0LCBleHByZXNzaW9uID0gJF9fNy5leHByZXNzaW9uLCBjYXNlQ2xhdXNlcyA9ICRfXzcuY2FzZUNsYXVzZXMsICRfXzcpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgZmFsbFRocm91Z2hTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgICAgICB2YXIgY2xhdXNlcyA9IFtdO1xuICAgICAgICB2YXIgdHJ5U3RhdGVzID0gW107XG4gICAgICAgIHZhciBoYXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gY2FzZUNsYXVzZXMubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBjbGF1c2UgPSBjYXNlQ2xhdXNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKGNsYXVzZS50eXBlID09PSBDQVNFX0NMQVVTRSkge1xuICAgICAgICAgICAgdmFyIGNhc2VDbGF1c2UgPSBjbGF1c2U7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSB0aGlzLmFkZFN3aXRjaENsYXVzZVN0YXRlc18obmV4dFN0YXRlLCBmYWxsVGhyb3VnaFN0YXRlLCBsYWJlbHMsIGNhc2VDbGF1c2Uuc3RhdGVtZW50cywgc3RhdGVzLCB0cnlTdGF0ZXMpO1xuICAgICAgICAgICAgY2xhdXNlcy5wdXNoKG5ldyBTd2l0Y2hDbGF1c2UoY2FzZUNsYXVzZS5leHByZXNzaW9uLCBuZXh0U3RhdGUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdENsYXVzZSA9IGNsYXVzZTtcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IHRoaXMuYWRkU3dpdGNoQ2xhdXNlU3RhdGVzXyhuZXh0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGxhYmVscywgZGVmYXVsdENsYXVzZS5zdGF0ZW1lbnRzLCBzdGF0ZXMsIHRyeVN0YXRlcyk7XG4gICAgICAgICAgICBjbGF1c2VzLnB1c2gobmV3IFN3aXRjaENsYXVzZShudWxsLCBuZXh0U3RhdGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNEZWZhdWx0KSB7XG4gICAgICAgICAgY2xhdXNlcy5wdXNoKG5ldyBTd2l0Y2hDbGF1c2UobnVsbCwgZmFsbFRocm91Z2hTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlcy5wdXNoKG5ldyBTd2l0Y2hTdGF0ZShzdGFydFN0YXRlLCBleHByZXNzaW9uLCBjbGF1c2VzLnJldmVyc2UoKSkpO1xuICAgICAgICB2YXIgc3dpdGNoTWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUoc3RhcnRTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgc3RhdGVzLnJldmVyc2UoKSwgdHJ5U3RhdGVzKTtcbiAgICAgICAgaWYgKG1hY2hpbmUpXG4gICAgICAgICAgc3dpdGNoTWFjaGluZSA9IG1hY2hpbmUuYXBwZW5kKHN3aXRjaE1hY2hpbmUpO1xuICAgICAgICByZXR1cm4gc3dpdGNoTWFjaGluZTtcbiAgICAgIH0sXG4gICAgICBhZGRTd2l0Y2hDbGF1c2VTdGF0ZXNfOiBmdW5jdGlvbihuZXh0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGxhYmVscywgc3RhdGVtZW50cywgc3RhdGVzLCB0cnlTdGF0ZXMpIHtcbiAgICAgICAgdmFyICRfXzg7XG4gICAgICAgIHZhciBtYWNoaW5lID0gdGhpcy5lbnN1cmVUcmFuc2Zvcm1lZExpc3RfKHN0YXRlbWVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hY2hpbmUuc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbWFjaGluZS5zdGF0ZXNbaV07XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkU3RhdGUgPSBzdGF0ZS50cmFuc2Zvcm1CcmVhayhsYWJlbHMsIGZhbGxUaHJvdWdoU3RhdGUpO1xuICAgICAgICAgIHN0YXRlcy5wdXNoKHRyYW5zZm9ybWVkU3RhdGUucmVwbGFjZVN0YXRlKG1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZSwgbmV4dFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgKCRfXzggPSB0cnlTdGF0ZXMpLnB1c2guYXBwbHkoJF9fOCwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChtYWNoaW5lLmV4Y2VwdGlvbkJsb2NrcykpO1xuICAgICAgICByZXR1cm4gbWFjaGluZS5zdGFydFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRyeVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENQU1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1UcnlTdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyICRfXzYgPSByZXN1bHQsXG4gICAgICAgICAgICBib2R5ID0gJF9fNi5ib2R5LFxuICAgICAgICAgICAgY2F0Y2hCbG9jayA9ICRfXzYuY2F0Y2hCbG9jayxcbiAgICAgICAgICAgIGZpbmFsbHlCbG9jayA9ICRfXzYuZmluYWxseUJsb2NrO1xuICAgICAgICBpZiAoYm9keS50eXBlICE9PSBTVEFURV9NQUNISU5FICYmIChjYXRjaEJsb2NrID09PSBudWxsIHx8IGNhdGNoQmxvY2suY2F0Y2hCb2R5LnR5cGUgIT09IFNUQVRFX01BQ0hJTkUpICYmIChmaW5hbGx5QmxvY2sgPT09IG51bGwgfHwgZmluYWxseUJsb2NrLmJsb2NrLnR5cGUgIT09IFNUQVRFX01BQ0hJTkUpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ZXJDYXRjaFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBvdXRlckZpbmFsbHlTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcHVzaFRyeVN0YXRlID0gdGhpcy5zdGF0ZW1lbnRUb1N0YXRlTWFjaGluZV8ocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHgucHVzaFRyeShcXG4gICAgICAgICAgICBcIiwgXCIsXFxuICAgICAgICAgICAgXCIsIFwiKTtcIl0pLCAoY2F0Y2hCbG9jayAmJiBvdXRlckNhdGNoU3RhdGUpLCAoZmluYWxseUJsb2NrICYmIG91dGVyRmluYWxseVN0YXRlKSkpO1xuICAgICAgICB2YXIgdHJ5TWFjaGluZSA9IHRoaXMuZW5zdXJlVHJhbnNmb3JtZWRfKGJvZHkpO1xuICAgICAgICB0cnlNYWNoaW5lID0gcHVzaFRyeVN0YXRlLmFwcGVuZCh0cnlNYWNoaW5lKTtcbiAgICAgICAgaWYgKGNhdGNoQmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcG9wVHJ5ID0gdGhpcy5zdGF0ZW1lbnRUb1N0YXRlTWFjaGluZV8ocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHgucG9wVHJ5KCk7XCJdKSkpO1xuICAgICAgICAgIHRyeU1hY2hpbmUgPSB0cnlNYWNoaW5lLmFwcGVuZChwb3BUcnkpO1xuICAgICAgICAgIHZhciBleGNlcHRpb25OYW1lID0gY2F0Y2hCbG9jay5iaW5kaW5nLmlkZW50aWZpZXJUb2tlbi52YWx1ZTtcbiAgICAgICAgICB2YXIgY2F0Y2hNYWNoaW5lID0gdGhpcy5lbnN1cmVUcmFuc2Zvcm1lZF8oY2F0Y2hCbG9jay5jYXRjaEJvZHkpO1xuICAgICAgICAgIHZhciBjYXRjaFN0YXJ0ID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgICAgdGhpcy5hZGRNYWNoaW5lVmFyaWFibGUoZXhjZXB0aW9uTmFtZSk7XG4gICAgICAgICAgdmFyIHN0YXRlcyA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQodHJ5TWFjaGluZS5zdGF0ZXMsIFtuZXcgRmFsbFRocm91Z2hTdGF0ZShjYXRjaFN0YXJ0LCBjYXRjaE1hY2hpbmUuc3RhcnRTdGF0ZSwgcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICAgICRjdHgucG9wVHJ5KCk7XFxuICAgICAgICAgICAgICAkY3R4Lm1heWJlVW5jYXRjaGFibGUoKTsgLy8gc2VlIFJFVFVSTl9TRU5USU5FTCBpbiBydW50aW1lXFxuICAgICAgICAgICAgICBcIiwgXCIgPSAkY3R4LnN0b3JlZEV4Y2VwdGlvbjtcIl0pLCBpZChleGNlcHRpb25OYW1lKSkpXSk7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlQW5kQWRkU3RhdGVzXyhjYXRjaE1hY2hpbmUuc3RhdGVzLCBjYXRjaE1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZSwgdHJ5TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZXMpO1xuICAgICAgICAgIHRyeU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHRyeU1hY2hpbmUuc3RhcnRTdGF0ZSwgdHJ5TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZXMsIFtuZXcgQ2F0Y2hTdGF0ZShleGNlcHRpb25OYW1lLCBjYXRjaFN0YXJ0LCB0cnlNYWNoaW5lLmZhbGxUaHJvdWdoU3RhdGUsIHRyeU1hY2hpbmUuZ2V0QWxsU3RhdGVJRHMoKSwgdHJ5TWFjaGluZS5leGNlcHRpb25CbG9ja3MpXSk7XG4gICAgICAgICAgdHJ5TWFjaGluZSA9IHRyeU1hY2hpbmUucmVwbGFjZVN0YXRlSWQoY2F0Y2hTdGFydCwgb3V0ZXJDYXRjaFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUJsb2NrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlNYWNoaW5lID0gdGhpcy5lbnN1cmVUcmFuc2Zvcm1lZF8oZmluYWxseUJsb2NrLmJsb2NrKTtcbiAgICAgICAgICB2YXIgcG9wVHJ5JF9fMTUgPSB0aGlzLnN0YXRlbWVudFRvU3RhdGVNYWNoaW5lXyhwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJGN0eC5wb3BUcnkoKTtcIl0pKSk7XG4gICAgICAgICAgZmluYWxseU1hY2hpbmUgPSBwb3BUcnkkX18xNS5hcHBlbmQoZmluYWxseU1hY2hpbmUpO1xuICAgICAgICAgIHZhciBzdGF0ZXMkX18xNiA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQodHJ5TWFjaGluZS5zdGF0ZXMsIGZpbmFsbHlNYWNoaW5lLnN0YXRlcywgW25ldyBGaW5hbGx5RmFsbFRocm91Z2hTdGF0ZShmaW5hbGx5TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlKV0pO1xuICAgICAgICAgIHRyeU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHRyeU1hY2hpbmUuc3RhcnRTdGF0ZSwgdHJ5TWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlLCBzdGF0ZXMkX18xNiwgW25ldyBGaW5hbGx5U3RhdGUoZmluYWxseU1hY2hpbmUuc3RhcnRTdGF0ZSwgZmluYWxseU1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZSwgdHJ5TWFjaGluZS5nZXRBbGxTdGF0ZUlEcygpLCB0cnlNYWNoaW5lLmV4Y2VwdGlvbkJsb2NrcyldKTtcbiAgICAgICAgICB0cnlNYWNoaW5lID0gdHJ5TWFjaGluZS5yZXBsYWNlU3RhdGVJZChmaW5hbGx5TWFjaGluZS5zdGFydFN0YXRlLCBvdXRlckZpbmFsbHlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyeU1hY2hpbmU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzg7XG4gICAgICAgIHZhciAkX182LFxuICAgICAgICAgICAgJF9fNztcbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzXygpO1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmNsZWFyQ3VycmVudExhYmVsXygpO1xuICAgICAgICB2YXIgY29uZGl0aW9uLFxuICAgICAgICAgICAgbWFjaGluZSxcbiAgICAgICAgICAgIGJvZHk7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25OZWVkc1N0YXRlTWFjaGluZSh0cmVlLmNvbmRpdGlvbikpIHtcbiAgICAgICAgICAoKCRfXzYgPSB0aGlzLmV4cHJlc3Npb25Ub1N0YXRlTWFjaGluZSh0cmVlLmNvbmRpdGlvbiksIG1hY2hpbmUgPSAkX182Lm1hY2hpbmUsIGNvbmRpdGlvbiA9ICRfXzYuZXhwcmVzc2lvbiwgJF9fNikpO1xuICAgICAgICAgIGJvZHkgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVdoaWxlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgICAgKCgkX183ID0gcmVzdWx0LCBjb25kaXRpb24gPSAkX183LmNvbmRpdGlvbiwgYm9keSA9ICRfXzcuYm9keSwgJF9fNykpO1xuICAgICAgICAgIGlmIChib2R5LnR5cGUgIT09IFNUQVRFX01BQ0hJTkUpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29wQm9keU1hY2hpbmUgPSB0aGlzLmVuc3VyZVRyYW5zZm9ybWVkXyhib2R5KTtcbiAgICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBsb29wQm9keU1hY2hpbmUuZmFsbFRocm91Z2hTdGF0ZTtcbiAgICAgICAgdmFyIGZhbGxUaHJvdWdoU3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlcyA9IFtdO1xuICAgICAgICB2YXIgY29uZGl0aW9uU3RhcnQgPSBzdGFydFN0YXRlO1xuICAgICAgICBpZiAobWFjaGluZSkge1xuICAgICAgICAgIG1hY2hpbmUgPSBtYWNoaW5lLnJlcGxhY2VTdGFydFN0YXRlKHN0YXJ0U3RhdGUpO1xuICAgICAgICAgIGNvbmRpdGlvblN0YXJ0ID0gbWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlO1xuICAgICAgICAgICgkX184ID0gc3RhdGVzKS5wdXNoLmFwcGx5KCRfXzgsICR0cmFjZXVyUnVudGltZS5zcHJlYWQobWFjaGluZS5zdGF0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZXMucHVzaChuZXcgQ29uZGl0aW9uYWxTdGF0ZShjb25kaXRpb25TdGFydCwgbG9vcEJvZHlNYWNoaW5lLnN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGNvbmRpdGlvbikpO1xuICAgICAgICB0aGlzLmFkZExvb3BCb2R5U3RhdGVzXyhsb29wQm9keU1hY2hpbmUsIHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIGxhYmVscywgc3RhdGVzKTtcbiAgICAgICAgbWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUoc3RhcnRTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgc3RhdGVzLCBsb29wQm9keU1hY2hpbmUuZXhjZXB0aW9uQmxvY2tzKTtcbiAgICAgICAgaWYgKGxhYmVsKVxuICAgICAgICAgIG1hY2hpbmUgPSBtYWNoaW5lLnJlcGxhY2VTdGF0ZUlkKHN0YXJ0U3RhdGUsIGxhYmVsLmNvbnRpbnVlU3RhdGUpO1xuICAgICAgICByZXR1cm4gbWFjaGluZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1XaXRoU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ1BTVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVdpdGhTdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5ib2R5LnR5cGUgIT09IFNUQVRFX01BQ0hJTkUpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWFjaGFibGUgLSB3aXRoIHN0YXRlbWVudCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS9oYXJtb255Jyk7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVNYWNoaW5lSW5uZXJGdW5jdGlvbjogZnVuY3Rpb24obWFjaGluZSkge1xuICAgICAgICB2YXIgZW5jbG9zaW5nRmluYWxseVN0YXRlID0gbWFjaGluZS5nZXRFbmNsb3NpbmdGaW5hbGx5TWFwKCk7XG4gICAgICAgIHZhciBTd2l0Y2hTdGF0ZW1lbnQgPSBjcmVhdGVTd2l0Y2hTdGF0ZW1lbnQoY3JlYXRlTWVtYmVyRXhwcmVzc2lvbignJGN0eCcsICdzdGF0ZScpLCB0aGlzLnRyYW5zZm9ybU1hY2hpbmVTdGF0ZXMobWFjaGluZSwgU3RhdGUuRU5EX1NUQVRFLCBTdGF0ZS5SRVRIUk9XX1NUQVRFLCBlbmNsb3NpbmdGaW5hbGx5U3RhdGUpKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiZnVuY3Rpb24oJGN0eCkge1xcbiAgICAgIHdoaWxlICh0cnVlKSBcIiwgXCJcXG4gICAgfVwiXSksIFN3aXRjaFN0YXRlbWVudCk7XG4gICAgICB9LFxuICAgICAgYWRkVGVtcFZhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLmFkZE1hY2hpbmVWYXJpYWJsZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICAgICAgYWRkTWFjaGluZVZhcmlhYmxlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuaG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcl8uYWRkVmFyaWFibGUobmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ3BzRnVuY3Rpb25Cb2R5OiBmdW5jdGlvbih0cmVlLCBydW50aW1lTWV0aG9kKSB7XG4gICAgICAgIHZhciAkX184O1xuICAgICAgICB2YXIgZnVuY3Rpb25SZWYgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBhbHBoYVJlbmFtZWRUcmVlID0gQWxwaGFSZW5hbWVyLnJlbmFtZSh0cmVlLCAnYXJndW1lbnRzJywgJyRhcmd1bWVudHMnKTtcbiAgICAgICAgdmFyIGhhc0FyZ3VtZW50cyA9IGFscGhhUmVuYW1lZFRyZWUgIT09IHRyZWU7XG4gICAgICAgIHZhciBob2lzdGVkVHJlZSA9IHRoaXMuaG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcl8udHJhbnNmb3JtQW55KGFscGhhUmVuYW1lZFRyZWUpO1xuICAgICAgICB2YXIgbWF5YmVNYWNoaW5lID0gdGhpcy50cmFuc2Zvcm1BbnkoaG9pc3RlZFRyZWUpO1xuICAgICAgICBpZiAodGhpcy5yZXBvcnRlci5oYWRFcnJvcigpKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB2YXIgbWFjaGluZTtcbiAgICAgICAgaWYgKG1heWJlTWFjaGluZS50eXBlICE9PSBTVEFURV9NQUNISU5FKSB7XG4gICAgICAgICAgbWFjaGluZSA9IHRoaXMuc3RhdGVtZW50c1RvU3RhdGVNYWNoaW5lXyhtYXliZU1hY2hpbmUuc3RhdGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUobWF5YmVNYWNoaW5lLnN0YXJ0U3RhdGUsIG1heWJlTWFjaGluZS5mYWxsVGhyb3VnaFN0YXRlLCB0aGlzLnJlbW92ZUVtcHR5U3RhdGVzKG1heWJlTWFjaGluZS5zdGF0ZXMpLCBtYXliZU1hY2hpbmUuZXhjZXB0aW9uQmxvY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBtYWNoaW5lID0gbWFjaGluZS5yZXBsYWNlRmFsbFRocm91Z2hTdGF0ZShTdGF0ZS5FTkRfU1RBVEUpLnJlcGxhY2VTdGFydFN0YXRlKFN0YXRlLlNUQVJUX1NUQVRFKTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcl8uaGFzRnVuY3Rpb25zKCkpXG4gICAgICAgICAgKCRfXzggPSBzdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KCRfXzgsICR0cmFjZXVyUnVudGltZS5zcHJlYWQodGhpcy5ob2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyXy5nZXRGdW5jdGlvbnMoKSkpO1xuICAgICAgICBpZiAodGhpcy5ob2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyXy5oYXNWYXJpYWJsZXMoKSlcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2godGhpcy5ob2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyXy5nZXRWYXJpYWJsZVN0YXRlbWVudCgpKTtcbiAgICAgICAgaWYgKGhhc0FyZ3VtZW50cylcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInZhciAkYXJndW1lbnRzID0gYXJndW1lbnRzO1wiXSkpKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uUmVmKSB7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJyZXR1cm4gXCIsIFwiKFxcbiAgICAgICAgICAgICAgXCIsIFwiLFxcbiAgICAgICAgICAgICAgXCIsIFwiLCB0aGlzKTtcIl0pLCBydW50aW1lTWV0aG9kLCB0aGlzLmdlbmVyYXRlTWFjaGluZUlubmVyRnVuY3Rpb24obWFjaGluZSksIGZ1bmN0aW9uUmVmKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJyZXR1cm4gXCIsIFwiKFxcbiAgICAgICAgICAgICAgXCIsIFwiLCB0aGlzKTtcIl0pLCBydW50aW1lTWV0aG9kLCB0aGlzLmdlbmVyYXRlTWFjaGluZUlubmVyRnVuY3Rpb24obWFjaGluZSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25Cb2R5KHN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycm93RnVuY3Rpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtU3RhdGVNYWNoaW5lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHN0YXRlbWVudFRvU3RhdGVNYWNoaW5lXzogZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzO1xuICAgICAgICBpZiAoc3RhdGVtZW50LnR5cGUgPT09IEJMT0NLKVxuICAgICAgICAgIHN0YXRlbWVudHMgPSBzdGF0ZW1lbnQuc3RhdGVtZW50cztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlbWVudHMgPSBbc3RhdGVtZW50XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVtZW50c1RvU3RhdGVNYWNoaW5lXyhzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBzdGF0ZW1lbnRzVG9TdGF0ZU1hY2hpbmVfOiBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gICAgICAgIHZhciBzdGFydFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBmYWxsVGhyb3VnaFN0YXRlID0gdGhpcy5hbGxvY2F0ZVN0YXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlVG9TdGF0ZU1hY2hpbmVfKG5ldyBGYWxsVGhyb3VnaFN0YXRlKHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIHN0YXRlbWVudHMpLCBmYWxsVGhyb3VnaFN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBzdGF0ZVRvU3RhdGVNYWNoaW5lXzogZnVuY3Rpb24obmV3U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUobmV3U3RhdGUuaWQsIGZhbGxUaHJvdWdoU3RhdGUsIFtuZXdTdGF0ZV0sIFtdKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NYWNoaW5lU3RhdGVzOiBmdW5jdGlvbihtYWNoaW5lLCBtYWNoaW5lRW5kU3RhdGUsIHJldGhyb3dTdGF0ZSwgZW5jbG9zaW5nRmluYWxseVN0YXRlKSB7XG4gICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hY2hpbmUuc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbWFjaGluZS5zdGF0ZXNbaV07XG4gICAgICAgICAgdmFyIHN0YXRlQ2FzZSA9IHN0YXRlLnRyYW5zZm9ybU1hY2hpbmVTdGF0ZShlbmNsb3NpbmdGaW5hbGx5U3RhdGVbc3RhdGUuaWRdLCBtYWNoaW5lRW5kU3RhdGUsIHRoaXMucmVwb3J0ZXIpO1xuICAgICAgICAgIGlmIChzdGF0ZUNhc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhc2VzLnB1c2goc3RhdGVDYXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRGaW5hbGx5RmFsbFRocm91Z2hEaXNwYXRjaGVzKG51bGwsIG1hY2hpbmUuZXhjZXB0aW9uQmxvY2tzLCBjYXNlcyk7XG4gICAgICAgIGNhc2VzLnB1c2goY3JlYXRlRGVmYXVsdENsYXVzZShwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInJldHVybiAkY3R4LmVuZCgpXCJdKSkpKTtcbiAgICAgICAgcmV0dXJuIGNhc2VzO1xuICAgICAgfSxcbiAgICAgIGFkZEZpbmFsbHlGYWxsVGhyb3VnaERpc3BhdGNoZXM6IGZ1bmN0aW9uKGVuY2xvc2luZ0ZpbmFsbHlTdGF0ZSwgdHJ5U3RhdGVzLCBjYXNlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyeVN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0cnlTdGF0ZSA9IHRyeVN0YXRlc1tpXTtcbiAgICAgICAgICBpZiAodHJ5U3RhdGUua2luZCA9PT0gVHJ5U3RhdGUuS2luZC5GSU5BTExZKSB7XG4gICAgICAgICAgICB2YXIgZmluYWxseVN0YXRlID0gdHJ5U3RhdGU7XG4gICAgICAgICAgICBpZiAoZW5jbG9zaW5nRmluYWxseVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBjYXNlQ2xhdXNlcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuY2xvc2luZ0ZpbmFsbHlTdGF0ZS50cnlTdGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBlbmNsb3NpbmdGaW5hbGx5U3RhdGUudHJ5U3RhdGVzW2pdO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZW5jbG9zaW5nRmluYWxseVN0YXRlLnRyeVN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cyA9IHBhcnNlU3RhdGVtZW50cygkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgICAgICAgICAgJGN0eC5zdGF0ZSA9ICRjdHguZmluYWxseUZhbGxUaHJvdWdoO1xcbiAgICAgICAgICAgICAgICAgICRjdHguZmluYWxseUZhbGxUaHJvdWdoID0gXCIsIFwiO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1wiXSksIFN0YXRlLklOVkFMSURfU1RBVEUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlQ2xhdXNlcy5wdXNoKGNyZWF0ZUNhc2VDbGF1c2UoY3JlYXRlTnVtYmVyTGl0ZXJhbChkZXN0aW5hdGlvbiksIHN0YXRlbWVudHMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlQ2xhdXNlcy5wdXNoKGNyZWF0ZURlZmF1bHRDbGF1c2UoW2NyZWF0ZUFzc2lnblN0YXRlU3RhdGVtZW50KGVuY2xvc2luZ0ZpbmFsbHlTdGF0ZS5maW5hbGx5U3RhdGUpLCBjcmVhdGVCcmVha1N0YXRlbWVudCgpXSkpO1xuICAgICAgICAgICAgICBjYXNlcy5wdXNoKGNyZWF0ZUNhc2VDbGF1c2UoY3JlYXRlTnVtYmVyTGl0ZXJhbChmaW5hbGx5U3RhdGUuZmFsbFRocm91Z2hTdGF0ZSksIFtjcmVhdGVTd2l0Y2hTdGF0ZW1lbnQoY3JlYXRlTWVtYmVyRXhwcmVzc2lvbignJGN0eCcsICdmaW5hbGx5RmFsbFRocm91Z2gnKSwgY2FzZUNsYXVzZXMpLCBjcmVhdGVCcmVha1N0YXRlbWVudCgpXSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2FzZXMucHVzaChjcmVhdGVDYXNlQ2xhdXNlKGNyZWF0ZU51bWJlckxpdGVyYWwoZmluYWxseVN0YXRlLmZhbGxUaHJvdWdoU3RhdGUpLCBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgICAgICAgICAkY3R4LnN0YXRlID0gJGN0eC5maW5hbGx5RmFsbFRocm91Z2g7XFxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1wiXSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEZpbmFsbHlGYWxsVGhyb3VnaERpc3BhdGNoZXMoZmluYWxseVN0YXRlLCBmaW5hbGx5U3RhdGUubmVzdGVkVHJ5cywgY2FzZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZpbmFsbHlGYWxsVGhyb3VnaERpc3BhdGNoZXMoZW5jbG9zaW5nRmluYWxseVN0YXRlLCB0cnlTdGF0ZS5uZXN0ZWRUcnlzLCBjYXNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbkxpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRlci5yZXBvcnRFcnJvcih0cmVlLmxvY2F0aW9uLCAnVHJhY2V1cjogY29uc3QvbGV0IGRlY2xhcmF0aW9ucyBpbiBhIGJsb2NrIGNvbnRhaW5pbmcgYSB5aWVsZCBhcmUgJyArICdub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIG1heWJlVHJhbnNmb3JtU3RhdGVtZW50XzogZnVuY3Rpb24obWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudCkge1xuICAgICAgICB2YXIgYnJlYWtDb250aW51ZVRyYW5zZm9ybWVkID0gbmV3IEJyZWFrQ29udGludWVUcmFuc2Zvcm1lcih0aGlzLnN0YXRlQWxsb2NhdG9yXykudHJhbnNmb3JtQW55KG1heWJlVHJhbnNmb3JtZWRTdGF0ZW1lbnQpO1xuICAgICAgICBpZiAoYnJlYWtDb250aW51ZVRyYW5zZm9ybWVkICE9PSBtYXliZVRyYW5zZm9ybWVkU3RhdGVtZW50KSB7XG4gICAgICAgICAgYnJlYWtDb250aW51ZVRyYW5zZm9ybWVkID0gdGhpcy50cmFuc2Zvcm1BbnkoYnJlYWtDb250aW51ZVRyYW5zZm9ybWVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJlYWtDb250aW51ZVRyYW5zZm9ybWVkO1xuICAgICAgfSxcbiAgICAgIGVuc3VyZVRyYW5zZm9ybWVkXzogZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gICAgICAgIGlmIChzdGF0ZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF5YmVUcmFuc2Zvcm1lZCA9IHRoaXMubWF5YmVUcmFuc2Zvcm1TdGF0ZW1lbnRfKHN0YXRlbWVudCk7XG4gICAgICAgIHJldHVybiBtYXliZVRyYW5zZm9ybWVkLnR5cGUgPT09IFNUQVRFX01BQ0hJTkUgPyBtYXliZVRyYW5zZm9ybWVkIDogdGhpcy5zdGF0ZW1lbnRUb1N0YXRlTWFjaGluZV8obWF5YmVUcmFuc2Zvcm1lZCk7XG4gICAgICB9LFxuICAgICAgZW5zdXJlVHJhbnNmb3JtZWRMaXN0XzogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgbWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGZvdW5kTWFjaGluZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICB2YXIgbWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudCA9IHRoaXMubWF5YmVUcmFuc2Zvcm1TdGF0ZW1lbnRfKHN0YXRlbWVudCk7XG4gICAgICAgICAgbWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudHMucHVzaChtYXliZVRyYW5zZm9ybWVkU3RhdGVtZW50KTtcbiAgICAgICAgICBpZiAobWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudC50eXBlID09PSBTVEFURV9NQUNISU5FKSB7XG4gICAgICAgICAgICBmb3VuZE1hY2hpbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kTWFjaGluZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlbWVudHNUb1N0YXRlTWFjaGluZV8oc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RhdGVtZW50TGlzdF8obWF5YmVUcmFuc2Zvcm1lZFN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb25Ub1N0YXRlTWFjaGluZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgY29tbWFFeHByZXNzaW9uID0gbmV3IEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIodGhpcykudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IG5ldyBOb3JtYWxpemVDb21tYUV4cHJlc3Npb25Ub1N0YXRlbWVudFRyYW5zZm9ybWVyKCkudHJhbnNmb3JtQW55KGNvbW1hRXhwcmVzc2lvbikuc3RhdGVtZW50cztcbiAgICAgICAgdmFyIGxhc3RTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzLnBvcCgpO1xuICAgICAgICBhc3NlcnQobGFzdFN0YXRlbWVudC50eXBlID09PSBFWFBSRVNTSU9OX1NUQVRFTUVOVCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gbGFzdFN0YXRlbWVudC5leHByZXNzaW9uO1xuICAgICAgICBzdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENQU1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1MaXN0XCIpLmNhbGwodGhpcywgc3RhdGVtZW50cyk7XG4gICAgICAgIHZhciBtYWNoaW5lID0gdGhpcy50cmFuc2Zvcm1TdGF0ZW1lbnRMaXN0XyhzdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgIG1hY2hpbmU6IG1hY2hpbmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRlbXBWYXJUcmFuc2Zvcm1lcik7XG4gIHZhciBOb3JtYWxpemVDb21tYUV4cHJlc3Npb25Ub1N0YXRlbWVudFRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOb3JtYWxpemVDb21tYUV4cHJlc3Npb25Ub1N0YXRlbWVudFRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTm9ybWFsaXplQ29tbWFFeHByZXNzaW9uVG9TdGF0ZW1lbnRUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE5vcm1hbGl6ZUNvbW1hRXhwcmVzc2lvblRvU3RhdGVtZW50VHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUNvbW1hRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fNSA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdHJlZS5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgIGlmIChleHByLnR5cGUgPT09IENPTkRJVElPTkFMX0VYUFJFU1NJT04pXG4gICAgICAgICAgICByZXR1cm4gJF9fNS50cmFuc2Zvcm1BbnkoZXhwcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayh0cmVlLmxvY2F0aW9uLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGlmQmxvY2sgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmxlZnQpO1xuICAgICAgICB2YXIgZWxzZUJsb2NrID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIHJldHVybiBuZXcgSWZTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgdHJlZS5jb25kaXRpb24sIGFub25CbG9ja1RvQmxvY2soaWZCbG9jayksIGFub25CbG9ja1RvQmxvY2soZWxzZUJsb2NrKSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIGZ1bmN0aW9uIGFub25CbG9ja1RvQmxvY2sodHJlZSkge1xuICAgIGlmICh0cmVlLnR5cGUgPT09IFBBUkVOX0VYUFJFU1NJT04pXG4gICAgICByZXR1cm4gYW5vbkJsb2NrVG9CbG9jayh0cmVlLmV4cHJlc3Npb24pO1xuICAgIHJldHVybiBuZXcgQmxvY2sodHJlZS5sb2NhdGlvbiwgdHJlZS5zdGF0ZW1lbnRzKTtcbiAgfVxuICByZXR1cm4ge2dldCBDUFNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBDUFNUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRW5kU3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRW5kU3RhdGUuanNcIjtcbiAgdmFyIFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9FbmRTdGF0ZS5qc1wiKSkuU3RhdGU7XG4gIHZhciBFbmRTdGF0ZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRW5kU3RhdGUoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihFbmRTdGF0ZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEVuZFN0YXRlLCB7XG4gICAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVuZFN0YXRlKFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgbWFjaGluZUVuZFN0YXRlLCByZXBvcnRlcikge1xuICAgICAgICByZXR1cm4gU3RhdGUuZ2VuZXJhdGVKdW1wKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTdGF0ZSk7XG4gIHJldHVybiB7Z2V0IEVuZFN0YXRlKCkge1xuICAgICAgcmV0dXJuIEVuZFN0YXRlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bc3luY1RyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0FzeW5jVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEF3YWl0U3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Bd2FpdFN0YXRlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXN5bmNUcmFuc2Zvcm1lci5qc1wiKSkuQXdhaXRTdGF0ZTtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bc3luY1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb24gPSAkX180LkJpbmFyeUV4cHJlc3Npb24sXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50ID0gJF9fNC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICB2YXIgQ1BTVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9DUFNUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0FzeW5jVHJhbnNmb3JtZXIuanNcIikpLkNQU1RyYW5zZm9ybWVyO1xuICB2YXIgRW5kU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9FbmRTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0FzeW5jVHJhbnNmb3JtZXIuanNcIikpLkVuZFN0YXRlO1xuICB2YXIgRmFsbFRocm91Z2hTdGF0ZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ZhbGxUaHJvdWdoU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bc3luY1RyYW5zZm9ybWVyLmpzXCIpKS5GYWxsVGhyb3VnaFN0YXRlO1xuICB2YXIgSW1wb3J0UnVudGltZVRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0FzeW5jVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX185ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXN5bmNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBV0FJVF9FWFBSRVNTSU9OID0gJF9fOS5BV0FJVF9FWFBSRVNTSU9OLFxuICAgICAgQklOQVJZX0VYUFJFU1NJT04gPSAkX185LkJJTkFSWV9FWFBSRVNTSU9OLFxuICAgICAgU1RBVEVfTUFDSElORSA9ICRfXzkuU1RBVEVfTUFDSElORTtcbiAgdmFyICRfXzEwID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXN5bmNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX18xMC5wYXJzZUV4cHJlc3Npb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzEwLnBhcnNlU3RhdGVtZW50LFxuICAgICAgcGFyc2VTdGF0ZW1lbnRzID0gJF9fMTAucGFyc2VTdGF0ZW1lbnRzO1xuICB2YXIgU3RhdGVNYWNoaW5lID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9TdGF0ZU1hY2hpbmUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bc3luY1RyYW5zZm9ybWVyLmpzXCIpKS5TdGF0ZU1hY2hpbmU7XG4gIHZhciBGaW5kSW5GdW5jdGlvblNjb3BlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL0ZpbmRJbkZ1bmN0aW9uU2NvcGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Bc3luY1RyYW5zZm9ybWVyLmpzXCIpKS5GaW5kSW5GdW5jdGlvblNjb3BlO1xuICB2YXIgY3JlYXRlVW5kZWZpbmVkRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvQXN5bmNUcmFuc2Zvcm1lci5qc1wiKSkuY3JlYXRlVW5kZWZpbmVkRXhwcmVzc2lvbjtcbiAgZnVuY3Rpb24gaXNBd2FpdEFzc2lnbih0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUudHlwZSA9PT0gQklOQVJZX0VYUFJFU1NJT04gJiYgdHJlZS5vcGVyYXRvci5pc0Fzc2lnbm1lbnRPcGVyYXRvcigpICYmIHRyZWUucmlnaHQudHlwZSA9PT0gQVdBSVRfRVhQUkVTU0lPTiAmJiB0cmVlLmxlZnQuaXNMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCk7XG4gIH1cbiAgdmFyIEF3YWl0RmluZGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBBd2FpdEZpbmRlcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEF3YWl0RmluZGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQXdhaXRGaW5kZXIsIHt2aXNpdEF3YWl0RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRJbkZ1bmN0aW9uU2NvcGUpO1xuICBmdW5jdGlvbiBzY29wZUNvbnRhaW5zQXdhaXQodHJlZSkge1xuICAgIHZhciB2aXNpdG9yID0gbmV3IEF3YWl0RmluZGVyKCk7XG4gICAgdmlzaXRvci52aXNpdEFueSh0cmVlKTtcbiAgICByZXR1cm4gdmlzaXRvci5mb3VuZDtcbiAgfVxuICB2YXIgQXN5bmNUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNUcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEFzeW5jVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBc3luY1RyYW5zZm9ybWVyLCB7XG4gICAgICBleHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc2NvcGVDb250YWluc0F3YWl0KHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0cmVlLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IEFXQUlUX0VYUFJFU1NJT04pXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXdhaXRFeHByZXNzaW9uXyhleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGlzQXdhaXRBc3NpZ24oZXhwcmVzc2lvbikpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXdhaXRBc3NpZ25fKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUoZXhwcmVzc2lvbikubWFjaGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEFzeW5jVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUV4cHJlc3Npb25TdGF0ZW1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bd2FpdEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcicpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUF3YWl0RXhwcmVzc2lvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQXdhaXRfKHRyZWUsIHRyZWUuZXhwcmVzc2lvbiwgbnVsbCwgbnVsbCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXdhaXRBc3NpZ25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUF3YWl0Xyh0cmVlLCB0cmVlLnJpZ2h0LmV4cHJlc3Npb24sIHRyZWUubGVmdCwgdHJlZS5vcGVyYXRvcik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXdhaXRfOiBmdW5jdGlvbih0cmVlLCBpbkV4cHJlc3Npb24sIGxlZnQsIG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciAkX18yO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIG1hY2hpbmU7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25OZWVkc1N0YXRlTWFjaGluZShpbkV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgKCgkX18yID0gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUoaW5FeHByZXNzaW9uKSwgZXhwcmVzc2lvbiA9ICRfXzIuZXhwcmVzc2lvbiwgbWFjaGluZSA9ICRfXzIubWFjaGluZSwgJF9fMikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueShpbkV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcmVhdGVUYXNrU3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGZhbGxUaHJvdWdoU3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrU3RhdGUgPSBsZWZ0ID8gdGhpcy5hbGxvY2F0ZVN0YXRlKCkgOiBmYWxsVGhyb3VnaFN0YXRlO1xuICAgICAgICB2YXIgc3RhdGVzID0gW107XG4gICAgICAgIHN0YXRlcy5wdXNoKG5ldyBBd2FpdFN0YXRlKGNyZWF0ZVRhc2tTdGF0ZSwgY2FsbGJhY2tTdGF0ZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBsZWZ0LCBvcGVyYXRvciwgcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkY3R4LnZhbHVlXCJdKSkpKTtcbiAgICAgICAgICBzdGF0ZXMucHVzaChuZXcgRmFsbFRocm91Z2hTdGF0ZShjYWxsYmFja1N0YXRlLCBmYWxsVGhyb3VnaFN0YXRlLCBbc3RhdGVtZW50XSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhd2FpdE1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKGNyZWF0ZVRhc2tTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgc3RhdGVzLCBbXSk7XG4gICAgICAgIGlmIChtYWNoaW5lKSB7XG4gICAgICAgICAgYXdhaXRNYWNoaW5lID0gbWFjaGluZS5hcHBlbmQoYXdhaXRNYWNoaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXRNYWNoaW5lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZpbmFsbHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBBc3luY1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GaW5hbGx5XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIGlmIChyZXN1bHQuYmxvY2sudHlwZSAhPT0gU1RBVEVfTUFDSElORSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBvcnRlci5yZXBvcnRFcnJvcih0cmVlLmxvY2F0aW9uLCAnYXdhaXQgbm90IHBlcm1pdHRlZCB3aXRoaW4gYSBmaW5hbGx5IGJsb2NrLicpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVJldHVyblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMjtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBtYWNoaW5lO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUodHJlZS5leHByZXNzaW9uKSkge1xuICAgICAgICAgICgoJF9fMiA9IHRoaXMuZXhwcmVzc2lvblRvU3RhdGVNYWNoaW5lKHRyZWUuZXhwcmVzc2lvbiksIGV4cHJlc3Npb24gPSAkX18yLmV4cHJlc3Npb24sIG1hY2hpbmUgPSAkX18yLm1hY2hpbmUsICRfXzIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gdHJlZS5leHByZXNzaW9uIHx8IGNyZWF0ZVVuZGVmaW5lZEV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgZW5kU3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGNvbXBsZXRlU3RhdGUgPSBuZXcgRmFsbFRocm91Z2hTdGF0ZShzdGFydFN0YXRlLCBlbmRTdGF0ZSwgcGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkY3R4LnJldHVyblZhbHVlID0gXCIsIFwiXCJdKSwgZXhwcmVzc2lvbikpO1xuICAgICAgICB2YXIgZW5kID0gbmV3IEVuZFN0YXRlKGVuZFN0YXRlKTtcbiAgICAgICAgdmFyIHJldHVybk1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHN0YXJ0U3RhdGUsIHRoaXMuYWxsb2NhdGVTdGF0ZSgpLCBbY29tcGxldGVTdGF0ZSwgZW5kXSwgW10pO1xuICAgICAgICBpZiAobWFjaGluZSlcbiAgICAgICAgICByZXR1cm5NYWNoaW5lID0gbWFjaGluZS5hcHBlbmQocmV0dXJuTWFjaGluZSk7XG4gICAgICAgIHJldHVybiByZXR1cm5NYWNoaW5lO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZUNvbXBsZXRlVGFza186IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHgucmVzb2x2ZShcIiwgXCIpXCJdKSwgcmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Bc3luY0JvZHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGFzeW5jV3JhcCA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ2FzeW5jV3JhcCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1DcHNGdW5jdGlvbkJvZHkodHJlZSwgYXN5bmNXcmFwKTtcbiAgICAgIH1cbiAgICB9LCB7dHJhbnNmb3JtQXN5bmNCb2R5OiBmdW5jdGlvbihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucywgYm9keSkge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpLnRyYW5zZm9ybUFzeW5jQm9keShib2R5KTtcbiAgICAgIH19LCAkX19zdXBlcik7XG4gIH0oSW1wb3J0UnVudGltZVRyYWl0KENQU1RyYW5zZm9ybWVyKSk7XG4gIDtcbiAgcmV0dXJuIHtnZXQgQXN5bmNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBBc3luY1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Gb3JJblRyYW5zZm9ybVBhc3MuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRm9ySW5UcmFuc2Zvcm1QYXNzLmpzXCI7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRm9ySW5UcmFuc2Zvcm1QYXNzLmpzXCIpKSxcbiAgICAgIEJMT0NLID0gJF9fMy5CTE9DSyxcbiAgICAgIFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgPSAkX18zLlZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QsXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX18zLklERU5USUZJRVJfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvRm9ySW5UcmFuc2Zvcm1QYXNzLmpzXCIpKSxcbiAgICAgIExFTkdUSCA9ICRfXzQuTEVOR1RILFxuICAgICAgUFVTSCA9ICRfXzQuUFVTSDtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Gb3JJblRyYW5zZm9ybVBhc3MuanNcIikpLlRlbXBWYXJUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0ZvckluVHJhbnNmb3JtUGFzcy5qc1wiKSksXG4gICAgICBCQU5HID0gJF9fNi5CQU5HLFxuICAgICAgSU4gPSAkX182LklOLFxuICAgICAgT1BFTl9BTkdMRSA9ICRfXzYuT1BFTl9BTkdMRSxcbiAgICAgIFBMVVNfUExVUyA9ICRfXzYuUExVU19QTFVTLFxuICAgICAgVkFSID0gJF9fNi5WQVI7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9Gb3JJblRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgY3JlYXRlQXJndW1lbnRMaXN0ID0gJF9fNy5jcmVhdGVBcmd1bWVudExpc3QsXG4gICAgICBjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50ID0gJF9fNy5jcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50LFxuICAgICAgY3JlYXRlQmluYXJ5RXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUJsb2NrID0gJF9fNy5jcmVhdGVCbG9jayxcbiAgICAgIGNyZWF0ZUNhbGxTdGF0ZW1lbnQgPSAkX183LmNyZWF0ZUNhbGxTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVDb250aW51ZVN0YXRlbWVudCA9ICRfXzcuY3JlYXRlQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVFbXB0eUFycmF5TGl0ZXJhbCA9ICRfXzcuY3JlYXRlRW1wdHlBcnJheUxpdGVyYWwsXG4gICAgICBjcmVhdGVGb3JJblN0YXRlbWVudCA9ICRfXzcuY3JlYXRlRm9ySW5TdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVGb3JTdGF0ZW1lbnQgPSAkX183LmNyZWF0ZUZvclN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uID0gJF9fNy5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUlmU3RhdGVtZW50ID0gJF9fNy5jcmVhdGVJZlN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX183LmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fNy5jcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTnVtYmVyTGl0ZXJhbCA9ICRfXzcuY3JlYXRlTnVtYmVyTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZU9wZXJhdG9yVG9rZW4gPSAkX183LmNyZWF0ZU9wZXJhdG9yVG9rZW4sXG4gICAgICBjcmVhdGVQYXJlbkV4cHJlc3Npb24gPSAkX183LmNyZWF0ZVBhcmVuRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVBvc3RmaXhFeHByZXNzaW9uID0gJF9fNy5jcmVhdGVQb3N0Zml4RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVVuYXJ5RXhwcmVzc2lvbiA9ICRfXzcuY3JlYXRlVW5hcnlFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX183LmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX183LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgRm9ySW5UcmFuc2Zvcm1QYXNzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGb3JJblRyYW5zZm9ybVBhc3MoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JJblRyYW5zZm9ybVBhc3MpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGb3JJblRyYW5zZm9ybVBhc3MsIHt0cmFuc2Zvcm1Gb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMSxcbiAgICAgICAgICAgICRfXzI7XG4gICAgICAgIHZhciBib2R5U3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChib2R5LnR5cGUgPT09IEJMT0NLKSB7XG4gICAgICAgICAgKCRfXzEgPSBib2R5U3RhdGVtZW50cykucHVzaC5hcHBseSgkX18xLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKGJvZHkuc3RhdGVtZW50cykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvZHlTdGF0ZW1lbnRzLnB1c2goYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFZBUiwga2V5cywgY3JlYXRlRW1wdHlBcnJheUxpdGVyYWwoKSkpO1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChWQVIsIGNvbGxlY3Rpb24sIHRyZWUuY29sbGVjdGlvbikpO1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgICAgZWxlbWVudHMucHVzaChjcmVhdGVGb3JJblN0YXRlbWVudChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIHAsIG51bGwpLCBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihjb2xsZWN0aW9uKSwgY3JlYXRlQ2FsbFN0YXRlbWVudChjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGtleXMsIFBVU0gpLCBjcmVhdGVBcmd1bWVudExpc3QoW2NyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHApXSkpKSk7XG4gICAgICAgIHZhciBpID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgbG9va3VwID0gY3JlYXRlTWVtYmVyTG9va3VwRXhwcmVzc2lvbihjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihrZXlzKSwgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oaSkpO1xuICAgICAgICB2YXIgb3JpZ2luYWxLZXksXG4gICAgICAgICAgICBhc3NpZ25PcmlnaW5hbEtleTtcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIudHlwZSA9PT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCkge1xuICAgICAgICAgIHZhciBkZWNMaXN0ID0gdHJlZS5pbml0aWFsaXplcjtcbiAgICAgICAgICBvcmlnaW5hbEtleSA9IGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKGRlY0xpc3QuZGVjbGFyYXRpb25zWzBdLmx2YWx1ZSk7XG4gICAgICAgICAgYXNzaWduT3JpZ2luYWxLZXkgPSBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChkZWNMaXN0LmRlY2xhcmF0aW9uVHlwZSwgb3JpZ2luYWxLZXkuaWRlbnRpZmllclRva2VuLCBsb29rdXApO1xuICAgICAgICB9IGVsc2UgaWYgKHRyZWUuaW5pdGlhbGl6ZXIudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgb3JpZ2luYWxLZXkgPSB0cmVlLmluaXRpYWxpemVyO1xuICAgICAgICAgIGFzc2lnbk9yaWdpbmFsS2V5ID0gY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCh0cmVlLmluaXRpYWxpemVyLCBsb29rdXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsZWZ0IGhhbmQgc2lkZSBvZiBmb3IgaW4gbG9vcCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbm5lckJsb2NrID0gW107XG4gICAgICAgIGlubmVyQmxvY2sucHVzaChhc3NpZ25PcmlnaW5hbEtleSk7XG4gICAgICAgIGlubmVyQmxvY2sucHVzaChjcmVhdGVJZlN0YXRlbWVudChjcmVhdGVVbmFyeUV4cHJlc3Npb24oY3JlYXRlT3BlcmF0b3JUb2tlbihCQU5HKSwgY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUJpbmFyeUV4cHJlc3Npb24ob3JpZ2luYWxLZXksIGNyZWF0ZU9wZXJhdG9yVG9rZW4oSU4pLCBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihjb2xsZWN0aW9uKSkpKSwgY3JlYXRlQ29udGludWVTdGF0ZW1lbnQoKSwgbnVsbCkpO1xuICAgICAgICAoJF9fMiA9IGlubmVyQmxvY2spLnB1c2guYXBwbHkoJF9fMiwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChib2R5U3RhdGVtZW50cykpO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGNyZWF0ZUZvclN0YXRlbWVudChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIGksIGNyZWF0ZU51bWJlckxpdGVyYWwoMCkpLCBjcmVhdGVCaW5hcnlFeHByZXNzaW9uKGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKGkpLCBjcmVhdGVPcGVyYXRvclRva2VuKE9QRU5fQU5HTEUpLCBjcmVhdGVNZW1iZXJFeHByZXNzaW9uKGtleXMsIExFTkdUSCkpLCBjcmVhdGVQb3N0Zml4RXhwcmVzc2lvbihjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihpKSwgY3JlYXRlT3BlcmF0b3JUb2tlbihQTFVTX1BMVVMpKSwgY3JlYXRlQmxvY2soaW5uZXJCbG9jaykpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2NrKGVsZW1lbnRzKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRlbXBWYXJUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IEZvckluVHJhbnNmb3JtUGFzcygpIHtcbiAgICAgIHJldHVybiBGb3JJblRyYW5zZm9ybVBhc3M7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1lpZWxkU3RhdGUuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvWWllbGRTdGF0ZS5qc1wiO1xuICB2YXIgU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1lpZWxkU3RhdGUuanNcIikpLlN0YXRlO1xuICB2YXIgY3JlYXRlUmV0dXJuU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9ZaWVsZFN0YXRlLmpzXCIpKS5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQ7XG4gIHZhciBZaWVsZFN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBZaWVsZFN0YXRlKGlkLCBmYWxsVGhyb3VnaFN0YXRlLCBleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihZaWVsZFN0YXRlKS5jYWxsKHRoaXMsIGlkKTtcbiAgICAgIHRoaXMuZmFsbFRocm91Z2hTdGF0ZSA9IGZhbGxUaHJvdWdoU3RhdGU7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoWWllbGRTdGF0ZSwge1xuICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSksIFN0YXRlLnJlcGxhY2VTdGF0ZUlkKHRoaXMuZmFsbFRocm91Z2hTdGF0ZSwgb2xkU3RhdGUsIG5ld1N0YXRlKSwgdGhpcy5leHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSwgcmVwb3J0ZXIpIHtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zcHJlYWQoU3RhdGUuZ2VuZXJhdGVBc3NpZ25TdGF0ZShlbmNsb3NpbmdGaW5hbGx5LCB0aGlzLmZhbGxUaHJvdWdoU3RhdGUpLCBbY3JlYXRlUmV0dXJuU3RhdGVtZW50KHRoaXMuZXhwcmVzc2lvbildKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFN0YXRlKTtcbiAgcmV0dXJuIHtnZXQgWWllbGRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBZaWVsZFN0YXRlO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9SZXR1cm5TdGF0ZS5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9SZXR1cm5TdGF0ZS5qc1wiO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi8uLi9zZW1hbnRpY3MvdXRpbC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1JldHVyblN0YXRlLmpzXCIpKSxcbiAgICAgIGlzVW5kZWZpbmVkID0gJF9fMi5pc1VuZGVmaW5lZCxcbiAgICAgIGlzVm9pZEV4cHJlc3Npb24gPSAkX18yLmlzVm9pZEV4cHJlc3Npb247XG4gIHZhciBZaWVsZFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vWWllbGRTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1JldHVyblN0YXRlLmpzXCIpKS5ZaWVsZFN0YXRlO1xuICB2YXIgU3RhdGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL1JldHVyblN0YXRlLmpzXCIpKS5TdGF0ZTtcbiAgdmFyIHBhcnNlU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvUmV0dXJuU3RhdGUuanNcIikpLnBhcnNlU3RhdGVtZW50O1xuICB2YXIgUmV0dXJuU3RhdGUgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoUmV0dXJuU3RhdGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSZXR1cm5TdGF0ZSwge3RyYW5zZm9ybTogZnVuY3Rpb24oZW5jbG9zaW5nRmluYWxseSwgbWFjaGluZUVuZFN0YXRlLCByZXBvcnRlcikge1xuICAgICAgICB2YXIgJF9fMTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmV4cHJlc3Npb247XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGlmIChlICYmICFpc1VuZGVmaW5lZChlKSAmJiAhaXNWb2lkRXhwcmVzc2lvbihlKSlcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHgucmV0dXJuVmFsdWUgPSBcIiwgXCJcIl0pLCB0aGlzLmV4cHJlc3Npb24pKTtcbiAgICAgICAgKCRfXzEgPSBzdGF0ZW1lbnRzKS5wdXNoLmFwcGx5KCRfXzEsICR0cmFjZXVyUnVudGltZS5zcHJlYWQoU3RhdGUuZ2VuZXJhdGVKdW1wKGVuY2xvc2luZ0ZpbmFsbHksIG1hY2hpbmVFbmRTdGF0ZSkpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShZaWVsZFN0YXRlKTtcbiAgcmV0dXJuIHtnZXQgUmV0dXJuU3RhdGUoKSB7XG4gICAgICByZXR1cm4gUmV0dXJuU3RhdGU7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBDUFNUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0NQU1RyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLkNQU1RyYW5zZm9ybWVyO1xuICB2YXIgJF9fNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi8uLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEJJTkFSWV9FWFBSRVNTSU9OID0gJF9fNC5CSU5BUllfRVhQUkVTU0lPTixcbiAgICAgIFlJRUxEX0VYUFJFU1NJT04gPSAkX180LllJRUxEX0VYUFJFU1NJT047XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQmluYXJ5RXhwcmVzc2lvbiA9ICRfXzUuQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQgPSAkX181LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHZhciBGaW5kSW5GdW5jdGlvblNjb3BlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL0ZpbmRJbkZ1bmN0aW9uU2NvcGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9HZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiKSkuRmluZEluRnVuY3Rpb25TY29wZTtcbiAgdmFyIFJldHVyblN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUmV0dXJuU3RhdGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9HZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiKSkuUmV0dXJuU3RhdGU7XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9nZW5lcmF0b3IvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBZaWVsZFN0YXRlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vWWllbGRTdGF0ZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKS5ZaWVsZFN0YXRlO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vZ2VuZXJhdG9yL0dlbmVyYXRvclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGlkID0gJF9fMTAuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJFeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZVVuZGVmaW5lZEV4cHJlc3Npb24gPSAkX18xMC5jcmVhdGVVbmRlZmluZWRFeHByZXNzaW9uO1xuICB2YXIgJF9fMTEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL2dlbmVyYXRvci9HZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX18xMS5wYXJzZUV4cHJlc3Npb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzExLnBhcnNlU3RhdGVtZW50LFxuICAgICAgcGFyc2VTdGF0ZW1lbnRzID0gJF9fMTEucGFyc2VTdGF0ZW1lbnRzO1xuICBmdW5jdGlvbiBpc1lpZWxkQXNzaWduKHRyZWUpIHtcbiAgICByZXR1cm4gdHJlZS50eXBlID09PSBCSU5BUllfRVhQUkVTU0lPTiAmJiB0cmVlLm9wZXJhdG9yLmlzQXNzaWdubWVudE9wZXJhdG9yKCkgJiYgdHJlZS5yaWdodC50eXBlID09PSBZSUVMRF9FWFBSRVNTSU9OICYmIHRyZWUubGVmdC5pc0xlZnRIYW5kU2lkZUV4cHJlc3Npb24oKTtcbiAgfVxuICB2YXIgWWllbGRGaW5kZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFlpZWxkRmluZGVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoWWllbGRGaW5kZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShZaWVsZEZpbmRlciwge3Zpc2l0WWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oRmluZEluRnVuY3Rpb25TY29wZSk7XG4gIGZ1bmN0aW9uIHNjb3BlQ29udGFpbnNZaWVsZCh0cmVlKSB7XG4gICAgdmFyIGZpbmRlciA9IG5ldyBZaWVsZEZpbmRlcigpO1xuICAgIGZpbmRlci52aXNpdEFueSh0cmVlKTtcbiAgICByZXR1cm4gZmluZGVyLmZvdW5kO1xuICB9XG4gIHZhciBHZW5lcmF0b3JUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEdlbmVyYXRvclRyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2hvdWxkQXBwZW5kVGhyb3dDbG9zZVN0YXRlXyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShHZW5lcmF0b3JUcmFuc2Zvcm1lciwge1xuICAgICAgZXhwcmVzc2lvbk5lZWRzU3RhdGVNYWNoaW5lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNjb3BlQ29udGFpbnNZaWVsZCh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1ZaWVsZEV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18yO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIG1hY2hpbmU7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25OZWVkc1N0YXRlTWFjaGluZSh0cmVlLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgKCgkX18yID0gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUodHJlZS5leHByZXNzaW9uKSwgZXhwcmVzc2lvbiA9ICRfXzIuZXhwcmVzc2lvbiwgbWFjaGluZSA9ICRfXzIubWFjaGluZSwgJF9fMikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLmlzWWllbGRGb3IpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtWWllbGRGb3JFeHByZXNzaW9uXyhleHByZXNzaW9uLCBtYWNoaW5lKTtcbiAgICAgICAgdmFyIHN0YXJ0U3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGZhbGxUaHJvdWdoU3RhdGUgPSB0aGlzLmFsbG9jYXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIHlpZWxkTWFjaGluZSA9IHRoaXMuc3RhdGVUb1N0YXRlTWFjaGluZV8obmV3IFlpZWxkU3RhdGUoc3RhcnRTdGF0ZSwgZmFsbFRocm91Z2hTdGF0ZSwgZXhwcmVzc2lvbiksIGZhbGxUaHJvdWdoU3RhdGUpO1xuICAgICAgICBpZiAobWFjaGluZSlcbiAgICAgICAgICB5aWVsZE1hY2hpbmUgPSBtYWNoaW5lLmFwcGVuZCh5aWVsZE1hY2hpbmUpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRBcHBlbmRUaHJvd0Nsb3NlU3RhdGVfKVxuICAgICAgICAgIHlpZWxkTWFjaGluZSA9IHlpZWxkTWFjaGluZS5hcHBlbmQodGhpcy5jcmVhdGVUaHJvd0Nsb3NlU3RhdGVfKCkpO1xuICAgICAgICByZXR1cm4geWllbGRNYWNoaW5lO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVlpZWxkRm9yRXhwcmVzc2lvbl86IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIG1hY2hpbmUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBnTmFtZSA9IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5hZGRNYWNoaW5lVmFyaWFibGUoZ05hbWUpO1xuICAgICAgICB2YXIgZyA9IGlkKGdOYW1lKTtcbiAgICAgICAgdmFyIG5leHROYW1lID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLmFkZE1hY2hpbmVWYXJpYWJsZShuZXh0TmFtZSk7XG4gICAgICAgIHZhciBuZXh0ID0gaWQobmV4dE5hbWUpO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IHBhcnNlU3RhdGVtZW50cygkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICBcIiwgXCIgPSAkY3R4LndyYXBZaWVsZFN0YXIoXCIsIFwiW1N5bWJvbC5pdGVyYXRvcl0oKSk7XFxuICAgICAgICAvLyByZWNlaXZlZCA9IHZvaWQgMDtcXG4gICAgICAgICRjdHguc2VudCA9IHZvaWQgMDtcXG4gICAgICAgIC8vIHNlbmQgPSB0cnVlOyAvLyByb3VnaGx5IGVxdWl2YWxlbnRcXG4gICAgICAgICRjdHguYWN0aW9uID0gJ25leHQnO1xcblxcbiAgICAgICAgZm9yICg7Oykge1xcbiAgICAgICAgICBcIiwgXCIgPSBcIiwgXCJbJGN0eC5hY3Rpb25dKCRjdHguc2VudElnbm9yZVRocm93KTtcXG4gICAgICAgICAgaWYgKFwiLCBcIi5kb25lKSB7XFxuICAgICAgICAgICAgJGN0eC5zZW50ID0gXCIsIFwiLnZhbHVlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHlpZWxkIFwiLCBcIi52YWx1ZTtcXG4gICAgICAgIH1cIl0pLCBnLCBleHByZXNzaW9uLCBuZXh0LCBnLCBuZXh0LCBuZXh0LCBuZXh0KTtcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZFRocm93Q2xvc2VTdGF0ZSA9IHRoaXMuc2hvdWxkQXBwZW5kVGhyb3dDbG9zZVN0YXRlXztcbiAgICAgICAgdGhpcy5zaG91bGRBcHBlbmRUaHJvd0Nsb3NlU3RhdGVfID0gZmFsc2U7XG4gICAgICAgIHN0YXRlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3Qoc3RhdGVtZW50cyk7XG4gICAgICAgIHZhciB5aWVsZE1hY2hpbmUgPSB0aGlzLnRyYW5zZm9ybVN0YXRlbWVudExpc3RfKHN0YXRlbWVudHMpO1xuICAgICAgICB0aGlzLnNob3VsZEFwcGVuZFRocm93Q2xvc2VTdGF0ZV8gPSBzaG91bGRBcHBlbmRUaHJvd0Nsb3NlU3RhdGU7XG4gICAgICAgIGlmIChtYWNoaW5lKVxuICAgICAgICAgIHlpZWxkTWFjaGluZSA9IG1hY2hpbmUuYXBwZW5kKHlpZWxkTWFjaGluZSk7XG4gICAgICAgIHJldHVybiB5aWVsZE1hY2hpbmU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMucmVwb3J0ZXIucmVwb3J0RXJyb3IodHJlZS5sb2NhdGlvbiwgJ09ubHkgXFwnYSA9IHlpZWxkIGJcXCcgYW5kIFxcJ3ZhciBhID0geWllbGQgYlxcJyBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1ZaWVsZEFzc2lnbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZFRocm93Q2xvc2VTdGF0ZSA9IHRoaXMuc2hvdWxkQXBwZW5kVGhyb3dDbG9zZVN0YXRlXztcbiAgICAgICAgdGhpcy5zaG91bGRBcHBlbmRUaHJvd0Nsb3NlU3RhdGVfID0gZmFsc2U7XG4gICAgICAgIHZhciBtYWNoaW5lID0gdGhpcy50cmFuc2Zvcm1ZaWVsZEV4cHJlc3Npb25fKHRyZWUucmlnaHQpO1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubGVmdCk7XG4gICAgICAgIHZhciBzZW50RXhwcmVzc2lvbiA9IHRyZWUucmlnaHQuaXNZaWVsZEZvciA/IHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJGN0eC5zZW50SWdub3JlVGhyb3dcIl0pKSA6IHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJGN0eC5zZW50XCJdKSk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnQgPSBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCBuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBsZWZ0LCB0cmVlLm9wZXJhdG9yLCBzZW50RXhwcmVzc2lvbikpO1xuICAgICAgICB2YXIgYXNzaWduTWFjaGluZSA9IHRoaXMuc3RhdGVtZW50VG9TdGF0ZU1hY2hpbmVfKHN0YXRlbWVudCk7XG4gICAgICAgIHRoaXMuc2hvdWxkQXBwZW5kVGhyb3dDbG9zZVN0YXRlXyA9IHNob3VsZEFwcGVuZFRocm93Q2xvc2VTdGF0ZTtcbiAgICAgICAgcmV0dXJuIG1hY2hpbmUuYXBwZW5kKGFzc2lnbk1hY2hpbmUpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVRocm93Q2xvc2VTdGF0ZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZW1lbnRUb1N0YXRlTWFjaGluZV8ocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRjdHgubWF5YmVUaHJvdygpXCJdKSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0cmVlLmV4cHJlc3Npb247XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IFlJRUxEX0VYUFJFU1NJT04pXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtWWllbGRFeHByZXNzaW9uXyhleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGlzWWllbGRBc3NpZ24oZXhwcmVzc2lvbikpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtWWllbGRBc3NpZ25fKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uVG9TdGF0ZU1hY2hpbmUoZXhwcmVzc2lvbikubWFjaGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEdlbmVyYXRvclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1FeHByZXNzaW9uU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQXdhaXRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRlci5yZXBvcnRFcnJvcih0cmVlLmxvY2F0aW9uLCAnR2VuZXJhdG9yIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBhbiBhd2FpdCBzdGF0ZW1lbnQuJyk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVJldHVyblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMjtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBtYWNoaW5lO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uTmVlZHNTdGF0ZU1hY2hpbmUodHJlZS5leHByZXNzaW9uKSlcbiAgICAgICAgICAoKCRfXzIgPSB0aGlzLmV4cHJlc3Npb25Ub1N0YXRlTWFjaGluZSh0cmVlLmV4cHJlc3Npb24pLCBleHByZXNzaW9uID0gJF9fMi5leHByZXNzaW9uLCBtYWNoaW5lID0gJF9fMi5tYWNoaW5lLCAkX18yKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBleHByZXNzaW9uID0gdHJlZS5leHByZXNzaW9uO1xuICAgICAgICB2YXIgc3RhcnRTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgZmFsbFRocm91Z2hTdGF0ZSA9IHRoaXMuYWxsb2NhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgcmV0dXJuTWFjaGluZSA9IHRoaXMuc3RhdGVUb1N0YXRlTWFjaGluZV8obmV3IFJldHVyblN0YXRlKHN0YXJ0U3RhdGUsIGZhbGxUaHJvdWdoU3RhdGUsIHRoaXMudHJhbnNmb3JtQW55KGV4cHJlc3Npb24pKSwgZmFsbFRocm91Z2hTdGF0ZSk7XG4gICAgICAgIGlmIChtYWNoaW5lKVxuICAgICAgICAgIHJldHVybiBtYWNoaW5lLmFwcGVuZChyZXR1cm5NYWNoaW5lKTtcbiAgICAgICAgcmV0dXJuIHJldHVybk1hY2hpbmU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtR2VuZXJhdG9yQm9keTogZnVuY3Rpb24odHJlZSwgbmFtZSkge1xuICAgICAgICB2YXIgY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UgPSB0aGlzLmdldFJ1bnRpbWVFeHByZXNzaW9uKCdjcmVhdGVHZW5lcmF0b3JJbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1DcHNGdW5jdGlvbkJvZHkodHJlZSwgY3JlYXRlR2VuZXJhdG9ySW5zdGFuY2UsIG5hbWUpO1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm1HZW5lcmF0b3JCb2R5OiBmdW5jdGlvbihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucywgYm9keSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRvclRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKS50cmFuc2Zvcm1HZW5lcmF0b3JCb2R5KGJvZHksIG5hbWUpO1xuICAgICAgfX0sICRfX3N1cGVyKTtcbiAgfShJbXBvcnRSdW50aW1lVHJhaXQoQ1BTVHJhbnNmb3JtZXIpKTtcbiAgO1xuICByZXR1cm4ge2dldCBHZW5lcmF0b3JUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBHZW5lcmF0b3JUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9HZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiO1xuICB2YXIgQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9HZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIpKS5BcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXI7XG4gIHZhciBBc3luY1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vZ2VuZXJhdG9yL0FzeW5jVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLkFzeW5jVHJhbnNmb3JtZXI7XG4gIHZhciBGb3JJblRyYW5zZm9ybVBhc3MgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9nZW5lcmF0b3IvRm9ySW5UcmFuc2Zvcm1QYXNzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9HZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIpKS5Gb3JJblRyYW5zZm9ybVBhc3M7XG4gIHZhciBHZW5lcmF0b3JUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2dlbmVyYXRvci9HZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiKSkuR2VuZXJhdG9yVHJhbnNmb3JtZXI7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgcGFyc2VFeHByZXNzaW9uID0gJF9fOC5wYXJzZUV4cHJlc3Npb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzgucGFyc2VTdGF0ZW1lbnQ7XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLlRlbXBWYXJUcmFuc2Zvcm1lcjtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5qc1wiKSkuZGVmYXVsdDtcbiAgdmFyIEZpbmRJbkZ1bmN0aW9uU2NvcGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9GaW5kSW5GdW5jdGlvblNjb3BlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9HZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIpKS5GaW5kSW5GdW5jdGlvblNjb3BlO1xuICB2YXIgJF9fMTIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fMTIuQW5vbkJsb2NrLFxuICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbiA9ICRfXzEyLkZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICBGdW5jdGlvbkV4cHJlc3Npb24gPSAkX18xMi5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciAkX18xMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIikpLFxuICAgICAgY3JlYXRlQmluZGluZ0lkZW50aWZpZXIgPSAkX18xMy5jcmVhdGVCaW5kaW5nSWRlbnRpZmllcixcbiAgICAgIGlkID0gJF9fMTMuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyVG9rZW4gPSAkX18xMy5jcmVhdGVJZGVudGlmaWVyVG9rZW47XG4gIHZhciBGb3JJbkZpbmRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRm9ySW5GaW5kZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGb3JJbkZpbmRlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZvckluRmluZGVyLCB7dmlzaXRGb3JJblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRJbkZ1bmN0aW9uU2NvcGUpO1xuICBmdW5jdGlvbiBuZWVkc1RyYW5zZm9ybSh0cmVlLCB0cmFuc2Zvcm1PcHRpb25zKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybU9wdGlvbnMuZ2VuZXJhdG9ycyAmJiB0cmVlLmlzR2VuZXJhdG9yKCkgfHwgdHJhbnNmb3JtT3B0aW9ucy5hc3luY0Z1bmN0aW9ucyAmJiB0cmVlLmlzQXN5bmNGdW5jdGlvbigpO1xuICB9XG4gIHZhciBHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudHJhbmZvcm1PcHRpb25zXyA9IG9wdGlvbnMudHJhbnNmb3JtT3B0aW9ucztcbiAgICAgIHRoaXMuaW5CbG9ja18gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEdlbmVyYXRvclRyYW5zZm9ybVBhc3MsIHtcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCFuZWVkc1RyYW5zZm9ybSh0cmVlLCB0aGlzLnRyYW5mb3JtT3B0aW9uc18pKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25EZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICBpZiAodHJlZS5pc0dlbmVyYXRvcigpKVxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUdlbmVyYXRvckRlY2xhcmF0aW9uXyh0cmVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRnVuY3Rpb25fKHRyZWUsIEZ1bmN0aW9uRGVjbGFyYXRpb24sIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUdlbmVyYXRvckRlY2xhcmF0aW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZUlkRXhwcmVzc2lvbiA9IGlkKHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW4pO1xuICAgICAgICB2YXIgaW5pdEdlbmVyYXRvckZ1bmN0aW9uID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignaW5pdEdlbmVyYXRvckZ1bmN0aW9uJyk7XG4gICAgICAgIHZhciBzZXR1cFByb3RvdHlwZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIihcIiwgXCIpXCJdKSwgaW5pdEdlbmVyYXRvckZ1bmN0aW9uLCBuYW1lSWRFeHByZXNzaW9uKTtcbiAgICAgICAgdmFyIHRtcFZhciA9IGlkKHRoaXMuaW5CbG9ja18gPyB0aGlzLmdldFRlbXBJZGVudGlmaWVyKCkgOiB0aGlzLmFkZFRlbXBWYXIoc2V0dXBQcm90b3R5cGVFeHByZXNzaW9uKSk7XG4gICAgICAgIHZhciBmdW5jRGVjbCA9IHRoaXMudHJhbnNmb3JtRnVuY3Rpb25fKHRyZWUsIEZ1bmN0aW9uRGVjbGFyYXRpb24sIHRtcFZhcik7XG4gICAgICAgIGlmICghdGhpcy5pbkJsb2NrXylcbiAgICAgICAgICByZXR1cm4gZnVuY0RlY2w7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIFtmdW5jRGVjbCwgcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInZhciBcIiwgXCIgPSBcIiwgXCJcIl0pLCB0bXBWYXIsIHNldHVwUHJvdG90eXBlRXhwcmVzc2lvbildKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCFuZWVkc1RyYW5zZm9ybSh0cmVlLCB0aGlzLnRyYW5mb3JtT3B0aW9uc18pKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25FeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIGlmICh0cmVlLmlzR2VuZXJhdG9yKCkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VuZXJhdG9yRXhwcmVzc2lvbl8odHJlZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9uXyh0cmVlLCBGdW5jdGlvbkV4cHJlc3Npb24sIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUdlbmVyYXRvckV4cHJlc3Npb25fOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBpZiAoIXRyZWUubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4odGhpcy5nZXRUZW1wSWRlbnRpZmllcigpKTtcbiAgICAgICAgICB0cmVlID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcihuYW1lKSwgdHJlZS5mdW5jdGlvbktpbmQsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS50eXBlQW5ub3RhdGlvbiwgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gdHJlZS5uYW1lLmlkZW50aWZpZXJUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuY3Rpb25FeHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1GdW5jdGlvbl8odHJlZSwgRnVuY3Rpb25FeHByZXNzaW9uLCBpZChuYW1lKSk7XG4gICAgICAgIHZhciBpbml0R2VuZXJhdG9yRnVuY3Rpb24gPSB0aGlzLmdldFJ1bnRpbWVFeHByZXNzaW9uKCdpbml0R2VuZXJhdG9yRnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCBpbml0R2VuZXJhdG9yRnVuY3Rpb24sIGZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25fOiBmdW5jdGlvbih0cmVlLCBjb25zdHJ1Y3RvciwgbmFtZUV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyICRfXzIgPSB0aGlzO1xuICAgICAgICB2YXIgYm9keSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1BbnlcIikuY2FsbCh0aGlzLCB0cmVlLmJvZHkpO1xuICAgICAgICB2YXIgZmluZGVyID0gbmV3IEZvckluRmluZGVyKCk7XG4gICAgICAgIGZpbmRlci52aXNpdEFueShib2R5KTtcbiAgICAgICAgaWYgKGZpbmRlci5mb3VuZCkge1xuICAgICAgICAgIGJvZHkgPSBuZXcgRm9ySW5UcmFuc2Zvcm1QYXNzKHRoaXMuaWRlbnRpZmllckdlbmVyYXRvciwgdGhpcy5yZXBvcnRlciwgdGhpcy5vcHRpb25zKS50cmFuc2Zvcm1BbnkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbmZvcm1PcHRpb25zXy5nZW5lcmF0b3JzICYmIHRyZWUuaXNHZW5lcmF0b3IoKSkge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBHZW5lcmF0b3JUcmFuc2Zvcm1lcih0aGlzLmlkZW50aWZpZXJHZW5lcmF0b3IsIHRoaXMucmVwb3J0ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgYm9keSA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybUdlbmVyYXRvckJvZHkoYm9keSwgbmFtZUV4cHJlc3Npb24pO1xuICAgICAgICAgIHRyYW5zZm9ybWVyLnJlcXVpcmVkTmFtZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAkX18yLmFkZEltcG9ydGVkTmFtZShuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5mb3JtT3B0aW9uc18uYXN5bmNGdW5jdGlvbnMgJiYgdHJlZS5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lciRfXzMgPSBuZXcgQXN5bmNUcmFuc2Zvcm1lcih0aGlzLmlkZW50aWZpZXJHZW5lcmF0b3IsIHRoaXMucmVwb3J0ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgYm9keSA9IHRyYW5zZm9ybWVyJF9fMy50cmFuc2Zvcm1Bc3luY0JvZHkoYm9keSwgbmFtZUV4cHJlc3Npb24pO1xuICAgICAgICAgIHRyYW5zZm9ybWVyJF9fMy5yZXF1aXJlZE5hbWVzLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICAgICAgJF9fMi5hZGRJbXBvcnRlZE5hbWUobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmN0aW9uS2luZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IodHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCBmdW5jdGlvbktpbmQsIHRyZWUucGFyYW1ldGVyTGlzdCwgdHJlZS50eXBlQW5ub3RhdGlvbiB8fCBudWxsLCB0cmVlLmFubm90YXRpb25zIHx8IG51bGwsIGJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycm93RnVuY3Rpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0cmVlLmlzQXN5bmNGdW5jdGlvbigpKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgR2VuZXJhdG9yVHJhbnNmb3JtUGFzcy5wcm90b3R5cGUsIFwidHJhbnNmb3JtQXJyb3dGdW5jdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BbnkoQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0aGlzLCB0cmVlKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmxvY2s6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluQmxvY2sgPSB0aGlzLmluQmxvY2tfO1xuICAgICAgICB0aGlzLmluQmxvY2tfID0gdHJ1ZTtcbiAgICAgICAgdmFyIHJ2ID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEdlbmVyYXRvclRyYW5zZm9ybVBhc3MucHJvdG90eXBlLCBcInRyYW5zZm9ybUJsb2NrXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHRoaXMuaW5CbG9ja18gPSBpbkJsb2NrO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShJbXBvcnRSdW50aW1lVHJhaXQoVGVtcFZhclRyYW5zZm9ybWVyKSk7XG4gIHJldHVybiB7Z2V0IEdlbmVyYXRvclRyYW5zZm9ybVBhc3MoKSB7XG4gICAgICByZXR1cm4gR2VuZXJhdG9yVHJhbnNmb3JtUGFzcztcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbmxpbmVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubGluZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBWQVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5saW5lTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLlZBUjtcbiAgdmFyIE1vZHVsZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTW9kdWxlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubGluZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5Nb2R1bGVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbmxpbmVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVCaW5kaW5nSWRlbnRpZmllciA9ICRfXzMuY3JlYXRlQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBjcmVhdGVFbXB0eVN0YXRlbWVudCA9ICRfXzMuY3JlYXRlRW1wdHlTdGF0ZW1lbnQsXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18zLmNyZWF0ZUZ1bmN0aW9uQm9keSxcbiAgICAgIGNyZWF0ZUltbWVkaWF0ZWx5SW52b2tlZEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICRfXzMuY3JlYXRlSW1tZWRpYXRlbHlJbnZva2VkRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX18zLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgYW5vbklubGluZU1vZHVsZXMgPSAwO1xuICB2YXIgSW5saW5lTW9kdWxlVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIElubGluZU1vZHVsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW5saW5lTW9kdWxlVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbmxpbmVNb2R1bGVUcmFuc2Zvcm1lciwge1xuICAgICAgd3JhcE1vZHVsZTogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgc2VlZCA9IHRoaXMubW9kdWxlTmFtZSB8fCAnYW5vbl8nICsgKythbm9uSW5saW5lTW9kdWxlcztcbiAgICAgICAgdmFyIGlkTmFtZSA9IHRoaXMuZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVOYW1lKHNlZWQpO1xuICAgICAgICB2YXIgYm9keSA9IGNyZWF0ZUZ1bmN0aW9uQm9keShzdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIG1vZHVsZUV4cHJlc3Npb24gPSBjcmVhdGVJbW1lZGlhdGVseUludm9rZWRGdW5jdGlvbkV4cHJlc3Npb24oYm9keSk7XG4gICAgICAgIHJldHVybiBbY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoVkFSLCBpZE5hbWUsIG1vZHVsZUV4cHJlc3Npb24pXTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1OYW1lZEV4cG9ydDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Nb2R1bGVTcGVjaWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyKHRoaXMuZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVTcGVjaWZpZXIodHJlZSkpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oTW9kdWxlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBJbmxpbmVNb2R1bGVUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBJbmxpbmVNb2R1bGVUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0luc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fMTAuQW5vbkJsb2NrLFxuICAgICAgQXJyYXlMaXRlcmFsID0gJF9fMTAuQXJyYXlMaXRlcmFsLFxuICAgICAgQ2xhc3NFeHByZXNzaW9uID0gJF9fMTAuQ2xhc3NFeHByZXNzaW9uLFxuICAgICAgQ29tbWFFeHByZXNzaW9uID0gJF9fMTAuQ29tbWFFeHByZXNzaW9uLFxuICAgICAgRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzEwLkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fMTAuVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgdmFyICRfXzExID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFOT05fQkxPQ0sgPSAkX18xMS5BTk9OX0JMT0NLLFxuICAgICAgQ0xBU1NfREVDTEFSQVRJT04gPSAkX18xMS5DTEFTU19ERUNMQVJBVElPTixcbiAgICAgIEZVTkNUSU9OX0RFQ0xBUkFUSU9OID0gJF9fMTEuRlVOQ1RJT05fREVDTEFSQVRJT04sXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX18xMS5JREVOVElGSUVSX0VYUFJFU1NJT04sXG4gICAgICBJTVBPUlRfU1BFQ0lGSUVSX1NFVCA9ICRfXzExLklNUE9SVF9TUEVDSUZJRVJfU0VULFxuICAgICAgTkFNRV9TUEFDRV9JTVBPUlQgPSAkX18xMS5OQU1FX1NQQUNFX0lNUE9SVDtcbiAgdmFyIFBhcnNlVHJlZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1BhcnNlVHJlZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0luc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVZpc2l0b3I7XG4gIHZhciBTY29wZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU2NvcGVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuU2NvcGVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzE0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QgPSAkX18xNC5jcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QsXG4gICAgICBjcmVhdGVGdW5jdGlvbkJvZHkgPSAkX18xNC5jcmVhdGVGdW5jdGlvbkJvZHksXG4gICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24gPSAkX18xNC5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBpZCA9ICRfXzE0LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlT2JqZWN0TGl0ZXJhbEZvckRlc2NyaXB0b3IgPSAkX18xNC5jcmVhdGVPYmplY3RMaXRlcmFsRm9yRGVzY3JpcHRvcixcbiAgICAgIGNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSA9ICRfXzE0LmNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSxcbiAgICAgIGNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gJF9fMTQuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QsXG4gICAgICBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudCA9ICRfXzE0LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgTW9kdWxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Nb2R1bGVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuTW9kdWxlVHJhbnNmb3JtZXI7XG4gIHZhciAkX18xNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIE1JTlVTX01JTlVTID0gJF9fMTYuTUlOVVNfTUlOVVMsXG4gICAgICBQTFVTX1BMVVMgPSAkX18xNi5QTFVTX1BMVVMsXG4gICAgICBWQVIgPSAkX18xNi5WQVI7XG4gIHZhciAkX18xNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbiA9ICRfXzE3LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fMTcucGFyc2VTdGF0ZW1lbnQsXG4gICAgICBwYXJzZVN0YXRlbWVudHMgPSAkX18xNy5wYXJzZVN0YXRlbWVudHM7XG4gIHZhciBIb2lzdFZhcmlhYmxlc1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuZGVmYXVsdDtcbiAgZnVuY3Rpb24gZmxhdHRlbkFub25CbG9ja3Moc3RhdGVtZW50cykge1xuICAgIHZhciAkX185O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgaWYgKHN0YXRlbWVudC50eXBlID09PSBBTk9OX0JMT0NLKSB7XG4gICAgICAgICgkX185ID0gcmVzdWx0KS5wdXNoLmFwcGx5KCRfXzksICR0cmFjZXVyUnVudGltZS5zcHJlYWQoc3RhdGVtZW50LnN0YXRlbWVudHMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIEV4cG9ydEJpbmRpbmdzVmlzaXRvciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRXhwb3J0QmluZGluZ3NWaXNpdG9yKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRXhwb3J0QmluZGluZ3NWaXNpdG9yKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRXhwb3J0QmluZGluZ3NWaXNpdG9yLCB7XG4gICAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nSWRlbnRpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmJpbmRpbmdzLnB1c2godHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYmluZGluZyk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVWaXNpdG9yKTtcbiAgdmFyIERlY2xhcmF0aW9uRXh0cmFjdGlvblRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBEZWNsYXJhdGlvbkV4dHJhY3Rpb25UcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKERlY2xhcmF0aW9uRXh0cmFjdGlvblRyYW5zZm9ybWVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5kZWNsYXJhdGlvbnNfID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShEZWNsYXJhdGlvbkV4dHJhY3Rpb25UcmFuc2Zvcm1lciwge1xuICAgICAgZ2V0RGVjbGFyYXRpb25TdGF0ZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5Bbm9uQmxvY2tzKCR0cmFjZXVyUnVudGltZS5zcHJlYWQoW3RoaXMuZ2V0VmFyaWFibGVTdGF0ZW1lbnQoKV0sIHRoaXMuZGVjbGFyYXRpb25zXykpO1xuICAgICAgfSxcbiAgICAgIGFkZERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zXy5wdXNoKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGREZWNsYXJhdGlvbih0cmVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRWYXJpYWJsZSh0cmVlLm5hbWUuaWRlbnRpZmllclRva2VuLnZhbHVlKTtcbiAgICAgICAgdHJlZSA9IG5ldyBDbGFzc0V4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCB0cmVlLnN1cGVyQ2xhc3MsIHRyZWUuZWxlbWVudHMsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIiA9IFwiLCBcIlwiXSksIHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW4sIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSG9pc3RWYXJpYWJsZXNUcmFuc2Zvcm1lcik7XG4gIHZhciBNb2R1bGVOYW1lSWRlbnRpZmllclRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBNb2R1bGVOYW1lSWRlbnRpZmllclRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTW9kdWxlTmFtZUlkZW50aWZpZXJUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCAnX19tb2R1bGVOYW1lJyk7XG4gICAgICB0aGlzLnVzZXNNb2R1bGVOYW1lID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNb2R1bGVOYW1lSWRlbnRpZmllclRyYW5zZm9ybWVyLCB7dHJhbnNmb3JtSWRlbnRpZmllckV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuaWRlbnRpZmllclRva2VuLnZhbHVlID09PSAnX19tb2R1bGVOYW1lJykge1xuICAgICAgICAgIHRoaXMudXNlc01vZHVsZU5hbWUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX21vZHVsZUNvbnRleHQuaWRcIl0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIE1vZHVsZU5hbWVJZGVudGlmaWVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShTY29wZVRyYW5zZm9ybWVyKTtcbiAgdmFyIEluc2VydEJpbmRpbmdBc3NpZ25tZW50VHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEluc2VydEJpbmRpbmdBc3NpZ25tZW50VHJhbnNmb3JtZXIoZXhwb3J0TmFtZSwgYmluZGluZ05hbWUpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEluc2VydEJpbmRpbmdBc3NpZ25tZW50VHJhbnNmb3JtZXIpLmNhbGwodGhpcywgYmluZGluZ05hbWUpO1xuICAgICAgdGhpcy5iaW5kaW5nTmFtZV8gPSBiaW5kaW5nTmFtZTtcbiAgICAgIHRoaXMuZXhwb3J0TmFtZV8gPSBleHBvcnROYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSW5zZXJ0QmluZGluZ0Fzc2lnbm1lbnRUcmFuc2Zvcm1lciwge1xuICAgICAgbWF0Y2hlc0JpbmRpbmdOYW1lXzogZnVuY3Rpb24oYmluZGluZykge1xuICAgICAgICByZXR1cm4gYmluZGluZy50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04gJiYgYmluZGluZy5pZGVudGlmaWVyVG9rZW4udmFsdWUgPT09IHRoaXMuYmluZGluZ05hbWVfO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2hlc0JpbmRpbmdOYW1lXyh0cmVlLm9wZXJhbmQpKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5zZXJ0QmluZGluZ0Fzc2lnbm1lbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtVW5hcnlFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBvcGVyYXRvclR5cGUgPSB0cmVlLm9wZXJhdG9yLnR5cGU7XG4gICAgICAgIGlmIChvcGVyYXRvclR5cGUgIT09IFBMVVNfUExVUyAmJiBvcGVyYXRvclR5cGUgIT09IE1JTlVTX01JTlVTKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5zZXJ0QmluZGluZ0Fzc2lnbm1lbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtVW5hcnlFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgaWYgKG9wZXJhbmQgIT09IHRyZWUub3BlcmFuZClcbiAgICAgICAgICB0cmVlID0gbmV3IFVuYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm9wZXJhdG9yLCBvcGVyYW5kKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJF9fZXhwb3J0KFwiLCBcIiwgXCIsIFwiKVwiXSksIHRoaXMuZXhwb3J0TmFtZV8sIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVBvc3RmaXhFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgSW5zZXJ0QmluZGluZ0Fzc2lnbm1lbnRUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtUG9zdGZpeEV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXNCaW5kaW5nTmFtZV8odHJlZS5vcGVyYW5kKSlcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgc3dpdGNoICh0cmVlLm9wZXJhdG9yLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFBMVVNfUExVUzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIigkX19leHBvcnQoXCIsIFwiLCBcIiwgXCIgKyAxKSwgXCIsIFwiKVwiXSksIHRoaXMuZXhwb3J0TmFtZV8sIHRyZWUub3BlcmFuZCwgdHJlZSk7XG4gICAgICAgICAgY2FzZSBNSU5VU19NSU5VUzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIigkX19leHBvcnQoXCIsIFwiLCBcIiwgXCIgLSAxKSwgXCIsIFwiKVwiXSksIHRoaXMuZXhwb3J0TmFtZV8sIHRyZWUub3BlcmFuZCwgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0cmVlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEluc2VydEJpbmRpbmdBc3NpZ25tZW50VHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgaWYgKCF0cmVlLm9wZXJhdG9yLmlzQXNzaWdubWVudE9wZXJhdG9yKCkpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaGVzQmluZGluZ05hbWVfKHRyZWUubGVmdCkpXG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX2V4cG9ydChcIiwgXCIsIFwiLCBcIil9XCJdKSwgdGhpcy5leHBvcnROYW1lXywgdHJlZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShTY29wZVRyYW5zZm9ybWVyKTtcbiAgdmFyIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIoaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW5zdGFudGlhdGVNb2R1bGVUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCBpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFub255bW91c01vZHVsZSA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuYnVuZGxlICYmIG9wdGlvbnMubW9kdWxlTmFtZSAhPT0gdHJ1ZTtcbiAgICAgIHRoaXMudXNlc01vZHVsZU5hbWUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5FeHBvcnRfID0gZmFsc2U7XG4gICAgICB0aGlzLmN1ckRlcEluZGV4XyA9IG51bGw7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgdGhpcy5leHRlcm5hbEV4cG9ydEJpbmRpbmdzID0gW107XG4gICAgICB0aGlzLmltcG9ydEJpbmRpbmdzID0gW107XG4gICAgICB0aGlzLmxvY2FsRXhwb3J0QmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMubW9kdWxlQmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuZXhwb3J0U3RhckJpbmRpbmdzID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLCB7XG4gICAgICBnZXRNb2R1bGVOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFub255bW91c01vZHVsZSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyZWUubW9kdWxlTmFtZTtcbiAgICAgIH0sXG4gICAgICBtb2R1bGVQcm9sb2c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgd3JhcE1vZHVsZTogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgcHJvbG9nID0gW2NyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSgpXTtcbiAgICAgICAgc3RhdGVtZW50cyA9IHByb2xvZy5jb25jYXQoc3RhdGVtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXNNb2R1bGVOYW1lKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50cygkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiU3lzdGVtLnJlZ2lzdGVyKFwiLCBcIixcXG4gICAgICAgICAgICBcIiwgXCIsIGZ1bmN0aW9uKCRfX2V4cG9ydCwgJF9fbW9kdWxlQ29udGV4dCkge1xcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgfSk7XCJdKSwgdGhpcy5tb2R1bGVOYW1lLCB0aGlzLmRlcGVuZGVuY2llcywgc3RhdGVtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlN5c3RlbS5yZWdpc3RlcihcIiwgXCIsIGZ1bmN0aW9uKCRfX2V4cG9ydCwgJF9fbW9kdWxlQ29udGV4dCkge1xcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICB9KTtcIl0pLCB0aGlzLmRlcGVuZGVuY2llcywgc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kdWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlN5c3RlbS5yZWdpc3RlcihcIiwgXCIsXFxuICAgICAgICAgIFwiLCBcIiwgZnVuY3Rpb24oJF9fZXhwb3J0KSB7XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIH0pO1wiXSksIHRoaXMubW9kdWxlTmFtZSwgdGhpcy5kZXBlbmRlbmNpZXMsIHN0YXRlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudHMoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlN5c3RlbS5yZWdpc3RlcihcIiwgXCIsIGZ1bmN0aW9uKCRfX2V4cG9ydCkge1xcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIH0pO1wiXSksIHRoaXMuZGVwZW5kZW5jaWVzLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICBhZGRFeHBvcnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyICRfXzYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25FeHRyYWN0aW9uVHJhbnNmb3JtZXIgPSBuZXcgRGVjbGFyYXRpb25FeHRyYWN0aW9uVHJhbnNmb3JtZXIoKTtcbiAgICAgICAgdmFyIG1vZHVsZU5hbWVJZGVudGlmaWVyVHJhbnNmb3JtZXIgPSBuZXcgTW9kdWxlTmFtZUlkZW50aWZpZXJUcmFuc2Zvcm1lcigpO1xuICAgICAgICBzdGF0ZW1lbnRzID0gbW9kdWxlTmFtZUlkZW50aWZpZXJUcmFuc2Zvcm1lci50cmFuc2Zvcm1MaXN0KHN0YXRlbWVudHMpO1xuICAgICAgICBpZiAobW9kdWxlTmFtZUlkZW50aWZpZXJUcmFuc2Zvcm1lci51c2VzTW9kdWxlTmFtZSlcbiAgICAgICAgICB0aGlzLnVzZXNNb2R1bGVOYW1lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2NhbEV4cG9ydEJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24oYmluZGluZykge1xuICAgICAgICAgIHN0YXRlbWVudHMgPSBuZXcgSW5zZXJ0QmluZGluZ0Fzc2lnbm1lbnRUcmFuc2Zvcm1lcihiaW5kaW5nLmV4cG9ydE5hbWUsIGJpbmRpbmcubG9jYWxOYW1lKS50cmFuc2Zvcm1MaXN0KHN0YXRlbWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV4ZWN1dGlvblN0YXRlbWVudHMgPSBkZWNsYXJhdGlvbkV4dHJhY3Rpb25UcmFuc2Zvcm1lci50cmFuc2Zvcm1MaXN0KHN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgZXhlY3V0aW9uRnVuY3Rpb24gPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRW1wdHlQYXJhbWV0ZXJMaXN0KCksIGNyZWF0ZUZ1bmN0aW9uQm9keShleGVjdXRpb25TdGF0ZW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvblN0YXRlbWVudHMgPSBkZWNsYXJhdGlvbkV4dHJhY3Rpb25UcmFuc2Zvcm1lci5nZXREZWNsYXJhdGlvblN0YXRlbWVudHMoKTtcbiAgICAgICAgdmFyIHNldHRlckZ1bmN0aW9ucyA9IHRoaXMuZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbihkZXAsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGltcG9ydEJpbmRpbmdzID0gJF9fNi5pbXBvcnRCaW5kaW5nc1tpbmRleF07XG4gICAgICAgICAgdmFyIGV4dGVybmFsRXhwb3J0QmluZGluZ3MgPSAkX182LmV4dGVybmFsRXhwb3J0QmluZGluZ3NbaW5kZXhdO1xuICAgICAgICAgIHZhciBleHBvcnRTdGFyQmluZGluZyA9ICRfXzYuZXhwb3J0U3RhckJpbmRpbmdzW2luZGV4XTtcbiAgICAgICAgICB2YXIgbW9kdWxlQmluZGluZyA9ICRfXzYubW9kdWxlQmluZGluZ3NbaW5kZXhdO1xuICAgICAgICAgIHZhciBzZXR0ZXJTdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgaWYgKGltcG9ydEJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpbXBvcnRCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgc2V0dGVyU3RhdGVtZW50cy5wdXNoKHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcIiwgXCIgPSAkX19tLlwiLCBcIjtcIl0pLCBpZChiaW5kaW5nLnZhcmlhYmxlTmFtZSksIGJpbmRpbmcuZXhwb3J0TmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRlcm5hbEV4cG9ydEJpbmRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgcmVleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGV4dGVybmFsRXhwb3J0QmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbigkX183KSB7XG4gICAgICAgICAgICAgIHZhciAkX184ID0gJF9fNyxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAkX184LmV4cG9ydE5hbWUsXG4gICAgICAgICAgICAgICAgICBpbXBvcnROYW1lID0gJF9fOC5pbXBvcnROYW1lO1xuICAgICAgICAgICAgICByZWV4cG9ydHNbZXhwb3J0TmFtZV0gPSBpbXBvcnROYW1lID09PSBudWxsID8gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkX19tXCJdKSkgOiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX20uXCIsIFwiXCJdKSwgaW1wb3J0TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldHRlclN0YXRlbWVudHMucHVzaChwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJF9fZXhwb3J0KFwiLCBcIilcIl0pLCBjcmVhdGVPYmplY3RMaXRlcmFsRm9yRGVzY3JpcHRvcihyZWV4cG9ydHMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2R1bGVCaW5kaW5nKSB7XG4gICAgICAgICAgICBzZXR0ZXJTdGF0ZW1lbnRzLnB1c2gocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIiA9ICRfX207XCJdKSwgaWQobW9kdWxlQmluZGluZykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4cG9ydFN0YXJCaW5kaW5nKSB7XG4gICAgICAgICAgICBzZXR0ZXJTdGF0ZW1lbnRzID0gc2V0dGVyU3RhdGVtZW50cy5jb25jYXQocGFyc2VTdGF0ZW1lbnRzKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgdmFyIGV4cG9ydE9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XFxuICAgICAgICAgIE9iamVjdC5rZXlzKCRfX20pLmZvckVhY2goZnVuY3Rpb24ocCkge1xcbiAgICAgICAgICAgIGlmIChwICE9PSAnZGVmYXVsdCcgJiYgISRfX2V4cG9ydE5hbWVzW3BdKVxcbiAgICAgICAgICAgICAgZXhwb3J0T2JqW3BdID0gJF9fbVtwXTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgICRfX2V4cG9ydChleHBvcnRPYmopO1xcbiAgICAgICAgXCJdKSkpO1xuICAgICAgICAgICAgdmFyIGV4cG9ydE5hbWVzID0ge307XG4gICAgICAgICAgICAkX182LmxvY2FsRXhwb3J0QmluZGluZ3MuY29uY2F0KCRfXzYuZXh0ZXJuYWxFeHBvcnRCaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbihiaW5kaW5nKSB7XG4gICAgICAgICAgICAgIGV4cG9ydE5hbWVzW2JpbmRpbmcuZXhwb3J0TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblN0YXRlbWVudHMucHVzaChwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICAgIHZhciAkX19leHBvcnROYW1lcyA9IFwiLCBcIjtcXG4gICAgICAgIFwiXSksIGNyZWF0ZU9iamVjdExpdGVyYWxGb3JEZXNjcmlwdG9yKGV4cG9ydE5hbWVzKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2V0dGVyU3RhdGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImZ1bmN0aW9uKCRfX20pIHtcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICB9XCJdKSwgc2V0dGVyU3RhdGVtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImZ1bmN0aW9uKCRfX20pIHt9XCJdKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWNsYXJhdGlvblN0YXRlbWVudHMgPSBkZWNsYXJhdGlvblN0YXRlbWVudHMuY29uY2F0KHRoaXMuZnVuY3Rpb25EZWNsYXJhdGlvbnMubWFwKGZ1bmN0aW9uKGJpbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX2V4cG9ydChcIiwgXCIsIFwiLCBcIilcIl0pLCBiaW5kaW5nLmV4cG9ydE5hbWUsIGlkKGJpbmRpbmcuZnVuY3Rpb25OYW1lKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZGVjbGFyYXRpb25TdGF0ZW1lbnRzLnB1c2gocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInJldHVybiB7XFxuICAgICAgc2V0dGVyczogXCIsIFwiLFxcbiAgICAgIGV4ZWN1dGU6IFwiLCBcIlxcbiAgICB9XCJdKSwgbmV3IEFycmF5TGl0ZXJhbChudWxsLCBzZXR0ZXJGdW5jdGlvbnMpLCBleGVjdXRpb25GdW5jdGlvbikpO1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25TdGF0ZW1lbnRzO1xuICAgICAgfSxcbiAgICAgIGFkZExvY2FsRXhwb3J0QmluZGluZzogZnVuY3Rpb24oZXhwb3J0TmFtZSkge1xuICAgICAgICB2YXIgbG9jYWxOYW1lID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IGV4cG9ydE5hbWU7XG4gICAgICAgIHRoaXMubG9jYWxFeHBvcnRCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICBleHBvcnROYW1lOiBleHBvcnROYW1lLFxuICAgICAgICAgIGxvY2FsTmFtZTogbG9jYWxOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGFkZEltcG9ydEJpbmRpbmc6IGZ1bmN0aW9uKGRlcEluZGV4LCB2YXJpYWJsZU5hbWUsIGV4cG9ydE5hbWUpIHtcbiAgICAgICAgdGhpcy5pbXBvcnRCaW5kaW5nc1tkZXBJbmRleF0gPSB0aGlzLmltcG9ydEJpbmRpbmdzW2RlcEluZGV4XSB8fCBbXTtcbiAgICAgICAgdGhpcy5pbXBvcnRCaW5kaW5nc1tkZXBJbmRleF0ucHVzaCh7XG4gICAgICAgICAgdmFyaWFibGVOYW1lOiB2YXJpYWJsZU5hbWUsXG4gICAgICAgICAgZXhwb3J0TmFtZTogZXhwb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRFeHRlcm5hbEV4cG9ydEJpbmRpbmc6IGZ1bmN0aW9uKGRlcEluZGV4LCBleHBvcnROYW1lLCBpbXBvcnROYW1lKSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxFeHBvcnRCaW5kaW5nc1tkZXBJbmRleF0gPSB0aGlzLmV4dGVybmFsRXhwb3J0QmluZGluZ3NbZGVwSW5kZXhdIHx8IFtdO1xuICAgICAgICB0aGlzLmV4dGVybmFsRXhwb3J0QmluZGluZ3NbZGVwSW5kZXhdLnB1c2goe1xuICAgICAgICAgIGV4cG9ydE5hbWU6IGV4cG9ydE5hbWUsXG4gICAgICAgICAgaW1wb3J0TmFtZTogaW1wb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhZGRFeHBvcnRTdGFyQmluZGluZzogZnVuY3Rpb24oZGVwSW5kZXgpIHtcbiAgICAgICAgdGhpcy5leHBvcnRTdGFyQmluZGluZ3NbZGVwSW5kZXhdID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBhZGRNb2R1bGVCaW5kaW5nOiBmdW5jdGlvbihkZXBJbmRleCwgdmFyaWFibGVOYW1lKSB7XG4gICAgICAgIHRoaXMubW9kdWxlQmluZGluZ3NbZGVwSW5kZXhdID0gdmFyaWFibGVOYW1lO1xuICAgICAgfSxcbiAgICAgIGFkZEV4cG9ydEZ1bmN0aW9uOiBmdW5jdGlvbihleHBvcnROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogZXhwb3J0TmFtZTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkRlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBleHBvcnROYW1lOiBleHBvcnROYW1lLFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldE9yQ3JlYXRlRGVwZW5kZW5jeUluZGV4OiBmdW5jdGlvbihtb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBtb2R1bGVTcGVjaWZpZXIudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgIHZhciBkZXBJbmRleCA9IHRoaXMuZGVwZW5kZW5jaWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgIGlmIChkZXBJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBkZXBJbmRleCA9IHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBJbmRleDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmluRXhwb3J0XyA9IHRydWU7XG4gICAgICAgIGlmICh0cmVlLmRlY2xhcmF0aW9uLm1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICAgIHRoaXMuY3VyRGVwSW5kZXhfID0gdGhpcy5nZXRPckNyZWF0ZURlcGVuZGVuY3lJbmRleCh0cmVlLmRlY2xhcmF0aW9uLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJEZXBJbmRleF8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZGVjbGFyYXRpb24pO1xuICAgICAgICB0aGlzLmluRXhwb3J0XyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluRXhwb3J0XylcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVZhcmlhYmxlU3RhdGVtZW50XCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHRoaXMuaW5FeHBvcnRfID0gZmFsc2U7XG4gICAgICAgIHZhciBiaW5kaW5nVmlzaXRvciA9IG5ldyBFeHBvcnRCaW5kaW5nc1Zpc2l0b3IoKTtcbiAgICAgICAgYmluZGluZ1Zpc2l0b3IudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZGluZ1Zpc2l0b3IuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllclRva2VuID0gYmluZGluZ1Zpc2l0b3IuYmluZGluZ3NbaV0uaWRlbnRpZmllclRva2VuO1xuICAgICAgICAgIHZhciBuYW1lID0gaWRlbnRpZmllclRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMuYWRkTG9jYWxFeHBvcnRCaW5kaW5nKG5hbWUpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJF9fZXhwb3J0KFwiLCBcIiwgXCIsIFwiKVwiXSksIG5hbWUsIGlkKGlkZW50aWZpZXJUb2tlbikpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQoJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUFueVwiKS5jYWxsKHRoaXMsIHRyZWUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgc3RhdGVtZW50cyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwb3J0U3RhcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmluRXhwb3J0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkZEV4cG9ydFN0YXJCaW5kaW5nKHRoaXMuY3VyRGVwSW5kZXhfKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluRXhwb3J0XylcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgdGhpcy5pbkV4cG9ydF8gPSBmYWxzZTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJUb2tlbiA9IHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW47XG4gICAgICAgIHZhciBuYW1lID0gaWRlbnRpZmllclRva2VuLnZhbHVlO1xuICAgICAgICB0aGlzLmFkZExvY2FsRXhwb3J0QmluZGluZyhuYW1lKTtcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKSwgcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX2V4cG9ydChcIiwgXCIsIFwiLCBcIilcIl0pLCBuYW1lLCBpZChpZGVudGlmaWVyVG9rZW4pKV07XG4gICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIHN0YXRlbWVudHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5FeHBvcnRfKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0cmVlLm5hbWUuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmFkZExvY2FsRXhwb3J0QmluZGluZyhuYW1lKTtcbiAgICAgICAgICB0aGlzLmFkZEV4cG9ydEZ1bmN0aW9uKG5hbWUpO1xuICAgICAgICAgIHRoaXMuaW5FeHBvcnRfID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBJbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTmFtZWRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICB2YXIgZXhwb3J0Q2xhdXNlID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHBvcnRDbGF1c2UpO1xuICAgICAgICBpZiAodGhpcy5jdXJEZXBJbmRleF8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0Q2xhdXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIFtdKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmN1ckRlcEluZGV4XyA9IHRoaXMuZ2V0T3JDcmVhdGVEZXBlbmRlbmN5SW5kZXgodHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIGlmICghdHJlZS5pbXBvcnRDbGF1c2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGltcG9ydENsYXVzZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuaW1wb3J0Q2xhdXNlKTtcbiAgICAgICAgaWYgKHRyZWUuaW1wb3J0Q2xhdXNlLnR5cGUgPT09IE5BTUVfU1BBQ0VfSU1QT1JUKSB7XG4gICAgICAgICAgdmFyIGJpbmRpbmdJZGVudGlmaWVyID0gdHJlZS5pbXBvcnRDbGF1c2UuYmluZGluZy5iaW5kaW5nO1xuICAgICAgICAgIHZhciBuYW1lID0gYmluZGluZ0lkZW50aWZpZXIuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICB0aGlzLmFkZE1vZHVsZUJpbmRpbmcodGhpcy5jdXJEZXBJbmRleF8sIG5hbWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1widmFyIFwiLCBcIjtcIl0pLCBiaW5kaW5nSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuaW1wb3J0Q2xhdXNlLnR5cGUgPT09IElNUE9SVF9TUEVDSUZJRVJfU0VUKSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydENsYXVzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZGluZ05hbWUgPSB0cmVlLmltcG9ydENsYXVzZS5iaW5kaW5nLmdldFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgIHRoaXMuYWRkSW1wb3J0QmluZGluZyh0aGlzLmN1ckRlcEluZGV4XywgYmluZGluZ05hbWUsICdkZWZhdWx0Jyk7XG4gICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1widmFyIFwiLCBcIjtcIl0pLCBiaW5kaW5nTmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW1wb3J0U3BlY2lmaWVyU2V0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChjcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChWQVIsIHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnNwZWNpZmllcnMpKSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwb3J0RGVmYXVsdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmluRXhwb3J0XyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuYWRkTG9jYWxFeHBvcnRCaW5kaW5nKCdkZWZhdWx0Jyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IENMQVNTX0RFQ0xBUkFUSU9OKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBDbGFzc0V4cHJlc3Npb24oZXhwcmVzc2lvbi5sb2NhdGlvbiwgZXhwcmVzc2lvbi5uYW1lLCBleHByZXNzaW9uLnN1cGVyQ2xhc3MsIGV4cHJlc3Npb24uZWxlbWVudHMsIGV4cHJlc3Npb24uYW5ub3RhdGlvbnMsIGV4cHJlc3Npb24udHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IEZVTkNUSU9OX0RFQ0xBUkFUSU9OKSB7XG4gICAgICAgICAgdGhpcy5hZGRFeHBvcnRGdW5jdGlvbignZGVmYXVsdCcsIGV4cHJlc3Npb24ubmFtZS5pZGVudGlmaWVyVG9rZW4udmFsdWUpO1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJF9fZXhwb3J0KCdkZWZhdWx0JywgXCIsIFwiKTtcIl0pLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwb3J0TmFtZTtcbiAgICAgICAgdmFyIGJpbmRpbmdOYW1lO1xuICAgICAgICBpZiAodHJlZS5yaHMpIHtcbiAgICAgICAgICBleHBvcnROYW1lID0gdHJlZS5yaHMudmFsdWU7XG4gICAgICAgICAgYmluZGluZ05hbWUgPSB0cmVlLmxocy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnROYW1lID0gdHJlZS5saHMudmFsdWU7XG4gICAgICAgICAgYmluZGluZ05hbWUgPSBleHBvcnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1ckRlcEluZGV4XyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYWRkRXh0ZXJuYWxFeHBvcnRCaW5kaW5nKHRoaXMuY3VyRGVwSW5kZXhfLCBleHBvcnROYW1lLCBiaW5kaW5nTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRMb2NhbEV4cG9ydEJpbmRpbmcoZXhwb3J0TmFtZSwgYmluZGluZ05hbWUpO1xuICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiRfX2V4cG9ydChcIiwgXCIsIFwiLCBcIik7XCJdKSwgZXhwb3J0TmFtZSwgaWQoYmluZGluZ05hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFNwZWNpZmllclNldDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnNwZWNpZmllcnMpO1xuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgbmV3IENvbW1hRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBzcGVjaWZpZXJzLmZpbHRlcihmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3BlY2lmaWVyO1xuICAgICAgICB9KSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5hbWVTcGFjZUV4cG9ydDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmFkZEV4dGVybmFsRXhwb3J0QmluZGluZyh0aGlzLmN1ckRlcEluZGV4XywgdHJlZS5uYW1lLnZhbHVlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yd2FyZERlZmF1bHRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5hZGRFeHRlcm5hbEV4cG9ydEJpbmRpbmcodGhpcy5jdXJEZXBJbmRleF8sIHRyZWUubmFtZS52YWx1ZSwgJ2RlZmF1bHQnKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsb2NhbEJpbmRpbmcgPSB0cmVlLmJpbmRpbmcuYmluZGluZztcbiAgICAgICAgdmFyIGxvY2FsQmluZGluZ1Rva2VuID0gbG9jYWxCaW5kaW5nLmlkZW50aWZpZXJUb2tlbjtcbiAgICAgICAgdmFyIGltcG9ydE5hbWUgPSAodHJlZS5uYW1lIHx8IGxvY2FsQmluZGluZ1Rva2VuKS52YWx1ZTtcbiAgICAgICAgdGhpcy5hZGRJbXBvcnRCaW5kaW5nKHRoaXMuY3VyRGVwSW5kZXhfLCBsb2NhbEJpbmRpbmdUb2tlbi52YWx1ZSwgaW1wb3J0TmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCBsb2NhbEJpbmRpbmcsIG51bGwsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmN1ckRlcEluZGV4XyA9IHRoaXMuZ2V0T3JDcmVhdGVEZXBlbmRlbmN5SW5kZXgodHJlZSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oTW9kdWxlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBJbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBTUFJFQURfRVhQUkVTU0lPTiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyLmpzXCIpKS5TUFJFQURfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlT2JqZWN0TGl0ZXJhbCA9ICRfXzIuY3JlYXRlT2JqZWN0TGl0ZXJhbCxcbiAgICAgIGNyZWF0ZUFyZ3VtZW50TGlzdCA9ICRfXzIuY3JlYXRlQXJndW1lbnRMaXN0O1xuICB2YXIgcGFyc2VFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1NwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VFeHByZXNzaW9uO1xuICB2YXIgSW1wb3J0UnVudGltZVRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICBmdW5jdGlvbiBoYXNTcHJlYWQodHJlZXMpIHtcbiAgICByZXR1cm4gdHJlZXMuc29tZShmdW5jdGlvbih0cmVlKSB7XG4gICAgICByZXR1cm4gdHJlZSAmJiB0cmVlLnR5cGUgPT09IFNQUkVBRF9FWFBSRVNTSU9OO1xuICAgIH0pO1xuICB9XG4gIHZhciBTcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIsIHt0cmFuc2Zvcm1PYmplY3RMaXRlcmFsOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghaGFzU3ByZWFkKHRyZWUucHJvcGVydHlOYW1lQW5kVmFsdWVzKSkge1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1PYmplY3RMaXRlcmFsXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5wcm9wZXJ0eU5hbWVBbmRWYWx1ZXMpO1xuICAgICAgICByZXR1cm4gc3ByZWFkUHJvcGVydGllcyhwcm9wZXJ0aWVzLCB0aGlzKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lcikpO1xuICBmdW5jdGlvbiBzcHJlYWRQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHNlbGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBhY2N1bW11bGF0ZWRQcm9wcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgaWYgKHByb3BlcnR5LnR5cGUgPT09IFNQUkVBRF9FWFBSRVNTSU9OKSB7XG4gICAgICAgIGlmIChhY2N1bW11bGF0ZWRQcm9wcykge1xuICAgICAgICAgIGFyZ3MucHVzaChjcmVhdGVPYmplY3RMaXRlcmFsKGFjY3VtbXVsYXRlZFByb3BzKSk7XG4gICAgICAgICAgYWNjdW1tdWxhdGVkUHJvcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChwcm9wZXJ0eS5leHByZXNzaW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghYWNjdW1tdWxhdGVkUHJvcHMpIHtcbiAgICAgICAgICBhY2N1bW11bGF0ZWRQcm9wcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtbXVsYXRlZFByb3BzLnB1c2gocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWNjdW1tdWxhdGVkUHJvcHMpIHtcbiAgICAgIGFyZ3MucHVzaChjcmVhdGVPYmplY3RMaXRlcmFsKGFjY3VtbXVsYXRlZFByb3BzKSk7XG4gICAgfVxuICAgIHZhciBydW50aW1lID0gc2VsZi5nZXRSdW50aW1lRXhwcmVzc2lvbignc3ByZWFkUHJvcGVydGllcycpO1xuICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIihcIiwgXCIpXCJdKSwgcnVudGltZSwgY3JlYXRlQXJndW1lbnRMaXN0KGFyZ3MpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBTcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyO1xuICAgIH0sXG4gICAgZ2V0IHNwcmVhZFByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4gc3ByZWFkUHJvcGVydGllcztcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSnN4VHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Kc3hUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgJF9fNCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSnN4VHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgSlNYX0VMRU1FTlQgPSAkX180LkpTWF9FTEVNRU5ULFxuICAgICAgSlNYX1BMQUNFSE9MREVSID0gJF9fNC5KU1hfUExBQ0VIT0xERVIsXG4gICAgICBKU1hfU1BSRUFEX0FUVFJJQlVURSA9ICRfXzQuSlNYX1NQUkVBRF9BVFRSSUJVVEUsXG4gICAgICBKU1hfVEVYVCA9ICRfXzQuSlNYX1RFWFQsXG4gICAgICBMSVRFUkFMX0VYUFJFU1NJT04gPSAkX180LkxJVEVSQUxfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0pzeFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEpzeFRleHQgPSAkX181LkpzeFRleHQsXG4gICAgICBMaXRlcmFsRXhwcmVzc2lvbiA9ICRfXzUuTGl0ZXJhbEV4cHJlc3Npb24sXG4gICAgICBMaXRlcmFsUHJvcGVydHlOYW1lID0gJF9fNS5MaXRlcmFsUHJvcGVydHlOYW1lLFxuICAgICAgU3ByZWFkRXhwcmVzc2lvbiA9ICRfXzUuU3ByZWFkRXhwcmVzc2lvbjtcbiAgdmFyIExpdGVyYWxUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvTGl0ZXJhbFRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Kc3hUcmFuc2Zvcm1lci5qc1wiKSkuTGl0ZXJhbFRva2VuO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSnN4VHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgU1RSSU5HID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0pzeFRyYW5zZm9ybWVyLmpzXCIpKS5TVFJJTkc7XG4gIHZhciAkX185ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSnN4VHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXJndW1lbnRMaXN0ID0gJF9fOS5jcmVhdGVBcmd1bWVudExpc3QsXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzkuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyVG9rZW4gPSAkX185LmNyZWF0ZUlkZW50aWZpZXJUb2tlbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX185LmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdWxsTGl0ZXJhbCA9ICRfXzkuY3JlYXRlTnVsbExpdGVyYWwsXG4gICAgICBjcmVhdGVPYmplY3RMaXRlcmFsID0gJF9fOS5jcmVhdGVPYmplY3RMaXRlcmFsLFxuICAgICAgY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudCA9ICRfXzkuY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudCxcbiAgICAgIGNyZWF0ZVN0cmluZ0xpdGVyYWwgPSAkX185LmNyZWF0ZVN0cmluZ0xpdGVyYWwsXG4gICAgICBjcmVhdGVTdHJpbmdMaXRlcmFsVG9rZW4gPSAkX185LmNyZWF0ZVN0cmluZ0xpdGVyYWxUb2tlbixcbiAgICAgIGNyZWF0ZVRydWVMaXRlcmFsID0gJF9fOS5jcmVhdGVUcnVlTGl0ZXJhbDtcbiAgdmFyIHBhcnNlRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Kc3hUcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VFeHByZXNzaW9uO1xuICB2YXIgc3ByZWFkUHJvcGVydGllcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1NwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSnN4VHJhbnNmb3JtZXIuanNcIikpLnNwcmVhZFByb3BlcnRpZXM7XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0pzeFRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgSnN4VHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEpzeFRyYW5zZm9ybWVyKGlkR2VuLCByZXBvcnRlciwgb3B0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSnN4VHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5qc3hGdW5jdGlvbl8gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSnN4VHJhbnNmb3JtZXIsIHtcbiAgICAgIGdldEpzeEZ1bmN0aW9uXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5qc3hGdW5jdGlvbl8pIHtcbiAgICAgICAgICB2YXIganN4ID0gdGhpcy5vcHRpb25zLmpzeDtcbiAgICAgICAgICBpZiAodHlwZW9mIGpzeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuanN4RnVuY3Rpb25fID0gcGFyc2VFeHByZXNzaW9uKFtqc3hdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5qc3hGdW5jdGlvbl8gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlJlYWN0LmNyZWF0ZUVsZW1lbnRcIl0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanN4RnVuY3Rpb25fO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeEVsZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm5hbWUpO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnRyYW5zZm9ybUpzeEF0dHJpYnV0ZXNfKHRyZWUpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnRyYW5zZm9ybUpzeENoaWxkcmVuXyh0cmVlLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBjcmVhdGVBcmd1bWVudExpc3QoJHRyYWNldXJSdW50aW1lLnNwcmVhZChbbmFtZSwgcHJvcHNdLCBjaGlsZHJlbikpO1xuICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcIiwgXCIoXCIsIFwiKVwiXSksIHRoaXMuZ2V0SnN4RnVuY3Rpb25fKCksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeEF0dHJpYnV0ZXNfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoYXR0cnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU51bGxMaXRlcmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuYXR0cmlidXRlcy5zb21lKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gYS50eXBlID09PSBKU1hfU1BSRUFEX0FUVFJJQlVURTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gc3ByZWFkUHJvcGVydGllcyhhdHRycywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdExpdGVyYWwoYXR0cnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeEVsZW1lbnROYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRyZWUubmFtZXNbMF0udmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlWzBdID09PSB2YWx1ZVswXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odmFsdWUpO1xuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gdHJlZS5uYW1lcy5tYXAoanN4SWRlbnRpZmllclRvVG9rZW4pO1xuICAgICAgICB2YXIgb3BlcmFuZCA9IG5hbWVzWzBdO1xuICAgICAgICBpZiAob3BlcmFuZC50eXBlID09PSBTVFJJTkcpIHtcbiAgICAgICAgICBuYW1lc1swXSA9IG5ldyBMaXRlcmFsRXhwcmVzc2lvbihvcGVyYW5kLmxvY2F0aW9uLCBvcGVyYW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTWVtYmVyRXhwcmVzc2lvbi5hcHBseSgodm9pZCAwKSwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChuYW1lcykpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeEF0dHJpYnV0ZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5ldyBMaXRlcmFsUHJvcGVydHlOYW1lKHRyZWUubmFtZS5sb2NhdGlvbiwganN4SWRlbnRpZmllclRvVG9rZW4odHJlZS5uYW1lKSk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHRyZWUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNyZWF0ZVRydWVMaXRlcmFsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJlZS52YWx1ZS50eXBlID09PSBMSVRFUkFMX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICB2YXIgbGl0ZXJhbFRva2VuID0gdHJlZS52YWx1ZS5saXRlcmFsVG9rZW47XG4gICAgICAgICAgdmFyIHYgPSBsaXRlcmFsVG9rZW4udmFsdWU7XG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gbGl0ZXJhbFRva2VuLmxvY2F0aW9uO1xuICAgICAgICAgIHZhciBsaXQgPSBuZXcgTGl0ZXJhbFRva2VuKFNUUklORywgbm9ybWFsaXplQXR0cmlidXRlVmFsdWUodiksIGxvY2F0aW9uKTtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBMaXRlcmFsRXhwcmVzc2lvbihsb2NhdGlvbiwgbGl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVQcm9wZXJ0eU5hbWVBc3NpZ25tZW50KG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hQbGFjZWhvbGRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Kc3hTcHJlYWRBdHRyaWJ1dGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJlYWRFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZXhwcmVzc2lvbikpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUpzeFRleHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0xpdGVyYWwodHJlZS52YWx1ZS52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSnN4Q2hpbGRyZW5fOiBmdW5jdGlvbih0cmVlcykge1xuICAgICAgICB2YXIgJF9fMSA9IHRoaXM7XG4gICAgICAgIHZhciBydiA9IFtdO1xuICAgICAgICB0cmVlcy5mb3JFYWNoKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgbmV3VHJlZTtcbiAgICAgICAgICBzd2l0Y2ggKHRyZWUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBKU1hfRUxFTUVOVDpcbiAgICAgICAgICAgICAgbmV3VHJlZSA9ICRfXzEudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSlNYX1BMQUNFSE9MREVSOlxuICAgICAgICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1RyZWUgPSAkX18xLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEpTWF9URVhUOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0cmVlLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL1xcdC9nLCAnICcpO1xuICAgICAgICAgICAgICAgIGlmICghL1tcXG5cXHJdLy50ZXN0KHMpKSB7XG4gICAgICAgICAgICAgICAgICBuZXdUcmVlID0gY3JlYXRlU3RyaW5nTGl0ZXJhbChzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgvXlsgXFx0XSpbXFxuXFxyXVxccyovLCAnJyk7XG4gICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9bIFxcdF0qW1xcblxccl1cXHMqJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdUcmVlID0gY3JlYXRlU3RyaW5nTGl0ZXJhbChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcnYucHVzaChuZXdUcmVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEltcG9ydFJ1bnRpbWVUcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lcikpO1xuICBmdW5jdGlvbiBqc3hJZGVudGlmaWVyVG9Ub2tlbih0b2tlbikge1xuICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgIGlmICh2YWx1ZS5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTGl0ZXJhbFRva2VuKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUlkZW50aWZpZXJUb2tlbih2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXR0cmlidXRlVmFsdWUocykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXG5cXHMrL2csICcgJykpO1xuICB9XG4gIHJldHVybiB7Z2V0IEpzeFRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIEpzeFRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlQ29uc3RydWN0b3JUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlQ29uc3RydWN0b3JUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgTWV0aG9kID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZUNvbnN0cnVjdG9yVHJhbnNmb3JtZXIuanNcIikpLk1ldGhvZDtcbiAgdmFyIFNVUEVSX0VYUFJFU1NJT04gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlQ29uc3RydWN0b3JUcmFuc2Zvcm1lci5qc1wiKSkuU1VQRVJfRVhQUkVTU0lPTjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlQ29uc3RydWN0b3JUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWVtYmVyVmFyaWFibGVDb25zdHJ1Y3RvclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUNvbW1hRXhwcmVzc2lvbiA9ICRfXzQuY3JlYXRlQ29tbWFFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzQuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uQm9keSA9ICRfXzQuY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fNC5jcmVhdGVQYXJlbkV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzQuY3JlYXRlVGhpc0V4cHJlc3Npb247XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZUNvbnN0cnVjdG9yVHJhbnNmb3JtZXIuanNcIikpLnByZXBlbmRTdGF0ZW1lbnRzO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1Db25zdHJ1Y3Rvcihjb25zdHJ1Y3RvciwgaW5pdEV4cHJlc3Npb24sIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAoc3VwZXJDbGFzcykge1xuICAgICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IFN1cGVyQ2FsbFRyYW5zZm9ybWVyKGluaXRFeHByZXNzaW9uKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lci50cmFuc2Zvcm1BbnkoY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICB2YXIgc3RhdGVtZW50cyA9IGNvbnN0cnVjdG9yLmJvZHkuc3RhdGVtZW50cztcbiAgICB2YXIgaW5pdFN0YXRlbWVudCA9IGNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQoaW5pdEV4cHJlc3Npb24pO1xuICAgIHN0YXRlbWVudHMgPSBwcmVwZW5kU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBpbml0U3RhdGVtZW50KTtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChjb25zdHJ1Y3Rvci5sb2NhdGlvbiwgZmFsc2UsIGNvbnN0cnVjdG9yLmZ1bmN0aW9uS2luZCwgY29uc3RydWN0b3IubmFtZSwgY29uc3RydWN0b3IucGFyYW1ldGVyTGlzdCwgY29uc3RydWN0b3IudHlwZUFubm90YXRpb24sIGNvbnN0cnVjdG9yLmFubm90YXRpb25zLCBjcmVhdGVGdW5jdGlvbkJvZHkoc3RhdGVtZW50cyksIGNvbnN0cnVjdG9yLmRlYnVnTmFtZSk7XG4gIH1cbiAgdmFyIFN1cGVyQ2FsbFRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBTdXBlckNhbGxUcmFuc2Zvcm1lcihleHByZXNzaW9uKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTdXBlckNhbGxUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTdXBlckNhbGxUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZC50eXBlID09PSBTVVBFUl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgdmFyIHRoaXNFeHByZXNzaW9uID0gY3JlYXRlVGhpc0V4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihbdHJlZSwgdGhpcy5leHByZXNzaW9uLCB0aGlzRXhwcmVzc2lvbl0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFN1cGVyQ2FsbFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCB0cmFuc2Zvcm1Db25zdHJ1Y3RvcigpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Db25zdHJ1Y3RvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgQ09OU1RSVUNUT1IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIpKS5DT05TVFJVQ1RPUjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fNS5Bbm9uQmxvY2ssXG4gICAgICBDbGFzc0RlY2xhcmF0aW9uID0gJF9fNS5DbGFzc0RlY2xhcmF0aW9uLFxuICAgICAgQ2xhc3NFeHByZXNzaW9uID0gJF9fNS5DbGFzc0V4cHJlc3Npb24sXG4gICAgICBGb3JtYWxQYXJhbWV0ZXJMaXN0ID0gJF9fNS5Gb3JtYWxQYXJhbWV0ZXJMaXN0LFxuICAgICAgSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX181LklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgTWV0aG9kID0gJF9fNS5NZXRob2QsXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQgPSAkX181LlJldHVyblN0YXRlbWVudDtcbiAgdmFyICRfXzYgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL01lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgR0VUX0FDQ0VTU09SID0gJF9fNi5HRVRfQUNDRVNTT1IsXG4gICAgICBNRVRIT0QgPSAkX182Lk1FVEhPRCxcbiAgICAgIFBST1BFUlRZX1ZBUklBQkxFX0RFQ0xBUkFUSU9OID0gJF9fNi5QUk9QRVJUWV9WQVJJQUJMRV9ERUNMQVJBVElPTixcbiAgICAgIFNFVF9BQ0NFU1NPUiA9ICRfXzYuU0VUX0FDQ0VTU09SO1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVDb21tYUV4cHJlc3Npb24gPSAkX184LmNyZWF0ZUNvbW1hRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uQm9keSA9ICRfXzguY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlSWRlbnRpZmllclRva2VuID0gJF9fOC5jcmVhdGVJZGVudGlmaWVyVG9rZW4sXG4gICAgICBjcmVhdGVJbW1lZGlhdGVseUludm9rZWRGdW5jdGlvbkV4cHJlc3Npb24gPSAkX184LmNyZWF0ZUltbWVkaWF0ZWx5SW52b2tlZEZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUxpdGVyYWxQcm9wZXJ0eU5hbWUgPSAkX184LmNyZWF0ZUxpdGVyYWxQcm9wZXJ0eU5hbWUsXG4gICAgICBjcmVhdGVSZXN0UGFyYW1ldGVyID0gJF9fOC5jcmVhdGVSZXN0UGFyYW1ldGVyO1xuICB2YXIgJF9fOSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uID0gJF9fOS5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fOS5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIHBhcnNlRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIpKS5wYXJzZUV4cHJlc3Npb247XG4gIHZhciBwcmVwZW5kU3RhdGVtZW50cyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1ByZXBlbmRTdGF0ZW1lbnRzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIpKS5wcmVwZW5kU3RhdGVtZW50cztcbiAgdmFyIHByb3BOYW1lID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N0YXRpY3NlbWFudGljcy9Qcm9wTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lci5qc1wiKSkucHJvcE5hbWU7XG4gIHZhciB0cmFuc2Zvcm1Db25zdHJ1Y3RvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL01lbWJlclZhcmlhYmxlQ29uc3RydWN0b3JUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lci5qc1wiKSkudHJhbnNmb3JtQ29uc3RydWN0b3I7XG4gIHZhciBNZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBNZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE1lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUNsYXNzRWxlbWVudHNfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBpbml0SW5zdGFuY2VWYXJzID0gW10sXG4gICAgICAgICAgICBpbml0U3RhdGljVmFycyA9IFtdO1xuICAgICAgICB2YXIgY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvckluZGV4ID0gMDtcbiAgICAgICAgdHJlZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgICB2YXIgaW5pdFZhcnM7XG4gICAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIGluaXRWYXJzID0gaW5pdFN0YXRpY1ZhcnM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRWYXJzID0gaW5pdEluc3RhbmNlVmFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0cmVlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgR0VUX0FDQ0VTU09SOlxuICAgICAgICAgICAgY2FzZSBTRVRfQUNDRVNTT1I6XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJF9fMi50cmFuc2Zvcm1BbnkodHJlZSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTUVUSE9EOlxuICAgICAgICAgICAgICBpZiAoIXRyZWUuaXNTdGF0aWMgJiYgcHJvcE5hbWUodHJlZSkgPT09IENPTlNUUlVDVE9SKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0cmVlO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9ySW5kZXggPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCgkX18yLnRyYW5zZm9ybUFueSh0cmVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBST1BFUlRZX1ZBUklBQkxFX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgICB0cmVlID0gJF9fMi50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5pdFZhcnMucHVzaCh0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJVbmV4cGVjdGVkIGNsYXNzIGVsZW1lbnQ6IFwiICsgdHJlZS50eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluaXRJbnN0YW5jZVZhcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBpbml0RXhwcmVzc2lvbiA9IGdldEluc3RhbmNlSW5pdEV4cHJlc3Npb24oaW5pdEluc3RhbmNlVmFycyk7XG4gICAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLmdldERlZmF1bHRDb25zdHJ1Y3Rvcl8odHJlZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cnVjdG9yID0gdHJhbnNmb3JtQ29uc3RydWN0b3IoY29uc3RydWN0b3IsIGluaXRFeHByZXNzaW9uLCB0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGVsZW1lbnRzLnNwbGljZShjb25zdHJ1Y3RvckluZGV4LCAwLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgaW5pdFN0YXRpY1ZhcnM6IGluaXRTdGF0aWNWYXJzXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgJF9fMyA9IHRoaXMudHJhbnNmb3JtQ2xhc3NFbGVtZW50c18odHJlZSksXG4gICAgICAgICAgICBlbGVtZW50cyA9ICRfXzMuZWxlbWVudHMsXG4gICAgICAgICAgICBpbml0U3RhdGljVmFycyA9ICRfXzMuaW5pdFN0YXRpY1ZhcnM7XG4gICAgICAgIHZhciBzdXBlckNsYXNzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgICAgdmFyIGNsYXNzRGVjbCA9IG5ldyBDbGFzc0RlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoaW5pdFN0YXRpY1ZhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzRGVjbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IGNyZWF0ZVN0YXRpY0luaXRpYWxpemVyU3RhdGVtZW50cyh0cmVlLm5hbWUuaWRlbnRpZmllclRva2VuLCBpbml0U3RhdGljVmFycyk7XG4gICAgICAgIHN0YXRlbWVudHMgPSBwcmVwZW5kU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjbGFzc0RlY2wpO1xuICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBzdGF0ZW1lbnRzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSB0aGlzLnRyYW5zZm9ybUNsYXNzRWxlbWVudHNfKHRyZWUpLFxuICAgICAgICAgICAgZWxlbWVudHMgPSAkX18zLmVsZW1lbnRzLFxuICAgICAgICAgICAgaW5pdFN0YXRpY1ZhcnMgPSAkX18zLmluaXRTdGF0aWNWYXJzO1xuICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBjbGFzc0V4cHJlc3Npb24gPSBuZXcgQ2xhc3NFeHByZXNzaW9uKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoaW5pdFN0YXRpY1ZhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNsYXNzRXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRUZW1wSWRlbnRpZmllcigpO1xuICAgICAgICB2YXIgaWRUb2tlbiA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihpZCk7XG4gICAgICAgIHZhciBpZEV4cHJlc3Npb24gPSBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24oaWRUb2tlbi5sb2NhdGlvbiwgaWRUb2tlbik7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLnNwcmVhZChbcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcImxldCBcIiwgXCIgPSBcIiwgXCJcIl0pLCBpZCwgY2xhc3NFeHByZXNzaW9uKV0sIGNyZWF0ZVN0YXRpY0luaXRpYWxpemVyU3RhdGVtZW50cyhpZFRva2VuLCBpbml0U3RhdGljVmFycyksIFtuZXcgUmV0dXJuU3RhdGVtZW50KG51bGwsIGlkRXhwcmVzc2lvbildKTtcbiAgICAgICAgdmFyIGJvZHkgPSBjcmVhdGVGdW5jdGlvbkJvZHkoc3RhdGVtZW50cyk7XG4gICAgICAgIHRoaXMucG9wVGVtcFNjb3BlKCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbW1lZGlhdGVseUludm9rZWRGdW5jdGlvbkV4cHJlc3Npb24oYm9keSk7XG4gICAgICB9LFxuICAgICAgZ2V0RGVmYXVsdENvbnN0cnVjdG9yXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5zdXBlckNsYXNzKSB7XG4gICAgICAgICAgdmFyIHBhcmFtID0gY3JlYXRlUmVzdFBhcmFtZXRlcihjcmVhdGVJZGVudGlmaWVyVG9rZW4oJ2FyZ3MnKSk7XG4gICAgICAgICAgdmFyIHBhcmFtTGlzdCA9IG5ldyBGb3JtYWxQYXJhbWV0ZXJMaXN0KG51bGwsIFtwYXJhbV0pO1xuICAgICAgICAgIHZhciBib2R5ID0gY3JlYXRlRnVuY3Rpb25Cb2R5KFtwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wic3VwZXIoLi4uYXJncylcIl0pKV0pO1xuICAgICAgICAgIHZhciBuYW1lID0gY3JlYXRlTGl0ZXJhbFByb3BlcnR5TmFtZShDT05TVFJVQ1RPUik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QodHJlZS5sb2NhdGlvbiwgZmFsc2UsIG51bGwsIG5hbWUsIHBhcmFtTGlzdCwgbnVsbCwgW10sIGJvZHksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVByb3BlcnR5RGVmaW5pdGlvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiY29uc3RydWN0b3IoKSB7fVwiXSkpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oVGVtcFZhclRyYW5zZm9ybWVyKTtcbiAgZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5pdGlhbGl6ZXJTdGF0ZW1lbnRzKGlkVG9rZW4sIGluaXRTdGF0aWNNZW1iZXJWYXJzKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IG5ldyBJZGVudGlmaWVyRXhwcmVzc2lvbihpZFRva2VuLmxvY2F0aW9uLCBpZFRva2VuKTtcbiAgICByZXR1cm4gaW5pdFN0YXRpY01lbWJlclZhcnMubWFwKGZ1bmN0aW9uKG12KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBtdi5uYW1lLmxpdGVyYWxUb2tlbi52YWx1ZTtcbiAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiT2JqZWN0LmRlZmluZVByb3BlcnR5KFwiLCBcIiwgXCIsIFwiLCB7ZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFwiLCBcIiwgd3JpdGFibGU6IHRydWV9KVwiXSksIGNsYXNzTmFtZSwgcHJvcE5hbWUsIG12LmluaXRpYWxpemVyKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRJbnN0YW5jZUluaXRFeHByZXNzaW9uKGluaXRJbnN0YW5jZVZhcnMpIHtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBpbml0SW5zdGFuY2VWYXJzLm1hcChmdW5jdGlvbihtdikge1xuICAgICAgdmFyIG5hbWUgPSBtdi5uYW1lLmxpdGVyYWxUb2tlbjtcbiAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInRoaXMuXCIsIFwiID0gXCIsIFwiXCJdKSwgbmFtZSwgbXYuaW5pdGlhbGl6ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVDb21tYUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xuICB9XG4gIHJldHVybiB7Z2V0IE1lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1BhcnNlVHJlZVdyaXRlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlV3JpdGVyLmpzXCI7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1BhcnNlVHJlZVdyaXRlci5qc1wiKSksXG4gICAgICBCTE9DSyA9ICRfXzQuQkxPQ0ssXG4gICAgICBDTEFTU19ERUNMQVJBVElPTiA9ICRfXzQuQ0xBU1NfREVDTEFSQVRJT04sXG4gICAgICBGVU5DVElPTl9ERUNMQVJBVElPTiA9ICRfXzQuRlVOQ1RJT05fREVDTEFSQVRJT04sXG4gICAgICBJRl9TVEFURU1FTlQgPSAkX180LklGX1NUQVRFTUVOVCxcbiAgICAgIExJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzQuTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgUE9TVEZJWF9FWFBSRVNTSU9OID0gJF9fNC5QT1NURklYX0VYUFJFU1NJT04sXG4gICAgICBVTkFSWV9FWFBSRVNTSU9OID0gJF9fNC5VTkFSWV9FWFBSRVNTSU9OO1xuICB2YXIgUGFyc2VUcmVlVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUGFyc2VUcmVlVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvb3V0cHV0Z2VuZXJhdGlvbi9QYXJzZVRyZWVXcml0ZXIuanNcIikpLlBhcnNlVHJlZVZpc2l0b3I7XG4gIHZhciAkX182ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QcmVkZWZpbmVkTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvb3V0cHV0Z2VuZXJhdGlvbi9QYXJzZVRyZWVXcml0ZXIuanNcIikpLFxuICAgICAgQVMgPSAkX182LkFTLFxuICAgICAgQVNZTkMgPSAkX182LkFTWU5DLFxuICAgICAgQVdBSVQgPSAkX182LkFXQUlULFxuICAgICAgRlJPTSA9ICRfXzYuRlJPTSxcbiAgICAgIEdFVCA9ICRfXzYuR0VULFxuICAgICAgT0YgPSAkX182Lk9GLFxuICAgICAgT04gPSAkX182Lk9OLFxuICAgICAgU0VUID0gJF9fNi5TRVQsXG4gICAgICBUWVBFID0gJF9fNi5UWVBFO1xuICB2YXIgJF9fNyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvU2Nhbm5lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvb3V0cHV0Z2VuZXJhdGlvbi9QYXJzZVRyZWVXcml0ZXIuanNcIikpLFxuICAgICAgaXNJZGVudGlmaWVyUGFydCA9ICRfXzcuaXNJZGVudGlmaWVyUGFydCxcbiAgICAgIGlzV2hpdGVzcGFjZSA9ICRfXzcuaXNXaGl0ZXNwYWNlO1xuICB2YXIgJF9fOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1BhcnNlVHJlZVdyaXRlci5qc1wiKSksXG4gICAgICBBUlJPVyA9ICRfXzguQVJST1csXG4gICAgICBBVCA9ICRfXzguQVQsXG4gICAgICBCQUNLX1FVT1RFID0gJF9fOC5CQUNLX1FVT1RFLFxuICAgICAgQkFSID0gJF9fOC5CQVIsXG4gICAgICBCUkVBSyA9ICRfXzguQlJFQUssXG4gICAgICBDQVNFID0gJF9fOC5DQVNFLFxuICAgICAgQ0FUQ0ggPSAkX184LkNBVENILFxuICAgICAgQ0xBU1MgPSAkX184LkNMQVNTLFxuICAgICAgQ0xPU0VfQU5HTEUgPSAkX184LkNMT1NFX0FOR0xFLFxuICAgICAgQ0xPU0VfQ1VSTFkgPSAkX184LkNMT1NFX0NVUkxZLFxuICAgICAgQ0xPU0VfUEFSRU4gPSAkX184LkNMT1NFX1BBUkVOLFxuICAgICAgQ0xPU0VfU1FVQVJFID0gJF9fOC5DTE9TRV9TUVVBUkUsXG4gICAgICBDT0xPTiA9ICRfXzguQ09MT04sXG4gICAgICBDT01NQSA9ICRfXzguQ09NTUEsXG4gICAgICBDT05USU5VRSA9ICRfXzguQ09OVElOVUUsXG4gICAgICBERUJVR0dFUiA9ICRfXzguREVCVUdHRVIsXG4gICAgICBERUZBVUxUID0gJF9fOC5ERUZBVUxULFxuICAgICAgRE8gPSAkX184LkRPLFxuICAgICAgRE9UX0RPVF9ET1QgPSAkX184LkRPVF9ET1RfRE9ULFxuICAgICAgRUxTRSA9ICRfXzguRUxTRSxcbiAgICAgIEVRVUFMID0gJF9fOC5FUVVBTCxcbiAgICAgIEVYUE9SVCA9ICRfXzguRVhQT1JULFxuICAgICAgRVhURU5EUyA9ICRfXzguRVhURU5EUyxcbiAgICAgIEZJTkFMTFkgPSAkX184LkZJTkFMTFksXG4gICAgICBGT1IgPSAkX184LkZPUixcbiAgICAgIEZVTkNUSU9OID0gJF9fOC5GVU5DVElPTixcbiAgICAgIElGID0gJF9fOC5JRixcbiAgICAgIElNUE9SVCA9ICRfXzguSU1QT1JULFxuICAgICAgSU4gPSAkX184LklOLFxuICAgICAgSU5URVJGQUNFID0gJF9fOC5JTlRFUkZBQ0UsXG4gICAgICBNSU5VUyA9ICRfXzguTUlOVVMsXG4gICAgICBNSU5VU19NSU5VUyA9ICRfXzguTUlOVVNfTUlOVVMsXG4gICAgICBORVcgPSAkX184Lk5FVyxcbiAgICAgIE5VTUJFUiA9ICRfXzguTlVNQkVSLFxuICAgICAgT1BFTl9BTkdMRSA9ICRfXzguT1BFTl9BTkdMRSxcbiAgICAgIE9QRU5fQ1VSTFkgPSAkX184Lk9QRU5fQ1VSTFksXG4gICAgICBPUEVOX1BBUkVOID0gJF9fOC5PUEVOX1BBUkVOLFxuICAgICAgT1BFTl9TUVVBUkUgPSAkX184Lk9QRU5fU1FVQVJFLFxuICAgICAgUEVSSU9EID0gJF9fOC5QRVJJT0QsXG4gICAgICBQTFVTID0gJF9fOC5QTFVTLFxuICAgICAgUExVU19QTFVTID0gJF9fOC5QTFVTX1BMVVMsXG4gICAgICBRVUVTVElPTiA9ICRfXzguUVVFU1RJT04sXG4gICAgICBSRVRVUk4gPSAkX184LlJFVFVSTixcbiAgICAgIFNFTUlfQ09MT04gPSAkX184LlNFTUlfQ09MT04sXG4gICAgICBTTEFTSCA9ICRfXzguU0xBU0gsXG4gICAgICBTVEFSID0gJF9fOC5TVEFSLFxuICAgICAgU1RBVElDID0gJF9fOC5TVEFUSUMsXG4gICAgICBTVVBFUiA9ICRfXzguU1VQRVIsXG4gICAgICBTV0lUQ0ggPSAkX184LlNXSVRDSCxcbiAgICAgIFRISVMgPSAkX184LlRISVMsXG4gICAgICBUSFJPVyA9ICRfXzguVEhST1csXG4gICAgICBUUlkgPSAkX184LlRSWSxcbiAgICAgIFdISUxFID0gJF9fOC5XSElMRSxcbiAgICAgIFdJVEggPSAkX184LldJVEgsXG4gICAgICBZSUVMRCA9ICRfXzguWUlFTEQ7XG4gIHZhciBORVdfTElORSA9ICdcXG4nO1xuICB2YXIgTElORV9MRU5HVEggPSA4MDtcbiAgdmFyIFBhcnNlVHJlZVdyaXRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VUcmVlV3JpdGVyKCkge1xuICAgICAgdmFyICRfXzM7XG4gICAgICB2YXIgJF9fMiA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBwcmV0dHlQcmludCA9ICgkX18zID0gJF9fMi5wcmV0dHlQcmludCkgPT09IHZvaWQgMCA/IHRydWUgOiAkX18zO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoUGFyc2VUcmVlV3JpdGVyKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5wcmV0dHlQcmludF8gPSBwcmV0dHlQcmludDtcbiAgICAgIHRoaXMucmVzdWx0XyA9ICcnO1xuICAgICAgdGhpcy5jdXJyZW50TGluZV8gPSAnJztcbiAgICAgIHRoaXMubGFzdENvZGVfID0gLTE7XG4gICAgICB0aGlzLmluZGVudERlcHRoXyA9IDA7XG4gICAgICB0aGlzLmN1cnJlbnRQYXJhbWV0ZXJUeXBlQW5ub3RhdGlvbl8gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUGFyc2VUcmVlV3JpdGVyLCB7XG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRMaW5lXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRfICs9IHRoaXMuY3VycmVudExpbmVfO1xuICAgICAgICAgIHRoaXMuY3VycmVudExpbmVfID0gJyc7XG4gICAgICAgICAgdGhpcy5sYXN0Q29kZV8gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QW5ub3RhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhBVCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgaWYgKHRyZWUuYXJncyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICAgIHRoaXMud3JpdGVMaXN0Xyh0cmVlLmFyZ3MuYXJncywgQ09NTUEsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEFyZ3VtZW50TGlzdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZUxpc3RfKHRyZWUuYXJncywgQ09NTUEsIGZhbHNlKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJyYXlDb21wcmVoZW5zaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5jb21wcmVoZW5zaW9uTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfU1FVQVJFKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFycmF5TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1NRVUFSRSk7XG4gICAgICAgIHRoaXMud3JpdGVMaXN0Xyh0cmVlLmVsZW1lbnRzLCBDT01NQSwgZmFsc2UpO1xuICAgICAgICBpZiAodHJlZS5lbGVtZW50c1t0cmVlLmVsZW1lbnRzLmxlbmd0aCAtIDFdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV8oQ09NTUEpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9TUVVBUkUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJyYXlQYXR0ZXJuOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgdGhpcy53cml0ZUxpc3RfKHRyZWUuZWxlbWVudHMsIENPTU1BLCBmYWxzZSk7XG4gICAgICAgIGlmICh0cmVlLmVsZW1lbnRzW3RyZWUuZWxlbWVudHMubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhDT01NQSk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1NRVUFSRSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJheVR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmVsZW1lbnRUeXBlKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9TUVVBUkUpO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9TUVVBUkUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJyb3dGdW5jdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5mdW5jdGlvbktpbmQpIHtcbiAgICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUuZnVuY3Rpb25LaW5kKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKEFSUk9XKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRBc3NpZ25tZW50RWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXNzaWdubWVudCk7XG4gICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKEVRVUFMKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0QXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKEFXQUlUKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdHJlZS5sZWZ0O1xuICAgICAgICB0aGlzLnZpc2l0QW55KGxlZnQpO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0cmVlLm9wZXJhdG9yO1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSBQT1NURklYX0VYUFJFU1NJT04gJiYgcmVxdWlyZXNTcGFjZUJldHdlZW4obGVmdC5vcGVyYXRvci50eXBlLCBvcGVyYXRvci50eXBlKSkge1xuICAgICAgICAgIHRoaXMud3JpdGVSZXF1aXJlZFNwYWNlXygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKG9wZXJhdG9yKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdHJlZS5yaWdodDtcbiAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09IFVOQVJZX0VYUFJFU1NJT04gJiYgcmVxdWlyZXNTcGFjZUJldHdlZW4ob3BlcmF0b3IudHlwZSwgcmlnaHQub3BlcmF0b3IudHlwZSkpIHtcbiAgICAgICAgICB0aGlzLndyaXRlUmVxdWlyZWRTcGFjZV8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEFueShyaWdodCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5kaW5nRWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHlwZUFubm90YXRpb24gPSB0aGlzLmN1cnJlbnRQYXJhbWV0ZXJUeXBlQW5ub3RhdGlvbl87XG4gICAgICAgIHRoaXMuY3VycmVudFBhcmFtZXRlclR5cGVBbm5vdGF0aW9uXyA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgICAgdGhpcy53cml0ZVR5cGVBbm5vdGF0aW9uXyh0eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKEVRVUFMKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0QmluZGluZ0lkZW50aWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLmlkZW50aWZpZXJUb2tlbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRCbG9jazogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlT3BlbkN1cmx5XygpO1xuICAgICAgICB0aGlzLndyaXRlbG5MaXN0Xyh0cmVlLnN0YXRlbWVudHMsIG51bGwpO1xuICAgICAgICB0aGlzLndyaXRlQ2xvc2VDdXJseV8oKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKEJSRUFLKTtcbiAgICAgICAgaWYgKHRyZWUubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZV8oU0VNSV9DT0xPTik7XG4gICAgICB9LFxuICAgICAgdmlzaXRDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5hcmdzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENhbGxTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVR5cGVBbm5vdGF0aW9uXyh0cmVlLnJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2FzZUNsYXVzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhDQVNFKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENPTE9OKTtcbiAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8rKztcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS5zdGF0ZW1lbnRzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8tLTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENhdGNoOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKENBVENIKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJpbmRpbmcpO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNhdGNoQm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDbGFzc1NoYXJlZF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xBU1MpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgaWYgKHRyZWUudHlwZVBhcmFtZXRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLnN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oRVhURU5EUyk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zdXBlckNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVPcGVuQ3VybHlfKCk7XG4gICAgICAgIHRoaXMud3JpdGVsbkxpc3RfKHRyZWUuZWxlbWVudHMsIG51bGwpO1xuICAgICAgICB0aGlzLndyaXRlQ2xvc2VDdXJseV8oKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdENsYXNzU2hhcmVkXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENsYXNzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3NTaGFyZWRfKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q29tbWFFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVMaXN0Xyh0cmVlLmV4cHJlc3Npb25zLCBDT01NQSwgZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q29tcHJlaGVuc2lvbkZvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhGT1IpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubGVmdCk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT0YpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pdGVyYXRvcik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q29tcHJlaGVuc2lvbklmOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKElGKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvbXB1dGVkUHJvcGVydHlOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fU1FVQVJFKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9TUVVBUkUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q29uc3RydWN0U2lnbmF0dXJlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE5FVyk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdENhbGxTaWduYXR1cmUodHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb25zdHJ1Y3RvclR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oTkVXKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb25UeXBlKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb25kaXRpb24pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKFFVRVNUSU9OKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubGVmdCk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ09MT04pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5yaWdodCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDb250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhDT05USU5VRSk7XG4gICAgICAgIGlmICh0cmVlLm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKFNFTUlfQ09MT04pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q292ZXJJbml0aWFsaXplZE5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5lcXVhbFRva2VuKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RGVidWdnZXJTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oREVCVUdHRVIpO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdERlZmF1bHRDbGF1c2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oREVGQVVMVCk7XG4gICAgICAgIHRoaXMud3JpdGVfKENPTE9OKTtcbiAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8rKztcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS5zdGF0ZW1lbnRzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8tLTtcbiAgICAgIH0sXG4gICAgICB2aXNpdERvV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oRE8pO1xuICAgICAgICB0aGlzLnZpc2l0QW55QmxvY2tPckluZGVudF8odHJlZS5ib2R5KTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhXSElMRSk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb25kaXRpb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHRoaXMud3JpdGVfKFNFTUlfQ09MT04pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RW1wdHlTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oU0VNSV9DT0xPTik7XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlQW5ub3RhdGlvbnNfKHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICB0aGlzLndyaXRlXyhFWFBPUlQpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5kZWNsYXJhdGlvbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnREZWZhdWx0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKERFRkFVTFQpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgc3dpdGNoICh0cmVlLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgICAgIGNhc2UgQ0xBU1NfREVDTEFSQVRJT046XG4gICAgICAgICAgY2FzZSBGVU5DVElPTl9ERUNMQVJBVElPTjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZVNwYWNlRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFNUQVIpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKEFTKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXROYW1lU3BhY2VJbXBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oU1RBUik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQVMpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHBvcnRDbGF1c2UpO1xuICAgICAgICBpZiAodHJlZS5tb2R1bGVTcGVjaWZpZXIpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oRlJPTSk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKFNFTUlfQ09MT04pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5saHMpO1xuICAgICAgICBpZiAodHJlZS5yaHMpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oQVMpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUucmhzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3BlY2lmaWVyU2V0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVPcGVuQ3VybHlfKCk7XG4gICAgICAgIHRoaXMud3JpdGVMaXN0Xyh0cmVlLnNwZWNpZmllcnMsIENPTU1BLCBmYWxzZSk7XG4gICAgICAgIHRoaXMud3JpdGVDbG9zZUN1cmx5XygpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RXhwb3J0U3RhcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhTVEFSKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZpbmFsbHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oRklOQUxMWSk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJsb2NrKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKEZPUik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT0YpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb2xsZWN0aW9uKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55QmxvY2tPckluZGVudF8odHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvck9uU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKEZPUik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT04pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vYnNlcnZhYmxlKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55QmxvY2tPckluZGVudF8odHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvckluU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKEZPUik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZV8oSU4pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jb2xsZWN0aW9uKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55QmxvY2tPckluZGVudF8odHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhGT1IpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy53cml0ZV8oU0VNSV9DT0xPTik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluY3JlbWVudCk7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueUJsb2NrT3JJbmRlbnRfKHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JtYWxQYXJhbWV0ZXJMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHRyZWUucGFyYW1ldGVyc1tpXTtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVfKENPTU1BKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52aXNpdEFueShwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3JtYWxQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhcmFtZXRlclR5cGVBbm5vdGF0aW9uXyA9IHRyZWUudHlwZUFubm90YXRpb247XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5wYXJhbWV0ZXIpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbWV0ZXJUeXBlQW5ub3RhdGlvbl8gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9yd2FyZERlZmF1bHRFeHBvcnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25Cb2R5OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVPcGVuQ3VybHlfKCk7XG4gICAgICAgIHRoaXMud3JpdGVsbkxpc3RfKHRyZWUuc3RhdGVtZW50cywgbnVsbCk7XG4gICAgICAgIHRoaXMud3JpdGVDbG9zZUN1cmx5XygpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb25fKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbl8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvbl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgaWYgKHRyZWUuaXNBc3luY0dlbmVyYXRvcigpKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV8oQVNZTkMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLmlzQXN5bmNGdW5jdGlvbigpKVxuICAgICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5mdW5jdGlvbktpbmQpO1xuICAgICAgICB0aGlzLndyaXRlXyhGVU5DVElPTik7XG4gICAgICAgIGlmICh0cmVlLmlzQXN5bmNHZW5lcmF0b3IoKSkge1xuICAgICAgICAgIHRoaXMud3JpdGVfKFNUQVIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLmlzR2VuZXJhdG9yKCkpXG4gICAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLmZ1bmN0aW9uS2luZCk7XG4gICAgICAgIGlmICh0cmVlLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVR5cGVBbm5vdGF0aW9uXyh0cmVlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGdW5jdGlvblR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZVBhcmFtZXRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhBUlJPVyk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnJldHVyblR5cGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0R2VuZXJhdG9yQ29tcHJlaGVuc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5jb21wcmVoZW5zaW9uTGlzdCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0R2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhTVEFUSUMpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlXyhHRVQpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlVHlwZUFubm90YXRpb25fKHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUuaWRlbnRpZmllclRva2VuKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdElmU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKElGKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueUJsb2NrT3JJbmRlbnRfKHRyZWUuaWZDbGF1c2UpO1xuICAgICAgICBpZiAodHJlZS5lbHNlQ2xhdXNlKSB7XG4gICAgICAgICAgaWYgKHRyZWUuaWZDbGF1c2UudHlwZSA9PT0gQkxPQ0spXG4gICAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oRUxTRSk7XG4gICAgICAgICAgaWYgKHRyZWUuZWxzZUNsYXVzZS50eXBlID09PSBJRl9TVEFURU1FTlQpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5lbHNlQ2xhdXNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpdEFueUJsb2NrT3JJbmRlbnRfKHRyZWUuZWxzZUNsYXVzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRJbmRleFNpZ25hdHVyZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1NRVUFSRSk7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ09MT04pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5pbmRleFR5cGUpO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9TUVVBUkUpO1xuICAgICAgICB0aGlzLndyaXRlVHlwZUFubm90YXRpb25fKHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEludGVyZmFjZURlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKElOVEVSRkFDRSk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLm5hbWUpO1xuICAgICAgICBpZiAodHJlZS50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuZXh0ZW5kc0NsYXVzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKEVYVEVORFMpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLndyaXRlTGlzdF8odHJlZS5leHRlbmRzQ2xhdXNlLCBDT01NQSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9iamVjdFR5cGUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QW55QmxvY2tPckluZGVudF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZSA9PT0gQkxPQ0spIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55SW5kZW50ZWRfKHRyZWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBbnlJbmRlbnRlZF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICBpZiAodGhpcy5wcmV0dHlQcmludF8pIHtcbiAgICAgICAgICB0aGlzLmluZGVudERlcHRoXyArPSBpbmRlbnQ7XG4gICAgICAgICAgdGhpcy53cml0ZWxuXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIGlmICh0aGlzLnByZXR0eVByaW50Xykge1xuICAgICAgICAgIHRoaXMuaW5kZW50RGVwdGhfIC09IGluZGVudDtcbiAgICAgICAgICB0aGlzLndyaXRlbG5fKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydENsYXVzZVBhaXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmZpcnN0KTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ09NTUEpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5zZWNvbmQpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oSU1QT1JUKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICBpZiAodHJlZS5pbXBvcnRDbGF1c2UpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW1wb3J0Q2xhdXNlKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oRlJPTSk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5uYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLm5hbWUpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLndyaXRlXyhBUyk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5iaW5kaW5nKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydFNwZWNpZmllclNldDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5zcGVjaWZpZXJzLnR5cGUgPT09IFNUQVIpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhTVEFSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlT3BlbkN1cmx5XygpO1xuICAgICAgICAgIHRoaXMud3JpdGVsbkxpc3RfKHRyZWUuc3BlY2lmaWVycywgQ09NTUEpO1xuICAgICAgICAgIHRoaXMud3JpdGVDbG9zZUN1cmx5XygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRJbXBvcnRUeXBlQ2xhdXNlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFRZUEUpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5jbGF1c2UpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4QXR0cmlidXRlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5uYW1lKTtcbiAgICAgICAgaWYgKHRyZWUudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhFUVVBTCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4RWxlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX0FOR0xFKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXR0cmlidXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV8oU0xBU0gpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKENMT1NFX0FOR0xFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9BTkdMRSk7XG4gICAgICAgICAgdGhpcy52aXNpdExpc3QodHJlZS5jaGlsZHJlbik7XG4gICAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9BTkdMRSk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oU0xBU0gpO1xuICAgICAgICAgIHRoaXMubGFzdENvZGVfID0gLTE7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKENMT1NFX0FOR0xFKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0SnN4RWxlbWVudE5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLm5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlXyhQRVJJT0QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRKc3hQbGFjZWhvbGRlcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX0NVUkxZKTtcbiAgICAgICAgaWYgKHRyZWUuZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9DVVJMWSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRKc3hTcHJlYWRBdHRyaWJ1dGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9DVVJMWSk7XG4gICAgICAgIHRoaXMud3JpdGVfKERPVF9ET1RfRE9UKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9DVVJMWSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRKc3hUZXh0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRMYWJlbGxlZFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMud3JpdGVfKENPTE9OKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuc3RhdGVtZW50KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdExpdGVyYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5saXRlcmFsVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TGl0ZXJhbFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubGl0ZXJhbFRva2VuKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICBpZiAodHJlZS5vcGVyYW5kLnR5cGUgPT09IExJVEVSQUxfRVhQUkVTU0lPTiAmJiB0cmVlLm9wZXJhbmQubGl0ZXJhbFRva2VuLnR5cGUgPT09IE5VTUJFUikge1xuICAgICAgICAgIGlmICghL1xcLnxlfEUvLnRlc3QodHJlZS5vcGVyYW5kLmxpdGVyYWxUb2tlbi52YWx1ZSkpXG4gICAgICAgICAgICB0aGlzLndyaXRlUmVxdWlyZWRTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlXyhQRVJJT0QpO1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubWVtYmVyTmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZW1iZXJMb29rdXBFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9TUVVBUkUpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1NRVUFSRSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZXRob2RTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICBpZiAodHJlZS5vcHRpb25hbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVfKFFVRVNUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuY2FsbFNpZ25hdHVyZSk7XG4gICAgICAgIHRoaXMud3JpdGVfKFNFTUlfQ09MT04pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U3ludGF4RXJyb3JUcmVlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKCcoZnVuY3Rpb24oKSB7JyArIChcInRocm93IFN5bnRheEVycm9yKFwiICsgSlNPTi5zdHJpbmdpZnkodHJlZS5tZXNzYWdlKSArIFwiKTtcIikgKyAnfSkoKScpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TW9kdWxlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVsbkxpc3RfKHRyZWUuc2NyaXB0SXRlbUxpc3QsIG51bGwpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS50b2tlbik7XG4gICAgICB9LFxuICAgICAgdmlzaXROZXdFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE5FVyk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRPYmplY3RMaXRlcmFsOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVPcGVuQ3VybHlfKCk7XG4gICAgICAgIGlmICh0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcy5sZW5ndGggPiAxKVxuICAgICAgICAgIHRoaXMud3JpdGVsbl8oKTtcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS5wcm9wZXJ0eU5hbWVBbmRWYWx1ZXMsIENPTU1BKTtcbiAgICAgICAgaWYgKHRyZWUucHJvcGVydHlOYW1lQW5kVmFsdWVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgdGhpcy53cml0ZWxuXygpO1xuICAgICAgICB0aGlzLndyaXRlQ2xvc2VDdXJseV8oKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZU9wZW5DdXJseV8oKTtcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS5maWVsZHMsIENPTU1BKTtcbiAgICAgICAgdGhpcy53cml0ZUNsb3NlQ3VybHlfKCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRPYmplY3RQYXR0ZXJuRmllbGQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICBpZiAodHJlZS5lbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV8oQ09MT04pO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdFR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZU9wZW5DdXJseV8oKTtcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS50eXBlTWVtYmVycywgbnVsbCk7XG4gICAgICAgIHRoaXMud3JpdGVDbG9zZUN1cmx5XygpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UGFyZW5FeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGFyc2VUcmVlV3JpdGVyLnByb3RvdHlwZSwgXCJ2aXNpdFBhcmVuRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICB9LFxuICAgICAgdmlzaXRQb3N0Zml4RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gUE9TVEZJWF9FWFBSRVNTSU9OICYmIHRyZWUub3BlcmFuZC5vcGVyYXRvci50eXBlID09PSB0cmVlLm9wZXJhdG9yLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlUmVxdWlyZWRTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUub3BlcmF0b3IpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UHJlZGVmaW5lZFR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLnR5cGVUb2tlbik7XG4gICAgICB9LFxuICAgICAgdmlzaXRTY3JpcHQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZWxuTGlzdF8odHJlZS5zY3JpcHRJdGVtTGlzdCwgbnVsbCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhTVEFUSUMpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZS5pc0FzeW5jRnVuY3Rpb24oKSB8fCB0cmVlLmlzQXN5bmNHZW5lcmF0b3IoKSlcbiAgICAgICAgICB0aGlzLndyaXRlXyhBU1lOQyk7XG4gICAgICAgIGlmICh0cmVlLmlzR2VuZXJhdG9yKCkgfHwgdHJlZS5pc0FzeW5jR2VuZXJhdG9yKCkpXG4gICAgICAgICAgdGhpcy53cml0ZV8oU1RBUik7XG4gICAgICAgIGlmICh0cmVlLmlzQXN5bmNHZW5lcmF0b3IoKSlcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9QQVJFTik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfUEFSRU4pO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVUeXBlQW5ub3RhdGlvbl8odHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFByb3BlcnR5TmFtZUFzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLndyaXRlXyhDT0xPTik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFByb3BlcnR5TmFtZVNob3J0aGFuZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQcm9wZXJ0eVZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUFubm90YXRpb25zXyh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLndyaXRlXyhTVEFUSUMpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMud3JpdGVUeXBlQW5ub3RhdGlvbl8odHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIGlmICh0cmVlLmluaXRhbGl6ZXIpIHtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oRVFVQUwpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKFNFTUlfQ09MT04pO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UHJvcGVydHlTaWduYXR1cmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICBpZiAodHJlZS5vcHRpb25hbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVfKFFVRVNUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlVHlwZUFubm90YXRpb25fKHRyZWUudHlwZUFubm90YXRpb24pO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZCkge1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZVJhd18oQkFDS19RVU9URSk7XG4gICAgICAgIHRoaXMudmlzaXRMaXN0KHRyZWUuZWxlbWVudHMpO1xuICAgICAgICB0aGlzLndyaXRlUmF3XyhCQUNLX1FVT1RFKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFRlbXBsYXRlTGl0ZXJhbFBvcnRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVRva2VuXyh0cmVlLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFRlbXBsYXRlU3Vic3RpdHV0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVSYXdfKCckJyk7XG4gICAgICAgIHRoaXMud3JpdGVSYXdfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud3JpdGVSYXdfKENMT1NFX0NVUkxZKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhSRVRVUk4pO1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXyh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFJlc3RQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oRE9UX0RPVF9ET1QpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuaWRlbnRpZmllcik7XG4gICAgICB9LFxuICAgICAgdmlzaXRTZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlQW5ub3RhdGlvbnNfKHRyZWUuYW5ub3RhdGlvbnMpO1xuICAgICAgICBpZiAodHJlZS5pc1N0YXRpYykge1xuICAgICAgICAgIHRoaXMud3JpdGVfKFNUQVRJQyk7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKFNFVCk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnBhcmFtZXRlckxpc3QpO1xuICAgICAgICB0aGlzLndyaXRlXyhDTE9TRV9QQVJFTik7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmJvZHkpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U3ByZWFkRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhET1RfRE9UX0RPVCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFNwcmVhZFBhdHRlcm5FbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKERPVF9ET1RfRE9UKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTdGF0ZU1hY2hpbmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBtYWNoaW5lcyBjYW5ub3QgYmUgY29udmVydGVkIHRvIHNvdXJjZScpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0U3VwZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFNVUEVSKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhTV0lUQ0gpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlT3BlbkN1cmx5XygpO1xuICAgICAgICB0aGlzLndyaXRlbG5MaXN0Xyh0cmVlLmNhc2VDbGF1c2VzLCBudWxsKTtcbiAgICAgICAgdGhpcy53cml0ZUNsb3NlQ3VybHlfKCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhUSElTKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFRocm93U3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFRIUk9XKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUudmFsdWUpO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFRyeVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhUUlkpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKHRyZWUuY2F0Y2hCbG9jaykge1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuY2F0Y2hCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuZmluYWxseUJsb2NrKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5maW5hbGx5QmxvY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLndyaXRlXyhUWVBFKTtcbiAgICAgICAgdGhpcy53cml0ZVJlcXVpcmVkU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhFUVVBTCk7XG4gICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnZhbHVlKTtcbiAgICAgICAgdGhpcy53cml0ZV8oU0VNSV9DT0xPTik7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlQXJndW1lbnRzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fQU5HTEUpO1xuICAgICAgICB2YXIgYXJncyA9IHRyZWUuYXJncztcbiAgICAgICAgdGhpcy52aXNpdEFueShhcmdzWzBdKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53cml0ZV8oQ09NTUEpO1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX0FOR0xFKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFR5cGVOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm1vZHVsZU5hbWUpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubW9kdWxlTmFtZSk7XG4gICAgICAgICAgdGhpcy53cml0ZV8oUEVSSU9EKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKHRyZWUubmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVUb2tlbl8odHJlZS5pZGVudGlmaWVyVG9rZW4pO1xuICAgICAgICBpZiAodHJlZS5leHRlbmRzVHlwZSkge1xuICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICB0aGlzLndyaXRlXyhFWFRFTkRTKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4dGVuZHNUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0VHlwZVBhcmFtZXRlcnM6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oT1BFTl9BTkdMRSk7XG4gICAgICAgIHRoaXMud3JpdGVMaXN0Xyh0cmVlLnBhcmFtZXRlcnMsIENPTU1BLCBmYWxzZSk7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX0FOR0xFKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgb3AgPSB0cmVlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLndyaXRlVG9rZW5fKG9wKTtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0cmVlLm9wZXJhbmQ7XG4gICAgICAgIGlmIChvcGVyYW5kLnR5cGUgPT09IFVOQVJZX0VYUFJFU1NJT04gJiYgcmVxdWlyZXNTcGFjZUJldHdlZW4ob3AudHlwZSwgb3BlcmFuZC5vcGVyYXRvci50eXBlKSkge1xuICAgICAgICAgIHRoaXMud3JpdGVSZXF1aXJlZFNwYWNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRBbnkob3BlcmFuZCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRVbmlvblR5cGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLnR5cGVzWzBdKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0cmVlLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKEJBUik7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS50eXBlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb25MaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKHRyZWUuZGVjbGFyYXRpb25UeXBlKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlTGlzdF8odHJlZS5kZWNsYXJhdGlvbnMsIENPTU1BLCB0cnVlLCAyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmx2YWx1ZSk7XG4gICAgICAgIHRoaXMud3JpdGVUeXBlQW5ub3RhdGlvbl8odHJlZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIGlmICh0cmVlLmluaXRpYWxpemVyICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMud3JpdGVfKEVRVUFMKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0VmFyaWFibGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcnNlVHJlZVdyaXRlci5wcm90b3R5cGUsIFwidmlzaXRWYXJpYWJsZVN0YXRlbWVudFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLndyaXRlXyhTRU1JX0NPTE9OKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFdoaWxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFdISUxFKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLndyaXRlXyhPUEVOX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy52aXNpdEFueUJsb2NrT3JJbmRlbnRfKHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRXaXRoU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKFdJVEgpO1xuICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fUEFSRU4pO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuZXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMud3JpdGVfKENMT1NFX1BBUkVOKTtcbiAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYm9keSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRZaWVsZEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy53cml0ZV8oWUlFTEQpO1xuICAgICAgICBpZiAodHJlZS5pc1lpZWxkRm9yKVxuICAgICAgICAgIHRoaXMud3JpdGVfKFNUQVIpO1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVNwYWNlXygpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlQ3VycmVudGxuXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzdWx0XyArPSB0aGlzLmN1cnJlbnRMaW5lXyArIE5FV19MSU5FO1xuICAgICAgfSxcbiAgICAgIHdyaXRlbG5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudExpbmVfKVxuICAgICAgICAgIHRoaXMud3JpdGVDdXJyZW50bG5fKCk7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmVfID0gJyc7XG4gICAgICAgIHRoaXMubGFzdENvZGVfID0gLTE7XG4gICAgICB9LFxuICAgICAgd3JpdGVsbkxpc3RfOiBmdW5jdGlvbihsaXN0LCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVMaXN0XyhsaXN0LCBkZWxpbWl0ZXIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aGlzLndyaXRlbG5fKCk7XG4gICAgICAgICAgdGhpcy53cml0ZUxpc3RfKGxpc3QsICcnLCB0cnVlKTtcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhpcy53cml0ZWxuXygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGVMaXN0XzogZnVuY3Rpb24obGlzdCwgZGVsaW1pdGVyLCB3cml0ZU5ld0xpbmUpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IGFyZ3VtZW50c1szXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkZWxpbWl0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgIHRoaXMud3JpdGVfKGRlbGltaXRlcik7XG4gICAgICAgICAgICAgIGlmICghd3JpdGVOZXdMaW5lKVxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVTcGFjZV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3cml0ZU5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8gKz0gaW5kZW50O1xuICAgICAgICAgICAgICB0aGlzLndyaXRlbG5fKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmlzaXRBbnkobGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyaXRlTmV3TGluZSAmJiBsaXN0Lmxlbmd0aCA+IDEpXG4gICAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8gLT0gaW5kZW50O1xuICAgICAgfSxcbiAgICAgIHdyaXRlUmF3XzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZV8gKz0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdENvZGVfID0gdmFsdWUuY2hhckNvZGVBdCh2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZVRva2VuXzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdGhpcy53cml0ZV8odG9rZW4udG9TdHJpbmcoKSk7XG4gICAgICB9LFxuICAgICAgd3JpdGVfOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5wcmV0dHlQcmludF8gJiYgdGhpcy5jdXJyZW50TGluZV8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsXG4gICAgICAgICAgICAgIGluZGVudCA9IHRoaXMuaW5kZW50RGVwdGhfOyBpIDwgaW5kZW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVSYXdfKCcgICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZWVkc1NwYWNlXyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLndyaXRlUmF3XygnICcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVSYXdfKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB3cml0ZUNsb3NlQ3VybHlfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbmRlbnREZXB0aF8tLTtcbiAgICAgICAgdGhpcy53cml0ZV8oQ0xPU0VfQ1VSTFkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRlT3BlbkN1cmx5XzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMud3JpdGVfKE9QRU5fQ1VSTFkpO1xuICAgICAgICB0aGlzLmluZGVudERlcHRoXysrO1xuICAgICAgfSxcbiAgICAgIHdyaXRlU3BhY2VfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldHR5UHJpbnRfICYmICFpc1doaXRlc3BhY2UodGhpcy5sYXN0Q29kZV8pKSB7XG4gICAgICAgICAgdGhpcy53cml0ZVJhd18oJyAnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlUmVxdWlyZWRTcGFjZV86IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZSh0aGlzLmxhc3RDb2RlXykpIHtcbiAgICAgICAgICB0aGlzLndyaXRlUmF3XygnICcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGVUeXBlQW5ub3RhdGlvbl86IGZ1bmN0aW9uKHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlQW5ub3RhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMud3JpdGVfKENPTE9OKTtcbiAgICAgICAgICB0aGlzLndyaXRlU3BhY2VfKCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0eXBlQW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3cml0ZUFubm90YXRpb25zXzogZnVuY3Rpb24oYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdmFyIHdyaXRlTmV3TGluZSA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnByZXR0eVByaW50XztcbiAgICAgICAgaWYgKGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLndyaXRlTGlzdF8oYW5ub3RhdGlvbnMsICcnLCB3cml0ZU5ld0xpbmUpO1xuICAgICAgICAgIGlmICh3cml0ZU5ld0xpbmUpXG4gICAgICAgICAgICB0aGlzLndyaXRlbG5fKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBuZWVkc1NwYWNlXzogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxhc3RDb2RlID0gdGhpcy5sYXN0Q29kZV87XG4gICAgICAgIGlmIChpc1doaXRlc3BhY2UobGFzdENvZGUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGZpcnN0Q29kZSA9IHRva2VuLnRvU3RyaW5nKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllclBhcnQoZmlyc3RDb2RlKSAmJiAoaXNJZGVudGlmaWVyUGFydChsYXN0Q29kZSkgfHwgbGFzdENvZGUgPT09IDQ3KTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVZpc2l0b3IpO1xuICBmdW5jdGlvbiByZXF1aXJlc1NwYWNlQmV0d2VlbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgcmV0dXJuIChmaXJzdCA9PT0gTUlOVVMgfHwgZmlyc3QgPT09IE1JTlVTX01JTlVTKSAmJiAoc2Vjb25kID09PSBNSU5VUyB8fCBzZWNvbmQgPT09IE1JTlVTX01JTlVTKSB8fCAoZmlyc3QgPT09IFBMVVMgfHwgZmlyc3QgPT09IFBMVVNfUExVUykgJiYgKHNlY29uZCA9PT0gUExVUyB8fCBzZWNvbmQgPT09IFBMVVNfUExVUyk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgUGFyc2VUcmVlV3JpdGVyKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZVdyaXRlcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1BhcnNlVHJlZU1hcFdyaXRlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlTWFwV3JpdGVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVXcml0ZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVXcml0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlTWFwV3JpdGVyLmpzXCIpKS5QYXJzZVRyZWVXcml0ZXI7XG4gIHZhciBTdHJpbmdTZXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9TdHJpbmdTZXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlTWFwV3JpdGVyLmpzXCIpKS5TdHJpbmdTZXQ7XG4gIHZhciBQYXJzZVRyZWVNYXBXcml0ZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFBhcnNlVHJlZU1hcFdyaXRlcihzb3VyY2VNYXBDb25maWd1cmF0aW9uKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFBhcnNlVHJlZU1hcFdyaXRlcikuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc291cmNlTWFwR2VuZXJhdG9yXyA9IHNvdXJjZU1hcENvbmZpZ3VyYXRpb24uc291cmNlTWFwR2VuZXJhdG9yO1xuICAgICAgdGhpcy5sb3dSZXNvbHV0aW9uXyA9IHNvdXJjZU1hcENvbmZpZ3VyYXRpb24ubG93UmVzb2x1dGlvbjtcbiAgICAgIHRoaXMuYmFzZXBhdGhfID0gc291cmNlTWFwQ29uZmlndXJhdGlvbi5iYXNlcGF0aDtcbiAgICAgIHRoaXMub3V0cHV0TGluZUNvdW50XyA9IDE7XG4gICAgICB0aGlzLmlzRmlyc3RNYXBwaW5nXyA9IHRydWU7XG4gICAgICB0aGlzLnNvdXJjZXNJbk1hcF8gPSBuZXcgU3RyaW5nU2V0KCk7XG4gICAgICB0aGlzLnJlbGF0aXZlU291cmNlTmFtZV8gPSAnJztcbiAgICAgIHRoaXMuZ2VuZXJhdGVkXyA9IG51bGw7XG4gICAgICB0aGlzLm9yaWdpbmFsXyA9IG51bGw7XG4gICAgICB0aGlzLnByZXZpb3VzTWFwcGluZ18gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUGFyc2VUcmVlTWFwV3JpdGVyLCB7XG4gICAgICB2aXNpdEFueTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZS5sb2NhdGlvbiAhPT0gbnVsbClcbiAgICAgICAgICB0aGlzLmVudGVyQnJhbmNoKHRyZWUubG9jYXRpb24pO1xuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUGFyc2VUcmVlTWFwV3JpdGVyLnByb3RvdHlwZSwgXCJ2aXNpdEFueVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICBpZiAodHJlZS5sb2NhdGlvbiAhPT0gbnVsbClcbiAgICAgICAgICB0aGlzLmV4aXRCcmFuY2godHJlZS5sb2NhdGlvbik7XG4gICAgICB9LFxuICAgICAgd3JpdGVDdXJyZW50bG5fOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFBhcnNlVHJlZU1hcFdyaXRlci5wcm90b3R5cGUsIFwid3JpdGVDdXJyZW50bG5fXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZmx1c2hNYXBwaW5ncygpO1xuICAgICAgICB0aGlzLm91dHB1dExpbmVDb3VudF8rKztcbiAgICAgICAgdGhpcy5nZW5lcmF0ZWRfID0ge1xuICAgICAgICAgIGxpbmU6IHRoaXMub3V0cHV0TGluZUNvdW50XyxcbiAgICAgICAgICBjb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mbHVzaE1hcHBpbmdzKCk7XG4gICAgICB9LFxuICAgICAgd3JpdGVfOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlKCk7XG4gICAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQYXJzZVRyZWVNYXBXcml0ZXIucHJvdG90eXBlLCBcIndyaXRlX1wiKS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZSgpO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuY3VycmVudExpbmVfLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGxlbmd0aCA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB0aGlzLmdlbmVyYXRlZF8gPSB7XG4gICAgICAgICAgbGluZTogdGhpcy5vdXRwdXRMaW5lQ291bnRfLFxuICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmx1c2hNYXBwaW5ncygpO1xuICAgICAgfSxcbiAgICAgIGVudGVyQnJhbmNoOiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgICAgICB2YXIgJF9fMiA9IGxvY2F0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgbGluZSA9ICRfXzIubGluZSxcbiAgICAgICAgICAgIGNvbHVtbiA9ICRfXzIuY29sdW1uLFxuICAgICAgICAgICAgc291cmNlID0gJF9fMi5zb3VyY2U7XG4gICAgICAgIHRoaXMub3JpZ2luYXRlKGxpbmUsIGNvbHVtbiwgc291cmNlKTtcbiAgICAgIH0sXG4gICAgICBleGl0QnJhbmNoOiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgICAgICB2YXIgJF9fMiA9IGxvY2F0aW9uLmVuZCxcbiAgICAgICAgICAgIGxpbmUgPSAkX18yLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW4gPSAkX18yLmNvbHVtbixcbiAgICAgICAgICAgIHNvdXJjZSA9ICRfXzIuc291cmNlO1xuICAgICAgICB0aGlzLm9yaWdpbmF0ZShsaW5lLCBjb2x1bW4gPyBjb2x1bW4gLSAxIDogMCwgc291cmNlKTtcbiAgICAgIH0sXG4gICAgICBvcmlnaW5hdGU6IGZ1bmN0aW9uKGxpbmUsIGNvbHVtbiwgc291cmNlKSB7XG4gICAgICAgIGxpbmUrKztcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxfICYmIHRoaXMub3JpZ2luYWxfLmxpbmUgIT09IGxpbmUpXG4gICAgICAgICAgdGhpcy5mbHVzaE1hcHBpbmdzKCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxfID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmUsXG4gICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIXRoaXMuc291cmNlc0luTWFwXy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZXNJbk1hcF8uYWRkKG5hbWUpO1xuICAgICAgICAgIHRoaXMucmVsYXRpdmVTb3VyY2VOYW1lXyA9IHJlbGF0aXZlUGF0aChuYW1lLCB0aGlzLmJhc2VwYXRoXyk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VNYXBHZW5lcmF0b3JfLnNldFNvdXJjZUNvbnRlbnQodGhpcy5yZWxhdGl2ZVNvdXJjZU5hbWVfLCBzb3VyY2UuY29udGVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmx1c2hNYXBwaW5ncygpO1xuICAgICAgfSxcbiAgICAgIGZsdXNoTWFwcGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbF8gJiYgdGhpcy5nZW5lcmF0ZWRfKSB7XG4gICAgICAgICAgdGhpcy5hZGRNYXBwaW5nKCk7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbF8gPSBudWxsO1xuICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc1NhbWU6IGZ1bmN0aW9uKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMubGluZSA9PT0gcmhzLmxpbmUgJiYgbGhzLmNvbHVtbiA9PT0gcmhzLmNvbHVtbjtcbiAgICAgIH0sXG4gICAgICBza2lwTWFwcGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHBpbmdfKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMubG93UmVzb2x1dGlvbl8gJiYgdGhpcy5wcmV2aW91c01hcHBpbmdfLmdlbmVyYXRlZC5saW5lID09PSB0aGlzLmdlbmVyYXRlZF8ubGluZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNTYW1lKHRoaXMucHJldmlvdXNNYXBwaW5nXy5nZW5lcmF0ZWQsIHRoaXMuZ2VuZXJhdGVkXykgJiYgdGhpcy5pc1NhbWUodGhpcy5wcmV2aW91c01hcHBpbmdfLm9yaWdpbmFsLCB0aGlzLm9yaWdpbmFsXykpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgYWRkTWFwcGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNraXBNYXBwaW5nKCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHRoaXMuZ2VuZXJhdGVkXyxcbiAgICAgICAgICBvcmlnaW5hbDogdGhpcy5vcmlnaW5hbF8sXG4gICAgICAgICAgc291cmNlOiB0aGlzLnJlbGF0aXZlU291cmNlTmFtZV9cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBHZW5lcmF0b3JfLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgIHRoaXMucHJldmlvdXNNYXBwaW5nXyA9IG1hcHBpbmc7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVXcml0ZXIpO1xuICBmdW5jdGlvbiByZWxhdGl2ZVBhdGgobmFtZSwgc291cmNlUm9vdCkge1xuICAgIHZhciAkX18zO1xuICAgIGlmICghbmFtZSB8fCBuYW1lWzBdID09PSAnQCcpXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICBpZiAoIXNvdXJjZVJvb3QpXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB2YXIgbmFtZVNlZ21lbnRzID0gbmFtZS5zcGxpdCgnLycpO1xuICAgIHZhciByb290U2VnbWVudHMgPSBzb3VyY2VSb290LnNwbGl0KCcvJyk7XG4gICAgaWYgKHJvb3RTZWdtZW50c1tyb290U2VnbWVudHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdFBhdGggbXVzdCBlbmQgaW4gLycpO1xuICAgIH1cbiAgICB2YXIgY29tbW9uU2VnbWVudHNMZW5ndGggPSAwO1xuICAgIHZhciB1bmlxdWVTZWdtZW50cyA9IFtdO1xuICAgIHZhciBmb3VuZFVuaXF1ZSA9IGZhbHNlO1xuICAgIG5hbWVTZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgICBpZiAoIWZvdW5kVW5pcXVlICYmIHNlZ21lbnQgPT09IHJvb3RTZWdtZW50c1tpbmRleF0pIHtcbiAgICAgICAgY29tbW9uU2VnbWVudHNMZW5ndGgrKztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm91bmRVbmlxdWUgPSB0cnVlO1xuICAgICAgdW5pcXVlU2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9KTtcbiAgICBpZiAoY29tbW9uU2VnbWVudHNMZW5ndGggPCAxIHx8IGNvbW1vblNlZ21lbnRzTGVuZ3RoID09PSByb290U2VnbWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgdmFyIGRvdERvdFNlZ21lbnRzID0gcm9vdFNlZ21lbnRzLmxlbmd0aCAtIGNvbW1vblNlZ21lbnRzTGVuZ3RoIC0gMTtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICB3aGlsZSAoZG90RG90U2VnbWVudHMtLSkge1xuICAgICAgc2VnbWVudHMucHVzaCgnLi4nKTtcbiAgICB9XG4gICAgKCRfXzMgPSBzZWdtZW50cykucHVzaC5hcHBseSgkX18zLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHVuaXF1ZVNlZ21lbnRzKSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmpvaW4oJy8nKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldCBQYXJzZVRyZWVNYXBXcml0ZXIoKSB7XG4gICAgICByZXR1cm4gUGFyc2VUcmVlTWFwV3JpdGVyO1xuICAgIH0sXG4gICAgZ2V0IHJlbGF0aXZlUGF0aCgpIHtcbiAgICAgIHJldHVybiByZWxhdGl2ZVBhdGg7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vU291cmNlTWFwSW50ZWdyYXRpb24uanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1NvdXJjZU1hcEludGVncmF0aW9uLmpzXCI7XG4gIGZ1bmN0aW9uIG1ha2VEZWZpbmUobWFwcGluZywgaWQpIHtcbiAgICB2YXIgcmVxdWlyZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gbWFwcGluZ1tpZF07XG4gICAgfTtcbiAgICB2YXIgZXhwb3J0cyA9IG1hcHBpbmdbaWRdID0ge307XG4gICAgdmFyIG1vZHVsZSA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgIGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKTtcbiAgICB9O1xuICB9XG4gIHZhciBkZWZpbmUsXG4gICAgICBtID0ge307XG4gIGRlZmluZSA9IG1ha2VEZWZpbmUobSwgJy4vdXRpbCcpO1xuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG4gIH1cbiAgZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICAgIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcbiAgICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgICB2YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG4gICAgZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICAgICAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgICAgIHBhdGg6IG1hdGNoWzVdXG4gICAgICB9O1xuICAgIH1cbiAgICBleHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG4gICAgZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICAgICAgdmFyIHVybCA9ICcnO1xuICAgICAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgICAgIH1cbiAgICAgIHVybCArPSAnLy8nO1xuICAgICAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgICAgfVxuICAgICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgICAgfVxuICAgICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gICAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgICAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgICB9XG4gICAgICB2YXIgaXNBYnNvbHV0ZSA9IChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKTtcbiAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgICAgIGZvciAodmFyIHBhcnQgPSB2b2lkIDAsXG4gICAgICAgICAgdXAgPSAwLFxuICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgIHVwKys7XG4gICAgICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG4gICAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gICAgICB9XG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4gICAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgICBhUm9vdCA9IFwiLlwiO1xuICAgICAgfVxuICAgICAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgICAgIGFQYXRoID0gXCIuXCI7XG4gICAgICB9XG4gICAgICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgICAgIH1cbiAgICAgIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICAgICAgfVxuICAgICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cbiAgICAgIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gICAgICB9XG4gICAgICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLycgPyBhUGF0aCA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcbiAgICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICB9XG4gICAgZXhwb3J0cy5qb2luID0gam9pbjtcbiAgICBmdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgICAgIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgICAgICBhUm9vdCA9IFwiLlwiO1xuICAgICAgfVxuICAgICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgdmFyIHVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICAgIGlmIChhUGF0aC5jaGFyQXQoMCkgPT0gXCIvXCIgJiYgdXJsICYmIHVybC5wYXRoID09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBhUGF0aC5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSA9PT0gMCA/IGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKSA6IGFQYXRoO1xuICAgIH1cbiAgICBleHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICAgICAgcmV0dXJuICckJyArIGFTdHI7XG4gICAgfVxuICAgIGV4cG9ydHMudG9TZXRTdHJpbmcgPSB0b1NldFN0cmluZztcbiAgICBmdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgICB9XG4gICAgZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gZnJvbVNldFN0cmluZztcbiAgICBmdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gICAgICB2YXIgczEgPSBhU3RyMSB8fCBcIlwiO1xuICAgICAgdmFyIHMyID0gYVN0cjIgfHwgXCJcIjtcbiAgICAgIHJldHVybiAoczEgPiBzMikgLSAoczEgPCBzMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgICAgdmFyIGNtcDtcbiAgICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgaWYgKGNtcCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gICAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGlmIChjbXApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgfVxuICAgIDtcbiAgICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG4gICAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgIHZhciBjbXA7XG4gICAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGlmIChjbXApIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgIH1cbiAgICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIGlmIChjbXAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgIH1cbiAgICAgIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gICAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gICAgICBpZiAoY21wKSB7XG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgICB9XG4gICAgICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgaWYgKGNtcCkge1xuICAgICAgICByZXR1cm4gY21wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbiAgICB9XG4gICAgO1xuICAgIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zO1xuICB9KTtcbiAgZGVmaW5lID0gbWFrZURlZmluZShtLCAnLi9hcnJheS1zZXQnKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xuICB9XG4gIGRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICAgIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICAgIHRoaXMuX3NldCA9IHt9O1xuICAgIH1cbiAgICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCxcbiAgICAgICAgICBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuICAgIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5oYXMoYVN0cik7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXSA9IGlkeDtcbiAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsIHV0aWwudG9TZXRTdHJpbmcoYVN0cikpO1xuICAgIH07XG4gICAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICAgIGlmICh0aGlzLmhhcyhhU3RyKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICAgIH07XG4gICAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgICB9O1xuICAgIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICAgIH07XG4gICAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuICB9KTtcbiAgZGVmaW5lID0gbWFrZURlZmluZShtLCAnLi9iYXNlNjQnKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xuICB9XG4gIGRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgY2hhclRvSW50TWFwID0ge307XG4gICAgdmFyIGludFRvQ2hhck1hcCA9IHt9O1xuICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihjaCwgaW5kZXgpIHtcbiAgICAgIGNoYXJUb0ludE1hcFtjaF0gPSBpbmRleDtcbiAgICAgIGludFRvQ2hhck1hcFtpbmRleF0gPSBjaDtcbiAgICB9KTtcbiAgICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NF9lbmNvZGUoYU51bWJlcikge1xuICAgICAgaWYgKGFOdW1iZXIgaW4gaW50VG9DaGFyTWFwKSB7XG4gICAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbYU51bWJlcl07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XG4gICAgICBpZiAoYUNoYXIgaW4gY2hhclRvSW50TWFwKSB7XG4gICAgICAgIHJldHVybiBjaGFyVG9JbnRNYXBbYUNoYXJdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBhIHZhbGlkIGJhc2UgNjQgZGlnaXQ6IFwiICsgYUNoYXIpO1xuICAgIH07XG4gIH0pO1xuICBkZWZpbmUgPSBtYWtlRGVmaW5lKG0sICcuL2Jhc2U2NC12bHEnKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xuICB9XG4gIGRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbiAgICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuICAgIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG4gICAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG4gICAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG4gICAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgICByZXR1cm4gYVZhbHVlIDwgMCA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICAgIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gICAgICByZXR1cm4gaXNOZWdhdGl2ZSA/IC1zaGlmdGVkIDogc2hpZnRlZDtcbiAgICB9XG4gICAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICAgICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgICAgdmFyIGRpZ2l0O1xuICAgICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICAgIH0gd2hpbGUgKHZscSA+IDApO1xuICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYU91dFBhcmFtKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIHZhciBzaGlmdCA9IDA7XG4gICAgICB2YXIgY29udGludWF0aW9uLFxuICAgICAgICAgIGRpZ2l0O1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoaSA+PSBzdHJMZW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckF0KGkrKykpO1xuICAgICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuICAgICAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICAgICAgYU91dFBhcmFtLnJlc3QgPSBhU3RyLnNsaWNlKGkpO1xuICAgIH07XG4gIH0pO1xuICBkZWZpbmUgPSBtYWtlRGVmaW5lKG0sICcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xuICB9XG4gIGRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICAgICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSkge1xuICAgICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSk7XG4gICAgfTtcbiAgfSk7XG4gIGRlZmluZSA9IG1ha2VEZWZpbmUobSwgJy4vbWFwcGluZy1saXN0Jyk7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbiAgfVxuICBkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgICAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgICAgIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8IHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gICAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xhc3QgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IC0xLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IDBcbiAgICAgIH07XG4gICAgfVxuICAgIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gICAgfTtcbiAgICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgICB2YXIgbWFwcGluZztcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICAgICAgfVxuICAgIH07XG4gICAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICAgICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXk7XG4gICAgfTtcbiAgICBleHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4gIH0pO1xuICBkZWZpbmUgPSBtYWtlRGVmaW5lKG0sICcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJyk7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbiAgfVxuICBkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gICAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgICAgaWYgKCFhQXJncykge1xuICAgICAgICBhQXJncyA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICAgICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7Z2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgfX07XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID0gZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9IGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgKyAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID0gZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMCAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZCAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWwgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDAgJiYgYVNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPSBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCxcbiAgICAgICAgICBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDEgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtbiAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KSA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcbiAgICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgfSk7XG4gIGRlZmluZSA9IG1ha2VEZWZpbmUobSwgJy4vc291cmNlLW1hcC1jb25zdW1lcicpO1xuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG4gIH1cbiAgZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gICAgdmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xuICAgIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gICAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgICAgfVxuICAgICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAgIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgICAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgICAgIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuICAgICAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZXMgPSBzb3VyY2VzLm1hcCh1dGlsLm5vcm1hbGl6ZSk7XG4gICAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuICAgICAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgIH1cbiAgICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICAgICAgc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSwgc21jLnNvdXJjZVJvb3QpO1xuICAgICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgICAgc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICAgIHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgcmV0dXJuIHNtYztcbiAgICB9O1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7Z2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH19KTtcbiAgICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgfX0pO1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIH19KTtcbiAgICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yID0gZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0cikge1xuICAgICAgdmFyIGMgPSBhU3RyLmNoYXJBdCgwKTtcbiAgICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgICB9O1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHN0ciA9IGFTdHI7XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgdmFyIG1hcHBpbmc7XG4gICAgICB3aGlsZSAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICc7Jykge1xuICAgICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcsJykge1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nID0ge307XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICF0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQocHJldmlvdXNTb3VyY2UgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICF0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gdGhpcy5fbmFtZXMuYXQocHJldmlvdXNOYW1lICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPSBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSwgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJyArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJyArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IpO1xuICAgIH07XG4gICAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG4gICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuICAgICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcbiAgICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLCBcImdlbmVyYXRlZExpbmVcIiwgXCJnZW5lcmF0ZWRDb2x1bW5cIiwgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgdGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBuYW1lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcbiAgICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCIgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsIFwib3JpZ2luYWxMaW5lXCIsIFwib3JpZ2luYWxDb2x1bW5cIiwgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG4gICAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogSW5maW5pdHlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLCB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLCBcIm9yaWdpbmFsTGluZVwiLCBcIm9yaWdpbmFsQ29sdW1uXCIsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG5lZWRsZS5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1stLWluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBpbmdzLnJldmVyc2UoKTtcbiAgICB9O1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gICAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuICAgIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcbiAgICAgIHZhciBtYXBwaW5ncztcbiAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24obWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lXG4gICAgICAgIH07XG4gICAgICB9KS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcbiAgICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG4gIH0pO1xuICBkZWZpbmUgPSBtYWtlRGVmaW5lKG0sICcuL3NvdXJjZS1ub2RlJyk7XG4gIGlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbiAgfVxuICBkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgICB2YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuICAgIHZhciBORVdMSU5FX0NPREUgPSAxMDtcbiAgICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgICAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gICAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgICAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgICAgIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gICAgICBpZiAoYUNodW5rcyAhPSBudWxsKVxuICAgICAgICB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgICB9XG4gICAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgICAgfTtcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsXG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgICB9XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aCA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSkgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSwgbWFwcGluZy5vcmlnaW5hbENvbHVtbiwgc291cmNlLCBjb2RlLCBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoYUNodW5rKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVuayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgICAgIHZhciBjaHVuaztcbiAgICAgIGZvciAodmFyIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgICBhRm4oY2h1bmssIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gICAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID0gZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuICAgIFNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLFxuICAgICAgICAgIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgIHRoaXMud2FsayhmdW5jdGlvbihjaHVuaykge1xuICAgICAgICBzdHIgKz0gY2h1bms7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICAgICAgY29kZTogXCJcIixcbiAgICAgICAgbGluZTogMSxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9O1xuICAgICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgICAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgICAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gICAgICB0aGlzLndhbGsoZnVuY3Rpb24oY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmUgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW4gfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe2dlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9fSk7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24oc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogZ2VuZXJhdGVkLmNvZGUsXG4gICAgICAgIG1hcDogbWFwXG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiAgfSk7XG4gIHZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSBtWycuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJ10uU291cmNlTWFwR2VuZXJhdG9yO1xuICB2YXIgU291cmNlTWFwQ29uc3VtZXIgPSBtWycuL3NvdXJjZS1tYXAtY29uc3VtZXInXS5Tb3VyY2VNYXBDb25zdW1lcjtcbiAgdmFyIFNvdXJjZU5vZGUgPSBtWycuL3NvdXJjZS1ub2RlJ10uU291cmNlTm9kZTtcbiAgdmFyIGpvaW4gPSBtWycuL3V0aWwnXS5qb2luO1xuICByZXR1cm4ge1xuICAgIGdldCBTb3VyY2VNYXBHZW5lcmF0b3IoKSB7XG4gICAgICByZXR1cm4gU291cmNlTWFwR2VuZXJhdG9yO1xuICAgIH0sXG4gICAgZ2V0IFNvdXJjZU1hcENvbnN1bWVyKCkge1xuICAgICAgcmV0dXJuIFNvdXJjZU1hcENvbnN1bWVyO1xuICAgIH0sXG4gICAgZ2V0IFNvdXJjZU5vZGUoKSB7XG4gICAgICByZXR1cm4gU291cmNlTm9kZTtcbiAgICB9LFxuICAgIGdldCBqb2luKCkge1xuICAgICAgcmV0dXJuIGpvaW47XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vdG9Tb3VyY2UuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL3RvU291cmNlLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVNYXBXcml0ZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVNYXBXcml0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vdG9Tb3VyY2UuanNcIikpLlBhcnNlVHJlZU1hcFdyaXRlcjtcbiAgdmFyIFBhcnNlVHJlZVdyaXRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVdyaXRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvb3V0cHV0Z2VuZXJhdGlvbi90b1NvdXJjZS5qc1wiKSkuUGFyc2VUcmVlV3JpdGVyO1xuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU291cmNlTWFwSW50ZWdyYXRpb24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vdG9Tb3VyY2UuanNcIikpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgZnVuY3Rpb24gdG9Tb3VyY2UodHJlZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBvdXRwdXROYW1lID0gYXJndW1lbnRzWzJdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1syXSA6ICc8dG9Tb3VyY2VPdXRwdXQ+JztcbiAgICB2YXIgc291cmNlUm9vdCA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgc291cmNlTWFwR2VuZXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgICB2YXIgc291cmNlbWFwcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zb3VyY2VNYXBzO1xuICAgIGlmICghc291cmNlTWFwR2VuZXJhdG9yICYmIHNvdXJjZW1hcHMpIHtcbiAgICAgIHNvdXJjZU1hcEdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiBvdXRwdXROYW1lLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290LFxuICAgICAgICBza2lwVmFsaWRhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzb3VyY2VNYXBDb25maWd1cmF0aW9uID0ge1xuICAgICAgc291cmNlTWFwR2VuZXJhdG9yOiBzb3VyY2VNYXBHZW5lcmF0b3IsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290LFxuICAgICAgbG93UmVzb2x1dGlvbjogb3B0aW9ucyAmJiBvcHRpb25zLmxvd1Jlc29sdXRpb25Tb3VyY2VNYXBcbiAgICB9O1xuICAgIHZhciB3cml0ZXI7XG4gICAgaWYgKHNvdXJjZU1hcEdlbmVyYXRvcilcbiAgICAgIHdyaXRlciA9IG5ldyBQYXJzZVRyZWVNYXBXcml0ZXIoc291cmNlTWFwQ29uZmlndXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgZWxzZVxuICAgICAgd3JpdGVyID0gbmV3IFBhcnNlVHJlZVdyaXRlcihvcHRpb25zKTtcbiAgICB3cml0ZXIudmlzaXRBbnkodHJlZSk7XG4gICAgcmV0dXJuIFt3cml0ZXIudG9TdHJpbmcoKSwgc291cmNlTWFwR2VuZXJhdG9yICYmIHNvdXJjZU1hcEdlbmVyYXRvci50b1N0cmluZygpXTtcbiAgfVxuICByZXR1cm4ge2dldCB0b1NvdXJjZSgpIHtcbiAgICAgIHJldHVybiB0b1NvdXJjZTtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1RyZWVXcml0ZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9vdXRwdXRnZW5lcmF0aW9uL1RyZWVXcml0ZXIuanNcIjtcbiAgdmFyIHRvU291cmNlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdG9Tb3VyY2UuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vVHJlZVdyaXRlci5qc1wiKSkudG9Tb3VyY2U7XG4gIGZ1bmN0aW9uIHdyaXRlKHRyZWUpIHtcbiAgICB2YXIgJF9fMixcbiAgICAgICAgJF9fMztcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb3V0cHV0TmFtZSA9IGFyZ3VtZW50c1syXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMl0gOiAnPFRyZWVXcml0ZXItb3V0cHV0Pic7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhcmd1bWVudHNbM107XG4gICAgdmFyICRfXzEgPSB0b1NvdXJjZSh0cmVlLCBvcHRpb25zLCBvdXRwdXROYW1lLCBzb3VyY2VSb290KSxcbiAgICAgICAgcmVzdWx0ID0gKCRfXzIgPSAkX18xW1N5bWJvbC5pdGVyYXRvcl0oKSwgKCRfXzMgPSAkX18yLm5leHQoKSkuZG9uZSA/IHZvaWQgMCA6ICRfXzMudmFsdWUpLFxuICAgICAgICBzb3VyY2VNYXAgPSAoJF9fMyA9ICRfXzIubmV4dCgpKS5kb25lID8gdm9pZCAwIDogJF9fMy52YWx1ZTtcbiAgICBpZiAoc291cmNlTWFwKVxuICAgICAgb3B0aW9ucy5nZW5lcmF0ZWRTb3VyY2VNYXAgPSBzb3VyY2VNYXA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgVHJlZVdyaXRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVXcml0ZXIoKSB7fVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUcmVlV3JpdGVyLCB7fSwge30pO1xuICB9KCk7XG4gIFRyZWVXcml0ZXIud3JpdGUgPSB3cml0ZTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgd3JpdGUoKSB7XG4gICAgICByZXR1cm4gd3JpdGU7XG4gICAgfSxcbiAgICBnZXQgVHJlZVdyaXRlcigpIHtcbiAgICAgIHJldHVybiBUcmVlV3JpdGVyO1xuICAgIH1cbiAgfTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VUcmVlVmFsaWRhdG9yLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlVHJlZVZhbGlkYXRvci5qc1wiO1xuICB2YXIgTmV3RXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc3ludGF4L1BhcnNlVHJlZVZhbGlkYXRvci5qc1wiKSkuTmV3RXhwcmVzc2lvbjtcbiAgdmFyIFBhcnNlVHJlZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVWaXNpdG9yLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VUcmVlVmFsaWRhdG9yLmpzXCIpKS5QYXJzZVRyZWVWaXNpdG9yO1xuICB2YXIgVHJlZVdyaXRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9vdXRwdXRnZW5lcmF0aW9uL1RyZWVXcml0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZVRyZWVWYWxpZGF0b3IuanNcIikpLlRyZWVXcml0ZXI7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VUcmVlVmFsaWRhdG9yLmpzXCIpKSxcbiAgICAgIEFNUEVSU0FORCA9ICRfXzcuQU1QRVJTQU5ELFxuICAgICAgQU1QRVJTQU5EX0VRVUFMID0gJF9fNy5BTVBFUlNBTkRfRVFVQUwsXG4gICAgICBBTkQgPSAkX183LkFORCxcbiAgICAgIEJBUiA9ICRfXzcuQkFSLFxuICAgICAgQkFSX0VRVUFMID0gJF9fNy5CQVJfRVFVQUwsXG4gICAgICBDQVJFVCA9ICRfXzcuQ0FSRVQsXG4gICAgICBDQVJFVF9FUVVBTCA9ICRfXzcuQ0FSRVRfRVFVQUwsXG4gICAgICBDTE9TRV9BTkdMRSA9ICRfXzcuQ0xPU0VfQU5HTEUsXG4gICAgICBFUVVBTCA9ICRfXzcuRVFVQUwsXG4gICAgICBFUVVBTF9FUVVBTCA9ICRfXzcuRVFVQUxfRVFVQUwsXG4gICAgICBFUVVBTF9FUVVBTF9FUVVBTCA9ICRfXzcuRVFVQUxfRVFVQUxfRVFVQUwsXG4gICAgICBHUkVBVEVSX0VRVUFMID0gJF9fNy5HUkVBVEVSX0VRVUFMLFxuICAgICAgSURFTlRJRklFUiA9ICRfXzcuSURFTlRJRklFUixcbiAgICAgIElOID0gJF9fNy5JTixcbiAgICAgIElOU1RBTkNFT0YgPSAkX183LklOU1RBTkNFT0YsXG4gICAgICBMRUZUX1NISUZUID0gJF9fNy5MRUZUX1NISUZULFxuICAgICAgTEVGVF9TSElGVF9FUVVBTCA9ICRfXzcuTEVGVF9TSElGVF9FUVVBTCxcbiAgICAgIExFU1NfRVFVQUwgPSAkX183LkxFU1NfRVFVQUwsXG4gICAgICBNSU5VUyA9ICRfXzcuTUlOVVMsXG4gICAgICBNSU5VU19FUVVBTCA9ICRfXzcuTUlOVVNfRVFVQUwsXG4gICAgICBOT1RfRVFVQUwgPSAkX183Lk5PVF9FUVVBTCxcbiAgICAgIE5PVF9FUVVBTF9FUVVBTCA9ICRfXzcuTk9UX0VRVUFMX0VRVUFMLFxuICAgICAgTlVNQkVSID0gJF9fNy5OVU1CRVIsXG4gICAgICBPUEVOX0FOR0xFID0gJF9fNy5PUEVOX0FOR0xFLFxuICAgICAgT1IgPSAkX183Lk9SLFxuICAgICAgUEVSQ0VOVCA9ICRfXzcuUEVSQ0VOVCxcbiAgICAgIFBFUkNFTlRfRVFVQUwgPSAkX183LlBFUkNFTlRfRVFVQUwsXG4gICAgICBQTFVTID0gJF9fNy5QTFVTLFxuICAgICAgUExVU19FUVVBTCA9ICRfXzcuUExVU19FUVVBTCxcbiAgICAgIFJJR0hUX1NISUZUID0gJF9fNy5SSUdIVF9TSElGVCxcbiAgICAgIFJJR0hUX1NISUZUX0VRVUFMID0gJF9fNy5SSUdIVF9TSElGVF9FUVVBTCxcbiAgICAgIFNMQVNIID0gJF9fNy5TTEFTSCxcbiAgICAgIFNMQVNIX0VRVUFMID0gJF9fNy5TTEFTSF9FUVVBTCxcbiAgICAgIFNUQVIgPSAkX183LlNUQVIsXG4gICAgICBTVEFSX0VRVUFMID0gJF9fNy5TVEFSX0VRVUFMLFxuICAgICAgU1RBUl9TVEFSID0gJF9fNy5TVEFSX1NUQVIsXG4gICAgICBTVEFSX1NUQVJfRVFVQUwgPSAkX183LlNUQVJfU1RBUl9FUVVBTCxcbiAgICAgIFNUUklORyA9ICRfXzcuU1RSSU5HLFxuICAgICAgVU5TSUdORURfUklHSFRfU0hJRlQgPSAkX183LlVOU0lHTkVEX1JJR0hUX1NISUZULFxuICAgICAgVU5TSUdORURfUklHSFRfU0hJRlRfRVFVQUwgPSAkX183LlVOU0lHTkVEX1JJR0hUX1NISUZUX0VRVUFMLFxuICAgICAgWUlFTEQgPSAkX183LllJRUxEO1xuICB2YXIgJF9fOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3N5bnRheC9QYXJzZVRyZWVWYWxpZGF0b3IuanNcIikpLFxuICAgICAgQVJSQVlfUEFUVEVSTiA9ICRfXzguQVJSQVlfUEFUVEVSTixcbiAgICAgIEFTU0lHTk1FTlRfRUxFTUVOVCA9ICRfXzguQVNTSUdOTUVOVF9FTEVNRU5ULFxuICAgICAgQklORElOR19FTEVNRU5UID0gJF9fOC5CSU5ESU5HX0VMRU1FTlQsXG4gICAgICBCSU5ESU5HX0lERU5USUZJRVIgPSAkX184LkJJTkRJTkdfSURFTlRJRklFUixcbiAgICAgIEJMT0NLID0gJF9fOC5CTE9DSyxcbiAgICAgIENBU0VfQ0xBVVNFID0gJF9fOC5DQVNFX0NMQVVTRSxcbiAgICAgIENBVENIID0gJF9fOC5DQVRDSCxcbiAgICAgIENMQVNTX0RFQ0xBUkFUSU9OID0gJF9fOC5DTEFTU19ERUNMQVJBVElPTixcbiAgICAgIENPTVBVVEVEX1BST1BFUlRZX05BTUUgPSAkX184LkNPTVBVVEVEX1BST1BFUlRZX05BTUUsXG4gICAgICBERUZBVUxUX0NMQVVTRSA9ICRfXzguREVGQVVMVF9DTEFVU0UsXG4gICAgICBFWFBPUlRfREVGQVVMVCA9ICRfXzguRVhQT1JUX0RFRkFVTFQsXG4gICAgICBFWFBPUlRfU1BFQ0lGSUVSID0gJF9fOC5FWFBPUlRfU1BFQ0lGSUVSLFxuICAgICAgRVhQT1JUX1NQRUNJRklFUl9TRVQgPSAkX184LkVYUE9SVF9TUEVDSUZJRVJfU0VULFxuICAgICAgRVhQT1JUX1NUQVIgPSAkX184LkVYUE9SVF9TVEFSLFxuICAgICAgRklOQUxMWSA9ICRfXzguRklOQUxMWSxcbiAgICAgIEZPUk1BTF9QQVJBTUVURVIgPSAkX184LkZPUk1BTF9QQVJBTUVURVIsXG4gICAgICBGT1JNQUxfUEFSQU1FVEVSX0xJU1QgPSAkX184LkZPUk1BTF9QQVJBTUVURVJfTElTVCxcbiAgICAgIEZPUldBUkRfREVGQVVMVF9FWFBPUlQgPSAkX184LkZPUldBUkRfREVGQVVMVF9FWFBPUlQsXG4gICAgICBGVU5DVElPTl9CT0RZID0gJF9fOC5GVU5DVElPTl9CT0RZLFxuICAgICAgRlVOQ1RJT05fREVDTEFSQVRJT04gPSAkX184LkZVTkNUSU9OX0RFQ0xBUkFUSU9OLFxuICAgICAgR0VUX0FDQ0VTU09SID0gJF9fOC5HRVRfQUNDRVNTT1IsXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX184LklERU5USUZJRVJfRVhQUkVTU0lPTixcbiAgICAgIElNUE9SVEVEX0JJTkRJTkcgPSAkX184LklNUE9SVEVEX0JJTkRJTkcsXG4gICAgICBJTVBPUlRfQ0xBVVNFX1BBSVIgPSAkX184LklNUE9SVF9DTEFVU0VfUEFJUixcbiAgICAgIElNUE9SVF9TUEVDSUZJRVJfU0VUID0gJF9fOC5JTVBPUlRfU1BFQ0lGSUVSX1NFVCxcbiAgICAgIElNUE9SVF9UWVBFX0NMQVVTRSA9ICRfXzguSU1QT1JUX1RZUEVfQ0xBVVNFLFxuICAgICAgSlNYX0FUVFJJQlVURSA9ICRfXzguSlNYX0FUVFJJQlVURSxcbiAgICAgIEpTWF9FTEVNRU5UX05BTUUgPSAkX184LkpTWF9FTEVNRU5UX05BTUUsXG4gICAgICBKU1hfRUxFTUVOVCA9ICRfXzguSlNYX0VMRU1FTlQsXG4gICAgICBKU1hfUExBQ0VIT0xERVIgPSAkX184LkpTWF9QTEFDRUhPTERFUixcbiAgICAgIEpTWF9TUFJFQURfQVRUUklCVVRFID0gJF9fOC5KU1hfU1BSRUFEX0FUVFJJQlVURSxcbiAgICAgIEpTWF9URVhUID0gJF9fOC5KU1hfVEVYVCxcbiAgICAgIExJVEVSQUxfUFJPUEVSVFlfTkFNRSA9ICRfXzguTElURVJBTF9QUk9QRVJUWV9OQU1FLFxuICAgICAgTUVUSE9EID0gJF9fOC5NRVRIT0QsXG4gICAgICBNT0RVTEVfU1BFQ0lGSUVSID0gJF9fOC5NT0RVTEVfU1BFQ0lGSUVSLFxuICAgICAgTkFNRURfRVhQT1JUID0gJF9fOC5OQU1FRF9FWFBPUlQsXG4gICAgICBOQU1FX1NQQUNFX0VYUE9SVCA9ICRfXzguTkFNRV9TUEFDRV9FWFBPUlQsXG4gICAgICBOQU1FX1NQQUNFX0lNUE9SVCA9ICRfXzguTkFNRV9TUEFDRV9JTVBPUlQsXG4gICAgICBPQkpFQ1RfUEFUVEVSTiA9ICRfXzguT0JKRUNUX1BBVFRFUk4sXG4gICAgICBPQkpFQ1RfUEFUVEVSTl9GSUVMRCA9ICRfXzguT0JKRUNUX1BBVFRFUk5fRklFTEQsXG4gICAgICBQUk9QRVJUWV9OQU1FX0FTU0lHTk1FTlQgPSAkX184LlBST1BFUlRZX05BTUVfQVNTSUdOTUVOVCxcbiAgICAgIFBST1BFUlRZX05BTUVfU0hPUlRIQU5EID0gJF9fOC5QUk9QRVJUWV9OQU1FX1NIT1JUSEFORCxcbiAgICAgIFBST1BFUlRZX1ZBUklBQkxFX0RFQ0xBUkFUSU9OID0gJF9fOC5QUk9QRVJUWV9WQVJJQUJMRV9ERUNMQVJBVElPTixcbiAgICAgIFJFU1RfUEFSQU1FVEVSID0gJF9fOC5SRVNUX1BBUkFNRVRFUixcbiAgICAgIFNFVF9BQ0NFU1NPUiA9ICRfXzguU0VUX0FDQ0VTU09SLFxuICAgICAgU1BSRUFEX0VYUFJFU1NJT04gPSAkX184LlNQUkVBRF9FWFBSRVNTSU9OLFxuICAgICAgVEVNUExBVEVfTElURVJBTF9QT1JUSU9OID0gJF9fOC5URU1QTEFURV9MSVRFUkFMX1BPUlRJT04sXG4gICAgICBURU1QTEFURV9TVUJTVElUVVRJT04gPSAkX184LlRFTVBMQVRFX1NVQlNUSVRVVElPTixcbiAgICAgIFRZUEVfQUxJQVNfREVDTEFSQVRJT04gPSAkX184LlRZUEVfQUxJQVNfREVDTEFSQVRJT04sXG4gICAgICBUWVBFX0FSR1VNRU5UUyA9ICRfXzguVFlQRV9BUkdVTUVOVFMsXG4gICAgICBUWVBFX05BTUUgPSAkX184LlRZUEVfTkFNRSxcbiAgICAgIFRZUEVfUEFSQU1FVEVSID0gJF9fOC5UWVBFX1BBUkFNRVRFUixcbiAgICAgIFRZUEVfUEFSQU1FVEVSUyA9ICRfXzguVFlQRV9QQVJBTUVURVJTLFxuICAgICAgVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCA9ICRfXzguVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCxcbiAgICAgIFZBUklBQkxFX1NUQVRFTUVOVCA9ICRfXzguVkFSSUFCTEVfU1RBVEVNRU5UO1xuICB2YXIgYXNzZXJ0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvYXNzZXJ0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9zeW50YXgvUGFyc2VUcmVlVmFsaWRhdG9yLmpzXCIpKS5hc3NlcnQ7XG4gIHZhciBWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcih0cmVlLCBtZXNzYWdlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihWYWxpZGF0aW9uRXJyb3IpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhbGlkYXRpb25FcnJvciwge30sIHt9LCAkX19zdXBlcik7XG4gIH0oRXJyb3IpO1xuICB2YXIgUGFyc2VUcmVlVmFsaWRhdG9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQYXJzZVRyZWVWYWxpZGF0b3IoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQYXJzZVRyZWVWYWxpZGF0b3IpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQYXJzZVRyZWVWYWxpZGF0b3IsIHtcbiAgICAgIGZhaWxfOiBmdW5jdGlvbih0cmVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodHJlZSwgbWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgY2hlY2tfOiBmdW5jdGlvbihjb25kaXRpb24sIHRyZWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICB0aGlzLmZhaWxfKHRyZWUsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tWaXNpdF86IGZ1bmN0aW9uKGNvbmRpdGlvbiwgdHJlZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmNoZWNrXyhjb25kaXRpb24sIHRyZWUsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrVHlwZV86IGZ1bmN0aW9uKHR5cGUsIHRyZWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLnR5cGUgPT09IHR5cGUsIHRyZWUsIG1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QXJndW1lbnRMaXN0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGFyZ3VtZW50ID0gdHJlZS5hcmdzW2ldO1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oYXJndW1lbnQuaXNBc3NpZ25tZW50T3JTcHJlYWQoKSwgYXJndW1lbnQsICdhc3NpZ25tZW50IG9yIHNwcmVhZCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJheUxpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0cmVlLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50LmlzQXNzaWdubWVudE9yU3ByZWFkKCksIGVsZW1lbnQsICdhc3NpZ25tZW50IG9yIHNwcmVhZCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRBcnJheVBhdHRlcm46IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0cmVlLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50LnR5cGUgPT09IEJJTkRJTkdfRUxFTUVOVCB8fCBlbGVtZW50LnR5cGUgPT09IEFTU0lHTk1FTlRfRUxFTUVOVCB8fCBlbGVtZW50LmlzTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHx8IGVsZW1lbnQuaXNQYXR0ZXJuKCkgfHwgZWxlbWVudC5pc1NwcmVhZFBhdHRlcm5FbGVtZW50KCksIGVsZW1lbnQsICdudWxsLCBzdWIgcGF0dGVybiwgbGVmdCBoYW5kIHNpZGUgZXhwcmVzc2lvbiBvciBzcHJlYWQgZXhwZWN0ZWQnKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmlzU3ByZWFkUGF0dGVybkVsZW1lbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja18oaSA9PT0gKHRyZWUuZWxlbWVudHMubGVuZ3RoIC0gMSksIGVsZW1lbnQsICdzcHJlYWQgaW4gYXJyYXkgcGF0dGVybnMgbXVzdCBiZSB0aGUgbGFzdCBlbGVtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHN3aXRjaCAodHJlZS5vcGVyYXRvci50eXBlKSB7XG4gICAgICAgICAgY2FzZSBFUVVBTDpcbiAgICAgICAgICBjYXNlIFNUQVJfRVFVQUw6XG4gICAgICAgICAgY2FzZSBTVEFSX1NUQVJfRVFVQUw6XG4gICAgICAgICAgY2FzZSBTTEFTSF9FUVVBTDpcbiAgICAgICAgICBjYXNlIFBFUkNFTlRfRVFVQUw6XG4gICAgICAgICAgY2FzZSBQTFVTX0VRVUFMOlxuICAgICAgICAgIGNhc2UgTUlOVVNfRVFVQUw6XG4gICAgICAgICAgY2FzZSBMRUZUX1NISUZUX0VRVUFMOlxuICAgICAgICAgIGNhc2UgUklHSFRfU0hJRlRfRVFVQUw6XG4gICAgICAgICAgY2FzZSBVTlNJR05FRF9SSUdIVF9TSElGVF9FUVVBTDpcbiAgICAgICAgICBjYXNlIEFNUEVSU0FORF9FUVVBTDpcbiAgICAgICAgICBjYXNlIENBUkVUX0VRVUFMOlxuICAgICAgICAgIGNhc2UgQkFSX0VRVUFMOlxuICAgICAgICAgICAgdGhpcy5jaGVja18odHJlZS5sZWZ0LmlzTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHx8IHRyZWUubGVmdC5pc1BhdHRlcm4oKSwgdHJlZS5sZWZ0LCAnbGVmdCBoYW5kIHNpZGUgZXhwcmVzc2lvbiBvciBwYXR0ZXJuIGV4cGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLnJpZ2h0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5yaWdodCwgJ2Fzc2lnbm1lbnQgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBBTkQ6XG4gICAgICAgICAgY2FzZSBPUjpcbiAgICAgICAgICBjYXNlIEJBUjpcbiAgICAgICAgICBjYXNlIENBUkVUOlxuICAgICAgICAgIGNhc2UgQU1QRVJTQU5EOlxuICAgICAgICAgIGNhc2UgRVFVQUxfRVFVQUw6XG4gICAgICAgICAgY2FzZSBOT1RfRVFVQUw6XG4gICAgICAgICAgY2FzZSBFUVVBTF9FUVVBTF9FUVVBTDpcbiAgICAgICAgICBjYXNlIE5PVF9FUVVBTF9FUVVBTDpcbiAgICAgICAgICBjYXNlIE9QRU5fQU5HTEU6XG4gICAgICAgICAgY2FzZSBDTE9TRV9BTkdMRTpcbiAgICAgICAgICBjYXNlIEdSRUFURVJfRVFVQUw6XG4gICAgICAgICAgY2FzZSBMRVNTX0VRVUFMOlxuICAgICAgICAgIGNhc2UgSU5TVEFOQ0VPRjpcbiAgICAgICAgICBjYXNlIElOOlxuICAgICAgICAgIGNhc2UgTEVGVF9TSElGVDpcbiAgICAgICAgICBjYXNlIFJJR0hUX1NISUZUOlxuICAgICAgICAgIGNhc2UgVU5TSUdORURfUklHSFRfU0hJRlQ6XG4gICAgICAgICAgY2FzZSBQTFVTOlxuICAgICAgICAgIGNhc2UgTUlOVVM6XG4gICAgICAgICAgY2FzZSBTVEFSOlxuICAgICAgICAgIGNhc2UgU0xBU0g6XG4gICAgICAgICAgY2FzZSBQRVJDRU5UOlxuICAgICAgICAgIGNhc2UgU1RBUl9TVEFSOlxuICAgICAgICAgICAgdGhpcy5jaGVja18odHJlZS5sZWZ0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5sZWZ0LCAnYXNzaWdubWVudCBleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLnJpZ2h0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5yaWdodCwgJ2Fzc2lnbm1lbnQgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZmFpbF8odHJlZSwgJ3VuZXhwZWN0ZWQgYmluYXJ5IG9wZXJhdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmxlZnQpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUucmlnaHQpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QmluZGluZ0VsZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0cmVlLmJpbmRpbmc7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oYmluZGluZy50eXBlID09PSBCSU5ESU5HX0lERU5USUZJRVIgfHwgYmluZGluZy50eXBlID09PSBPQkpFQ1RfUEFUVEVSTiB8fCBiaW5kaW5nLnR5cGUgPT09IEFSUkFZX1BBVFRFUk4sIGJpbmRpbmcsICdleHBlY3RlZCB2YWxpZCBiaW5kaW5nIGVsZW1lbnQnKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEFzc2lnbm1lbnRFbGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBhc3NpZ25tZW50ID0gdHJlZS5hc3NpZ25tZW50O1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKGFzc2lnbm1lbnQudHlwZSA9PT0gT0JKRUNUX1BBVFRFUk4gfHwgYXNzaWdubWVudC50eXBlID09PSBBUlJBWV9QQVRURVJOIHx8IGFzc2lnbm1lbnQuaXNMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCksIGFzc2lnbm1lbnQsICdleHBlY3RlZCB2YWxpZCBhc3NpZ25tZW50IGVsZW1lbnQnKTtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmluaXRpYWxpemVyKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEJsb2NrOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5zdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRyZWUuc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHN0YXRlbWVudC5pc1N0YXRlbWVudExpc3RJdGVtKCksIHN0YXRlbWVudCwgJ3N0YXRlbWVudCBvciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLm9wZXJhbmQuaXNNZW1iZXJFeHByZXNzaW9uKCksIHRyZWUub3BlcmFuZCwgJ21lbWJlciBleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQgaW5zdGFuY2VvZiBOZXdFeHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5jaGVja18odHJlZS5vcGVyYW5kLmFyZ3MgIT09IG51bGwsIHRyZWUub3BlcmFuZCwgJ25ldyBhcmdzIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm9wZXJhbmQpO1xuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUuYXJncyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDYXNlQ2xhdXNlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5leHByZXNzaW9uLmlzRXhwcmVzc2lvbigpLCB0cmVlLmV4cHJlc3Npb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5zdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRyZWUuc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHN0YXRlbWVudC5pc1N0YXRlbWVudExpc3RJdGVtKCksIHN0YXRlbWVudCwgJ3N0YXRlbWVudCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRDYXRjaDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuYmluZGluZy5pc1BhdHRlcm4oKSB8fCB0cmVlLmJpbmRpbmcudHlwZSA9PT0gQklORElOR19JREVOVElGSUVSLCB0cmVlLmJpbmRpbmcsICdiaW5kaW5nIGlkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmNhdGNoQm9keS50eXBlID09PSBCTE9DSywgdHJlZS5jYXRjaEJvZHksICdibG9jayBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3NTaGFyZWRfKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMudmlzaXRDbGFzc1NoYXJlZF8odHJlZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRDbGFzc1NoYXJlZF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUudHlwZVBhcmFtZXRlcnMudHlwZSA9PT0gVFlQRV9QQVJBTUVURVJTLCB0cmVlLnR5cGVQYXJhbWV0ZXJzLCAndHlwZSBwYXJhbWV0ZXJzIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0cmVlLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdFVF9BQ0NFU1NPUjpcbiAgICAgICAgICAgIGNhc2UgU0VUX0FDQ0VTU09SOlxuICAgICAgICAgICAgY2FzZSBNRVRIT0Q6XG4gICAgICAgICAgICBjYXNlIFBST1BFUlRZX1ZBUklBQkxFX0RFQ0xBUkFUSU9OOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuZmFpbF8oZWxlbWVudCwgJ2NsYXNzIGVsZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy52aXNpdEFueShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0Q29tbWFFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdHJlZS5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKGV4cHJlc3Npb24uaXNFeHByZXNzaW9uKCksIGV4cHJlc3Npb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuY29uZGl0aW9uLmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5jb25kaXRpb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5sZWZ0LmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5sZWZ0LCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUucmlnaHQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbigpLCB0cmVlLnJpZ2h0LCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Q292ZXJGb3JtYWxzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZmFpbF8odHJlZSwgJ0NvdmVyRm9ybWFscyBzaG91bGQgaGF2ZSBiZWVuIHJlbW92ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdENvdmVySW5pdGlhbGl6ZWROYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuZmFpbF8odHJlZSwgJ0NvdmVySW5pdGlhbGl6ZWROYW1lIHNob3VsZCBoYXZlIGJlZW4gcmVtb3ZlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0RGVmYXVsdENsYXVzZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0cmVlLnN0YXRlbWVudHNbaV07XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0XyhzdGF0ZW1lbnQuaXNTdGF0ZW1lbnRMaXN0SXRlbSgpLCBzdGF0ZW1lbnQsICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0RG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuYm9keS5pc1N0YXRlbWVudCgpLCB0cmVlLmJvZHksICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmNvbmRpdGlvbi5pc0V4cHJlc3Npb24oKSwgdHJlZS5jb25kaXRpb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZGVjbFR5cGUgPSB0cmVlLmRlY2xhcmF0aW9uLnR5cGU7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oZGVjbFR5cGUgPT09IFZBUklBQkxFX1NUQVRFTUVOVCB8fCBkZWNsVHlwZSA9PT0gRlVOQ1RJT05fREVDTEFSQVRJT04gfHwgZGVjbFR5cGUgPT09IENMQVNTX0RFQ0xBUkFUSU9OIHx8IGRlY2xUeXBlID09PSBOQU1FRF9FWFBPUlQgfHwgZGVjbFR5cGUgPT09IEVYUE9SVF9ERUZBVUxUIHx8IGRlY2xUeXBlID09PSBUWVBFX0FMSUFTX0RFQ0xBUkFUSU9OLCB0cmVlLmRlY2xhcmF0aW9uLCAnZXhwZWN0ZWQgdmFsaWQgZXhwb3J0IHRyZWUnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBzcGVjaWZpZXJUeXBlID0gdHJlZS5leHBvcnRDbGF1c2UudHlwZTtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0XyhzcGVjaWZpZXJUeXBlID09PSBFWFBPUlRfU1BFQ0lGSUVSIHx8IHNwZWNpZmllclR5cGUgPT09IEVYUE9SVF9TUEVDSUZJRVJfU0VUIHx8IHNwZWNpZmllclR5cGUgPT09IEVYUE9SVF9TVEFSIHx8IHNwZWNpZmllclR5cGUgPT09IEZPUldBUkRfREVGQVVMVF9FWFBPUlQgfHwgc3BlY2lmaWVyVHlwZSA9PT0gTkFNRV9TUEFDRV9FWFBPUlQsIHRyZWUuZXhwb3J0Q2xhdXNlLCAnSW52YWxpZCBleHBvcnQgY2xhdXNlJyk7XG4gICAgICAgIGlmICh0cmVlLm1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5tb2R1bGVTcGVjaWZpZXIudHlwZSA9PT0gTU9EVUxFX1NQRUNJRklFUiwgdHJlZS5tb2R1bGVTcGVjaWZpZXIsICdtb2R1bGUgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRFeHBvcnRTcGVjaWZpZXJTZXQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja18odHJlZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDAsIHRyZWUsICdleHBlY3RlZCBhdCBsZWFzdCBvbmUgaWRlbnRpZmllcicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuc3BlY2lmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzcGVjaWZpZXIgPSB0cmVlLnNwZWNpZmllcnNbaV07XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0XyhzcGVjaWZpZXIudHlwZSA9PT0gRVhQT1JUX1NQRUNJRklFUiB8fCBzcGVjaWZpZXIudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OLCBzcGVjaWZpZXIsICdleHBlY3RlZCB2YWxpZCBleHBvcnQgc3BlY2lmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmV4cHJlc3Npb24uaXNFeHByZXNzaW9uKCksIHRyZWUuZXhwcmVzc2lvbiwgJ2V4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZpbmFsbHk6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmJsb2NrLnR5cGUgPT09IEJMT0NLLCB0cmVlLmJsb2NrLCAnYmxvY2sgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvck9mU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5pbml0aWFsaXplci5pc1BhdHRlcm4oKSB8fCB0cmVlLmluaXRpYWxpemVyLnR5cGUgPT09IElERU5USUZJRVJfRVhQUkVTU0lPTiB8fCB0cmVlLmluaXRpYWxpemVyLnR5cGUgPT09IFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QgJiYgdHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxLCB0cmVlLmluaXRpYWxpemVyLCAnZm9yLWVhY2ggc3RhdGVtZW50IG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gb25lIHZhcmlhYmxlIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5jb2xsZWN0aW9uLmlzRXhwcmVzc2lvbigpLCB0cmVlLmNvbGxlY3Rpb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5ib2R5LmlzU3RhdGVtZW50KCksIHRyZWUuYm9keSwgJ3N0YXRlbWVudCBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0Rm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuaW5pdGlhbGl6ZXIudHlwZSA9PT0gVkFSSUFCTEVfREVDTEFSQVRJT05fTElTVCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5pbml0aWFsaXplci5kZWNsYXJhdGlvbnMubGVuZ3RoIDw9IDEsIHRyZWUuaW5pdGlhbGl6ZXIsICdmb3ItaW4gc3RhdGVtZW50IG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gb25lIHZhcmlhYmxlIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmluaXRpYWxpemVyLmlzUGF0dGVybigpIHx8IHRyZWUuaW5pdGlhbGl6ZXIuaXNFeHByZXNzaW9uKCksIHRyZWUuaW5pdGlhbGl6ZXIsICd2YXJpYWJsZSBkZWNsYXJhdGlvbiwgZXhwcmVzc2lvbiBvciAnICsgJ3BhdHRlcm4gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuY29sbGVjdGlvbi5pc0V4cHJlc3Npb24oKSwgdHJlZS5jb2xsZWN0aW9uLCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuYm9keS5pc1N0YXRlbWVudCgpLCB0cmVlLmJvZHksICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZvcm1hbFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gdHJlZS5wYXJhbWV0ZXJzW2ldO1xuICAgICAgICAgIGFzc2VydChwYXJhbWV0ZXIudHlwZSA9PT0gRk9STUFMX1BBUkFNRVRFUik7XG4gICAgICAgICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyLnBhcmFtZXRlcjtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEJJTkRJTkdfRUxFTUVOVDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJFU1RfUEFSQU1FVEVSOlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKGkgPT09IHRyZWUucGFyYW1ldGVycy5sZW5ndGggLSAxLCBwYXJhbWV0ZXIsICdyZXN0IHBhcmFtZXRlcnMgbXVzdCBiZSB0aGUgbGFzdCBwYXJhbWV0ZXIgaW4gYSBwYXJhbWV0ZXIgbGlzdCcpO1xuICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZV8oQklORElOR19JREVOVElGSUVSLCBwYXJhbWV0ZXIuaWRlbnRpZmllciwgJ2JpbmRpbmcgaWRlbnRpZmllciBleHBlY3RlZCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuZmFpbF8ocGFyYW1ldGVyLCAncGFyYW1ldGVycyBtdXN0IGJlIGlkZW50aWZpZXJzIG9yIHJlc3QnICsgKFwiIHBhcmFtZXRlcnMuIEZvdW5kOiBcIiArIHBhcmFtZXRlci50eXBlKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEZvclN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5pbml0aWFsaXplciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5pbml0aWFsaXplci5pc0V4cHJlc3Npb24oKSB8fCB0cmVlLmluaXRpYWxpemVyLnR5cGUgPT09IFZBUklBQkxFX0RFQ0xBUkFUSU9OX0xJU1QsIHRyZWUuaW5pdGlhbGl6ZXIsICd2YXJpYWJsZSBkZWNsYXJhdGlvbiBsaXN0IG9yIGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZS5jb25kaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuY29uZGl0aW9uLmlzRXhwcmVzc2lvbigpLCB0cmVlLmNvbmRpdGlvbiwgJ2V4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZS5pbmNyZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuaW5jcmVtZW50LmlzRXhwcmVzc2lvbigpLCB0cmVlLmluY3JlbWVudCwgJ2V4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuYm9keS5pc1N0YXRlbWVudCgpLCB0cmVlLmJvZHksICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uQm9keTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0cmVlLnN0YXRlbWVudHNbaV07XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0XyhzdGF0ZW1lbnQuaXNTdGF0ZW1lbnRMaXN0SXRlbSgpLCBzdGF0ZW1lbnQsICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZV8oQklORElOR19JREVOVElGSUVSLCB0cmVlLm5hbWUsICdiaW5kaW5nIGlkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5uYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1R5cGVfKEJJTkRJTkdfSURFTlRJRklFUiwgdHJlZS5uYW1lLCAnYmluZGluZyBpZGVudGlmaWVyIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uXyh0cmVlKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEZ1bmN0aW9uXzogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZV8oRk9STUFMX1BBUkFNRVRFUl9MSVNULCB0cmVlLnBhcmFtZXRlckxpc3QsICdmb3JtYWwgcGFyYW1ldGVycyBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrVHlwZV8oRlVOQ1RJT05fQk9EWSwgdHJlZS5ib2R5LCAnZnVuY3Rpb24gYm9keSBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0R2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Byb3BlcnR5TmFtZV8odHJlZS5uYW1lKTtcbiAgICAgICAgdGhpcy5jaGVja1R5cGVfKEZVTkNUSU9OX0JPRFksIHRyZWUuYm9keSwgJ2Z1bmN0aW9uIGJvZHkgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdElmU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5jb25kaXRpb24uaXNFeHByZXNzaW9uKCksIHRyZWUuY29uZGl0aW9uLCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuaWZDbGF1c2UuaXNTdGF0ZW1lbnQoKSwgdHJlZS5pZkNsYXVzZSwgJ3N0YXRlbWVudCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAodHJlZS5lbHNlQ2xhdXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmVsc2VDbGF1c2UuaXNTdGF0ZW1lbnQoKSwgdHJlZS5lbHNlQ2xhdXNlLCAnc3RhdGVtZW50IGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmltcG9ydENsYXVzZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tfKHRyZWUuaW1wb3J0Q2xhdXNlLnR5cGUgPT09IE5BTUVfU1BBQ0VfSU1QT1JUIHx8IHRyZWUuaW1wb3J0Q2xhdXNlLnR5cGUgPT09IElNUE9SVEVEX0JJTkRJTkcgfHwgdHJlZS5pbXBvcnRDbGF1c2UudHlwZSA9PT0gSU1QT1JUX1NQRUNJRklFUl9TRVQgfHwgdHJlZS5pbXBvcnRDbGF1c2UudHlwZSA9PT0gSU1QT1JUX0NMQVVTRV9QQUlSIHx8IHRyZWUuaW1wb3J0Q2xhdXNlLnR5cGUgPT09IElNUE9SVF9UWVBFX0NMQVVTRSwgdHJlZS5pbXBvcnRDbGF1c2UsICdJbnZhbGlkIGltcG9ydCBjbGF1c2UnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrVHlwZV8oTU9EVUxFX1NQRUNJRklFUiwgdHJlZS5tb2R1bGVTcGVjaWZpZXIsICdtb2R1bGUgc3BlY2lmaWVyIGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRJbXBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGVfKElNUE9SVEVEX0JJTkRJTkcsIHRyZWUuYmluZGluZywgJ0ltcG9ydGVkQmluZGluZyBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0ZWRCaW5kaW5nOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlXyhCSU5ESU5HX0lERU5USUZJRVIsIHRyZWUuYmluZGluZywgJ2JpbmRpbmcgaWRlbnRpZmllciBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0Q2xhdXNlUGFpcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZV8oSU1QT1JURURfQklORElORywgdHJlZS5maXJzdCwgJ0ltcG9ydGVkQmluZGluZyBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLnNlY29uZC50eXBlID09PSBOQU1FX1NQQUNFX0lNUE9SVCB8fCB0cmVlLnNlY29uZC50eXBlID09PSBJTVBPUlRfU1BFQ0lGSUVSX1NFVCwgdHJlZS5zZWNvbmQsICdJbnZhbGlkIGltcG9ydCBjbGF1c2UnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdEpzeEVsZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGVfKEpTWF9FTEVNRU5UX05BTUUsIHRyZWUubmFtZSwgJ0pTWCBFbGVtZW50IE5hbWUgZXhwZWN0ZWQnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IHRyZWUuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKGF0dHIudHlwZSA9PT0gSlNYX0FUVFJJQlVURSB8fCBhdHRyLnR5cGUgPT09IEpTWF9TUFJFQURfQVRUUklCVVRFLCBhdHRyLCAnSlNYIEF0dHJpYnV0ZSBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkX18zID0gMDsgaSRfXzMgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSRfXzMrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baSRfXzNdO1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oY2hpbGQudHlwZSA9PT0gSlNYX0VMRU1FTlQgfHwgY2hpbGQudHlwZSA9PT0gSlNYX1BMQUNFSE9MREVSIHx8IGNoaWxkLnR5cGUgPT09IEpTWF9URVhULCBjaGlsZCwgJ0pTWCBjaGlsZCBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRMYWJlbGxlZFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuc3RhdGVtZW50LmlzU3RhdGVtZW50KCksIHRyZWUuc3RhdGVtZW50LCAnc3RhdGVtZW50IGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfKHRyZWUub3BlcmFuZC5pc01lbWJlckV4cHJlc3Npb24oKSwgdHJlZS5vcGVyYW5kLCAnbWVtYmVyIGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZCBpbnN0YW5jZW9mIE5ld0V4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLm9wZXJhbmQuYXJncyAhPT0gbnVsbCwgdHJlZS5vcGVyYW5kLCAnbmV3IGFyZ3MgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUub3BlcmFuZCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZW1iZXJMb29rdXBFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfKHRyZWUub3BlcmFuZC5pc01lbWJlckV4cHJlc3Npb24oKSwgdHJlZS5vcGVyYW5kLCAnbWVtYmVyIGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZCBpbnN0YW5jZW9mIE5ld0V4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLm9wZXJhbmQuYXJncyAhPT0gbnVsbCwgdHJlZS5vcGVyYW5kLCAnbmV3IGFyZ3MgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUub3BlcmFuZCk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTeW50YXhFcnJvclRyZWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5mYWlsXyh0cmVlLCAoXCJwYXJzZSB0cmVlIGNvbnRhaW5zIFN5bnRheEVycm9yOiBcIiArIHRyZWUubWVzc2FnZSkpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfKHRyZWUudG9rZW4udHlwZSA9PT0gU1RSSU5HLCB0cmVlLCAnc3RyaW5nIG9yIGlkZW50aWZpZXIgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLm9wZXJhbmQuaXNNZW1iZXJFeHByZXNzaW9uKCksIHRyZWUub3BlcmFuZCwgJ21lbWJlciBleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZS5hcmdzKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdExpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IHRyZWUucHJvcGVydHlOYW1lQW5kVmFsdWVzW2ldO1xuICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lQW5kVmFsdWUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBHRVRfQUNDRVNTT1I6XG4gICAgICAgICAgICBjYXNlIFNFVF9BQ0NFU1NPUjpcbiAgICAgICAgICAgIGNhc2UgTUVUSE9EOlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrXyghcHJvcGVydHlOYW1lQW5kVmFsdWUuaXNTdGF0aWMsIHByb3BlcnR5TmFtZUFuZFZhbHVlLCAnc3RhdGljIGlzIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFsIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBST1BFUlRZX05BTUVfQVNTSUdOTUVOVDpcbiAgICAgICAgICAgIGNhc2UgUFJPUEVSVFlfTkFNRV9TSE9SVEhBTkQ6XG4gICAgICAgICAgICBjYXNlIFNQUkVBRF9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuZmFpbF8ocHJvcGVydHlOYW1lQW5kVmFsdWUsICdhY2Nlc3NvciwgcHJvcGVydHkgbmFtZSAnICsgJ2Fzc2lnbm1lbnQgb3IgcHJvcGVydHkgbWV0aG9kIGFzc2lnbWVudCBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHByb3BlcnR5TmFtZUFuZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0T2JqZWN0UGF0dGVybjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gdHJlZS5maWVsZHNbaV07XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0XyhmaWVsZC50eXBlID09PSBPQkpFQ1RfUEFUVEVSTl9GSUVMRCB8fCBmaWVsZC50eXBlID09PSBBU1NJR05NRU5UX0VMRU1FTlQgfHwgZmllbGQudHlwZSA9PT0gQklORElOR19FTEVNRU5ULCBmaWVsZCwgJ29iamVjdCBwYXR0ZXJuIGZpZWxkIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdE9iamVjdFBhdHRlcm5GaWVsZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrUHJvcGVydHlOYW1lXyh0cmVlLm5hbWUpO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuZWxlbWVudC50eXBlID09PSBBU1NJR05NRU5UX0VMRU1FTlQgfHwgdHJlZS5lbGVtZW50LnR5cGUgPT09IEJJTkRJTkdfRUxFTUVOVCB8fCB0cmVlLmVsZW1lbnQuaXNQYXR0ZXJuKCkgfHwgdHJlZS5lbGVtZW50LmlzTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpLCB0cmVlLmVsZW1lbnQsICdiaW5kaW5nIGVsZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFBhcmVuRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uLmlzUGF0dGVybigpKSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5leHByZXNzaW9uLmlzRXhwcmVzc2lvbigpLCB0cmVlLmV4cHJlc3Npb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdFBvc3RmaXhFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5vcGVyYW5kLmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5vcGVyYW5kLCAnYXNzaWdubWVudCBleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQcmVkZWZpbmVkVHlwZTogZnVuY3Rpb24odHJlZSkge30sXG4gICAgICB2aXNpdFNjcmlwdDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUuc2NyaXB0SXRlbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgc2NyaXB0SXRlbUxpc3QgPSB0cmVlLnNjcmlwdEl0ZW1MaXN0W2ldO1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oc2NyaXB0SXRlbUxpc3QuaXNTY3JpcHRFbGVtZW50KCksIHNjcmlwdEl0ZW1MaXN0LCAnZ2xvYmFsIHNjcmlwdCBpdGVtIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjaGVja1Byb3BlcnR5TmFtZV86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLnR5cGUgPT09IExJVEVSQUxfUFJPUEVSVFlfTkFNRSB8fCB0cmVlLnR5cGUgPT09IENPTVBVVEVEX1BST1BFUlRZX05BTUUsIHRyZWUsICdwcm9wZXJ0eSBuYW1lIGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRQcm9wZXJ0eU5hbWVBc3NpZ25tZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQcm9wZXJ0eU5hbWVfKHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS52YWx1ZS5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKCksIHRyZWUudmFsdWUsICdhc3NpZ25tZW50IGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFByb3BlcnR5TmFtZVNob3J0aGFuZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLm5hbWUudHlwZSA9PT0gSURFTlRJRklFUiB8fCB0cmVlLm5hbWUudHlwZSA9PT0gWUlFTEQgfHwgdHJlZS5uYW1lLmlzU3RyaWN0S2V5d29yZCgpLCB0cmVlLCAnaWRlbnRpZmllciB0b2tlbiBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TGl0ZXJhbFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdHlwZSA9IHRyZWUubGl0ZXJhbFRva2VuLnR5cGU7XG4gICAgICAgIHRoaXMuY2hlY2tfKHRyZWUubGl0ZXJhbFRva2VuLmlzS2V5d29yZCgpIHx8IHR5cGUgPT09IElERU5USUZJRVIgfHwgdHlwZSA9PT0gTlVNQkVSIHx8IHR5cGUgPT09IFNUUklORywgdHJlZSwgJ1VuZXhwZWN0ZWQgdG9rZW4gaW4gbGl0ZXJhbCBwcm9wZXJ0eSBuYW1lJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUub3BlcmFuZC5pc01lbWJlckV4cHJlc3Npb24oKSwgdHJlZS5vcGVyYW5kLCAnbWVtYmVyIG9yIGNhbGwgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdHJlZS5lbGVtZW50c1tpXTtcbiAgICAgICAgICBpZiAoaSAlIDIpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tUeXBlXyhURU1QTEFURV9TVUJTVElUVVRJT04sIGVsZW1lbnQsICdUZW1wbGF0ZSBsaXRlcmFsIHN1YnN0aXR1dGlvbiBleHBlY3RlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVHlwZV8oVEVNUExBVEVfTElURVJBTF9QT1JUSU9OLCBlbGVtZW50LCAnVGVtcGxhdGUgbGl0ZXJhbCBwb3J0aW9uIGV4cGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5leHByZXNzaW9uLmlzRXhwcmVzc2lvbigpLCB0cmVlLmV4cHJlc3Npb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdFNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQcm9wZXJ0eU5hbWVfKHRyZWUubmFtZSk7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlXyhGVU5DVElPTl9CT0RZLCB0cmVlLmJvZHksICdmdW5jdGlvbiBib2R5IGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTcHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5leHByZXNzaW9uLmlzQXNzaWdubWVudEV4cHJlc3Npb24oKSwgdHJlZS5leHByZXNzaW9uLCAnYXNzaWdubWVudCBleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRTdGF0ZU1hY2hpbmU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5mYWlsXyh0cmVlLCAnU3RhdGUgbWFjaGluZXMgYXJlIG5ldmVyIHZhbGlkIG91dHNpZGUgb2YgdGhlICcgKyAnR2VuZXJhdG9yVHJhbnNmb3JtZXIgcGFzcy4nKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuZXhwcmVzc2lvbi5pc0V4cHJlc3Npb24oKSwgdHJlZS5leHByZXNzaW9uLCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB2YXIgZGVmYXVsdENvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmNhc2VDbGF1c2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNhc2VDbGF1c2UgPSB0cmVlLmNhc2VDbGF1c2VzW2ldO1xuICAgICAgICAgIGlmIChjYXNlQ2xhdXNlLnR5cGUgPT09IERFRkFVTFRfQ0xBVVNFKSB7XG4gICAgICAgICAgICArK2RlZmF1bHRDb3VudDtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8oZGVmYXVsdENvdW50IDw9IDEsIGNhc2VDbGF1c2UsICdubyBtb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGFsbG93ZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVfKENBU0VfQ0xBVVNFLCBjYXNlQ2xhdXNlLCAnY2FzZSBvciBkZWZhdWx0IGNsYXVzZSBleHBlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0VGhyb3dTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLnZhbHVlLmlzRXhwcmVzc2lvbigpLCB0cmVlLnZhbHVlLCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VHJ5U3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlXyhCTE9DSywgdHJlZS5ib2R5LCAnYmxvY2sgZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKHRyZWUuY2F0Y2hCbG9jayAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tUeXBlXyhDQVRDSCwgdHJlZS5jYXRjaEJsb2NrLCAnY2F0Y2ggYmxvY2sgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJlZS5maW5hbGx5QmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVHlwZV8oRklOQUxMWSwgdHJlZS5maW5hbGx5QmxvY2ssICdmaW5hbGx5IGJsb2NrIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUuY2F0Y2hCbG9jayA9PT0gbnVsbCAmJiB0cmVlLmZpbmFsbHlCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZmFpbF8odHJlZSwgJ2VpdGhlciBjYXRjaCBvciBmaW5hbGx5IG11c3QgYmUgcHJlc2VudCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlQXJndW1lbnRzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBhcmdzID0gdHJlZS5hcmdzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKGFyZ3NbaV0uaXNUeXBlKCksIGFyZ3NbaV0sICdUeXBlIGFyZ3VtZW50cyBtdXN0IGJlIHR5cGUgZXhwcmVzc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0VHlwZU5hbWU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLm1vZHVsZU5hbWUgPT09IG51bGwgfHwgdHJlZS5tb2R1bGVOYW1lLnR5cGUgPT09IFRZUEVfTkFNRSwgdHJlZS5tb2R1bGVOYW1lLCAnbW9kdWxlTmFtZSBtdXN0IGJlIG51bGwgb3IgYSBUeXBlTmFtZScpO1xuICAgICAgICB0aGlzLmNoZWNrXyh0cmVlLm5hbWUudHlwZSA9PT0gSURFTlRJRklFUiwgdHJlZSwgJ25hbWUgbXVzdCBiZSBhbiBpZGVudGlmaWVyJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUmVmZXJlbmNlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlXyhUWVBFX05BTUUsIHRyZWUudHlwZU5hbWUsICd0eXBlTmFtZSBtdXN0IGJlIGEgVHlwZU5hbWUnKTtcbiAgICAgICAgdGhpcy5jaGVja1R5cGVfKFRZUEVfQVJHVU1FTlRTLCB0cmVlLmFyZ3MsICdhcmdzIG11c3QgYmUgYSBUeXBlQXJndW1lbnRzJyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUGFyYW1ldGVyczogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHRyZWUucGFyYW1ldGVycztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1R5cGVfKFRZUEVfUEFSQU1FVEVSLCBwYXJhbWV0ZXJzW2ldLCAnVHlwZSBwYXJhbWV0ZXJzIG11c3QgYWxsIGJlIHR5cGUgcGFyYW1ldGVycycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRUeXBlUGFyYW1ldGVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tfKHRyZWUuaWRlbnRpZmllclRva2VuLnR5cGUgPT09IElERU5USUZJRVIsIHRyZWUsICdUeXBlIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXIgdG9rZW4nKTtcbiAgICAgICAgaWYgKHRyZWUuZXh0ZW5kc1R5cGUpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuZXh0ZW5kc1R5cGUuaXNUeXBlKCksIHRyZWUuZXh0ZW5kc1R5cGUsICdleHRlbmRzIHR5cGUgbXVzdCBiZSBhIHR5cGUgZXhwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLm9wZXJhbmQuaXNBc3NpZ25tZW50RXhwcmVzc2lvbigpLCB0cmVlLm9wZXJhbmQsICdhc3NpZ25tZW50IGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmx2YWx1ZS5pc1BhdHRlcm4oKSB8fCB0cmVlLmx2YWx1ZS50eXBlID09PSBCSU5ESU5HX0lERU5USUZJRVIsIHRyZWUubHZhbHVlLCAnYmluZGluZyBpZGVudGlmaWVyIGV4cGVjdGVkLCBmb3VuZDogJyArIHRyZWUubHZhbHVlLnR5cGUpO1xuICAgICAgICBpZiAodHJlZS5pbml0aWFsaXplciAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5pbml0aWFsaXplci5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKCksIHRyZWUuaW5pdGlhbGl6ZXIsICdhc3NpZ25tZW50IGV4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZpc2l0V2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmNvbmRpdGlvbi5pc0V4cHJlc3Npb24oKSwgdHJlZS5jb25kaXRpb24sICdleHByZXNzaW9uIGV4cGVjdGVkJyk7XG4gICAgICAgIHRoaXMuY2hlY2tWaXNpdF8odHJlZS5ib2R5LmlzU3RhdGVtZW50KCksIHRyZWUuYm9keSwgJ3N0YXRlbWVudCBleHBlY3RlZCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0V2l0aFN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuZXhwcmVzc2lvbi5pc0V4cHJlc3Npb24oKSwgdHJlZS5leHByZXNzaW9uLCAnZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xuICAgICAgICB0aGlzLmNoZWNrVmlzaXRfKHRyZWUuYm9keS5pc1N0YXRlbWVudCgpLCB0cmVlLmJvZHksICdzdGF0ZW1lbnQgZXhwZWN0ZWQnKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdFlpZWxkRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5leHByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Zpc2l0Xyh0cmVlLmV4cHJlc3Npb24uaXNFeHByZXNzaW9uKCksIHRyZWUuZXhwcmVzc2lvbiwgJ2V4cHJlc3Npb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVmlzaXRvcik7XG4gIFBhcnNlVHJlZVZhbGlkYXRvci52YWxpZGF0ZSA9IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFBhcnNlVHJlZVZhbGlkYXRvcigpO1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0b3IudmlzaXRBbnkodHJlZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhdGlvbiA9IG51bGw7XG4gICAgICBpZiAoZS50cmVlICE9PSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uID0gZS50cmVlLmxvY2F0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGxvY2F0aW9uID09PSBudWxsKSB7XG4gICAgICAgIGxvY2F0aW9uID0gdHJlZS5sb2NhdGlvbjtcbiAgICAgIH1cbiAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IGxvY2F0aW9uICE9PSBudWxsID8gbG9jYXRpb24uc3RhcnQudG9TdHJpbmcoKSA6ICcodW5rbm93biknO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlBhcnNlIHRyZWUgdmFsaWRhdGlvbiBmYWlsdXJlICdcIiArIGUubWVzc2FnZSArIFwiJyBhdCBcIiArIGxvY2F0aW9uU3RyaW5nICsgXCI6XCIpICsgKFwiXFxuXFxuXCIgKyBUcmVlV3JpdGVyLndyaXRlKHRyZWUpICsgXCJcXG5cIikpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtnZXQgUGFyc2VUcmVlVmFsaWRhdG9yKCkge1xuICAgICAgcmV0dXJuIFBhcnNlVHJlZVZhbGlkYXRvcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9NdWx0aVRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTXVsdGlUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVmFsaWRhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9QYXJzZVRyZWVWYWxpZGF0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL011bHRpVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVZhbGlkYXRvcjtcbiAgdmFyIE11bHRpVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNdWx0aVRyYW5zZm9ybWVyKHJlcG9ydGVyLCB2YWxpZGF0ZSkge1xuICAgICAgdGhpcy5yZXBvcnRlcl8gPSByZXBvcnRlcjtcbiAgICAgIHRoaXMudmFsaWRhdGVfID0gdmFsaWRhdGU7XG4gICAgICB0aGlzLnRyZWVUcmFuc2Zvcm1lcnNfID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNdWx0aVRyYW5zZm9ybWVyLCB7XG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uKHRyZWVUcmFuc2Zvcm1lcikge1xuICAgICAgICB0aGlzLnRyZWVUcmFuc2Zvcm1lcnNfLnB1c2godHJlZVRyYW5zZm9ybWVyKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHJlcG9ydGVyID0gdGhpcy5yZXBvcnRlcl87XG4gICAgICAgIHZhciB2YWxpZGF0ZSA9IHRoaXMudmFsaWRhdGVfO1xuICAgICAgICB0aGlzLnRyZWVUcmFuc2Zvcm1lcnNfLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zZm9ybVRyZWUpIHtcbiAgICAgICAgICB0cmVlID0gdHJhbnNmb3JtVHJlZSh0cmVlKTtcbiAgICAgICAgICBpZiAocmVwb3J0ZXIuaGFkRXJyb3IoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBpZiAodmFsaWRhdGUpXG4gICAgICAgICAgICBQYXJzZVRyZWVWYWxpZGF0b3IudmFsaWRhdGUodHJlZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgTXVsdGlUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBNdWx0aVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL051bWVyaWNMaXRlcmFsVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9OdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9OdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL051bWVyaWNMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgTGl0ZXJhbEV4cHJlc3Npb24gPSAkX18yLkxpdGVyYWxFeHByZXNzaW9uLFxuICAgICAgTGl0ZXJhbFByb3BlcnR5TmFtZSA9ICRfXzIuTGl0ZXJhbFByb3BlcnR5TmFtZTtcbiAgdmFyIExpdGVyYWxUb2tlbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvTGl0ZXJhbFRva2VuLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9OdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKS5MaXRlcmFsVG9rZW47XG4gIHZhciBOVU1CRVIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lci5qc1wiKSkuTlVNQkVSO1xuICBmdW5jdGlvbiBuZWVkc1RyYW5zZm9ybSh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09PSBOVU1CRVIgJiYgL14wW2JCb09dLy50ZXN0KHRva2VuLnZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Ub2tlbih0b2tlbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbFRva2VuKE5VTUJFUiwgU3RyaW5nKHRva2VuLnByb2Nlc3NlZFZhbHVlKSwgdG9rZW4ubG9jYXRpb24pO1xuICB9XG4gIHZhciBOdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE51bWVyaWNMaXRlcmFsVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUxpdGVyYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRyZWUubGl0ZXJhbFRva2VuO1xuICAgICAgICBpZiAobmVlZHNUcmFuc2Zvcm0odG9rZW4pKVxuICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJhbnNmb3JtVG9rZW4odG9rZW4pKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGl0ZXJhbFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSB0cmVlLmxpdGVyYWxUb2tlbjtcbiAgICAgICAgaWYgKG5lZWRzVHJhbnNmb3JtKHRva2VuKSlcbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcm9wZXJ0eU5hbWUodHJlZS5sb2NhdGlvbiwgdHJhbnNmb3JtVG9rZW4odG9rZW4pKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IE51bWVyaWNMaXRlcmFsVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEZpbmRWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRmluZFZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL09iamVjdExpdGVyYWxUcmFuc2Zvcm1lci5qc1wiKSkuRmluZFZpc2l0b3I7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNC5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzQuSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBMaXRlcmFsRXhwcmVzc2lvbiA9ICRfXzQuTGl0ZXJhbEV4cHJlc3Npb247XG4gIHZhciBUZW1wVmFyVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UZW1wVmFyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL09iamVjdExpdGVyYWxUcmFuc2Zvcm1lci5qc1wiKSkuVGVtcFZhclRyYW5zZm9ybWVyO1xuICB2YXIgSURFTlRJRklFUiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLklERU5USUZJRVI7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQ09NUFVURURfUFJPUEVSVFlfTkFNRSA9ICRfXzcuQ09NUFVURURfUFJPUEVSVFlfTkFNRSxcbiAgICAgIExJVEVSQUxfUFJPUEVSVFlfTkFNRSA9ICRfXzcuTElURVJBTF9QUk9QRVJUWV9OQU1FO1xuICB2YXIgU3RyaW5nTWFwID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvU3RyaW5nTWFwLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLlN0cmluZ01hcDtcbiAgdmFyICRfXzkgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9PYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24gPSAkX185LmNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlQ29tbWFFeHByZXNzaW9uID0gJF9fOS5jcmVhdGVDb21tYUV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVEZWZpbmVQcm9wZXJ0eSA9ICRfXzkuY3JlYXRlRGVmaW5lUHJvcGVydHksXG4gICAgICBjcmVhdGVFbXB0eVBhcmFtZXRlckxpc3QgPSAkX185LmNyZWF0ZUVtcHR5UGFyYW1ldGVyTGlzdCxcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9ICRfXzkuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX185LmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlT2JqZWN0Q3JlYXRlID0gJF9fOS5jcmVhdGVPYmplY3RDcmVhdGUsXG4gICAgICBjcmVhdGVPYmplY3RMaXRlcmFsID0gJF9fOS5jcmVhdGVPYmplY3RMaXRlcmFsLFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fOS5jcmVhdGVQYXJlbkV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVQcm9wZXJ0eU5hbWVBc3NpZ25tZW50ID0gJF9fOS5jcmVhdGVQcm9wZXJ0eU5hbWVBc3NpZ25tZW50LFxuICAgICAgY3JlYXRlU3RyaW5nTGl0ZXJhbCA9ICRfXzkuY3JlYXRlU3RyaW5nTGl0ZXJhbDtcbiAgdmFyIHByb3BOYW1lID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N0YXRpY3NlbWFudGljcy9Qcm9wTmFtZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKS5wcm9wTmFtZTtcbiAgdmFyIEZpbmRBZHZhbmNlZFByb3BlcnR5ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBGaW5kQWR2YW5jZWRQcm9wZXJ0eSh0cmFuc2Zvcm1PcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGaW5kQWR2YW5jZWRQcm9wZXJ0eSkuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtT3B0aW9uc18gPSB0cmFuc2Zvcm1PcHRpb25zO1xuICAgICAgdGhpcy5wcm90b0V4cHJlc3Npb24gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoRmluZEFkdmFuY2VkUHJvcGVydHksIHtcbiAgICAgIHZpc2l0UHJvcGVydHlOYW1lQXNzaWdubWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoaXNQcm90b05hbWUodHJlZS5uYW1lKSlcbiAgICAgICAgICB0aGlzLnByb3RvRXhwcmVzc2lvbiA9IHRyZWUudmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRNZXRob2Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0R2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtT3B0aW9uc18ucHJvcGVyVGFpbENhbGxzKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFueSh0cmVlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmlzaXRTZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1PcHRpb25zXy5wcm9wZXJUYWlsQ2FsbHMpIHtcbiAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QW55KHRyZWUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdENvbXB1dGVkUHJvcGVydHlOYW1lOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU9wdGlvbnNfLmNvbXB1dGVkUHJvcGVydHlOYW1lcylcbiAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEZpbmRWaXNpdG9yKTtcbiAgZnVuY3Rpb24gaXNQcm90b05hbWUodHJlZSkge1xuICAgIHJldHVybiBwcm9wTmFtZSh0cmVlKSA9PT0gJ19fcHJvdG9fXyc7XG4gIH1cbiAgdmFyIE9iamVjdExpdGVyYWxUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihPYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIpLmNhbGwodGhpcywgaWRlbnRpZmllckdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1PcHRpb25zXyA9IG9wdGlvbnMudHJhbnNmb3JtT3B0aW9ucztcbiAgICAgIHRoaXMucHJvdG9FeHByZXNzaW9uID0gbnVsbDtcbiAgICAgIHRoaXMubmVlZHNBZHZhbmNlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZWVuQWNjZXNzb3JzID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE9iamVjdExpdGVyYWxUcmFuc2Zvcm1lciwge1xuICAgICAgZmluZFNlZW5BY2Nlc3Nvcl86IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gQ09NUFVURURfUFJPUEVSVFlfTkFNRSlcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIHMgPSBwcm9wTmFtZShuYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VlbkFjY2Vzc29ycy5nZXQocyk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlU2VlbkFjY2Vzc29yXzogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAobmFtZS50eXBlID09PSBDT01QVVRFRF9QUk9QRVJUWV9OQU1FKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHMgPSBwcm9wTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5zZWVuQWNjZXNzb3JzLmRlbGV0ZShzKTtcbiAgICAgIH0sXG4gICAgICBhZGRTZWVuQWNjZXNzb3JfOiBmdW5jdGlvbihuYW1lLCBkZXNjcikge1xuICAgICAgICBpZiAobmFtZS50eXBlID09PSBDT01QVVRFRF9QUk9QRVJUWV9OQU1FKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHMgPSBwcm9wTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5zZWVuQWNjZXNzb3JzLnNldChzLCBkZXNjcik7XG4gICAgICB9LFxuICAgICAgY3JlYXRlUHJvcGVydHlfOiBmdW5jdGlvbihuYW1lLCBkZXNjcikge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKG5hbWUudHlwZSA9PT0gTElURVJBTF9QUk9QRVJUWV9OQU1FKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmVlZHNBZHZhbmNlZFRyYW5zZm9ybSlcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmdldFByb3BlcnR5TmFtZV8obmFtZSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IG5hbWUuZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3IuZ2V0IHx8IGRlc2NyLnNldCkge1xuICAgICAgICAgIHZhciBvbGRBY2Nlc3NvciA9IHRoaXMuZmluZFNlZW5BY2Nlc3Nvcl8obmFtZSk7XG4gICAgICAgICAgaWYgKG9sZEFjY2Vzc29yKSB7XG4gICAgICAgICAgICBvbGRBY2Nlc3Nvci5nZXQgPSBkZXNjci5nZXQgfHwgb2xkQWNjZXNzb3IuZ2V0O1xuICAgICAgICAgICAgb2xkQWNjZXNzb3Iuc2V0ID0gZGVzY3Iuc2V0IHx8IG9sZEFjY2Vzc29yLnNldDtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VlbkFjY2Vzc29yXyhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZW5BY2Nlc3Nvcl8obmFtZSwgZGVzY3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2V4cHJlc3Npb24sIGRlc2NyXTtcbiAgICAgIH0sXG4gICAgICBnZXRQcm9wZXJ0eU5hbWVfOiBmdW5jdGlvbihuYW1lVHJlZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBuYW1lVHJlZS5saXRlcmFsVG9rZW47XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgSURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdMaXRlcmFsKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHRva2VuLmlzS2V5d29yZCgpKVxuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTGl0ZXJhbCh0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odG9rZW4ubG9jYXRpb24sIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdExpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9sZE5lZWRzVHJhbnNmb3JtID0gdGhpcy5uZWVkc0FkdmFuY2VkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgb2xkU2VlbkFjY2Vzc29ycyA9IHRoaXMuc2VlbkFjY2Vzc29ycztcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdGhpcy50cmFuc2Zvcm1PYmplY3RMaXRlcmFsSW5uZXJfKHRyZWUpO1xuICAgICAgICB0aGlzLm5lZWRzQWR2YW5jZWRUcmFuc2Zvcm0gPSBvbGROZWVkc1RyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5zZWVuQWNjZXNzb3JzID0gb2xkU2VlbkFjY2Vzc29ycztcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdExpdGVyYWxJbm5lcl86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGZpbmRlciA9IG5ldyBGaW5kQWR2YW5jZWRQcm9wZXJ0eSh0aGlzLnRyYW5zZm9ybU9wdGlvbnNfKTtcbiAgICAgICAgZmluZGVyLnZpc2l0QW55KHRyZWUpO1xuICAgICAgICBpZiAoIWZpbmRlci5mb3VuZCkge1xuICAgICAgICAgIHRoaXMubmVlZHNBZHZhbmNlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1PYmplY3RMaXRlcmFsXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZWVkc0FkdmFuY2VkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWVuQWNjZXNzb3JzID0gbmV3IFN0cmluZ01hcCgpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLnByb3BlcnR5TmFtZUFuZFZhbHVlcyk7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdGVtcFZhciA9IHRoaXMuYWRkVGVtcFZhcigpO1xuICAgICAgICB2YXIgdGVtcFZhcklkZW50aWZpZXJFeHByZXNzaW9uID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odGVtcFZhcik7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHByb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwcm9wZXJ0eVswXTtcbiAgICAgICAgICB2YXIgZGVzY3IgPSBwcm9wZXJ0eVsxXTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRGVmaW5lUHJvcGVydHkodGVtcFZhcklkZW50aWZpZXJFeHByZXNzaW9uLCBleHByZXNzaW9uLCBkZXNjcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvdG9FeHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkoZmluZGVyLnByb3RvRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBvYmplY3RFeHByZXNzaW9uO1xuICAgICAgICBpZiAocHJvdG9FeHByZXNzaW9uKVxuICAgICAgICAgIG9iamVjdEV4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RDcmVhdGUocHJvdG9FeHByZXNzaW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9iamVjdEV4cHJlc3Npb24gPSBjcmVhdGVPYmplY3RMaXRlcmFsKFtdKTtcbiAgICAgICAgZXhwcmVzc2lvbnMudW5zaGlmdChjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbih0ZW1wVmFySWRlbnRpZmllckV4cHJlc3Npb24sIG9iamVjdEV4cHJlc3Npb24pKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0ZW1wVmFySWRlbnRpZmllckV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUNvbW1hRXhwcmVzc2lvbihleHByZXNzaW9ucykpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByb3BlcnR5TmFtZUFzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzQWR2YW5jZWRUcmFuc2Zvcm0pXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBPYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVByb3BlcnR5TmFtZUFzc2lnbm1lbnRcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgaWYgKGlzUHJvdG9OYW1lKHRyZWUubmFtZSkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb3BlcnR5Xyh0cmVlLm5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogdGhpcy50cmFuc2Zvcm1BbnkodHJlZS52YWx1ZSksXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtR2V0QWNjZXNzb3I6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzQWR2YW5jZWRUcmFuc2Zvcm0pXG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBPYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUdldEFjY2Vzc29yXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgdmFyIGZ1bmMgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRW1wdHlQYXJhbWV0ZXJMaXN0KCksIGJvZHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQcm9wZXJ0eV8odHJlZS5uYW1lLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVNldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdGhpcy5uZWVkc0FkdmFuY2VkVHJhbnNmb3JtKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1TZXRBY2Nlc3NvclwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJMaXN0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5wYXJhbWV0ZXJMaXN0KTtcbiAgICAgICAgdmFyIGZ1bmMgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1ldGVyTGlzdCwgYm9keSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb3BlcnR5Xyh0cmVlLm5hbWUsIHtcbiAgICAgICAgICBzZXQ6IGZ1bmMsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWV0aG9kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLmRlYnVnTmFtZSwgdHJlZS5mdW5jdGlvbktpbmQsIHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCksIHRyZWUudHlwZUFubm90YXRpb24sIFtdLCB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmJvZHkpKTtcbiAgICAgICAgaWYgKCF0aGlzLm5lZWRzQWR2YW5jZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvcGVydHlOYW1lQXNzaWdubWVudCh0cmVlLm5hbWUsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvcGVydHlfKHRyZWUubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBmdW5jLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByb3BlcnR5TmFtZVNob3J0aGFuZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoIXRoaXMubmVlZHNBZHZhbmNlZFRyYW5zZm9ybSlcbiAgICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIE9iamVjdExpdGVyYWxUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtUHJvcGVydHlOYW1lU2hvcnRoYW5kXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvcGVydHlfKHRyZWUubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLmlkZW50aWZpZXJUb2tlbiksXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oVGVtcFZhclRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIE9iamVjdExpdGVyYWxUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jld3JpdGVUYWlsRXhwcmVzc2lvbnNUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciAkX18yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQXJndW1lbnRMaXN0ID0gJF9fMi5Bcmd1bWVudExpc3QsXG4gICAgICBCaW5hcnlFeHByZXNzaW9uID0gJF9fMi5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgQ2FsbEV4cHJlc3Npb24gPSAkX18yLkNhbGxFeHByZXNzaW9uLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gJF9fMi5Db25kaXRpb25hbEV4cHJlc3Npb24sXG4gICAgICBNZW1iZXJFeHByZXNzaW9uID0gJF9fMi5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgTWVtYmVyTG9va3VwRXhwcmVzc2lvbiA9ICRfXzIuTWVtYmVyTG9va3VwRXhwcmVzc2lvbjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXJyYXlMaXRlcmFsID0gJF9fMy5jcmVhdGVBcnJheUxpdGVyYWwsXG4gICAgICBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiA9ICRfXzMuY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVDb21tYUV4cHJlc3Npb24gPSAkX18zLmNyZWF0ZUNvbW1hRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX18zLmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBpZCA9ICRfXzMuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVOdWxsTGl0ZXJhbCA9ICRfXzMuY3JlYXRlTnVsbExpdGVyYWwsXG4gICAgICBjcmVhdGVQYXJlbkV4cHJlc3Npb24gPSAkX18zLmNyZWF0ZVBhcmVuRXhwcmVzc2lvbjtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jld3JpdGVUYWlsRXhwcmVzc2lvbnNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBDT01NQV9FWFBSRVNTSU9OID0gJF9fNC5DT01NQV9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0VYUFJFU1NJT04gPSAkX180Lk1FTUJFUl9FWFBSRVNTSU9OLFxuICAgICAgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OID0gJF9fNC5NRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04sXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX180LklERU5USUZJRVJfRVhQUkVTU0lPTixcbiAgICAgIFBBUkVOX0VYUFJFU1NJT04gPSAkX180LlBBUkVOX0VYUFJFU1NJT04sXG4gICAgICBUSElTX0VYUFJFU1NJT04gPSAkX180LlRISVNfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFORCA9ICRfXzUuQU5ELFxuICAgICAgT1IgPSAkX181Lk9SO1xuICBmdW5jdGlvbiBjcmVhdGVDYWxsKHRyZWUsIG9wZXJhbmQsIHRoaXNBcmcsIGltcG9ydFJ1bnRpbWVUcmFuc2Zvcm1lcikge1xuICAgIHZhciBhcmdMaXN0ID0gdHJlZS5hcmdzO1xuICAgIHZhciBhcmdBcnJheSA9IGFyZ0xpc3QgPyBhcmdMaXN0LmFyZ3MgOiBbXTtcbiAgICBhcmdBcnJheSA9IGFyZ0FycmF5Lm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmIChhcmcudHlwZSA9PT0gQ09NTUFfRVhQUkVTU0lPTikge1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGFyZy50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmc7XG4gICAgfSk7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiA9IGltcG9ydFJ1bnRpbWVUcmFuc2Zvcm1lci5nZXRSdW50aW1lRXhwcmVzc2lvbignY29udGludWF0aW9uJyk7XG4gICAgcmV0dXJuIG5ldyBDYWxsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBjb250aW51YXRpb24sIG5ldyBBcmd1bWVudExpc3QoYXJnTGlzdCA/IGFyZ0xpc3QubG9jYXRpb24gOiBudWxsLCBbb3BlcmFuZCwgdGhpc0FyZywgY3JlYXRlQXJyYXlMaXRlcmFsKGFyZ0FycmF5KV0pKTtcbiAgfVxuICB2YXIgUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBSZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIoYm9keVRyYW5zZm9ybWVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihSZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmJvZHlUcmFuc2Zvcm1lcl8gPSBib2R5VHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdHJlZS5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG9wZXJhdG9yLnR5cGUgIT09IEFORCAmJiBvcGVyYXRvci50eXBlICE9PSBPUikge1xuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICBpZiAocmlnaHQgIT09IHRyZWUucmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5sZWZ0LCBvcGVyYXRvciwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUNhbGxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdHJlZS5vcGVyYW5kO1xuICAgICAgICB3aGlsZSAob3BlcmFuZC50eXBlID09PSBQQVJFTl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgb3BlcmFuZCA9IG9wZXJhbmQuZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhbmQudHlwZSkge1xuICAgICAgICAgIGNhc2UgSURFTlRJRklFUl9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGwodHJlZSwgb3BlcmFuZCwgY3JlYXRlTnVsbExpdGVyYWwoKSwgdGhpcy5ib2R5VHJhbnNmb3JtZXJfKTtcbiAgICAgICAgICBjYXNlIE1FTUJFUl9FWFBSRVNTSU9OOlxuICAgICAgICAgIGNhc2UgTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVtYmVyRXhwcmVzc2lvbkNhbGxfKHRyZWUsIG9wZXJhbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlckV4cHJlc3Npb25DYWxsXzogZnVuY3Rpb24odHJlZSwgb3BlcmFuZCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gb3BlcmFuZC5vcGVyYW5kO1xuICAgICAgICB2YXIgdGhpc0FyZztcbiAgICAgICAgdmFyIGFzc2lnbm1lbnQ7XG4gICAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OIHx8IG9iamVjdC50eXBlID09PSBUSElTX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICB0aGlzQXJnID0gb2JqZWN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNBcmcgPSBpZCh0aGlzLmJvZHlUcmFuc2Zvcm1lcl8uYWRkVGVtcFZhcigpKTtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odGhpc0FyZywgb3BlcmFuZC5vcGVyYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlcmFuZC50eXBlID09PSBNRU1CRVJfRVhQUkVTU0lPTikge1xuICAgICAgICAgIG9wZXJhbmQgPSBuZXcgTWVtYmVyRXhwcmVzc2lvbihvcGVyYW5kLmxvY2F0aW9uLCB0aGlzQXJnLCBvcGVyYW5kLm1lbWJlck5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhbmQgPSBuZXcgTWVtYmVyTG9va3VwRXhwcmVzc2lvbihvcGVyYW5kLmxvY2F0aW9uLCB0aGlzQXJnLCBvcGVyYW5kLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihjcmVhdGVDb21tYUV4cHJlc3Npb24oW2Fzc2lnbm1lbnQsIGNyZWF0ZUNhbGwodHJlZSwgb3BlcmFuZCwgdGhpc0FyZywgdGhpcy5ib2R5VHJhbnNmb3JtZXJfKV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FsbCh0cmVlLCBvcGVyYW5kLCB0aGlzQXJnLCB0aGlzLmJvZHlUcmFuc2Zvcm1lcl8pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29tbWFFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRyZWUuZXhwcmVzc2lvbnM7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbZXhwcmVzc2lvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZEV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueShleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IHRyYW5zZm9ybWVkRXhwcmVzc2lvbikge1xuICAgICAgICAgIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godHJhbnNmb3JtZWRFeHByZXNzaW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbW1hRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBleHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5sZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5yaWdodCk7XG4gICAgICAgIGlmIChsZWZ0ICE9PSB0cmVlLmxlZnQgfHwgcmlnaHQgIT09IHRyZWUucmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLmNvbmRpdGlvbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdCA9IHRoaXMuYm9keVRyYW5zZm9ybWVyXy5nZXRSdW50aW1lRXhwcmVzc2lvbignY29uc3RydWN0Jyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDYWxsKHRyZWUsIGNvbnN0cnVjdCwgdHJlZS5vcGVyYW5kLCB0aGlzLmJvZHlUcmFuc2Zvcm1lcl8pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUFycmF5TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BcnJvd0Z1bmN0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JZGVudGlmaWVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1MaXRlcmFsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1NZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlckxvb2t1cEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtUG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtT2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1VbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9XG4gICAgfSwge3RyYW5zZm9ybTogZnVuY3Rpb24oYm9keVRyYW5zZm9ybWVyLCB0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyKGJvZHlUcmFuc2Zvcm1lcikudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgfX0sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IFJld3JpdGVUYWlsRXhwcmVzc2lvbnNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBSZXdyaXRlVGFpbEV4cHJlc3Npb25zVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmV3cml0ZVRhaWxDYWxsc1RyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmV3cml0ZVRhaWxDYWxsc1RyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIuanNcIikpLlJld3JpdGVUYWlsRXhwcmVzc2lvbnNUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jld3JpdGVUYWlsQ2FsbHNUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBSZXR1cm5TdGF0ZW1lbnQgPSAkX18zLlJldHVyblN0YXRlbWVudCxcbiAgICAgIFRyeVN0YXRlbWVudCA9ICRfXzMuVHJ5U3RhdGVtZW50O1xuICB2YXIgU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ta2lwRnVuY3Rpb25zVHJhbnNmb3JtZXJUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmV3cml0ZVRhaWxDYWxsc1RyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgUmV3cml0ZVRhaWxDYWxsc1RyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBSZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIoYm9keVRyYW5zZm9ybWVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihSZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmJvZHlUcmFuc2Zvcm1lcl8gPSBib2R5VHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybVJldHVyblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRyZWUuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gUmV3cml0ZVRhaWxFeHByZXNzaW9uc1RyYW5zZm9ybWVyLnRyYW5zZm9ybSh0aGlzLmJvZHlUcmFuc2Zvcm1lcl8sIGV4cHJlc3Npb24pO1xuICAgICAgICAgIGlmIChleHByZXNzaW9uICE9PSB0cmVlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIGV4cHJlc3Npb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UcnlTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGJsb2NrO1xuICAgICAgICBpZiAodHJlZS5maW5hbGx5QmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgICBibG9jayA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuZmluYWxseUJsb2NrKTtcbiAgICAgICAgICBpZiAoYmxvY2sgIT09IHRyZWUuZmluYWxseUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyeVN0YXRlbWVudCh0cmVlLmxvY2F0aW9uLCB0cmVlLmJvZHksIHRyZWUuY2F0Y2hCbG9jaywgYmxvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuY2F0Y2hCbG9jayk7XG4gICAgICAgICAgaWYgKGJsb2NrICE9PSB0cmVlLmNhdGNoQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJ5U3RhdGVtZW50KHRyZWUubG9jYXRpb24sIHRyZWUuYm9keSwgYmxvY2ssIHRyZWUuZmluYWxseUJsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9ySW5TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRm9yT25TdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db21wcmVoZW5zaW9uRm9yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVZhcmlhYmxlU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfVxuICAgIH0sIHt0cmFuc2Zvcm06IGZ1bmN0aW9uKGJvZHlUcmFuc2Zvcm1lciwgdHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJld3JpdGVUYWlsQ2FsbHNUcmFuc2Zvcm1lcihib2R5VHJhbnNmb3JtZXIpLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgIH19LCAkX19zdXBlcik7XG4gIH0oU2tpcEZ1bmN0aW9uc1RyYW5zZm9ybWVyVHJhaXQoUGFyc2VUcmVlVHJhbnNmb3JtZXIpKTtcbiAgcmV0dXJuIHtnZXQgUmV3cml0ZVRhaWxDYWxsc1RyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFJld3JpdGVUYWlsQ2FsbHNUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Qcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHJvcGVyVGFpbENhbGxUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Qcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciBSZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9SZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Byb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIuanNcIikpLlJld3JpdGVUYWlsQ2FsbHNUcmFuc2Zvcm1lcjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Qcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uQm9keSA9ICRfXzMuY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fMy5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBpZCA9ICRfXzMuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb247XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Byb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgcGFyc2VFeHByZXNzaW9uID0gJF9fNC5wYXJzZUV4cHJlc3Npb24sXG4gICAgICBwYXJzZVN0YXRlbWVudCA9ICRfXzQucGFyc2VTdGF0ZW1lbnQsXG4gICAgICBwYXJzZVN0YXRlbWVudHMgPSAkX180LnBhcnNlU3RhdGVtZW50cztcbiAgdmFyICRfXzUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Byb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQW5vbkJsb2NrID0gJF9fNS5Bbm9uQmxvY2ssXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uID0gJF9fNS5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNS5GdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhciBJbXBvcnRSdW50aW1lVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbXBvcnRSdW50aW1lVHJhaXQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Byb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciBQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaW5CbG9ja18gPSBmYWxzZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHRyZWUgPSAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgUHJvcGVyVGFpbENhbGxUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRnVuY3Rpb25EZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICBpZiAodHJlZS5mdW5jdGlvbktpbmQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZUlkRXhwcmVzc2lvbiA9IGlkKHRyZWUubmFtZS5pZGVudGlmaWVyVG9rZW4pO1xuICAgICAgICB2YXIgaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbiA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ2luaXRUYWlsUmVjdXJzaXZlRnVuY3Rpb24nKTtcbiAgICAgICAgdmFyIHNldHVwRmxhZ0V4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIihcIiwgXCIpXCJdKSwgaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbiwgbmFtZUlkRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBmdW5jRGVjbCA9IHRoaXMudHJhbnNmb3JtRnVuY3Rpb25fKHRyZWUsIEZ1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgICBpZiAoZnVuY0RlY2wgPT09IHRyZWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG1wVmFyID0gaWQodGhpcy5pbkJsb2NrXyA/IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSA6IHRoaXMuYWRkVGVtcFZhcihzZXR1cEZsYWdFeHByZXNzaW9uKSk7XG4gICAgICAgIGlmICghdGhpcy5pbkJsb2NrXykge1xuICAgICAgICAgIHJldHVybiBmdW5jRGVjbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBbZnVuY0RlY2wsIHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJ2YXIgXCIsIFwiID0gXCIsIFwiO1wiXSksIHRtcFZhciwgc2V0dXBGbGFnRXhwcmVzc2lvbildKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdHJlZSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgICAgaWYgKHRyZWUuZnVuY3Rpb25LaW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmN0aW9uRXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtRnVuY3Rpb25fKHRyZWUsIEZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChmdW5jdGlvbkV4cHJlc3Npb24gPT09IHRyZWUpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdFRhaWxSZWN1cnNpdmVGdW5jdGlvbiA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ2luaXRUYWlsUmVjdXJzaXZlRnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCBpbml0VGFpbFJlY3Vyc2l2ZUZ1bmN0aW9uLCBmdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uXzogZnVuY3Rpb24odHJlZSwgY29uc3RydWN0b3IpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBSZXdyaXRlVGFpbENhbGxzVHJhbnNmb3JtZXIudHJhbnNmb3JtKHRoaXMsIHRyZWUuYm9keSk7XG4gICAgICAgIGlmIChib2R5ID09PSB0cmVlLmJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9IGlkKHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgICAgIHZhciBpbm5lckZ1bmN0aW9uID0gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHRyZWUucGFyYW1ldGVyTGlzdCwgYm9keSk7XG4gICAgICAgIHZhciBjYWxsID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignY2FsbCcpO1xuICAgICAgICB2YXIgb3V0ZXJCb2R5ID0gY3JlYXRlRnVuY3Rpb25Cb2R5KHBhcnNlU3RhdGVtZW50cygkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICByZXR1cm4gXCIsIFwiKFwiLCBcIiwgdGhpcywgYXJndW1lbnRzKTtcIl0pLCBjYWxsLCBpbm5lckZ1bmN0aW9uKSk7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IodHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lLCB0cmVlLmZ1bmN0aW9uS2luZCwgdHJlZS5wYXJhbWV0ZXJMaXN0LCB0cmVlLnR5cGVBbm5vdGF0aW9uLCB0cmVlLmFubm90YXRpb25zLCBvdXRlckJvZHkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJsb2NrOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbkJsb2NrID0gdGhpcy5pbkJsb2NrXztcbiAgICAgICAgdGhpcy5pbkJsb2NrXyA9IHRydWU7XG4gICAgICAgIHZhciBydiA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1CbG9ja1wiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLmluQmxvY2tfID0gaW5CbG9jaztcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSW1wb3J0UnVudGltZVRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpO1xuICByZXR1cm4ge2dldCBQcm9wZXJUYWlsQ2FsbFRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFByb3BlclRhaWxDYWxsVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHJvcGVydHlOYW1lU2hvcnRoYW5kVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Qcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgJF9fMSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHJvcGVydHlOYW1lU2hvcnRoYW5kVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18xLklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgTGl0ZXJhbFByb3BlcnR5TmFtZSA9ICRfXzEuTGl0ZXJhbFByb3BlcnR5TmFtZSxcbiAgICAgIFByb3BlcnR5TmFtZUFzc2lnbm1lbnQgPSAkX18xLlByb3BlcnR5TmFtZUFzc2lnbm1lbnQ7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Qcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBQcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUHJvcGVydHlOYW1lU2hvcnRoYW5kVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFByb3BlcnR5TmFtZVNob3J0aGFuZFRyYW5zZm9ybWVyLCB7dHJhbnNmb3JtUHJvcGVydHlOYW1lU2hvcnRoYW5kOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlOYW1lQXNzaWdubWVudCh0cmVlLmxvY2F0aW9uLCBuZXcgTGl0ZXJhbFByb3BlcnR5TmFtZSh0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUpLCBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lKSk7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IFByb3BlcnR5TmFtZVNob3J0aGFuZFRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFByb3BlcnR5TmFtZVNob3J0aGFuZFRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL291dHB1dGdlbmVyYXRpb24vcmVnZXhwdVJld3JpdGVQYXR0ZXJuLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvb3V0cHV0Z2VuZXJhdGlvbi9yZWdleHB1UmV3cml0ZVBhdHRlcm4uanNcIjtcbiAgdmFyIG1vZHVsZXMgPSB7fTtcbiAgdmFyIG1vZHVsZSA9IHt9O1xuICB2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG4gIHZhciByZXF1aXJlID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gbW9kdWxlc1tpZF07XG4gIH07XG4gIDtcbiAgKGZ1bmN0aW9uKHJvb3QpIHtcbiAgICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuICAgIHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuICAgIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG4gICAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG4gICAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgICB9XG4gICAgdmFyIEVSUk9SUyA9IHtcbiAgICAgICdyYW5nZU9yZGVyJzogJ0EgcmFuZ2VcXHUyMDE5cyBgc3RvcGAgdmFsdWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgJyArICd0byB0aGUgYHN0YXJ0YCB2YWx1ZS4nLFxuICAgICAgJ2NvZGVQb2ludFJhbmdlJzogJ0ludmFsaWQgY29kZSBwb2ludCB2YWx1ZS4gQ29kZSBwb2ludHMgcmFuZ2UgZnJvbSAnICsgJ1UrMDAwMDAwIHRvIFUrMTBGRkZGLidcbiAgICB9O1xuICAgIHZhciBISUdIX1NVUlJPR0FURV9NSU4gPSAweEQ4MDA7XG4gICAgdmFyIEhJR0hfU1VSUk9HQVRFX01BWCA9IDB4REJGRjtcbiAgICB2YXIgTE9XX1NVUlJPR0FURV9NSU4gPSAweERDMDA7XG4gICAgdmFyIExPV19TVVJST0dBVEVfTUFYID0gMHhERkZGO1xuICAgIHZhciByZWdleE51bGwgPSAvXFxcXHgwMChbXjAxMjM0NTY3ODldfCQpL2c7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9O1xuICAgIHZhciBmb3JFYWNoID0gZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdC50b1N0cmluZztcbiAgICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICAgIHZhciBpc051bWJlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE51bWJlcl0nO1xuICAgIH07XG4gICAgdmFyIHplcm9lcyA9ICcwMDAwJztcbiAgICB2YXIgcGFkID0gZnVuY3Rpb24obnVtYmVyLCB0b3RhbENoYXJhY3RlcnMpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcobnVtYmVyKTtcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoIDwgdG90YWxDaGFyYWN0ZXJzID8gKHplcm9lcyArIHN0cmluZykuc2xpY2UoLXRvdGFsQ2hhcmFjdGVycykgOiBzdHJpbmc7XG4gICAgfTtcbiAgICB2YXIgaGV4ID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG51bWJlcikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcbiAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcbiAgICB2YXIgZGF0YUZyb21Db2RlUG9pbnRzID0gZnVuY3Rpb24oY29kZVBvaW50cykge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICB2YXIgbWF4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpc1N0YXJ0ID0gdHJ1ZTtcbiAgICAgIHZhciB0bXA7XG4gICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdG1wID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godG1wKTtcbiAgICAgICAgICBwcmV2aW91cyA9IHRtcDtcbiAgICAgICAgICBpc1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRtcCA9PSBwcmV2aW91cyArIDEpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSBtYXgpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXMgPSB0bXA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwcmV2aW91cyArIDEsIHRtcCk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTdGFydCkge1xuICAgICAgICByZXN1bHQucHVzaCh0bXAgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB2YXIgZGF0YVJlbW92ZSA9IGZ1bmN0aW9uKGRhdGEsIGNvZGVQb2ludCkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IHN0YXJ0ICYmIGNvZGVQb2ludCA8IGVuZCkge1xuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPT0gc3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IGNvZGVQb2ludCArIDE7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID09IGVuZCAtIDEpIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGNvZGVQb2ludDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMiwgc3RhcnQsIGNvZGVQb2ludCwgY29kZVBvaW50ICsgMSwgZW5kKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCArPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICB2YXIgZGF0YVJlbW92ZVJhbmdlID0gZnVuY3Rpb24oZGF0YSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpIHtcbiAgICAgIGlmIChyYW5nZUVuZCA8IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoRVJST1JTLnJhbmdlT3JkZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB3aGlsZSAoaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV0gLSAxO1xuICAgICAgICBpZiAoc3RhcnQgPiByYW5nZUVuZCkge1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlRW5kID49IGVuZCkge1xuICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2VTdGFydCA+PSBzdGFydCAmJiByYW5nZUVuZCA8IGVuZCkge1xuICAgICAgICAgIGlmIChyYW5nZVN0YXJ0ID09IHN0YXJ0KSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGVuZCArIDE7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDIsIHN0YXJ0LCByYW5nZVN0YXJ0LCByYW5nZUVuZCArIDEsIGVuZCArIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0ID49IHN0YXJ0ICYmIHJhbmdlU3RhcnQgPD0gZW5kKSB7XG4gICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gcmFuZ2VTdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZUVuZCA+PSBzdGFydCAmJiByYW5nZUVuZCA8PSBlbmQpIHtcbiAgICAgICAgICBkYXRhW2luZGV4XSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCArPSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICB2YXIgZGF0YUFkZCA9IGZ1bmN0aW9uKGRhdGEsIGNvZGVQb2ludCkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDAgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihFUlJPUlMuY29kZVBvaW50UmFuZ2UpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgIGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSBzdGFydCAmJiBjb2RlUG9pbnQgPCBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50ID09IHN0YXJ0IC0gMSkge1xuICAgICAgICAgIGRhdGFbaW5kZXhdID0gY29kZVBvaW50O1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA+IGNvZGVQb2ludCkge1xuICAgICAgICAgIGRhdGEuc3BsaWNlKGxhc3RJbmRleCAhPSBudWxsID8gbGFzdEluZGV4ICsgMiA6IDAsIDAsIGNvZGVQb2ludCwgY29kZVBvaW50ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA9PSBlbmQpIHtcbiAgICAgICAgICBpZiAoY29kZVBvaW50ICsgMSA9PSBkYXRhW2luZGV4ICsgMl0pIHtcbiAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCA0LCBzdGFydCwgZGF0YVtpbmRleCArIDNdKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBjb2RlUG9pbnQgKyAxO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICBpbmRleCArPSAyO1xuICAgICAgfVxuICAgICAgZGF0YS5wdXNoKGNvZGVQb2ludCwgY29kZVBvaW50ICsgMSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHZhciBkYXRhQWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFBLnNsaWNlKCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YUIubGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0YUJbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhQltpbmRleCArIDFdIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgIGRhdGEgPSBkYXRhQWRkKGRhdGEsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZGF0YUFkZFJhbmdlKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHZhciBkYXRhUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uKGRhdGFBLCBkYXRhQikge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFBLnNsaWNlKCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YUIubGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0YUJbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhQltpbmRleCArIDFdIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgIGRhdGEgPSBkYXRhUmVtb3ZlKGRhdGEsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZGF0YVJlbW92ZVJhbmdlKGRhdGEsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHZhciBkYXRhQWRkUmFuZ2UgPSBmdW5jdGlvbihkYXRhLCByYW5nZVN0YXJ0LCByYW5nZUVuZCkge1xuICAgICAgaWYgKHJhbmdlRW5kIDwgcmFuZ2VTdGFydCkge1xuICAgICAgICB0aHJvdyBFcnJvcihFUlJPUlMucmFuZ2VPcmRlcik7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VTdGFydCA8IDB4MCB8fCByYW5nZVN0YXJ0ID4gMHgxMEZGRkYgfHwgcmFuZ2VFbmQgPCAweDAgfHwgcmFuZ2VFbmQgPiAweDEwRkZGRikge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKEVSUk9SUy5jb2RlUG9pbnRSYW5nZSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGVuZDtcbiAgICAgIHZhciBhZGRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgIGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09IHJhbmdlRW5kICsgMSkge1xuICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXggLSAxLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnQgPiByYW5nZUVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCA+PSByYW5nZVN0YXJ0ICYmIHN0YXJ0IDw9IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gcmFuZ2VTdGFydCAmJiBlbmQgLSAxIDw9IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAyKTtcbiAgICAgICAgICAgICAgaW5kZXggLT0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4IC0gMSwgMik7XG4gICAgICAgICAgICAgIGluZGV4IC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0ID09IHJhbmdlRW5kICsgMSkge1xuICAgICAgICAgIGRhdGFbaW5kZXhdID0gcmFuZ2VTdGFydDtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+IHJhbmdlRW5kKSB7XG4gICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDAsIHJhbmdlU3RhcnQsIHJhbmdlRW5kICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2VTdGFydCA+PSBzdGFydCAmJiByYW5nZVN0YXJ0IDwgZW5kICYmIHJhbmdlRW5kICsgMSA8PSBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmICgocmFuZ2VTdGFydCA+PSBzdGFydCAmJiByYW5nZVN0YXJ0IDwgZW5kKSB8fCBlbmQgPT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2VTdGFydCA8PSBzdGFydCAmJiByYW5nZUVuZCArIDEgPj0gZW5kKSB7XG4gICAgICAgICAgZGF0YVtpbmRleF0gPSByYW5nZVN0YXJ0O1xuICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IHJhbmdlRW5kICsgMTtcbiAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cbiAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgZGF0YS5wdXNoKHJhbmdlU3RhcnQsIHJhbmdlRW5kICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHZhciBkYXRhQ29udGFpbnMgPSBmdW5jdGlvbihkYXRhLCBjb2RlUG9pbnQpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQgPSBkYXRhW2luZGV4XTtcbiAgICAgIHZhciBlbmQgPSBkYXRhW2xlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCBzdGFydCB8fCBjb2RlUG9pbnQgPiBlbmQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gc3RhcnQgJiYgY29kZVBvaW50IDwgZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHZhciBkYXRhSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oZGF0YSwgY29kZVBvaW50cykge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgIGlmIChkYXRhQ29udGFpbnMoZGF0YSwgY29kZVBvaW50KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgKytpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhRnJvbUNvZGVQb2ludHMocmVzdWx0KTtcbiAgICB9O1xuICAgIHZhciBkYXRhSXNFbXB0eSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiAhZGF0YS5sZW5ndGg7XG4gICAgfTtcbiAgICB2YXIgZGF0YUlzU2luZ2xldG9uID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID09IDIgJiYgZGF0YVswXSArIDEgPT0gZGF0YVsxXTtcbiAgICB9O1xuICAgIHZhciBkYXRhVG9BcnJheSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgc3RhcnQ7XG4gICAgICB2YXIgZW5kO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0YVtpbmRleF07XG4gICAgICAgIGVuZCA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhcnQpO1xuICAgICAgICAgICsrc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBoaWdoU3Vycm9nYXRlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoZmxvb3IoKGNvZGVQb2ludCAtIDB4MTAwMDApIC8gMHg0MDApICsgSElHSF9TVVJST0dBVEVfTUlOLCAxMCk7XG4gICAgfTtcbiAgICB2YXIgbG93U3Vycm9nYXRlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoKGNvZGVQb2ludCAtIDB4MTAwMDApICUgMHg0MDAgKyBMT1dfU1VSUk9HQVRFX01JTiwgMTApO1xuICAgIH07XG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGNvZGVQb2ludFRvU3RyaW5nID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG4gICAgICB2YXIgc3RyaW5nO1xuICAgICAgaWYgKGNvZGVQb2ludCA9PSAweDA5KSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxcdCc7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBBKSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxcbic7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBDKSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxcZic7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDBEKSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxccic7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDVDKSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxcXFxcXCc7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA9PSAweDI0IHx8IChjb2RlUG9pbnQgPj0gMHgyOCAmJiBjb2RlUG9pbnQgPD0gMHgyQikgfHwgY29kZVBvaW50ID09IDB4MkQgfHwgY29kZVBvaW50ID09IDB4MkUgfHwgY29kZVBvaW50ID09IDB4M0YgfHwgKGNvZGVQb2ludCA+PSAweDVCICYmIGNvZGVQb2ludCA8PSAweDVFKSB8fCAoY29kZVBvaW50ID49IDB4N0IgJiYgY29kZVBvaW50IDw9IDB4N0QpKSB7XG4gICAgICAgIHN0cmluZyA9ICdcXFxcJyArIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPj0gMHgyMCAmJiBjb2RlUG9pbnQgPD0gMHg3RSkge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4RkYpIHtcbiAgICAgICAgc3RyaW5nID0gJ1xcXFx4JyArIHBhZChoZXgoY29kZVBvaW50KSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcgPSAnXFxcXHUnICsgcGFkKGhleChjb2RlUG9pbnQpLCA0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcbiAgICB2YXIgc3ltYm9sVG9Db2RlUG9pbnQgPSBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgIHZhciBsZW5ndGggPSBzeW1ib2wubGVuZ3RoO1xuICAgICAgdmFyIGZpcnN0ID0gc3ltYm9sLmNoYXJDb2RlQXQoMCk7XG4gICAgICB2YXIgc2Vjb25kO1xuICAgICAgaWYgKGZpcnN0ID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBmaXJzdCA8PSBISUdIX1NVUlJPR0FURV9NQVggJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICBzZWNvbmQgPSBzeW1ib2wuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgcmV0dXJuIChmaXJzdCAtIEhJR0hfU1VSUk9HQVRFX01JTikgKiAweDQwMCArIHNlY29uZCAtIExPV19TVVJST0dBVEVfTUlOICsgMHgxMDAwMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBpZiAoZGF0YUlzU2luZ2xldG9uKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyhkYXRhWzBdKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV0gLSAxO1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCArIDEgPT0gZW5kKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXJ0KSArIGNvZGVQb2ludFRvU3RyaW5nKGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXJ0KSArICctJyArIGNvZGVQb2ludFRvU3RyaW5nKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnWycgKyByZXN1bHQgKyAnXSc7XG4gICAgfTtcbiAgICB2YXIgc3BsaXRBdEJNUCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBsb25lSGlnaFN1cnJvZ2F0ZXMgPSBbXTtcbiAgICAgIHZhciBsb25lTG93U3Vycm9nYXRlcyA9IFtdO1xuICAgICAgdmFyIGJtcCA9IFtdO1xuICAgICAgdmFyIGFzdHJhbCA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBlbmQ7XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgc3RhcnQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgZW5kID0gZGF0YVtpbmRleCArIDFdIC0gMTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgSElHSF9TVVJST0dBVEVfTUlOKSB7XG4gICAgICAgICAgaWYgKGVuZCA8IEhJR0hfU1VSUk9HQVRFX01JTikge1xuICAgICAgICAgICAgYm1wLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID49IEhJR0hfU1VSUk9HQVRFX01JTiAmJiBlbmQgPD0gSElHSF9TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICBibXAucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUlOKTtcbiAgICAgICAgICAgIGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKEhJR0hfU1VSUk9HQVRFX01JTiwgZW5kICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICBibXAucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUlOKTtcbiAgICAgICAgICAgIGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKEhJR0hfU1VSUk9HQVRFX01JTiwgSElHSF9TVVJST0dBVEVfTUFYICsgMSk7XG4gICAgICAgICAgICBsb25lTG93U3Vycm9nYXRlcy5wdXNoKExPV19TVVJST0dBVEVfTUlOLCBlbmQgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZCA+IExPV19TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgICBibXAucHVzaChzdGFydCwgSElHSF9TVVJST0dBVEVfTUlOKTtcbiAgICAgICAgICAgIGxvbmVIaWdoU3Vycm9nYXRlcy5wdXNoKEhJR0hfU1VSUk9HQVRFX01JTiwgSElHSF9TVVJST0dBVEVfTUFYICsgMSk7XG4gICAgICAgICAgICBsb25lTG93U3Vycm9nYXRlcy5wdXNoKExPV19TVVJST0dBVEVfTUlOLCBMT1dfU1VSUk9HQVRFX01BWCArIDEpO1xuICAgICAgICAgICAgaWYgKGVuZCA8PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgYm1wLnB1c2goTE9XX1NVUlJPR0FURV9NQVggKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgMHhGRkZGICsgMSk7XG4gICAgICAgICAgICAgIGFzdHJhbC5wdXNoKDB4RkZGRiArIDEsIGVuZCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGFydCA+PSBISUdIX1NVUlJPR0FURV9NSU4gJiYgc3RhcnQgPD0gSElHSF9TVVJST0dBVEVfTUFYKSB7XG4gICAgICAgICAgaWYgKGVuZCA+PSBISUdIX1NVUlJPR0FURV9NSU4gJiYgZW5kIDw9IEhJR0hfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgbG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID49IExPV19TVVJST0dBVEVfTUlOICYmIGVuZCA8PSBMT1dfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgbG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goc3RhcnQsIEhJR0hfU1VSUk9HQVRFX01BWCArIDEpO1xuICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChMT1dfU1VSUk9HQVRFX01JTiwgZW5kICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPiBMT1dfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgbG9uZUhpZ2hTdXJyb2dhdGVzLnB1c2goc3RhcnQsIEhJR0hfU1VSUk9HQVRFX01BWCArIDEpO1xuICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChMT1dfU1VSUk9HQVRFX01JTiwgTE9XX1NVUlJPR0FURV9NQVggKyAxKTtcbiAgICAgICAgICAgIGlmIChlbmQgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgZW5kICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBibXAucHVzaChMT1dfU1VSUk9HQVRFX01BWCArIDEsIDB4RkZGRiArIDEpO1xuICAgICAgICAgICAgICBhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPj0gTE9XX1NVUlJPR0FURV9NSU4gJiYgc3RhcnQgPD0gTE9XX1NVUlJPR0FURV9NQVgpIHtcbiAgICAgICAgICBpZiAoZW5kID49IExPV19TVVJST0dBVEVfTUlOICYmIGVuZCA8PSBMT1dfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPiBMT1dfU1VSUk9HQVRFX01BWCkge1xuICAgICAgICAgICAgbG9uZUxvd1N1cnJvZ2F0ZXMucHVzaChzdGFydCwgTE9XX1NVUlJPR0FURV9NQVggKyAxKTtcbiAgICAgICAgICAgIGlmIChlbmQgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgIGJtcC5wdXNoKExPV19TVVJST0dBVEVfTUFYICsgMSwgZW5kICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBibXAucHVzaChMT1dfU1VSUk9HQVRFX01BWCArIDEsIDB4RkZGRiArIDEpO1xuICAgICAgICAgICAgICBhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBMT1dfU1VSUk9HQVRFX01BWCAmJiBzdGFydCA8PSAweEZGRkYpIHtcbiAgICAgICAgICBpZiAoZW5kIDw9IDB4RkZGRikge1xuICAgICAgICAgICAgYm1wLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibXAucHVzaChzdGFydCwgMHhGRkZGICsgMSk7XG4gICAgICAgICAgICBhc3RyYWwucHVzaCgweEZGRkYgKyAxLCBlbmQgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXN0cmFsLnB1c2goc3RhcnQsIGVuZCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbG9uZUhpZ2hTdXJyb2dhdGVzJzogbG9uZUhpZ2hTdXJyb2dhdGVzLFxuICAgICAgICAnbG9uZUxvd1N1cnJvZ2F0ZXMnOiBsb25lTG93U3Vycm9nYXRlcyxcbiAgICAgICAgJ2JtcCc6IGJtcCxcbiAgICAgICAgJ2FzdHJhbCc6IGFzdHJhbFxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBvcHRpbWl6ZVN1cnJvZ2F0ZU1hcHBpbmdzID0gZnVuY3Rpb24oc3Vycm9nYXRlTWFwcGluZ3MpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB0bXBMb3cgPSBbXTtcbiAgICAgIHZhciBhZGRMb3cgPSBmYWxzZTtcbiAgICAgIHZhciBtYXBwaW5nO1xuICAgICAgdmFyIG5leHRNYXBwaW5nO1xuICAgICAgdmFyIGhpZ2hTdXJyb2dhdGVzO1xuICAgICAgdmFyIGxvd1N1cnJvZ2F0ZXM7XG4gICAgICB2YXIgbmV4dEhpZ2hTdXJyb2dhdGVzO1xuICAgICAgdmFyIG5leHRMb3dTdXJyb2dhdGVzO1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgbWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4XTtcbiAgICAgICAgbmV4dE1hcHBpbmcgPSBzdXJyb2dhdGVNYXBwaW5nc1tpbmRleCArIDFdO1xuICAgICAgICBpZiAoIW5leHRNYXBwaW5nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaFN1cnJvZ2F0ZXMgPSBtYXBwaW5nWzBdO1xuICAgICAgICBsb3dTdXJyb2dhdGVzID0gbWFwcGluZ1sxXTtcbiAgICAgICAgbmV4dEhpZ2hTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmdbMF07XG4gICAgICAgIG5leHRMb3dTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmdbMV07XG4gICAgICAgIHRtcExvdyA9IGxvd1N1cnJvZ2F0ZXM7XG4gICAgICAgIHdoaWxlIChuZXh0SGlnaFN1cnJvZ2F0ZXMgJiYgaGlnaFN1cnJvZ2F0ZXNbMF0gPT0gbmV4dEhpZ2hTdXJyb2dhdGVzWzBdICYmIGhpZ2hTdXJyb2dhdGVzWzFdID09IG5leHRIaWdoU3Vycm9nYXRlc1sxXSkge1xuICAgICAgICAgIGlmIChkYXRhSXNTaW5nbGV0b24obmV4dExvd1N1cnJvZ2F0ZXMpKSB7XG4gICAgICAgICAgICB0bXBMb3cgPSBkYXRhQWRkKHRtcExvdywgbmV4dExvd1N1cnJvZ2F0ZXNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBMb3cgPSBkYXRhQWRkUmFuZ2UodG1wTG93LCBuZXh0TG93U3Vycm9nYXRlc1swXSwgbmV4dExvd1N1cnJvZ2F0ZXNbMV0gLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBtYXBwaW5nID0gc3Vycm9nYXRlTWFwcGluZ3NbaW5kZXhdO1xuICAgICAgICAgIGhpZ2hTdXJyb2dhdGVzID0gbWFwcGluZ1swXTtcbiAgICAgICAgICBsb3dTdXJyb2dhdGVzID0gbWFwcGluZ1sxXTtcbiAgICAgICAgICBuZXh0TWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4ICsgMV07XG4gICAgICAgICAgbmV4dEhpZ2hTdXJyb2dhdGVzID0gbmV4dE1hcHBpbmcgJiYgbmV4dE1hcHBpbmdbMF07XG4gICAgICAgICAgbmV4dExvd1N1cnJvZ2F0ZXMgPSBuZXh0TWFwcGluZyAmJiBuZXh0TWFwcGluZ1sxXTtcbiAgICAgICAgICBhZGRMb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKFtoaWdoU3Vycm9nYXRlcywgYWRkTG93ID8gdG1wTG93IDogbG93U3Vycm9nYXRlc10pO1xuICAgICAgICBhZGRMb3cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpbWl6ZUJ5TG93U3Vycm9nYXRlcyhyZXN1bHQpO1xuICAgIH07XG4gICAgdmFyIG9wdGltaXplQnlMb3dTdXJyb2dhdGVzID0gZnVuY3Rpb24oc3Vycm9nYXRlTWFwcGluZ3MpIHtcbiAgICAgIGlmIChzdXJyb2dhdGVNYXBwaW5ncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gc3Vycm9nYXRlTWFwcGluZ3M7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBpbm5lckluZGV4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHN1cnJvZ2F0ZU1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2luZGV4XTtcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZXMgPSBtYXBwaW5nWzFdO1xuICAgICAgICB2YXIgbG93U3Vycm9nYXRlU3RhcnQgPSBsb3dTdXJyb2dhdGVzWzBdO1xuICAgICAgICB2YXIgbG93U3Vycm9nYXRlRW5kID0gbG93U3Vycm9nYXRlc1sxXTtcbiAgICAgICAgaW5uZXJJbmRleCA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoKytpbm5lckluZGV4IDwgc3Vycm9nYXRlTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG90aGVyTWFwcGluZyA9IHN1cnJvZ2F0ZU1hcHBpbmdzW2lubmVySW5kZXhdO1xuICAgICAgICAgIHZhciBvdGhlckxvd1N1cnJvZ2F0ZXMgPSBvdGhlck1hcHBpbmdbMV07XG4gICAgICAgICAgdmFyIG90aGVyTG93U3Vycm9nYXRlU3RhcnQgPSBvdGhlckxvd1N1cnJvZ2F0ZXNbMF07XG4gICAgICAgICAgdmFyIG90aGVyTG93U3Vycm9nYXRlRW5kID0gb3RoZXJMb3dTdXJyb2dhdGVzWzFdO1xuICAgICAgICAgIGlmIChsb3dTdXJyb2dhdGVTdGFydCA9PSBvdGhlckxvd1N1cnJvZ2F0ZVN0YXJ0ICYmIGxvd1N1cnJvZ2F0ZUVuZCA9PSBvdGhlckxvd1N1cnJvZ2F0ZUVuZCkge1xuICAgICAgICAgICAgaWYgKGRhdGFJc1NpbmdsZXRvbihvdGhlck1hcHBpbmdbMF0pKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmdbMF0gPSBkYXRhQWRkKG1hcHBpbmdbMF0sIG90aGVyTWFwcGluZ1swXVswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXBwaW5nWzBdID0gZGF0YUFkZFJhbmdlKG1hcHBpbmdbMF0sIG90aGVyTWFwcGluZ1swXVswXSwgb3RoZXJNYXBwaW5nWzBdWzFdIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXJyb2dhdGVNYXBwaW5ncy5zcGxpY2UoaW5uZXJJbmRleCwgMSk7XG4gICAgICAgICAgICAtLWlubmVySW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Vycm9nYXRlTWFwcGluZ3M7XG4gICAgfTtcbiAgICB2YXIgc3Vycm9nYXRlU2V0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGVuZDtcbiAgICAgIHZhciBzdGFydEhpZ2g7XG4gICAgICB2YXIgc3RhcnRMb3c7XG4gICAgICB2YXIgcHJldlN0YXJ0SGlnaCA9IDA7XG4gICAgICB2YXIgcHJldkVuZEhpZ2ggPSAwO1xuICAgICAgdmFyIHRtcExvdyA9IFtdO1xuICAgICAgdmFyIGVuZEhpZ2g7XG4gICAgICB2YXIgZW5kTG93O1xuICAgICAgdmFyIHN1cnJvZ2F0ZU1hcHBpbmdzID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB2YXIgZGF0YUhpZ2ggPSBbXTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBlbmQgPSBkYXRhW2luZGV4ICsgMV0gLSAxO1xuICAgICAgICBzdGFydEhpZ2ggPSBoaWdoU3Vycm9nYXRlKHN0YXJ0KTtcbiAgICAgICAgc3RhcnRMb3cgPSBsb3dTdXJyb2dhdGUoc3RhcnQpO1xuICAgICAgICBlbmRIaWdoID0gaGlnaFN1cnJvZ2F0ZShlbmQpO1xuICAgICAgICBlbmRMb3cgPSBsb3dTdXJyb2dhdGUoZW5kKTtcbiAgICAgICAgdmFyIHN0YXJ0c1dpdGhMb3dlc3RMb3dTdXJyb2dhdGUgPSBzdGFydExvdyA9PSBMT1dfU1VSUk9HQVRFX01JTjtcbiAgICAgICAgdmFyIGVuZHNXaXRoSGlnaGVzdExvd1N1cnJvZ2F0ZSA9IGVuZExvdyA9PSBMT1dfU1VSUk9HQVRFX01BWDtcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGFydEhpZ2ggPT0gZW5kSGlnaCB8fCBzdGFydHNXaXRoTG93ZXN0TG93U3Vycm9nYXRlICYmIGVuZHNXaXRoSGlnaGVzdExvd1N1cnJvZ2F0ZSkge1xuICAgICAgICAgIHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1tzdGFydEhpZ2gsIGVuZEhpZ2ggKyAxXSwgW3N0YXJ0TG93LCBlbmRMb3cgKyAxXV0pO1xuICAgICAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdXJyb2dhdGVNYXBwaW5ncy5wdXNoKFtbc3RhcnRIaWdoLCBzdGFydEhpZ2ggKyAxXSwgW3N0YXJ0TG93LCBMT1dfU1VSUk9HQVRFX01BWCArIDFdXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wbGV0ZSAmJiBzdGFydEhpZ2ggKyAxIDwgZW5kSGlnaCkge1xuICAgICAgICAgIGlmIChlbmRzV2l0aEhpZ2hlc3RMb3dTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1tzdGFydEhpZ2ggKyAxLCBlbmRIaWdoICsgMV0sIFtMT1dfU1VSUk9HQVRFX01JTiwgZW5kTG93ICsgMV1dKTtcbiAgICAgICAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vycm9nYXRlTWFwcGluZ3MucHVzaChbW3N0YXJ0SGlnaCArIDEsIGVuZEhpZ2hdLCBbTE9XX1NVUlJPR0FURV9NSU4sIExPV19TVVJST0dBVEVfTUFYICsgMV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wbGV0ZSkge1xuICAgICAgICAgIHN1cnJvZ2F0ZU1hcHBpbmdzLnB1c2goW1tlbmRIaWdoLCBlbmRIaWdoICsgMV0sIFtMT1dfU1VSUk9HQVRFX01JTiwgZW5kTG93ICsgMV1dKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2U3RhcnRIaWdoID0gc3RhcnRIaWdoO1xuICAgICAgICBwcmV2RW5kSGlnaCA9IGVuZEhpZ2g7XG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW1pemVTdXJyb2dhdGVNYXBwaW5ncyhzdXJyb2dhdGVNYXBwaW5ncyk7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlU3Vycm9nYXRlQ2hhcmFjdGVyQ2xhc3NlcyA9IGZ1bmN0aW9uKHN1cnJvZ2F0ZU1hcHBpbmdzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JFYWNoKHN1cnJvZ2F0ZU1hcHBpbmdzLCBmdW5jdGlvbihzdXJyb2dhdGVNYXBwaW5nKSB7XG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlcyA9IHN1cnJvZ2F0ZU1hcHBpbmdbMF07XG4gICAgICAgIHZhciBsb3dTdXJyb2dhdGVzID0gc3Vycm9nYXRlTWFwcGluZ1sxXTtcbiAgICAgICAgcmVzdWx0LnB1c2goY3JlYXRlQk1QQ2hhcmFjdGVyQ2xhc3NlcyhoaWdoU3Vycm9nYXRlcykgKyBjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzKGxvd1N1cnJvZ2F0ZXMpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCd8Jyk7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlQ2hhcmFjdGVyQ2xhc3Nlc0Zyb21EYXRhID0gZnVuY3Rpb24oZGF0YSwgYm1wT25seSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdEJNUChkYXRhKTtcbiAgICAgIHZhciBsb25lSGlnaFN1cnJvZ2F0ZXMgPSBwYXJ0cy5sb25lSGlnaFN1cnJvZ2F0ZXM7XG4gICAgICB2YXIgbG9uZUxvd1N1cnJvZ2F0ZXMgPSBwYXJ0cy5sb25lTG93U3Vycm9nYXRlcztcbiAgICAgIHZhciBibXAgPSBwYXJ0cy5ibXA7XG4gICAgICB2YXIgYXN0cmFsID0gcGFydHMuYXN0cmFsO1xuICAgICAgdmFyIGhhc0FzdHJhbCA9ICFkYXRhSXNFbXB0eShwYXJ0cy5hc3RyYWwpO1xuICAgICAgdmFyIGhhc0xvbmVIaWdoU3Vycm9nYXRlcyA9ICFkYXRhSXNFbXB0eShsb25lSGlnaFN1cnJvZ2F0ZXMpO1xuICAgICAgdmFyIGhhc0xvbmVMb3dTdXJyb2dhdGVzID0gIWRhdGFJc0VtcHR5KGxvbmVMb3dTdXJyb2dhdGVzKTtcbiAgICAgIHZhciBzdXJyb2dhdGVNYXBwaW5ncyA9IHN1cnJvZ2F0ZVNldChhc3RyYWwpO1xuICAgICAgaWYgKGJtcE9ubHkpIHtcbiAgICAgICAgYm1wID0gZGF0YUFkZERhdGEoYm1wLCBsb25lSGlnaFN1cnJvZ2F0ZXMpO1xuICAgICAgICBoYXNMb25lSGlnaFN1cnJvZ2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgYm1wID0gZGF0YUFkZERhdGEoYm1wLCBsb25lTG93U3Vycm9nYXRlcyk7XG4gICAgICAgIGhhc0xvbmVMb3dTdXJyb2dhdGVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWRhdGFJc0VtcHR5KGJtcCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3JlYXRlQk1QQ2hhcmFjdGVyQ2xhc3NlcyhibXApKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXJyb2dhdGVNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY3JlYXRlU3Vycm9nYXRlQ2hhcmFjdGVyQ2xhc3NlcyhzdXJyb2dhdGVNYXBwaW5ncykpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xvbmVIaWdoU3Vycm9nYXRlcykge1xuICAgICAgICByZXN1bHQucHVzaChjcmVhdGVCTVBDaGFyYWN0ZXJDbGFzc2VzKGxvbmVIaWdoU3Vycm9nYXRlcykgKyAnKD8hW1xcXFx1REMwMC1cXFxcdURGRkZdKScpO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xvbmVMb3dTdXJyb2dhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcoPzpbXlxcXFx1RDgwMC1cXFxcdURCRkZdfF4pJyArIGNyZWF0ZUJNUENoYXJhY3RlckNsYXNzZXMobG9uZUxvd1N1cnJvZ2F0ZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQuam9pbignfCcpO1xuICAgIH07XG4gICAgdmFyIHJlZ2VuZXJhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiByZWdlbmVyYXRlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmFkZCh2YWx1ZSkgOiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChuZXcgcmVnZW5lcmF0ZSkuYWRkKHZhbHVlKTtcbiAgICB9O1xuICAgIHJlZ2VuZXJhdGUudmVyc2lvbiA9ICcxLjIuMCc7XG4gICAgdmFyIHByb3RvID0gcmVnZW5lcmF0ZS5wcm90b3R5cGU7XG4gICAgZXh0ZW5kKHByb3RvLCB7XG4gICAgICAnYWRkJzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVnZW5lcmF0ZSkge1xuICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhQWRkRGF0YSgkdGhpcy5kYXRhLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFsdWUgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgJHRoaXMuYWRkKGl0ZW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgfVxuICAgICAgICAkdGhpcy5kYXRhID0gZGF0YUFkZCgkdGhpcy5kYXRhLCBpc051bWJlcih2YWx1ZSkgPyB2YWx1ZSA6IHN5bWJvbFRvQ29kZVBvaW50KHZhbHVlKSk7XG4gICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgIH0sXG4gICAgICAncmVtb3ZlJzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVnZW5lcmF0ZSkge1xuICAgICAgICAgICR0aGlzLmRhdGEgPSBkYXRhUmVtb3ZlRGF0YSgkdGhpcy5kYXRhLCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICByZXR1cm4gJHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFsdWUgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgJHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgICAgfVxuICAgICAgICAkdGhpcy5kYXRhID0gZGF0YVJlbW92ZSgkdGhpcy5kYXRhLCBpc051bWJlcih2YWx1ZSkgPyB2YWx1ZSA6IHN5bWJvbFRvQ29kZVBvaW50KHZhbHVlKSk7XG4gICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgIH0sXG4gICAgICAnYWRkUmFuZ2UnOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgICAgICR0aGlzLmRhdGEgPSBkYXRhQWRkUmFuZ2UoJHRoaXMuZGF0YSwgaXNOdW1iZXIoc3RhcnQpID8gc3RhcnQgOiBzeW1ib2xUb0NvZGVQb2ludChzdGFydCksIGlzTnVtYmVyKGVuZCkgPyBlbmQgOiBzeW1ib2xUb0NvZGVQb2ludChlbmQpKTtcbiAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgfSxcbiAgICAgICdyZW1vdmVSYW5nZSc6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0Q29kZVBvaW50ID0gaXNOdW1iZXIoc3RhcnQpID8gc3RhcnQgOiBzeW1ib2xUb0NvZGVQb2ludChzdGFydCk7XG4gICAgICAgIHZhciBlbmRDb2RlUG9pbnQgPSBpc051bWJlcihlbmQpID8gZW5kIDogc3ltYm9sVG9Db2RlUG9pbnQoZW5kKTtcbiAgICAgICAgJHRoaXMuZGF0YSA9IGRhdGFSZW1vdmVSYW5nZSgkdGhpcy5kYXRhLCBzdGFydENvZGVQb2ludCwgZW5kQ29kZVBvaW50KTtcbiAgICAgICAgcmV0dXJuICR0aGlzO1xuICAgICAgfSxcbiAgICAgICdpbnRlcnNlY3Rpb24nOiBmdW5jdGlvbihhcmd1bWVudCkge1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudCBpbnN0YW5jZW9mIHJlZ2VuZXJhdGUgPyBkYXRhVG9BcnJheShhcmd1bWVudC5kYXRhKSA6IGFyZ3VtZW50O1xuICAgICAgICAkdGhpcy5kYXRhID0gZGF0YUludGVyc2VjdGlvbigkdGhpcy5kYXRhLCBhcnJheSk7XG4gICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgIH0sXG4gICAgICAnY29udGFpbnMnOiBmdW5jdGlvbihjb2RlUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFDb250YWlucyh0aGlzLmRhdGEsIGlzTnVtYmVyKGNvZGVQb2ludCkgPyBjb2RlUG9pbnQgOiBzeW1ib2xUb0NvZGVQb2ludChjb2RlUG9pbnQpKTtcbiAgICAgIH0sXG4gICAgICAnY2xvbmUnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyByZWdlbmVyYXRlO1xuICAgICAgICBzZXQuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSgwKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgIH0sXG4gICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVDaGFyYWN0ZXJDbGFzc2VzRnJvbURhdGEodGhpcy5kYXRhLCBvcHRpb25zID8gb3B0aW9ucy5ibXBPbmx5IDogZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UocmVnZXhOdWxsLCAnXFxcXDAkMScpO1xuICAgICAgfSxcbiAgICAgICd0b1JlZ0V4cCc6IGZ1bmN0aW9uKGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAodGhpcy50b1N0cmluZygpLCBmbGFncyB8fCAnJyk7XG4gICAgICB9LFxuICAgICAgJ3ZhbHVlT2YnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFUb0FycmF5KHRoaXMuZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvdG8udG9BcnJheSA9IHByb3RvLnZhbHVlT2Y7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcbiAgICAgIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgICAgIGZyZWVNb2R1bGUuZXhwb3J0cyA9IHJlZ2VuZXJhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmVlRXhwb3J0cy5yZWdlbmVyYXRlID0gcmVnZW5lcmF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5yZWdlbmVyYXRlID0gcmVnZW5lcmF0ZTtcbiAgICB9XG4gIH0oKHZvaWQgMCkpKTtcbiAgbW9kdWxlc1sncmVnZW5lcmF0ZSddID0gbW9kdWxlLmV4cG9ydHMgfHwgd2luZG93LnJlZ2VuZXJhdGU7XG4gIDtcbiAgKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICAgJ29iamVjdCc6IHRydWVcbiAgICB9O1xuICAgIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcbiAgICB2YXIgb2xkUm9vdCA9IHJvb3Q7XG4gICAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHM7XG4gICAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gICAgdmFyIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlICYmIHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuICAgIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgICB9XG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KCkge1xuICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xuICAgICAgdmFyIGNvZGVVbml0cyA9IFtdO1xuICAgICAgdmFyIGhpZ2hTdXJyb2dhdGU7XG4gICAgICB2YXIgbG93U3Vycm9nYXRlO1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBOdW1iZXIoYXJndW1lbnRzW2luZGV4XSk7XG4gICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCBjb2RlUG9pbnQgPCAwIHx8IGNvZGVQb2ludCA+IDB4MTBGRkZGIHx8IGZsb29yKGNvZGVQb2ludCkgIT0gY29kZVBvaW50KSB7XG4gICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikge1xuICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwO1xuICAgICAgICAgIGxvd1N1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgJSAweDQwMCkgKyAweERDMDA7XG4gICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggKyAxID09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XG4gICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydFR5cGUodHlwZSwgZXhwZWN0ZWQpIHtcbiAgICAgIGlmIChleHBlY3RlZC5pbmRleE9mKCd8JykgPT0gLTEpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbm9kZSB0eXBlOiAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgICBleHBlY3RlZCA9IGFzc2VydFR5cGUuaGFzT3duUHJvcGVydHkoZXhwZWN0ZWQpID8gYXNzZXJ0VHlwZVtleHBlY3RlZF0gOiAoYXNzZXJ0VHlwZVtleHBlY3RlZF0gPSBSZWdFeHAoJ14oPzonICsgZXhwZWN0ZWQgKyAnKSQnKSk7XG4gICAgICBpZiAoZXhwZWN0ZWQudGVzdCh0eXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBub2RlIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSkge1xuICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICBpZiAoZ2VuZXJhdGUuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgdHlwZW9mIGdlbmVyYXRlW3R5cGVdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlW3R5cGVdKG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbm9kZSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQWx0ZXJuYXRpdmUobm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbHRlcm5hdGl2ZScpO1xuICAgICAgdmFyIHRlcm1zID0gbm9kZS5ib2R5LFxuICAgICAgICAgIGxlbmd0aCA9IHRlcm1zID8gdGVybXMubGVuZ3RoIDogMDtcbiAgICAgIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVUZXJtKHRlcm1zWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZVRlcm0odGVybXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQW5jaG9yKG5vZGUpIHtcbiAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnYW5jaG9yJyk7XG4gICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgcmV0dXJuICdeJztcbiAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICByZXR1cm4gJyQnO1xuICAgICAgICBjYXNlICdib3VuZGFyeSc6XG4gICAgICAgICAgcmV0dXJuICdcXFxcYic7XG4gICAgICAgIGNhc2UgJ25vdC1ib3VuZGFyeSc6XG4gICAgICAgICAgcmV0dXJuICdcXFxcQic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYXNzZXJ0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXRvbShub2RlKSB7XG4gICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2FuY2hvcnxjaGFyYWN0ZXJDbGFzc3xjaGFyYWN0ZXJDbGFzc0VzY2FwZXxkb3R8Z3JvdXB8cmVmZXJlbmNlfHZhbHVlJyk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUobm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcmFjdGVyQ2xhc3Mobm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdjaGFyYWN0ZXJDbGFzcycpO1xuICAgICAgdmFyIGNsYXNzUmFuZ2VzID0gbm9kZS5ib2R5LFxuICAgICAgICAgIGxlbmd0aCA9IGNsYXNzUmFuZ2VzID8gY2xhc3NSYW5nZXMubGVuZ3RoIDogMDtcbiAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gJ1snO1xuICAgICAgaWYgKG5vZGUubmVnYXRpdmUpIHtcbiAgICAgICAgcmVzdWx0ICs9ICdeJztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGdlbmVyYXRlQ2xhc3NBdG9tKGNsYXNzUmFuZ2VzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzRXNjYXBlKG5vZGUpIHtcbiAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAnY2hhcmFjdGVyQ2xhc3NFc2NhcGUnKTtcbiAgICAgIHJldHVybiAnXFxcXCcgKyBub2RlLnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzUmFuZ2Uobm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdjaGFyYWN0ZXJDbGFzc1JhbmdlJyk7XG4gICAgICB2YXIgbWluID0gbm9kZS5taW4sXG4gICAgICAgICAgbWF4ID0gbm9kZS5tYXg7XG4gICAgICBpZiAobWluLnR5cGUgPT0gJ2NoYXJhY3RlckNsYXNzUmFuZ2UnIHx8IG1heC50eXBlID09ICdjaGFyYWN0ZXJDbGFzc1JhbmdlJykge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3MgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZUNsYXNzQXRvbShtaW4pICsgJy0nICsgZ2VuZXJhdGVDbGFzc0F0b20obWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc0F0b20obm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbmNob3J8Y2hhcmFjdGVyQ2xhc3NFc2NhcGV8Y2hhcmFjdGVyQ2xhc3NSYW5nZXxkb3R8dmFsdWUnKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZShub2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVEaXNqdW5jdGlvbihub2RlKSB7XG4gICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2Rpc2p1bmN0aW9uJyk7XG4gICAgICB2YXIgYm9keSA9IG5vZGUuYm9keSxcbiAgICAgICAgICBsZW5ndGggPSBib2R5ID8gYm9keS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdObyBib2R5Jyk7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZShib2R5WzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnfCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZShib2R5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZURvdChub2RlKSB7XG4gICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2RvdCcpO1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVHcm91cChub2RlKSB7XG4gICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ2dyb3VwJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gJygnO1xuICAgICAgc3dpdGNoIChub2RlLmJlaGF2aW9yKSB7XG4gICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgcmVzdWx0ICs9ICc/Oic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xvb2thaGVhZCc6XG4gICAgICAgICAgcmVzdWx0ICs9ICc/PSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25lZ2F0aXZlTG9va2FoZWFkJzpcbiAgICAgICAgICByZXN1bHQgKz0gJz8hJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBiZWhhdmlvdXI6ICcgKyBub2RlLmJlaGF2aW91cik7XG4gICAgICB9XG4gICAgICB2YXIgYm9keSA9IG5vZGUuYm9keSxcbiAgICAgICAgICBsZW5ndGggPSBib2R5ID8gYm9keS5sZW5ndGggOiAwO1xuICAgICAgaWYgKGxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZW5lcmF0ZShib2R5WzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZ2VuZXJhdGUoYm9keVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnKSc7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVF1YW50aWZpZXIobm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdxdWFudGlmaWVyJyk7XG4gICAgICB2YXIgcXVhbnRpZmllciA9ICcnLFxuICAgICAgICAgIG1pbiA9IG5vZGUubWluLFxuICAgICAgICAgIG1heCA9IG5vZGUubWF4O1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBzd2l0Y2ggKG1pbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBxdWFudGlmaWVyID0gJyonO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcXVhbnRpZmllciA9ICcrJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBxdWFudGlmaWVyID0gJ3snICsgbWluICsgJyx9JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChtaW4gPT0gbWF4KSB7XG4gICAgICAgICAgICBxdWFudGlmaWVyID0gJ3snICsgbWluICsgJ30nO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWluID09IDAgJiYgbWF4ID09IDEpIHtcbiAgICAgICAgICAgIHF1YW50aWZpZXIgPSAnPyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YW50aWZpZXIgPSAneycgKyBtaW4gKyAnLCcgKyBtYXggKyAnfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlLmdyZWVkeSkge1xuICAgICAgICBxdWFudGlmaWVyICs9ICc/JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZUF0b20obm9kZS5ib2R5WzBdKSArIHF1YW50aWZpZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmZXJlbmNlKG5vZGUpIHtcbiAgICAgIGFzc2VydFR5cGUobm9kZS50eXBlLCAncmVmZXJlbmNlJyk7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgbm9kZS5tYXRjaEluZGV4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVRlcm0obm9kZSkge1xuICAgICAgYXNzZXJ0VHlwZShub2RlLnR5cGUsICdhbmNob3J8Y2hhcmFjdGVyQ2xhc3N8Y2hhcmFjdGVyQ2xhc3NFc2NhcGV8ZW1wdHl8Z3JvdXB8cXVhbnRpZmllcnxyZWZlcmVuY2V8dmFsdWUnKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZShub2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWYWx1ZShub2RlKSB7XG4gICAgICBhc3NlcnRUeXBlKG5vZGUudHlwZSwgJ3ZhbHVlJyk7XG4gICAgICB2YXIga2luZCA9IG5vZGUua2luZCxcbiAgICAgICAgICBjb2RlUG9pbnQgPSBub2RlLmNvZGVQb2ludDtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlICdjb250cm9sTGV0dGVyJzpcbiAgICAgICAgICByZXR1cm4gJ1xcXFxjJyArIGZyb21Db2RlUG9pbnQoY29kZVBvaW50ICsgNjQpO1xuICAgICAgICBjYXNlICdoZXhhZGVjaW1hbEVzY2FwZSc6XG4gICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICAgICAgICBjYXNlICdpZGVudGlmaWVyJzpcbiAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgZnJvbUNvZGVQb2ludChjb2RlUG9pbnQpO1xuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICByZXR1cm4gJ1xcXFwnICsgY29kZVBvaW50O1xuICAgICAgICBjYXNlICdvY3RhbCc6XG4gICAgICAgICAgcmV0dXJuICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZyg4KTtcbiAgICAgICAgY2FzZSAnc2luZ2xlRXNjYXBlJzpcbiAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgY2FzZSAweDAwMDg6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXGInO1xuICAgICAgICAgICAgY2FzZSAweDAwOTpcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdCc7XG4gICAgICAgICAgICBjYXNlIDB4MDBBOlxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgICAgIGNhc2UgMHgwMEI6XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHYnO1xuICAgICAgICAgICAgY2FzZSAweDAwQzpcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcZic7XG4gICAgICAgICAgICBjYXNlIDB4MDBEOlxuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvZGVwb2ludDogJyArIGNvZGVQb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgIGNhc2UgJ3VuaWNvZGVFc2NhcGUnOlxuICAgICAgICAgIHJldHVybiAnXFxcXHUnICsgKCcwMDAwJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpO1xuICAgICAgICBjYXNlICd1bmljb2RlQ29kZVBvaW50RXNjYXBlJzpcbiAgICAgICAgICByZXR1cm4gJ1xcXFx1eycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnfSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIG5vZGUga2luZDogJyArIGtpbmQpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZS5hbHRlcm5hdGl2ZSA9IGdlbmVyYXRlQWx0ZXJuYXRpdmU7XG4gICAgZ2VuZXJhdGUuYW5jaG9yID0gZ2VuZXJhdGVBbmNob3I7XG4gICAgZ2VuZXJhdGUuY2hhcmFjdGVyQ2xhc3MgPSBnZW5lcmF0ZUNoYXJhY3RlckNsYXNzO1xuICAgIGdlbmVyYXRlLmNoYXJhY3RlckNsYXNzRXNjYXBlID0gZ2VuZXJhdGVDaGFyYWN0ZXJDbGFzc0VzY2FwZTtcbiAgICBnZW5lcmF0ZS5jaGFyYWN0ZXJDbGFzc1JhbmdlID0gZ2VuZXJhdGVDaGFyYWN0ZXJDbGFzc1JhbmdlO1xuICAgIGdlbmVyYXRlLmRpc2p1bmN0aW9uID0gZ2VuZXJhdGVEaXNqdW5jdGlvbjtcbiAgICBnZW5lcmF0ZS5kb3QgPSBnZW5lcmF0ZURvdDtcbiAgICBnZW5lcmF0ZS5ncm91cCA9IGdlbmVyYXRlR3JvdXA7XG4gICAgZ2VuZXJhdGUucXVhbnRpZmllciA9IGdlbmVyYXRlUXVhbnRpZmllcjtcbiAgICBnZW5lcmF0ZS5yZWZlcmVuY2UgPSBnZW5lcmF0ZVJlZmVyZW5jZTtcbiAgICBnZW5lcmF0ZS52YWx1ZSA9IGdlbmVyYXRlVmFsdWU7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7J2dlbmVyYXRlJzogZ2VuZXJhdGV9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgICBmcmVlRXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LnJlZ2pzZ2VuID0geydnZW5lcmF0ZSc6IGdlbmVyYXRlfTtcbiAgICB9XG4gIH0uY2FsbCgodm9pZCAwKSkpO1xuICBtb2R1bGVzWydyZWdqc2dlbiddID0ge2dlbmVyYXRlOiBleHBvcnRzLmdlbmVyYXRlIHx8IHdpbmRvdy5yZWdqc2dlbn07XG4gIChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBwYXJzZShzdHIsIGZsYWdzKSB7XG4gICAgICBmdW5jdGlvbiBhZGRSYXcobm9kZSkge1xuICAgICAgICBub2RlLnJhdyA9IHN0ci5zdWJzdHJpbmcobm9kZS5yYW5nZVswXSwgbm9kZS5yYW5nZVsxXSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlUmF3U3RhcnQobm9kZSwgc3RhcnQpIHtcbiAgICAgICAgbm9kZS5yYW5nZVswXSA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gYWRkUmF3KG5vZGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQW5jaG9yKGtpbmQsIHJhd0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAnYW5jaG9yJyxcbiAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgIHJhbmdlOiBbcG9zIC0gcmF3TGVuZ3RoLCBwb3NdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlVmFsdWUoa2luZCwgY29kZVBvaW50LCBmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAndmFsdWUnLFxuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgY29kZVBvaW50OiBjb2RlUG9pbnQsXG4gICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVFc2NhcGVkKGtpbmQsIGNvZGVQb2ludCwgdmFsdWUsIGZyb21PZmZzZXQpIHtcbiAgICAgICAgZnJvbU9mZnNldCA9IGZyb21PZmZzZXQgfHwgMDtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZhbHVlKGtpbmQsIGNvZGVQb2ludCwgcG9zIC0gKHZhbHVlLmxlbmd0aCArIGZyb21PZmZzZXQpLCBwb3MpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlQ2hhcmFjdGVyKG1hdGNoZXMpIHtcbiAgICAgICAgdmFyIF9jaGFyID0gbWF0Y2hlc1swXTtcbiAgICAgICAgdmFyIGZpcnN0ID0gX2NoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGhhc1VuaWNvZGVGbGFnKSB7XG4gICAgICAgICAgdmFyIHNlY29uZDtcbiAgICAgICAgICBpZiAoX2NoYXIubGVuZ3RoID09PSAxICYmIGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYpIHtcbiAgICAgICAgICAgIHNlY29uZCA9IGxvb2thaGVhZCgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVmFsdWUoJ3N5bWJvbCcsIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDAsIHBvcyAtIDIsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVWYWx1ZSgnc3ltYm9sJywgZmlyc3QsIHBvcyAtIDEsIHBvcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVEaXNqdW5jdGlvbihhbHRlcm5hdGl2ZXMsIGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgIHR5cGU6ICdkaXNqdW5jdGlvbicsXG4gICAgICAgICAgYm9keTogYWx0ZXJuYXRpdmVzLFxuICAgICAgICAgIHJhbmdlOiBbZnJvbSwgdG9dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlRG90KCkge1xuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAnZG90JyxcbiAgICAgICAgICByYW5nZTogW3BvcyAtIDEsIHBvc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc0VzY2FwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAnY2hhcmFjdGVyQ2xhc3NFc2NhcGUnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICByYW5nZTogW3BvcyAtIDIsIHBvc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2UobWF0Y2hJbmRleCkge1xuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAncmVmZXJlbmNlJyxcbiAgICAgICAgICBtYXRjaEluZGV4OiBwYXJzZUludChtYXRjaEluZGV4LCAxMCksXG4gICAgICAgICAgcmFuZ2U6IFtwb3MgLSAxIC0gbWF0Y2hJbmRleC5sZW5ndGgsIHBvc11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVHcm91cChiZWhhdmlvciwgZGlzanVuY3Rpb24sIGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBhZGRSYXcoe1xuICAgICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgICAgICAgIGJvZHk6IGRpc2p1bmN0aW9uLFxuICAgICAgICAgIHJhbmdlOiBbZnJvbSwgdG9dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY3JlYXRlUXVhbnRpZmllcihtaW4sIG1heCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICBmcm9tID0gcG9zIC0gMTtcbiAgICAgICAgICB0byA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkUmF3KHtcbiAgICAgICAgICB0eXBlOiAncXVhbnRpZmllcicsXG4gICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVBbHRlcm5hdGl2ZSh0ZXJtcywgZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgdHlwZTogJ2FsdGVybmF0aXZlJyxcbiAgICAgICAgICBib2R5OiB0ZXJtcyxcbiAgICAgICAgICByYW5nZTogW2Zyb20sIHRvXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlckNsYXNzKGNsYXNzUmFuZ2VzLCBuZWdhdGl2ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgdHlwZTogJ2NoYXJhY3RlckNsYXNzJyxcbiAgICAgICAgICBib2R5OiBjbGFzc1JhbmdlcyxcbiAgICAgICAgICBuZWdhdGl2ZTogbmVnYXRpdmUsXG4gICAgICAgICAgcmFuZ2U6IFtmcm9tLCB0b11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjcmVhdGVDbGFzc1JhbmdlKG1pbiwgbWF4LCBmcm9tLCB0bykge1xuICAgICAgICBpZiAobWluLmNvZGVQb2ludCA+IG1heC5jb2RlUG9pbnQpIHtcbiAgICAgICAgICBiYWlsKCdpbnZhbGlkIHJhbmdlIGluIGNoYXJhY3RlciBjbGFzcycsIG1pbi5yYXcgKyAnLScgKyBtYXgucmF3LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZFJhdyh7XG4gICAgICAgICAgdHlwZTogJ2NoYXJhY3RlckNsYXNzUmFuZ2UnLFxuICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgIG1heDogbWF4LFxuICAgICAgICAgIHJhbmdlOiBbZnJvbSwgdG9dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZmxhdHRlbkJvZHkoYm9keSkge1xuICAgICAgICBpZiAoYm9keS50eXBlID09PSAnYWx0ZXJuYXRpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuYm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2JvZHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqLnR5cGUgPT09ICdlbXB0eSc7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbmNyKGFtb3VudCkge1xuICAgICAgICBhbW91bnQgPSAoYW1vdW50IHx8IDEpO1xuICAgICAgICB2YXIgcmVzID0gc3RyLnN1YnN0cmluZyhwb3MsIHBvcyArIGFtb3VudCk7XG4gICAgICAgIHBvcyArPSAoYW1vdW50IHx8IDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2tpcCh2YWx1ZSkge1xuICAgICAgICBpZiAoIW1hdGNoKHZhbHVlKSkge1xuICAgICAgICAgIGJhaWwoJ2NoYXJhY3RlcicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgICAgaWYgKHN0ci5pbmRleE9mKHZhbHVlLCBwb3MpID09PSBwb3MpIHtcbiAgICAgICAgICByZXR1cm4gaW5jcih2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb29rYWhlYWQoKSB7XG4gICAgICAgIHJldHVybiBzdHJbcG9zXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKHZhbHVlLCBwb3MpID09PSBwb3M7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdHJbcG9zICsgMV0gPT09IHZhbHVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWF0Y2hSZWcocmVnRXhwKSB7XG4gICAgICAgIHZhciBzdWJTdHIgPSBzdHIuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgIHZhciByZXMgPSBzdWJTdHIubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHJlcy5yYW5nZSA9IFtdO1xuICAgICAgICAgIHJlcy5yYW5nZVswXSA9IHBvcztcbiAgICAgICAgICBpbmNyKHJlc1swXS5sZW5ndGgpO1xuICAgICAgICAgIHJlcy5yYW5nZVsxXSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VEaXNqdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgcmVzLnB1c2gocGFyc2VBbHRlcm5hdGl2ZSgpKTtcbiAgICAgICAgd2hpbGUgKG1hdGNoKCd8JykpIHtcbiAgICAgICAgICByZXMucHVzaChwYXJzZUFsdGVybmF0aXZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRGlzanVuY3Rpb24ocmVzLCBmcm9tLCBwb3MpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VBbHRlcm5hdGl2ZSgpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgdmFyIHRlcm07XG4gICAgICAgIHdoaWxlICh0ZXJtID0gcGFyc2VUZXJtKCkpIHtcbiAgICAgICAgICByZXMucHVzaCh0ZXJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiByZXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFsdGVybmF0aXZlKHJlcywgZnJvbSwgcG9zKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlVGVybSgpIHtcbiAgICAgICAgaWYgKHBvcyA+PSBzdHIubGVuZ3RoIHx8IGN1cnJlbnQoJ3wnKSB8fCBjdXJyZW50KCcpJykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5jaG9yID0gcGFyc2VBbmNob3IoKTtcbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0b20gPSBwYXJzZUF0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgYmFpbCgnRXhwZWN0ZWQgYXRvbScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWFudGlmaWVyID0gcGFyc2VRdWFudGlmaWVyKCkgfHwgZmFsc2U7XG4gICAgICAgIGlmIChxdWFudGlmaWVyKSB7XG4gICAgICAgICAgcXVhbnRpZmllci5ib2R5ID0gZmxhdHRlbkJvZHkoYXRvbSk7XG4gICAgICAgICAgdXBkYXRlUmF3U3RhcnQocXVhbnRpZmllciwgYXRvbS5yYW5nZVswXSk7XG4gICAgICAgICAgcmV0dXJuIHF1YW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0b207XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZUdyb3VwKG1hdGNoQSwgdHlwZUEsIG1hdGNoQiwgdHlwZUIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsLFxuICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgaWYgKG1hdGNoKG1hdGNoQSkpIHtcbiAgICAgICAgICB0eXBlID0gdHlwZUE7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2gobWF0Y2hCKSkge1xuICAgICAgICAgIHR5cGUgPSB0eXBlQjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBwYXJzZURpc2p1bmN0aW9uKCk7XG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIGJhaWwoJ0V4cGVjdGVkIGRpc2p1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcCgnKScpO1xuICAgICAgICB2YXIgZ3JvdXAgPSBjcmVhdGVHcm91cCh0eXBlLCBmbGF0dGVuQm9keShib2R5KSwgZnJvbSwgcG9zKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ25vcm1hbCcpIHtcbiAgICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNsb3NlZENhcHR1cmVDb3VudGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQW5jaG9yKCkge1xuICAgICAgICB2YXIgcmVzLFxuICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgaWYgKG1hdGNoKCdeJykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQW5jaG9yKCdzdGFydCcsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCckJykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQW5jaG9yKCdlbmQnLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnXFxcXGInKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVBbmNob3IoJ2JvdW5kYXJ5JywgMik7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1xcXFxCJykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQW5jaG9yKCdub3QtYm91bmRhcnknLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cCgnKD89JywgJ2xvb2thaGVhZCcsICcoPyEnLCAnbmVnYXRpdmVMb29rYWhlYWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VRdWFudGlmaWVyKCkge1xuICAgICAgICB2YXIgcmVzLFxuICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgdmFyIHF1YW50aWZpZXI7XG4gICAgICAgIHZhciBtaW4sXG4gICAgICAgICAgICBtYXg7XG4gICAgICAgIGlmIChtYXRjaCgnKicpKSB7XG4gICAgICAgICAgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIoMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSkge1xuICAgICAgICAgIHF1YW50aWZpZXIgPSBjcmVhdGVRdWFudGlmaWVyKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICBxdWFudGlmaWVyID0gY3JlYXRlUXVhbnRpZmllcigwLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXlxceyhbMC05XSspXFx9LykpIHtcbiAgICAgICAgICBtaW4gPSBwYXJzZUludChyZXNbMV0sIDEwKTtcbiAgICAgICAgICBxdWFudGlmaWVyID0gY3JlYXRlUXVhbnRpZmllcihtaW4sIG1pbiwgcmVzLnJhbmdlWzBdLCByZXMucmFuZ2VbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFx7KFswLTldKyksXFx9LykpIHtcbiAgICAgICAgICBtaW4gPSBwYXJzZUludChyZXNbMV0sIDEwKTtcbiAgICAgICAgICBxdWFudGlmaWVyID0gY3JlYXRlUXVhbnRpZmllcihtaW4sIHVuZGVmaW5lZCwgcmVzLnJhbmdlWzBdLCByZXMucmFuZ2VbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eXFx7KFswLTldKyksKFswLTldKylcXH0vKSkge1xuICAgICAgICAgIG1pbiA9IHBhcnNlSW50KHJlc1sxXSwgMTApO1xuICAgICAgICAgIG1heCA9IHBhcnNlSW50KHJlc1syXSwgMTApO1xuICAgICAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgICAgIGJhaWwoJ251bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXInLCAnJywgZnJvbSwgcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIobWluLCBtYXgsIHJlcy5yYW5nZVswXSwgcmVzLnJhbmdlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVhbnRpZmllcikge1xuICAgICAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgICBxdWFudGlmaWVyLmdyZWVkeSA9IGZhbHNlO1xuICAgICAgICAgICAgcXVhbnRpZmllci5yYW5nZVsxXSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVhbnRpZmllcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQXRvbSgpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKHJlcyA9IG1hdGNoUmVnKC9eW15eJFxcXFwuKis/KCl7W3xdLykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKHJlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVEb3QoKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnXFxcXCcpKSB7XG4gICAgICAgICAgcmVzID0gcGFyc2VBdG9tRXNjYXBlKCk7XG4gICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIGJhaWwoJ2F0b21Fc2NhcGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBwYXJzZUNoYXJhY3RlckNsYXNzKCkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJzZUdyb3VwKCcoPzonLCAnaWdub3JlJywgJygnLCAnbm9ybWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoZmlyc3RFc2NhcGUpIHtcbiAgICAgICAgaWYgKGhhc1VuaWNvZGVGbGFnKSB7XG4gICAgICAgICAgdmFyIGZpcnN0LFxuICAgICAgICAgICAgICBzZWNvbmQ7XG4gICAgICAgICAgaWYgKGZpcnN0RXNjYXBlLmtpbmQgPT0gJ3VuaWNvZGVFc2NhcGUnICYmIChmaXJzdCA9IGZpcnN0RXNjYXBlLmNvZGVQb2ludCkgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBjdXJyZW50KCdcXFxcJykgJiYgbmV4dCgndScpKSB7XG4gICAgICAgICAgICB2YXIgcHJldlBvcyA9IHBvcztcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgdmFyIHNlY29uZEVzY2FwZSA9IHBhcnNlQ2xhc3NFc2NhcGUoKTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRFc2NhcGUua2luZCA9PSAndW5pY29kZUVzY2FwZScgJiYgKHNlY29uZCA9IHNlY29uZEVzY2FwZS5jb2RlUG9pbnQpID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIGZpcnN0RXNjYXBlLnJhbmdlWzFdID0gc2Vjb25kRXNjYXBlLnJhbmdlWzFdO1xuICAgICAgICAgICAgICBmaXJzdEVzY2FwZS5jb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICAgICAgICBmaXJzdEVzY2FwZS50eXBlID0gJ3ZhbHVlJztcbiAgICAgICAgICAgICAgZmlyc3RFc2NhcGUua2luZCA9ICd1bmljb2RlQ29kZVBvaW50RXNjYXBlJztcbiAgICAgICAgICAgICAgYWRkUmF3KGZpcnN0RXNjYXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvcyA9IHByZXZQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdEVzY2FwZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NFc2NhcGUoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUF0b21Fc2NhcGUodHJ1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZUF0b21Fc2NhcGUoaW5zaWRlQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICAgICAgdmFyIHJlcyxcbiAgICAgICAgICAgIGZyb20gPSBwb3M7XG4gICAgICAgIHJlcyA9IHBhcnNlRGVjaW1hbEVzY2FwZSgpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zaWRlQ2hhcmFjdGVyQ2xhc3MpIHtcbiAgICAgICAgICBpZiAobWF0Y2goJ2InKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ3NpbmdsZUVzY2FwZScsIDB4MDAwOCwgJ1xcXFxiJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnQicpKSB7XG4gICAgICAgICAgICBiYWlsKCdcXFxcQiBub3QgcG9zc2libGUgaW5zaWRlIG9mIENoYXJhY3RlckNsYXNzJywgJycsIGZyb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgPSBwYXJzZUNoYXJhY3RlckVzY2FwZSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VEZWNpbWFsRXNjYXBlKCkge1xuICAgICAgICB2YXIgcmVzLFxuICAgICAgICAgICAgbWF0Y2g7XG4gICAgICAgIGlmIChyZXMgPSBtYXRjaFJlZygvXig/ITApXFxkKy8pKSB7XG4gICAgICAgICAgbWF0Y2ggPSByZXNbMF07XG4gICAgICAgICAgdmFyIHJlZklkeCA9IHBhcnNlSW50KHJlc1swXSwgMTApO1xuICAgICAgICAgIGlmIChyZWZJZHggPD0gY2xvc2VkQ2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWZlcmVuY2UocmVzWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFja3JlZkRlbmllZC5wdXNoKHJlZklkeCk7XG4gICAgICAgICAgICBpbmNyKC1yZXNbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXMgPSBtYXRjaFJlZygvXlswLTddezEsM30vKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnb2N0YWwnLCBwYXJzZUludChyZXNbMF0sIDgpLCByZXNbMF0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlQ2hhcmFjdGVyKG1hdGNoUmVnKC9eWzg5XS8pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJhd1N0YXJ0KHJlcywgcmVzLnJhbmdlWzBdIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IG1hdGNoUmVnKC9eWzAtN117MSwzfS8pKSB7XG4gICAgICAgICAgbWF0Y2ggPSByZXNbMF07XG4gICAgICAgICAgaWYgKC9eMHsxLDN9JC8udGVzdChtYXRjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdudWxsJywgMHgwMDAwLCAnMCcsIG1hdGNoLmxlbmd0aCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnb2N0YWwnLCBwYXJzZUludChtYXRjaCwgOCksIG1hdGNoLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL15bZERzU3dXXS8pKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlckNsYXNzRXNjYXBlKHJlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJFc2NhcGUoKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmIChyZXMgPSBtYXRjaFJlZygvXltmbnJ0dl0vKSkge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAwO1xuICAgICAgICAgIHN3aXRjaCAocmVzWzBdKSB7XG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gMHgwMDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4MDBBO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAweDAwQjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gMHgwMEM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4MDBEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ3NpbmdsZUVzY2FwZScsIGNvZGVQb2ludCwgJ1xcXFwnICsgcmVzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBtYXRjaFJlZygvXmMoW2EtekEtWl0pLykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnY29udHJvbExldHRlcicsIHJlc1sxXS5jaGFyQ29kZUF0KDApICUgMzIsIHJlc1sxXSwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL154KFswLTlhLWZBLUZdezJ9KS8pKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUVzY2FwZWQoJ2hleGFkZWNpbWFsRXNjYXBlJywgcGFyc2VJbnQocmVzWzFdLCAxNiksIHJlc1sxXSwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzID0gbWF0Y2hSZWcoL151KFswLTlhLWZBLUZdezR9KS8pKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVW5pY29kZVN1cnJvZ2F0ZVBhaXJFc2NhcGUoY3JlYXRlRXNjYXBlZCgndW5pY29kZUVzY2FwZScsIHBhcnNlSW50KHJlc1sxXSwgMTYpLCByZXNbMV0sIDIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNVbmljb2RlRmxhZyAmJiAocmVzID0gbWF0Y2hSZWcoL151XFx7KFswLTlhLWZBLUZdKylcXH0vKSkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgndW5pY29kZUNvZGVQb2ludEVzY2FwZScsIHBhcnNlSW50KHJlc1sxXSwgMTYpLCByZXNbMV0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJzZUlkZW50aXR5RXNjYXBlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgICAgdmFyIE5vbkFzY2lpSWRlbnRpZmllclBhcnQgPSBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyk7XG4gICAgICAgIHJldHVybiAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAoY2ggPj0gNjUgJiYgY2ggPD0gOTApIHx8IChjaCA+PSA5NyAmJiBjaCA8PSAxMjIpIHx8IChjaCA+PSA0OCAmJiBjaCA8PSA1NykgfHwgKGNoID09PSA5MikgfHwgKChjaCA+PSAweDgwKSAmJiBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlSWRlbnRpdHlFc2NhcGUoKSB7XG4gICAgICAgIHZhciBaV0ogPSAnXFx1MjAwQyc7XG4gICAgICAgIHZhciBaV05KID0gJ1xcdTIwMEQnO1xuICAgICAgICB2YXIgdG1wO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQobG9va2FoZWFkKCkpKSB7XG4gICAgICAgICAgdG1wID0gaW5jcigpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdpZGVudGlmaWVyJywgdG1wLmNoYXJDb2RlQXQoMCksIHRtcCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKFpXSikpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRXNjYXBlZCgnaWRlbnRpZmllcicsIDB4MjAwQywgWldKKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaChaV05KKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVFc2NhcGVkKCdpZGVudGlmaWVyJywgMHgyMDBELCBaV05KKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyQ2xhc3MoKSB7XG4gICAgICAgIHZhciByZXMsXG4gICAgICAgICAgICBmcm9tID0gcG9zO1xuICAgICAgICBpZiAocmVzID0gbWF0Y2hSZWcoL15cXFtcXF4vKSkge1xuICAgICAgICAgIHJlcyA9IHBhcnNlQ2xhc3NSYW5nZXMoKTtcbiAgICAgICAgICBza2lwKCddJyk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlckNsYXNzKHJlcywgdHJ1ZSwgZnJvbSwgcG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgcmVzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICAgIHNraXAoJ10nKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyQ2xhc3MocmVzLCBmYWxzZSwgZnJvbSwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NSYW5nZXMoKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmIChjdXJyZW50KCddJykpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gcGFyc2VOb25lbXB0eUNsYXNzUmFuZ2VzKCk7XG4gICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIGJhaWwoJ25vbkVtcHR5Q2xhc3NSYW5nZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyc2VIZWxwZXJDbGFzc1JhbmdlcyhhdG9tKSB7XG4gICAgICAgIHZhciBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGlmIChjdXJyZW50KCctJykgJiYgIW5leHQoJ10nKSkge1xuICAgICAgICAgIHNraXAoJy0nKTtcbiAgICAgICAgICByZXMgPSBwYXJzZUNsYXNzQXRvbSgpO1xuICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICBiYWlsKCdjbGFzc0F0b20nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG8gPSBwb3M7XG4gICAgICAgICAgdmFyIGNsYXNzUmFuZ2VzID0gcGFyc2VDbGFzc1JhbmdlcygpO1xuICAgICAgICAgIGlmICghY2xhc3NSYW5nZXMpIHtcbiAgICAgICAgICAgIGJhaWwoJ2NsYXNzUmFuZ2VzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb20gPSBhdG9tLnJhbmdlWzBdO1xuICAgICAgICAgIGlmIChjbGFzc1Jhbmdlcy50eXBlID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNsYXNzUmFuZ2UoYXRvbSwgcmVzLCBmcm9tLCB0byldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNsYXNzUmFuZ2UoYXRvbSwgcmVzLCBmcm9tLCB0byldLmNvbmNhdChjbGFzc1Jhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gcGFyc2VOb25lbXB0eUNsYXNzUmFuZ2VzTm9EYXNoKCk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgYmFpbCgnbm9uRW1wdHlDbGFzc1Jhbmdlc05vRGFzaCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbYXRvbV0uY29uY2F0KHJlcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZU5vbmVtcHR5Q2xhc3NSYW5nZXMoKSB7XG4gICAgICAgIHZhciBhdG9tID0gcGFyc2VDbGFzc0F0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgYmFpbCgnY2xhc3NBdG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQoJ10nKSkge1xuICAgICAgICAgIHJldHVybiBbYXRvbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSGVscGVyQ2xhc3NSYW5nZXMoYXRvbSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2goKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZUNsYXNzQXRvbSgpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgIGJhaWwoJ2NsYXNzQXRvbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50KCddJykpIHtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUhlbHBlckNsYXNzUmFuZ2VzKHJlcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzQXRvbSgpIHtcbiAgICAgICAgaWYgKG1hdGNoKCctJykpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyKCctJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQ2xhc3NBdG9tTm9EYXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3NBdG9tTm9EYXNoKCkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAocmVzID0gbWF0Y2hSZWcoL15bXlxcXFxcXF0tXS8pKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3RlcihyZXNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdcXFxcJykpIHtcbiAgICAgICAgICByZXMgPSBwYXJzZUNsYXNzRXNjYXBlKCk7XG4gICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIGJhaWwoJ2NsYXNzRXNjYXBlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZVVuaWNvZGVTdXJyb2dhdGVQYWlyRXNjYXBlKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhaWwobWVzc2FnZSwgZGV0YWlscywgZnJvbSwgdG8pIHtcbiAgICAgICAgZnJvbSA9IGZyb20gPT0gbnVsbCA/IHBvcyA6IGZyb207XG4gICAgICAgIHRvID0gdG8gPT0gbnVsbCA/IGZyb20gOiB0bztcbiAgICAgICAgdmFyIGNvbnRleHRTdGFydCA9IE1hdGgubWF4KDAsIGZyb20gLSAxMCk7XG4gICAgICAgIHZhciBjb250ZXh0RW5kID0gTWF0aC5taW4odG8gKyAxMCwgc3RyLmxlbmd0aCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gJyAgICAnICsgc3RyLnN1YnN0cmluZyhjb250ZXh0U3RhcnQsIGNvbnRleHRFbmQpO1xuICAgICAgICB2YXIgcG9pbnRlciA9ICcgICAgJyArIG5ldyBBcnJheShmcm9tIC0gY29udGV4dFN0YXJ0ICsgMSkuam9pbignICcpICsgJ14nO1xuICAgICAgICB0aHJvdyBTeW50YXhFcnJvcihtZXNzYWdlICsgJyBhdCBwb3NpdGlvbiAnICsgZnJvbSArIChkZXRhaWxzID8gJzogJyArIGRldGFpbHMgOiAnJykgKyAnXFxuJyArIGNvbnRleHQgKyAnXFxuJyArIHBvaW50ZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGJhY2tyZWZEZW5pZWQgPSBbXTtcbiAgICAgIHZhciBjbG9zZWRDYXB0dXJlQ291bnRlciA9IDA7XG4gICAgICB2YXIgZmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuICAgICAgdmFyIGhhc1VuaWNvZGVGbGFnID0gKGZsYWdzIHx8IFwiXCIpLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICBpZiAoc3RyID09PSAnJykge1xuICAgICAgICBzdHIgPSAnKD86KSc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VEaXNqdW5jdGlvbigpO1xuICAgICAgaWYgKHJlc3VsdC5yYW5nZVsxXSAhPT0gc3RyLmxlbmd0aCkge1xuICAgICAgICBiYWlsKCdDb3VsZCBub3QgcGFyc2UgZW50aXJlIGlucHV0IC0gZ290IHN0dWNrJywgJycsIHJlc3VsdC5yYW5nZVsxXSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhY2tyZWZEZW5pZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJhY2tyZWZEZW5pZWRbaV0gPD0gY2xvc2VkQ2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgIGZpcnN0SXRlcmF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRGlzanVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHJlZ2pzcGFyc2VyID0ge3BhcnNlOiBwYXJzZX07XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJlZ2pzcGFyc2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVnanNwYXJzZXIgPSByZWdqc3BhcnNlcjtcbiAgICB9XG4gIH0oKSk7XG4gIG1vZHVsZXNbJ3JlZ2pzcGFyc2VyJ10gPSBtb2R1bGUuZXhwb3J0cyB8fCB3aW5kb3cucmVnanNwYXJzZXI7XG4gIG1vZHVsZXNbJy4vZGF0YS9pdS1tYXBwaW5ncy5qc29uJ10gPSAoe1xuICAgIFwiNzVcIjogODQ5MCxcbiAgICBcIjgzXCI6IDM4MyxcbiAgICBcIjEwN1wiOiA4NDkwLFxuICAgIFwiMTE1XCI6IDM4MyxcbiAgICBcIjE4MVwiOiA5MjQsXG4gICAgXCIxOTdcIjogODQ5MSxcbiAgICBcIjM4M1wiOiA4MyxcbiAgICBcIjQ1MlwiOiA0NTMsXG4gICAgXCI0NTNcIjogNDUyLFxuICAgIFwiNDU1XCI6IDQ1NixcbiAgICBcIjQ1NlwiOiA0NTUsXG4gICAgXCI0NThcIjogNDU5LFxuICAgIFwiNDU5XCI6IDQ1OCxcbiAgICBcIjQ5N1wiOiA0OTgsXG4gICAgXCI0OThcIjogNDk3LFxuICAgIFwiODM3XCI6IDgxMjYsXG4gICAgXCI5MTRcIjogOTc2LFxuICAgIFwiOTE3XCI6IDEwMTMsXG4gICAgXCI5MjBcIjogMTAxMixcbiAgICBcIjkyMVwiOiA4MTI2LFxuICAgIFwiOTIyXCI6IDEwMDgsXG4gICAgXCI5MjRcIjogMTgxLFxuICAgIFwiOTI4XCI6IDk4MixcbiAgICBcIjkyOVwiOiAxMDA5LFxuICAgIFwiOTMxXCI6IDk2MixcbiAgICBcIjkzNFwiOiA5ODEsXG4gICAgXCI5MzdcIjogODQ4NixcbiAgICBcIjk2MlwiOiA5MzEsXG4gICAgXCI5NzZcIjogOTE0LFxuICAgIFwiOTc3XCI6IDEwMTIsXG4gICAgXCI5ODFcIjogOTM0LFxuICAgIFwiOTgyXCI6IDkyOCxcbiAgICBcIjEwMDhcIjogOTIyLFxuICAgIFwiMTAwOVwiOiA5MjksXG4gICAgXCIxMDEyXCI6IFs5MjAsIDk3N10sXG4gICAgXCIxMDEzXCI6IDkxNyxcbiAgICBcIjc3NzZcIjogNzgzNSxcbiAgICBcIjc4MzVcIjogNzc3NixcbiAgICBcIjgxMjZcIjogWzgzNywgOTIxXSxcbiAgICBcIjg0ODZcIjogOTM3LFxuICAgIFwiODQ5MFwiOiA3NSxcbiAgICBcIjg0OTFcIjogMTk3LFxuICAgIFwiNjY1NjBcIjogNjY2MDAsXG4gICAgXCI2NjU2MVwiOiA2NjYwMSxcbiAgICBcIjY2NTYyXCI6IDY2NjAyLFxuICAgIFwiNjY1NjNcIjogNjY2MDMsXG4gICAgXCI2NjU2NFwiOiA2NjYwNCxcbiAgICBcIjY2NTY1XCI6IDY2NjA1LFxuICAgIFwiNjY1NjZcIjogNjY2MDYsXG4gICAgXCI2NjU2N1wiOiA2NjYwNyxcbiAgICBcIjY2NTY4XCI6IDY2NjA4LFxuICAgIFwiNjY1NjlcIjogNjY2MDksXG4gICAgXCI2NjU3MFwiOiA2NjYxMCxcbiAgICBcIjY2NTcxXCI6IDY2NjExLFxuICAgIFwiNjY1NzJcIjogNjY2MTIsXG4gICAgXCI2NjU3M1wiOiA2NjYxMyxcbiAgICBcIjY2NTc0XCI6IDY2NjE0LFxuICAgIFwiNjY1NzVcIjogNjY2MTUsXG4gICAgXCI2NjU3NlwiOiA2NjYxNixcbiAgICBcIjY2NTc3XCI6IDY2NjE3LFxuICAgIFwiNjY1NzhcIjogNjY2MTgsXG4gICAgXCI2NjU3OVwiOiA2NjYxOSxcbiAgICBcIjY2NTgwXCI6IDY2NjIwLFxuICAgIFwiNjY1ODFcIjogNjY2MjEsXG4gICAgXCI2NjU4MlwiOiA2NjYyMixcbiAgICBcIjY2NTgzXCI6IDY2NjIzLFxuICAgIFwiNjY1ODRcIjogNjY2MjQsXG4gICAgXCI2NjU4NVwiOiA2NjYyNSxcbiAgICBcIjY2NTg2XCI6IDY2NjI2LFxuICAgIFwiNjY1ODdcIjogNjY2MjcsXG4gICAgXCI2NjU4OFwiOiA2NjYyOCxcbiAgICBcIjY2NTg5XCI6IDY2NjI5LFxuICAgIFwiNjY1OTBcIjogNjY2MzAsXG4gICAgXCI2NjU5MVwiOiA2NjYzMSxcbiAgICBcIjY2NTkyXCI6IDY2NjMyLFxuICAgIFwiNjY1OTNcIjogNjY2MzMsXG4gICAgXCI2NjU5NFwiOiA2NjYzNCxcbiAgICBcIjY2NTk1XCI6IDY2NjM1LFxuICAgIFwiNjY1OTZcIjogNjY2MzYsXG4gICAgXCI2NjU5N1wiOiA2NjYzNyxcbiAgICBcIjY2NTk4XCI6IDY2NjM4LFxuICAgIFwiNjY1OTlcIjogNjY2MzksXG4gICAgXCI2NjYwMFwiOiA2NjU2MCxcbiAgICBcIjY2NjAxXCI6IDY2NTYxLFxuICAgIFwiNjY2MDJcIjogNjY1NjIsXG4gICAgXCI2NjYwM1wiOiA2NjU2MyxcbiAgICBcIjY2NjA0XCI6IDY2NTY0LFxuICAgIFwiNjY2MDVcIjogNjY1NjUsXG4gICAgXCI2NjYwNlwiOiA2NjU2NixcbiAgICBcIjY2NjA3XCI6IDY2NTY3LFxuICAgIFwiNjY2MDhcIjogNjY1NjgsXG4gICAgXCI2NjYwOVwiOiA2NjU2OSxcbiAgICBcIjY2NjEwXCI6IDY2NTcwLFxuICAgIFwiNjY2MTFcIjogNjY1NzEsXG4gICAgXCI2NjYxMlwiOiA2NjU3MixcbiAgICBcIjY2NjEzXCI6IDY2NTczLFxuICAgIFwiNjY2MTRcIjogNjY1NzQsXG4gICAgXCI2NjYxNVwiOiA2NjU3NSxcbiAgICBcIjY2NjE2XCI6IDY2NTc2LFxuICAgIFwiNjY2MTdcIjogNjY1NzcsXG4gICAgXCI2NjYxOFwiOiA2NjU3OCxcbiAgICBcIjY2NjE5XCI6IDY2NTc5LFxuICAgIFwiNjY2MjBcIjogNjY1ODAsXG4gICAgXCI2NjYyMVwiOiA2NjU4MSxcbiAgICBcIjY2NjIyXCI6IDY2NTgyLFxuICAgIFwiNjY2MjNcIjogNjY1ODMsXG4gICAgXCI2NjYyNFwiOiA2NjU4NCxcbiAgICBcIjY2NjI1XCI6IDY2NTg1LFxuICAgIFwiNjY2MjZcIjogNjY1ODYsXG4gICAgXCI2NjYyN1wiOiA2NjU4NyxcbiAgICBcIjY2NjI4XCI6IDY2NTg4LFxuICAgIFwiNjY2MjlcIjogNjY1ODksXG4gICAgXCI2NjYzMFwiOiA2NjU5MCxcbiAgICBcIjY2NjMxXCI6IDY2NTkxLFxuICAgIFwiNjY2MzJcIjogNjY1OTIsXG4gICAgXCI2NjYzM1wiOiA2NjU5MyxcbiAgICBcIjY2NjM0XCI6IDY2NTk0LFxuICAgIFwiNjY2MzVcIjogNjY1OTUsXG4gICAgXCI2NjYzNlwiOiA2NjU5NixcbiAgICBcIjY2NjM3XCI6IDY2NTk3LFxuICAgIFwiNjY2MzhcIjogNjY1OTgsXG4gICAgXCI2NjYzOVwiOiA2NjU5OSxcbiAgICBcIjcxODQwXCI6IDcxODcyLFxuICAgIFwiNzE4NDFcIjogNzE4NzMsXG4gICAgXCI3MTg0MlwiOiA3MTg3NCxcbiAgICBcIjcxODQzXCI6IDcxODc1LFxuICAgIFwiNzE4NDRcIjogNzE4NzYsXG4gICAgXCI3MTg0NVwiOiA3MTg3NyxcbiAgICBcIjcxODQ2XCI6IDcxODc4LFxuICAgIFwiNzE4NDdcIjogNzE4NzksXG4gICAgXCI3MTg0OFwiOiA3MTg4MCxcbiAgICBcIjcxODQ5XCI6IDcxODgxLFxuICAgIFwiNzE4NTBcIjogNzE4ODIsXG4gICAgXCI3MTg1MVwiOiA3MTg4MyxcbiAgICBcIjcxODUyXCI6IDcxODg0LFxuICAgIFwiNzE4NTNcIjogNzE4ODUsXG4gICAgXCI3MTg1NFwiOiA3MTg4NixcbiAgICBcIjcxODU1XCI6IDcxODg3LFxuICAgIFwiNzE4NTZcIjogNzE4ODgsXG4gICAgXCI3MTg1N1wiOiA3MTg4OSxcbiAgICBcIjcxODU4XCI6IDcxODkwLFxuICAgIFwiNzE4NTlcIjogNzE4OTEsXG4gICAgXCI3MTg2MFwiOiA3MTg5MixcbiAgICBcIjcxODYxXCI6IDcxODkzLFxuICAgIFwiNzE4NjJcIjogNzE4OTQsXG4gICAgXCI3MTg2M1wiOiA3MTg5NSxcbiAgICBcIjcxODY0XCI6IDcxODk2LFxuICAgIFwiNzE4NjVcIjogNzE4OTcsXG4gICAgXCI3MTg2NlwiOiA3MTg5OCxcbiAgICBcIjcxODY3XCI6IDcxODk5LFxuICAgIFwiNzE4NjhcIjogNzE5MDAsXG4gICAgXCI3MTg2OVwiOiA3MTkwMSxcbiAgICBcIjcxODcwXCI6IDcxOTAyLFxuICAgIFwiNzE4NzFcIjogNzE5MDMsXG4gICAgXCI3MTg3MlwiOiA3MTg0MCxcbiAgICBcIjcxODczXCI6IDcxODQxLFxuICAgIFwiNzE4NzRcIjogNzE4NDIsXG4gICAgXCI3MTg3NVwiOiA3MTg0MyxcbiAgICBcIjcxODc2XCI6IDcxODQ0LFxuICAgIFwiNzE4NzdcIjogNzE4NDUsXG4gICAgXCI3MTg3OFwiOiA3MTg0NixcbiAgICBcIjcxODc5XCI6IDcxODQ3LFxuICAgIFwiNzE4ODBcIjogNzE4NDgsXG4gICAgXCI3MTg4MVwiOiA3MTg0OSxcbiAgICBcIjcxODgyXCI6IDcxODUwLFxuICAgIFwiNzE4ODNcIjogNzE4NTEsXG4gICAgXCI3MTg4NFwiOiA3MTg1MixcbiAgICBcIjcxODg1XCI6IDcxODUzLFxuICAgIFwiNzE4ODZcIjogNzE4NTQsXG4gICAgXCI3MTg4N1wiOiA3MTg1NSxcbiAgICBcIjcxODg4XCI6IDcxODU2LFxuICAgIFwiNzE4ODlcIjogNzE4NTcsXG4gICAgXCI3MTg5MFwiOiA3MTg1OCxcbiAgICBcIjcxODkxXCI6IDcxODU5LFxuICAgIFwiNzE4OTJcIjogNzE4NjAsXG4gICAgXCI3MTg5M1wiOiA3MTg2MSxcbiAgICBcIjcxODk0XCI6IDcxODYyLFxuICAgIFwiNzE4OTVcIjogNzE4NjMsXG4gICAgXCI3MTg5NlwiOiA3MTg2NCxcbiAgICBcIjcxODk3XCI6IDcxODY1LFxuICAgIFwiNzE4OThcIjogNzE4NjYsXG4gICAgXCI3MTg5OVwiOiA3MTg2NyxcbiAgICBcIjcxOTAwXCI6IDcxODY4LFxuICAgIFwiNzE5MDFcIjogNzE4NjksXG4gICAgXCI3MTkwMlwiOiA3MTg3MCxcbiAgICBcIjcxOTAzXCI6IDcxODcxXG4gIH0pO1xuICB2YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoJ3JlZ2VuZXJhdGUnKTtcbiAgZXhwb3J0cy5SRUdVTEFSID0ge1xuICAgICdkJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MzAsIDB4MzkpLFxuICAgICdEJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHgyRikuYWRkUmFuZ2UoMHgzQSwgMHhGRkZGKSxcbiAgICAncyc6IHJlZ2VuZXJhdGUoMHgyMCwgMHhBMCwgMHgxNjgwLCAweDE4MEUsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRikuYWRkUmFuZ2UoMHg5LCAweEQpLmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKS5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG4gICAgJ1MnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweDgpLmFkZFJhbmdlKDB4RSwgMHgxRikuYWRkUmFuZ2UoMHgyMSwgMHg5RikuYWRkUmFuZ2UoMHhBMSwgMHgxNjdGKS5hZGRSYW5nZSgweDE2ODEsIDB4MTgwRCkuYWRkUmFuZ2UoMHgxODBGLCAweDFGRkYpLmFkZFJhbmdlKDB4MjAwQiwgMHgyMDI3KS5hZGRSYW5nZSgweDIwMkEsIDB4MjAyRSkuYWRkUmFuZ2UoMHgyMDMwLCAweDIwNUUpLmFkZFJhbmdlKDB4MjA2MCwgMHgyRkZGKS5hZGRSYW5nZSgweDMwMDEsIDB4RkVGRSkuYWRkUmFuZ2UoMHhGRjAwLCAweEZGRkYpLFxuICAgICd3JzogcmVnZW5lcmF0ZSgweDVGKS5hZGRSYW5nZSgweDMwLCAweDM5KS5hZGRSYW5nZSgweDQxLCAweDVBKS5hZGRSYW5nZSgweDYxLCAweDdBKSxcbiAgICAnVyc6IHJlZ2VuZXJhdGUoMHg2MCkuYWRkUmFuZ2UoMHgwLCAweDJGKS5hZGRSYW5nZSgweDNBLCAweDQwKS5hZGRSYW5nZSgweDVCLCAweDVFKS5hZGRSYW5nZSgweDdCLCAweEZGRkYpXG4gIH07XG4gIGV4cG9ydHMuVU5JQ09ERSA9IHtcbiAgICAnZCc6IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDMwLCAweDM5KSxcbiAgICAnRCc6IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4MkYpLmFkZFJhbmdlKDB4M0EsIDB4MTBGRkZGKSxcbiAgICAncyc6IHJlZ2VuZXJhdGUoMHgyMCwgMHhBMCwgMHgxNjgwLCAweDE4MEUsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRikuYWRkUmFuZ2UoMHg5LCAweEQpLmFkZFJhbmdlKDB4MjAwMCwgMHgyMDBBKS5hZGRSYW5nZSgweDIwMjgsIDB4MjAyOSksXG4gICAgJ1MnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweDgpLmFkZFJhbmdlKDB4RSwgMHgxRikuYWRkUmFuZ2UoMHgyMSwgMHg5RikuYWRkUmFuZ2UoMHhBMSwgMHgxNjdGKS5hZGRSYW5nZSgweDE2ODEsIDB4MTgwRCkuYWRkUmFuZ2UoMHgxODBGLCAweDFGRkYpLmFkZFJhbmdlKDB4MjAwQiwgMHgyMDI3KS5hZGRSYW5nZSgweDIwMkEsIDB4MjAyRSkuYWRkUmFuZ2UoMHgyMDMwLCAweDIwNUUpLmFkZFJhbmdlKDB4MjA2MCwgMHgyRkZGKS5hZGRSYW5nZSgweDMwMDEsIDB4RkVGRSkuYWRkUmFuZ2UoMHhGRjAwLCAweDEwRkZGRiksXG4gICAgJ3cnOiByZWdlbmVyYXRlKDB4NUYpLmFkZFJhbmdlKDB4MzAsIDB4MzkpLmFkZFJhbmdlKDB4NDEsIDB4NUEpLmFkZFJhbmdlKDB4NjEsIDB4N0EpLFxuICAgICdXJzogcmVnZW5lcmF0ZSgweDYwKS5hZGRSYW5nZSgweDAsIDB4MkYpLmFkZFJhbmdlKDB4M0EsIDB4NDApLmFkZFJhbmdlKDB4NUIsIDB4NUUpLmFkZFJhbmdlKDB4N0IsIDB4MTBGRkZGKVxuICB9O1xuICBleHBvcnRzLlVOSUNPREVfSUdOT1JFX0NBU0UgPSB7XG4gICAgJ2QnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgzMCwgMHgzOSksXG4gICAgJ0QnOiByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweDJGKS5hZGRSYW5nZSgweDNBLCAweDEwRkZGRiksXG4gICAgJ3MnOiByZWdlbmVyYXRlKDB4MjAsIDB4QTAsIDB4MTY4MCwgMHgxODBFLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkYpLmFkZFJhbmdlKDB4OSwgMHhEKS5hZGRSYW5nZSgweDIwMDAsIDB4MjAwQSkuYWRkUmFuZ2UoMHgyMDI4LCAweDIwMjkpLFxuICAgICdTJzogcmVnZW5lcmF0ZSgpLmFkZFJhbmdlKDB4MCwgMHg4KS5hZGRSYW5nZSgweEUsIDB4MUYpLmFkZFJhbmdlKDB4MjEsIDB4OUYpLmFkZFJhbmdlKDB4QTEsIDB4MTY3RikuYWRkUmFuZ2UoMHgxNjgxLCAweDE4MEQpLmFkZFJhbmdlKDB4MTgwRiwgMHgxRkZGKS5hZGRSYW5nZSgweDIwMEIsIDB4MjAyNykuYWRkUmFuZ2UoMHgyMDJBLCAweDIwMkUpLmFkZFJhbmdlKDB4MjAzMCwgMHgyMDVFKS5hZGRSYW5nZSgweDIwNjAsIDB4MkZGRikuYWRkUmFuZ2UoMHgzMDAxLCAweEZFRkUpLmFkZFJhbmdlKDB4RkYwMCwgMHgxMEZGRkYpLFxuICAgICd3JzogcmVnZW5lcmF0ZSgweDVGLCAweDE3RiwgMHgyMTJBKS5hZGRSYW5nZSgweDMwLCAweDM5KS5hZGRSYW5nZSgweDQxLCAweDVBKS5hZGRSYW5nZSgweDYxLCAweDdBKSxcbiAgICAnVyc6IHJlZ2VuZXJhdGUoMHg0QiwgMHg1MywgMHg2MCkuYWRkUmFuZ2UoMHgwLCAweDJGKS5hZGRSYW5nZSgweDNBLCAweDQwKS5hZGRSYW5nZSgweDVCLCAweDVFKS5hZGRSYW5nZSgweDdCLCAweDEwRkZGRilcbiAgfTtcbiAgbW9kdWxlc1snLi9kYXRhL2NoYXJhY3Rlci1jbGFzcy1lc2NhcGUtc2V0cy5qcyddID0ge1xuICAgIFJFR1VMQVI6IGV4cG9ydHMuUkVHVUxBUixcbiAgICBVTklDT0RFOiBleHBvcnRzLlVOSUNPREUsXG4gICAgVU5JQ09ERV9JR05PUkVfQ0FTRTogZXhwb3J0cy5VTklDT0RFX0lHTk9SRV9DQVNFXG4gIH07XG4gIHZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoJ3JlZ2pzZ2VuJykuZ2VuZXJhdGU7XG4gIHZhciBwYXJzZSA9IHJlcXVpcmUoJ3JlZ2pzcGFyc2VyJykucGFyc2U7XG4gIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSgncmVnZW5lcmF0ZScpO1xuICB2YXIgaXVNYXBwaW5ncyA9IHJlcXVpcmUoJy4vZGF0YS9pdS1tYXBwaW5ncy5qc29uJyk7XG4gIHZhciBFU0NBUEVfU0VUUyA9IHJlcXVpcmUoJy4vZGF0YS9jaGFyYWN0ZXItY2xhc3MtZXNjYXBlLXNldHMuanMnKTtcbiAgZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXQoY2hhcmFjdGVyKSB7XG4gICAgaWYgKHVuaWNvZGUpIHtcbiAgICAgIGlmIChpZ25vcmVDYXNlKSB7XG4gICAgICAgIHJldHVybiBFU0NBUEVfU0VUUy5VTklDT0RFX0lHTk9SRV9DQVNFW2NoYXJhY3Rlcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gRVNDQVBFX1NFVFMuVU5JQ09ERVtjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gRVNDQVBFX1NFVFMuUkVHVUxBUltjaGFyYWN0ZXJdO1xuICB9XG4gIHZhciBvYmplY3QgPSB7fTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICB9XG4gIHZhciBVTklDT0RFX1NFVCA9IHJlZ2VuZXJhdGUoKS5hZGRSYW5nZSgweDAsIDB4MTBGRkZGKTtcbiAgdmFyIEJNUF9TRVQgPSByZWdlbmVyYXRlKCkuYWRkUmFuZ2UoMHgwLCAweEZGRkYpO1xuICB2YXIgRE9UX1NFVF9VTklDT0RFID0gVU5JQ09ERV9TRVQuY2xvbmUoKS5yZW1vdmUoMHgwMDBBLCAweDAwMEQsIDB4MjAyOCwgMHgyMDI5KTtcbiAgdmFyIERPVF9TRVQgPSBET1RfU0VUX1VOSUNPREUuY2xvbmUoKS5pbnRlcnNlY3Rpb24oQk1QX1NFVCk7XG4gIHJlZ2VuZXJhdGUucHJvdG90eXBlLml1QWRkUmFuZ2UgPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgdmFyIGZvbGRlZCA9IGNhc2VGb2xkKG1pbik7XG4gICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICR0aGlzLmFkZChmb2xkZWQpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCsrbWluIDw9IG1heCk7XG4gICAgcmV0dXJuICR0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGUoaXRlbSwgcGF0dGVybikge1xuICAgIHZhciB0cmVlID0gcGFyc2UocGF0dGVybiwgJycpO1xuICAgIHN3aXRjaCAodHJlZS50eXBlKSB7XG4gICAgICBjYXNlICdjaGFyYWN0ZXJDbGFzcyc6XG4gICAgICBjYXNlICdncm91cCc6XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdHJlZSA9IHdyYXAodHJlZSwgcGF0dGVybik7XG4gICAgfVxuICAgIGFzc2lnbihpdGVtLCB0cmVlKTtcbiAgfVxuICBmdW5jdGlvbiB3cmFwKHRyZWUsIHBhdHRlcm4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3R5cGUnOiAnZ3JvdXAnLFxuICAgICAgJ2JlaGF2aW9yJzogJ2lnbm9yZScsXG4gICAgICAnYm9keSc6IFt0cmVlXSxcbiAgICAgICdyYXcnOiAnKD86JyArIHBhdHRlcm4gKyAnKSdcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNhc2VGb2xkKGNvZGVQb2ludCkge1xuICAgIHJldHVybiBoYXMoaXVNYXBwaW5ncywgY29kZVBvaW50KSA/IGl1TWFwcGluZ3NbY29kZVBvaW50XSA6IGZhbHNlO1xuICB9XG4gIHZhciBpZ25vcmVDYXNlID0gZmFsc2U7XG4gIHZhciB1bmljb2RlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHByb2Nlc3NDaGFyYWN0ZXJDbGFzcyhjaGFyYWN0ZXJDbGFzc0l0ZW0pIHtcbiAgICB2YXIgc2V0ID0gcmVnZW5lcmF0ZSgpO1xuICAgIHZhciBib2R5ID0gY2hhcmFjdGVyQ2xhc3NJdGVtLmJvZHkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgc2V0LmFkZChpdGVtLmNvZGVQb2ludCk7XG4gICAgICAgICAgaWYgKGlnbm9yZUNhc2UgJiYgdW5pY29kZSkge1xuICAgICAgICAgICAgdmFyIGZvbGRlZCA9IGNhc2VGb2xkKGl0ZW0uY29kZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgICAgc2V0LmFkZChmb2xkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hhcmFjdGVyQ2xhc3NSYW5nZSc6XG4gICAgICAgICAgdmFyIG1pbiA9IGl0ZW0ubWluLmNvZGVQb2ludDtcbiAgICAgICAgICB2YXIgbWF4ID0gaXRlbS5tYXguY29kZVBvaW50O1xuICAgICAgICAgIHNldC5hZGRSYW5nZShtaW4sIG1heCk7XG4gICAgICAgICAgaWYgKGlnbm9yZUNhc2UgJiYgdW5pY29kZSkge1xuICAgICAgICAgICAgc2V0Lml1QWRkUmFuZ2UobWluLCBtYXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hhcmFjdGVyQ2xhc3NFc2NhcGUnOlxuICAgICAgICAgIHNldC5hZGQoZ2V0Q2hhcmFjdGVyQ2xhc3NFc2NhcGVTZXQoaXRlbS52YWx1ZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIHRlcm0gdHlwZTogJyArIGl0ZW0udHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGNoYXJhY3RlckNsYXNzSXRlbS5uZWdhdGl2ZSkge1xuICAgICAgc2V0ID0gKHVuaWNvZGUgPyBVTklDT0RFX1NFVCA6IEJNUF9TRVQpLmNsb25lKCkucmVtb3ZlKHNldCk7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFyYWN0ZXJDbGFzc0l0ZW0sIHNldC50b1N0cmluZygpKTtcbiAgICByZXR1cm4gY2hhcmFjdGVyQ2xhc3NJdGVtO1xuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NUZXJtKGl0ZW0pIHtcbiAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xuICAgICAgY2FzZSAnZG90JzpcbiAgICAgICAgdXBkYXRlKGl0ZW0sICh1bmljb2RlID8gRE9UX1NFVF9VTklDT0RFIDogRE9UX1NFVCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hhcmFjdGVyQ2xhc3MnOlxuICAgICAgICBpdGVtID0gcHJvY2Vzc0NoYXJhY3RlckNsYXNzKGl0ZW0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NoYXJhY3RlckNsYXNzRXNjYXBlJzpcbiAgICAgICAgdXBkYXRlKGl0ZW0sIGdldENoYXJhY3RlckNsYXNzRXNjYXBlU2V0KGl0ZW0udmFsdWUpLnRvU3RyaW5nKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FsdGVybmF0aXZlJzpcbiAgICAgIGNhc2UgJ2Rpc2p1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ2dyb3VwJzpcbiAgICAgIGNhc2UgJ3F1YW50aWZpZXInOlxuICAgICAgICBpdGVtLmJvZHkgPSBpdGVtLmJvZHkubWFwKHByb2Nlc3NUZXJtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBpdGVtLmNvZGVQb2ludDtcbiAgICAgICAgdmFyIHNldCA9IHJlZ2VuZXJhdGUoY29kZVBvaW50KTtcbiAgICAgICAgaWYgKGlnbm9yZUNhc2UgJiYgdW5pY29kZSkge1xuICAgICAgICAgIHZhciBmb2xkZWQgPSBjYXNlRm9sZChjb2RlUG9pbnQpO1xuICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgIHNldC5hZGQoZm9sZGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKGl0ZW0sIHNldC50b1N0cmluZygpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbmNob3InOlxuICAgICAgY2FzZSAnZW1wdHknOlxuICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0ZXJtIHR5cGU6ICcgKyBpdGVtLnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuICA7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdHJlZSA9IHBhcnNlKHBhdHRlcm4sIGZsYWdzKTtcbiAgICBpZ25vcmVDYXNlID0gZmxhZ3MgPyBmbGFncy5pbmRleE9mKCdpJykgPiAtMSA6IGZhbHNlO1xuICAgIHVuaWNvZGUgPSBmbGFncyA/IGZsYWdzLmluZGV4T2YoJ3UnKSA+IC0xIDogZmFsc2U7XG4gICAgYXNzaWduKHRyZWUsIHByb2Nlc3NUZXJtKHRyZWUpKTtcbiAgICByZXR1cm4gZ2VuZXJhdGUodHJlZSk7XG4gIH07XG4gIHZhciByZWdleHB1UmV3cml0ZVBhdHRlcm4gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIHtnZXQgcmVnZXhwdVJld3JpdGVQYXR0ZXJuKCkge1xuICAgICAgcmV0dXJuIHJlZ2V4cHVSZXdyaXRlUGF0dGVybjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZWd1bGFyRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBMaXRlcmFsRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSkuTGl0ZXJhbEV4cHJlc3Npb247XG4gIHZhciBMaXRlcmFsVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSkuTGl0ZXJhbFRva2VuO1xuICB2YXIgUkVHVUxBUl9FWFBSRVNTSU9OID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1JlZ3VsYXJFeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIikpLlJFR1VMQVJfRVhQUkVTU0lPTjtcbiAgdmFyIHJlZ2V4cHVSZXdyaXRlUGF0dGVybiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9vdXRwdXRnZW5lcmF0aW9uL3JlZ2V4cHVSZXdyaXRlUGF0dGVybi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lci5qc1wiKSkucmVnZXhwdVJld3JpdGVQYXR0ZXJuO1xuICB2YXIgUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFJlZ3VsYXJFeHByZXNzaW9uVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSZWd1bGFyRXhwcmVzc2lvblRyYW5zZm9ybWVyLCB7dHJhbnNmb3JtTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdHJlZS5saXRlcmFsVG9rZW47XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBSRUdVTEFSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IHZhbHVlLnNsaWNlKDEsIGxhc3RJbmRleCk7XG4gICAgICAgICAgdmFyIGZsYWdzID0gdmFsdWUuc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnLycgKyByZWdleHB1UmV3cml0ZVBhdHRlcm4ocGF0dGVybiwgZmxhZ3MpICsgJy8nICsgZmxhZ3MucmVwbGFjZSgndScsICcnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbmV3IExpdGVyYWxUb2tlbihSRUdVTEFSX0VYUFJFU1NJT04sIHJlc3VsdCwgdG9rZW4ubG9jYXRpb24pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IFJlZ3VsYXJFeHByZXNzaW9uVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gUmVndWxhckV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEZvcm1hbFBhcmFtZXRlckxpc3QgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiKSkuRm9ybWFsUGFyYW1ldGVyTGlzdDtcbiAgdmFyIFBhcmFtZXRlclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiKSkuUGFyYW1ldGVyVHJhbnNmb3JtZXI7XG4gIHZhciBjcmVhdGVJZGVudGlmaWVyVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9SZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXIuanNcIikpLmNyZWF0ZUlkZW50aWZpZXJUb2tlbjtcbiAgdmFyIHBhcnNlU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1Jlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VTdGF0ZW1lbnQ7XG4gIGZ1bmN0aW9uIGhhc1Jlc3RQYXJhbWV0ZXIocGFyYW1ldGVyTGlzdCkge1xuICAgIHZhciBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyTGlzdC5wYXJhbWV0ZXJzO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDAgJiYgcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdLmlzUmVzdFBhcmFtZXRlcigpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlc3RQYXJhbWV0ZXJMaXRlcmFsVG9rZW4ocGFyYW1ldGVyTGlzdCkge1xuICAgIHZhciBwYXJhbWV0ZXJzID0gcGFyYW1ldGVyTGlzdC5wYXJhbWV0ZXJzO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV0ucGFyYW1ldGVyLmlkZW50aWZpZXIuaWRlbnRpZmllclRva2VuO1xuICB9XG4gIHZhciBSZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFJlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFJlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFJlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lciwge3RyYW5zZm9ybUZvcm1hbFBhcmFtZXRlckxpc3Q6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFJlc3RQYXJhbWV0ZXJUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtRm9ybWFsUGFyYW1ldGVyTGlzdFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICBpZiAoaGFzUmVzdFBhcmFtZXRlcih0cmFuc2Zvcm1lZCkpIHtcbiAgICAgICAgICB2YXIgcGFyYW1ldGVyc1dpdGhvdXRSZXN0UGFyYW0gPSBuZXcgRm9ybWFsUGFyYW1ldGVyTGlzdCh0cmFuc2Zvcm1lZC5sb2NhdGlvbiwgdHJhbnNmb3JtZWQucGFyYW1ldGVycy5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdHJhbnNmb3JtZWQucGFyYW1ldGVycy5sZW5ndGggLSAxO1xuICAgICAgICAgIHZhciBpID0gY3JlYXRlSWRlbnRpZmllclRva2VuKHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKSk7XG4gICAgICAgICAgdmFyIG5hbWUgPSBnZXRSZXN0UGFyYW1ldGVyTGl0ZXJhbFRva2VuKHRyYW5zZm9ybWVkKTtcbiAgICAgICAgICB2YXIgbG9vcDtcbiAgICAgICAgICBpZiAoc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgbG9vcCA9IHBhcnNlU3RhdGVtZW50KCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICBmb3IgKHZhciBcIiwgXCIgPSBbXSwgXCIsIFwiID0gXCIsIFwiO1xcbiAgICAgICAgICAgICAgICAgXCIsIFwiIDwgYXJndW1lbnRzLmxlbmd0aDsgXCIsIFwiKyspXFxuICAgICAgICAgICAgICBcIiwgXCJbXCIsIFwiIC0gXCIsIFwiXSA9IGFyZ3VtZW50c1tcIiwgXCJdO1wiXSksIG5hbWUsIGksIHN0YXJ0SW5kZXgsIGksIGksIG5hbWUsIGksIHN0YXJ0SW5kZXgsIGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29wID0gcGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgIGZvciAodmFyIFwiLCBcIiA9IFtdLCBcIiwgXCIgPSAwO1xcbiAgICAgICAgICAgICAgICAgXCIsIFwiIDwgYXJndW1lbnRzLmxlbmd0aDsgXCIsIFwiKyspXFxuICAgICAgICAgICAgICBcIiwgXCJbXCIsIFwiXSA9IGFyZ3VtZW50c1tcIiwgXCJdO1wiXSksIG5hbWUsIGksIGksIGksIG5hbWUsIGksIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBhcmFtZXRlclN0YXRlbWVudHMucHVzaChsb29wKTtcbiAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1dpdGhvdXRSZXN0UGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyYW1ldGVyVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBSZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gUmVzdFBhcmFtZXRlclRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1NwcmVhZFRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1ByZWRlZmluZWROYW1lLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBUFBMWSA9ICRfXzMuQVBQTFksXG4gICAgICBCSU5EID0gJF9fMy5CSU5ELFxuICAgICAgRlVOQ1RJT04gPSAkX18zLkZVTkNUSU9OLFxuICAgICAgUFJPVE9UWVBFID0gJF9fMy5QUk9UT1RZUEU7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBNRU1CRVJfRVhQUkVTU0lPTiA9ICRfXzQuTUVNQkVSX0VYUFJFU1NJT04sXG4gICAgICBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPSAkX180Lk1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTixcbiAgICAgIFNQUkVBRF9FWFBSRVNTSU9OID0gJF9fNC5TUFJFQURfRVhQUkVTU0lPTjtcbiAgdmFyIFNjcmlwdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkVHJhbnNmb3JtZXIuanNcIikpLlNjcmlwdDtcbiAgdmFyIFRlbXBWYXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1RlbXBWYXJUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkVHJhbnNmb3JtZXIuanNcIikpLlRlbXBWYXJUcmFuc2Zvcm1lcjtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX184ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ByZWFkVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXJndW1lbnRMaXN0ID0gJF9fOC5jcmVhdGVBcmd1bWVudExpc3QsXG4gICAgICBjcmVhdGVBcnJheUxpdGVyYWwgPSAkX184LmNyZWF0ZUFycmF5TGl0ZXJhbCxcbiAgICAgIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVDYWxsRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUVtcHR5QXJndW1lbnRMaXN0ID0gJF9fOC5jcmVhdGVFbXB0eUFyZ3VtZW50TGlzdCxcbiAgICAgIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU1lbWJlckV4cHJlc3Npb24gPSAkX184LmNyZWF0ZU1lbWJlckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fOC5jcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTmV3RXhwcmVzc2lvbiA9ICRfXzguY3JlYXRlTmV3RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU51bGxMaXRlcmFsID0gJF9fOC5jcmVhdGVOdWxsTGl0ZXJhbCxcbiAgICAgIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbiA9ICRfXzguY3JlYXRlUGFyZW5FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlVm9pZDAgPSAkX184LmNyZWF0ZVZvaWQwO1xuICB2YXIgJF9fOSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TcHJlYWRUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBwYXJzZUV4cHJlc3Npb24gPSAkX185LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlU3RhdGVtZW50ID0gJF9fOS5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIHByZXBlbmRTdGF0ZW1lbnRzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUHJlcGVuZFN0YXRlbWVudHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1NwcmVhZFRyYW5zZm9ybWVyLmpzXCIpKS5wcmVwZW5kU3RhdGVtZW50cztcbiAgZnVuY3Rpb24gaGFzU3ByZWFkTWVtYmVyKHRyZWVzKSB7XG4gICAgcmV0dXJuIHRyZWVzLnNvbWUoZnVuY3Rpb24odHJlZSkge1xuICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS50eXBlID09PSBTUFJFQURfRVhQUkVTU0lPTjtcbiAgICB9KTtcbiAgfVxuICB2YXIgU3ByZWFkVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFNwcmVhZFRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3ByZWFkVHJhbnNmb3JtZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTcHJlYWRUcmFuc2Zvcm1lciwge1xuICAgICAgY3JlYXRlQXJyYXlGcm9tRWxlbWVudHNfOiBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICB2YXIgbGFzdEFycmF5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzW2ldICYmIGVsZW1lbnRzW2ldLnR5cGUgPT09IFNQUkVBRF9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgICBpZiAobGFzdEFycmF5KSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChjcmVhdGVBcnJheUxpdGVyYWwobGFzdEFycmF5KSk7XG4gICAgICAgICAgICAgIGxhc3RBcnJheSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy50cmFuc2Zvcm1BbnkoZWxlbWVudHNbaV0uZXhwcmVzc2lvbikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWxhc3RBcnJheSlcbiAgICAgICAgICAgICAgbGFzdEFycmF5ID0gW107XG4gICAgICAgICAgICBsYXN0QXJyYXkucHVzaCh0aGlzLnRyYW5zZm9ybUFueShlbGVtZW50c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEFycmF5KVxuICAgICAgICAgIGFyZ3MucHVzaChjcmVhdGVBcnJheUxpdGVyYWwobGFzdEFycmF5KSk7XG4gICAgICAgIHZhciBzcHJlYWQgPSB0aGlzLmdldFJ1bnRpbWVFeHByZXNzaW9uKCdzcHJlYWQnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCBzcHJlYWQsIGNyZWF0ZUFyZ3VtZW50TGlzdChhcmdzKSk7XG4gICAgICB9LFxuICAgICAgZGVzdWdhckNhbGxTcHJlYWRfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uT2JqZWN0LFxuICAgICAgICAgICAgY29udGV4dE9iamVjdDtcbiAgICAgICAgdGhpcy5wdXNoVGVtcFNjb3BlKCk7XG4gICAgICAgIGlmIChvcGVyYW5kLnR5cGUgPT09IE1FTUJFUl9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgdmFyIHRlbXBJZGVudCA9IGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKHRoaXMuYWRkVGVtcFZhcigpKTtcbiAgICAgICAgICB2YXIgcGFyZW5FeHByZXNzaW9uID0gY3JlYXRlUGFyZW5FeHByZXNzaW9uKGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKHRlbXBJZGVudCwgb3BlcmFuZC5vcGVyYW5kKSk7XG4gICAgICAgICAgdmFyIG1lbWJlck5hbWUgPSBvcGVyYW5kLm1lbWJlck5hbWU7XG4gICAgICAgICAgY29udGV4dE9iamVjdCA9IHRlbXBJZGVudDtcbiAgICAgICAgICBmdW5jdGlvbk9iamVjdCA9IGNyZWF0ZU1lbWJlckV4cHJlc3Npb24ocGFyZW5FeHByZXNzaW9uLCBtZW1iZXJOYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gTUVNQkVSX0xPT0tVUF9FWFBSRVNTSU9OKSB7XG4gICAgICAgICAgdmFyIHRlbXBJZGVudCRfXzEgPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbih0aGlzLmFkZFRlbXBWYXIoKSk7XG4gICAgICAgICAgdmFyIHBhcmVuRXhwcmVzc2lvbiRfXzIgPSBjcmVhdGVQYXJlbkV4cHJlc3Npb24oY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24odGVtcElkZW50JF9fMSwgb3BlcmFuZC5vcGVyYW5kKSk7XG4gICAgICAgICAgdmFyIG1lbWJlckV4cHJlc3Npb24gPSB0aGlzLnRyYW5zZm9ybUFueShvcGVyYW5kLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICAgIGNvbnRleHRPYmplY3QgPSB0ZW1wSWRlbnQkX18xO1xuICAgICAgICAgIGZ1bmN0aW9uT2JqZWN0ID0gY3JlYXRlTWVtYmVyTG9va3VwRXhwcmVzc2lvbihwYXJlbkV4cHJlc3Npb24kX18yLCBtZW1iZXJFeHByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0T2JqZWN0ID0gY3JlYXRlVm9pZDAoKTtcbiAgICAgICAgICBmdW5jdGlvbk9iamVjdCA9IG9wZXJhbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3BUZW1wU2NvcGUoKTtcbiAgICAgICAgdmFyIGFycmF5RXhwcmVzc2lvbiA9IHRoaXMuY3JlYXRlQXJyYXlGcm9tRWxlbWVudHNfKHRyZWUuYXJncy5hcmdzKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNyZWF0ZU1lbWJlckV4cHJlc3Npb24oZnVuY3Rpb25PYmplY3QsIEFQUExZKSwgY3JlYXRlQXJndW1lbnRMaXN0KFtjb250ZXh0T2JqZWN0LCBhcnJheUV4cHJlc3Npb25dKSk7XG4gICAgICB9LFxuICAgICAgZGVzdWdhck5ld1NwcmVhZF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGFycmF5RXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW2NyZWF0ZU51bGxMaXRlcmFsKCldLCB0cmVlLmFyZ3MuYXJncyk7XG4gICAgICAgIGFycmF5RXhwcmVzc2lvbiA9IHRoaXMuY3JlYXRlQXJyYXlGcm9tRWxlbWVudHNfKGFycmF5RXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjcmVhdGVOZXdFeHByZXNzaW9uKGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihjcmVhdGVDYWxsRXhwcmVzc2lvbihjcmVhdGVNZW1iZXJFeHByZXNzaW9uKEZVTkNUSU9OLCBQUk9UT1RZUEUsIEJJTkQsIEFQUExZKSwgY3JlYXRlQXJndW1lbnRMaXN0KFt0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm9wZXJhbmQpLCBhcnJheUV4cHJlc3Npb25dKSkpLCBjcmVhdGVFbXB0eUFyZ3VtZW50TGlzdCgpKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1BcnJheUxpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKGhhc1NwcmVhZE1lbWJlcih0cmVlLmVsZW1lbnRzKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFycmF5RnJvbUVsZW1lbnRzXyh0cmVlLmVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNwcmVhZFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1BcnJheUxpdGVyYWxcIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoaGFzU3ByZWFkTWVtYmVyKHRyZWUuYXJncy5hcmdzKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlc3VnYXJDYWxsU3ByZWFkXyh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFNwcmVhZFRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUuYXJncyAhPT0gbnVsbCAmJiBoYXNTcHJlYWRNZW1iZXIodHJlZS5hcmdzLmFyZ3MpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdWdhck5ld1NwcmVhZF8odHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTcHJlYWRUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTmV3RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSW1wb3J0UnVudGltZVRyYWl0KFRlbXBWYXJUcmFuc2Zvcm1lcikpO1xuICByZXR1cm4ge2dldCBTcHJlYWRUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBTcHJlYWRUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TdXBlclRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3VwZXJUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgSW1wb3J0UnVudGltZVRyYWl0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vSW1wb3J0UnVudGltZVRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TdXBlclRyYW5zZm9ybWVyLmpzXCIpKS5kZWZhdWx0O1xuICB2YXIgVGVtcFZhclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcFZhclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TdXBlclRyYW5zZm9ybWVyLmpzXCIpKS5UZW1wVmFyVHJhbnNmb3JtZXI7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TdXBlclRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFyZ3VtZW50TGlzdCA9ICRfXzcuQXJndW1lbnRMaXN0LFxuICAgICAgQ2xhc3NEZWNsYXJhdGlvbiA9ICRfXzcuQ2xhc3NEZWNsYXJhdGlvbixcbiAgICAgIENsYXNzRXhwcmVzc2lvbiA9ICRfXzcuQ2xhc3NFeHByZXNzaW9uLFxuICAgICAgR2V0QWNjZXNzb3IgPSAkX183LkdldEFjY2Vzc29yLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzcuTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIE1ldGhvZCA9ICRfXzcuTWV0aG9kLFxuICAgICAgU2V0QWNjZXNzb3IgPSAkX183LlNldEFjY2Vzc29yO1xuICB2YXIgJF9fOCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3VwZXJUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBNRU1CRVJfRVhQUkVTU0lPTiA9ICRfXzguTUVNQkVSX0VYUFJFU1NJT04sXG4gICAgICBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPSAkX184Lk1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTixcbiAgICAgIFNVUEVSX0VYUFJFU1NJT04gPSAkX184LlNVUEVSX0VYUFJFU1NJT047XG4gIHZhciAkX185ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N1cGVyVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgRVFVQUwgPSAkX185LkVRVUFMLFxuICAgICAgTUlOVVNfTUlOVVMgPSAkX185Lk1JTlVTX01JTlVTLFxuICAgICAgUExVU19QTFVTID0gJF9fOS5QTFVTX1BMVVM7XG4gIHZhciAkX18xMCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZUZhY3RvcnkuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N1cGVyVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24gPSAkX18xMC5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyID0gJF9fMTAuY3JlYXRlQmluZGluZ0lkZW50aWZpZXIsXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzEwLmNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlSWRlbnRpZmllclRva2VuID0gJF9fMTAuY3JlYXRlSWRlbnRpZmllclRva2VuLFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlUGFyZW5FeHByZXNzaW9uLFxuICAgICAgY3JlYXRlU3RyaW5nTGl0ZXJhbCA9ICRfXzEwLmNyZWF0ZVN0cmluZ0xpdGVyYWwsXG4gICAgICBjcmVhdGVUaGlzRXhwcmVzc2lvbiA9ICRfXzEwLmNyZWF0ZVRoaXNFeHByZXNzaW9uO1xuICB2YXIgcGFyc2VFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N1cGVyVHJhbnNmb3JtZXIuanNcIikpLnBhcnNlRXhwcmVzc2lvbjtcbiAgdmFyIEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TdXBlclRyYW5zZm9ybWVyLmpzXCIpKS5FeHBsb2RlRXhwcmVzc2lvblRyYW5zZm9ybWVyO1xuICBmdW5jdGlvbiBoYXNTdXBlck1lbWJlckV4cHJlc3Npb24odHJlZSkge1xuICAgIHJldHVybiAodHJlZS50eXBlID09PSBNRU1CRVJfRVhQUkVTU0lPTiB8fCB0cmVlLnR5cGUgPT09IE1FTUJFUl9MT09LVVBfRVhQUkVTU0lPTikgJiYgdHJlZS5vcGVyYW5kLnR5cGUgPT09IFNVUEVSX0VYUFJFU1NJT047XG4gIH1cbiAgdmFyIFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3RhdGUodHJhbnNmb3JtZXIsIGhvbWUpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbiAgICAgIHRoaXMuaG9tZV8gPSBob21lO1xuICAgICAgdGhpcy50ZW1wTmFtZSA9IGhvbWUgPyBudWxsIDogdHJhbnNmb3JtZXIuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgIHRoaXMuaGFzU3VwZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFN0YXRlLCB7Z2V0IGhvbWUoKSB7XG4gICAgICAgIHRoaXMuaGFzU3VwZXIgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5ob21lXyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuaG9tZV8gPSBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihjcmVhdGVJZGVudGlmaWVyVG9rZW4odGhpcy50ZW1wTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhvbWVfO1xuICAgICAgfX0sIHt9KTtcbiAgfSgpO1xuICB2YXIgQ2xhc3NTdGF0ZSA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3NTdGF0ZSh0cmFuc2Zvcm1lciwgdHJlZSkge1xuICAgICAgdmFyIGhvbWUgPSBudWxsO1xuICAgICAgaWYgKHRyZWUubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBob21lID0gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5uYW1lLmlkZW50aWZpZXJUb2tlbik7XG4gICAgICB9XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDbGFzc1N0YXRlKS5jYWxsKHRoaXMsIHRyYW5zZm9ybWVyLCBob21lKTtcbiAgICAgIHRoaXMubmFtZV8gPSB0cmVlLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDbGFzc1N0YXRlLCB7Z2V0IG5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVfICE9PSBudWxsKVxuICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICAgICAgICBpZiAodGhpcy5oYXNTdXBlcikge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcih0aGlzLmhvbWUuaWRlbnRpZmllclRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFN0YXRlKTtcbiAgdmFyIFByb3RvdHlwZVN0YXRlID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQcm90b3R5cGVTdGF0ZSh0cmFuc2Zvcm1lciwgY2xhc3NTdGF0ZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoUHJvdG90eXBlU3RhdGUpLmNhbGwodGhpcywgdHJhbnNmb3JtZXIsIG51bGwpO1xuICAgICAgdGhpcy5jbGFzc1N0YXRlID0gY2xhc3NTdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFByb3RvdHlwZVN0YXRlLCB7Z2V0IGhvbWUoKSB7XG4gICAgICAgIHZhciBpZGVudCA9IHRoaXMuY2xhc3NTdGF0ZS5ob21lO1xuICAgICAgICByZXR1cm4gbmV3IE1lbWJlckV4cHJlc3Npb24obnVsbCwgaWRlbnQsIGNyZWF0ZUlkZW50aWZpZXJUb2tlbigncHJvdG90eXBlJykpO1xuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oU3RhdGUpO1xuICB2YXIgU3VwZXJUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gU3VwZXJUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoU3VwZXJUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCBpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnN0YXRlU3RhY2tfID0gW107XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShTdXBlclRyYW5zZm9ybWVyLCB7XG4gICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGVTdGFja18ucHVzaChzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVN0YWNrXy5wb3AoKTtcbiAgICAgIH0sXG4gICAgICBwZWVrU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVN0YWNrX1t0aGlzLnN0YXRlU3RhY2tfLmxlbmd0aCAtIDFdO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU9iamVjdExpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKHRoaXMsIG51bGwpO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTdXBlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1PYmplY3RMaXRlcmFsXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUuaGFzU3VwZXIpIHtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyVGVtcFZhck5hbWUoc3RhdGUudGVtcE5hbWUpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihzdGF0ZS5ob21lLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVsZWFzZVRlbXBOYW1lKHN0YXRlLnRlbXBOYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLnN1cGVyQ2xhc3MpO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hbm5vdGF0aW9ucyk7XG4gICAgICAgIHZhciBjbGFzc1N0YXRlID0gbmV3IENsYXNzU3RhdGUodGhpcywgdHJlZSk7XG4gICAgICAgIHZhciBwcm90b3R5cGVTdGF0ZSA9IG5ldyBQcm90b3R5cGVTdGF0ZSh0aGlzLCBjbGFzc1N0YXRlKTtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoY2xhc3NTdGF0ZSk7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKHByb3RvdHlwZVN0YXRlKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy50cmFuc2Zvcm1MaXN0KHRyZWUuZWxlbWVudHMpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgaWYgKHRyZWUubmFtZSA9PT0gbnVsbCAmJiB0cmVlLnN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICBjbGFzc1N0YXRlLmhvbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHJlZS5zdXBlckNsYXNzID09PSBzdXBlckNsYXNzICYmIHRyZWUuZWxlbWVudHMgPT09IGVsZW1lbnRzICYmIHRyZWUuYW5ub3RhdGlvbnMgPT09IGFubm90YXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0V4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgY2xhc3NTdGF0ZS5uYW1lLCBzdXBlckNsYXNzLCBlbGVtZW50cywgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS50eXBlUGFyYW1ldGVycyk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuc3VwZXJDbGFzcyk7XG4gICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMudHJhbnNmb3JtTGlzdCh0cmVlLmFubm90YXRpb25zKTtcbiAgICAgICAgdmFyIGNsYXNzU3RhdGUgPSBuZXcgQ2xhc3NTdGF0ZSh0aGlzLCB0cmVlKTtcbiAgICAgICAgdmFyIHByb3RvdHlwZVN0YXRlID0gbmV3IFByb3RvdHlwZVN0YXRlKHRoaXMsIGNsYXNzU3RhdGUpO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShjbGFzc1N0YXRlKTtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUocHJvdG90eXBlU3RhdGUpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5lbGVtZW50cyk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICBpZiAodHJlZS5zdXBlckNsYXNzID09PSBzdXBlckNsYXNzICYmIHRyZWUuZWxlbWVudHMgPT09IGVsZW1lbnRzICYmIHRyZWUuYW5ub3RhdGlvbnMgPT09IGFubm90YXRpb25zKSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDbGFzc0RlY2xhcmF0aW9uKHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSwgc3VwZXJDbGFzcywgZWxlbWVudHMsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUudHlwZVBhcmFtZXRlcnMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciBwcm90b3R5cGVTdGF0ZTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICBwcm90b3R5cGVTdGF0ZSA9IHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwcm90b3R5cGVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUubmFtZSA9PT0gbmFtZSAmJiB0cmVlLnBhcmFtZXRlckxpc3QgPT09IHBhcmFtZXRlckxpc3QgJiYgdHJlZS5ib2R5ID09PSBib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2QodHJlZS5sb2NhdGlvbiwgdHJlZS5pc1N0YXRpYywgdHJlZS5mdW5jdGlvbktpbmQsIG5hbWUsIHBhcmFtZXRlckxpc3QsIHRyZWUudHlwZUFubm90YXRpb24sIHRyZWUuYW5ub3RhdGlvbnMsIGJvZHksIHRyZWUuZGVidWdOYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1HZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciBwcm90b3R5cGVTdGF0ZTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICBwcm90b3R5cGVTdGF0ZSA9IHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUuYm9keSk7XG4gICAgICAgIGlmICh0cmVlLmlzU3RhdGljKSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUocHJvdG90eXBlU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmVlLm5hbWUgPT09IG5hbWUgJiYgdHJlZS5ib2R5ID09PSBib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBHZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBuYW1lLCB0cmVlLnR5cGVBbm5vdGF0aW9uLCB0cmVlLmFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TZXRBY2Nlc3NvcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUubmFtZSk7XG4gICAgICAgIHZhciBwcm90b3R5cGVTdGF0ZTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICBwcm90b3R5cGVTdGF0ZSA9IHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucGFyYW1ldGVyTGlzdCk7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5ib2R5KTtcbiAgICAgICAgaWYgKHRyZWUuaXNTdGF0aWMpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwcm90b3R5cGVTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyZWUubmFtZSA9PT0gbmFtZSAmJiB0cmVlLnBhcmFtZXRlckxpc3QgPT09IHBhcmFtZXRlckxpc3QgJiYgdHJlZS5ib2R5ID09PSBib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCBuYW1lLCBwYXJhbWV0ZXJMaXN0LCB0cmVlLmFubm90YXRpb25zLCBib2R5KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db21wdXRlZFByb3BlcnR5TmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgczEgPSB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgIHZhciBzMiA9IHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTdXBlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Db21wdXRlZFByb3BlcnR5TmFtZVwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB0aGlzLnB1c2hTdGF0ZShzMik7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKHMxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1TdXBlckV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1lbWJlclNoYXJlZF86IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGhvbWUgPSB0aGlzLnBlZWtTdGF0ZSgpLmhvbWU7XG4gICAgICAgIHZhciBzdXBlckdldCA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ3N1cGVyR2V0Jyk7XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIih0aGlzLCBcIiwgXCIsIFwiLCBcIilcIl0pLCBzdXBlckdldCwgaG9tZSwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5vcGVyYW5kLnR5cGUgPT09IFNVUEVSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1NZW1iZXJTaGFyZWRfKHRyZWUubWVtYmVyTmFtZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTdXBlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1NZW1iZXJFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTWVtYmVyTG9va3VwRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5vcGVyYW5kLnR5cGUgPT09IFNVUEVSX0VYUFJFU1NJT04pXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVtYmVyU2hhcmVkXyh0cmVlLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFN1cGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybU1lbWJlckxvb2t1cEV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgb3BlcmFuZCxcbiAgICAgICAgICAgIGFyZ3M7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gU1VQRVJfRVhQUkVTU0lPTikge1xuICAgICAgICAgIGFyZ3MgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmFyZ3MpO1xuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJndW1lbnRMaXN0KHRyZWUubG9jYXRpb24sICR0cmFjZXVyUnVudGltZS5zcHJlYWQoW2NyZWF0ZVRoaXNFeHByZXNzaW9uKCldLCBhcmdzLmFyZ3MpKTtcbiAgICAgICAgICB2YXIgaG9tZSA9IHRoaXMuc3RhdGVTdGFja19bdGhpcy5zdGF0ZVN0YWNrXy5sZW5ndGggLSAyXS5ob21lO1xuICAgICAgICAgIHZhciBzdXBlckNvbnN0cnVjdG9yID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignc3VwZXJDb25zdHJ1Y3RvcicpO1xuICAgICAgICAgIG9wZXJhbmQgPSBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIihcIiwgXCIpXCJdKSwgc3VwZXJDb25zdHJ1Y3RvciwgaG9tZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzU3VwZXJNZW1iZXJFeHByZXNzaW9uKHRyZWUub3BlcmFuZCkpIHtcbiAgICAgICAgICBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgICBhcmdzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5hcmdzKTtcbiAgICAgICAgICBhcmdzID0gbmV3IEFyZ3VtZW50TGlzdChhcmdzLmxvY2F0aW9uLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKFtjcmVhdGVUaGlzRXhwcmVzc2lvbigpXSwgYXJncy5hcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTdXBlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1DYWxsRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIlwiLCBcIi5jYWxsKFwiLCBcIilcIl0pLCBvcGVyYW5kLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1CaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhdG9yLmlzQXNzaWdubWVudE9wZXJhdG9yKCkgJiYgaGFzU3VwZXJNZW1iZXJFeHByZXNzaW9uKHRyZWUubGVmdCkpIHtcbiAgICAgICAgICBpZiAodHJlZS5vcGVyYXRvci50eXBlICE9PSBFUVVBTCkge1xuICAgICAgICAgICAgdmFyIGV4cGxvZGVkID0gbmV3IEV4cGxvZGVFeHByZXNzaW9uVHJhbnNmb3JtZXIodGhpcykudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQW55KGNyZWF0ZVBhcmVuRXhwcmVzc2lvbihleHBsb2RlZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IHRyZWUubGVmdC50eXBlID09PSBNRU1CRVJfTE9PS1VQX0VYUFJFU1NJT04gPyB0cmVlLmxlZnQubWVtYmVyRXhwcmVzc2lvbiA6IGNyZWF0ZVN0cmluZ0xpdGVyYWwodHJlZS5sZWZ0Lm1lbWJlck5hbWUudmFsdWUpO1xuICAgICAgICAgIHZhciByaWdodCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUucmlnaHQpO1xuICAgICAgICAgIHZhciBob21lID0gdGhpcy5wZWVrU3RhdGUoKS5ob21lO1xuICAgICAgICAgIHZhciBzdXBlclNldCA9IHRoaXMuZ2V0UnVudGltZUV4cHJlc3Npb24oJ3N1cGVyU2V0Jyk7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKHRoaXMsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIpXCJdKSwgc3VwZXJTZXQsIGhvbWUsIG5hbWUsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFN1cGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1VbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdGhpcy50cmFuc2Zvcm1JbmNyZW1lbnREZWNyZW1lbnRfKHRyZWUpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQpXG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgICAgICByZXR1cm4gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIFN1cGVyVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVVuYXJ5RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVBvc3RmaXhFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRoaXMudHJhbnNmb3JtSW5jcmVtZW50RGVjcmVtZW50Xyh0cmVlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkKVxuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBTdXBlclRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qb3N0Zml4RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUluY3JlbWVudERlY3JlbWVudF86IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdHJlZS5vcGVyYXRvcjtcbiAgICAgICAgdmFyIG9wZXJhbmQgPSB0cmVlLm9wZXJhbmQ7XG4gICAgICAgIGlmICgob3BlcmF0b3IudHlwZSA9PT0gUExVU19QTFVTIHx8IG9wZXJhdG9yLnR5cGUgPT09IE1JTlVTX01JTlVTKSAmJiBoYXNTdXBlck1lbWJlckV4cHJlc3Npb24ob3BlcmFuZCkpIHtcbiAgICAgICAgICB2YXIgZXhwbG9kZWQgPSBuZXcgRXhwbG9kZUV4cHJlc3Npb25UcmFuc2Zvcm1lcih0aGlzKS50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgICAgaWYgKGV4cGxvZGVkICE9PSB0cmVlKVxuICAgICAgICAgICAgZXhwbG9kZWQgPSBjcmVhdGVQYXJlbkV4cHJlc3Npb24oZXhwbG9kZWQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFueShleHBsb2RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShJbXBvcnRSdW50aW1lVHJhaXQoVGVtcFZhclRyYW5zZm9ybWVyKSk7XG4gIHJldHVybiB7Z2V0IFN1cGVyVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gU3VwZXJUcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TeW1ib2xUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N5bWJvbFRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciAkX18zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TeW1ib2xUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBCaW5hcnlFeHByZXNzaW9uID0gJF9fMy5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgVW5hcnlFeHByZXNzaW9uID0gJF9fMy5VbmFyeUV4cHJlc3Npb247XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVUeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TeW1ib2xUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkX180LklERU5USUZJRVJfRVhQUkVTU0lPTixcbiAgICAgIExJVEVSQUxfRVhQUkVTU0lPTiA9ICRfXzQuTElURVJBTF9FWFBSRVNTSU9OLFxuICAgICAgVU5BUllfRVhQUkVTU0lPTiA9ICRfXzQuVU5BUllfRVhQUkVTU0lPTjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N5bWJvbFRyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vU3ltYm9sVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX183ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1N5bWJvbFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEVRVUFMX0VRVUFMID0gJF9fNy5FUVVBTF9FUVVBTCxcbiAgICAgIEVRVUFMX0VRVUFMX0VRVUFMID0gJF9fNy5FUVVBTF9FUVVBTF9FUVVBTCxcbiAgICAgIE5PVF9FUVVBTCA9ICRfXzcuTk9UX0VRVUFMLFxuICAgICAgTk9UX0VRVUFMX0VRVUFMID0gJF9fNy5OT1RfRVFVQUxfRVFVQUwsXG4gICAgICBUWVBFT0YgPSAkX183LlRZUEVPRjtcbiAgdmFyIHBhcnNlRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9TeW1ib2xUcmFuc2Zvcm1lci5qc1wiKSkucGFyc2VFeHByZXNzaW9uO1xuICBmdW5jdGlvbiBpc0VxdWFsaXR5RXhwcmVzc2lvbih0cmVlKSB7XG4gICAgc3dpdGNoICh0cmVlLm9wZXJhdG9yLnR5cGUpIHtcbiAgICAgIGNhc2UgRVFVQUxfRVFVQUw6XG4gICAgICBjYXNlIEVRVUFMX0VRVUFMX0VRVUFMOlxuICAgICAgY2FzZSBOT1RfRVFVQUw6XG4gICAgICBjYXNlIE5PVF9FUVVBTF9FUVVBTDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpc1R5cGVvZih0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUudHlwZSA9PT0gVU5BUllfRVhQUkVTU0lPTiAmJiB0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFRZUEVPRjtcbiAgfVxuICBmdW5jdGlvbiBpc1NhZmVUeXBlb2ZTdHJpbmcodHJlZSkge1xuICAgIGlmICh0cmVlLnR5cGUgIT09IExJVEVSQUxfRVhQUkVTU0lPTilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgdmFsdWUgPSB0cmVlLmxpdGVyYWxUb2tlbi5wcm9jZXNzZWRWYWx1ZTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgU3ltYm9sVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFN5bWJvbFRyYW5zZm9ybWVyKGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihTeW1ib2xUcmFuc2Zvcm1lcikuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuaWRlbnRpZmllckdlbmVyYXRvciA9IGlkZW50aWZpZXJHZW5lcmF0b3I7XG4gICAgICB0aGlzLnJlcG9ydGVyID0gcmVwb3J0ZXI7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU3ltYm9sVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybVR5cGVvZk9wZXJhbmRfOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5vcGVyYXRvciwgb3BlcmFuZCk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoaXNFcXVhbGl0eUV4cHJlc3Npb24odHJlZSkpIHtcbiAgICAgICAgICBpZiAoaXNUeXBlb2YodHJlZS5sZWZ0KSAmJiBpc1NhZmVUeXBlb2ZTdHJpbmcodHJlZS5yaWdodCkpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy50cmFuc2Zvcm1UeXBlb2ZPcGVyYW5kXyh0cmVlLmxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdHJlZS5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5RXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBsZWZ0LCB0cmVlLm9wZXJhdG9yLCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1R5cGVvZih0cmVlLnJpZ2h0KSAmJiBpc1NhZmVUeXBlb2ZTdHJpbmcodHJlZS5sZWZ0KSkge1xuICAgICAgICAgICAgdmFyIGxlZnQkX18xID0gdHJlZS5sZWZ0O1xuICAgICAgICAgICAgdmFyIHJpZ2h0JF9fMiA9IHRoaXMudHJhbnNmb3JtVHlwZW9mT3BlcmFuZF8odHJlZS5yaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgbGVmdCRfXzEsIHRyZWUub3BlcmF0b3IsIHJpZ2h0JF9fMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU3ltYm9sVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUJpbmFyeUV4cHJlc3Npb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1VbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmF0b3IudHlwZSAhPT0gVFlQRU9GKVxuICAgICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgU3ltYm9sVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVVuYXJ5RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgICB2YXIgb3BlcmFuZCA9IHRoaXMudHJhbnNmb3JtQW55KHRyZWUub3BlcmFuZCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5nZXRSdW50aW1lVHlwZW9mKG9wZXJhbmQpO1xuICAgICAgICBpZiAob3BlcmFuZC50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIodHlwZW9mIFwiLCBcIiA9PT0gJ3VuZGVmaW5lZCcgP1xcbiAgICAgICAgICAndW5kZWZpbmVkJyA6IFwiLCBcIilcIl0pLCBvcGVyYW5kLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgIH0sXG4gICAgICBnZXRSdW50aW1lVHlwZW9mOiBmdW5jdGlvbihvcGVyYW5kKSB7XG4gICAgICAgIHZhciB0eXBlT2YgPSB0aGlzLmdldFJ1bnRpbWVFeHByZXNzaW9uKCd0eXBlb2YnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbigkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiXCIsIFwiKFwiLCBcIilcIl0pLCB0eXBlT2YsIG9wZXJhbmQpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oSW1wb3J0UnVudGltZVRyYWl0KFBhcnNlVHJlZVRyYW5zZm9ybWVyKSk7XG4gIHJldHVybiB7Z2V0IFN5bWJvbFRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFN5bWJvbFRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEJJTkFSWV9FWFBSRVNTSU9OID0gJF9fMy5CSU5BUllfRVhQUkVTU0lPTixcbiAgICAgIENPTU1BX0VYUFJFU1NJT04gPSAkX18zLkNPTU1BX0VYUFJFU1NJT04sXG4gICAgICBDT05ESVRJT05BTF9FWFBSRVNTSU9OID0gJF9fMy5DT05ESVRJT05BTF9FWFBSRVNTSU9OLFxuICAgICAgVEVNUExBVEVfTElURVJBTF9QT1JUSU9OID0gJF9fMy5URU1QTEFURV9MSVRFUkFMX1BPUlRJT04sXG4gICAgICBURU1QTEFURV9MSVRFUkFMX0VYUFJFU1NJT04gPSAkX18zLlRFTVBMQVRFX0xJVEVSQUxfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIExpdGVyYWxFeHByZXNzaW9uID0gJF9fNC5MaXRlcmFsRXhwcmVzc2lvbixcbiAgICAgIE5ld0V4cHJlc3Npb24gPSAkX180Lk5ld0V4cHJlc3Npb247XG4gIHZhciBMaXRlcmFsVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLkxpdGVyYWxUb2tlbjtcbiAgdmFyIFBhcmVuVHJhaXQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJlblRyYWl0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wbGF0ZUxpdGVyYWxUcmFuc2Zvcm1lci5qc1wiKSkuUGFyZW5UcmFpdDtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIEltcG9ydFJ1bnRpbWVUcmFpdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ltcG9ydFJ1bnRpbWVUcmFpdC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIuanNcIikpLmRlZmF1bHQ7XG4gIHZhciAkX185ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC9Ub2tlblR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1RlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIFBFUkNFTlQgPSAkX185LlBFUkNFTlQsXG4gICAgICBQTFVTID0gJF9fOS5QTFVTLFxuICAgICAgU0xBU0ggPSAkX185LlNMQVNILFxuICAgICAgU1RBUiA9ICRfXzkuU1RBUixcbiAgICAgIFNUUklORyA9ICRfXzkuU1RSSU5HO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVGYWN0b3J5LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UZW1wbGF0ZUxpdGVyYWxUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBjcmVhdGVBcmd1bWVudExpc3QgPSAkX18xMC5jcmVhdGVBcmd1bWVudExpc3QsXG4gICAgICBjcmVhdGVBcnJheUxpdGVyYWwgPSAkX18xMC5jcmVhdGVBcnJheUxpdGVyYWwsXG4gICAgICBjcmVhdGVCaW5hcnlFeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZUNhbGxFeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlQ2FsbEV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJFeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU9wZXJhdG9yVG9rZW4gPSAkX18xMC5jcmVhdGVPcGVyYXRvclRva2VuLFxuICAgICAgY3JlYXRlUGFyZW5FeHByZXNzaW9uID0gJF9fMTAuY3JlYXRlUGFyZW5FeHByZXNzaW9uO1xuICBmdW5jdGlvbiBjcmVhdGVTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbihsb2MsIHN0cikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHJlc3Npb24obG9jLCBuZXcgTGl0ZXJhbFRva2VuKFNUUklORywgc3RyLCBsb2MpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVHZXRUZW1wbGF0ZU9iamVjdChlbGVtZW50cywgZ2V0VGVtcGxhdGVPYmplY3QpIHtcbiAgICB2YXIgY29va2VkID0gW107XG4gICAgdmFyIHJhdyA9IFtdO1xuICAgIHZhciBzYW1lID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgbG9jID0gZWxlbWVudHNbaV0ubG9jYXRpb247XG4gICAgICB2YXIgc3RyID0gZWxlbWVudHNbaV0udmFsdWUudmFsdWU7XG4gICAgICB2YXIgY29va2VkU3RyID0gdG9Db29rZWRTdHJpbmcoc3RyKTtcbiAgICAgIHZhciByYXdTdHIgPSB0b1Jhd1N0cmluZyhzdHIpO1xuICAgICAgdmFyIGNvb2tlZExpdGVyYWwkX18xID0gY3JlYXRlU3RyaW5nTGl0ZXJhbEV4cHJlc3Npb24obG9jLCBjb29rZWRTdHIpO1xuICAgICAgY29va2VkLnB1c2goY29va2VkTGl0ZXJhbCRfXzEpO1xuICAgICAgaWYgKGNvb2tlZFN0ciAhPT0gcmF3U3RyKSB7XG4gICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJhd0xpdGVyYWwgPSBjcmVhdGVTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbihsb2MsIHJhd1N0cik7XG4gICAgICAgIHJhdy5wdXNoKHJhd0xpdGVyYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmF3LnB1c2goY29va2VkTGl0ZXJhbCRfXzEpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXliZUFkZEVtcHR5U3RyaW5nQXRFbmQoZWxlbWVudHMsIGNvb2tlZCk7XG4gICAgdmFyIGNvb2tlZExpdGVyYWwgPSBjcmVhdGVBcnJheUxpdGVyYWwoY29va2VkKTtcbiAgICB2YXIgYXJncyA9IFtjb29rZWRMaXRlcmFsXTtcbiAgICBpZiAoIXNhbWUpIHtcbiAgICAgIG1heWJlQWRkRW1wdHlTdHJpbmdBdEVuZChlbGVtZW50cywgcmF3KTtcbiAgICAgIHZhciByYXdMaXRlcmFsJF9fMiA9IGNyZWF0ZUFycmF5TGl0ZXJhbChyYXcpO1xuICAgICAgYXJncy51bnNoaWZ0KHJhd0xpdGVyYWwkX18yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGdldFRlbXBsYXRlT2JqZWN0LCBjcmVhdGVBcmd1bWVudExpc3QoYXJncykpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlQWRkRW1wdHlTdHJpbmdBdEVuZChlbGVtZW50cywgaXRlbXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoIHx8IGVsZW1lbnRzW2xlbmd0aCAtIDFdLnR5cGUgIT09IFRFTVBMQVRFX0xJVEVSQUxfUE9SVElPTikge1xuICAgICAgaXRlbXMucHVzaChjcmVhdGVTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbihudWxsLCAnXCJcIicpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdG9SYXdTdHJpbmcoc3RyKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpO1xuICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KHN0cik7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHUyMDI4fFxcdTIwMjkvZywgZnVuY3Rpb24oYykge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI4JztcbiAgICAgICAgY2FzZSAnXFx1MjAyOSc6XG4gICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKCdOb3QgcmVhY2hhYmxlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9Db29rZWRTdHJpbmcocykge1xuICAgIHZhciBzYiA9IFsnXCInXTtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGsgPSAxLFxuICAgICAgICBjLFxuICAgICAgICBjMjtcbiAgICB3aGlsZSAoaSA8IHMubGVuZ3RoKSB7XG4gICAgICBjID0gc1tpKytdO1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgIGMyID0gc1tpKytdO1xuICAgICAgICAgIHN3aXRjaCAoYzIpIHtcbiAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICBjYXNlICdcXHUyMDI4JzpcbiAgICAgICAgICAgIGNhc2UgJ1xcdTIwMjknOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICAgIGlmIChzW2kgKyAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzYltrKytdID0gYztcbiAgICAgICAgICAgICAgc2JbaysrXSA9IGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHNiW2srK10gPSAnXFxcXFwiJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICBzYltrKytdID0gJ1xcXFxuJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICBpZiAoc1tpXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgc2JbaysrXSA9ICdcXFxcbic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgc2JbaysrXSA9ICdcXFxcdCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcZic6XG4gICAgICAgICAgc2JbaysrXSA9ICdcXFxcZic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcYic6XG4gICAgICAgICAgc2JbaysrXSA9ICdcXFxcYic7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuICAgICAgICAgIHNiW2srK10gPSAnXFxcXHUyMDI4JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFx1MjAyOSc6XG4gICAgICAgICAgc2JbaysrXSA9ICdcXFxcdTIwMjknO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNiW2srK10gPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICBzYltrKytdID0gJ1wiJztcbiAgICByZXR1cm4gc2Iuam9pbignJyk7XG4gIH1cbiAgdmFyIFRlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWxUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKCF0cmVlLm9wZXJhbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWZhdWx0VGVtcGxhdGVMaXRlcmFsKHRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVyYW5kID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5vcGVyYW5kKTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdHJlZS5lbGVtZW50cztcbiAgICAgICAgdmFyIGdldFRlbXBsYXRlT2JqZWN0ID0gdGhpcy5nZXRSdW50aW1lRXhwcmVzc2lvbignZ2V0VGVtcGxhdGVPYmplY3QnKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbY3JlYXRlR2V0VGVtcGxhdGVPYmplY3QodHJlZS5lbGVtZW50cywgZ2V0VGVtcGxhdGVPYmplY3QpXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnRyYW5zZm9ybUFueShlbGVtZW50c1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDYWxsRXhwcmVzc2lvbihvcGVyYW5kLCBjcmVhdGVBcmd1bWVudExpc3QoYXJncykpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlU3Vic3RpdHV0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFRyZWUgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmV4cHJlc3Npb24pO1xuICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybWVkVHJlZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBCSU5BUllfRVhQUkVTU0lPTjpcbiAgICAgICAgICAgIHN3aXRjaCAodHJhbnNmb3JtZWRUcmVlLm9wZXJhdG9yLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBTVEFSOlxuICAgICAgICAgICAgICBjYXNlIFBFUkNFTlQ6XG4gICAgICAgICAgICAgIGNhc2UgU0xBU0g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJlbkV4cHJlc3Npb24odHJhbnNmb3JtZWRUcmVlKTtcbiAgICAgICAgICBjYXNlIENPTU1BX0VYUFJFU1NJT046XG4gICAgICAgICAgY2FzZSBDT05ESVRJT05BTF9FWFBSRVNTSU9OOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmVuRXhwcmVzc2lvbih0cmFuc2Zvcm1lZFRyZWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVGVtcGxhdGVMaXRlcmFsUG9ydGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgc3RyID0gdG9Db29rZWRTdHJpbmcodHJlZS52YWx1ZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBzdHIpO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZURlZmF1bHRUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdHJlZS5lbGVtZW50cztcbiAgICAgICAgdmFyIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCAnXCJcIicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdE5vbkVtcHR5ID0gZWxlbWVudHNbMF0udmFsdWUudmFsdWUgPT09ICcnO1xuICAgICAgICB2YXIgYmluYXJ5RXhwcmVzc2lvbiA9IHRoaXMudHJhbnNmb3JtQW55KGVsZW1lbnRzWzBdKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSlcbiAgICAgICAgICByZXR1cm4gYmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIHBsdXNUb2tlbiA9IGNyZWF0ZU9wZXJhdG9yVG9rZW4oUExVUyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFRFTVBMQVRFX0xJVEVSQUxfUE9SVElPTikge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Tm9uRW1wdHkgJiYgaSA9PT0gMikge1xuICAgICAgICAgICAgICBiaW5hcnlFeHByZXNzaW9uID0gYmluYXJ5RXhwcmVzc2lvbi5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVHJlZSA9IHRoaXMudHJhbnNmb3JtQW55KGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBiaW5hcnlFeHByZXNzaW9uID0gY3JlYXRlQmluYXJ5RXhwcmVzc2lvbihiaW5hcnlFeHByZXNzaW9uLCBwbHVzVG9rZW4sIHRyYW5zZm9ybWVkVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjcmVhdGVQYXJlbkV4cHJlc3Npb24oYmluYXJ5RXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShJbXBvcnRSdW50aW1lVHJhaXQoUGFyZW5UcmFpdChQYXJzZVRyZWVUcmFuc2Zvcm1lcikpKTtcbiAgcmV0dXJuIHtnZXQgVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCI7XG4gIHZhciBQYXJzZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BhcnNlVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UeXBlVG9FeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIEFyZ3VtZW50TGlzdCA9ICRfXzIuQXJndW1lbnRMaXN0LFxuICAgICAgSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18yLklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzIuTWVtYmVyRXhwcmVzc2lvbjtcbiAgdmFyIHBhcnNlRXhwcmVzc2lvbiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UeXBlVG9FeHByZXNzaW9uVHJhbnNmb3JtZXIuanNcIikpLnBhcnNlRXhwcmVzc2lvbjtcbiAgdmFyIFR5cGVUb0V4cHJlc3Npb25UcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyLCB7XG4gICAgICB0cmFuc2Zvcm1UeXBlTmFtZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5tb2R1bGVOYW1lKSB7XG4gICAgICAgICAgdmFyIG9wZXJhbmQgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZU5hbWUpO1xuICAgICAgICAgIHJldHVybiBuZXcgTWVtYmVyRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBvcGVyYW5kLCB0cmVlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1QcmVkZWZpbmVkVHlwZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCR0cmFjZXVyUnVudGltZS5nZXRUZW1wbGF0ZU9iamVjdChbXCIkdHJhY2V1clJ1bnRpbWUudHlwZS5cIiwgXCIpXCJdKSwgdHJlZS50eXBlVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVR5cGVSZWZlcmVuY2U6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS50eXBlTmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5hcmdzKTtcbiAgICAgICAgdmFyIGFyZ3VtZW50TGlzdCA9IG5ldyBBcmd1bWVudExpc3QodHJlZS5sb2NhdGlvbiwgJHRyYWNldXJSdW50aW1lLnNwcmVhZChbdHlwZU5hbWVdLCBhcmdzKSk7XG4gICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb24oJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcIiR0cmFjZXVyUnVudGltZS5nZW5lcmljVHlwZShcIiwgXCIpXCJdKSwgYXJndW1lbnRMaXN0KTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UeXBlQXJndW1lbnRzOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUxpc3QodHJlZS5hcmdzKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFR5cGVUb0V4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UeXBlVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9UeXBlVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzEgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1R5cGVUcmFuc2Zvcm1lci5qc1wiKSksXG4gICAgICBBbm9uQmxvY2sgPSAkX18xLkFub25CbG9jayxcbiAgICAgIEZvcm1hbFBhcmFtZXRlciA9ICRfXzEuRm9ybWFsUGFyYW1ldGVyLFxuICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbiA9ICRfXzEuRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbiA9ICRfXzEuRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgR2V0QWNjZXNzb3IgPSAkX18xLkdldEFjY2Vzc29yLFxuICAgICAgTWV0aG9kID0gJF9fMS5NZXRob2QsXG4gICAgICBWYXJpYWJsZURlY2xhcmF0aW9uID0gJF9fMS5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVHlwZVRyYW5zZm9ybWVyLmpzXCIpKSxcbiAgICAgIElNUE9SVF9UWVBFX0NMQVVTRSA9ICRfXzIuSU1QT1JUX1RZUEVfQ0xBVVNFLFxuICAgICAgVFlQRV9BTElBU19ERUNMQVJBVElPTiA9ICRfXzIuVFlQRV9BTElBU19ERUNMQVJBVElPTjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1R5cGVUcmFuc2Zvcm1lci5qc1wiKSkuUGFyc2VUcmVlVHJhbnNmb3JtZXI7XG4gIHZhciBUeXBlVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIFR5cGVUcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFR5cGVUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFR5cGVUcmFuc2Zvcm1lciwge1xuICAgICAgdHJhbnNmb3JtVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgIHRyZWUgPSBuZXcgVmFyaWFibGVEZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLmx2YWx1ZSwgbnVsbCwgdHJlZS5pbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybVZhcmlhYmxlRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Gb3JtYWxQYXJhbWV0ZXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZUFubm90YXRpb24gIT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYWxQYXJhbWV0ZXIodHJlZS5sb2NhdGlvbiwgdHJlZS5wYXJhbWV0ZXIsIG51bGwsIFtdKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgIHRyZWUgPSBuZXcgRnVuY3Rpb25EZWNsYXJhdGlvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIG51bGwsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRGVjbGFyYXRpb25cIikuY2FsbCh0aGlzLCB0cmVlKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1GdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUudHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICB0cmVlID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLnBhcmFtZXRlckxpc3QsIG51bGwsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUZ1bmN0aW9uRXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU1ldGhvZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgIHRyZWUgPSBuZXcgTWV0aG9kKHRyZWUubG9jYXRpb24sIHRyZWUuaXNTdGF0aWMsIHRyZWUuZnVuY3Rpb25LaW5kLCB0cmVlLm5hbWUsIHRyZWUucGFyYW1ldGVyTGlzdCwgbnVsbCwgdHJlZS5hbm5vdGF0aW9ucywgdHJlZS5ib2R5LCB0cmVlLmRlYnVnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybU1ldGhvZFwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUdldEFjY2Vzc29yOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgdHJlZSA9IG5ldyBHZXRBY2Nlc3Nvcih0cmVlLmxvY2F0aW9uLCB0cmVlLmlzU3RhdGljLCB0cmVlLm5hbWUsIG51bGwsIHRyZWUuYW5ub3RhdGlvbnMsIHRyZWUuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUdldEFjY2Vzc29yXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtSW50ZXJmYWNlRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFRZUEVfQUxJQVNfREVDTEFSQVRJT04pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFub25CbG9jayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBUeXBlVHJhbnNmb3JtZXIucHJvdG90eXBlLCBcInRyYW5zZm9ybUV4cG9ydERlY2xhcmF0aW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtVHlwZUFsaWFzRGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICghdHJlZS5pbXBvcnRDbGF1c2UgfHwgdHJlZS5pbXBvcnRDbGF1c2UudHlwZSA9PT0gSU1QT1JUX1RZUEVfQ0xBVVNFKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbm9uQmxvY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgVHlwZVRyYW5zZm9ybWVyLnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBUeXBlVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gVHlwZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1VuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVW5pY29kZUVzY2FwZVNlcXVlbmNlVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1VuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyLmpzXCIpKS5QYXJzZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIExpdGVyYWxFeHByZXNzaW9uID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Vbmljb2RlRXNjYXBlU2VxdWVuY2VUcmFuc2Zvcm1lci5qc1wiKSkuTGl0ZXJhbEV4cHJlc3Npb247XG4gIHZhciBMaXRlcmFsVG9rZW4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L0xpdGVyYWxUb2tlbi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vVW5pY29kZUVzY2FwZVNlcXVlbmNlVHJhbnNmb3JtZXIuanNcIikpLkxpdGVyYWxUb2tlbjtcbiAgdmFyIFNUUklORyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvVG9rZW5UeXBlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Vbmljb2RlRXNjYXBlU2VxdWVuY2VUcmFuc2Zvcm1lci5qc1wiKSkuU1RSSU5HO1xuICB2YXIgcmUgPSAvKFxcXFwqKVxcXFx1eyhbMC05YS1mQS1GXSspfS9nO1xuICBmdW5jdGlvbiB6ZXJvUGFkKHZhbHVlKSB7XG4gICAgcmV0dXJuICcwMDAwJy5zbGljZSh2YWx1ZS5sZW5ndGgpICsgdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gbmVlZHNUcmFuc2Zvcm0odG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gU1RSSU5HICYmIHJlLnRlc3QodG9rZW4udmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVRva2VuKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uKG1hdGNoLCBiYWNrc2xhc2hlcywgaGV4RGlnaXRzKSB7XG4gICAgICB2YXIgYmFja3NsYXNoSXNFc2NhcGVkID0gYmFja3NsYXNoZXMubGVuZ3RoICUgMiA9PT0gMTtcbiAgICAgIGlmIChiYWNrc2xhc2hJc0VzY2FwZWQpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgICAgdmFyIGNvZGVQb2ludCA9IHBhcnNlSW50KGhleERpZ2l0cywgMTYpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcbiAgICAgICAgdmFsdWUgPSAnXFxcXHUnICsgemVyb1BhZChjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhpZ2ggPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDEwMDAwKSAvIDB4NDAwKSArIDB4RDgwMDtcbiAgICAgICAgdmFyIGxvdyA9IChjb2RlUG9pbnQgLSAweDEwMDAwKSAlIDB4NDAwICsgMHhEQzAwO1xuICAgICAgICB2YWx1ZSA9ICdcXFxcdScgKyBoaWdoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJ1xcXFx1JyArIGxvdy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWNrc2xhc2hlcyArIHZhbHVlO1xuICAgIH0pO1xuICB9XG4gIHZhciBVbmljb2RlRXNjYXBlU2VxdWVuY2VUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVW5pY29kZUVzY2FwZVNlcXVlbmNlVHJhbnNmb3JtZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihVbmljb2RlRXNjYXBlU2VxdWVuY2VUcmFuc2Zvcm1lcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyLCB7dHJhbnNmb3JtTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdHJlZS5saXRlcmFsVG9rZW47XG4gICAgICAgIGlmIChuZWVkc1RyYW5zZm9ybSh0b2tlbikpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1Ub2tlbih0b2tlbik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCBuZXcgTGl0ZXJhbFRva2VuKFNUUklORywgdmFsdWUsIHRva2VuLmxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShQYXJzZVRyZWVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1VuaXF1ZUlkZW50aWZpZXJHZW5lcmF0b3IuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9VbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yLmpzXCI7XG4gIHZhciBVbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvcigpIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFVuaXF1ZUlkZW50aWZpZXJHZW5lcmF0b3IsIHtnZW5lcmF0ZVVuaXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFwiJF9fXCIgKyB0aGlzLmlkZW50aWZpZXJJbmRleCsrKTtcbiAgICAgIH19LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvcigpIHtcbiAgICAgIHJldHVybiBVbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9Db25zdENoZWNrZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvQ29uc3RDaGVja2VyLmpzXCI7XG4gIHZhciBJREVOVElGSUVSX0VYUFJFU1NJT04gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9Db25zdENoZWNrZXIuanNcIikpLklERU5USUZJRVJfRVhQUkVTU0lPTjtcbiAgdmFyICRfXzMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0Q2hlY2tlci5qc1wiKSksXG4gICAgICBDT05TVCA9ICRfXzMuQ09OU1QsXG4gICAgICBNSU5VU19NSU5VUyA9ICRfXzMuTUlOVVNfTUlOVVMsXG4gICAgICBQTFVTX1BMVVMgPSAkX18zLlBMVVNfUExVUztcbiAgdmFyIFNjb3BlVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Njb3BlVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0Q2hlY2tlci5qc1wiKSkuU2NvcGVWaXNpdG9yO1xuICB2YXIgU2NvcGVDaGFpbkJ1aWxkZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TY29wZUNoYWluQnVpbGRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0NvbnN0Q2hlY2tlci5qc1wiKSkuU2NvcGVDaGFpbkJ1aWxkZXI7XG4gIHZhciBDb25zdENoZWNrZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIENvbnN0Q2hlY2tlcihzY29wZUJ1aWxkZXIsIHJlcG9ydGVyKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihDb25zdENoZWNrZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNjb3BlQnVpbGRlcl8gPSBzY29wZUJ1aWxkZXI7XG4gICAgICB0aGlzLnJlcG9ydGVyXyA9IHJlcG9ydGVyO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ29uc3RDaGVja2VyLCB7XG4gICAgICBwdXNoU2NvcGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUgPSB0aGlzLnNjb3BlQnVpbGRlcl8uZ2V0U2NvcGVGb3JUcmVlKHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0VW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm9wZXJhbmQudHlwZSA9PT0gSURFTlRJRklFUl9FWFBSRVNTSU9OICYmICh0cmVlLm9wZXJhdG9yLnR5cGUgPT09IFBMVVNfUExVUyB8fCB0cmVlLm9wZXJhdG9yLnR5cGUgPT09IE1JTlVTX01JTlVTKSkge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVNdXRhdGlvbl8odHJlZS5vcGVyYW5kKTtcbiAgICAgICAgfVxuICAgICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQodGhpcywgQ29uc3RDaGVja2VyLnByb3RvdHlwZSwgXCJ2aXNpdFVuYXJ5RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0UG9zdGZpeEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRyZWUub3BlcmFuZC50eXBlID09PSBJREVOVElGSUVSX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlTXV0YXRpb25fKHRyZWUub3BlcmFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENvbnN0Q2hlY2tlci5wcm90b3R5cGUsIFwidmlzaXRQb3N0Zml4RXhwcmVzc2lvblwiKS5jYWxsKHRoaXMsIHRyZWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0QmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAodHJlZS5sZWZ0LnR5cGUgPT09IElERU5USUZJRVJfRVhQUkVTU0lPTiAmJiB0cmVlLm9wZXJhdG9yLmlzQXNzaWdubWVudE9wZXJhdG9yKCkpIHtcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlTXV0YXRpb25fKHRyZWUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIENvbnN0Q2hlY2tlci5wcm90b3R5cGUsIFwidmlzaXRCaW5hcnlFeHByZXNzaW9uXCIpLmNhbGwodGhpcywgdHJlZSk7XG4gICAgICB9LFxuICAgICAgdmFsaWRhdGVNdXRhdGlvbl86IGZ1bmN0aW9uKGlkZW50aWZpZXJFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmluV2l0aEJsb2NrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKGlkZW50aWZpZXJFeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGJpbmRpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyICRfXzEgPSBiaW5kaW5nLFxuICAgICAgICAgICAgdHlwZSA9ICRfXzEudHlwZSxcbiAgICAgICAgICAgIHRyZWUgPSAkX18xLnRyZWU7XG4gICAgICAgIGlmICh0eXBlID09PSBDT05TVCkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3JfKGlkZW50aWZpZXJFeHByZXNzaW9uLmxvY2F0aW9uLCAodHJlZS5nZXRTdHJpbmdWYWx1ZSgpICsgXCIgaXMgcmVhZC1vbmx5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcG9ydEVycm9yXzogZnVuY3Rpb24obG9jYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRlcl8ucmVwb3J0RXJyb3IobG9jYXRpb24sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oU2NvcGVWaXNpdG9yKTtcbiAgZnVuY3Rpb24gdmFsaWRhdGUodHJlZSwgcmVwb3J0ZXIpIHtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBTY29wZUNoYWluQnVpbGRlcihyZXBvcnRlcik7XG4gICAgYnVpbGRlci52aXNpdEFueSh0cmVlKTtcbiAgICB2YXIgY2hlY2tlciA9IG5ldyBDb25zdENoZWNrZXIoYnVpbGRlciwgcmVwb3J0ZXIpO1xuICAgIGNoZWNrZXIudmlzaXRBbnkodHJlZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQgQ29uc3RDaGVja2VyKCkge1xuICAgICAgcmV0dXJuIENvbnN0Q2hlY2tlcjtcbiAgICB9LFxuICAgIGdldCB2YWxpZGF0ZSgpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZTtcbiAgICB9XG4gIH07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvc2VtYW50aWNzL0ZyZWVWYXJpYWJsZUNoZWNrZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9zZW1hbnRpY3MvRnJlZVZhcmlhYmxlQ2hlY2tlci5qc1wiO1xuICB2YXIgU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Njb3BlQ2hhaW5CdWlsZGVyV2l0aFJlZmVyZW5jZXMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3NlbWFudGljcy9GcmVlVmFyaWFibGVDaGVja2VyLmpzXCIpKS5TY29wZUNoYWluQnVpbGRlcldpdGhSZWZlcmVuY2VzO1xuICB2YXIgRnJlZVZhcmlhYmxlQ2hlY2tlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRnJlZVZhcmlhYmxlQ2hlY2tlcihyZXBvcnRlciwgZ2xvYmFsKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihGcmVlVmFyaWFibGVDaGVja2VyKS5jYWxsKHRoaXMsIHJlcG9ydGVyKTtcbiAgICAgIHRoaXMuZ2xvYmFsXyA9IGdsb2JhbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEZyZWVWYXJpYWJsZUNoZWNrZXIsIHtyZWZlcmVuY2VGb3VuZDogZnVuY3Rpb24odHJlZSwgbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zY29wZS5nZXRCaW5kaW5nKHRyZWUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLmdsb2JhbF8pKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRlci5yZXBvcnRFcnJvcih0cmVlLmxvY2F0aW9uLCAobmFtZSArIFwiIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgfX0sIHt9LCAkX19zdXBlcik7XG4gIH0oU2NvcGVDaGFpbkJ1aWxkZXJXaXRoUmVmZXJlbmNlcyk7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHRyZWUsIHJlcG9ydGVyKSB7XG4gICAgdmFyIGdsb2JhbCA9IGFyZ3VtZW50c1syXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMl0gOiBSZWZsZWN0Lmdsb2JhbDtcbiAgICB2YXIgY2hlY2tlciA9IG5ldyBGcmVlVmFyaWFibGVDaGVja2VyKHJlcG9ydGVyLCBnbG9iYWwpO1xuICAgIGNoZWNrZXIudmlzaXRBbnkodHJlZSk7XG4gIH1cbiAgcmV0dXJuIHtnZXQgdmFsaWRhdGUoKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGU7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyIEFtZFRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQW1kVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkFtZFRyYW5zZm9ybWVyO1xuICB2YXIgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0Fubm90YXRpb25zVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkFubm90YXRpb25zVHJhbnNmb3JtZXI7XG4gIHZhciBBcnJheUNvbXByZWhlbnNpb25UcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0FycmF5Q29tcHJlaGVuc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5BcnJheUNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIEFycm93RnVuY3Rpb25UcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0Fycm93RnVuY3Rpb25UcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuQXJyb3dGdW5jdGlvblRyYW5zZm9ybWVyO1xuICB2YXIgQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQXN5bmNHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5Bc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3M7XG4gIHZhciBBc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lcjtcbiAgdmFyIEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vQmxvY2tCaW5kaW5nVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkJsb2NrQmluZGluZ1RyYW5zZm9ybWVyO1xuICB2YXIgQ2xhc3NUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0NsYXNzVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkNsYXNzVHJhbnNmb3JtZXI7XG4gIHZhciBDbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9DbG9zdXJlTW9kdWxlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkNsb3N1cmVNb2R1bGVUcmFuc2Zvcm1lcjtcbiAgdmFyIENvbW1vbkpzTW9kdWxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Db21tb25Kc01vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5Db21tb25Kc01vZHVsZVRyYW5zZm9ybWVyO1xuICB2YXIgRGVmYXVsdFBhcmFtZXRlcnNUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0RlZmF1bHRQYXJhbWV0ZXJzVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkRlZmF1bHRQYXJhbWV0ZXJzVHJhbnNmb3JtZXI7XG4gIHZhciBEZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9EZXN0cnVjdHVyaW5nVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkRlc3RydWN0dXJpbmdUcmFuc2Zvcm1lcjtcbiAgdmFyIEV4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9FeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5FeHBvbmVudGlhdGlvblRyYW5zZm9ybWVyO1xuICB2YXIgRm9yT2ZUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0Zvck9mVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkZvck9mVHJhbnNmb3JtZXI7XG4gIHZhciBGb3JPblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRm9yT25UcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuRm9yT25UcmFuc2Zvcm1lcjtcbiAgdmFyIEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0dlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuR2VuZXJhdG9yQ29tcHJlaGVuc2lvblRyYW5zZm9ybWVyO1xuICB2YXIgR2VuZXJhdG9yVHJhbnNmb3JtUGFzcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0dlbmVyYXRvclRyYW5zZm9ybVBhc3MuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLkdlbmVyYXRvclRyYW5zZm9ybVBhc3M7XG4gIHZhciBJbmxpbmVNb2R1bGVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0lubGluZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5JbmxpbmVNb2R1bGVUcmFuc2Zvcm1lcjtcbiAgdmFyIEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5JbnN0YW50aWF0ZU1vZHVsZVRyYW5zZm9ybWVyO1xuICB2YXIgSnN4VHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Kc3hUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuSnN4VHJhbnNmb3JtZXI7XG4gIHZhciBNZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lcjtcbiAgdmFyIE1vZHVsZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTW9kdWxlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLk1vZHVsZVRyYW5zZm9ybWVyO1xuICB2YXIgTXVsdGlUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL011bHRpVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLk11bHRpVHJhbnNmb3JtZXI7XG4gIHZhciBOdW1lcmljTGl0ZXJhbFRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lcjtcbiAgdmFyIE9iamVjdExpdGVyYWxUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL09iamVjdExpdGVyYWxUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiKSkuT2JqZWN0TGl0ZXJhbFRyYW5zZm9ybWVyO1xuICB2YXIgUHJvcGVyVGFpbENhbGxUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Byb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlByb3BlclRhaWxDYWxsVHJhbnNmb3JtZXI7XG4gIHZhciBQcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1Byb3BlcnR5TmFtZVNob3J0aGFuZFRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5Qcm9wZXJ0eU5hbWVTaG9ydGhhbmRUcmFuc2Zvcm1lcjtcbiAgdmFyIFJlZ3VsYXJFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9SZWd1bGFyRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5SZWd1bGFyRXhwcmVzc2lvblRyYW5zZm9ybWVyO1xuICB2YXIgUmVzdFBhcmFtZXRlclRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUmVzdFBhcmFtZXRlclRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5SZXN0UGFyYW1ldGVyVHJhbnNmb3JtZXI7XG4gIHZhciBTcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9TcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlNwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lcjtcbiAgdmFyIFNwcmVhZFRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3ByZWFkVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlNwcmVhZFRyYW5zZm9ybWVyO1xuICB2YXIgU3VwZXJUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N1cGVyVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlN1cGVyVHJhbnNmb3JtZXI7XG4gIHZhciBTeW1ib2xUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1N5bWJvbFRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5TeW1ib2xUcmFuc2Zvcm1lcjtcbiAgdmFyIFRlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVGVtcGxhdGVMaXRlcmFsVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlRlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyO1xuICB2YXIgVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVHlwZVRvRXhwcmVzc2lvblRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS5UeXBlVG9FeHByZXNzaW9uVHJhbnNmb3JtZXI7XG4gIHZhciBUeXBlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UeXBlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlR5cGVUcmFuc2Zvcm1lcjtcbiAgdmFyIFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVW5pY29kZUVzY2FwZVNlcXVlbmNlVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlVuaWNvZGVFc2NhcGVTZXF1ZW5jZVRyYW5zZm9ybWVyO1xuICB2YXIgVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1VuaXF1ZUlkZW50aWZpZXJHZW5lcmF0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLlVuaXF1ZUlkZW50aWZpZXJHZW5lcmF0b3I7XG4gIHZhciB2YWxpZGF0ZUNvbnN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy9Db25zdENoZWNrZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0Zyb21PcHRpb25zVHJhbnNmb3JtZXIuanNcIikpLnZhbGlkYXRlO1xuICB2YXIgdmFsaWRhdGVGcmVlVmFyaWFibGVzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy9GcmVlVmFyaWFibGVDaGVja2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIpKS52YWxpZGF0ZTtcbiAgdmFyIEZyb21PcHRpb25zVHJhbnNmb3JtZXIgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIEZyb21PcHRpb25zVHJhbnNmb3JtZXIocmVwb3J0ZXIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciAkX18xO1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoRnJvbU9wdGlvbnNUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCByZXBvcnRlciwgb3B0aW9ucy52YWxpZGF0ZSk7XG4gICAgICB2YXIgdHJhbnNmb3JtT3B0aW9ucyA9IG9wdGlvbnMudHJhbnNmb3JtT3B0aW9ucztcbiAgICAgIHZhciBpZEdlbmVyYXRvciA9IG5ldyBVbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yKCk7XG4gICAgICB2YXIgYXBwZW5kID0gKCRfXzEgPSB0aGlzLCBmdW5jdGlvbih0cmFuc2Zvcm1lcikge1xuICAgICAgICAkX18xLmFwcGVuZChmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0cmFuc2Zvcm1lcihpZEdlbmVyYXRvciwgcmVwb3J0ZXIsIG9wdGlvbnMpLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmJsb2NrQmluZGluZykge1xuICAgICAgICB0aGlzLmFwcGVuZChmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb25zdCh0cmVlLCByZXBvcnRlcik7XG4gICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZnJlZVZhcmlhYmxlQ2hlY2tlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFsaWRhdGVGcmVlVmFyaWFibGVzKHRyZWUsIHJlcG9ydGVyKTtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5leHBvbmVudGlhdGlvbilcbiAgICAgICAgYXBwZW5kKEV4cG9uZW50aWF0aW9uVHJhbnNmb3JtZXIpO1xuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMubnVtZXJpY0xpdGVyYWxzKVxuICAgICAgICBhcHBlbmQoTnVtZXJpY0xpdGVyYWxUcmFuc2Zvcm1lcik7XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy51bmljb2RlRXhwcmVzc2lvbnMpXG4gICAgICAgIGFwcGVuZChSZWd1bGFyRXhwcmVzc2lvblRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmpzeCkge1xuICAgICAgICBhcHBlbmQoSnN4VHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMudGVtcGxhdGVMaXRlcmFscylcbiAgICAgICAgYXBwZW5kKFRlbXBsYXRlTGl0ZXJhbFRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnR5cGVzICYmIHRyYW5zZm9ybU9wdGlvbnMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgYXBwZW5kKFR5cGVUb0V4cHJlc3Npb25UcmFuc2Zvcm1lcik7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy51bmljb2RlRXNjYXBlU2VxdWVuY2VzKVxuICAgICAgICBhcHBlbmQoVW5pY29kZUVzY2FwZVNlcXVlbmNlVHJhbnNmb3JtZXIpO1xuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuYW5ub3RhdGlvbnMpXG4gICAgICAgIGFwcGVuZChBbm5vdGF0aW9uc1RyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnByb3BlcnR5TmFtZVNob3J0aGFuZClcbiAgICAgICAgYXBwZW5kKFByb3BlcnR5TmFtZVNob3J0aGFuZFRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLm1lbWJlclZhcmlhYmxlcykge1xuICAgICAgICBhcHBlbmQoTWVtYmVyVmFyaWFibGVUcmFuc2Zvcm1lcik7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5jbGFzc2VzKSB7XG4gICAgICAgIGFwcGVuZChTdXBlclRyYW5zZm9ybWVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmFycm93RnVuY3Rpb25zKSB7XG4gICAgICAgIGFwcGVuZChBcnJvd0Z1bmN0aW9uVHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuY2xhc3Nlcykge1xuICAgICAgICBhcHBlbmQoQ2xhc3NUcmFuc2Zvcm1lcik7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5zcHJlYWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGFwcGVuZChTcHJlYWRQcm9wZXJ0aWVzVHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMucHJvcGVydHlNZXRob2RzIHx8IHRyYW5zZm9ybU9wdGlvbnMuY29tcHV0ZWRQcm9wZXJ0eU5hbWVzIHx8IHRyYW5zZm9ybU9wdGlvbnMucHJvcGVyVGFpbENhbGxzKSB7XG4gICAgICAgIGFwcGVuZChPYmplY3RMaXRlcmFsVHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuZ2VuZXJhdG9yQ29tcHJlaGVuc2lvbilcbiAgICAgICAgYXBwZW5kKEdlbmVyYXRvckNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcik7XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5hcnJheUNvbXByZWhlbnNpb24pXG4gICAgICAgIGFwcGVuZChBcnJheUNvbXByZWhlbnNpb25UcmFuc2Zvcm1lcik7XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5mb3JPZilcbiAgICAgICAgYXBwZW5kKEZvck9mVHJhbnNmb3JtZXIpO1xuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuYXN5bmNHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFwcGVuZChBc3luY0dlbmVyYXRvclRyYW5zZm9ybVBhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMuZm9yT24pXG4gICAgICAgIGFwcGVuZChGb3JPblRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnJlc3RQYXJhbWV0ZXJzKVxuICAgICAgICBhcHBlbmQoUmVzdFBhcmFtZXRlclRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmRlZmF1bHRQYXJhbWV0ZXJzKVxuICAgICAgICBhcHBlbmQoRGVmYXVsdFBhcmFtZXRlcnNUcmFuc2Zvcm1lcik7XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5kZXN0cnVjdHVyaW5nKVxuICAgICAgICBhcHBlbmQoRGVzdHJ1Y3R1cmluZ1RyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnR5cGVzKVxuICAgICAgICBhcHBlbmQoVHlwZVRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnNwcmVhZClcbiAgICAgICAgYXBwZW5kKFNwcmVhZFRyYW5zZm9ybWVyKTtcbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLmJsb2NrQmluZGluZykge1xuICAgICAgICB0aGlzLmFwcGVuZChmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IEJsb2NrQmluZGluZ1RyYW5zZm9ybWVyKGlkR2VuZXJhdG9yLCByZXBvcnRlciwgdHJlZSk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5hc3luY0Z1bmN0aW9ucyAmJiBvcHRpb25zLmdlbmVyYXRvcnMgPT09ICdwYXJzZScpIHtcbiAgICAgICAgYXBwZW5kKEFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lcik7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybU9wdGlvbnMuZ2VuZXJhdG9ycyB8fCB0cmFuc2Zvcm1PcHRpb25zLmFzeW5jRnVuY3Rpb25zKSB7XG4gICAgICAgIGFwcGVuZChHZW5lcmF0b3JUcmFuc2Zvcm1QYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1PcHRpb25zLnN5bWJvbHMpXG4gICAgICAgIGFwcGVuZChTeW1ib2xUcmFuc2Zvcm1lcik7XG4gICAgICBpZiAodHJhbnNmb3JtT3B0aW9ucy5wcm9wZXJUYWlsQ2FsbHMpIHtcbiAgICAgICAgYXBwZW5kKFByb3BlclRhaWxDYWxsVHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybU9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybU9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGNhc2UgJ2NvbW1vbmpzJzpcbiAgICAgICAgICAgIGFwcGVuZChDb21tb25Kc01vZHVsZVRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FtZCc6XG4gICAgICAgICAgICBhcHBlbmQoQW1kVHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2xvc3VyZSc6XG4gICAgICAgICAgICBhcHBlbmQoQ2xvc3VyZU1vZHVsZVRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2lubGluZSc6XG4gICAgICAgICAgICBhcHBlbmQoSW5saW5lTW9kdWxlVHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnaW5zdGFudGlhdGUnOlxuICAgICAgICAgICAgYXBwZW5kKEluc3RhbnRpYXRlTW9kdWxlVHJhbnNmb3JtZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm9vdHN0cmFwJzpcbiAgICAgICAgICAgIGFwcGVuZChNb2R1bGVUcmFuc2Zvcm1lcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdwYXJzZSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZHVsZXMgdHJhbnNmb3JtIG9wdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShGcm9tT3B0aW9uc1RyYW5zZm9ybWVyLCB7fSwge30sICRfX3N1cGVyKTtcbiAgfShNdWx0aVRyYW5zZm9ybWVyKTtcbiAgcmV0dXJuIHtnZXQgRnJvbU9wdGlvbnNUcmFuc2Zvcm1lcigpIHtcbiAgICAgIHJldHVybiBGcm9tT3B0aW9uc1RyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5saW5lRVM2TW9kdWxlVHJhbnNmb3JtZXIuanNcIjtcbiAgdmFyICRfXzIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1Rva2VuVHlwZS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5saW5lRVM2TW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQ09OU1QgPSAkX18yLkNPTlNULFxuICAgICAgTEVUID0gJF9fMi5MRVQ7XG4gIHZhciBNb2R1bGVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL01vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9JbmxpbmVFUzZNb2R1bGVUcmFuc2Zvcm1lci5qc1wiKSkuTW9kdWxlVHJhbnNmb3JtZXI7XG4gIHZhciAkX180ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGFyc2VUcmVlRmFjdG9yeS5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5saW5lRVM2TW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCA9ICRfXzQuY3JlYXRlQXNzaWdubWVudFN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUFyZ3VtZW50TGlzdCA9ICRfXzQuY3JlYXRlQXJndW1lbnRMaXN0LFxuICAgICAgY3JlYXRlQmluZGluZ0lkZW50aWZpZXIgPSAkX180LmNyZWF0ZUJpbmRpbmdJZGVudGlmaWVyLFxuICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24gPSAkX180LmNyZWF0ZUNhbGxFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCA9ICRfXzQuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUZvckluU3RhdGVtZW50ID0gJF9fNC5jcmVhdGVGb3JJblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZUZ1bmN0aW9uQm9keSA9ICRfXzQuY3JlYXRlRnVuY3Rpb25Cb2R5LFxuICAgICAgY3JlYXRlSWZTdGF0ZW1lbnQgPSAkX180LmNyZWF0ZUlmU3RhdGVtZW50LFxuICAgICAgY3JlYXRlSW1tZWRpYXRlbHlJbnZva2VkRnVuY3Rpb25FeHByZXNzaW9uID0gJF9fNC5jcmVhdGVJbW1lZGlhdGVseUludm9rZWRGdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbiA9ICRfXzQuY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24sXG4gICAgICBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uID0gJF9fNC5jcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uLFxuICAgICAgY3JlYXRlTWVtYmVyRXhwcmVzc2lvbiA9ICRfXzQuY3JlYXRlTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgIGNyZWF0ZU9iamVjdExpdGVyYWwgPSAkX180LmNyZWF0ZU9iamVjdExpdGVyYWwsXG4gICAgICBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQgPSAkX180LmNyZWF0ZVJldHVyblN0YXRlbWVudCxcbiAgICAgIGNyZWF0ZVVzZVN0cmljdERpcmVjdGl2ZSA9ICRfXzQuY3JlYXRlVXNlU3RyaWN0RGlyZWN0aXZlLFxuICAgICAgY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QgPSAkX180LmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0LFxuICAgICAgY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQgPSAkX180LmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50O1xuICB2YXIgSU1QT1JUX1NQRUNJRklFUl9TRVQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L3RyZWVzL1BhcnNlVHJlZVR5cGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5JTVBPUlRfU1BFQ0lGSUVSX1NFVDtcbiAgdmFyIEFub25CbG9jayA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vSW5saW5lRVM2TW9kdWxlVHJhbnNmb3JtZXIuanNcIikpLkFub25CbG9jaztcbiAgdmFyIHBhcnNlU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL0lubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyLmpzXCIpKS5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIGFub25JbmxpbmVNb2R1bGVzID0gMDtcbiAgdmFyIElubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBJbmxpbmVFUzZNb2R1bGVUcmFuc2Zvcm1lcihpZGVudGlmaWVyR2VuZXJhdG9yLCByZXBvcnRlciwgb3B0aW9ucywgbWV0YWRhdGEpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKElubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyKS5jYWxsKHRoaXMsIGlkZW50aWZpZXJHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zKTtcbiAgICAgIHRoaXMubWV0YWRhdGFfID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbmxpbmVFUzZNb2R1bGVUcmFuc2Zvcm1lciwge1xuICAgICAgbW9kdWxlUHJvbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtjcmVhdGVVc2VTdHJpY3REaXJlY3RpdmUoKV07XG4gICAgICB9LFxuICAgICAgd3JhcE1vZHVsZTogZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICAgICAgICB2YXIgc2VlZCA9IHRoaXMubW9kdWxlTmFtZSB8fCAnYW5vbl8nICsgKythbm9uSW5saW5lTW9kdWxlcztcbiAgICAgICAgdmFyIGlkTmFtZSA9IHRoaXMuZ2V0VGVtcFZhck5hbWVGb3JNb2R1bGVOYW1lKHNlZWQpO1xuICAgICAgICBpZiAodGhpcy5pc1Jvb3RNb2R1bGUpIHtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnBvcCgpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gY3JlYXRlRnVuY3Rpb25Cb2R5KHN0YXRlbWVudHMpO1xuICAgICAgICB2YXIgbW9kdWxlRXhwcmVzc2lvbiA9IGNyZWF0ZUltbWVkaWF0ZWx5SW52b2tlZEZ1bmN0aW9uRXhwcmVzc2lvbihib2R5KTtcbiAgICAgICAgcmV0dXJuIFtjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChDT05TVCwgaWROYW1lLCBtb2R1bGVFeHByZXNzaW9uKV07XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRXhwb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSb290TW9kdWxlKVxuICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB0aGlzLmV4cG9ydFZpc2l0b3IudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLmRlY2xhcmF0aW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1JbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICBpZiAoIXRyZWUuaW1wb3J0Q2xhdXNlIHx8ICh0cmVlLmltcG9ydENsYXVzZS50eXBlID09PSBJTVBPUlRfU1BFQ0lGSUVSX1NFVCAmJiB0cmVlLmltcG9ydENsYXVzZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZVNwZWNpZmllcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy50cmFuc2Zvcm1BbnkodHJlZS5pbXBvcnRDbGF1c2UpO1xuICAgICAgICB2YXIgaW5pdGlhbGl6ZXIgPSB0aGlzLnRyYW5zZm9ybUFueSh0cmVlLm1vZHVsZVNwZWNpZmllcik7XG4gICAgICAgIHJldHVybiBjcmVhdGVWYXJpYWJsZVN0YXRlbWVudChDT05TVCwgYmluZGluZywgaW5pdGlhbGl6ZXIpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybU5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbkJsb2NrKG51bGwsIFtdKTtcbiAgICAgIH0sXG4gICAgICBhZGRFeHBvcnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyICRfXzEgPSB0aGlzO1xuICAgICAgICB2YXIgZXhwb3J0UHJvcGVydGllcyA9IHRoaXMuZ2V0RXhwb3J0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgZXhwb3J0T2JqZWN0ID0gY3JlYXRlT2JqZWN0TGl0ZXJhbChleHBvcnRQcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwb3J0VmlzaXRvci5zdGFyRXhwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc3RhckV4cG9ydHMgPSB0aGlzLmV4cG9ydFZpc2l0b3Iuc3RhckV4cG9ydHM7XG4gICAgICAgICAgdmFyIHN0YXJJZGVudHMgPSBzdGFyRXhwb3J0cy5tYXAoZnVuY3Rpb24obW9kdWxlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oJF9fMS5nZXRUZW1wVmFyTmFtZUZvck1vZHVsZVNwZWNpZmllcihtb2R1bGVTcGVjaWZpZXIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXhwb3J0UHJvcGVydGllcy5sZW5ndGgpXG4gICAgICAgICAgICBzdGFySWRlbnRzLnB1c2goZXhwb3J0T2JqZWN0KTtcbiAgICAgICAgICB2YXIgZXhwb3J0cyA9IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoTEVULCBleHBvcnRzLCBjcmVhdGVPYmplY3RMaXRlcmFsKFwiXCIpKSk7XG4gICAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0VGVtcElkZW50aWZpZXIoKTtcbiAgICAgICAgICBzdGFySWRlbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhcklkZW50KSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goY3JlYXRlRm9ySW5TdGF0ZW1lbnQoY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoTEVULCBrZXksIG51bGwpLCBzdGFySWRlbnQsIGNyZWF0ZUlmU3RhdGVtZW50KGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNyZWF0ZU1lbWJlckV4cHJlc3Npb24oc3RhcklkZW50LCAnaGFzT3duUHJvcGVydHknKSwgY3JlYXRlQXJndW1lbnRMaXN0KFtjcmVhdGVJZGVudGlmaWVyRXhwcmVzc2lvbihrZXkpXSkpLCBjcmVhdGVBc3NpZ25tZW50U3RhdGVtZW50KGNyZWF0ZU1lbWJlckxvb2t1cEV4cHJlc3Npb24oY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oZXhwb3J0cyksIGNyZWF0ZUlkZW50aWZpZXJFeHByZXNzaW9uKGtleSkpLCBjcmVhdGVNZW1iZXJMb29rdXBFeHByZXNzaW9uKHN0YXJJZGVudCwgY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oa2V5KSkpKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChjcmVhdGVSZXR1cm5TdGF0ZW1lbnQoY3JlYXRlSWRlbnRpZmllckV4cHJlc3Npb24oZXhwb3J0cykpKTtcbiAgICAgICAgICByZXR1cm4gc3RhdGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocGFyc2VTdGF0ZW1lbnQoJHRyYWNldXJSdW50aW1lLmdldFRlbXBsYXRlT2JqZWN0KFtcInJldHVybiBcIiwgXCJcIl0pLCBleHBvcnRPYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCaW5kaW5nSWRlbnRpZmllcih0aGlzLmdldFRlbXBWYXJOYW1lRm9yTW9kdWxlU3BlY2lmaWVyKHRyZWUpKTtcbiAgICAgIH0sXG4gICAgICBnZXQgaXNSb290TW9kdWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVOYW1lID09PSAodGhpcy5tZXRhZGF0YV8gJiYgdGhpcy5tZXRhZGF0YV8ucm9vdE1vZHVsZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShNb2R1bGVUcmFuc2Zvcm1lcik7XG4gIHJldHVybiB7Z2V0IElubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyKCkge1xuICAgICAgcmV0dXJuIElubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1B1cmVFUzZUcmFuc2Zvcm1lci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1B1cmVFUzZUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgQW5ub3RhdGlvbnNUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0Fubm90YXRpb25zVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL1B1cmVFUzZUcmFuc2Zvcm1lci5qc1wiKSkuQW5ub3RhdGlvbnNUcmFuc2Zvcm1lcjtcbiAgdmFyIEFzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0FzeW5jVG9HZW5lcmF0b3JUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIpKS5Bc3luY1RvR2VuZXJhdG9yVHJhbnNmb3JtZXI7XG4gIHZhciBJbmxpbmVFUzZNb2R1bGVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0lubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QdXJlRVM2VHJhbnNmb3JtZXIuanNcIikpLklubGluZUVTNk1vZHVsZVRyYW5zZm9ybWVyO1xuICB2YXIgSnN4VHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Kc3hUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIpKS5Kc3hUcmFuc2Zvcm1lcjtcbiAgdmFyIE1lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9NZW1iZXJWYXJpYWJsZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QdXJlRVM2VHJhbnNmb3JtZXIuanNcIikpLk1lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXI7XG4gIHZhciBNdWx0aVRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTXVsdGlUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIpKS5NdWx0aVRyYW5zZm9ybWVyO1xuICB2YXIgU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vU3ByZWFkUHJvcGVydGllc1RyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QdXJlRVM2VHJhbnNmb3JtZXIuanNcIikpLlNwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lcjtcbiAgdmFyIFR5cGVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL1R5cGVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIpKS5UeXBlVHJhbnNmb3JtZXI7XG4gIHZhciBVbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIpKS5VbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yO1xuICB2YXIgdmFsaWRhdGVGcmVlVmFyaWFibGVzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3NlbWFudGljcy9GcmVlVmFyaWFibGVDaGVja2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9QdXJlRVM2VHJhbnNmb3JtZXIuanNcIikpLnZhbGlkYXRlO1xuICB2YXIgUHVyZUVTNlRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBQdXJlRVM2VHJhbnNmb3JtZXIocmVwb3J0ZXIsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gICAgICB2YXIgJF9fMTtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFB1cmVFUzZUcmFuc2Zvcm1lcikuY2FsbCh0aGlzLCByZXBvcnRlciwgb3B0aW9ucy52YWxpZGF0ZSk7XG4gICAgICB2YXIgaWRHZW5lcmF0b3IgPSBuZXcgVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvcigpO1xuICAgICAgdmFyIGFwcGVuZCA9ICgkX18xID0gdGhpcywgZnVuY3Rpb24odHJhbnNmb3JtZXIpIHtcbiAgICAgICAgJF9fMS5hcHBlbmQoZnVuY3Rpb24odHJlZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdHJhbnNmb3JtZXIoaWRHZW5lcmF0b3IsIHJlcG9ydGVyLCBvcHRpb25zLCBtZXRhZGF0YSkudHJhbnNmb3JtQW55KHRyZWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZnJlZVZhcmlhYmxlQ2hlY2tlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgICAgdmFsaWRhdGVGcmVlVmFyaWFibGVzKHRyZWUsIHJlcG9ydGVyKTtcbiAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5qc3gpIHtcbiAgICAgICAgYXBwZW5kKEpzeFRyYW5zZm9ybWVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNwcmVhZFByb3BlcnRpZXMpIHtcbiAgICAgICAgYXBwZW5kKFNwcmVhZFByb3BlcnRpZXNUcmFuc2Zvcm1lcik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5tZW1iZXJWYXJpYWJsZXMpIHtcbiAgICAgICAgYXBwZW5kKE1lbWJlclZhcmlhYmxlVHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgICAgYXBwZW5kKEFubm90YXRpb25zVHJhbnNmb3JtZXIpO1xuICAgICAgYXBwZW5kKFR5cGVUcmFuc2Zvcm1lcik7XG4gICAgICBhcHBlbmQoQXN5bmNUb0dlbmVyYXRvclRyYW5zZm9ybWVyKTtcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgIGFwcGVuZChJbmxpbmVFUzZNb2R1bGVUcmFuc2Zvcm1lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShQdXJlRVM2VHJhbnNmb3JtZXIsIHt9LCB7fSwgJF9fc3VwZXIpO1xuICB9KE11bHRpVHJhbnNmb3JtZXIpO1xuICByZXR1cm4ge2dldCBQdXJlRVM2VHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gUHVyZUVTNlRyYW5zZm9ybWVyO1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL0NvbXBpbGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvQ29tcGlsZXIuanNcIjtcbiAgdmFyIEF0dGFjaE1vZHVsZU5hbWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9BdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL0NvbXBpbGVyLmpzXCIpKS5BdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXI7XG4gIHZhciBGcm9tT3B0aW9uc1RyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vY29kZWdlbmVyYXRpb24vRnJvbU9wdGlvbnNUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvQ29tcGlsZXIuanNcIikpLkZyb21PcHRpb25zVHJhbnNmb3JtZXI7XG4gIHZhciBQYXJzZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9zeW50YXgvUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSkuUGFyc2VyO1xuICB2YXIgUHVyZUVTNlRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSkuUHVyZUVTNlRyYW5zZm9ybWVyO1xuICB2YXIgU291cmNlRmlsZSA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N5bnRheC9Tb3VyY2VGaWxlLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSkuU291cmNlRmlsZTtcbiAgdmFyIENvbGxlY3RpbmdFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vdXRpbC9Db2xsZWN0aW5nRXJyb3JSZXBvcnRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvQ29tcGlsZXIuanNcIikpLkNvbGxlY3RpbmdFcnJvclJlcG9ydGVyO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9PcHRpb25zLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSksXG4gICAgICBPcHRpb25zID0gJF9fMTAuT3B0aW9ucyxcbiAgICAgIHZlcnNpb25Mb2NrZWRPcHRpb25zID0gJF9fMTAudmVyc2lvbkxvY2tlZE9wdGlvbnM7XG4gIHZhciBQYXJzZVRyZWVNYXBXcml0ZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9vdXRwdXRnZW5lcmF0aW9uL1BhcnNlVHJlZU1hcFdyaXRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvQ29tcGlsZXIuanNcIikpLlBhcnNlVHJlZU1hcFdyaXRlcjtcbiAgdmFyIFBhcnNlVHJlZVdyaXRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlV3JpdGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSkuUGFyc2VUcmVlV3JpdGVyO1xuICB2YXIgJF9fMTMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9vdXRwdXRnZW5lcmF0aW9uL1NvdXJjZU1hcEludGVncmF0aW9uLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9Db21waWxlci5qc1wiKSksXG4gICAgICBTb3VyY2VNYXBDb25zdW1lciA9ICRfXzEzLlNvdXJjZU1hcENvbnN1bWVyLFxuICAgICAgU291cmNlTWFwR2VuZXJhdG9yID0gJF9fMTMuU291cmNlTWFwR2VuZXJhdG9yO1xuICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBzcmNzID0gW10sXG4gICAgICAgICRfXzIgPSAwOyAkX18yIDwgYXJndW1lbnRzLmxlbmd0aDsgJF9fMisrKVxuICAgICAgc3Jjc1skX18yXSA9IGFyZ3VtZW50c1skX18yXTtcbiAgICB2YXIgZGVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc3Jjcy5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xuICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNyY01vZHVsZXMgPSBzcmMubW9kdWxlcztcbiAgICAgIGlmICh0eXBlb2Ygc3JjTW9kdWxlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVzdC5tb2R1bGVzID0gc3JjTW9kdWxlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBmdW5jdGlvbiBiYXNlUGF0aChuYW1lKSB7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdmFyIGxhc3RTbGFzaCA9IG5hbWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICBpZiAobGFzdFNsYXNoIDwgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBuYW1lLnN1YnN0cmluZygwLCBsYXN0U2xhc2ggKyAxKTtcbiAgfVxuICB2YXIgQ29tcGlsZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlcigpIHtcbiAgICAgIHZhciBvdmVycmlkaW5nT3B0aW9ucyA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHRoaXMub3B0aW9uc18gPSBuZXcgT3B0aW9ucyh0aGlzLmRlZmF1bHRPcHRpb25zKCkpO1xuICAgICAgdGhpcy5vcHRpb25zXy5zZXRGcm9tT2JqZWN0KG92ZXJyaWRpbmdPcHRpb25zKTtcbiAgICAgIHRoaXMuc291cmNlTWFwQ29uZmlndXJhdGlvbl8gPSBudWxsO1xuICAgICAgdGhpcy5zb3VyY2VNYXBJbmZvXyA9IG51bGw7XG4gICAgICB0aGlzLnNvdXJjZU1hcENhY2hlXyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShDb21waWxlciwge1xuICAgICAgY29tcGlsZTogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc291cmNlTmFtZSA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiAnPGNvbXBpbGVTb3VyY2U+JztcbiAgICAgICAgdmFyIG91dHB1dE5hbWUgPSBhcmd1bWVudHNbMl0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzJdIDogJzxjb21waWxlT3V0cHV0Pic7XG4gICAgICAgIHZhciBzb3VyY2VSb290ID0gYXJndW1lbnRzWzNdO1xuICAgICAgICBzb3VyY2VOYW1lID0gdGhpcy5ub3JtYWxpemUoc291cmNlTmFtZSk7XG4gICAgICAgIG91dHB1dE5hbWUgPSB0aGlzLm5vcm1hbGl6ZShvdXRwdXROYW1lKTtcbiAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnBhcnNlKGNvbnRlbnQsIHNvdXJjZU5hbWUpO1xuICAgICAgICB0cmVlID0gdGhpcy50cmFuc2Zvcm0odHJlZSwgc291cmNlTmFtZSk7XG4gICAgICAgIHZhciBzb3VyY2VVUkwgPSBzb3VyY2VOYW1lICE9PSBvdXRwdXROYW1lID8gc291cmNlTmFtZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBzb3VyY2VSb290ID0gdGhpcy5vcHRpb25zXy5zb3VyY2VSb290O1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZSh0cmVlLCBvdXRwdXROYW1lLCBzb3VyY2VSb290LCBzb3VyY2VVUkwpO1xuICAgICAgfSxcbiAgICAgIHRocm93SWZFcnJvcnM6IGZ1bmN0aW9uKGVycm9yUmVwb3J0ZXIpIHtcbiAgICAgICAgaWYgKGVycm9yUmVwb3J0ZXIuaGFkRXJyb3IoKSlcbiAgICAgICAgICB0aHJvdyBlcnJvclJlcG9ydGVyLnRvRXJyb3IoKTtcbiAgICAgIH0sXG4gICAgICBwYXJzZTogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgc291cmNlTmFtZSA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiAnPGNvbXBpbGVyLXBhcnNlLWlucHV0Pic7XG4gICAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLm5vcm1hbGl6ZShzb3VyY2VOYW1lKTtcbiAgICAgICAgdGhpcy5zb3VyY2VNYXBDYWNoZV8gPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZU1hcENvbmZpZ3VyYXRpb25fID0gbnVsbDtcbiAgICAgICAgdmFyIGVycm9yUmVwb3J0ZXIgPSBuZXcgQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIoKTtcbiAgICAgICAgdmFyIHNvdXJjZUZpbGUgPSBuZXcgU291cmNlRmlsZShzb3VyY2VOYW1lLCBjb250ZW50KTtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoc291cmNlRmlsZSwgZXJyb3JSZXBvcnRlciwgdGhpcy5vcHRpb25zXyk7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy5vcHRpb25zXy5zY3JpcHQgPyBwYXJzZXIucGFyc2VTY3JpcHQoKSA6IHBhcnNlci5wYXJzZU1vZHVsZSgpO1xuICAgICAgICB0aGlzLnRocm93SWZFcnJvcnMoZXJyb3JSZXBvcnRlcik7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlTW9kdWxlTmFtZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXI7XG4gICAgICAgIGlmIChjYW5kaWRhdGVNb2R1bGVOYW1lKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVyJF9fMyA9IG5ldyBBdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIoY2FuZGlkYXRlTW9kdWxlTmFtZSk7XG4gICAgICAgICAgdHJlZSA9IHRyYW5zZm9ybWVyJF9fMy50cmFuc2Zvcm1BbnkodHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yUmVwb3J0ZXIgPSBuZXcgQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ub3V0cHV0TGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA9PT0gJ2VzNicpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IG5ldyBQdXJlRVM2VHJhbnNmb3JtZXIoZXJyb3JSZXBvcnRlciwgdGhpcy5vcHRpb25zXywgbWV0YWRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0gbmV3IEZyb21PcHRpb25zVHJhbnNmb3JtZXIoZXJyb3JSZXBvcnRlciwgdGhpcy5vcHRpb25zXyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkVHJlZSA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0cmVlKTtcbiAgICAgICAgdGhpcy50aHJvd0lmRXJyb3JzKGVycm9yUmVwb3J0ZXIpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRUcmVlO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNvdXJjZU1hcENvbmZpZ3VyYXRpb25fOiBmdW5jdGlvbihvdXRwdXROYW1lKSB7XG4gICAgICAgIHZhciBzb3VyY2VSb290ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgc291cmNlVVJMID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VNYXBzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZU1hcEdlbmVyYXRvcjogbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgICAgICAgIGZpbGU6IG91dHB1dE5hbWUsXG4gICAgICAgICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3QsXG4gICAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJhc2VwYXRoOiBiYXNlUGF0aChvdXRwdXROYW1lKSxcbiAgICAgICAgICAgIGlucHV0U291cmNlTWFwOiB0aGlzLm9wdGlvbnNfLmlucHV0U291cmNlTWFwLFxuICAgICAgICAgICAgc291cmNlVVJMOiBzb3VyY2VVUkwsXG4gICAgICAgICAgICBvdXRwdXROYW1lOiBvdXRwdXROYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFNvdXJjZU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcENhY2hlXykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hcENhY2hlXztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3VyY2VNYXBDb25maWd1cmF0aW9uXykge1xuICAgICAgICAgIHZhciBzb3VyY2VNYXAgPSB0aGlzLnNvdXJjZU1hcENvbmZpZ3VyYXRpb25fLnNvdXJjZU1hcEdlbmVyYXRvci50b1N0cmluZygpO1xuICAgICAgICAgIHZhciBpbnB1dFNvdXJjZU1hcCA9IHRoaXMuc291cmNlTWFwQ29uZmlndXJhdGlvbl8uaW5wdXRTb3VyY2VNYXA7XG4gICAgICAgICAgaWYgKGlucHV0U291cmNlTWFwKSB7XG4gICAgICAgICAgICB2YXIgZ2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAobmV3IFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCkpO1xuICAgICAgICAgICAgZ2VuZXJhdG9yLmFwcGx5U291cmNlTWFwKG5ldyBTb3VyY2VNYXBDb25zdW1lcihpbnB1dFNvdXJjZU1hcCkpO1xuICAgICAgICAgICAgc291cmNlTWFwID0gZ2VuZXJhdG9yLnRvSlNPTigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNvdXJjZU1hcENhY2hlXyA9IHNvdXJjZU1hcDtcbiAgICAgICAgICByZXR1cm4gc291cmNlTWFwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0IHNvdXJjZU1hcEluZm8oKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VNYXBJbmZvXyAmJiB0aGlzLnNvdXJjZU1hcENvbmZpZ3VyYXRpb25fKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZU1hcCA9IHRoaXMuZ2V0U291cmNlTWFwKCk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VNYXBJbmZvXyA9IHtcbiAgICAgICAgICAgIHVybDogdGhpcy5zb3VyY2VNYXBDb25maWd1cmF0aW9uXy5zb3VyY2VVUkwsXG4gICAgICAgICAgICBvdXRwdXROYW1lOiB0aGlzLnNvdXJjZU1hcENvbmZpZ3VyYXRpb25fLm91dHB1dE5hbWUsXG4gICAgICAgICAgICBtYXA6IHNvdXJjZU1hcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwSW5mb187XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG91dHB1dE5hbWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBzb3VyY2VSb290ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgc291cmNlVVJMID0gYXJndW1lbnRzWzNdO1xuICAgICAgICBvdXRwdXROYW1lID0gdGhpcy5ub3JtYWxpemUob3V0cHV0TmFtZSk7XG4gICAgICAgIGlmIChzb3VyY2VSb290ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgc291cmNlUm9vdCA9IHRoaXMub3B0aW9uc18uc291cmNlUm9vdDtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgPT09IHRydWUpXG4gICAgICAgICAgc291cmNlUm9vdCA9IGJhc2VQYXRoKG91dHB1dE5hbWUpO1xuICAgICAgICBlbHNlIGlmICghc291cmNlUm9vdClcbiAgICAgICAgICBzb3VyY2VSb290ID0gdW5kZWZpbmVkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc291cmNlUm9vdCA9IHRoaXMubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICAgICAgICB2YXIgd3JpdGVyO1xuICAgICAgICB0aGlzLnNvdXJjZU1hcENhY2hlXyA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlTWFwQ29uZmlndXJhdGlvbl8gPSB0aGlzLmNyZWF0ZVNvdXJjZU1hcENvbmZpZ3VyYXRpb25fKG91dHB1dE5hbWUsIHNvdXJjZVJvb3QsIHNvdXJjZVVSTCk7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcENvbmZpZ3VyYXRpb25fKSB7XG4gICAgICAgICAgdGhpcy5zb3VyY2VNYXBDb25maWd1cmF0aW9uXy5sb3dSZXNvbHV0aW9uID0gdGhpcy5vcHRpb25zXy5sb3dSZXNvbHV0aW9uU291cmNlTWFwO1xuICAgICAgICAgIHdyaXRlciA9IG5ldyBQYXJzZVRyZWVNYXBXcml0ZXIodGhpcy5zb3VyY2VNYXBDb25maWd1cmF0aW9uXywgdGhpcy5vcHRpb25zXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyID0gbmV3IFBhcnNlVHJlZVdyaXRlcih0aGlzLm9wdGlvbnNfKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHZhciBjb21waWxlZENvZGUgPSB3cml0ZXIudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmRlYnVnZ2VyTGluayhzb3VyY2VVUkwsIG91dHB1dE5hbWUpO1xuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgIGNvbXBpbGVkQ29kZSArPSBsaW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlZENvZGU7XG4gICAgICB9LFxuICAgICAgZGVidWdnZXJMaW5rOiBmdW5jdGlvbihzb3VyY2VVUkwsIG91dHB1dE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlTWFwQ29uZmlndXJhdGlvbl8pIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VNYXBzID09PSAnbWVtb3J5Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IHRoaXMuc291cmNlTWFwcGluZ1VSTChzb3VyY2VVUkwgfHwgb3V0cHV0TmFtZSB8fCAndW5uYW1lZC5qcycpO1xuICAgICAgICAgIHJldHVybiAnLy8jIHNvdXJjZU1hcHBpbmdVUkw9JyArIHNvdXJjZU1hcHBpbmdVUkwgKyAnXFxuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc291cmNlVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8vIyBzb3VyY2VVUkw9JyArIHNvdXJjZVVSTCArICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNvdXJjZU5hbWU6IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICAgIH0sXG4gICAgICBzb3VyY2VNYXBwaW5nVVJMOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnNvdXJjZU1hcHMgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgaWYgKFJlZmxlY3QuZ2xvYmFsLmJ0b2EpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGhpcy5nZXRTb3VyY2VNYXAoKSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGggfHwgJ3VuYW1lZC5qcyc7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIHJldHVybiBwYXRoICsgJy5tYXAnO1xuICAgICAgfSxcbiAgICAgIHNvdXJjZU5hbWVGcm9tVHJlZTogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gdHJlZS5sb2NhdGlvbi5zdGFydC5zb3VyY2UubmFtZTtcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTG9ja2VkT3B0aW9ucztcbiAgICAgIH0sXG4gICAgICBub3JtYWxpemU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgJiYgbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2NyaXB0OiBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICBvcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc2NyaXB0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlcihvcHRpb25zKS5jb21waWxlKGNvbnRlbnQpO1xuICAgICAgfSxcbiAgICAgIG1vZHVsZTogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgb3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLm1vZHVsZXMgPSAnYm9vdHN0cmFwJztcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlcihvcHRpb25zKS5jb21waWxlKGNvbnRlbnQpO1xuICAgICAgfSxcbiAgICAgIGFtZE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1swXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIGFtZE9wdGlvbnMgPSB7XG4gICAgICAgICAgbW9kdWxlczogJ2FtZCcsXG4gICAgICAgICAgc291cmNlTWFwczogZmFsc2UsXG4gICAgICAgICAgbW9kdWxlTmFtZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGFtZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGNsb3N1cmVPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMF0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBjbG9zdXJlT3B0aW9ucyA9IHtcbiAgICAgICAgICBtb2R1bGVzOiAnY2xvc3VyZScsXG4gICAgICAgICAgc291cmNlTWFwczogZmFsc2UsXG4gICAgICAgICAgbW9kdWxlTmFtZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWVyZ2UoY2xvc3VyZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgfSxcbiAgICAgIGNvbW1vbkpTT3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgY29tbW9uanNPcHRpb25zID0ge1xuICAgICAgICAgIG1vZHVsZXM6ICdjb21tb25qcycsXG4gICAgICAgICAgc291cmNlTWFwczogZmFsc2UsXG4gICAgICAgICAgbW9kdWxlTmFtZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGNvbW1vbmpzT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgQ29tcGlsZXIoKSB7XG4gICAgICByZXR1cm4gQ29tcGlsZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xvbmVUcmVlVHJhbnNmb3JtZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9DbG9uZVRyZWVUcmFuc2Zvcm1lci5qc1wiO1xuICB2YXIgUGFyc2VUcmVlVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9QYXJzZVRyZWVUcmFuc2Zvcm1lci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xvbmVUcmVlVHJhbnNmb3JtZXIuanNcIikpLlBhcnNlVHJlZVRyYW5zZm9ybWVyO1xuICB2YXIgJF9fMiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvdHJlZXMvUGFyc2VUcmVlcy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vQ2xvbmVUcmVlVHJhbnNmb3JtZXIuanNcIikpLFxuICAgICAgQmluZGluZ0lkZW50aWZpZXIgPSAkX18yLkJpbmRpbmdJZGVudGlmaWVyLFxuICAgICAgQnJlYWtTdGF0ZW1lbnQgPSAkX18yLkJyZWFrU3RhdGVtZW50LFxuICAgICAgQ29udGludWVTdGF0ZW1lbnQgPSAkX18yLkNvbnRpbnVlU3RhdGVtZW50LFxuICAgICAgRGVidWdnZXJTdGF0ZW1lbnQgPSAkX18yLkRlYnVnZ2VyU3RhdGVtZW50LFxuICAgICAgRW1wdHlTdGF0ZW1lbnQgPSAkX18yLkVtcHR5U3RhdGVtZW50LFxuICAgICAgRXhwb3J0U3BlY2lmaWVyID0gJF9fMi5FeHBvcnRTcGVjaWZpZXIsXG4gICAgICBFeHBvcnRTdGFyID0gJF9fMi5FeHBvcnRTdGFyLFxuICAgICAgSWRlbnRpZmllckV4cHJlc3Npb24gPSAkX18yLklkZW50aWZpZXJFeHByZXNzaW9uLFxuICAgICAgTGl0ZXJhbEV4cHJlc3Npb24gPSAkX18yLkxpdGVyYWxFeHByZXNzaW9uLFxuICAgICAgTW9kdWxlU3BlY2lmaWVyID0gJF9fMi5Nb2R1bGVTcGVjaWZpZXIsXG4gICAgICBQcmVkZWZpbmVkVHlwZSA9ICRfXzIuUHJlZGVmaW5lZFR5cGUsXG4gICAgICBQcm9wZXJ0eU5hbWVTaG9ydGhhbmQgPSAkX18yLlByb3BlcnR5TmFtZVNob3J0aGFuZCxcbiAgICAgIFRlbXBsYXRlTGl0ZXJhbFBvcnRpb24gPSAkX18yLlRlbXBsYXRlTGl0ZXJhbFBvcnRpb24sXG4gICAgICBTdXBlckV4cHJlc3Npb24gPSAkX18yLlN1cGVyRXhwcmVzc2lvbixcbiAgICAgIFRoaXNFeHByZXNzaW9uID0gJF9fMi5UaGlzRXhwcmVzc2lvbjtcbiAgdmFyIENsb25lVHJlZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBDbG9uZVRyZWVUcmFuc2Zvcm1lcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKENsb25lVHJlZVRyYW5zZm9ybWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ2xvbmVUcmVlVHJhbnNmb3JtZXIsIHtcbiAgICAgIHRyYW5zZm9ybUJpbmRpbmdJZGVudGlmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ0lkZW50aWZpZXIodHJlZS5sb2NhdGlvbiwgdHJlZS5pZGVudGlmaWVyVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUJyZWFrU3RhdGVtZW50OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnJlYWtTdGF0ZW1lbnQodHJlZS5sb2NhdGlvbiwgdHJlZS5uYW1lKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRpbnVlU3RhdGVtZW50KHRyZWUubG9jYXRpb24sIHRyZWUubmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtRGVidWdnZXJTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z2dlclN0YXRlbWVudCh0cmVlLmxvY2F0aW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1FbXB0eVN0YXRlbWVudDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5U3RhdGVtZW50KHRyZWUubG9jYXRpb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4cG9ydFNwZWNpZmllcih0cmVlLmxvY2F0aW9uLCB0cmVlLmxocywgdHJlZS5yaHMpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUV4cG9ydFN0YXI6IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHBvcnRTdGFyKHRyZWUubG9jYXRpb24pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUlkZW50aWZpZXJFeHByZXNzaW9uOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWRlbnRpZmllckV4cHJlc3Npb24odHJlZS5sb2NhdGlvbiwgdHJlZS5pZGVudGlmaWVyVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybUxpc3Q6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgaWYgKCFsaXN0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckdldCh0aGlzLCBDbG9uZVRyZWVUcmFuc2Zvcm1lci5wcm90b3R5cGUsIFwidHJhbnNmb3JtTGlzdFwiKS5jYWxsKHRoaXMsIGxpc3QpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTGl0ZXJhbEV4cHJlc3Npb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uLCB0cmVlLmxpdGVyYWxUb2tlbik7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9kdWxlU3BlY2lmaWVyKHRyZWUubG9jYXRpb24sIHRyZWUudG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByZWRlZmluZWRUeXBlOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZGVmaW5lZFR5cGUodHJlZS5sb2NhdGlvbiwgdHJlZS50eXBlVG9rZW4pO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVByb3BlcnR5TmFtZVNob3J0aGFuZDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5TmFtZVNob3J0aGFuZCh0cmVlLmxvY2F0aW9uLCB0cmVlLm5hbWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVRlbXBsYXRlTGl0ZXJhbFBvcnRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZUxpdGVyYWxQb3J0aW9uKHRyZWUubG9jYXRpb24sIHRyZWUudmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybVN1cGVyRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1cGVyRXhwcmVzc2lvbih0cmVlLmxvY2F0aW9uKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1UaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRoaXNFeHByZXNzaW9uKHRyZWUubG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0sIHt9LCAkX19zdXBlcik7XG4gIH0oUGFyc2VUcmVlVHJhbnNmb3JtZXIpO1xuICBDbG9uZVRyZWVUcmFuc2Zvcm1lci5jbG9uZVRyZWUgPSBmdW5jdGlvbih0cmVlKSB7XG4gICAgcmV0dXJuIG5ldyBDbG9uZVRyZWVUcmFuc2Zvcm1lcigpLnRyYW5zZm9ybUFueSh0cmVlKTtcbiAgfTtcbiAgcmV0dXJuIHtnZXQgQ2xvbmVUcmVlVHJhbnNmb3JtZXIoKSB7XG4gICAgICByZXR1cm4gQ2xvbmVUcmVlVHJhbnNmb3JtZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL2NyZWF0ZU1vZHVsZUV2YWx1YXRpb25TdGF0ZW1lbnQuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvY3JlYXRlTW9kdWxlRXZhbHVhdGlvblN0YXRlbWVudC5qc1wiO1xuICB2YXIgcGFyc2VTdGF0ZW1lbnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vUGxhY2Vob2xkZXJQYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9jcmVhdGVNb2R1bGVFdmFsdWF0aW9uU3RhdGVtZW50LmpzXCIpKS5wYXJzZVN0YXRlbWVudDtcbiAgZnVuY3Rpb24gY3JlYXRlTW9kdWxlRXZhbHVhdGlvblN0YXRlbWVudChub3JtYWxpemVkTmFtZSkge1xuICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgkdHJhY2V1clJ1bnRpbWUuZ2V0VGVtcGxhdGVPYmplY3QoW1wiJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZShcIiwgXCIgKycnKVwiXSksIG5vcm1hbGl6ZWROYW1lKTtcbiAgfVxuICByZXR1cm4ge2dldCBjcmVhdGVNb2R1bGVFdmFsdWF0aW9uU3RhdGVtZW50KCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU1vZHVsZUV2YWx1YXRpb25TdGF0ZW1lbnQ7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29tcGlsZXItaW1wb3J0cy5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIjtcbiAgdmFyICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfQ29tcGlsZXJfNDZfanNfXyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0NvbXBpbGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKTtcbiAgdmFyIFBhcnNlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N5bnRheC9QYXJzZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLlBhcnNlcjtcbiAgdmFyIFNjcmlwdCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5TY3JpcHQ7XG4gIHZhciBTb3VyY2VGaWxlID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vc3ludGF4L1NvdXJjZUZpbGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLlNvdXJjZUZpbGU7XG4gIHZhciBzeW50YXggPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgU291cmNlRmlsZTogU291cmNlRmlsZSxcbiAgICB0cmVlczoge1NjcmlwdDogU2NyaXB0fVxuICB9O1xuICB2YXIgUGFyc2VUcmVlTWFwV3JpdGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vb3V0cHV0Z2VuZXJhdGlvbi9QYXJzZVRyZWVNYXBXcml0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLlBhcnNlVHJlZU1hcFdyaXRlcjtcbiAgdmFyIFBhcnNlVHJlZVdyaXRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL291dHB1dGdlbmVyYXRpb24vUGFyc2VUcmVlV3JpdGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5QYXJzZVRyZWVXcml0ZXI7XG4gIHZhciByZWdleHB1UmV3cml0ZVBhdHRlcm4gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9vdXRwdXRnZW5lcmF0aW9uL3JlZ2V4cHVSZXdyaXRlUGF0dGVybi5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29tcGlsZXItaW1wb3J0cy5qc1wiKSkucmVnZXhwdVJld3JpdGVQYXR0ZXJuO1xuICB2YXIgU291cmNlTWFwQ29uc3VtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9vdXRwdXRnZW5lcmF0aW9uL1NvdXJjZU1hcEludGVncmF0aW9uLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5Tb3VyY2VNYXBDb25zdW1lcjtcbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL291dHB1dGdlbmVyYXRpb24vU291cmNlTWFwSW50ZWdyYXRpb24uanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIFRyZWVXcml0ZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9vdXRwdXRnZW5lcmF0aW9uL1RyZWVXcml0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLlRyZWVXcml0ZXI7XG4gIHZhciBvdXRwdXRnZW5lcmF0aW9uID0ge1xuICAgIFBhcnNlVHJlZU1hcFdyaXRlcjogUGFyc2VUcmVlTWFwV3JpdGVyLFxuICAgIFBhcnNlVHJlZVdyaXRlcjogUGFyc2VUcmVlV3JpdGVyLFxuICAgIHJlZ2V4cHVSZXdyaXRlUGF0dGVybjogcmVnZXhwdVJld3JpdGVQYXR0ZXJuLFxuICAgIFNvdXJjZU1hcENvbnN1bWVyOiBTb3VyY2VNYXBDb25zdW1lcixcbiAgICBTb3VyY2VNYXBHZW5lcmF0b3I6IFNvdXJjZU1hcEdlbmVyYXRvcixcbiAgICBUcmVlV3JpdGVyOiBUcmVlV3JpdGVyXG4gIH07XG4gIHZhciBBdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvQXR0YWNoTW9kdWxlTmFtZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5BdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXI7XG4gIHZhciBDbG9uZVRyZWVUcmFuc2Zvcm1lciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2NvZGVnZW5lcmF0aW9uL0Nsb25lVHJlZVRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5DbG9uZVRyZWVUcmFuc2Zvcm1lcjtcbiAgdmFyIEZyb21PcHRpb25zVHJhbnNmb3JtZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9jb2RlZ2VuZXJhdGlvbi9Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5Gcm9tT3B0aW9uc1RyYW5zZm9ybWVyO1xuICB2YXIgUHVyZUVTNlRyYW5zZm9ybWVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vY29kZWdlbmVyYXRpb24vUHVyZUVTNlRyYW5zZm9ybWVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKS5QdXJlRVM2VHJhbnNmb3JtZXI7XG4gIHZhciBjcmVhdGVNb2R1bGVFdmFsdWF0aW9uU3RhdGVtZW50ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vY29kZWdlbmVyYXRpb24vbW9kdWxlL2NyZWF0ZU1vZHVsZUV2YWx1YXRpb25TdGF0ZW1lbnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvbXBpbGVyLWltcG9ydHMuanNcIikpLmNyZWF0ZU1vZHVsZUV2YWx1YXRpb25TdGF0ZW1lbnQ7XG4gIHZhciAkX18xNiA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2NvZGVnZW5lcmF0aW9uL1BsYWNlaG9sZGVyUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb21waWxlci1pbXBvcnRzLmpzXCIpKSxcbiAgICAgIHBhcnNlRXhwcmVzc2lvbiA9ICRfXzE2LnBhcnNlRXhwcmVzc2lvbixcbiAgICAgIHBhcnNlTW9kdWxlID0gJF9fMTYucGFyc2VNb2R1bGUsXG4gICAgICBwYXJzZVNjcmlwdCA9ICRfXzE2LnBhcnNlU2NyaXB0LFxuICAgICAgcGFyc2VTdGF0ZW1lbnQgPSAkX18xNi5wYXJzZVN0YXRlbWVudDtcbiAgdmFyIGNvZGVnZW5lcmF0aW9uID0ge1xuICAgIENsb25lVHJlZVRyYW5zZm9ybWVyOiBDbG9uZVRyZWVUcmFuc2Zvcm1lcixcbiAgICBGcm9tT3B0aW9uc1RyYW5zZm9ybWVyOiBGcm9tT3B0aW9uc1RyYW5zZm9ybWVyLFxuICAgIFB1cmVFUzZUcmFuc2Zvcm1lcjogUHVyZUVTNlRyYW5zZm9ybWVyLFxuICAgIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICAgIHBhcnNlTW9kdWxlOiBwYXJzZU1vZHVsZSxcbiAgICBwYXJzZVNjcmlwdDogcGFyc2VTY3JpcHQsXG4gICAgcGFyc2VTdGF0ZW1lbnQ6IHBhcnNlU3RhdGVtZW50LFxuICAgIG1vZHVsZToge1xuICAgICAgQXR0YWNoTW9kdWxlTmFtZVRyYW5zZm9ybWVyOiBBdHRhY2hNb2R1bGVOYW1lVHJhbnNmb3JtZXIsXG4gICAgICBjcmVhdGVNb2R1bGVFdmFsdWF0aW9uU3RhdGVtZW50OiBjcmVhdGVNb2R1bGVFdmFsdWF0aW9uU3RhdGVtZW50XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGdldCBDb21waWxlcigpIHtcbiAgICAgIHJldHVybiAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X0NvbXBpbGVyXzQ2X2pzX18uQ29tcGlsZXI7XG4gICAgfSxcbiAgICBnZXQgc3ludGF4KCkge1xuICAgICAgcmV0dXJuIHN5bnRheDtcbiAgICB9LFxuICAgIGdldCBvdXRwdXRnZW5lcmF0aW9uKCkge1xuICAgICAgcmV0dXJuIG91dHB1dGdlbmVyYXRpb247XG4gICAgfSxcbiAgICBnZXQgY29kZWdlbmVyYXRpb24oKSB7XG4gICAgICByZXR1cm4gY29kZWdlbmVyYXRpb247XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9WYWxpZGF0aW9uVmlzaXRvci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9WYWxpZGF0aW9uVmlzaXRvci5qc1wiO1xuICB2YXIgTW9kdWxlVmlzaXRvciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL01vZHVsZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9WYWxpZGF0aW9uVmlzaXRvci5qc1wiKSkuTW9kdWxlVmlzaXRvcjtcbiAgdmFyIFZhbGlkYXRpb25WaXNpdG9yID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uVmlzaXRvcigpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKFZhbGlkYXRpb25WaXNpdG9yKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVmFsaWRhdGlvblZpc2l0b3IsIHtcbiAgICAgIGNoZWNrRXhwb3J0XzogZnVuY3Rpb24odHJlZSwgbmFtZSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRpb24gPSB0aGlzLnZhbGlkYXRpbmdNb2R1bGVEZXNjcmlwdGlvbl87XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiAmJiAhZGVzY3JpcHRpb24uZ2V0RXhwb3J0KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIG1vZHVsZU5hbWUgPSBkZXNjcmlwdGlvbi5ub3JtYWxpemVkTmFtZTtcbiAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKHRyZWUsIChcIidcIiArIG5hbWUgKyBcIicgaXMgbm90IGV4cG9ydGVkIGJ5ICdcIiArIG1vZHVsZU5hbWUgKyBcIidcIikpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2hlY2tJbXBvcnRfOiBmdW5jdGlvbih0cmVlLCBuYW1lKSB7XG4gICAgICAgIHZhciBleGlzdGluZ0ltcG9ydCA9IHRoaXMubW9kdWxlU3ltYm9sLmdldEltcG9ydChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nSW1wb3J0KSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcih0cmVlLCAoXCInXCIgKyBuYW1lICsgXCInIHdhcyBwcmV2aW91c2x5IGltcG9ydGVkIGF0IFwiICsgZXhpc3RpbmdJbXBvcnQubG9jYXRpb24uc3RhcnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZVN5bWJvbC5hZGRJbXBvcnQobmFtZSwgdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEFuZFZhbGlkYXRlXzogZnVuY3Rpb24obW9kdWxlRGVzY3JpcHRpb24sIHRyZWUpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRpbmdNb2R1bGVEZXNjcmlwdGlvbiA9IHRoaXMudmFsaWRhdGluZ01vZHVsZURlc2NyaXB0aW9uXztcbiAgICAgICAgdGhpcy52YWxpZGF0aW5nTW9kdWxlRGVzY3JpcHRpb25fID0gbW9kdWxlRGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudmlzaXRBbnkodHJlZSk7XG4gICAgICAgIHRoaXMudmFsaWRhdGluZ01vZHVsZURlc2NyaXB0aW9uXyA9IHZhbGlkYXRpbmdNb2R1bGVEZXNjcmlwdGlvbjtcbiAgICAgIH0sXG4gICAgICB2aXNpdE5hbWVkRXhwb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIGlmICh0cmVlLm1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICAgIHZhciBuYW1lID0gdHJlZS5tb2R1bGVTcGVjaWZpZXIudG9rZW4ucHJvY2Vzc2VkVmFsdWU7XG4gICAgICAgICAgdmFyIG1vZHVsZURlc2NyaXB0aW9uID0gdGhpcy5nZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcihuYW1lKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QW5kVmFsaWRhdGVfKG1vZHVsZURlc2NyaXB0aW9uLCB0cmVlLmV4cG9ydENsYXVzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2aXNpdEV4cG9ydFNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0Xyh0cmVlLCB0cmVlLmxocy52YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdmlzaXRGb3J3YXJkRGVmYXVsdEV4cG9ydDogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0Xyh0cmVlLCAnZGVmYXVsdCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0cmVlLm1vZHVsZVNwZWNpZmllci50b2tlbi5wcm9jZXNzZWRWYWx1ZTtcbiAgICAgICAgdmFyIG1vZHVsZURlc2NyaXB0aW9uID0gdGhpcy5nZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcihuYW1lKTtcbiAgICAgICAgdGhpcy52aXNpdEFuZFZhbGlkYXRlXyhtb2R1bGVEZXNjcmlwdGlvbiwgdHJlZS5pbXBvcnRDbGF1c2UpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbXBvcnROYW1lID0gdHJlZS5iaW5kaW5nLmdldFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgIHZhciBleHBvcnROYW1lID0gdHJlZS5uYW1lID8gdHJlZS5uYW1lLnZhbHVlIDogaW1wb3J0TmFtZTtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydF8odHJlZSwgaW1wb3J0TmFtZSk7XG4gICAgICAgIHRoaXMuY2hlY2tFeHBvcnRfKHRyZWUsIGV4cG9ydE5hbWUpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0SW1wb3J0ZWRCaW5kaW5nOiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbXBvcnROYW1lID0gdHJlZS5iaW5kaW5nLmdldFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRfKHRyZWUsIGltcG9ydE5hbWUpO1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0Xyh0cmVlLCAnZGVmYXVsdCcpO1xuICAgICAgfSxcbiAgICAgIHZpc2l0TmFtZVNwYWNlSW1wb3J0OiBmdW5jdGlvbih0cmVlKSB7XG4gICAgICAgIHZhciBpbXBvcnROYW1lID0gdHJlZS5iaW5kaW5nLmJpbmRpbmcuZ2V0U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydF8odHJlZSwgaW1wb3J0TmFtZSk7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShNb2R1bGVWaXNpdG9yKTtcbiAgcmV0dXJuIHtnZXQgVmFsaWRhdGlvblZpc2l0b3IoKSB7XG4gICAgICByZXR1cm4gVmFsaWRhdGlvblZpc2l0b3I7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydExpc3RCdWlsZGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydExpc3RCdWlsZGVyLmpzXCI7XG4gIHZhciBFeHBvcnRWaXNpdG9yID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vRXhwb3J0VmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydExpc3RCdWlsZGVyLmpzXCIpKS5FeHBvcnRWaXNpdG9yO1xuICB2YXIgVmFsaWRhdGlvblZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9WYWxpZGF0aW9uVmlzaXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydExpc3RCdWlsZGVyLmpzXCIpKS5WYWxpZGF0aW9uVmlzaXRvcjtcbiAgZnVuY3Rpb24gYnVpbGRFeHBvcnRMaXN0KGRlcHMsIGxvYWRlciwgcmVwb3J0ZXIpIHtcbiAgICBmdW5jdGlvbiBkb1Zpc2l0KGN0b3IpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBjdG9yKHJlcG9ydGVyLCBsb2FkZXIsIGRlcHNbaV0pO1xuICAgICAgICB2aXNpdG9yLnZpc2l0QW55KGRlcHNbaV0udHJlZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldmVyc2VWaXNpdChjdG9yKSB7XG4gICAgICBmb3IgKHZhciBpID0gZGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBjdG9yKHJlcG9ydGVyLCBsb2FkZXIsIGRlcHNbaV0pO1xuICAgICAgICB2aXNpdG9yLnZpc2l0QW55KGRlcHNbaV0udHJlZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldmVyc2VWaXNpdChFeHBvcnRWaXNpdG9yKTtcbiAgICBkb1Zpc2l0KFZhbGlkYXRpb25WaXNpdG9yKTtcbiAgfVxuICByZXR1cm4ge2dldCBidWlsZEV4cG9ydExpc3QoKSB7XG4gICAgICByZXR1cm4gYnVpbGRFeHBvcnRMaXN0O1xuICAgIH19O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVTcGVjaWZpZXJWaXNpdG9yLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvY29kZWdlbmVyYXRpb24vbW9kdWxlL01vZHVsZVNwZWNpZmllclZpc2l0b3IuanNcIjtcbiAgdmFyIFBhcnNlVHJlZVZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vLi4vc3ludGF4L1BhcnNlVHJlZVZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVTcGVjaWZpZXJWaXNpdG9yLmpzXCIpKS5QYXJzZVRyZWVWaXNpdG9yO1xuICB2YXIgU3RyaW5nU2V0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uLy4uL3V0aWwvU3RyaW5nU2V0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvTW9kdWxlU3BlY2lmaWVyVmlzaXRvci5qc1wiKSkuU3RyaW5nU2V0O1xuICB2YXIgTW9kdWxlU3BlY2lmaWVyVmlzaXRvciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTW9kdWxlU3BlY2lmaWVyVmlzaXRvcihvcHRpb25zKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihNb2R1bGVTcGVjaWZpZXJWaXNpdG9yKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5vcHRpb25zXyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm1vZHVsZVNwZWNpZmllcnNfID0gbmV3IFN0cmluZ1NldCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTW9kdWxlU3BlY2lmaWVyVmlzaXRvciwge1xuICAgICAgZ2V0IG1vZHVsZVNwZWNpZmllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZVNwZWNpZmllcnNfLnZhbHVlc0FzQXJyYXkoKTtcbiAgICAgIH0sXG4gICAgICB2aXNpdE1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24odHJlZSkge1xuICAgICAgICB0aGlzLm1vZHVsZVNwZWNpZmllcnNfLmFkZCh0cmVlLnRva2VuLnByb2Nlc3NlZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KFBhcnNlVHJlZVZpc2l0b3IpO1xuICByZXR1cm4ge2dldCBNb2R1bGVTcGVjaWZpZXJWaXNpdG9yKCkge1xuICAgICAgcmV0dXJuIE1vZHVsZVNwZWNpZmllclZpc2l0b3I7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL3N5c3RlbS1tYXAuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvc3lzdGVtLW1hcC5qc1wiO1xuICBmdW5jdGlvbiBwcmVmaXhNYXRjaExlbmd0aChuYW1lLCBwcmVmaXgpIHtcbiAgICB2YXIgcHJlZml4UGFydHMgPSBwcmVmaXguc3BsaXQoJy8nKTtcbiAgICB2YXIgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLycpO1xuICAgIGlmIChwcmVmaXhQYXJ0cy5sZW5ndGggPiBuYW1lUGFydHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5hbWVQYXJ0c1tpXSAhPSBwcmVmaXhQYXJ0c1tpXSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBwcmVmaXhQYXJ0cy5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlNYXAobWFwLCBuYW1lLCBwYXJlbnROYW1lKSB7XG4gICAgdmFyIGN1ck1hdGNoLFxuICAgICAgICBjdXJNYXRjaExlbmd0aCA9IDA7XG4gICAgdmFyIGN1clBhcmVudCxcbiAgICAgICAgY3VyUGFyZW50TWF0Y2hMZW5ndGggPSAwO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICB2YXIgbWFwcGVkTmFtZTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcCkuc29tZShmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBjdXJNYXAgPSBtYXBbcF07XG4gICAgICAgIGlmIChjdXJNYXAgJiYgdHlwZW9mIGN1ck1hcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAocHJlZml4TWF0Y2hMZW5ndGgocGFyZW50TmFtZSwgcCkgPD0gY3VyUGFyZW50TWF0Y2hMZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VyTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgICAgIGlmIChwcmVmaXhNYXRjaExlbmd0aChuYW1lLCBxKSA+IGN1ck1hdGNoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGN1ck1hdGNoID0gcTtcbiAgICAgICAgICAgICAgY3VyTWF0Y2hMZW5ndGggPSBxLnNwbGl0KCcvJykubGVuZ3RoO1xuICAgICAgICAgICAgICBjdXJQYXJlbnQgPSBwO1xuICAgICAgICAgICAgICBjdXJQYXJlbnRNYXRjaExlbmd0aCA9IHAuc3BsaXQoJy8nKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ck1hdGNoKSB7XG4gICAgICAgICAgdmFyIHN1YlBhdGggPSBuYW1lLnNwbGl0KCcvJykuc3BsaWNlKGN1ck1hdGNoTGVuZ3RoKS5qb2luKCcvJyk7XG4gICAgICAgICAgbWFwcGVkTmFtZSA9IG1hcFtjdXJQYXJlbnRdW2N1ck1hdGNoXSArIChzdWJQYXRoID8gJy8nICsgc3ViUGF0aCA6ICcnKTtcbiAgICAgICAgICByZXR1cm4gbWFwcGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXBwZWROYW1lKVxuICAgICAgcmV0dXJuIG1hcHBlZE5hbWU7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBjdXJNYXAgPSBtYXBbcF07XG4gICAgICBpZiAoY3VyTWFwICYmIHR5cGVvZiBjdXJNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChwcmVmaXhNYXRjaExlbmd0aChuYW1lLCBwKSA+IGN1ck1hdGNoTGVuZ3RoKSB7XG4gICAgICAgICAgY3VyTWF0Y2ggPSBwO1xuICAgICAgICAgIGN1ck1hdGNoTGVuZ3RoID0gcC5zcGxpdCgnLycpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY3VyTWF0Y2gpXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB2YXIgc3ViUGF0aCA9IG5hbWUuc3BsaXQoJy8nKS5zcGxpY2UoY3VyTWF0Y2hMZW5ndGgpLmpvaW4oJy8nKTtcbiAgICByZXR1cm4gbWFwW2N1ck1hdGNoXSArIChzdWJQYXRoID8gJy8nICsgc3ViUGF0aCA6ICcnKTtcbiAgfVxuICB2YXIgc3lzdGVtanMgPSB7YXBwbHlNYXA6IGFwcGx5TWFwfTtcbiAgcmV0dXJuIHtnZXQgc3lzdGVtanMoKSB7XG4gICAgICByZXR1cm4gc3lzdGVtanM7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0xvYWRlckNvbXBpbGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0xvYWRlckNvbXBpbGVyLmpzXCI7XG4gIHZhciBidWlsZEV4cG9ydExpc3QgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY29kZWdlbmVyYXRpb24vbW9kdWxlL0V4cG9ydExpc3RCdWlsZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyQ29tcGlsZXIuanNcIikpLmJ1aWxkRXhwb3J0TGlzdDtcbiAgdmFyIENvbGxlY3RpbmdFcnJvclJlcG9ydGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9Mb2FkZXJDb21waWxlci5qc1wiKSkuQ29sbGVjdGluZ0Vycm9yUmVwb3J0ZXI7XG4gIHZhciBDb21waWxlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9Db21waWxlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0xvYWRlckNvbXBpbGVyLmpzXCIpKS5Db21waWxlcjtcbiAgdmFyIE1vZHVsZVNwZWNpZmllclZpc2l0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY29kZWdlbmVyYXRpb24vbW9kdWxlL01vZHVsZVNwZWNpZmllclZpc2l0b3IuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9Mb2FkZXJDb21waWxlci5qc1wiKSkuTW9kdWxlU3BlY2lmaWVyVmlzaXRvcjtcbiAgdmFyIE1vZHVsZVN5bWJvbCA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9jb2RlZ2VuZXJhdGlvbi9tb2R1bGUvTW9kdWxlU3ltYm9sLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyQ29tcGlsZXIuanNcIikpLk1vZHVsZVN5bWJvbDtcbiAgdmFyIFBhcnNlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9zeW50YXgvUGFyc2VyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyQ29tcGlsZXIuanNcIikpLlBhcnNlcjtcbiAgdmFyIFNvdXJjZUZpbGUgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vc3ludGF4L1NvdXJjZUZpbGUuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9Mb2FkZXJDb21waWxlci5qc1wiKSkuU291cmNlRmlsZTtcbiAgdmFyIHN5c3RlbWpzID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vc3lzdGVtLW1hcC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0xvYWRlckNvbXBpbGVyLmpzXCIpKS5zeXN0ZW1qcztcbiAgdmFyIFVuaXF1ZUlkZW50aWZpZXJHZW5lcmF0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vY29kZWdlbmVyYXRpb24vVW5pcXVlSWRlbnRpZmllckdlbmVyYXRvci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0xvYWRlckNvbXBpbGVyLmpzXCIpKS5VbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yO1xuICB2YXIgJF9fMTAgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC91cmwuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9Mb2FkZXJDb21waWxlci5qc1wiKSksXG4gICAgICBpc0Fic29sdXRlID0gJF9fMTAuaXNBYnNvbHV0ZSxcbiAgICAgIHJlc29sdmVVcmwgPSAkX18xMC5yZXNvbHZlVXJsO1xuICB2YXIgYXNzZXJ0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvYXNzZXJ0LmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyQ29tcGlsZXIuanNcIikpLmFzc2VydDtcbiAgdmFyIE5PVF9TVEFSVEVEID0gMDtcbiAgdmFyIExPQURJTkcgPSAxO1xuICB2YXIgTE9BREVEID0gMjtcbiAgdmFyIFBBUlNFRCA9IDM7XG4gIHZhciBUUkFOU0ZPUk1JTkcgPSA0O1xuICB2YXIgVFJBTlNGT1JNRUQgPSA1O1xuICB2YXIgQ09NUExFVEUgPSA2O1xuICB2YXIgRVJST1IgPSA3O1xuICB2YXIgaWRlbnRpZmllckdlbmVyYXRvciA9IG5ldyBVbmlxdWVJZGVudGlmaWVyR2VuZXJhdG9yKCk7XG4gIHZhciBhbm9ueW1vdXNTb3VyY2VzU2VlbiA9IDA7XG4gIHZhciBMb2FkZXJDb21waWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExvYWRlckNvbXBpbGVyKCkge31cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTG9hZGVyQ29tcGlsZXIsIHtcbiAgICAgIGdldE1vZHVsZVNwZWNpZmllcnM6IGZ1bmN0aW9uKGNvZGVVbml0KSB7XG4gICAgICAgIHRoaXMucGFyc2UoY29kZVVuaXQpO1xuICAgICAgICB2YXIgbW9kdWxlU3BlY2lmaWVyVmlzaXRvciA9IG5ldyBNb2R1bGVTcGVjaWZpZXJWaXNpdG9yKGNvZGVVbml0Lm1ldGFkYXRhLnRyYWNldXJPcHRpb25zKTtcbiAgICAgICAgbW9kdWxlU3BlY2lmaWVyVmlzaXRvci52aXNpdChjb2RlVW5pdC5tZXRhZGF0YS50cmVlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVNwZWNpZmllclZpc2l0b3IubW9kdWxlU3BlY2lmaWVycztcbiAgICAgIH0sXG4gICAgICBwYXJzZTogZnVuY3Rpb24oY29kZVVuaXQpIHtcbiAgICAgICAgYXNzZXJ0KCFjb2RlVW5pdC5tZXRhZGF0YS50cmVlKTtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gY29kZVVuaXQubWV0YWRhdGE7XG4gICAgICAgIHZhciBvcHRpb25zID0gbWV0YWRhdGEudHJhY2V1ck9wdGlvbnM7XG4gICAgICAgIGlmIChjb2RlVW5pdC50eXBlID09PSAnc2NyaXB0JylcbiAgICAgICAgICBvcHRpb25zLnNjcmlwdCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLmNvbXBpbGVyID0gbmV3IENvbXBpbGVyKG9wdGlvbnMpO1xuICAgICAgICB2YXIgc291cmNlTmFtZSA9IGNvZGVVbml0Lm1ldGFkYXRhLnNvdXJjZU5hbWUgPSBjb2RlVW5pdC5hZGRyZXNzIHx8IGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lIHx8ICcodW5uYW1lZCkjJyArIFN0cmluZygrK2Fub255bW91c1NvdXJjZXNTZWVuKTtcbiAgICAgICAgbWV0YWRhdGEudHJlZSA9IG1ldGFkYXRhLmNvbXBpbGVyLnBhcnNlKGNvZGVVbml0LnNvdXJjZSwgc291cmNlTmFtZSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihjb2RlVW5pdCkge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBjb2RlVW5pdC5tZXRhZGF0YTtcbiAgICAgICAgbWV0YWRhdGEudHJhbnNmb3JtZWRUcmVlID0gbWV0YWRhdGEuY29tcGlsZXIudHJhbnNmb3JtKG1ldGFkYXRhLnRyZWUsIGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lLCBtZXRhZGF0YSk7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvZGVVbml0KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGNvZGVVbml0Lm1ldGFkYXRhO1xuICAgICAgICB2YXIgb3V0cHV0TmFtZSA9IG1ldGFkYXRhLm91dHB1dE5hbWUgfHwgbWV0YWRhdGEuc291cmNlTmFtZSB8fCAnPGxvYWRlck91dHB1dD4nO1xuICAgICAgICB2YXIgc291cmNlUm9vdCA9IG1ldGFkYXRhLnNvdXJjZVJvb3Q7XG4gICAgICAgIHZhciBzb3VyY2VVUkwgPSBtZXRhZGF0YS5zb3VyY2VOYW1lIHx8IGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lIHx8IGNvZGVVbml0LmFkZHJlc3M7XG4gICAgICAgIG1ldGFkYXRhLnRyYW5zY29kZWQgPSBtZXRhZGF0YS5jb21waWxlci53cml0ZShtZXRhZGF0YS50cmFuc2Zvcm1lZFRyZWUsIG91dHB1dE5hbWUsIHVuZGVmaW5lZCwgc291cmNlVVJMKTtcbiAgICAgIH0sXG4gICAgICBldmFsdWF0ZUNvZGVVbml0OiBmdW5jdGlvbihjb2RlVW5pdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gKCdnbG9iYWwnLCBldmFsKShjb2RlVW5pdC5tZXRhZGF0YS50cmFuc2NvZGVkKTtcbiAgICAgICAgY29kZVVuaXQubWV0YWRhdGEudHJhbnNmb3JtZWRUcmVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBhbmFseXplRGVwZW5kZW5jaWVzOiBmdW5jdGlvbihkZXBlbmRlbmNpZXMsIGxvYWRlcikge1xuICAgICAgICB2YXIgZGVwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjb2RlVW5pdCA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICBhc3NlcnQoY29kZVVuaXQuc3RhdGUgPj0gUEFSU0VEKTtcbiAgICAgICAgICBpZiAoY29kZVVuaXQuc3RhdGUgPT0gUEFSU0VEKSB7XG4gICAgICAgICAgICB2YXIgc3ltYm9sID0gY29kZVVuaXQubWV0YWRhdGEubW9kdWxlU3ltYm9sID0gbmV3IE1vZHVsZVN5bWJvbChjb2RlVW5pdC5tZXRhZGF0YS50cmVlLCBjb2RlVW5pdC5ub3JtYWxpemVkTmFtZSk7XG4gICAgICAgICAgICBkZXBzLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ZvckVycm9ycyhmdW5jdGlvbihyZXBvcnRlcikge1xuICAgICAgICAgIHJldHVybiBidWlsZEV4cG9ydExpc3QoZGVwcywgbG9hZGVyLCByZXBvcnRlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNoZWNrRm9yRXJyb3JzOiBmdW5jdGlvbihmbmNPZlJlcG9ydGVyKSB7XG4gICAgICAgIHZhciByZXBvcnRlciA9IG5ldyBDb2xsZWN0aW5nRXJyb3JSZXBvcnRlcigpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm5jT2ZSZXBvcnRlcihyZXBvcnRlcik7XG4gICAgICAgIGlmIChyZXBvcnRlci5oYWRFcnJvcigpKVxuICAgICAgICAgIHRocm93IHJlcG9ydGVyLnRvRXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtnZXQgTG9hZGVyQ29tcGlsZXIoKSB7XG4gICAgICByZXR1cm4gTG9hZGVyQ29tcGlsZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0ludGVybmFsTG9hZGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0ludGVybmFsTG9hZGVyLmpzXCI7XG4gIHZhciBhc3NlcnQgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vdXRpbC9hc3NlcnQuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9JbnRlcm5hbExvYWRlci5qc1wiKSkuYXNzZXJ0O1xuICB2YXIgTG9hZGVyQ29tcGlsZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Mb2FkZXJDb21waWxlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0ludGVybmFsTG9hZGVyLmpzXCIpKS5Mb2FkZXJDb21waWxlcjtcbiAgdmFyIEV4cG9ydHNMaXN0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL2NvZGVnZW5lcmF0aW9uL21vZHVsZS9Nb2R1bGVTeW1ib2wuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9JbnRlcm5hbExvYWRlci5qc1wiKSkuRXhwb3J0c0xpc3Q7XG4gIHZhciAkX18xMyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi91dGlsL3VybC5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0ludGVybmFsTG9hZGVyLmpzXCIpKSxcbiAgICAgIGlzQWJzb2x1dGUgPSAkX18xMy5pc0Fic29sdXRlLFxuICAgICAgcmVzb2x2ZVVybCA9ICRfXzEzLnJlc29sdmVVcmw7XG4gIHZhciBPcHRpb25zID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL09wdGlvbnMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9JbnRlcm5hbExvYWRlci5qc1wiKSkuT3B0aW9ucztcbiAgdmFyIE5PVF9TVEFSVEVEID0gMDtcbiAgdmFyIExPQURJTkcgPSAxO1xuICB2YXIgTE9BREVEID0gMjtcbiAgdmFyIFBBUlNFRCA9IDM7XG4gIHZhciBUUkFOU0ZPUk1JTkcgPSA0O1xuICB2YXIgVFJBTlNGT1JNRUQgPSA1O1xuICB2YXIgQ09NUExFVEUgPSA2O1xuICB2YXIgRVJST1IgPSA3O1xuICBmdW5jdGlvbiBtYXBUb1ZhbHVlcyhtYXApIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICBhcnJheS5wdXNoKHYpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgTG9hZGVyRXJyb3IgPSBmdW5jdGlvbigkX19zdXBlcikge1xuICAgIGZ1bmN0aW9uIExvYWRlckVycm9yKG1zZywgdHJlZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoTG9hZGVyRXJyb3IpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgdGhpcy5uYW1lID0gJ0xvYWRlckVycm9yJztcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKExvYWRlckVycm9yLCB7fSwge30sICRfX3N1cGVyKTtcbiAgfShFcnJvcik7XG4gIHZhciBDb2RlVW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIENvZGVVbml0KGxvYWRlckNvbXBpbGVyLCBub3JtYWxpemVkTmFtZSwgdHlwZSwgc3RhdGUsIG5hbWUsIHJlZmVycmVyTmFtZSwgYWRkcmVzcykge1xuICAgICAgdmFyICRfXzggPSB0aGlzO1xuICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzLCByZWopIHtcbiAgICAgICAgJF9fOC5sb2FkZXJDb21waWxlciA9IGxvYWRlckNvbXBpbGVyO1xuICAgICAgICAkX184Lm5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplZE5hbWU7XG4gICAgICAgICRfXzgudHlwZSA9IHR5cGU7XG4gICAgICAgICRfXzgubmFtZV8gPSBuYW1lO1xuICAgICAgICAkX184LnJlZmVycmVyTmFtZV8gPSByZWZlcnJlck5hbWU7XG4gICAgICAgICRfXzguYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICRfXzguc3RhdGVfID0gc3RhdGUgfHwgTk9UX1NUQVJURUQ7XG4gICAgICAgICRfXzguZXJyb3IgPSBudWxsO1xuICAgICAgICAkX184LnJlc3VsdCA9IG51bGw7XG4gICAgICAgICRfXzgubWV0YWRhdGFfID0ge307XG4gICAgICAgICRfXzguZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICRfXzgucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgJF9fOC5yZWplY3QgPSByZWo7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKENvZGVVbml0LCB7XG4gICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlXztcbiAgICAgIH0sXG4gICAgICBzZXQgc3RhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5zdGF0ZV8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUgY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZV8gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhXztcbiAgICAgIH0sXG4gICAgICBzZXQgbWV0YWRhdGEodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YV8gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBuYW1lVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHJhY2UgPSB0aGlzLnNwZWNpZmllZEFzKCk7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKHRoaXMubmFtZV8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNlICsgJ0FuIGFic29sdXRlIG5hbWUuXFxuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWZlcnJlck5hbWVfKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNlICsgdGhpcy5pbXBvcnRlZEJ5KCkgKyB0aGlzLm5vcm1hbGl6ZXNUbygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFjZSArIHRoaXMubm9ybWFsaXplc1RvKCk7XG4gICAgICB9LFxuICAgICAgc3BlY2lmaWVkQXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFwiU3BlY2lmaWVkIGFzIFwiICsgdGhpcy5uYW1lXyArIFwiLlxcblwiKTtcbiAgICAgIH0sXG4gICAgICBpbXBvcnRlZEJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcIkltcG9ydGVkIGJ5IFwiICsgdGhpcy5yZWZlcnJlck5hbWVfICsgXCIuXFxuXCIpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZXNUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnTm9ybWFsaXplcyB0byAnICsgdGhpcy5ub3JtYWxpemVkTmFtZSArICdcXG4nO1xuICAgICAgfVxuICAgIH0sIHt9KTtcbiAgfSgpO1xuICB2YXIgUHJlQ29tcGlsZWRDb2RlVW5pdCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gUHJlQ29tcGlsZWRDb2RlVW5pdChsb2FkZXJDb21waWxlciwgbm9ybWFsaXplZE5hbWUsIG5hbWUsIHJlZmVycmVyTmFtZSwgYWRkcmVzcywgbW9kdWxlKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihQcmVDb21waWxlZENvZGVVbml0KS5jYWxsKHRoaXMsIGxvYWRlckNvbXBpbGVyLCBub3JtYWxpemVkTmFtZSwgJ21vZHVsZScsIENPTVBMRVRFLCBuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MpO1xuICAgICAgdGhpcy5yZXN1bHQgPSBtb2R1bGU7XG4gICAgICB0aGlzLnJlc29sdmUodGhpcy5yZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoUHJlQ29tcGlsZWRDb2RlVW5pdCwge30sIHt9LCAkX19zdXBlcik7XG4gIH0oQ29kZVVuaXQpO1xuICB2YXIgQnVuZGxlZENvZGVVbml0ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBCdW5kbGVkQ29kZVVuaXQobG9hZGVyQ29tcGlsZXIsIG5vcm1hbGl6ZWROYW1lLCBuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIGRlcHMsIGV4ZWN1dGUsIHNldE1vZHVsZSkge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoQnVuZGxlZENvZGVVbml0KS5jYWxsKHRoaXMsIGxvYWRlckNvbXBpbGVyLCBub3JtYWxpemVkTmFtZSwgJ21vZHVsZScsIFRSQU5TRk9STUVELCBuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MpO1xuICAgICAgdGhpcy5kZXBzID0gZGVwcztcbiAgICAgIHRoaXMuZXhlY3V0ZSA9IGV4ZWN1dGU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShCdW5kbGVkQ29kZVVuaXQsIHtcbiAgICAgIGdldE1vZHVsZVNwZWNpZmllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXBzO1xuICAgICAgfSxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICRfXzggPSB0aGlzO1xuICAgICAgICB2YXIgbm9ybWFsaXplZE5hbWVzID0gdGhpcy5kZXBzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICRfXzgubG9hZGVyXy5ub3JtYWxpemUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW9kdWxlID0gdGhpcy5leGVjdXRlLmFwcGx5KFJlZmxlY3QuZ2xvYmFsLCBub3JtYWxpemVkTmFtZXMpO1xuICAgICAgICBzZXRNb2R1bGUodGhpcy5ub3JtYWxpemVkTmFtZSwgbW9kdWxlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KENvZGVVbml0KTtcbiAgdmFyIEhvb2tlZENvZGVVbml0ID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBIb29rZWRDb2RlVW5pdCgpIHtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEhvb2tlZENvZGVVbml0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSG9va2VkQ29kZVVuaXQsIHtcbiAgICAgIGdldE1vZHVsZVNwZWNpZmllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXJDb21waWxlci5nZXRNb2R1bGVTcGVjaWZpZXJzKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyQ29tcGlsZXIuZXZhbHVhdGVDb2RlVW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KENvZGVVbml0KTtcbiAgdmFyIExvYWRDb2RlVW5pdCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gTG9hZENvZGVVbml0KGxvYWRlckNvbXBpbGVyLCBub3JtYWxpemVkTmFtZSwgbmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihMb2FkQ29kZVVuaXQpLmNhbGwodGhpcywgbG9hZGVyQ29tcGlsZXIsIG5vcm1hbGl6ZWROYW1lLCAnbW9kdWxlJywgTk9UX1NUQVJURUQsIG5hbWUsIHJlZmVycmVyTmFtZSwgYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShMb2FkQ29kZVVuaXQsIHt9LCB7fSwgJF9fc3VwZXIpO1xuICB9KEhvb2tlZENvZGVVbml0KTtcbiAgdmFyIEV2YWxDb2RlVW5pdCA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gRXZhbENvZGVVbml0KGxvYWRlckNvbXBpbGVyLCBjb2RlKSB7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1syXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMl0gOiAnc2NyaXB0JztcbiAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IGFyZ3VtZW50c1szXTtcbiAgICAgIHZhciByZWZlcnJlck5hbWUgPSBhcmd1bWVudHNbNF07XG4gICAgICB2YXIgYWRkcmVzcyA9IGFyZ3VtZW50c1s1XTtcbiAgICAgICR0cmFjZXVyUnVudGltZS5zdXBlckNvbnN0cnVjdG9yKEV2YWxDb2RlVW5pdCkuY2FsbCh0aGlzLCBsb2FkZXJDb21waWxlciwgbm9ybWFsaXplZE5hbWUsIHR5cGUsIExPQURFRCwgbnVsbCwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzKTtcbiAgICAgIHRoaXMuc291cmNlID0gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEV2YWxDb2RlVW5pdCwge30sIHt9LCAkX19zdXBlcik7XG4gIH0oSG9va2VkQ29kZVVuaXQpO1xuICB2YXIgdW5pcXVlTmFtZUNvdW50ID0gMDtcbiAgdmFyIEludGVybmFsTG9hZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJuYWxMb2FkZXIobG9hZGVyLCBsb2FkZXJDb21waWxlcikge1xuICAgICAgYXNzZXJ0KGxvYWRlckNvbXBpbGVyKTtcbiAgICAgIHRoaXMubG9hZGVyXyA9IGxvYWRlcjtcbiAgICAgIHRoaXMubG9hZGVyQ29tcGlsZXIgPSBsb2FkZXJDb21waWxlcjtcbiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnVybFRvS2V5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuc3luY18gPSBmYWxzZTtcbiAgICAgIHRoaXMuc291cmNlTWFwc0J5VVJMXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLnNvdXJjZU1hcHNCeU91dHB1dE5hbWVfID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEludGVybmFsTG9hZGVyLCB7XG4gICAgICBkZWZhdWx0TWV0YWRhdGFfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgaW5jb21pbmcgPSBtZXRhZGF0YS50cmFjZXVyT3B0aW9ucztcbiAgICAgICAgaWYgKGluY29taW5nICYmICEoaW5jb21pbmcgaW5zdGFuY2VvZiBPcHRpb25zKSkge1xuICAgICAgICAgIHZhciB1bmtub3duID0gT3B0aW9ucy5saXN0VW5rbm93bk9wdGlvbnMoaW5jb21pbmcpO1xuICAgICAgICAgIGlmICh1bmtub3duLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmtub3duIG1ldGFkYXRhLnRyYWNldXJPcHRpb25zIGlnbm9yZWQ6ICcgKyB1bmtub3duLmpvaW4oJywnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnRyYWNldXJPcHRpb25zID0gaW5jb21pbmcgfHwgbmV3IE9wdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHRNb2R1bGVNZXRhZGF0YV86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBhcmd1bWVudHNbMF0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMuZGVmYXVsdE1ldGFkYXRhXyhtZXRhZGF0YSk7XG4gICAgICAgIG1ldGFkYXRhLnRyYWNldXJPcHRpb25zLnNjcmlwdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICB9LFxuICAgICAgZ2V0U291cmNlTWFwOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFwc0J5VVJMX1t1cmxdIHx8IHRoaXMuc291cmNlTWFwc0J5T3V0cHV0TmFtZV9bdXJsXTtcbiAgICAgIH0sXG4gICAgICBsb2FkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciByZWZlcnJlck5hbWUgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDogdGhpcy5sb2FkZXJfLmJhc2VVUkw7XG4gICAgICAgIHZhciBhZGRyZXNzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSBhcmd1bWVudHNbM10gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgICAgIG1ldGFkYXRhID0gdGhpcy5kZWZhdWx0TWV0YWRhdGFfKG1ldGFkYXRhKTtcbiAgICAgICAgdmFyIGNvZGVVbml0ID0gdGhpcy5nZXRPckNyZWF0ZUNvZGVVbml0XyhuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5sb2FkXyhjb2RlVW5pdCk7XG4gICAgICAgIHJldHVybiBjb2RlVW5pdC5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZGVVbml0O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsb2FkXzogZnVuY3Rpb24oY29kZVVuaXQpIHtcbiAgICAgICAgdmFyICRfXzggPSB0aGlzO1xuICAgICAgICBpZiAoY29kZVVuaXQuc3RhdGUgPT09IEVSUk9SKSB7XG4gICAgICAgICAgcmV0dXJuIGNvZGVVbml0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlVW5pdC5zdGF0ZSA9PT0gVFJBTlNGT1JNRUQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNvZGVVbml0TG9hZGVkKGNvZGVVbml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZVVuaXQuc3RhdGUgIT09IE5PVF9TVEFSVEVEKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVVbml0O1xuICAgICAgICAgIGNvZGVVbml0LnN0YXRlID0gTE9BRElORztcbiAgICAgICAgICBjb2RlVW5pdC5hZGRyZXNzID0gdGhpcy5sb2FkZXJfLmxvY2F0ZShjb2RlVW5pdCk7XG4gICAgICAgICAgdGhpcy5sb2FkZXJfLmZldGNoKGNvZGVVbml0KS50aGVuKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIGNvZGVVbml0LnNvdXJjZSA9IHRleHQ7XG4gICAgICAgICAgICByZXR1cm4gY29kZVVuaXQ7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbihsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gJF9fOC5sb2FkZXJfLnRyYW5zbGF0ZShsb2FkKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgY29kZVVuaXQuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgY29kZVVuaXQuc3RhdGUgPSBMT0FERUQ7XG4gICAgICAgICAgICAkX184LmhhbmRsZUNvZGVVbml0TG9hZGVkKGNvZGVVbml0KTtcbiAgICAgICAgICAgIHJldHVybiBjb2RlVW5pdDtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvZGVVbml0LnN0YXRlID0gRVJST1I7XG4gICAgICAgICAgICAgIGNvZGVVbml0LmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAkX184LmhhbmRsZUNvZGVVbml0TG9hZEVycm9yKGNvZGVVbml0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludGVybmFsIEVycm9yICcgKyAoZXguc3RhY2sgfHwgZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVVuaXQ7XG4gICAgICB9LFxuICAgICAgbW9kdWxlOiBmdW5jdGlvbihjb2RlLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBjb2RlVW5pdCA9IG5ldyBFdmFsQ29kZVVuaXQodGhpcy5sb2FkZXJDb21waWxlciwgY29kZSwgJ21vZHVsZScsIG51bGwsIHJlZmVycmVyTmFtZSwgYWRkcmVzcyk7XG4gICAgICAgIGNvZGVVbml0Lm1ldGFkYXRhID0gdGhpcy5kZWZhdWx0TWV0YWRhdGFfKG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoe30sIGNvZGVVbml0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2RlVW5pdExvYWRlZChjb2RlVW5pdCk7XG4gICAgICAgIHJldHVybiBjb2RlVW5pdC5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGRlZmluZTogZnVuY3Rpb24obm9ybWFsaXplZE5hbWUsIGNvZGUsIGFkZHJlc3MsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBjb2RlVW5pdCA9IG5ldyBFdmFsQ29kZVVuaXQodGhpcy5sb2FkZXJDb21waWxlciwgY29kZSwgJ21vZHVsZScsIG5vcm1hbGl6ZWROYW1lLCBudWxsLCBhZGRyZXNzKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KG5vcm1hbGl6ZWROYW1lLCAnbW9kdWxlJyk7XG4gICAgICAgIGNvZGVVbml0Lm1ldGFkYXRhID0gdGhpcy5kZWZhdWx0TWV0YWRhdGFfKG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBjb2RlVW5pdCk7XG4gICAgICAgIHRoaXMuaGFuZGxlQ29kZVVuaXRMb2FkZWQoY29kZVVuaXQpO1xuICAgICAgICByZXR1cm4gY29kZVVuaXQucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBzY3JpcHQ6IGZ1bmN0aW9uKGNvZGUsIG5hbWUsIHJlZmVycmVyTmFtZSwgYWRkcmVzcywgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gdGhpcy5sb2FkZXJfLm5vcm1hbGl6ZShuYW1lIHx8ICcnLCByZWZlcnJlck5hbWUsIGFkZHJlc3MpO1xuICAgICAgICB2YXIgY29kZVVuaXQgPSBuZXcgRXZhbENvZGVVbml0KHRoaXMubG9hZGVyQ29tcGlsZXIsIGNvZGUsICdzY3JpcHQnLCBub3JtYWxpemVkTmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzKTtcbiAgICAgICAgdmFyIGtleSA9IHt9O1xuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICBrZXkgPSB0aGlzLmdldEtleShub3JtYWxpemVkTmFtZSwgJ3NjcmlwdCcpO1xuICAgICAgICBjb2RlVW5pdC5tZXRhZGF0YSA9IHRoaXMuZGVmYXVsdE1ldGFkYXRhXyhtZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgY29kZVVuaXQpO1xuICAgICAgICB0aGlzLmhhbmRsZUNvZGVVbml0TG9hZGVkKGNvZGVVbml0KTtcbiAgICAgICAgcmV0dXJuIGNvZGVVbml0LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgZ2V0S2V5OiBmdW5jdGlvbih1cmwsIHR5cGUpIHtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gdHlwZSArICc6JyArIHVybDtcbiAgICAgICAgaWYgKGNvbWJpbmVkIGluIHRoaXMudXJsVG9LZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy51cmxUb0tleVtjb21iaW5lZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXJsVG9LZXlbY29tYmluZWRdID0ge307XG4gICAgICB9LFxuICAgICAgZ2V0Q29kZVVuaXRfOiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkobm9ybWFsaXplZE5hbWUsIHR5cGUpO1xuICAgICAgICB2YXIgY29kZVVuaXQgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGNvZGVVbml0OiBjb2RlVW5pdFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldE9yQ3JlYXRlQ29kZVVuaXRfOiBmdW5jdGlvbihuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IHRoaXMubG9hZGVyXy5ub3JtYWxpemUobmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzKTtcbiAgICAgICAgdmFyIHR5cGUgPSAnbW9kdWxlJztcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnRyYWNldXJPcHRpb25zICYmIG1ldGFkYXRhLnRyYWNldXJPcHRpb25zLnNjcmlwdClcbiAgICAgICAgICB0eXBlID0gJ3NjcmlwdCc7XG4gICAgICAgIHZhciAkX185ID0gdGhpcy5nZXRDb2RlVW5pdF8obm9ybWFsaXplZE5hbWUsIHR5cGUpLFxuICAgICAgICAgICAga2V5ID0gJF9fOS5rZXksXG4gICAgICAgICAgICBjb2RlVW5pdCA9ICRfXzkuY29kZVVuaXQ7XG4gICAgICAgIGlmICghY29kZVVuaXQpIHtcbiAgICAgICAgICBhc3NlcnQobWV0YWRhdGEgJiYgbWV0YWRhdGEudHJhY2V1ck9wdGlvbnMpO1xuICAgICAgICAgIHZhciBtb2R1bGUgPSB0aGlzLmxvYWRlcl8uZ2V0KG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICBjb2RlVW5pdCA9IG5ldyBQcmVDb21waWxlZENvZGVVbml0KHRoaXMubG9hZGVyQ29tcGlsZXIsIG5vcm1hbGl6ZWROYW1lLCBuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIG1vZHVsZSk7XG4gICAgICAgICAgICBjb2RlVW5pdC50eXBlID0gJ21vZHVsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVVbml0ID0gbmV3IExvYWRDb2RlVW5pdCh0aGlzLmxvYWRlckNvbXBpbGVyLCBub3JtYWxpemVkTmFtZSwgbmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvZGVVbml0LnR5cGUgPSB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlVW5pdC5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIHRyYWNldXJPcHRpb25zOiBtZXRhZGF0YS50cmFjZXVyT3B0aW9ucyxcbiAgICAgICAgICAgIG91dHB1dE5hbWU6IG1ldGFkYXRhLm91dHB1dE5hbWUsXG4gICAgICAgICAgICByb290TW9kdWxlOiBtZXRhZGF0YS5yb290TW9kdWxlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIGNvZGVVbml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVVuaXQ7XG4gICAgICB9LFxuICAgICAgYXJlQWxsOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbWFwVG9WYWx1ZXModGhpcy5jYWNoZSkuZXZlcnkoZnVuY3Rpb24oY29kZVVuaXQpIHtcbiAgICAgICAgICByZXR1cm4gY29kZVVuaXQuc3RhdGUgPj0gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldENvZGVVbml0Rm9yTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbihuYW1lLCByZWZlcnJlck5hbWUpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gdGhpcy5sb2FkZXJfLm5vcm1hbGl6ZShuYW1lLCByZWZlcnJlck5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2RlVW5pdF8obm9ybWFsaXplZE5hbWUsICdtb2R1bGUnKS5jb2RlVW5pdDtcbiAgICAgIH0sXG4gICAgICBnZXRFeHBvcnRzTGlzdEZvck1vZHVsZVNwZWNpZmllcjogZnVuY3Rpb24obmFtZSwgcmVmZXJyZXIpIHtcbiAgICAgICAgdmFyIGNvZGVVbml0ID0gdGhpcy5nZXRDb2RlVW5pdEZvck1vZHVsZVNwZWNpZmllcihuYW1lLCByZWZlcnJlcik7XG4gICAgICAgIHZhciBleHBvcnRzTGlzdCA9IGNvZGVVbml0Lm1ldGFkYXRhLm1vZHVsZVN5bWJvbDtcbiAgICAgICAgaWYgKCFleHBvcnRzTGlzdCkge1xuICAgICAgICAgIGlmIChjb2RlVW5pdC5yZXN1bHQpIHtcbiAgICAgICAgICAgIGV4cG9ydHNMaXN0ID0gbmV3IEV4cG9ydHNMaXN0KGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgICAgIGV4cG9ydHNMaXN0LmFkZEV4cG9ydHNGcm9tTW9kdWxlKGNvZGVVbml0LnJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJJbnRlcm5hbEVycm9yOiBcIiArIG5hbWUgKyBcIiBpcyBub3QgYSBtb2R1bGUsIHJlcXVpcmVkIGJ5IFwiICsgcmVmZXJyZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cG9ydHNMaXN0O1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNvZGVVbml0TG9hZGVkOiBmdW5jdGlvbihjb2RlVW5pdCkge1xuICAgICAgICB2YXIgJF9fOCA9IHRoaXM7XG4gICAgICAgIHZhciByZWZlcnJlck5hbWUgPSBjb2RlVW5pdC5ub3JtYWxpemVkTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbW9kdWxlU3BlY2lmaWVycyA9IGNvZGVVbml0LmdldE1vZHVsZVNwZWNpZmllcnMoKTtcbiAgICAgICAgICBjb2RlVW5pdC5zdGF0ZSA9IFBBUlNFRDtcbiAgICAgICAgICBpZiAoIW1vZHVsZVNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRBbGwoKFwiTm8gbW9kdWxlIHNwZWNpZmllcnMgaW4gXCIgKyByZWZlcnJlck5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZVVuaXQuZGVwZW5kZW5jaWVzID0gbW9kdWxlU3BlY2lmaWVycy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICRfXzguZ2V0T3JDcmVhdGVDb2RlVW5pdF8obmFtZSwgcmVmZXJyZXJOYW1lLCBudWxsLCAkX184LmRlZmF1bHRNb2R1bGVNZXRhZGF0YV8oY29kZVVuaXQubWV0YWRhdGEpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLnJlamVjdE9uZUFuZEFsbChjb2RlVW5pdCwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb2RlVW5pdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgJF9fOC5sb2FkXyhkZXBlbmRlbmN5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbChQQVJTRUQpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjb2RlVW5pdC50eXBlID09PSAnbW9kdWxlJylcbiAgICAgICAgICAgICAgdGhpcy5hbmFseXplKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdE9uZUFuZEFsbChjb2RlVW5pdCwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlamVjdE9uZUFuZEFsbDogZnVuY3Rpb24oY29kZVVuaXQsIGVycm9yKSB7XG4gICAgICAgIGNvZGVVbml0LnN0YXRlLkVSUk9SO1xuICAgICAgICBjb2RlVW5pdC5lcnJvciA9IGVycm9yO1xuICAgICAgICBjb2RlVW5pdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLmFib3J0QWxsKGVycm9yKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDb2RlVW5pdExvYWRFcnJvcjogZnVuY3Rpb24oY29kZVVuaXQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb2RlVW5pdC5lcnJvciA/IFN0cmluZyhjb2RlVW5pdC5lcnJvcikgKyAnXFxuJyA6IChcIkZhaWxlZCB0byBsb2FkICdcIiArIGNvZGVVbml0LmFkZHJlc3MgKyBcIicuXFxuXCIpO1xuICAgICAgICBtZXNzYWdlICs9IGNvZGVVbml0Lm5hbWVUcmFjZSgpICsgdGhpcy5sb2FkZXJfLm5hbWVUcmFjZShjb2RlVW5pdCk7XG4gICAgICAgIHRoaXMucmVqZWN0T25lQW5kQWxsKGNvZGVVbml0LCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgfSxcbiAgICAgIGFib3J0QWxsOiBmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVVbml0KSB7XG4gICAgICAgICAgaWYgKGNvZGVVbml0LnN0YXRlICE9PSBFUlJPUilcbiAgICAgICAgICAgIGNvZGVVbml0LnJlamVjdChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBhbmFseXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJDb21waWxlci5hbmFseXplRGVwZW5kZW5jaWVzKG1hcFRvVmFsdWVzKHRoaXMuY2FjaGUpLCB0aGlzKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llc18obWFwVG9WYWx1ZXModGhpcy5jYWNoZSkpO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybURlcGVuZGVuY2llc186IGZ1bmN0aW9uKGRlcGVuZGVuY2llcywgZGVwZW5kZW50TmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjb2RlVW5pdCA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICBpZiAoY29kZVVuaXQuc3RhdGUgPj0gVFJBTlNGT1JNRUQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVVuaXQuc3RhdGUgPT09IFRSQU5TRk9STUlORykge1xuICAgICAgICAgICAgdmFyIGNpciA9IGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lO1xuICAgICAgICAgICAgdmFyIGNsZSA9IGRlcGVuZGVudE5hbWU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdE9uZUFuZEFsbChjb2RlVW5pdCwgbmV3IEVycm9yKChcIlVuc3VwcG9ydGVkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBcIiArIGNpciArIFwiIGFuZCBcIiArIGNsZSkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZVVuaXQuc3RhdGUgPSBUUkFOU0ZPUk1JTkc7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29kZVVuaXRfKGNvZGVVbml0KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5yZWplY3RPbmVBbmRBbGwoY29kZVVuaXQsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm1Db2RlVW5pdF86IGZ1bmN0aW9uKGNvZGVVbml0KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGVwZW5kZW5jaWVzXyhjb2RlVW5pdC5kZXBlbmRlbmNpZXMsIGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lKTtcbiAgICAgICAgaWYgKGNvZGVVbml0LnN0YXRlID09PSBFUlJPUilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubG9hZGVyQ29tcGlsZXIudHJhbnNmb3JtKGNvZGVVbml0KTtcbiAgICAgICAgY29kZVVuaXQuc3RhdGUgPSBUUkFOU0ZPUk1FRDtcbiAgICAgICAgdGhpcy5sb2FkZXJDb21waWxlci53cml0ZShjb2RlVW5pdCk7XG4gICAgICAgIHZhciBpbmZvID0gY29kZVVuaXQubWV0YWRhdGEuY29tcGlsZXIuc291cmNlTWFwSW5mbztcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICB0aGlzLnNvdXJjZU1hcHNCeVVSTF9baW5mby51cmxdID0gaW5mby5tYXA7XG4gICAgICAgICAgdGhpcy5zb3VyY2VNYXBzQnlPdXRwdXROYW1lX1tpbmZvLm91dHB1dE5hbWVdID0gaW5mby5tYXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZXJfLmluc3RhbnRpYXRlKGNvZGVVbml0KTtcbiAgICAgIH0sXG4gICAgICBvcmRlckRlcGVuZGVuY2llczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aXNpdGVkID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgb3JkZXJlZCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBvcmRlckNvZGVVbml0cyhjb2RlVW5pdCkge1xuICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyhjb2RlVW5pdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmlzaXRlZC5zZXQoY29kZVVuaXQsIHRydWUpO1xuICAgICAgICAgIGNvZGVVbml0LmRlcGVuZGVuY2llcy5mb3JFYWNoKG9yZGVyQ29kZVVuaXRzKTtcbiAgICAgICAgICBvcmRlcmVkLnB1c2goY29kZVVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuZm9yRWFjaChvcmRlckNvZGVVbml0cyk7XG4gICAgICAgIHJldHVybiBvcmRlcmVkO1xuICAgICAgfSxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRoaXMub3JkZXJEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29kZVVuaXQgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgaWYgKGNvZGVVbml0LnN0YXRlID49IENPTVBMRVRFKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29kZVVuaXQuZXZhbHVhdGUoKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3RPbmVBbmRBbGwoY29kZVVuaXQsIGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZVVuaXQucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgIGNvZGVVbml0LnNvdXJjZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29kZVVuaXQgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgaWYgKGNvZGVVbml0LnN0YXRlID49IENPTVBMRVRFKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZVVuaXQuc3RhdGUgPSBDT01QTEVURTtcbiAgICAgICAgICBjb2RlVW5pdC5yZXNvbHZlKGNvZGVVbml0LnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgdmFyIGludGVybmFscyA9IHtcbiAgICBDb2RlVW5pdDogQ29kZVVuaXQsXG4gICAgRXZhbENvZGVVbml0OiBFdmFsQ29kZVVuaXQsXG4gICAgTG9hZENvZGVVbml0OiBMb2FkQ29kZVVuaXQsXG4gICAgTG9hZGVyQ29tcGlsZXI6IExvYWRlckNvbXBpbGVyXG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0IEludGVybmFsTG9hZGVyKCkge1xuICAgICAgcmV0dXJuIEludGVybmFsTG9hZGVyO1xuICAgIH0sXG4gICAgZ2V0IGludGVybmFscygpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbHM7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9Mb2FkZXIuanNcIiwgW10sIGZ1bmN0aW9uKCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fbW9kdWxlTmFtZSA9IFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyLmpzXCI7XG4gIHZhciBJbnRlcm5hbExvYWRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0ludGVybmFsTG9hZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTG9hZGVyLmpzXCIpKS5JbnRlcm5hbExvYWRlcjtcbiAgZnVuY3Rpb24gdGhyb3dBYnN0cmFjdE1ldGhvZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgTG9hZGVyIGZ1bmN0aW9uLCBzZWUgZXh0ZW5kZWQgY2xhc3MnKTtcbiAgfVxuICB2YXIgTG9hZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTG9hZGVyKGxvYWRlckNvbXBpbGVyKSB7XG4gICAgICB0aGlzLmludGVybmFsTG9hZGVyXyA9IG5ldyBJbnRlcm5hbExvYWRlcih0aGlzLCBsb2FkZXJDb21waWxlcik7XG4gICAgICB0aGlzLmxvYWRlckNvbXBpbGVyXyA9IGxvYWRlckNvbXBpbGVyO1xuICAgIH1cbiAgICByZXR1cm4gKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoTG9hZGVyLCB7XG4gICAgICBpbXBvcnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyICRfXzMgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICByZWZlcnJlck5hbWUgPSAkX18zLnJlZmVycmVyTmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3MgPSAkX18zLmFkZHJlc3MsXG4gICAgICAgICAgICBtZXRhZGF0YSA9ICRfXzMubWV0YWRhdGE7XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxMb2FkZXJfLmxvYWQobmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzLCBtZXRhZGF0YSkudGhlbihmdW5jdGlvbihjb2RlVW5pdCkge1xuICAgICAgICAgIHJldHVybiAkX18yLmdldChjb2RlVW5pdC5ub3JtYWxpemVkTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG1vZHVsZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciAkX18zID0gYXJndW1lbnRzWzFdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAgICAgcmVmZXJyZXJOYW1lID0gJF9fMy5yZWZlcnJlck5hbWUsXG4gICAgICAgICAgICBhZGRyZXNzID0gJF9fMy5hZGRyZXNzLFxuICAgICAgICAgICAgbWV0YWRhdGEgPSAkX18zLm1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbExvYWRlcl8ubW9kdWxlKHNvdXJjZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzLCBtZXRhZGF0YSk7XG4gICAgICB9LFxuICAgICAgZGVmaW5lOiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgc291cmNlKSB7XG4gICAgICAgIHZhciAkX18zID0gYXJndW1lbnRzWzJdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgYWRkcmVzcyA9ICRfXzMuYWRkcmVzcyxcbiAgICAgICAgICAgIG1ldGFkYXRhID0gJF9fMy5tZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxMb2FkZXJfLmRlZmluZShub3JtYWxpemVkTmFtZSwgc291cmNlLCBhZGRyZXNzLCBtZXRhZGF0YSk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSkge1xuICAgICAgICB0aHJvd0Fic3RyYWN0TWV0aG9kKCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgbW9kdWxlKSB7XG4gICAgICAgIHRocm93QWJzdHJhY3RNZXRob2QoKTtcbiAgICAgIH0sXG4gICAgICBub3JtYWxpemU6IGZ1bmN0aW9uKG5hbWUsIHJlZmVycmVyTmFtZSwgcmVmZXJyZXJBZGRyZXNzKSB7XG4gICAgICAgIHRocm93QWJzdHJhY3RNZXRob2QoKTtcbiAgICAgIH0sXG4gICAgICBsb2NhdGU6IGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgdGhyb3dBYnN0cmFjdE1ldGhvZCgpO1xuICAgICAgfSxcbiAgICAgIGZldGNoOiBmdW5jdGlvbihsb2FkKSB7XG4gICAgICAgIHRocm93QWJzdHJhY3RNZXRob2QoKTtcbiAgICAgIH0sXG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgdGhyb3dBYnN0cmFjdE1ldGhvZCgpO1xuICAgICAgfSxcbiAgICAgIGluc3RhbnRpYXRlOiBmdW5jdGlvbihsb2FkKSB7XG4gICAgICAgIHRocm93QWJzdHJhY3RNZXRob2QoKTtcbiAgICAgIH1cbiAgICB9LCB7fSk7XG4gIH0oKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgdGhyb3dBYnN0cmFjdE1ldGhvZCgpIHtcbiAgICAgIHJldHVybiB0aHJvd0Fic3RyYWN0TWV0aG9kO1xuICAgIH0sXG4gICAgZ2V0IExvYWRlcigpIHtcbiAgICAgIHJldHVybiBMb2FkZXI7XG4gICAgfSxcbiAgICBnZXQgTG9hZGVyQ29tcGlsZXIoKSB7XG4gICAgICByZXR1cm4gTG9hZGVyQ29tcGlsZXI7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci92ZXJzaW9uLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL3ZlcnNpb24uanNcIjtcbiAgdmFyIHZlcnNpb24gPSAnMC4wLjExMSc7XG4gIHJldHVybiB7Z2V0IHZlcnNpb24oKSB7XG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvVHJhY2V1ckxvYWRlci5qc1wiLCBbXSwgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19tb2R1bGVOYW1lID0gXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9UcmFjZXVyTG9hZGVyLmpzXCI7XG4gIHZhciAkX181ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3V0aWwvdXJsLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvVHJhY2V1ckxvYWRlci5qc1wiKSksXG4gICAgICBpc0Fic29sdXRlID0gJF9fNS5pc0Fic29sdXRlLFxuICAgICAgcmVzb2x2ZVVybCA9ICRfXzUucmVzb2x2ZVVybDtcbiAgdmFyIExvYWRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0xvYWRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL1RyYWNldXJMb2FkZXIuanNcIikpLkxvYWRlcjtcbiAgdmFyIExvYWRlckNvbXBpbGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vTG9hZGVyQ29tcGlsZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9UcmFjZXVyTG9hZGVyLmpzXCIpKS5Mb2FkZXJDb21waWxlcjtcbiAgdmFyIE9wdGlvbnMgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi4vT3B0aW9ucy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL1RyYWNldXJMb2FkZXIuanNcIikpLk9wdGlvbnM7XG4gIHZhciBzeXN0ZW1qcyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3N5c3RlbS1tYXAuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9UcmFjZXVyTG9hZGVyLmpzXCIpKS5zeXN0ZW1qcztcbiAgdmFyIHdlYkxvYWRlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3dlYkxvYWRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL1RyYWNldXJMb2FkZXIuanNcIikpLndlYkxvYWRlcjtcbiAgdmFyIHZlcnNpb24gPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi92ZXJzaW9uLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvVHJhY2V1ckxvYWRlci5qc1wiKSkudmVyc2lvbjtcbiAgdmFyIFdlYlBhZ2VUcmFuc2NvZGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL1dlYlBhZ2VUcmFuc2NvZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvVHJhY2V1ckxvYWRlci5qc1wiKSkuV2ViUGFnZVRyYW5zY29kZXI7XG4gIHZhciB1bmlxdWVOYW1lQ291bnQgPSAwO1xuICB2YXIgVHJhY2V1ckxvYWRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gVHJhY2V1ckxvYWRlcihmaWxlTG9hZGVyLCBiYXNlVVJMKSB7XG4gICAgICB2YXIgbG9hZGVyQ29tcGlsZXIgPSBhcmd1bWVudHNbMl0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzJdIDogbmV3IExvYWRlckNvbXBpbGVyKCk7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihUcmFjZXVyTG9hZGVyKS5jYWxsKHRoaXMsIGxvYWRlckNvbXBpbGVyKTtcbiAgICAgIHRoaXMuZmlsZUxvYWRlcl8gPSBmaWxlTG9hZGVyO1xuICAgICAgdGhpcy5iYXNlVVJMXyA9IGJhc2VVUkwgJiYgU3RyaW5nKGJhc2VVUkwpO1xuICAgICAgdGhpcy5tb2R1bGVTdG9yZV8gPSAkdHJhY2V1clJ1bnRpbWUuTW9kdWxlU3RvcmU7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShUcmFjZXVyTG9hZGVyLCB7XG4gICAgICBnZXQgYmFzZVVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVVSTF87XG4gICAgICB9LFxuICAgICAgc2V0IGJhc2VVUkwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYXNlVVJMXyA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVTdG9yZV8uZ2V0KG5vcm1hbGl6ZWROYW1lKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5vcm1hbGl6ZWROYW1lLCBtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVTdG9yZV8uc2V0KG5vcm1hbGl6ZWROYW1lLCBtb2R1bGUpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24obmFtZSwgcmVmZXJyZXJOYW1lLCByZWZlcnJlckFkZHJlc3MpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gdGhpcy5tb2R1bGVTdG9yZV8ubm9ybWFsaXplKG5hbWUsIHJlZmVycmVyTmFtZSwgcmVmZXJyZXJBZGRyZXNzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzeXN0ZW1qcyAhPT0gJ3VuZGVmaW5lZCcgJiYgU3lzdGVtLm1hcClcbiAgICAgICAgICByZXR1cm4gc3lzdGVtanMuYXBwbHlNYXAoU3lzdGVtLm1hcCwgbm9ybWFsaXplZE5hbWUsIHJlZmVycmVyTmFtZSk7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkTmFtZTtcbiAgICAgIH0sXG4gICAgICBsb2NhdGU6IGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgbG9hZC5tZXRhZGF0YS50cmFjZXVyT3B0aW9ucyA9IGxvYWQubWV0YWRhdGEudHJhY2V1ck9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB1cmwgPSBsb2FkLm5vcm1hbGl6ZWROYW1lO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGxvYWQubWV0YWRhdGEudHJhY2V1ck9wdGlvbnM7XG4gICAgICAgIHZhciBiYXNlVVJMID0gbG9hZC5tZXRhZGF0YSAmJiBsb2FkLm1ldGFkYXRhLmJhc2VVUkw7XG4gICAgICAgIGJhc2VVUkwgPSBiYXNlVVJMIHx8IHRoaXMuYmFzZVVSTDtcbiAgICAgICAgdmFyIHJlZmVycmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlZmVycmVyO1xuICAgICAgICBpZiAocmVmZXJyZXIpIHtcbiAgICAgICAgICB2YXIgbWluQ2hhcnMgPSBNYXRoLm1pbihyZWZlcnJlci5sZW5ndGgsIGJhc2VVUkwubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgY29tbW9uQ2hhcnMgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ2hhcnM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFDaGFyID0gcmVmZXJyZXJbcmVmZXJyZXIubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgICAgaWYgKGFDaGFyID09PSBiYXNlVVJMW2Jhc2VVUkwubGVuZ3RoIC0gMSAtIGldKVxuICAgICAgICAgICAgICBjb21tb25DaGFycysrO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1vbkNoYXJzKSB7XG4gICAgICAgICAgICB2YXIgcGFja2FnZU5hbWUgPSByZWZlcnJlci5zbGljZSgwLCAtY29tbW9uQ2hhcnMpO1xuICAgICAgICAgICAgdmFyIHJvb3REaXJlY3RvcnkgPSBiYXNlVVJMLnNsaWNlKDAsIC1jb21tb25DaGFycyk7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YocGFja2FnZU5hbWUpID09PSAwKSB7XG4gICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHBhY2thZ2VOYW1lLCByb290RGlyZWN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0Fic29sdXRlKHVybCkpIHtcbiAgICAgICAgICBpZiAoYmFzZVVSTCkge1xuICAgICAgICAgICAgbG9hZC5tZXRhZGF0YS5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICAgICAgICAgIHVybCA9IHJlc29sdmVVcmwoYmFzZVVSTCwgdXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH0sXG4gICAgICBzb3VyY2VOYW1lOiBmdW5jdGlvbihsb2FkKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gbG9hZC5tZXRhZGF0YS50cmFjZXVyT3B0aW9ucztcbiAgICAgICAgdmFyIHNvdXJjZU5hbWUgPSBsb2FkLmFkZHJlc3M7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcHMpIHtcbiAgICAgICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuYmFzZVVSTDtcbiAgICAgICAgICBpZiAoc291cmNlTmFtZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QgJiYgc291cmNlTmFtZS5pbmRleE9mKHNvdXJjZVJvb3QpID09PSAwKSB7XG4gICAgICAgICAgICAgIHNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lLnN1YnN0cmluZyhzb3VyY2VSb290Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLmJhc2VVUkwgKyBTdHJpbmcodW5pcXVlTmFtZUNvdW50KyspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlTmFtZTtcbiAgICAgIH0sXG4gICAgICBuYW1lVHJhY2U6IGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gJyc7XG4gICAgICAgIGlmIChsb2FkLm1ldGFkYXRhLmxvY2F0ZU1hcCkge1xuICAgICAgICAgIHRyYWNlICs9IHRoaXMubG9jYXRlTWFwVHJhY2UobG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2UgPSBsb2FkLm1ldGFkYXRhLmJhc2VVUkwgfHwgdGhpcy5iYXNlVVJMO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgIHRyYWNlICs9IHRoaXMuYmFzZVVSTFRyYWNlKGJhc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyYWNlICs9ICdObyBiYXNlVVJMXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2U7XG4gICAgICB9LFxuICAgICAgbG9jYXRlTWFwVHJhY2U6IGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgdmFyIG1hcCA9IGxvYWQubWV0YWRhdGEubG9jYXRlTWFwO1xuICAgICAgICByZXR1cm4gKFwibG9jYXRlIGZvdW5kIFxcJ1wiICsgbWFwLnBhdHRlcm4gKyBcIlxcJyAtPiBcXCdcIiArIG1hcC5yZXBsYWNlbWVudCArIFwiXFwnXFxuXCIpO1xuICAgICAgfSxcbiAgICAgIGJhc2VVUkxUcmFjZTogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgICByZXR1cm4gJ2xvY2F0ZSByZXNvbHZlZCBhZ2FpbnN0IGJhc2UgXFwnJyArIGJhc2UgKyAnXFwnXFxuJztcbiAgICAgIH0sXG4gICAgICBmZXRjaDogZnVuY3Rpb24obG9hZCkge1xuICAgICAgICB2YXIgJF9fMiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpZiAoIWxvYWQpXG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignZmV0Y2ggcmVxdWlyZXMgYXJndW1lbnQgb2JqZWN0JykpO1xuICAgICAgICAgIGVsc2UgaWYgKCFsb2FkLmFkZHJlc3MgfHwgdHlwZW9mIGxvYWQuYWRkcmVzcyAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignZmV0Y2goe2FkZHJlc3N9KSBtaXNzaW5nIHJlcXVpcmVkIHN0cmluZy4nKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgJF9fMi5maWxlTG9hZGVyXy5sb2FkKGxvYWQuYWRkcmVzcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbihsb2FkKSB7XG4gICAgICAgIHJldHVybiBsb2FkLnNvdXJjZTtcbiAgICAgIH0sXG4gICAgICBpbnN0YW50aWF0ZTogZnVuY3Rpb24oJF9fMykge1xuICAgICAgICB2YXIgJF9fNCA9ICRfXzMsXG4gICAgICAgICAgICBuYW1lID0gJF9fNC5uYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEgPSAkX180Lm1ldGFkYXRhLFxuICAgICAgICAgICAgYWRkcmVzcyA9ICRfXzQuYWRkcmVzcyxcbiAgICAgICAgICAgIHNvdXJjZSA9ICRfXzQuc291cmNlLFxuICAgICAgICAgICAgc291cmNlTWFwID0gJF9fNC5zb3VyY2VNYXA7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGJ1bmRsZWRNb2R1bGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxlU3RvcmVfLmJ1bmRsZVN0b3JlW25hbWVdO1xuICAgICAgfSxcbiAgICAgIGltcG9ydEFsbDogZnVuY3Rpb24obmFtZXMpIHtcbiAgICAgICAgdmFyICRfXzMgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICByZWZlcnJlck5hbWUgPSAkX18zLnJlZmVycmVyTmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3MgPSAkX18zLmFkZHJlc3MsXG4gICAgICAgICAgICBtZXRhZGF0YSA9ICRfXzMubWV0YWRhdGE7XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5hbWVzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICRfXzIuaW1wb3J0KG5hbWUsIHtcbiAgICAgICAgICAgIHJlZmVycmVyTmFtZTogcmVmZXJyZXJOYW1lLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgbG9hZEFzU2NyaXB0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciAkX180O1xuICAgICAgICB2YXIgJF9fMyA9IGFyZ3VtZW50c1sxXSAhPT0gKHZvaWQgMCkgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICAgIHJlZmVycmVyTmFtZSA9ICRfXzMucmVmZXJyZXJOYW1lLFxuICAgICAgICAgICAgYWRkcmVzcyA9ICRfXzMuYWRkcmVzcyxcbiAgICAgICAgICAgIG1ldGFkYXRhID0gKCRfXzQgPSAkX18zLm1ldGFkYXRhKSA9PT0gdm9pZCAwID8ge30gOiAkX180O1xuICAgICAgICBtZXRhZGF0YS50cmFjZXVyT3B0aW9ucyA9IG1ldGFkYXRhLnRyYWNldXJPcHRpb25zIHx8IHt9O1xuICAgICAgICBtZXRhZGF0YS50cmFjZXVyT3B0aW9ucy5zY3JpcHQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbExvYWRlcl8ubG9hZChuYW1lLCByZWZlcnJlck5hbWUsIGFkZHJlc3MsIG1ldGFkYXRhKS50aGVuKGZ1bmN0aW9uKGxvYWQpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZC5yZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGxvYWRBc1NjcmlwdEFsbDogZnVuY3Rpb24obmFtZXMpIHtcbiAgICAgICAgdmFyICRfXzMgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICByZWZlcnJlck5hbWUgPSAkX18zLnJlZmVycmVyTmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3MgPSAkX18zLmFkZHJlc3MsXG4gICAgICAgICAgICBtZXRhZGF0YSA9ICRfXzMubWV0YWRhdGE7XG4gICAgICAgIHZhciAkX18yID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5hbWVzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuICRfXzIubG9hZEFzU2NyaXB0KG5hbWUsIHtcbiAgICAgICAgICAgIHJlZmVycmVyTmFtZTogcmVmZXJyZXJOYW1lLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2NyaXB0OiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyICRfXzMgPSBhcmd1bWVudHNbMV0gIT09ICh2b2lkIDApID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICBuYW1lID0gJF9fMy5uYW1lLFxuICAgICAgICAgICAgcmVmZXJyZXJOYW1lID0gJF9fMy5yZWZlcnJlck5hbWUsXG4gICAgICAgICAgICBhZGRyZXNzID0gJF9fMy5hZGRyZXNzLFxuICAgICAgICAgICAgbWV0YWRhdGEgPSAkX18zLm1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbExvYWRlcl8uc2NyaXB0KHNvdXJjZSwgbmFtZSwgcmVmZXJyZXJOYW1lLCBhZGRyZXNzLCBtZXRhZGF0YSk7XG4gICAgICB9LFxuICAgICAgc2VtVmVyUmVnRXhwXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvXihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSg/Oi0oWzAtOUEtWmEtei1dKyg/OlxcLlswLTlBLVphLXotXSspKikpPyg/OlxcK1swLTlBLVphLXotXSspPyQvO1xuICAgICAgfSxcbiAgICAgIHNlbXZlck1hcDogZnVuY3Rpb24obm9ybWFsaXplZE5hbWUpIHtcbiAgICAgICAgdmFyIHNsYXNoID0gbm9ybWFsaXplZE5hbWUuaW5kZXhPZignLycpO1xuICAgICAgICBpZiAoc2xhc2ggPCAwKSB7XG4gICAgICAgICAgc2xhc2ggPSBub3JtYWxpemVkTmFtZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb25QYXJ0ID0gbm9ybWFsaXplZE5hbWUuc2xpY2UoMCwgc2xhc2gpO1xuICAgICAgICB2YXIgYXQgPSB2ZXJzaW9uUGFydC5pbmRleE9mKCdAJyk7XG4gICAgICAgIGlmIChhdCAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgc2VtdmVyID0gdmVyc2lvblBhcnQuc2xpY2UoYXQgKyAxKTtcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuc2VtVmVyUmVnRXhwXygpLmV4ZWMoc2VtdmVyKTtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIG1ham9yID0gbVsxXTtcbiAgICAgICAgICAgIHZhciBtaW5vciA9IG1bMl07XG4gICAgICAgICAgICB2YXIgcGFja2FnZU5hbWUgPSB2ZXJzaW9uUGFydC5zbGljZSgwLCBhdCk7XG4gICAgICAgICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIG1hcFtwYWNrYWdlTmFtZV0gPSB2ZXJzaW9uUGFydDtcbiAgICAgICAgICAgIG1hcFtwYWNrYWdlTmFtZSArICdAJyArIG1ham9yXSA9IHZlcnNpb25QYXJ0O1xuICAgICAgICAgICAgbWFwW3BhY2thZ2VOYW1lICsgJ0AnICsgbWFqb3IgKyAnLicgKyBtaW5vcl0gPSB2ZXJzaW9uUGFydDtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VtdmVyTWFwIGZvdW5kIG5vIG1hdGNoaW5nIHNlbXZlciByZWdleHAgaW4gJyArIHNlbXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW12ZXJNYXAgZXhwZWN0ZWQgbmFtZUBzZW12ZXIsIGdvdCAnICsgdmVyc2lvblBhcnQgKyAnICcgKyBub3JtYWxpemVkTmFtZSk7XG4gICAgICB9LFxuICAgICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgfSxcbiAgICAgIGdldFNvdXJjZU1hcDogZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxMb2FkZXJfLmdldFNvdXJjZU1hcChmaWxlbmFtZSk7XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5vcm1hbGl6ZWROYW1lLCBkZXBzLCBmYWN0b3J5RnVuY3Rpb24pIHtcbiAgICAgICAgJHRyYWNldXJSdW50aW1lLk1vZHVsZVN0b3JlLnJlZ2lzdGVyKG5vcm1hbGl6ZWROYW1lLCBkZXBzLCBmYWN0b3J5RnVuY3Rpb24pO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyTW9kdWxlOiBmdW5jdGlvbihub3JtYWxpemVkTmFtZSwgZGVwcywgZmFjdG9yeUZ1bmN0aW9uKSB7XG4gICAgICAgICR0cmFjZXVyUnVudGltZS5Nb2R1bGVTdG9yZS5yZWdpc3Rlck1vZHVsZShub3JtYWxpemVkTmFtZSwgZGVwcywgZmFjdG9yeUZ1bmN0aW9uKTtcbiAgICAgIH0sXG4gICAgICBkaXJuYW1lOiBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgICAgICB2YXIgbGFzdFNsYXNoID0gZmlsZW5hbWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpXG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gMClcbiAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICByZXR1cm4gZmlsZW5hbWUuc2xpY2UoMCwgbGFzdFNsYXNoKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KExvYWRlcik7XG4gIHZhciBCcm93c2VyVHJhY2V1ckxvYWRlciA9IGZ1bmN0aW9uKCRfX3N1cGVyKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlclRyYWNldXJMb2FkZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihCcm93c2VyVHJhY2V1ckxvYWRlcikuY2FsbCh0aGlzLCB3ZWJMb2FkZXIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBuZXcgTG9hZGVyQ29tcGlsZXIoKSk7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShCcm93c2VyVHJhY2V1ckxvYWRlciwge2xvYWRTY3JpcHRUeXBlTW9kdWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRyYWNldXJPcHRpb25zID0gYXJndW1lbnRzWzBdICE9PSAodm9pZCAwKSA/IGFyZ3VtZW50c1swXSA6IG5ldyBPcHRpb25zKCk7XG4gICAgICAgIG5ldyB0cmFjZXVyLldlYlBhZ2VUcmFuc2NvZGVyKGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsIHRyYWNldXJPcHRpb25zKS5ydW4oKTtcbiAgICAgIH19LCB7fSwgJF9fc3VwZXIpO1xuICB9KFRyYWNldXJMb2FkZXIpO1xuICByZXR1cm4ge1xuICAgIGdldCBUcmFjZXVyTG9hZGVyKCkge1xuICAgICAgcmV0dXJuIFRyYWNldXJMb2FkZXI7XG4gICAgfSxcbiAgICBnZXQgQnJvd3NlclRyYWNldXJMb2FkZXIoKSB7XG4gICAgICByZXR1cm4gQnJvd3NlclRyYWNldXJMb2FkZXI7XG4gICAgfVxuICB9O1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL25vZGUvTm9kZUxvYWRlckNvbXBpbGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbm9kZS9Ob2RlTG9hZGVyQ29tcGlsZXIuanNcIjtcbiAgdmFyIExvYWRlckNvbXBpbGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL2xvYWRlci9Mb2FkZXJDb21waWxlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbm9kZS9Ob2RlTG9hZGVyQ29tcGlsZXIuanNcIikpLkxvYWRlckNvbXBpbGVyO1xuICB2YXIgTm9kZUxvYWRlckNvbXBpbGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOb2RlTG9hZGVyQ29tcGlsZXIoKSB7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihOb2RlTG9hZGVyQ29tcGlsZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnNvdXJjZU1hcHNJbk1lbW9yeV8gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE5vZGVMb2FkZXJDb21waWxlciwge1xuICAgICAgZXZhbHVhdGVDb2RlVW5pdDogZnVuY3Rpb24oY29kZVVuaXQpIHtcbiAgICAgICAgdmFyIHJ1bkluVGhpc0NvbnRleHQgPSByZXF1aXJlKCd2bScpLnJ1bkluVGhpc0NvbnRleHQ7XG4gICAgICAgIHZhciBzZW12ZXIgPSByZXF1aXJlKCdzZW12ZXInKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjb2RlVW5pdC5tZXRhZGF0YS50cmFuc2NvZGVkO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBjb2RlVW5pdC5hZGRyZXNzIHx8IGNvZGVVbml0Lm5vcm1hbGl6ZWROYW1lO1xuICAgICAgICBpZiAoY29kZVVuaXQubWV0YWRhdGEudHJhY2V1ck9wdGlvbnMuc291cmNlTWFwcyA9PT0gJ21lbW9yeScpIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZU1lbW9yeVNvdXJjZU1hcHNfKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmIChzZW12ZXIuZ3RlKHByb2Nlc3MudmVyc2lvbiwgJzAuMTIuMCcpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHtmaWxlbmFtZTogZmlsZW5hbWV9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBmaWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gcnVuSW5UaGlzQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgY29kZVVuaXQubWV0YWRhdGEudHJhbnNmb3JtZWRUcmVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBlbmFibGVNZW1vcnlTb3VyY2VNYXBzXzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZU1hcHNJbk1lbW9yeV8pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZSgnc291cmNlLW1hcC1zdXBwb3J0JykuaW5zdGFsbCh7cmV0cmlldmVTb3VyY2VNYXA6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIG1hcCA9IFN5c3RlbS5nZXRTb3VyY2VNYXAodXJsKTtcbiAgICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgIG1hcDogbWFwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmV0cmlldmVTb3VyY2VNYXAgRkFJTEVEICcsIGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fSk7XG4gICAgICAgIHRoaXMuc291cmNlTWFwc0luTWVtb3J5XyA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge30sICRfX3N1cGVyKTtcbiAgfShMb2FkZXJDb21waWxlcik7XG4gIHJldHVybiB7Z2V0IE5vZGVMb2FkZXJDb21waWxlcigpIHtcbiAgICAgIHJldHVybiBOb2RlTG9hZGVyQ29tcGlsZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0lubGluZUxvYWRlckNvbXBpbGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL0lubGluZUxvYWRlckNvbXBpbGVyLmpzXCI7XG4gIHZhciBMb2FkZXJDb21waWxlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0xvYWRlckNvbXBpbGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvSW5saW5lTG9hZGVyQ29tcGlsZXIuanNcIikpLkxvYWRlckNvbXBpbGVyO1xuICB2YXIgU2NyaXB0ID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL3N5bnRheC90cmVlcy9QYXJzZVRyZWVzLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvSW5saW5lTG9hZGVyQ29tcGlsZXIuanNcIikpLlNjcmlwdDtcbiAgdmFyIElubGluZUxvYWRlckNvbXBpbGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBJbmxpbmVMb2FkZXJDb21waWxlcihlbGVtZW50cykge1xuICAgICAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IoSW5saW5lTG9hZGVyQ29tcGlsZXIpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfVxuICAgIHJldHVybiAoJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShJbmxpbmVMb2FkZXJDb21waWxlciwge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uKCkge30sXG4gICAgICBldmFsdWF0ZUNvZGVVbml0OiBmdW5jdGlvbihjb2RlVW5pdCkge1xuICAgICAgICB2YXIgJF9fMTtcbiAgICAgICAgdmFyIHRyZWUgPSBjb2RlVW5pdC5tZXRhZGF0YS50cmFuc2Zvcm1lZFRyZWU7XG4gICAgICAgICgkX18xID0gdGhpcy5lbGVtZW50cykucHVzaC5hcHBseSgkX18xLCAkdHJhY2V1clJ1bnRpbWUuc3ByZWFkKHRyZWUuc2NyaXB0SXRlbUxpc3QpKTtcbiAgICAgIH0sXG4gICAgICB0b1RyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjcmlwdChudWxsLCB0aGlzLmVsZW1lbnRzLCBudWxsKTtcbiAgICAgIH1cbiAgICB9LCB7fSwgJF9fc3VwZXIpO1xuICB9KExvYWRlckNvbXBpbGVyKTtcbiAgcmV0dXJuIHtnZXQgSW5saW5lTG9hZGVyQ29tcGlsZXIoKSB7XG4gICAgICByZXR1cm4gSW5saW5lTG9hZGVyQ29tcGlsZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL05vZGVUcmFjZXVyTG9hZGVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL05vZGVUcmFjZXVyTG9hZGVyLmpzXCI7XG4gIHZhciBUcmFjZXVyTG9hZGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVHJhY2V1ckxvYWRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL05vZGVUcmFjZXVyTG9hZGVyLmpzXCIpKS5UcmFjZXVyTG9hZGVyO1xuICB2YXIgTm9kZUxvYWRlckNvbXBpbGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4uL25vZGUvTm9kZUxvYWRlckNvbXBpbGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvTm9kZVRyYWNldXJMb2FkZXIuanNcIikpLk5vZGVMb2FkZXJDb21waWxlcjtcbiAgdmFyIE5vZGVUcmFjZXVyTG9hZGVyID0gZnVuY3Rpb24oJF9fc3VwZXIpIHtcbiAgICBmdW5jdGlvbiBOb2RlVHJhY2V1ckxvYWRlcigpIHtcbiAgICAgIHZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgICAgdmFyIGZpbGVsb2FkZXIgPSByZXF1aXJlKCcuLi9ub2RlL25vZGVMb2FkZXIuanMnKTtcbiAgICAgIHZhciB1cmwgPSAocGF0aC5yZXNvbHZlKCcuLycpICsgJy8nKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDb25zdHJ1Y3RvcihOb2RlVHJhY2V1ckxvYWRlcikuY2FsbCh0aGlzLCBmaWxlbG9hZGVyLCB1cmwsIG5ldyBOb2RlTG9hZGVyQ29tcGlsZXIoKSk7XG4gICAgICB0aGlzLnRyYWNldXJNYXBfID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKE5vZGVUcmFjZXVyTG9hZGVyLCB7Z2V0U291cmNlTWFwOiBmdW5jdGlvbihmaWxlbmFtZSkge1xuICAgICAgICB2YXIgbWFwID0gJHRyYWNldXJSdW50aW1lLnN1cGVyR2V0KHRoaXMsIE5vZGVUcmFjZXVyTG9hZGVyLnByb3RvdHlwZSwgXCJnZXRTb3VyY2VNYXBcIikuY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIGlmICghbWFwICYmIGZpbGVuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5lbmRzV2l0aCgnL2Jpbi90cmFjZXVyLmpzJykpIHtcbiAgICAgICAgICBpZiAoIXRoaXMudHJhY2V1ck1hcF8pIHtcbiAgICAgICAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNldXJNYXBfID0gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lICsgJy5tYXAnLCAndXRmOCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAgPSB0aGlzLnRyYWNldXJNYXBfO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9fSwge30sICRfX3N1cGVyKTtcbiAgfShUcmFjZXVyTG9hZGVyKTtcbiAgcmV0dXJuIHtnZXQgTm9kZVRyYWNldXJMb2FkZXIoKSB7XG4gICAgICByZXR1cm4gTm9kZVRyYWNldXJMb2FkZXI7XG4gICAgfX07XG59KTtcbiR0cmFjZXVyUnVudGltZS5yZWdpc3Rlck1vZHVsZShcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCI7XG4gIHZhciBMb2FkZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Mb2FkZXIuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL2xvYWRlci9sb2FkZXItaW1wb3J0cy5qc1wiKSkuTG9hZGVyO1xuICB2YXIgTG9hZGVyQ29tcGlsZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Mb2FkZXJDb21waWxlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCIpKS5Mb2FkZXJDb21waWxlcjtcbiAgdmFyIEJyb3dzZXJUcmFjZXVyTG9hZGVyID0gJHRyYWNldXJSdW50aW1lLmdldE1vZHVsZSgkdHJhY2V1clJ1bnRpbWUubm9ybWFsaXplTW9kdWxlTmFtZShcIi4vVHJhY2V1ckxvYWRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCIpKS5Ccm93c2VyVHJhY2V1ckxvYWRlcjtcbiAgdmFyIE5vZGVMb2FkZXJDb21waWxlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuLi9ub2RlL05vZGVMb2FkZXJDb21waWxlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCIpKS5Ob2RlTG9hZGVyQ29tcGlsZXI7XG4gIHZhciBJbmxpbmVMb2FkZXJDb21waWxlciA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL0lubGluZUxvYWRlckNvbXBpbGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvbG9hZGVyLWltcG9ydHMuanNcIikpLklubGluZUxvYWRlckNvbXBpbGVyO1xuICB2YXIgTm9kZVRyYWNldXJMb2FkZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9Ob2RlVHJhY2V1ckxvYWRlci5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvbG9hZGVyL2xvYWRlci1pbXBvcnRzLmpzXCIpKS5Ob2RlVHJhY2V1ckxvYWRlcjtcbiAgdmFyIFRyYWNldXJMb2FkZXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi9UcmFjZXVyTG9hZGVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy9sb2FkZXIvbG9hZGVyLWltcG9ydHMuanNcIikpLlRyYWNldXJMb2FkZXI7XG4gIHZhciBsb2FkZXIgPSB7XG4gICAgQnJvd3NlclRyYWNldXJMb2FkZXI6IEJyb3dzZXJUcmFjZXVyTG9hZGVyLFxuICAgIElubGluZUxvYWRlckNvbXBpbGVyOiBJbmxpbmVMb2FkZXJDb21waWxlcixcbiAgICBMb2FkZXI6IExvYWRlcixcbiAgICBMb2FkZXJDb21waWxlcjogTG9hZGVyQ29tcGlsZXIsXG4gICAgTm9kZUxvYWRlckNvbXBpbGVyOiBOb2RlTG9hZGVyQ29tcGlsZXIsXG4gICAgTm9kZVRyYWNldXJMb2FkZXI6IE5vZGVUcmFjZXVyTG9hZGVyLFxuICAgIFRyYWNldXJMb2FkZXI6IFRyYWNldXJMb2FkZXJcbiAgfTtcbiAgcmV0dXJuIHtnZXQgbG9hZGVyKCkge1xuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9fTtcbn0pO1xuJHRyYWNldXJSdW50aW1lLnJlZ2lzdGVyTW9kdWxlKFwidHJhY2V1ckAwLjAuMTExL3NyYy90cmFjZXVyLmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvdHJhY2V1ci5qc1wiO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N191dGlsXzQ1X2ltcG9ydHNfNDZfanNfXyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL3V0aWwtaW1wb3J0cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdHJhY2V1ci5qc1wiKSk7XG4gIHZhciAkX190cmFjZXVyXzY0XzBfNDZfMF80Nl8xMTFfNDdfc3JjXzQ3X2NvbXBpbGVyXzQ1X2ltcG9ydHNfNDZfanNfXyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2NvbXBpbGVyLWltcG9ydHMuanNcIiwgXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3RyYWNldXIuanNcIikpO1xuICB2YXIgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19sb2FkZXJfNDdfbG9hZGVyXzQ1X2ltcG9ydHNfNDZfanNfXyA9ICR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoJHRyYWNldXJSdW50aW1lLm5vcm1hbGl6ZU1vZHVsZU5hbWUoXCIuL2xvYWRlci9sb2FkZXItaW1wb3J0cy5qc1wiLCBcInRyYWNldXJAMC4wLjExMS9zcmMvdHJhY2V1ci5qc1wiKSk7XG4gIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuZXhwb3J0U3Rhcih7fSwgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N191dGlsXzQ1X2ltcG9ydHNfNDZfanNfXywgJF9fdHJhY2V1cl82NF8wXzQ2XzBfNDZfMTExXzQ3X3NyY180N19jb21waWxlcl80NV9pbXBvcnRzXzQ2X2pzX18sICRfX3RyYWNldXJfNjRfMF80Nl8wXzQ2XzExMV80N19zcmNfNDdfbG9hZGVyXzQ3X2xvYWRlcl80NV9pbXBvcnRzXzQ2X2pzX18pO1xufSk7XG4kdHJhY2V1clJ1bnRpbWUucmVnaXN0ZXJNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3RyYWNldXItaW1wb3J0LmpzXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX21vZHVsZU5hbWUgPSBcInRyYWNldXJAMC4wLjExMS9zcmMvdHJhY2V1ci1pbXBvcnQuanNcIjtcbiAgdmFyIHRyYWNldXIgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0TW9kdWxlKCR0cmFjZXVyUnVudGltZS5ub3JtYWxpemVNb2R1bGVOYW1lKFwiLi90cmFjZXVyLmpzXCIsIFwidHJhY2V1ckAwLjAuMTExL3NyYy90cmFjZXVyLWltcG9ydC5qc1wiKSk7XG4gIFJlZmxlY3QuZ2xvYmFsLnRyYWNldXIgPSB0cmFjZXVyO1xuICAkdHJhY2V1clJ1bnRpbWUuTW9kdWxlU3RvcmUuc2V0KCd0cmFjZXVyQCcsIHRyYWNldXIpO1xuICByZXR1cm4ge307XG59KTtcbiR0cmFjZXVyUnVudGltZS5nZXRNb2R1bGUoXCJ0cmFjZXVyQDAuMC4xMTEvc3JjL3RyYWNldXItaW1wb3J0LmpzXCIgKyAnJyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZXVyLmpzLm1hcFxuXG5cbi8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cbm1vZHVsZS5leHBvcnRzID0gdHJhY2V1cjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/exports-loader/index.js?traceur!./node_modules/traceur/bin/traceur.js\n");

/***/ })

}]);